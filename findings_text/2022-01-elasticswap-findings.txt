# Handle  pauliax   # Vulnerability details  ## Impact Result of this.totalSupply() could be cached to avoid duplicate calls: ```solidity   require(this.totalSupply() > 0, "Exchange: INSUFFICIENT_LIQUIDITY");   ...   uint256 totalSupplyOfLiquidityTokens = this.totalSupply(); ```   
# Handle  pauliax   # Vulnerability details  ## Impact Using the unchecked keyword to avoid redundant arithmetic checks and save gas when an underflow/overflow cannot happen, e.g.: ```solidity     if (rootK > rootKLast) {         uint256 numerator =             _totalSupplyOfLiquidityTokens * (rootK - rootKLast); ``` rootK - rootKLast will never underflow here.   
# Handle  pauliax   # Vulnerability details  ## Impact Would be cheapier to have >= here when quoteTokenQtyToReturn = internalBalances.quoteTokenReserveQty to skip math operation: ```solidity     // We should ensure no possible overflow here.     if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {         internalBalances.quoteTokenReserveQty = 0;     } else {         internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;     } ```   
# Handle  pauliax   # Vulnerability details  ## Impact Conditions should be inclusive >= or <= : ```solidity   require(       baseTokenQty > _baseTokenQtyMin,       "MathLib: INSUFFICIENT_BASE_TOKEN_QTY"   );   require(       quoteTokenQty > _quoteTokenQtyMin,       "MathLib: INSUFFICIENT_QUOTE_TOKEN_QTY"   );   require(       _baseTokenQtyMin < maxBaseTokenQty,       "MathLib: INSUFFICIENT_DECAY"   );   require(       _quoteTokenQtyMin < maxQuoteTokenQty,       "MathLib: INSUFFICIENT_DECAY"   ); ```  Otherwise, these functions will fail when e.g. baseTokenQty = _baseTokenQtyMin when the end-user expects it to pass through.  
# Handle  wuwe1   # Vulnerability details  ## Proof of Concept redundant code  https://github.com/code-423n4/2022-01-elasticswap/blob/main/elasticswap/src/contracts/Exchange.sol#L266-L269  https://github.com/code-423n4/2022-01-elasticswap/blob/main/elasticswap/src/libraries/MathLib.sol#L663-L666  ## Tools Used  remove Exchange.sol#L266-L269  
# Handle  OriDabush   # Vulnerability details  ## Mathlib.sol (`calculateAddQuoteTokenLiquidityQuantities()`) In the `calculateAddQuoteTokenLiquidityQuantities()` function, the return line is unnecessary, because those variables are returned anyway (it will save gas if you'll remove the return line.)  ```sol return (quoteTokenQty, liquidityTokenQty); // remove this line to save gas ```  
# Handle  gzeon   # Vulnerability details  ## Impact `> 0` is less gas efficient than `!= 0` for uint in require condition when optimizer is enabled Ref: https://twitter.com/GalloDaSballo/status/1485430908165443590  ## Proof of Concept https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L176 ```         require(this.totalSupply() > 0, "Exchange: INSUFFICIENT_LIQUIDITY"); ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L27-L28  ```solidity MathLib.InternalBalances public internalBalances =     MathLib.InternalBalances(0, 0, 0); ```  Initialize `internalBalances` to the default state is redundant.  Change to `MathLib.InternalBalances public internalBalances;` can make the code simpler and save some gas.  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L217-L233  ```solidity   uint256 baseTokenQtyToRemoveFromInternalAccounting =       (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /           totalSupplyOfLiquidityTokens;    internalBalances       .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting;    // We should ensure no possible overflow here.   if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {       internalBalances.quoteTokenReserveQty = 0;   } else {       internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;   }    internalBalances.kLast =       internalBalances.baseTokenReserveQty *       internalBalances.quoteTokenReserveQty; ```  `internalBalances.baseTokenReserveQty` and `internalBalances.quoteTokenReserveQty` can be cached.  ### Recommendation  Change to:  ```solidity uint256 internalBaseTokenReserveQty = internalBalances.baseTokenReserveQty; uint256 baseTokenQtyToRemoveFromInternalAccounting =     (_liquidityTokenQty * internalBaseTokenReserveQty) /         totalSupplyOfLiquidityTokens;  internalBalances     .baseTokenReserveQty = internalBaseTokenReserveQty = internalBaseTokenReserveQty - baseTokenQtyToRemoveFromInternalAccounting;  // We should ensure no possible overflow here. uint256 internalQuoteTokenReserveQty = internalBalances.quoteTokenReserveQty; if (quoteTokenQtyToReturn > internalQuoteTokenReserveQty) {     internalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = 0; } else {     internalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = internalQuoteTokenReserveQty - quoteTokenQtyToReturn; }  internalBalances.kLast =     internalBaseTokenReserveQty *     internalQuoteTokenReserveQty; ```  
# Handle  WatchPug   # Vulnerability details  Outdated versions of OpenZeppelin library are used.  New versions of OpenZeppelin libraries can be more gas efficient.   For example:  `ERC20.sol` in @openzeppelin/contracts@4.1.0:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/token/ERC20/ERC20.sol#L152-L153  ```solidity require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance"); _approve(sender, _msgSender(), currentAllowance - amount); ```  A gas optimization upgrade has been added to @openzeppelin/contracts@4.4.2:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.4.2/contracts/token/ERC20/ERC20.sol#L158-L161 ```solidity require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance"); unchecked {     _approve(sender, _msgSender(), currentAllowance - amount); } ```  
# Handle  WatchPug   # Vulnerability details  Redundant code increase contract size and gas usage at deployment.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L227-L233  ```solidity function calculateAddQuoteTokenLiquidityQuantities(     uint256 _quoteTokenQtyDesired,     uint256 _quoteTokenQtyMin,     uint256 _baseTokenReserveQty,     uint256 _totalSupplyOfLiquidityTokens,     InternalBalances storage _internalBalances ) public returns (uint256 quoteTokenQty, uint256 liquidityTokenQty) { ```  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L282-L282  ```solidity return (quoteTokenQty, liquidityTokenQty); ```  L282, `return (quoteTokenQty, liquidityTokenQty)` is redundant.   
# Handle  WatchPug   # Vulnerability details  The check of `y > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `y <= 3`.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L82-L93  ```solidity function sqrt(uint256 y) internal pure returns (uint256 z) {     if (y > 3) {         z = y;         uint256 x = y / 2 + 1;         while (x < z) {             z = x;             x = (y / x + x) / 2;         }     } else if (y != 0) {         z = 1;     } } ```   ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  Or use:  https://github.com/Rari-Capital/solmate/blob/dd13c61b5f9cb5c539a7e356ba94a6c2979e9eb9/src/utils/FixedPointMathLib.sol#L150-L205   
# Handle  WatchPug   # Vulnerability details  In the current implementation, the amount of LP tokens to be minted when `addLiquidity()` is calculated based on the ratio between the amount of newly added `quoteToken` and the current wallet balance of `quoteToken` in the `Exchange` contract.  However, since anyone can transfer `quoteToken` to the contract, and make the balance of `quoteToken` to be larger than `_internalBalances.quoteTokenReserveQty`, existing liquidity providers can take advantage of this by donating `quoteToken` and make future liquidity providers receive fewer LP tokens than expected and lose funds.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L578-L582  ```solidity liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(     _totalSupplyOfLiquidityTokens,     quoteTokenQty,     _quoteTokenReserveQty // IERC20(quoteToken).balanceOf(address(this)) ); ```  ### PoC  Given:  - The `Exchange` pool is new;  1. Alice `addLiquidity()` with `1e18 baseToken` and `1e18 quoteToken`, recived `1e18` LP token; 2. Alice transfer `99e18 quoteToken` to the `Exchange` pool contract; 3. Bob `addLiquidity()` with `1e18 baseToken` and `1e18 quoteToken`; 3. Bob `removeLiquidity()` with all the LP token in balance.  **Expected Results**: Bob recived `1e18 baseToken` and >= `1e18 quoteToken`.  **Actual Results**: Bob recived ~`0.02e18 baseToken` and ~`1e18 quoteToken`.  Alice can now `removeLiquidity()` and recive ~`1.98e18 baseToken` and ~`100e18 quoteToken`.  As a result, Bob suffers a fund loss of `0.98e18 baseToken`.  ### Recommendation  Change to:  ```solidity liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(     _totalSupplyOfLiquidityTokens,     quoteTokenQty,     _internalBalances.quoteTokenReserveQty ); ```  
# Handle  WatchPug   # Vulnerability details  For the first minter of an Exchange pool, the ratio of `X/Y` and the `totalSupply` of the LP token can be manipulated.  A sophisticated attacker can mint and burn all of the LP tokens but `1 Wei`, and then artificially create a situation of rebasing up by transferring baseToken to the pool contract. Then `addLiquidity()` in `singleAssetEntry` mode.  Due to the special design of `singleAssetEntry` mode, the value of LP token can be inflated very quickly.  As a result, `1 Wei` of LP token can be worthing a significate amount of baseToken and quoteToken.  Combine this with the precision loss when calculating the amount of LP tokens to be minted to the new liquidity provider, the attacker can turn the pool into a trap which will take a certain amount of cut for all future liquidity providers by minting fewer LP tokens to them.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L493-L512  ```solidity } else {     // this user will set the initial pricing curve     require(         _baseTokenQtyDesired > 0,         "MathLib: INSUFFICIENT_BASE_QTY_DESIRED"     );     require(         _quoteTokenQtyDesired > 0,         "MathLib: INSUFFICIENT_QUOTE_QTY_DESIRED"     );      tokenQtys.baseTokenQty = _baseTokenQtyDesired;     tokenQtys.quoteTokenQty = _quoteTokenQtyDesired;     tokenQtys.liquidityTokenQty = sqrt(         _baseTokenQtyDesired * _quoteTokenQtyDesired     );      _internalBalances.baseTokenReserveQty += tokenQtys.baseTokenQty;     _internalBalances.quoteTokenReserveQty += tokenQtys.quoteTokenQty; } ```  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L204-L212  ```solidity function calculateLiquidityTokenQtyForDoubleAssetEntry(     uint256 _totalSupplyOfLiquidityTokens,     uint256 _quoteTokenQty,     uint256 _quoteTokenReserveBalance ) public pure returns (uint256 liquidityTokenQty) {     liquidityTokenQty =         (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /         _quoteTokenReserveBalance; } ```  ### PoC  Given:  - The `Pool` is newly created; - The market price of `baseToken` in terms of `quoteToken` is `1`.  The attacker can do the following steps in one tx:  1. `addLiquidity()` with `2 Wei of baseToken` and `100e18 quoteToken`, received `14142135623` LP tokens; 2. `removeLiquidity()` with `14142135622` LP tokens, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - baseTokenReserveQty: 1 Wei - quoteTokenReserveQty: 7071067813 Wei 3. `baseToken.transfer()` 7071067812 Wei to the Pool contract; 4. `addLiquidity()` with no baseToken and `50e18 quoteToken`; 5. `swapBaseTokenForQuoteToken()` with `600000000000000 baseToken`, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - quoteTokenReserveQty 591021750159032 - baseTokenReserveQty 600007071067801 6. `baseToken.transfer()` 999399992928932200 Wei to the Pool contract; 7. `addLiquidity()` with no baseToken and `1e18 quoteToken`, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - quoteTokenReserveQty: 1000000000000000013 - quoteTokenReserveQty: 985024641638342212 - baseTokenDecay: 0  From now on, `addLiquidity()` with less than `1e18` of `baseToken` and `quoteToken` will receive `0` LP token due to precision loss.  The amounts can be manipulated to higher numbers and cause most future liquidity providers to receive fewer LP tokens than expected, and the attacker will be able to profit from it as the attacker will take a larger share of the pool than expected.  ### Recommendation  Consider requiring a certain amount of minimal LP token amount (eg, 1e8) for the first minter and lock some of the first minter's LP tokens by minting ~1% of the initial amount to the factory address.  
# Handle  WatchPug   # Vulnerability details  ### Current Implementation  #### When `baseToken` rebase up  Per the document: https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/ElasticSwapMath.md#:~:text=When%20there%20is%20alphaDecay  and related code: https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L227-L283  `Gamma` is the ratio of shares received by the new liquidity provider when `addLiquidity()` (ΔRo) to the new totalSupply (total shares = Ro' = Ro + ΔRo).  ``` ΔRo = (Ro/(1 - γ)) * γ          Ro * Gamma     = --------------          1 - Gamma ⟺ ΔRo * ( 1 - Gamma ) = Gamma * Ro ΔRo - Gamma * ΔRo = Gamma * Ro ΔRo = Gamma * Ro + Gamma * ΔRo            ΔRo     Gamma = ---------          Ro + ΔRo  ```  In the current implementation:  ``` γ = ΔY / Y' / 2 * ( ΔX / α^ ) ```  ΔY is the `quoteToken` added by the new liquidity provider. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L277  Y' is the new Y after `addLiquidity()`, `Y' = Y + ΔY`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L272 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L278  ΔX is `ΔY * Omega`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L259-L263 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L279  α^ is `Alpha - X`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L234-L235 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L280   For instance:  Given: -   Original State: X = Alpha = 1, Y = Beta = 1, Omega = X/Y = 1 -   When `baseToken` rebase up: Alpha becomes 10 -   Current State: Alpha = 10, X = 1, Y = Beta = 1, Omega = 1   When: new liquidity provider `addLiquidity()` with 4 quoteToken:  ```              4          4 * Omega      16 Gamma = ------------ * ------------ = ----          (1+4) * 2       10 - 1        90 ``` After `addLiquidity()`:  -   baseToken belongs to the newLP: 10 * 16 / 90 = 160 / 90 = 1.7777777777777777 -   quoteToken belongs to the newLP: (1+4) * 16 / 90 = 80 / 90 = 0.8888888888888888 -   In the terms of `quoteToken`, the total value is: 160 / 90 / Omega + 80 / 90 = 240 / 90 = 2.6666666666666665   As a result, the new liquidity provider suffers a fund loss of `4 - 240 / 90 = 1.3333333333333333 in the terms of quoteToken`  The case above can be reproduced by changing the numbers in [this test unit](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/test/exchangeTest.js#L1804).   #### When `baseToken` rebase down   Per the document: https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/ElasticSwapMath.md#:~:text=When%20there%20is%20betaDecay  and related code: https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L297-L363  `Gamma` is the ratio of shares received by the new liquidity provider when `addLiquidity()` (ΔRo) to the new totalSupply (total shares = Ro' = Ro + ΔRo).   ``` ΔRo = (Ro/(1 - γ)) * γ          Ro * Gamma     = --------------          1 - Gamma ⟺ ΔRo * ( 1 - Gamma ) = Gamma * Ro ΔRo - Gamma * ΔRo = Gamma * Ro ΔRo = Gamma * Ro + Gamma * ΔRo            ΔRo     Gamma = ---------          Ro + ΔRo  ```  In the current implementation:  ``` γ = ΔX / X / 2 * ( ΔXByQuoteTokenAmount / β^ ) ```  ΔX is the amount of `baseToken` added by the new liquidity provider. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L357  X is the balanceOf `baseToken`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L358  ΔXByQuoteTokenAmount is ΔX / Omega, the value of ΔX in the terms of `quoteToken`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L318-L322 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L329-L333 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L359  β^ is maxΔX / Omega, the value of maxΔX in the terms of `quoteToken`. `maxΔX = X - Alpha`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L304-L305 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L318-L322 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L341-L342 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L360    For instance:  Given: -   Original State: X = Alpha = 10, Y = Beta = 10, Omega = X/Y = 1 -   When `baseToken` rebase down, Alpha becomes 1 -   Current State: Alpha = 1, X = 10, Y = Beta = 10, Omega = 1   When: new liquidity provider `addLiquidity()` with `4 baseToken` ```             4          4 / Omega       8 Gamma = -------- * ---------------- = ----           10 * 2    (10-1) / Omega     90 ``` After `addLiquidity()`: -   baseToken belongs to the newLP: (1 + 4) * 8 / 90 = 40 / 90 = 0.4444444444444444 -   quoteToken belongs to the newLP: 10 * 8 / 90 = 80 / 90 = 0.8888888888888888 -   In the terms of quoteToken, the total value is: 40 / 90 + 80 / 90 * Omega = 120 / 90 = 1.3333333333333333 < 4  As a result, the new liquidity provider suffers a fund loss of `4 - 120 / 90 = 2.6666666666666665 in the terms of quoteToken`  The case above can be reproduced by changing the numbers in [this test unit](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/test/exchangeTest.js#L2146).   ### The correct formula for ΔRo  #### When baseToken rebase up  ```md When: new liquidity provider addLiquidity with ΔY quoteToken (ΔY <= maxΔY or ΔY <= α^ / ω)  After addLiquidity(): -   baseToken belongs to the newLP: ΔXOfNewLP -   quoteToken belongs to the newLP: ΔYOfNewLP  ΔY can be divided into 2 parts: -   ΔYToX: the part used for swap ΔXOfNewLP.  ΔXOfNewLP = ΔYToX * Omega                  (a1) -   ΔY - ΔYToX: the rest as ΔYOfNewLP  The ratio of newly minted LP tokens for new liquidity provider to the new totalSupply (Ro'): Gamma              ΔRo       ΔY - ΔYToX     ΔXOfNewLP        = --------- = ----------- = -----------                                    (a2)          Ro + ΔRo     Y + ΔY          Alpha                       ΔY - ΔYToX     ΔYToX * Omega                      = ----------- = ---------------   // substituting (a1)             (a_exp1)                       Y + ΔY          Alpha          ⟺  (ΔY - ΔYToX) * Alpha = ΔYToX * Omega * (Y + ΔY) ΔY * Alpha - ΔYToX * Alpha = ΔYToX * Omega * (Y + ΔY) ΔY * Alpha = ΔYToX * Alpha + ΔYToX * Omega * (Y + ΔY)            = ΔYToX * ( Alpha + Omega * (Y + ΔY))                ΔY * Alpha                  ΔY * Alpha             ΔYToX = ---------------------------  = --------------------                       (a_r1)          Alpha + Omega * (Y + ΔY)       Alpha + Omega * Y'      Continue from (a_exp1):            ΔYToX * Omega  Gamma  = ---------------             Alpha                       ΔY * Omega        = -----------------------   // substituting (a_r1)                              (a_r2(1))            Alpha + Omega * Y'                   ΔY         = ---------------------                                                   (a_r2(2))             Alpha/Omega + Y'   Gamma is the ratio of ΔY to the total amounts of baseToken and quoteToken after addLiquidity: -   (a_r2(1)) is the formula in the terms of baseToken -   (a_r2(2)) is the formula in the terms of quoteToken    Based on (a2):             ΔRo     Gamma = ---------          Ro + ΔRo  ⟺ ΔRo = Gamma * Ro + Gamma * ΔRo ΔRo - Gamma * ΔRo = Gamma * Ro ΔRo * ( 1 - Gamma ) = Gamma * Ro         Ro * Gamma ΔRo = --------------          1 - Gamma  ```  #### When baseToken rebase down  ```md When: new liquidity provider addLiquidity with ΔX baseToken (ΔX <= maxΔX or ΔY <= α^)  After addLiquidity() -   baseToken belongs to the newLP: ΔXOfNewLP -   quoteToken belongs to the newLP: ΔYOfNewLP  ΔX can be divided into 2 parts: -   ΔXToY:  the part used for swap ΔYOfNewLP. ΔYOfNewLP = ΔXToY / Omega                 (b1) -   ΔX - ΔXToY: the rest as ΔXOfNewLP   The ratio of newly minted LP tokens for new liquidity provider to the new totalSupply (Ro'): Gamma            ΔRo        ΔX - ΔXToY     ΔYOfNewLP          = --------- = ------------ = ------------                                  (b2)         Ro + ΔRo     Alpha + ΔX         Y                                        ΔXToY / Omega                                = -------------    // substituting (b1)                                       Y                                       ΔXToY                                     = -------------                                   (b_exp1)                                    Y * Omega     ⟺  (ΔX - ΔXToY) * Y = (Alpha + ΔX) * ΔXToY / Omega ΔX * Y - ΔXToY * Y = (Alpha + ΔX) * ΔXToY / Omega ΔX * Y = ΔXToY * Y + (Alpha + ΔX) * ΔXToY / Omega        = ΔXToY * ( Y + (Alpha + ΔX) / Omega )                    ΔX * Y ΔXToY = --------------------------                                               (b_r1)          Y + (Alpha + ΔX) / Omega    Continue from (b_exp1)              ΔXToY     Gamma = -------------           Y * Omega                      ΔX * Y       = ----------------------------------------    // substituting (b_r1)          (Y + (Alpha + ΔX) / Omega) * Y * Omega                 ΔX / Omega       = ---------------------------                                               (b_r2(2))          Y + (Alpha + ΔX) / Omega                     ΔX       = ---------------------------                                               (b_r2(1))          Y * Omega + (Alpha + ΔX)                 ΔX       = -------------------  // substituting (Omega = X/Y)          X + (Alpha + ΔX)    Gamma is the ratio of ΔX to the total amounts of baseToken and quoteToken after addLiquidity: -   (b_r2(1)) is the formula in the terms of baseToken -   (b_r2(2)) is the formula in the terms of quoteToken   Based on (b2):             ΔRo     Gamma = ---------          Ro + ΔRo  ⟺         Ro * Gamma ΔRo = --------------          1 - Gamma  ```  ### Recommendation  Update code and document using the correct formula for ΔRo.  
# Handle  UncleGrandpa925   # Vulnerability details  ## Impact Saving gas-cost for all transactions interacting with the pools.   Currently the bytecode size of the Exchange is 10.99KB. Making the entire MathLib internal (therefore embedding it into the Exchange) will only make the bytecode size grows to 14.45KB, which is well below the limit of 24576 bytes. Doing this will save at least 2300 gas for every transaction since that the cost for cold-load the bytecode of the library, and also saving the gas cost of doing delegate call to the library instead of doing internal call.  ## Recommended Mitigation Steps Converting all public properties in the MathLib to internal.  ## Note  Normally I'm not into farming gas-optimization issues, but I think this is worth doing.   
# Handle  sirhashalot   # Vulnerability details  ## Impact  The Exchange.sol constructor has a natspec comment which is missing the _exchangeFactoryAddress function parameter. Issues with comments are low risk based on [Code4rena risk categories](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  [Exchange.sol line 62](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L58-L68) is missing a comment indicating the _exchangeFactoryAddress input parameter is required.  ## Recommended Mitigation Steps  Make sure natspec comments include all parameters and add one for the _exchangeFactoryAddress parameter.  
# Handle  camden   # Vulnerability details  ## Impact https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/src/contracts/ExchangeFactory.sol#L38  A user could create an exchange with a name and symbol that is misleading or allows phishing into an exchange created with an unexpected token.  ## Recommended Mitigation Steps Allow the ExchangeFactory to change the name and symbol of an exchange.  
# Handle  0x0x0x   # Vulnerability details  `removeLiquidity.sol#baseTokenQtyToRemoveFromInternalAccounting` is used only once and caching it does cost extra gas. So ```         uint256 baseTokenQtyToRemoveFromInternalAccounting =             (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /                 totalSupplyOfLiquidityTokens;          internalBalances             .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting; ``` can be replaced with ```          internalBalances.baseTokenReserveQty -= (_liquidityTokenQty * internalBalances.baseTokenReserveQty) / totalSupplyOfLiquidityTokens; ```  
# Handle  Ruhum   # Vulnerability details  ## Impact The `internalBalances` state variable is used extensively throughout the `Exchange` contract. Reading and writing to storage is expensive. Instead of working the state variable directly, the functions should work with a  cached memory variable. The final value should then be saved to storage.  ## Proof of Concept There are too many places where this is happening. Most prominently in the `MathLib` library, where the state variable is passed around as a function parameter. Working with a cached version will be way cheaper.   ## Tools Used  ## Recommended Mitigation Steps Replace the storage variable with a cached memory variable. The library has to be refactored to return the modified values so they can be written back to storage.  
# Handle  Dravee   # Vulnerability details  ## Impact Saving the gas cost from the calculation  ## Proof of Concept See the `@audit-info` tags: ``` File: MathLib.sol 141:     function calculateQtyToReturnAfterFees( 142:         uint256 _tokenASwapQty, 143:         uint256 _tokenAReserveQty, 144:         uint256 _tokenBReserveQty, 145:         uint256 _liquidityFeeInBasisPoints 146:     ) public pure returns (uint256 qtyToReturn) { 147:         uint256 tokenASwapQtyLessFee = //@audit-info == 0 if _tokenASwapQty == 0 148:             _tokenASwapQty * (BASIS_POINTS - _liquidityFeeInBasisPoints);  149:         qtyToReturn = 150:             (tokenASwapQtyLessFee * _tokenBReserveQty) / //@audit-info 0 is possible if _tokenBReserveQty == 0 or above is equal to 0 151:             ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee); 152:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Return 0 if `_tokenASwapQty == 0 || _tokenBReserveQty == 0` or the `&&` equivalent. Here's an example: ``` File: MathLib.sol 141:     function calculateQtyToReturnAfterFees( 142:         uint256 _tokenASwapQty, 143:         uint256 _tokenAReserveQty, 144:         uint256 _tokenBReserveQty, 145:         uint256 _liquidityFeeInBasisPoints 146:     ) public pure returns (uint256 qtyToReturn) { 147:         if(_tokenASwapQty != 0 && _tokenBReserveQty != 0){ 148:             uint256 tokenASwapQtyLessFee = _tokenASwapQty *  149:                 (BASIS_POINTS - _liquidityFeeInBasisPoints);  150:             qtyToReturn = (tokenASwapQtyLessFee * _tokenBReserveQty) /  151:                 ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee); 152:         } 153:     } ``` (here `qtyToReturn` if set to 0 by default so the value returned would be 0)  
# Handle  Dravee   # Vulnerability details  ## Impact  Some of the require statements can be placed earlier to reduce gas usage on revert.  ## Proof of Concept  The following can be reordered to save gas on revert:  ``` File: MathLib.sol 464:                 tokenQtys.baseTokenQty += baseTokenQtyFromDecay; 465:                 tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay; 466:                 tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay; 467:  468:                 require( 469:                     tokenQtys.baseTokenQty >= _baseTokenQtyMin, 470:                     "MathLib: INSUFFICIENT_BASE_QTY" 471:                 ); 472:  473:                 require( 474:                     tokenQtys.quoteTokenQty >= _quoteTokenQtyMin, 475:                     "MathLib: INSUFFICIENT_QUOTE_QTY" 476:                 ); ``` to ``` File: MathLib.sol 464:                 tokenQtys.baseTokenQty += baseTokenQtyFromDecay; 465:                  466:                 require( 467:                     tokenQtys.baseTokenQty >= _baseTokenQtyMin, 468:                     "MathLib: INSUFFICIENT_BASE_QTY" 469:                 ); 470:  471:                 tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay; 472:  473:                 require( 474:                     tokenQtys.quoteTokenQty >= _quoteTokenQtyMin, 475:                     "MathLib: INSUFFICIENT_QUOTE_QTY" 476:                 ); 477:  478:                 tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay; ```  ## Tools Used  VS Code   ## Recommended Mitigation Steps  Relocate the said require statements  
# Handle  Dravee   # Vulnerability details  ## Impact   It's possible to save gas by optimizing conditional flows to avoid some unnecessary opcodes    ## Proof of Concept   In `Exchange.sol:removeLiquidity()`, the code is as follows: ``` File: Exchange.sol 225:         if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) { 226:             internalBalances.quoteTokenReserveQty = 0; 227:         } else { 228:             internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn; 229:         } ```   However, this can be optimized :   - Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)   - In this case here, if `quoteTokenQtyToReturn == internalBalances.quoteTokenReserveQty`: `internalBalances.quoteTokenReserveQty = 0` should be used   - Avoiding the else clause would avoid some opcodes (1 SUB = 3 gas, 2 MLOADs = 6 gas...)      The code would become:   ``` File: Exchange.sol 225:         if (quoteTokenQtyToReturn >= internalBalances.quoteTokenReserveQty) { 226:             internalBalances.quoteTokenReserveQty = 0; 227:         } else { 228:             internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn; 229:         } ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the non-strict greater-than operator in this particular case   
# Handle  Dravee   # Vulnerability details  ## Impact Public functions that are never called by the contract should be declared external to save gas.  ## Proof of Concept Instances include: ``` File: ExchangeFactory.sol 81:     function feeAddress() public view virtual override returns (address) { 82:         return feeAddress_; 83:     } ```  ## Tools Used Slither  ## Recommended Mitigation Steps Change the visibility to `external`  
# Handle  pauliax   # Vulnerability details  ## Impact Result of this.totalSupply() could be cached to avoid duplicate calls: ```solidity   require(this.totalSupply() > 0, "Exchange: INSUFFICIENT_LIQUIDITY");   ...   uint256 totalSupplyOfLiquidityTokens = this.totalSupply(); ```   
# Handle  pauliax   # Vulnerability details  ## Impact Using the unchecked keyword to avoid redundant arithmetic checks and save gas when an underflow/overflow cannot happen, e.g.: ```solidity     if (rootK > rootKLast) {         uint256 numerator =             _totalSupplyOfLiquidityTokens * (rootK - rootKLast); ``` rootK - rootKLast will never underflow here.   
# Handle  pauliax   # Vulnerability details  ## Impact Would be cheapier to have >= here when quoteTokenQtyToReturn = internalBalances.quoteTokenReserveQty to skip math operation: ```solidity     // We should ensure no possible overflow here.     if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {         internalBalances.quoteTokenReserveQty = 0;     } else {         internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;     } ```   
# Handle  pauliax   # Vulnerability details  ## Impact Conditions should be inclusive >= or <= : ```solidity   require(       baseTokenQty > _baseTokenQtyMin,       "MathLib: INSUFFICIENT_BASE_TOKEN_QTY"   );   require(       quoteTokenQty > _quoteTokenQtyMin,       "MathLib: INSUFFICIENT_QUOTE_TOKEN_QTY"   );   require(       _baseTokenQtyMin < maxBaseTokenQty,       "MathLib: INSUFFICIENT_DECAY"   );   require(       _quoteTokenQtyMin < maxQuoteTokenQty,       "MathLib: INSUFFICIENT_DECAY"   ); ```  Otherwise, these functions will fail when e.g. baseTokenQty = _baseTokenQtyMin when the end-user expects it to pass through.  
# Handle  wuwe1   # Vulnerability details  ## Proof of Concept redundant code  https://github.com/code-423n4/2022-01-elasticswap/blob/main/elasticswap/src/contracts/Exchange.sol#L266-L269  https://github.com/code-423n4/2022-01-elasticswap/blob/main/elasticswap/src/libraries/MathLib.sol#L663-L666  ## Tools Used  remove Exchange.sol#L266-L269  
# Handle  OriDabush   # Vulnerability details  ## Mathlib.sol (`calculateAddQuoteTokenLiquidityQuantities()`) In the `calculateAddQuoteTokenLiquidityQuantities()` function, the return line is unnecessary, because those variables are returned anyway (it will save gas if you'll remove the return line.)  ```sol return (quoteTokenQty, liquidityTokenQty); // remove this line to save gas ```  
# Handle  gzeon   # Vulnerability details  ## Impact `> 0` is less gas efficient than `!= 0` for uint in require condition when optimizer is enabled Ref: https://twitter.com/GalloDaSballo/status/1485430908165443590  ## Proof of Concept https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L176 ```         require(this.totalSupply() > 0, "Exchange: INSUFFICIENT_LIQUIDITY"); ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L27-L28  ```solidity MathLib.InternalBalances public internalBalances =     MathLib.InternalBalances(0, 0, 0); ```  Initialize `internalBalances` to the default state is redundant.  Change to `MathLib.InternalBalances public internalBalances;` can make the code simpler and save some gas.  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L217-L233  ```solidity   uint256 baseTokenQtyToRemoveFromInternalAccounting =       (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /           totalSupplyOfLiquidityTokens;    internalBalances       .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting;    // We should ensure no possible overflow here.   if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {       internalBalances.quoteTokenReserveQty = 0;   } else {       internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;   }    internalBalances.kLast =       internalBalances.baseTokenReserveQty *       internalBalances.quoteTokenReserveQty; ```  `internalBalances.baseTokenReserveQty` and `internalBalances.quoteTokenReserveQty` can be cached.  ### Recommendation  Change to:  ```solidity uint256 internalBaseTokenReserveQty = internalBalances.baseTokenReserveQty; uint256 baseTokenQtyToRemoveFromInternalAccounting =     (_liquidityTokenQty * internalBaseTokenReserveQty) /         totalSupplyOfLiquidityTokens;  internalBalances     .baseTokenReserveQty = internalBaseTokenReserveQty = internalBaseTokenReserveQty - baseTokenQtyToRemoveFromInternalAccounting;  // We should ensure no possible overflow here. uint256 internalQuoteTokenReserveQty = internalBalances.quoteTokenReserveQty; if (quoteTokenQtyToReturn > internalQuoteTokenReserveQty) {     internalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = 0; } else {     internalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = internalQuoteTokenReserveQty - quoteTokenQtyToReturn; }  internalBalances.kLast =     internalBaseTokenReserveQty *     internalQuoteTokenReserveQty; ```  
# Handle  WatchPug   # Vulnerability details  Outdated versions of OpenZeppelin library are used.  New versions of OpenZeppelin libraries can be more gas efficient.   For example:  `ERC20.sol` in @openzeppelin/contracts@4.1.0:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/token/ERC20/ERC20.sol#L152-L153  ```solidity require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance"); _approve(sender, _msgSender(), currentAllowance - amount); ```  A gas optimization upgrade has been added to @openzeppelin/contracts@4.4.2:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.4.2/contracts/token/ERC20/ERC20.sol#L158-L161 ```solidity require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance"); unchecked {     _approve(sender, _msgSender(), currentAllowance - amount); } ```  
# Handle  WatchPug   # Vulnerability details  Redundant code increase contract size and gas usage at deployment.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L227-L233  ```solidity function calculateAddQuoteTokenLiquidityQuantities(     uint256 _quoteTokenQtyDesired,     uint256 _quoteTokenQtyMin,     uint256 _baseTokenReserveQty,     uint256 _totalSupplyOfLiquidityTokens,     InternalBalances storage _internalBalances ) public returns (uint256 quoteTokenQty, uint256 liquidityTokenQty) { ```  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L282-L282  ```solidity return (quoteTokenQty, liquidityTokenQty); ```  L282, `return (quoteTokenQty, liquidityTokenQty)` is redundant.   
# Handle  WatchPug   # Vulnerability details  The check of `y > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `y <= 3`.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L82-L93  ```solidity function sqrt(uint256 y) internal pure returns (uint256 z) {     if (y > 3) {         z = y;         uint256 x = y / 2 + 1;         while (x < z) {             z = x;             x = (y / x + x) / 2;         }     } else if (y != 0) {         z = 1;     } } ```   ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  Or use:  https://github.com/Rari-Capital/solmate/blob/dd13c61b5f9cb5c539a7e356ba94a6c2979e9eb9/src/utils/FixedPointMathLib.sol#L150-L205   
# Handle  WatchPug   # Vulnerability details  In the current implementation, the amount of LP tokens to be minted when `addLiquidity()` is calculated based on the ratio between the amount of newly added `quoteToken` and the current wallet balance of `quoteToken` in the `Exchange` contract.  However, since anyone can transfer `quoteToken` to the contract, and make the balance of `quoteToken` to be larger than `_internalBalances.quoteTokenReserveQty`, existing liquidity providers can take advantage of this by donating `quoteToken` and make future liquidity providers receive fewer LP tokens than expected and lose funds.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L578-L582  ```solidity liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(     _totalSupplyOfLiquidityTokens,     quoteTokenQty,     _quoteTokenReserveQty // IERC20(quoteToken).balanceOf(address(this)) ); ```  ### PoC  Given:  - The `Exchange` pool is new;  1. Alice `addLiquidity()` with `1e18 baseToken` and `1e18 quoteToken`, recived `1e18` LP token; 2. Alice transfer `99e18 quoteToken` to the `Exchange` pool contract; 3. Bob `addLiquidity()` with `1e18 baseToken` and `1e18 quoteToken`; 3. Bob `removeLiquidity()` with all the LP token in balance.  **Expected Results**: Bob recived `1e18 baseToken` and >= `1e18 quoteToken`.  **Actual Results**: Bob recived ~`0.02e18 baseToken` and ~`1e18 quoteToken`.  Alice can now `removeLiquidity()` and recive ~`1.98e18 baseToken` and ~`100e18 quoteToken`.  As a result, Bob suffers a fund loss of `0.98e18 baseToken`.  ### Recommendation  Change to:  ```solidity liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(     _totalSupplyOfLiquidityTokens,     quoteTokenQty,     _internalBalances.quoteTokenReserveQty ); ```  
# Handle  WatchPug   # Vulnerability details  For the first minter of an Exchange pool, the ratio of `X/Y` and the `totalSupply` of the LP token can be manipulated.  A sophisticated attacker can mint and burn all of the LP tokens but `1 Wei`, and then artificially create a situation of rebasing up by transferring baseToken to the pool contract. Then `addLiquidity()` in `singleAssetEntry` mode.  Due to the special design of `singleAssetEntry` mode, the value of LP token can be inflated very quickly.  As a result, `1 Wei` of LP token can be worthing a significate amount of baseToken and quoteToken.  Combine this with the precision loss when calculating the amount of LP tokens to be minted to the new liquidity provider, the attacker can turn the pool into a trap which will take a certain amount of cut for all future liquidity providers by minting fewer LP tokens to them.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L493-L512  ```solidity } else {     // this user will set the initial pricing curve     require(         _baseTokenQtyDesired > 0,         "MathLib: INSUFFICIENT_BASE_QTY_DESIRED"     );     require(         _quoteTokenQtyDesired > 0,         "MathLib: INSUFFICIENT_QUOTE_QTY_DESIRED"     );      tokenQtys.baseTokenQty = _baseTokenQtyDesired;     tokenQtys.quoteTokenQty = _quoteTokenQtyDesired;     tokenQtys.liquidityTokenQty = sqrt(         _baseTokenQtyDesired * _quoteTokenQtyDesired     );      _internalBalances.baseTokenReserveQty += tokenQtys.baseTokenQty;     _internalBalances.quoteTokenReserveQty += tokenQtys.quoteTokenQty; } ```  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L204-L212  ```solidity function calculateLiquidityTokenQtyForDoubleAssetEntry(     uint256 _totalSupplyOfLiquidityTokens,     uint256 _quoteTokenQty,     uint256 _quoteTokenReserveBalance ) public pure returns (uint256 liquidityTokenQty) {     liquidityTokenQty =         (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /         _quoteTokenReserveBalance; } ```  ### PoC  Given:  - The `Pool` is newly created; - The market price of `baseToken` in terms of `quoteToken` is `1`.  The attacker can do the following steps in one tx:  1. `addLiquidity()` with `2 Wei of baseToken` and `100e18 quoteToken`, received `14142135623` LP tokens; 2. `removeLiquidity()` with `14142135622` LP tokens, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - baseTokenReserveQty: 1 Wei - quoteTokenReserveQty: 7071067813 Wei 3. `baseToken.transfer()` 7071067812 Wei to the Pool contract; 4. `addLiquidity()` with no baseToken and `50e18 quoteToken`; 5. `swapBaseTokenForQuoteToken()` with `600000000000000 baseToken`, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - quoteTokenReserveQty 591021750159032 - baseTokenReserveQty 600007071067801 6. `baseToken.transfer()` 999399992928932200 Wei to the Pool contract; 7. `addLiquidity()` with no baseToken and `1e18 quoteToken`, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - quoteTokenReserveQty: 1000000000000000013 - quoteTokenReserveQty: 985024641638342212 - baseTokenDecay: 0  From now on, `addLiquidity()` with less than `1e18` of `baseToken` and `quoteToken` will receive `0` LP token due to precision loss.  The amounts can be manipulated to higher numbers and cause most future liquidity providers to receive fewer LP tokens than expected, and the attacker will be able to profit from it as the attacker will take a larger share of the pool than expected.  ### Recommendation  Consider requiring a certain amount of minimal LP token amount (eg, 1e8) for the first minter and lock some of the first minter's LP tokens by minting ~1% of the initial amount to the factory address.  
# Handle  WatchPug   # Vulnerability details  ### Current Implementation  #### When `baseToken` rebase up  Per the document: https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/ElasticSwapMath.md#:~:text=When%20there%20is%20alphaDecay  and related code: https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L227-L283  `Gamma` is the ratio of shares received by the new liquidity provider when `addLiquidity()` (ΔRo) to the new totalSupply (total shares = Ro' = Ro + ΔRo).  ``` ΔRo = (Ro/(1 - γ)) * γ          Ro * Gamma     = --------------          1 - Gamma ⟺ ΔRo * ( 1 - Gamma ) = Gamma * Ro ΔRo - Gamma * ΔRo = Gamma * Ro ΔRo = Gamma * Ro + Gamma * ΔRo            ΔRo     Gamma = ---------          Ro + ΔRo  ```  In the current implementation:  ``` γ = ΔY / Y' / 2 * ( ΔX / α^ ) ```  ΔY is the `quoteToken` added by the new liquidity provider. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L277  Y' is the new Y after `addLiquidity()`, `Y' = Y + ΔY`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L272 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L278  ΔX is `ΔY * Omega`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L259-L263 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L279  α^ is `Alpha - X`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L234-L235 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L280   For instance:  Given: -   Original State: X = Alpha = 1, Y = Beta = 1, Omega = X/Y = 1 -   When `baseToken` rebase up: Alpha becomes 10 -   Current State: Alpha = 10, X = 1, Y = Beta = 1, Omega = 1   When: new liquidity provider `addLiquidity()` with 4 quoteToken:  ```              4          4 * Omega      16 Gamma = ------------ * ------------ = ----          (1+4) * 2       10 - 1        90 ``` After `addLiquidity()`:  -   baseToken belongs to the newLP: 10 * 16 / 90 = 160 / 90 = 1.7777777777777777 -   quoteToken belongs to the newLP: (1+4) * 16 / 90 = 80 / 90 = 0.8888888888888888 -   In the terms of `quoteToken`, the total value is: 160 / 90 / Omega + 80 / 90 = 240 / 90 = 2.6666666666666665   As a result, the new liquidity provider suffers a fund loss of `4 - 240 / 90 = 1.3333333333333333 in the terms of quoteToken`  The case above can be reproduced by changing the numbers in [this test unit](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/test/exchangeTest.js#L1804).   #### When `baseToken` rebase down   Per the document: https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/ElasticSwapMath.md#:~:text=When%20there%20is%20betaDecay  and related code: https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L297-L363  `Gamma` is the ratio of shares received by the new liquidity provider when `addLiquidity()` (ΔRo) to the new totalSupply (total shares = Ro' = Ro + ΔRo).   ``` ΔRo = (Ro/(1 - γ)) * γ          Ro * Gamma     = --------------          1 - Gamma ⟺ ΔRo * ( 1 - Gamma ) = Gamma * Ro ΔRo - Gamma * ΔRo = Gamma * Ro ΔRo = Gamma * Ro + Gamma * ΔRo            ΔRo     Gamma = ---------          Ro + ΔRo  ```  In the current implementation:  ``` γ = ΔX / X / 2 * ( ΔXByQuoteTokenAmount / β^ ) ```  ΔX is the amount of `baseToken` added by the new liquidity provider. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L357  X is the balanceOf `baseToken`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L358  ΔXByQuoteTokenAmount is ΔX / Omega, the value of ΔX in the terms of `quoteToken`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L318-L322 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L329-L333 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L359  β^ is maxΔX / Omega, the value of maxΔX in the terms of `quoteToken`. `maxΔX = X - Alpha`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L304-L305 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L318-L322 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L341-L342 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L360    For instance:  Given: -   Original State: X = Alpha = 10, Y = Beta = 10, Omega = X/Y = 1 -   When `baseToken` rebase down, Alpha becomes 1 -   Current State: Alpha = 1, X = 10, Y = Beta = 10, Omega = 1   When: new liquidity provider `addLiquidity()` with `4 baseToken` ```             4          4 / Omega       8 Gamma = -------- * ---------------- = ----           10 * 2    (10-1) / Omega     90 ``` After `addLiquidity()`: -   baseToken belongs to the newLP: (1 + 4) * 8 / 90 = 40 / 90 = 0.4444444444444444 -   quoteToken belongs to the newLP: 10 * 8 / 90 = 80 / 90 = 0.8888888888888888 -   In the terms of quoteToken, the total value is: 40 / 90 + 80 / 90 * Omega = 120 / 90 = 1.3333333333333333 < 4  As a result, the new liquidity provider suffers a fund loss of `4 - 120 / 90 = 2.6666666666666665 in the terms of quoteToken`  The case above can be reproduced by changing the numbers in [this test unit](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/test/exchangeTest.js#L2146).   ### The correct formula for ΔRo  #### When baseToken rebase up  ```md When: new liquidity provider addLiquidity with ΔY quoteToken (ΔY <= maxΔY or ΔY <= α^ / ω)  After addLiquidity(): -   baseToken belongs to the newLP: ΔXOfNewLP -   quoteToken belongs to the newLP: ΔYOfNewLP  ΔY can be divided into 2 parts: -   ΔYToX: the part used for swap ΔXOfNewLP.  ΔXOfNewLP = ΔYToX * Omega                  (a1) -   ΔY - ΔYToX: the rest as ΔYOfNewLP  The ratio of newly minted LP tokens for new liquidity provider to the new totalSupply (Ro'): Gamma              ΔRo       ΔY - ΔYToX     ΔXOfNewLP        = --------- = ----------- = -----------                                    (a2)          Ro + ΔRo     Y + ΔY          Alpha                       ΔY - ΔYToX     ΔYToX * Omega                      = ----------- = ---------------   // substituting (a1)             (a_exp1)                       Y + ΔY          Alpha          ⟺  (ΔY - ΔYToX) * Alpha = ΔYToX * Omega * (Y + ΔY) ΔY * Alpha - ΔYToX * Alpha = ΔYToX * Omega * (Y + ΔY) ΔY * Alpha = ΔYToX * Alpha + ΔYToX * Omega * (Y + ΔY)            = ΔYToX * ( Alpha + Omega * (Y + ΔY))                ΔY * Alpha                  ΔY * Alpha             ΔYToX = ---------------------------  = --------------------                       (a_r1)          Alpha + Omega * (Y + ΔY)       Alpha + Omega * Y'      Continue from (a_exp1):            ΔYToX * Omega  Gamma  = ---------------             Alpha                       ΔY * Omega        = -----------------------   // substituting (a_r1)                              (a_r2(1))            Alpha + Omega * Y'                   ΔY         = ---------------------                                                   (a_r2(2))             Alpha/Omega + Y'   Gamma is the ratio of ΔY to the total amounts of baseToken and quoteToken after addLiquidity: -   (a_r2(1)) is the formula in the terms of baseToken -   (a_r2(2)) is the formula in the terms of quoteToken    Based on (a2):             ΔRo     Gamma = ---------          Ro + ΔRo  ⟺ ΔRo = Gamma * Ro + Gamma * ΔRo ΔRo - Gamma * ΔRo = Gamma * Ro ΔRo * ( 1 - Gamma ) = Gamma * Ro         Ro * Gamma ΔRo = --------------          1 - Gamma  ```  #### When baseToken rebase down  ```md When: new liquidity provider addLiquidity with ΔX baseToken (ΔX <= maxΔX or ΔY <= α^)  After addLiquidity() -   baseToken belongs to the newLP: ΔXOfNewLP -   quoteToken belongs to the newLP: ΔYOfNewLP  ΔX can be divided into 2 parts: -   ΔXToY:  the part used for swap ΔYOfNewLP. ΔYOfNewLP = ΔXToY / Omega                 (b1) -   ΔX - ΔXToY: the rest as ΔXOfNewLP   The ratio of newly minted LP tokens for new liquidity provider to the new totalSupply (Ro'): Gamma            ΔRo        ΔX - ΔXToY     ΔYOfNewLP          = --------- = ------------ = ------------                                  (b2)         Ro + ΔRo     Alpha + ΔX         Y                                        ΔXToY / Omega                                = -------------    // substituting (b1)                                       Y                                       ΔXToY                                     = -------------                                   (b_exp1)                                    Y * Omega     ⟺  (ΔX - ΔXToY) * Y = (Alpha + ΔX) * ΔXToY / Omega ΔX * Y - ΔXToY * Y = (Alpha + ΔX) * ΔXToY / Omega ΔX * Y = ΔXToY * Y + (Alpha + ΔX) * ΔXToY / Omega        = ΔXToY * ( Y + (Alpha + ΔX) / Omega )                    ΔX * Y ΔXToY = --------------------------                                               (b_r1)          Y + (Alpha + ΔX) / Omega    Continue from (b_exp1)              ΔXToY     Gamma = -------------           Y * Omega                      ΔX * Y       = ----------------------------------------    // substituting (b_r1)          (Y + (Alpha + ΔX) / Omega) * Y * Omega                 ΔX / Omega       = ---------------------------                                               (b_r2(2))          Y + (Alpha + ΔX) / Omega                     ΔX       = ---------------------------                                               (b_r2(1))          Y * Omega + (Alpha + ΔX)                 ΔX       = -------------------  // substituting (Omega = X/Y)          X + (Alpha + ΔX)    Gamma is the ratio of ΔX to the total amounts of baseToken and quoteToken after addLiquidity: -   (b_r2(1)) is the formula in the terms of baseToken -   (b_r2(2)) is the formula in the terms of quoteToken   Based on (b2):             ΔRo     Gamma = ---------          Ro + ΔRo  ⟺         Ro * Gamma ΔRo = --------------          1 - Gamma  ```  ### Recommendation  Update code and document using the correct formula for ΔRo.  
# Handle  UncleGrandpa925   # Vulnerability details  ## Impact Saving gas-cost for all transactions interacting with the pools.   Currently the bytecode size of the Exchange is 10.99KB. Making the entire MathLib internal (therefore embedding it into the Exchange) will only make the bytecode size grows to 14.45KB, which is well below the limit of 24576 bytes. Doing this will save at least 2300 gas for every transaction since that the cost for cold-load the bytecode of the library, and also saving the gas cost of doing delegate call to the library instead of doing internal call.  ## Recommended Mitigation Steps Converting all public properties in the MathLib to internal.  ## Note  Normally I'm not into farming gas-optimization issues, but I think this is worth doing.   
# Handle  sirhashalot   # Vulnerability details  ## Impact  The Exchange.sol constructor has a natspec comment which is missing the _exchangeFactoryAddress function parameter. Issues with comments are low risk based on [Code4rena risk categories](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  [Exchange.sol line 62](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L58-L68) is missing a comment indicating the _exchangeFactoryAddress input parameter is required.  ## Recommended Mitigation Steps  Make sure natspec comments include all parameters and add one for the _exchangeFactoryAddress parameter.  
# Handle  camden   # Vulnerability details  ## Impact https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/src/contracts/ExchangeFactory.sol#L38  A user could create an exchange with a name and symbol that is misleading or allows phishing into an exchange created with an unexpected token.  ## Recommended Mitigation Steps Allow the ExchangeFactory to change the name and symbol of an exchange.  
# Handle  0x0x0x   # Vulnerability details  `removeLiquidity.sol#baseTokenQtyToRemoveFromInternalAccounting` is used only once and caching it does cost extra gas. So ```         uint256 baseTokenQtyToRemoveFromInternalAccounting =             (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /                 totalSupplyOfLiquidityTokens;          internalBalances             .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting; ``` can be replaced with ```          internalBalances.baseTokenReserveQty -= (_liquidityTokenQty * internalBalances.baseTokenReserveQty) / totalSupplyOfLiquidityTokens; ```  
# Handle  Ruhum   # Vulnerability details  ## Impact The `internalBalances` state variable is used extensively throughout the `Exchange` contract. Reading and writing to storage is expensive. Instead of working the state variable directly, the functions should work with a  cached memory variable. The final value should then be saved to storage.  ## Proof of Concept There are too many places where this is happening. Most prominently in the `MathLib` library, where the state variable is passed around as a function parameter. Working with a cached version will be way cheaper.   ## Tools Used  ## Recommended Mitigation Steps Replace the storage variable with a cached memory variable. The library has to be refactored to return the modified values so they can be written back to storage.  
# Handle  Dravee   # Vulnerability details  ## Impact Saving the gas cost from the calculation  ## Proof of Concept See the `@audit-info` tags: ``` File: MathLib.sol 141:     function calculateQtyToReturnAfterFees( 142:         uint256 _tokenASwapQty, 143:         uint256 _tokenAReserveQty, 144:         uint256 _tokenBReserveQty, 145:         uint256 _liquidityFeeInBasisPoints 146:     ) public pure returns (uint256 qtyToReturn) { 147:         uint256 tokenASwapQtyLessFee = //@audit-info == 0 if _tokenASwapQty == 0 148:             _tokenASwapQty * (BASIS_POINTS - _liquidityFeeInBasisPoints);  149:         qtyToReturn = 150:             (tokenASwapQtyLessFee * _tokenBReserveQty) / //@audit-info 0 is possible if _tokenBReserveQty == 0 or above is equal to 0 151:             ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee); 152:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Return 0 if `_tokenASwapQty == 0 || _tokenBReserveQty == 0` or the `&&` equivalent. Here's an example: ``` File: MathLib.sol 141:     function calculateQtyToReturnAfterFees( 142:         uint256 _tokenASwapQty, 143:         uint256 _tokenAReserveQty, 144:         uint256 _tokenBReserveQty, 145:         uint256 _liquidityFeeInBasisPoints 146:     ) public pure returns (uint256 qtyToReturn) { 147:         if(_tokenASwapQty != 0 && _tokenBReserveQty != 0){ 148:             uint256 tokenASwapQtyLessFee = _tokenASwapQty *  149:                 (BASIS_POINTS - _liquidityFeeInBasisPoints);  150:             qtyToReturn = (tokenASwapQtyLessFee * _tokenBReserveQty) /  151:                 ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee); 152:         } 153:     } ``` (here `qtyToReturn` if set to 0 by default so the value returned would be 0)  
# Handle  Dravee   # Vulnerability details  ## Impact  Some of the require statements can be placed earlier to reduce gas usage on revert.  ## Proof of Concept  The following can be reordered to save gas on revert:  ``` File: MathLib.sol 464:                 tokenQtys.baseTokenQty += baseTokenQtyFromDecay; 465:                 tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay; 466:                 tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay; 467:  468:                 require( 469:                     tokenQtys.baseTokenQty >= _baseTokenQtyMin, 470:                     "MathLib: INSUFFICIENT_BASE_QTY" 471:                 ); 472:  473:                 require( 474:                     tokenQtys.quoteTokenQty >= _quoteTokenQtyMin, 475:                     "MathLib: INSUFFICIENT_QUOTE_QTY" 476:                 ); ``` to ``` File: MathLib.sol 464:                 tokenQtys.baseTokenQty += baseTokenQtyFromDecay; 465:                  466:                 require( 467:                     tokenQtys.baseTokenQty >= _baseTokenQtyMin, 468:                     "MathLib: INSUFFICIENT_BASE_QTY" 469:                 ); 470:  471:                 tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay; 472:  473:                 require( 474:                     tokenQtys.quoteTokenQty >= _quoteTokenQtyMin, 475:                     "MathLib: INSUFFICIENT_QUOTE_QTY" 476:                 ); 477:  478:                 tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay; ```  ## Tools Used  VS Code   ## Recommended Mitigation Steps  Relocate the said require statements  
# Handle  Dravee   # Vulnerability details  ## Impact   It's possible to save gas by optimizing conditional flows to avoid some unnecessary opcodes    ## Proof of Concept   In `Exchange.sol:removeLiquidity()`, the code is as follows: ``` File: Exchange.sol 225:         if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) { 226:             internalBalances.quoteTokenReserveQty = 0; 227:         } else { 228:             internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn; 229:         } ```   However, this can be optimized :   - Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)   - In this case here, if `quoteTokenQtyToReturn == internalBalances.quoteTokenReserveQty`: `internalBalances.quoteTokenReserveQty = 0` should be used   - Avoiding the else clause would avoid some opcodes (1 SUB = 3 gas, 2 MLOADs = 6 gas...)      The code would become:   ``` File: Exchange.sol 225:         if (quoteTokenQtyToReturn >= internalBalances.quoteTokenReserveQty) { 226:             internalBalances.quoteTokenReserveQty = 0; 227:         } else { 228:             internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn; 229:         } ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the non-strict greater-than operator in this particular case   
# Handle  Dravee   # Vulnerability details  ## Impact Public functions that are never called by the contract should be declared external to save gas.  ## Proof of Concept Instances include: ``` File: ExchangeFactory.sol 81:     function feeAddress() public view virtual override returns (address) { 82:         return feeAddress_; 83:     } ```  ## Tools Used Slither  ## Recommended Mitigation Steps Change the visibility to `external`  
# Handle  pauliax   # Vulnerability details  ## Impact Result of this.totalSupply() could be cached to avoid duplicate calls: ```solidity   require(this.totalSupply() > 0, "Exchange: INSUFFICIENT_LIQUIDITY");   ...   uint256 totalSupplyOfLiquidityTokens = this.totalSupply(); ```   
# Handle  pauliax   # Vulnerability details  ## Impact Using the unchecked keyword to avoid redundant arithmetic checks and save gas when an underflow/overflow cannot happen, e.g.: ```solidity     if (rootK > rootKLast) {         uint256 numerator =             _totalSupplyOfLiquidityTokens * (rootK - rootKLast); ``` rootK - rootKLast will never underflow here.   
# Handle  pauliax   # Vulnerability details  ## Impact Would be cheapier to have >= here when quoteTokenQtyToReturn = internalBalances.quoteTokenReserveQty to skip math operation: ```solidity     // We should ensure no possible overflow here.     if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {         internalBalances.quoteTokenReserveQty = 0;     } else {         internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;     } ```   
# Handle  pauliax   # Vulnerability details  ## Impact Conditions should be inclusive >= or <= : ```solidity   require(       baseTokenQty > _baseTokenQtyMin,       "MathLib: INSUFFICIENT_BASE_TOKEN_QTY"   );   require(       quoteTokenQty > _quoteTokenQtyMin,       "MathLib: INSUFFICIENT_QUOTE_TOKEN_QTY"   );   require(       _baseTokenQtyMin < maxBaseTokenQty,       "MathLib: INSUFFICIENT_DECAY"   );   require(       _quoteTokenQtyMin < maxQuoteTokenQty,       "MathLib: INSUFFICIENT_DECAY"   ); ```  Otherwise, these functions will fail when e.g. baseTokenQty = _baseTokenQtyMin when the end-user expects it to pass through.  
# Handle  wuwe1   # Vulnerability details  ## Proof of Concept redundant code  https://github.com/code-423n4/2022-01-elasticswap/blob/main/elasticswap/src/contracts/Exchange.sol#L266-L269  https://github.com/code-423n4/2022-01-elasticswap/blob/main/elasticswap/src/libraries/MathLib.sol#L663-L666  ## Tools Used  remove Exchange.sol#L266-L269  
# Handle  OriDabush   # Vulnerability details  ## Mathlib.sol (`calculateAddQuoteTokenLiquidityQuantities()`) In the `calculateAddQuoteTokenLiquidityQuantities()` function, the return line is unnecessary, because those variables are returned anyway (it will save gas if you'll remove the return line.)  ```sol return (quoteTokenQty, liquidityTokenQty); // remove this line to save gas ```  
# Handle  gzeon   # Vulnerability details  ## Impact `> 0` is less gas efficient than `!= 0` for uint in require condition when optimizer is enabled Ref: https://twitter.com/GalloDaSballo/status/1485430908165443590  ## Proof of Concept https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L176 ```         require(this.totalSupply() > 0, "Exchange: INSUFFICIENT_LIQUIDITY"); ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L27-L28  ```solidity MathLib.InternalBalances public internalBalances =     MathLib.InternalBalances(0, 0, 0); ```  Initialize `internalBalances` to the default state is redundant.  Change to `MathLib.InternalBalances public internalBalances;` can make the code simpler and save some gas.  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L217-L233  ```solidity   uint256 baseTokenQtyToRemoveFromInternalAccounting =       (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /           totalSupplyOfLiquidityTokens;    internalBalances       .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting;    // We should ensure no possible overflow here.   if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {       internalBalances.quoteTokenReserveQty = 0;   } else {       internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;   }    internalBalances.kLast =       internalBalances.baseTokenReserveQty *       internalBalances.quoteTokenReserveQty; ```  `internalBalances.baseTokenReserveQty` and `internalBalances.quoteTokenReserveQty` can be cached.  ### Recommendation  Change to:  ```solidity uint256 internalBaseTokenReserveQty = internalBalances.baseTokenReserveQty; uint256 baseTokenQtyToRemoveFromInternalAccounting =     (_liquidityTokenQty * internalBaseTokenReserveQty) /         totalSupplyOfLiquidityTokens;  internalBalances     .baseTokenReserveQty = internalBaseTokenReserveQty = internalBaseTokenReserveQty - baseTokenQtyToRemoveFromInternalAccounting;  // We should ensure no possible overflow here. uint256 internalQuoteTokenReserveQty = internalBalances.quoteTokenReserveQty; if (quoteTokenQtyToReturn > internalQuoteTokenReserveQty) {     internalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = 0; } else {     internalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = internalQuoteTokenReserveQty - quoteTokenQtyToReturn; }  internalBalances.kLast =     internalBaseTokenReserveQty *     internalQuoteTokenReserveQty; ```  
# Handle  WatchPug   # Vulnerability details  Outdated versions of OpenZeppelin library are used.  New versions of OpenZeppelin libraries can be more gas efficient.   For example:  `ERC20.sol` in @openzeppelin/contracts@4.1.0:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/token/ERC20/ERC20.sol#L152-L153  ```solidity require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance"); _approve(sender, _msgSender(), currentAllowance - amount); ```  A gas optimization upgrade has been added to @openzeppelin/contracts@4.4.2:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.4.2/contracts/token/ERC20/ERC20.sol#L158-L161 ```solidity require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance"); unchecked {     _approve(sender, _msgSender(), currentAllowance - amount); } ```  
# Handle  WatchPug   # Vulnerability details  Redundant code increase contract size and gas usage at deployment.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L227-L233  ```solidity function calculateAddQuoteTokenLiquidityQuantities(     uint256 _quoteTokenQtyDesired,     uint256 _quoteTokenQtyMin,     uint256 _baseTokenReserveQty,     uint256 _totalSupplyOfLiquidityTokens,     InternalBalances storage _internalBalances ) public returns (uint256 quoteTokenQty, uint256 liquidityTokenQty) { ```  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L282-L282  ```solidity return (quoteTokenQty, liquidityTokenQty); ```  L282, `return (quoteTokenQty, liquidityTokenQty)` is redundant.   
# Handle  WatchPug   # Vulnerability details  The check of `y > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `y <= 3`.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L82-L93  ```solidity function sqrt(uint256 y) internal pure returns (uint256 z) {     if (y > 3) {         z = y;         uint256 x = y / 2 + 1;         while (x < z) {             z = x;             x = (y / x + x) / 2;         }     } else if (y != 0) {         z = 1;     } } ```   ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  Or use:  https://github.com/Rari-Capital/solmate/blob/dd13c61b5f9cb5c539a7e356ba94a6c2979e9eb9/src/utils/FixedPointMathLib.sol#L150-L205   
# Handle  WatchPug   # Vulnerability details  In the current implementation, the amount of LP tokens to be minted when `addLiquidity()` is calculated based on the ratio between the amount of newly added `quoteToken` and the current wallet balance of `quoteToken` in the `Exchange` contract.  However, since anyone can transfer `quoteToken` to the contract, and make the balance of `quoteToken` to be larger than `_internalBalances.quoteTokenReserveQty`, existing liquidity providers can take advantage of this by donating `quoteToken` and make future liquidity providers receive fewer LP tokens than expected and lose funds.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L578-L582  ```solidity liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(     _totalSupplyOfLiquidityTokens,     quoteTokenQty,     _quoteTokenReserveQty // IERC20(quoteToken).balanceOf(address(this)) ); ```  ### PoC  Given:  - The `Exchange` pool is new;  1. Alice `addLiquidity()` with `1e18 baseToken` and `1e18 quoteToken`, recived `1e18` LP token; 2. Alice transfer `99e18 quoteToken` to the `Exchange` pool contract; 3. Bob `addLiquidity()` with `1e18 baseToken` and `1e18 quoteToken`; 3. Bob `removeLiquidity()` with all the LP token in balance.  **Expected Results**: Bob recived `1e18 baseToken` and >= `1e18 quoteToken`.  **Actual Results**: Bob recived ~`0.02e18 baseToken` and ~`1e18 quoteToken`.  Alice can now `removeLiquidity()` and recive ~`1.98e18 baseToken` and ~`100e18 quoteToken`.  As a result, Bob suffers a fund loss of `0.98e18 baseToken`.  ### Recommendation  Change to:  ```solidity liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(     _totalSupplyOfLiquidityTokens,     quoteTokenQty,     _internalBalances.quoteTokenReserveQty ); ```  
# Handle  WatchPug   # Vulnerability details  For the first minter of an Exchange pool, the ratio of `X/Y` and the `totalSupply` of the LP token can be manipulated.  A sophisticated attacker can mint and burn all of the LP tokens but `1 Wei`, and then artificially create a situation of rebasing up by transferring baseToken to the pool contract. Then `addLiquidity()` in `singleAssetEntry` mode.  Due to the special design of `singleAssetEntry` mode, the value of LP token can be inflated very quickly.  As a result, `1 Wei` of LP token can be worthing a significate amount of baseToken and quoteToken.  Combine this with the precision loss when calculating the amount of LP tokens to be minted to the new liquidity provider, the attacker can turn the pool into a trap which will take a certain amount of cut for all future liquidity providers by minting fewer LP tokens to them.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L493-L512  ```solidity } else {     // this user will set the initial pricing curve     require(         _baseTokenQtyDesired > 0,         "MathLib: INSUFFICIENT_BASE_QTY_DESIRED"     );     require(         _quoteTokenQtyDesired > 0,         "MathLib: INSUFFICIENT_QUOTE_QTY_DESIRED"     );      tokenQtys.baseTokenQty = _baseTokenQtyDesired;     tokenQtys.quoteTokenQty = _quoteTokenQtyDesired;     tokenQtys.liquidityTokenQty = sqrt(         _baseTokenQtyDesired * _quoteTokenQtyDesired     );      _internalBalances.baseTokenReserveQty += tokenQtys.baseTokenQty;     _internalBalances.quoteTokenReserveQty += tokenQtys.quoteTokenQty; } ```  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L204-L212  ```solidity function calculateLiquidityTokenQtyForDoubleAssetEntry(     uint256 _totalSupplyOfLiquidityTokens,     uint256 _quoteTokenQty,     uint256 _quoteTokenReserveBalance ) public pure returns (uint256 liquidityTokenQty) {     liquidityTokenQty =         (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /         _quoteTokenReserveBalance; } ```  ### PoC  Given:  - The `Pool` is newly created; - The market price of `baseToken` in terms of `quoteToken` is `1`.  The attacker can do the following steps in one tx:  1. `addLiquidity()` with `2 Wei of baseToken` and `100e18 quoteToken`, received `14142135623` LP tokens; 2. `removeLiquidity()` with `14142135622` LP tokens, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - baseTokenReserveQty: 1 Wei - quoteTokenReserveQty: 7071067813 Wei 3. `baseToken.transfer()` 7071067812 Wei to the Pool contract; 4. `addLiquidity()` with no baseToken and `50e18 quoteToken`; 5. `swapBaseTokenForQuoteToken()` with `600000000000000 baseToken`, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - quoteTokenReserveQty 591021750159032 - baseTokenReserveQty 600007071067801 6. `baseToken.transfer()` 999399992928932200 Wei to the Pool contract; 7. `addLiquidity()` with no baseToken and `1e18 quoteToken`, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - quoteTokenReserveQty: 1000000000000000013 - quoteTokenReserveQty: 985024641638342212 - baseTokenDecay: 0  From now on, `addLiquidity()` with less than `1e18` of `baseToken` and `quoteToken` will receive `0` LP token due to precision loss.  The amounts can be manipulated to higher numbers and cause most future liquidity providers to receive fewer LP tokens than expected, and the attacker will be able to profit from it as the attacker will take a larger share of the pool than expected.  ### Recommendation  Consider requiring a certain amount of minimal LP token amount (eg, 1e8) for the first minter and lock some of the first minter's LP tokens by minting ~1% of the initial amount to the factory address.  
# Handle  WatchPug   # Vulnerability details  ### Current Implementation  #### When `baseToken` rebase up  Per the document: https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/ElasticSwapMath.md#:~:text=When%20there%20is%20alphaDecay  and related code: https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L227-L283  `Gamma` is the ratio of shares received by the new liquidity provider when `addLiquidity()` (ΔRo) to the new totalSupply (total shares = Ro' = Ro + ΔRo).  ``` ΔRo = (Ro/(1 - γ)) * γ          Ro * Gamma     = --------------          1 - Gamma ⟺ ΔRo * ( 1 - Gamma ) = Gamma * Ro ΔRo - Gamma * ΔRo = Gamma * Ro ΔRo = Gamma * Ro + Gamma * ΔRo            ΔRo     Gamma = ---------          Ro + ΔRo  ```  In the current implementation:  ``` γ = ΔY / Y' / 2 * ( ΔX / α^ ) ```  ΔY is the `quoteToken` added by the new liquidity provider. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L277  Y' is the new Y after `addLiquidity()`, `Y' = Y + ΔY`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L272 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L278  ΔX is `ΔY * Omega`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L259-L263 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L279  α^ is `Alpha - X`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L234-L235 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L280   For instance:  Given: -   Original State: X = Alpha = 1, Y = Beta = 1, Omega = X/Y = 1 -   When `baseToken` rebase up: Alpha becomes 10 -   Current State: Alpha = 10, X = 1, Y = Beta = 1, Omega = 1   When: new liquidity provider `addLiquidity()` with 4 quoteToken:  ```              4          4 * Omega      16 Gamma = ------------ * ------------ = ----          (1+4) * 2       10 - 1        90 ``` After `addLiquidity()`:  -   baseToken belongs to the newLP: 10 * 16 / 90 = 160 / 90 = 1.7777777777777777 -   quoteToken belongs to the newLP: (1+4) * 16 / 90 = 80 / 90 = 0.8888888888888888 -   In the terms of `quoteToken`, the total value is: 160 / 90 / Omega + 80 / 90 = 240 / 90 = 2.6666666666666665   As a result, the new liquidity provider suffers a fund loss of `4 - 240 / 90 = 1.3333333333333333 in the terms of quoteToken`  The case above can be reproduced by changing the numbers in [this test unit](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/test/exchangeTest.js#L1804).   #### When `baseToken` rebase down   Per the document: https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/ElasticSwapMath.md#:~:text=When%20there%20is%20betaDecay  and related code: https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L297-L363  `Gamma` is the ratio of shares received by the new liquidity provider when `addLiquidity()` (ΔRo) to the new totalSupply (total shares = Ro' = Ro + ΔRo).   ``` ΔRo = (Ro/(1 - γ)) * γ          Ro * Gamma     = --------------          1 - Gamma ⟺ ΔRo * ( 1 - Gamma ) = Gamma * Ro ΔRo - Gamma * ΔRo = Gamma * Ro ΔRo = Gamma * Ro + Gamma * ΔRo            ΔRo     Gamma = ---------          Ro + ΔRo  ```  In the current implementation:  ``` γ = ΔX / X / 2 * ( ΔXByQuoteTokenAmount / β^ ) ```  ΔX is the amount of `baseToken` added by the new liquidity provider. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L357  X is the balanceOf `baseToken`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L358  ΔXByQuoteTokenAmount is ΔX / Omega, the value of ΔX in the terms of `quoteToken`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L318-L322 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L329-L333 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L359  β^ is maxΔX / Omega, the value of maxΔX in the terms of `quoteToken`. `maxΔX = X - Alpha`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L304-L305 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L318-L322 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L341-L342 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L360    For instance:  Given: -   Original State: X = Alpha = 10, Y = Beta = 10, Omega = X/Y = 1 -   When `baseToken` rebase down, Alpha becomes 1 -   Current State: Alpha = 1, X = 10, Y = Beta = 10, Omega = 1   When: new liquidity provider `addLiquidity()` with `4 baseToken` ```             4          4 / Omega       8 Gamma = -------- * ---------------- = ----           10 * 2    (10-1) / Omega     90 ``` After `addLiquidity()`: -   baseToken belongs to the newLP: (1 + 4) * 8 / 90 = 40 / 90 = 0.4444444444444444 -   quoteToken belongs to the newLP: 10 * 8 / 90 = 80 / 90 = 0.8888888888888888 -   In the terms of quoteToken, the total value is: 40 / 90 + 80 / 90 * Omega = 120 / 90 = 1.3333333333333333 < 4  As a result, the new liquidity provider suffers a fund loss of `4 - 120 / 90 = 2.6666666666666665 in the terms of quoteToken`  The case above can be reproduced by changing the numbers in [this test unit](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/test/exchangeTest.js#L2146).   ### The correct formula for ΔRo  #### When baseToken rebase up  ```md When: new liquidity provider addLiquidity with ΔY quoteToken (ΔY <= maxΔY or ΔY <= α^ / ω)  After addLiquidity(): -   baseToken belongs to the newLP: ΔXOfNewLP -   quoteToken belongs to the newLP: ΔYOfNewLP  ΔY can be divided into 2 parts: -   ΔYToX: the part used for swap ΔXOfNewLP.  ΔXOfNewLP = ΔYToX * Omega                  (a1) -   ΔY - ΔYToX: the rest as ΔYOfNewLP  The ratio of newly minted LP tokens for new liquidity provider to the new totalSupply (Ro'): Gamma              ΔRo       ΔY - ΔYToX     ΔXOfNewLP        = --------- = ----------- = -----------                                    (a2)          Ro + ΔRo     Y + ΔY          Alpha                       ΔY - ΔYToX     ΔYToX * Omega                      = ----------- = ---------------   // substituting (a1)             (a_exp1)                       Y + ΔY          Alpha          ⟺  (ΔY - ΔYToX) * Alpha = ΔYToX * Omega * (Y + ΔY) ΔY * Alpha - ΔYToX * Alpha = ΔYToX * Omega * (Y + ΔY) ΔY * Alpha = ΔYToX * Alpha + ΔYToX * Omega * (Y + ΔY)            = ΔYToX * ( Alpha + Omega * (Y + ΔY))                ΔY * Alpha                  ΔY * Alpha             ΔYToX = ---------------------------  = --------------------                       (a_r1)          Alpha + Omega * (Y + ΔY)       Alpha + Omega * Y'      Continue from (a_exp1):            ΔYToX * Omega  Gamma  = ---------------             Alpha                       ΔY * Omega        = -----------------------   // substituting (a_r1)                              (a_r2(1))            Alpha + Omega * Y'                   ΔY         = ---------------------                                                   (a_r2(2))             Alpha/Omega + Y'   Gamma is the ratio of ΔY to the total amounts of baseToken and quoteToken after addLiquidity: -   (a_r2(1)) is the formula in the terms of baseToken -   (a_r2(2)) is the formula in the terms of quoteToken    Based on (a2):             ΔRo     Gamma = ---------          Ro + ΔRo  ⟺ ΔRo = Gamma * Ro + Gamma * ΔRo ΔRo - Gamma * ΔRo = Gamma * Ro ΔRo * ( 1 - Gamma ) = Gamma * Ro         Ro * Gamma ΔRo = --------------          1 - Gamma  ```  #### When baseToken rebase down  ```md When: new liquidity provider addLiquidity with ΔX baseToken (ΔX <= maxΔX or ΔY <= α^)  After addLiquidity() -   baseToken belongs to the newLP: ΔXOfNewLP -   quoteToken belongs to the newLP: ΔYOfNewLP  ΔX can be divided into 2 parts: -   ΔXToY:  the part used for swap ΔYOfNewLP. ΔYOfNewLP = ΔXToY / Omega                 (b1) -   ΔX - ΔXToY: the rest as ΔXOfNewLP   The ratio of newly minted LP tokens for new liquidity provider to the new totalSupply (Ro'): Gamma            ΔRo        ΔX - ΔXToY     ΔYOfNewLP          = --------- = ------------ = ------------                                  (b2)         Ro + ΔRo     Alpha + ΔX         Y                                        ΔXToY / Omega                                = -------------    // substituting (b1)                                       Y                                       ΔXToY                                     = -------------                                   (b_exp1)                                    Y * Omega     ⟺  (ΔX - ΔXToY) * Y = (Alpha + ΔX) * ΔXToY / Omega ΔX * Y - ΔXToY * Y = (Alpha + ΔX) * ΔXToY / Omega ΔX * Y = ΔXToY * Y + (Alpha + ΔX) * ΔXToY / Omega        = ΔXToY * ( Y + (Alpha + ΔX) / Omega )                    ΔX * Y ΔXToY = --------------------------                                               (b_r1)          Y + (Alpha + ΔX) / Omega    Continue from (b_exp1)              ΔXToY     Gamma = -------------           Y * Omega                      ΔX * Y       = ----------------------------------------    // substituting (b_r1)          (Y + (Alpha + ΔX) / Omega) * Y * Omega                 ΔX / Omega       = ---------------------------                                               (b_r2(2))          Y + (Alpha + ΔX) / Omega                     ΔX       = ---------------------------                                               (b_r2(1))          Y * Omega + (Alpha + ΔX)                 ΔX       = -------------------  // substituting (Omega = X/Y)          X + (Alpha + ΔX)    Gamma is the ratio of ΔX to the total amounts of baseToken and quoteToken after addLiquidity: -   (b_r2(1)) is the formula in the terms of baseToken -   (b_r2(2)) is the formula in the terms of quoteToken   Based on (b2):             ΔRo     Gamma = ---------          Ro + ΔRo  ⟺         Ro * Gamma ΔRo = --------------          1 - Gamma  ```  ### Recommendation  Update code and document using the correct formula for ΔRo.  
# Handle  UncleGrandpa925   # Vulnerability details  ## Impact Saving gas-cost for all transactions interacting with the pools.   Currently the bytecode size of the Exchange is 10.99KB. Making the entire MathLib internal (therefore embedding it into the Exchange) will only make the bytecode size grows to 14.45KB, which is well below the limit of 24576 bytes. Doing this will save at least 2300 gas for every transaction since that the cost for cold-load the bytecode of the library, and also saving the gas cost of doing delegate call to the library instead of doing internal call.  ## Recommended Mitigation Steps Converting all public properties in the MathLib to internal.  ## Note  Normally I'm not into farming gas-optimization issues, but I think this is worth doing.   
# Handle  sirhashalot   # Vulnerability details  ## Impact  The Exchange.sol constructor has a natspec comment which is missing the _exchangeFactoryAddress function parameter. Issues with comments are low risk based on [Code4rena risk categories](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  [Exchange.sol line 62](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L58-L68) is missing a comment indicating the _exchangeFactoryAddress input parameter is required.  ## Recommended Mitigation Steps  Make sure natspec comments include all parameters and add one for the _exchangeFactoryAddress parameter.  
# Handle  camden   # Vulnerability details  ## Impact https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/src/contracts/ExchangeFactory.sol#L38  A user could create an exchange with a name and symbol that is misleading or allows phishing into an exchange created with an unexpected token.  ## Recommended Mitigation Steps Allow the ExchangeFactory to change the name and symbol of an exchange.  
# Handle  0x0x0x   # Vulnerability details  `removeLiquidity.sol#baseTokenQtyToRemoveFromInternalAccounting` is used only once and caching it does cost extra gas. So ```         uint256 baseTokenQtyToRemoveFromInternalAccounting =             (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /                 totalSupplyOfLiquidityTokens;          internalBalances             .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting; ``` can be replaced with ```          internalBalances.baseTokenReserveQty -= (_liquidityTokenQty * internalBalances.baseTokenReserveQty) / totalSupplyOfLiquidityTokens; ```  
# Handle  Ruhum   # Vulnerability details  ## Impact The `internalBalances` state variable is used extensively throughout the `Exchange` contract. Reading and writing to storage is expensive. Instead of working the state variable directly, the functions should work with a  cached memory variable. The final value should then be saved to storage.  ## Proof of Concept There are too many places where this is happening. Most prominently in the `MathLib` library, where the state variable is passed around as a function parameter. Working with a cached version will be way cheaper.   ## Tools Used  ## Recommended Mitigation Steps Replace the storage variable with a cached memory variable. The library has to be refactored to return the modified values so they can be written back to storage.  
# Handle  Dravee   # Vulnerability details  ## Impact Saving the gas cost from the calculation  ## Proof of Concept See the `@audit-info` tags: ``` File: MathLib.sol 141:     function calculateQtyToReturnAfterFees( 142:         uint256 _tokenASwapQty, 143:         uint256 _tokenAReserveQty, 144:         uint256 _tokenBReserveQty, 145:         uint256 _liquidityFeeInBasisPoints 146:     ) public pure returns (uint256 qtyToReturn) { 147:         uint256 tokenASwapQtyLessFee = //@audit-info == 0 if _tokenASwapQty == 0 148:             _tokenASwapQty * (BASIS_POINTS - _liquidityFeeInBasisPoints);  149:         qtyToReturn = 150:             (tokenASwapQtyLessFee * _tokenBReserveQty) / //@audit-info 0 is possible if _tokenBReserveQty == 0 or above is equal to 0 151:             ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee); 152:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Return 0 if `_tokenASwapQty == 0 || _tokenBReserveQty == 0` or the `&&` equivalent. Here's an example: ``` File: MathLib.sol 141:     function calculateQtyToReturnAfterFees( 142:         uint256 _tokenASwapQty, 143:         uint256 _tokenAReserveQty, 144:         uint256 _tokenBReserveQty, 145:         uint256 _liquidityFeeInBasisPoints 146:     ) public pure returns (uint256 qtyToReturn) { 147:         if(_tokenASwapQty != 0 && _tokenBReserveQty != 0){ 148:             uint256 tokenASwapQtyLessFee = _tokenASwapQty *  149:                 (BASIS_POINTS - _liquidityFeeInBasisPoints);  150:             qtyToReturn = (tokenASwapQtyLessFee * _tokenBReserveQty) /  151:                 ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee); 152:         } 153:     } ``` (here `qtyToReturn` if set to 0 by default so the value returned would be 0)  
# Handle  Dravee   # Vulnerability details  ## Impact  Some of the require statements can be placed earlier to reduce gas usage on revert.  ## Proof of Concept  The following can be reordered to save gas on revert:  ``` File: MathLib.sol 464:                 tokenQtys.baseTokenQty += baseTokenQtyFromDecay; 465:                 tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay; 466:                 tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay; 467:  468:                 require( 469:                     tokenQtys.baseTokenQty >= _baseTokenQtyMin, 470:                     "MathLib: INSUFFICIENT_BASE_QTY" 471:                 ); 472:  473:                 require( 474:                     tokenQtys.quoteTokenQty >= _quoteTokenQtyMin, 475:                     "MathLib: INSUFFICIENT_QUOTE_QTY" 476:                 ); ``` to ``` File: MathLib.sol 464:                 tokenQtys.baseTokenQty += baseTokenQtyFromDecay; 465:                  466:                 require( 467:                     tokenQtys.baseTokenQty >= _baseTokenQtyMin, 468:                     "MathLib: INSUFFICIENT_BASE_QTY" 469:                 ); 470:  471:                 tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay; 472:  473:                 require( 474:                     tokenQtys.quoteTokenQty >= _quoteTokenQtyMin, 475:                     "MathLib: INSUFFICIENT_QUOTE_QTY" 476:                 ); 477:  478:                 tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay; ```  ## Tools Used  VS Code   ## Recommended Mitigation Steps  Relocate the said require statements  
# Handle  Dravee   # Vulnerability details  ## Impact   It's possible to save gas by optimizing conditional flows to avoid some unnecessary opcodes    ## Proof of Concept   In `Exchange.sol:removeLiquidity()`, the code is as follows: ``` File: Exchange.sol 225:         if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) { 226:             internalBalances.quoteTokenReserveQty = 0; 227:         } else { 228:             internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn; 229:         } ```   However, this can be optimized :   - Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)   - In this case here, if `quoteTokenQtyToReturn == internalBalances.quoteTokenReserveQty`: `internalBalances.quoteTokenReserveQty = 0` should be used   - Avoiding the else clause would avoid some opcodes (1 SUB = 3 gas, 2 MLOADs = 6 gas...)      The code would become:   ``` File: Exchange.sol 225:         if (quoteTokenQtyToReturn >= internalBalances.quoteTokenReserveQty) { 226:             internalBalances.quoteTokenReserveQty = 0; 227:         } else { 228:             internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn; 229:         } ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the non-strict greater-than operator in this particular case   
# Handle  Dravee   # Vulnerability details  ## Impact Public functions that are never called by the contract should be declared external to save gas.  ## Proof of Concept Instances include: ``` File: ExchangeFactory.sol 81:     function feeAddress() public view virtual override returns (address) { 82:         return feeAddress_; 83:     } ```  ## Tools Used Slither  ## Recommended Mitigation Steps Change the visibility to `external`  
