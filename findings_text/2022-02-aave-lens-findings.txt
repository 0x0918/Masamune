# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/LensHub.sol#L929   # Vulnerability details  All the external function of LensHub have whenNotPasued modifier. However, LensHub is erc721 and the transfer function doesn't have the whenNotPaused modifier.  ## Impact In case where the governance wants to stop all activity, they still can't stop transferring profiles nfts. an example where stopping transferring tokens was actually very helpful: [https://mobile.twitter.com/flashfish0x/status/1466369783016869892](https://mobile.twitter.com/flashfish0x/status/1466369783016869892)   ## Recommended Mitigation Steps add whenNotPasued to `_beforeTokenTransfer`  
# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/libraries/InteractionLogic.sol#L49   # Vulnerability details  When someone tries to follow a profile, it checks if the handle exists, and if it doesn't, it reverts because the profile is deleted. The problem is that there might be a new profile with the same handle as the deleted one, allowing following deleted profiles.   ## Proof of Concept Alice creates a profile with the handle "alice." The profile id is 1. she deleted the profile. she opens a new profile with the handle "alice". The new profile id is 2. bob tries to follow the deleted profile (id is 1). the check ``` if (_profileIdByHandleHash[keccak256(bytes(handle))] == 0)  revert Errors.TokenDoesNotExist(); ``` doesn't revert because there exists a profile with the handle "alice". Therefore bob followed a deleted profile when he meant to follow the new profile.   ## Recommended Mitigation Steps  change to: ``` if (_profileIdByHandleHash[keccak256(bytes(handle))] != profileIds[i])  revert Errors.TokenDoesNotExist(); ```   
# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L176   # Vulnerability details  ## Impact  Treasury fee can be zero, while collect modules do attempt to send it in such a case anyway as there is no check in place. Some ERC20 tokens do not allow zero value transfers, reverting such attempts.  This way, a combination of zero treasury fee and such a token set as a collect fee currency will revert any collect operations, rendering collect functionality unavailable  ## Proof of Concept  Treasury fee can be set to zero:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/ModuleGlobals.sol#L109  Treasury fee transfer attempts are now done uncoditionally in all the collect modules.  Namely, FeeCollectModule, LimitedFeeCollectModule, TimedFeeCollectModule and LimitedTimedFeeCollectModule do not check the treasury fee to be send, `treasuryAmount`, before transferring:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L176  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedFeeCollectModule.sol#L194  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/TimedFeeCollectModule.sol#L190  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedTimedFeeCollectModule.sol#L205  The same happens in the FeeFollowModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/follow/FeeFollowModule.sol#L90  ## References  Some ERC20 tokens revert on zero value transfers:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  ## Recommended Mitigation Steps  Consider checking the treasury fee amount and do transfer only when it is positive.  Now: ``` IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount); ```  To be: ``` if (treasuryAmount > 0)  IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount); ```   
# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L72   # Vulnerability details  ## Impact  Base fee modules require minimum fixed fee amount to be at least BPS_MAX, which is hard coded to be 10000.  This turns out to be a functionality restricting requirement for some currencies.  For example, WBTC (https://etherscan.io/token/0x2260fac5e5542a773aa44fbcfedf7c193bc2c599, #10 in ERC20 token rankings), has decimals of 8 and current market rate around $40k, i.e. if you want to use any WBTC based collect fee, it has to be at least $4 per collect or fee enabled follow.  Tether and USDC (https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7 and https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48, #1 and #3) have decimals of 6, so it is at least $0.01 per collect/follow, which also looks a bit tight for a hard floor minimum.  ## Proof of Concept  BPS_MAX is a system wide constant, now 10000:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/FeeModuleBase.sol#L17  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/ModuleGlobals.sol#L20  This is correct for any fees defined in basis point terms.  When it comes to the nominal amount, 10000 can be too loose or too tight depending on a currency used, as there can be various combinations of decimals and market rates.   The following base collect module implementations require fee amount to be at least BPS_MAX (initialization reverts when amount < BPS_MAX):  All collect module implementations use the same check:  FeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L72  LimitedFeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedFeeCollectModule.sol#L79  TimedFeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/TimedFeeCollectModule.sol#L81  LimitedTimedFeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedTimedFeeCollectModule.sol#L86   FeeFollowModule also uses the same approach:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/follow/FeeFollowModule.sol#L62  ## Recommended Mitigation Steps  As a simplest solution consider adding a separate constant for minimum fee amount in nominal terms, say 1 or 10   
# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/LensHub.sol#L929   # Vulnerability details  All the external function of LensHub have whenNotPasued modifier. However, LensHub is erc721 and the transfer function doesn't have the whenNotPaused modifier.  ## Impact In case where the governance wants to stop all activity, they still can't stop transferring profiles nfts. an example where stopping transferring tokens was actually very helpful: [https://mobile.twitter.com/flashfish0x/status/1466369783016869892](https://mobile.twitter.com/flashfish0x/status/1466369783016869892)   ## Recommended Mitigation Steps add whenNotPasued to `_beforeTokenTransfer`  
# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/libraries/InteractionLogic.sol#L49   # Vulnerability details  When someone tries to follow a profile, it checks if the handle exists, and if it doesn't, it reverts because the profile is deleted. The problem is that there might be a new profile with the same handle as the deleted one, allowing following deleted profiles.   ## Proof of Concept Alice creates a profile with the handle "alice." The profile id is 1. she deleted the profile. she opens a new profile with the handle "alice". The new profile id is 2. bob tries to follow the deleted profile (id is 1). the check ``` if (_profileIdByHandleHash[keccak256(bytes(handle))] == 0)  revert Errors.TokenDoesNotExist(); ``` doesn't revert because there exists a profile with the handle "alice". Therefore bob followed a deleted profile when he meant to follow the new profile.   ## Recommended Mitigation Steps  change to: ``` if (_profileIdByHandleHash[keccak256(bytes(handle))] != profileIds[i])  revert Errors.TokenDoesNotExist(); ```   
# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L176   # Vulnerability details  ## Impact  Treasury fee can be zero, while collect modules do attempt to send it in such a case anyway as there is no check in place. Some ERC20 tokens do not allow zero value transfers, reverting such attempts.  This way, a combination of zero treasury fee and such a token set as a collect fee currency will revert any collect operations, rendering collect functionality unavailable  ## Proof of Concept  Treasury fee can be set to zero:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/ModuleGlobals.sol#L109  Treasury fee transfer attempts are now done uncoditionally in all the collect modules.  Namely, FeeCollectModule, LimitedFeeCollectModule, TimedFeeCollectModule and LimitedTimedFeeCollectModule do not check the treasury fee to be send, `treasuryAmount`, before transferring:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L176  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedFeeCollectModule.sol#L194  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/TimedFeeCollectModule.sol#L190  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedTimedFeeCollectModule.sol#L205  The same happens in the FeeFollowModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/follow/FeeFollowModule.sol#L90  ## References  Some ERC20 tokens revert on zero value transfers:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  ## Recommended Mitigation Steps  Consider checking the treasury fee amount and do transfer only when it is positive.  Now: ``` IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount); ```  To be: ``` if (treasuryAmount > 0)  IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount); ```   
# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L72   # Vulnerability details  ## Impact  Base fee modules require minimum fixed fee amount to be at least BPS_MAX, which is hard coded to be 10000.  This turns out to be a functionality restricting requirement for some currencies.  For example, WBTC (https://etherscan.io/token/0x2260fac5e5542a773aa44fbcfedf7c193bc2c599, #10 in ERC20 token rankings), has decimals of 8 and current market rate around $40k, i.e. if you want to use any WBTC based collect fee, it has to be at least $4 per collect or fee enabled follow.  Tether and USDC (https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7 and https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48, #1 and #3) have decimals of 6, so it is at least $0.01 per collect/follow, which also looks a bit tight for a hard floor minimum.  ## Proof of Concept  BPS_MAX is a system wide constant, now 10000:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/FeeModuleBase.sol#L17  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/ModuleGlobals.sol#L20  This is correct for any fees defined in basis point terms.  When it comes to the nominal amount, 10000 can be too loose or too tight depending on a currency used, as there can be various combinations of decimals and market rates.   The following base collect module implementations require fee amount to be at least BPS_MAX (initialization reverts when amount < BPS_MAX):  All collect module implementations use the same check:  FeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L72  LimitedFeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedFeeCollectModule.sol#L79  TimedFeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/TimedFeeCollectModule.sol#L81  LimitedTimedFeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedTimedFeeCollectModule.sol#L86   FeeFollowModule also uses the same approach:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/follow/FeeFollowModule.sol#L62  ## Recommended Mitigation Steps  As a simplest solution consider adding a separate constant for minimum fee amount in nominal terms, say 1 or 10   
