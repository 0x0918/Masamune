# Handle  pauliax   # Vulnerability details  ## Impact function handleFees can become cheaper by eliminating this surrounding if/else statement if you initially assign the value to the lastFee upon creation or initialization.  ## Recommended Mitigation Steps   uint256 public override lastFee = block.timestamp; or in function initialize as it will get this value anyway when doing the initial mintTo. But then you would probably need to skip handleFees if the timeDiff is 0.  
# Handle  pauliax   # Vulnerability details  ## Impact function handleFees calls factory.ownerSplit() twice. To save some gas and reduce the number of external calls, you should save the value after the first call and re-use it later.  ## Recommended Mitigation Steps Cache factory.ownerSplit() in a local variable and re-use it.  
# Handle  pauliax   # Vulnerability details  ## Impact Here basketAsERC20.totalSupply() does not change inside the loop so it can be called outside the loop to avoid multiple duplicate external calls:   uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;  ## Recommended Mitigation Steps Cache basketAsERC20.totalSupply() in a temporary variable and re-use it.  
# Handle  pauliax   # Vulnerability details  ## Impact function settleAuction could skip withdrawBounty if there are no bounties.  ## Recommended Mitigation Steps if (bountyIDs.length > 0) {   withdrawBounty(bountyIDs); }   
# Handle  pauliax   # Vulnerability details  ## Impact function createBasket in Factory should also be nonReentrant as it interacts with various tokens inside the loop and these tokens may contain callback hooks.  ## Recommended Mitigation Steps Add nonReentrant modifier to the declaration of createBasket.  
# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in Factory.sol.  Missing event :  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L39  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L43  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L47  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L51  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L55 ## Proof of Concept  See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.  
# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are basket functions that do not emit any events in Auction.sol.   Missing event :   https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Auction.sol#L44   ## Proof of Concept  See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L152  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {         require(newPublisher != address(0));          if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {             require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);             publisher = newPublisher; ```  `pendingPublisher.publisher` will never be `address(0)` if `newPublisher != address(0)` and `pendingPublisher.publisher == newPublisher`.  Removing `pendingPublisher.publisher != address(0)` can make the code simpler and save some gas.  ### Recommendation  Remove the redundant assertion.  
# Handle  WatchPug   # Vulnerability details  `Basket.sol#changeLicenseFee()` checks for `pendingLicenseFee.licenseFee  != 0`, while the assertion above already making sure that `newLicenseFee >= factory.minLicenseFee()`.  If we can make sure `factory.minLicenseFee() > 0`, then the check of `pendingLicenseFee.licenseFee != 0` will be redundant.  Removing it will make the code simpler and save some gas.  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L167-L170  ```solidity function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {     require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);     if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {         require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION); ```  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Factory.sol#L39-L41  ```solidity function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {     minLicenseFee = newMinLicenseFee; } ```  ### Recommendation  Consider adding `require(newMinLicenseFee > 0);` to `Factory.sol#setMinLicenseFee()`.  Remove the redundant check.  
# Handle  WatchPug   # Vulnerability details  As per the test, changePublisher to the current publisher should not be allowed:  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/test/Basket.test.js#L122-L122  ```javascript let publisher = await basket.publisher(); expect(publisher).to.equal(addr2.address);  await expect(basket.connect(addr2).changePublisher(addr2.address)).to.be.reverted; ```  However, there is no such check to make sure that.  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L148  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0)); ```  ### Recommendation  Change to:  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0) && newPublisher != publisher); ```  
# Handle  WatchPug   # Vulnerability details  While changing publisher and licenseFee is timelocked, there are no methods to cancel pending changes.  As a result, wrong changes may not be able to get canceled  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L163  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0));      if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {         require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);         publisher = newPublisher;          pendingPublisher.publisher = address(0);          emit ChangedPublisher(publisher);     } else {         pendingPublisher.publisher = newPublisher;         pendingPublisher.block = block.number;          emit NewPublisherSubmitted(newPublisher);     } } ```  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L167-L182  ```solidity function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {     require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);     if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {         require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);         licenseFee = newLicenseFee;          pendingLicenseFee.licenseFee = 0;          emit ChangedLicenseFee(licenseFee);     } else {         pendingLicenseFee.licenseFee = newLicenseFee;         pendingLicenseFee.block = block.number;          emit NewLicenseFeeSubmitted(newLicenseFee);     } } ```  ### Recommendation  Consider adding methods to cancel pending changes.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L83-L88  ```solidity function mint(uint256 amount) public nonReentrant override {     mintTo(amount, msg.sender); }  function mintTo(uint256 amount, address to) public nonReentrant override {     require(auction.auctionOngoing() == false); ```  The `mint()` method is malfunction because of the extra `nonReentrant` modifier, as `mintTo` already has a `nonReentrant` modifier.  ### Recommendation  Change to:  ```solidity function mint(uint256 amount) public override {     mintTo(amount, msg.sender); } ```  
# Handle  kenzo   # Vulnerability details  # Vulnerability details  The function creates and populates a new array to check for duplicates, this is not necessary.  ## Impact Some amount of gas unnecessarily spent.  ## Proof of Concept The relevant area: https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Basket.sol#L71:#L80 ## Tools Used Manual analysis, hardhat gas estimator.  ## Recommended Mitigation Steps Change the check to the following: ``` for (uint i = 0; i < length; i++) {   require(_tokens[i] != address(0));   require(_weights[i] > 0);   for (uint256 x = 0; x < i; x++) {       require(_tokens[i] != _tokens[x]);   } } ```  
# Handle  kenzo   # Vulnerability details  After an auction has started, as time passes and according to the bondBlock, newRatio (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket. This is not capped, and after a while, newRatio can become smaller than current ibRatio.  ## Impact If for some reason nobody has bonded and settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio < ibRatio, or even until newRatio ~= 0 (for an initial ibRatio of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.  ## Proof of Concept These are the vulnerable lines: https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Auction.sol#L95:#L105 ```         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();         IERC20 basketAsERC20 = IERC20(address(basket));          for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         }  ``` The function verifies that ```pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE```. This is the formula that will be used later to mint/burn/withdraw user funds. As bondBlock increases, newRatio will get smaller, and there is no check on this. After a while we'll arrive at a point where ```newRatio ~= 0```, so ```tokensNeeded = newRatio*(...) ~= 0```, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Your needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in settleAuction: ``` require (newRatio > basket.ibRatio()); ``` Maybe you would require newRatio to be > BASE but not sure.  
# Handle  kenzo   # Vulnerability details  While handling the fees, the contract calculates the new ibRatio by dividing by totalSupply. This can be 0 leading to a division by 0.  ## Impact If everybody burns their shares, in the next mint, totalSupply will be 0, handleFees will revert, and so nobody will be able to use the basket anymore.  ## Proof of Concept Vulnerable line: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L124 You can add the following test to Basket.test.js and see that it reverts (..after you remove "nonReentrant" from "mint", see other issue): it("should divide by 0", async () => {     await basket.connect(addr1).burn(await basket.balanceOf(addr1.address));     await basket.connect(addr2).burn(await basket.balanceOf(addr2.address));      await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await basket.connect(addr1).mint(ethers.BigNumber.from(1)); });   ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to handleFees: if totalSupply= 0, you can just return, no need to calculate new ibRatio / fees. You might want to reset ibRatio to BASE at this point.  
# Handle  ye0lde   # Vulnerability details  ## Impact It is possible to minimize the number of storage slots used by rearranging the state variables in a more efficient way.  ## Proof of Concept In Auction.sol: https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Auction.sol#L16-L28  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Arrange the bool and address variables such that they fit into the same slot. For example: <code>     uint256 private constant BASE = 1e18;     uint256 private constant ONE_DAY = 4 * 60 * 24; // one day in blocks          bool public override auctionOngoing;     bool public override hasBonded;     bool public override initialized;     address public override auctionBonder;          uint256 public override auctionStart; </code>        
# Handle  pants   # Vulnerability details  The function `Basket.auctionBurn()` uses the `onlyAuction` and `nonReentrant` modifier, with this order.  ## Impact The `nonReentrant` modifier doesn't protect agains reentrancy during the execution of the first modifier. Practically, there cannot be any reentrancy there when considering the current implementation of `onlyAuction`, but it is still a best practice recommendation for safe programming.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Use the `nonReentrant` modifier before any other modifier.  
# Handle  pants   # Vulnerability details  The function `Factory.proposeBasketLicense()` claims to override `IFactory.proposeBasketLicense()`, but some of their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Factory.proposeBasketLicense()` and `IFactory.proposeBasketLicense()`.  
# Handle  pants   # Vulnerability details  The function `Basket.publishNewIndex()` claims to override `IBasket.publishNewIndex()`, but their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Basket.publishNewIndex()` and `IBasket.publishNewIndex()`.  
# Handle  pants   # Vulnerability details  The function `Auction.settleAuction()` claims to override `IAuction.settleAuction()`, but their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Auction.settleAuction()` and `IAuction.settleAuction()`.  
# Handle  pants   # Vulnerability details  The function `Basket.publishNewIndex()` contains the following code: ``` if (auction.auctionOngoing() == false) {  // ... } else if (auction.hasBonded()) {  } else {  // ... } ```  ## Impact Empty code blocks increase gas costs (add overheads) and make the code less readable.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Get rid of the empty block by changing this code to: ``` if (auction.auctionOngoing() == false) {  // ... } else if (!auction.hasBonded()) {  // ... } ```  
# Handle  pants   # Vulnerability details  There are many for loops that follows this for-each pattern: ``` for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` } ```  In such for loops, the `array.length` is read on every iteration, instead of caching it once in a local variable and read it from there.  ## Impact Storage reads are much more expensive than reading local variables. Memory reads are a bit more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage / memory once, cache them in local variables and then read them again from the local variables. For example: ``` uint256 length = array.length; for (uint256 i = 0; i < length; i++) {  // do something with `array[i]` } ```  
# Handle  pants   # Vulnerability details  The functions `Factory.getProposalWeights()` and `Factory.createBasket()` read values from storage multiple times instead of caching them in local variables: - `Factory.getProposalWeights()` reads `_proposals[id]` twice. - `Factory.createBasket()` reads `_proposals[idNumber]` twice.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  
# Handle  pants   # Vulnerability details  The functions `Basket.handleFees()`, `Basket.changePublisher()`, `Basket.changeLicenseFee()`, `Basket.publishNewIndex()`, `Basket.deleteNewIndex()`, `Basket.updateIBRatio()`, `Basket.approveUnderlying()`, `Basket.pushUnderlying()` and `Basket.pullUnderlying()` read values from storage multiple times instead of caching them in local variables: - `Basket.handleFees()` reads `lastFee` up to twice, `factory` 3 times and `ibRatio` once (when `newIbRatio` can be used). - `Basket.changePublisher()` reads `pendingPublisher.publisher` up to twice and `publisher` up to once (when `newPublisher` can be used). - `Basket.changeLicenseFee()` reads `pendingLicenseFee.licenseFee` up to twice and `licenseFee` up to once (when `newLicenseFee` can be used). - `Basket.publishNewIndex()` reads `auction` up to 3 times and `licenseFee` up to once (when `newLicenseFee` can be used). - `Basket.deleteNewIndex()` reads `publisher` twice and `auction` up to twice. - `Basket.updateIBRatio()` reads `ibRatio` twice. - `Basket.approveUnderlying()` reads `tokens[i]` twice. - `Basket.pushUnderlying()` reads `ibRatio` once per iteration. - `Basket.pullUnderlying()` reads `ibRatio` once per iteration.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  
# Handle  pants   # Vulnerability details  The functions `Auction.bondForRebalance()`, `Auction.settleAuction()`, `Auction.bondBurn()` and `Auction.withdrawBounty()` read values from storage multiple times instead of caching them in local variables: - `Auction.bondForRebalance()` reads `bondAmount` twice. - `Auction.settleAuction()` reads `bondBlock` twice, `basket` 8 times and `factory` twice. - `Auction.bondBurn()` reads `basket` twice and `bondAmount` twice. - `Auction.withdrawBounty()` reads `bounty.token` twice and `bounty.amount` twice.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  
# Handle  pants   # Vulnerability details  The function `Auction.withdrawBounty()` accept an argument called `bountyIds` and use it as indices to determine which elements in the `_bounties` array should be loaded and treated. However, this function don't check that the indices it receives as an argument actually fits the bounds of the `_bounties` array.  ## Impact If one of the indices exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to this function to validate that the given argument fits the `_bounties` array bounds.  
# Handle  pants   # Vulnerability details  The functions `Factory.proposal()`, `Factory.getProposalWeights()` and `Factory.createBasket()` accept an argument called `proposalId`, `id` or `idNumber`, respectively, and use it as an index to determine which element in the `_proposals` array should be loaded and treated. However, these functions don't check that the index they receive as an argument actually fits the bounds of the `_proposals` array.  ## Impact If the index exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_proposals` array bounds.  
# Handle  pants   # Vulnerability details  The functions `Auction.initialize()` and `Basket.initialize()` look like this: ``` require(address(factory) == address(0)); require(!initialized); // ... factory = ...; // ... initialized = true;  ```  The second require statement is enough to make sure that these functions can only be called once. The first require statement is redundent.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the first require statement in these functions.  
# Handle  pants   # Vulnerability details  The modifier `Basket.onlyPublisher()` casts `publisher` to type `address`, although it is already a variable of type `address`.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the cast to `address`.  
# Handle  pants   # Vulnerability details  The function `Factory.proposeBasketLicense()` casts `msg.sender` to type `address`, although it is already a variable of type `address`.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the cast to `address`.  
# Handle  pants   # Vulnerability details  The `internal` function `Auction.withdrawBounty()` is never called by a contract that inherits `Auction`. Therefore, its visibility can be reduced to `private`.  ## Impact `private` functions are cheaper than `internal` functions.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define this function as `private`.  
# Handle  pants   # Vulnerability details  The `public` functions `Factory.setMinLicenseFee()`, `Factory.setAuctionDecrement()`, `Factory.setAuctionMultiplier()`, `Factory.setBondPercentDiv()`, `Factory.setOwnerSplit()` and `Factory.proposeBasketLicense()` are never called by `Factory`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  
# Handle  pants   # Vulnerability details  The `public` functions `Basket.mint()`, `Basket.burn()`, `Basket.changePublisher()`, `Basket.changeLicenseFee()`, `Basket.publishNewIndex()` and `Basket.deleteNewIndex()` are never called by `Basket`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  
# Handle  pants   # Vulnerability details  The `public` functions `Auction.startAuction()`, `Auction.killAuction()`, `Auction.initialize()`, `Auction.bondForRebalance()`, `Auction.settleAuction()` and `Auction.addBounty()` are never called by `Auction`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  
# Handle  pants   # Vulnerability details  The state variables `Factory.auctionImpl` and `Factory.basketImpl` can be `immutable` since they are only set once, at the constructor.  ## Impact Reading from immutable state variables is much cheaper than from regular state variables.  ## Proof of Concept https://blog.soliditylang.org/2020/05/13/immutable-keyword/  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these state variables as `immutable`.  
# Handle  pauliax   # Vulnerability details  ## Impact function handleFees can become cheaper by eliminating this surrounding if/else statement if you initially assign the value to the lastFee upon creation or initialization.  ## Recommended Mitigation Steps   uint256 public override lastFee = block.timestamp; or in function initialize as it will get this value anyway when doing the initial mintTo. But then you would probably need to skip handleFees if the timeDiff is 0.  
# Handle  pauliax   # Vulnerability details  ## Impact function handleFees calls factory.ownerSplit() twice. To save some gas and reduce the number of external calls, you should save the value after the first call and re-use it later.  ## Recommended Mitigation Steps Cache factory.ownerSplit() in a local variable and re-use it.  
# Handle  pauliax   # Vulnerability details  ## Impact Here basketAsERC20.totalSupply() does not change inside the loop so it can be called outside the loop to avoid multiple duplicate external calls:   uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;  ## Recommended Mitigation Steps Cache basketAsERC20.totalSupply() in a temporary variable and re-use it.  
# Handle  pauliax   # Vulnerability details  ## Impact function settleAuction could skip withdrawBounty if there are no bounties.  ## Recommended Mitigation Steps if (bountyIDs.length > 0) {   withdrawBounty(bountyIDs); }   
# Handle  pauliax   # Vulnerability details  ## Impact function createBasket in Factory should also be nonReentrant as it interacts with various tokens inside the loop and these tokens may contain callback hooks.  ## Recommended Mitigation Steps Add nonReentrant modifier to the declaration of createBasket.  
# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in Factory.sol.  Missing event :  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L39  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L43  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L47  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L51  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L55 ## Proof of Concept  See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.  
# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are basket functions that do not emit any events in Auction.sol.   Missing event :   https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Auction.sol#L44   ## Proof of Concept  See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L152  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {         require(newPublisher != address(0));          if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {             require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);             publisher = newPublisher; ```  `pendingPublisher.publisher` will never be `address(0)` if `newPublisher != address(0)` and `pendingPublisher.publisher == newPublisher`.  Removing `pendingPublisher.publisher != address(0)` can make the code simpler and save some gas.  ### Recommendation  Remove the redundant assertion.  
# Handle  WatchPug   # Vulnerability details  `Basket.sol#changeLicenseFee()` checks for `pendingLicenseFee.licenseFee  != 0`, while the assertion above already making sure that `newLicenseFee >= factory.minLicenseFee()`.  If we can make sure `factory.minLicenseFee() > 0`, then the check of `pendingLicenseFee.licenseFee != 0` will be redundant.  Removing it will make the code simpler and save some gas.  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L167-L170  ```solidity function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {     require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);     if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {         require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION); ```  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Factory.sol#L39-L41  ```solidity function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {     minLicenseFee = newMinLicenseFee; } ```  ### Recommendation  Consider adding `require(newMinLicenseFee > 0);` to `Factory.sol#setMinLicenseFee()`.  Remove the redundant check.  
# Handle  WatchPug   # Vulnerability details  As per the test, changePublisher to the current publisher should not be allowed:  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/test/Basket.test.js#L122-L122  ```javascript let publisher = await basket.publisher(); expect(publisher).to.equal(addr2.address);  await expect(basket.connect(addr2).changePublisher(addr2.address)).to.be.reverted; ```  However, there is no such check to make sure that.  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L148  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0)); ```  ### Recommendation  Change to:  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0) && newPublisher != publisher); ```  
# Handle  WatchPug   # Vulnerability details  While changing publisher and licenseFee is timelocked, there are no methods to cancel pending changes.  As a result, wrong changes may not be able to get canceled  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L163  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0));      if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {         require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);         publisher = newPublisher;          pendingPublisher.publisher = address(0);          emit ChangedPublisher(publisher);     } else {         pendingPublisher.publisher = newPublisher;         pendingPublisher.block = block.number;          emit NewPublisherSubmitted(newPublisher);     } } ```  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L167-L182  ```solidity function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {     require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);     if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {         require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);         licenseFee = newLicenseFee;          pendingLicenseFee.licenseFee = 0;          emit ChangedLicenseFee(licenseFee);     } else {         pendingLicenseFee.licenseFee = newLicenseFee;         pendingLicenseFee.block = block.number;          emit NewLicenseFeeSubmitted(newLicenseFee);     } } ```  ### Recommendation  Consider adding methods to cancel pending changes.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L83-L88  ```solidity function mint(uint256 amount) public nonReentrant override {     mintTo(amount, msg.sender); }  function mintTo(uint256 amount, address to) public nonReentrant override {     require(auction.auctionOngoing() == false); ```  The `mint()` method is malfunction because of the extra `nonReentrant` modifier, as `mintTo` already has a `nonReentrant` modifier.  ### Recommendation  Change to:  ```solidity function mint(uint256 amount) public override {     mintTo(amount, msg.sender); } ```  
# Handle  kenzo   # Vulnerability details  # Vulnerability details  The function creates and populates a new array to check for duplicates, this is not necessary.  ## Impact Some amount of gas unnecessarily spent.  ## Proof of Concept The relevant area: https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Basket.sol#L71:#L80 ## Tools Used Manual analysis, hardhat gas estimator.  ## Recommended Mitigation Steps Change the check to the following: ``` for (uint i = 0; i < length; i++) {   require(_tokens[i] != address(0));   require(_weights[i] > 0);   for (uint256 x = 0; x < i; x++) {       require(_tokens[i] != _tokens[x]);   } } ```  
# Handle  kenzo   # Vulnerability details  After an auction has started, as time passes and according to the bondBlock, newRatio (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket. This is not capped, and after a while, newRatio can become smaller than current ibRatio.  ## Impact If for some reason nobody has bonded and settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio < ibRatio, or even until newRatio ~= 0 (for an initial ibRatio of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.  ## Proof of Concept These are the vulnerable lines: https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Auction.sol#L95:#L105 ```         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();         IERC20 basketAsERC20 = IERC20(address(basket));          for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         }  ``` The function verifies that ```pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE```. This is the formula that will be used later to mint/burn/withdraw user funds. As bondBlock increases, newRatio will get smaller, and there is no check on this. After a while we'll arrive at a point where ```newRatio ~= 0```, so ```tokensNeeded = newRatio*(...) ~= 0```, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Your needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in settleAuction: ``` require (newRatio > basket.ibRatio()); ``` Maybe you would require newRatio to be > BASE but not sure.  
# Handle  kenzo   # Vulnerability details  While handling the fees, the contract calculates the new ibRatio by dividing by totalSupply. This can be 0 leading to a division by 0.  ## Impact If everybody burns their shares, in the next mint, totalSupply will be 0, handleFees will revert, and so nobody will be able to use the basket anymore.  ## Proof of Concept Vulnerable line: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L124 You can add the following test to Basket.test.js and see that it reverts (..after you remove "nonReentrant" from "mint", see other issue): it("should divide by 0", async () => {     await basket.connect(addr1).burn(await basket.balanceOf(addr1.address));     await basket.connect(addr2).burn(await basket.balanceOf(addr2.address));      await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await basket.connect(addr1).mint(ethers.BigNumber.from(1)); });   ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to handleFees: if totalSupply= 0, you can just return, no need to calculate new ibRatio / fees. You might want to reset ibRatio to BASE at this point.  
# Handle  ye0lde   # Vulnerability details  ## Impact It is possible to minimize the number of storage slots used by rearranging the state variables in a more efficient way.  ## Proof of Concept In Auction.sol: https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Auction.sol#L16-L28  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Arrange the bool and address variables such that they fit into the same slot. For example: <code>     uint256 private constant BASE = 1e18;     uint256 private constant ONE_DAY = 4 * 60 * 24; // one day in blocks          bool public override auctionOngoing;     bool public override hasBonded;     bool public override initialized;     address public override auctionBonder;          uint256 public override auctionStart; </code>        
# Handle  pants   # Vulnerability details  The function `Basket.auctionBurn()` uses the `onlyAuction` and `nonReentrant` modifier, with this order.  ## Impact The `nonReentrant` modifier doesn't protect agains reentrancy during the execution of the first modifier. Practically, there cannot be any reentrancy there when considering the current implementation of `onlyAuction`, but it is still a best practice recommendation for safe programming.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Use the `nonReentrant` modifier before any other modifier.  
# Handle  pants   # Vulnerability details  The function `Factory.proposeBasketLicense()` claims to override `IFactory.proposeBasketLicense()`, but some of their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Factory.proposeBasketLicense()` and `IFactory.proposeBasketLicense()`.  
# Handle  pants   # Vulnerability details  The function `Basket.publishNewIndex()` claims to override `IBasket.publishNewIndex()`, but their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Basket.publishNewIndex()` and `IBasket.publishNewIndex()`.  
# Handle  pants   # Vulnerability details  The function `Auction.settleAuction()` claims to override `IAuction.settleAuction()`, but their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Auction.settleAuction()` and `IAuction.settleAuction()`.  
# Handle  pants   # Vulnerability details  The function `Basket.publishNewIndex()` contains the following code: ``` if (auction.auctionOngoing() == false) {  // ... } else if (auction.hasBonded()) {  } else {  // ... } ```  ## Impact Empty code blocks increase gas costs (add overheads) and make the code less readable.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Get rid of the empty block by changing this code to: ``` if (auction.auctionOngoing() == false) {  // ... } else if (!auction.hasBonded()) {  // ... } ```  
# Handle  pants   # Vulnerability details  There are many for loops that follows this for-each pattern: ``` for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` } ```  In such for loops, the `array.length` is read on every iteration, instead of caching it once in a local variable and read it from there.  ## Impact Storage reads are much more expensive than reading local variables. Memory reads are a bit more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage / memory once, cache them in local variables and then read them again from the local variables. For example: ``` uint256 length = array.length; for (uint256 i = 0; i < length; i++) {  // do something with `array[i]` } ```  
# Handle  pants   # Vulnerability details  The functions `Factory.getProposalWeights()` and `Factory.createBasket()` read values from storage multiple times instead of caching them in local variables: - `Factory.getProposalWeights()` reads `_proposals[id]` twice. - `Factory.createBasket()` reads `_proposals[idNumber]` twice.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  
# Handle  pants   # Vulnerability details  The functions `Basket.handleFees()`, `Basket.changePublisher()`, `Basket.changeLicenseFee()`, `Basket.publishNewIndex()`, `Basket.deleteNewIndex()`, `Basket.updateIBRatio()`, `Basket.approveUnderlying()`, `Basket.pushUnderlying()` and `Basket.pullUnderlying()` read values from storage multiple times instead of caching them in local variables: - `Basket.handleFees()` reads `lastFee` up to twice, `factory` 3 times and `ibRatio` once (when `newIbRatio` can be used). - `Basket.changePublisher()` reads `pendingPublisher.publisher` up to twice and `publisher` up to once (when `newPublisher` can be used). - `Basket.changeLicenseFee()` reads `pendingLicenseFee.licenseFee` up to twice and `licenseFee` up to once (when `newLicenseFee` can be used). - `Basket.publishNewIndex()` reads `auction` up to 3 times and `licenseFee` up to once (when `newLicenseFee` can be used). - `Basket.deleteNewIndex()` reads `publisher` twice and `auction` up to twice. - `Basket.updateIBRatio()` reads `ibRatio` twice. - `Basket.approveUnderlying()` reads `tokens[i]` twice. - `Basket.pushUnderlying()` reads `ibRatio` once per iteration. - `Basket.pullUnderlying()` reads `ibRatio` once per iteration.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  
# Handle  pants   # Vulnerability details  The functions `Auction.bondForRebalance()`, `Auction.settleAuction()`, `Auction.bondBurn()` and `Auction.withdrawBounty()` read values from storage multiple times instead of caching them in local variables: - `Auction.bondForRebalance()` reads `bondAmount` twice. - `Auction.settleAuction()` reads `bondBlock` twice, `basket` 8 times and `factory` twice. - `Auction.bondBurn()` reads `basket` twice and `bondAmount` twice. - `Auction.withdrawBounty()` reads `bounty.token` twice and `bounty.amount` twice.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  
# Handle  pants   # Vulnerability details  The function `Auction.withdrawBounty()` accept an argument called `bountyIds` and use it as indices to determine which elements in the `_bounties` array should be loaded and treated. However, this function don't check that the indices it receives as an argument actually fits the bounds of the `_bounties` array.  ## Impact If one of the indices exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to this function to validate that the given argument fits the `_bounties` array bounds.  
# Handle  pants   # Vulnerability details  The functions `Factory.proposal()`, `Factory.getProposalWeights()` and `Factory.createBasket()` accept an argument called `proposalId`, `id` or `idNumber`, respectively, and use it as an index to determine which element in the `_proposals` array should be loaded and treated. However, these functions don't check that the index they receive as an argument actually fits the bounds of the `_proposals` array.  ## Impact If the index exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_proposals` array bounds.  
# Handle  pants   # Vulnerability details  The functions `Auction.initialize()` and `Basket.initialize()` look like this: ``` require(address(factory) == address(0)); require(!initialized); // ... factory = ...; // ... initialized = true;  ```  The second require statement is enough to make sure that these functions can only be called once. The first require statement is redundent.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the first require statement in these functions.  
# Handle  pants   # Vulnerability details  The modifier `Basket.onlyPublisher()` casts `publisher` to type `address`, although it is already a variable of type `address`.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the cast to `address`.  
# Handle  pants   # Vulnerability details  The function `Factory.proposeBasketLicense()` casts `msg.sender` to type `address`, although it is already a variable of type `address`.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the cast to `address`.  
# Handle  pants   # Vulnerability details  The `internal` function `Auction.withdrawBounty()` is never called by a contract that inherits `Auction`. Therefore, its visibility can be reduced to `private`.  ## Impact `private` functions are cheaper than `internal` functions.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define this function as `private`.  
# Handle  pants   # Vulnerability details  The `public` functions `Factory.setMinLicenseFee()`, `Factory.setAuctionDecrement()`, `Factory.setAuctionMultiplier()`, `Factory.setBondPercentDiv()`, `Factory.setOwnerSplit()` and `Factory.proposeBasketLicense()` are never called by `Factory`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  
# Handle  pants   # Vulnerability details  The `public` functions `Basket.mint()`, `Basket.burn()`, `Basket.changePublisher()`, `Basket.changeLicenseFee()`, `Basket.publishNewIndex()` and `Basket.deleteNewIndex()` are never called by `Basket`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  
# Handle  pants   # Vulnerability details  The `public` functions `Auction.startAuction()`, `Auction.killAuction()`, `Auction.initialize()`, `Auction.bondForRebalance()`, `Auction.settleAuction()` and `Auction.addBounty()` are never called by `Auction`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  
# Handle  pants   # Vulnerability details  The state variables `Factory.auctionImpl` and `Factory.basketImpl` can be `immutable` since they are only set once, at the constructor.  ## Impact Reading from immutable state variables is much cheaper than from regular state variables.  ## Proof of Concept https://blog.soliditylang.org/2020/05/13/immutable-keyword/  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these state variables as `immutable`.  
# Handle  pauliax   # Vulnerability details  ## Impact function handleFees can become cheaper by eliminating this surrounding if/else statement if you initially assign the value to the lastFee upon creation or initialization.  ## Recommended Mitigation Steps   uint256 public override lastFee = block.timestamp; or in function initialize as it will get this value anyway when doing the initial mintTo. But then you would probably need to skip handleFees if the timeDiff is 0.  
# Handle  pauliax   # Vulnerability details  ## Impact function handleFees calls factory.ownerSplit() twice. To save some gas and reduce the number of external calls, you should save the value after the first call and re-use it later.  ## Recommended Mitigation Steps Cache factory.ownerSplit() in a local variable and re-use it.  
# Handle  pauliax   # Vulnerability details  ## Impact Here basketAsERC20.totalSupply() does not change inside the loop so it can be called outside the loop to avoid multiple duplicate external calls:   uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;  ## Recommended Mitigation Steps Cache basketAsERC20.totalSupply() in a temporary variable and re-use it.  
# Handle  pauliax   # Vulnerability details  ## Impact function settleAuction could skip withdrawBounty if there are no bounties.  ## Recommended Mitigation Steps if (bountyIDs.length > 0) {   withdrawBounty(bountyIDs); }   
# Handle  pauliax   # Vulnerability details  ## Impact function createBasket in Factory should also be nonReentrant as it interacts with various tokens inside the loop and these tokens may contain callback hooks.  ## Recommended Mitigation Steps Add nonReentrant modifier to the declaration of createBasket.  
# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in Factory.sol.  Missing event :  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L39  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L43  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L47  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L51  https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Factory.sol#L55 ## Proof of Concept  See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.  
# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are basket functions that do not emit any events in Auction.sol.   Missing event :   https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Auction.sol#L44   ## Proof of Concept  See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L152  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {         require(newPublisher != address(0));          if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {             require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);             publisher = newPublisher; ```  `pendingPublisher.publisher` will never be `address(0)` if `newPublisher != address(0)` and `pendingPublisher.publisher == newPublisher`.  Removing `pendingPublisher.publisher != address(0)` can make the code simpler and save some gas.  ### Recommendation  Remove the redundant assertion.  
# Handle  WatchPug   # Vulnerability details  `Basket.sol#changeLicenseFee()` checks for `pendingLicenseFee.licenseFee  != 0`, while the assertion above already making sure that `newLicenseFee >= factory.minLicenseFee()`.  If we can make sure `factory.minLicenseFee() > 0`, then the check of `pendingLicenseFee.licenseFee != 0` will be redundant.  Removing it will make the code simpler and save some gas.  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L167-L170  ```solidity function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {     require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);     if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {         require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION); ```  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Factory.sol#L39-L41  ```solidity function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {     minLicenseFee = newMinLicenseFee; } ```  ### Recommendation  Consider adding `require(newMinLicenseFee > 0);` to `Factory.sol#setMinLicenseFee()`.  Remove the redundant check.  
# Handle  WatchPug   # Vulnerability details  As per the test, changePublisher to the current publisher should not be allowed:  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/test/Basket.test.js#L122-L122  ```javascript let publisher = await basket.publisher(); expect(publisher).to.equal(addr2.address);  await expect(basket.connect(addr2).changePublisher(addr2.address)).to.be.reverted; ```  However, there is no such check to make sure that.  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L148  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0)); ```  ### Recommendation  Change to:  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0) && newPublisher != publisher); ```  
# Handle  WatchPug   # Vulnerability details  While changing publisher and licenseFee is timelocked, there are no methods to cancel pending changes.  As a result, wrong changes may not be able to get canceled  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L163  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0));      if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {         require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);         publisher = newPublisher;          pendingPublisher.publisher = address(0);          emit ChangedPublisher(publisher);     } else {         pendingPublisher.publisher = newPublisher;         pendingPublisher.block = block.number;          emit NewPublisherSubmitted(newPublisher);     } } ```  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L167-L182  ```solidity function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {     require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);     if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {         require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);         licenseFee = newLicenseFee;          pendingLicenseFee.licenseFee = 0;          emit ChangedLicenseFee(licenseFee);     } else {         pendingLicenseFee.licenseFee = newLicenseFee;         pendingLicenseFee.block = block.number;          emit NewLicenseFeeSubmitted(newLicenseFee);     } } ```  ### Recommendation  Consider adding methods to cancel pending changes.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L83-L88  ```solidity function mint(uint256 amount) public nonReentrant override {     mintTo(amount, msg.sender); }  function mintTo(uint256 amount, address to) public nonReentrant override {     require(auction.auctionOngoing() == false); ```  The `mint()` method is malfunction because of the extra `nonReentrant` modifier, as `mintTo` already has a `nonReentrant` modifier.  ### Recommendation  Change to:  ```solidity function mint(uint256 amount) public override {     mintTo(amount, msg.sender); } ```  
# Handle  kenzo   # Vulnerability details  # Vulnerability details  The function creates and populates a new array to check for duplicates, this is not necessary.  ## Impact Some amount of gas unnecessarily spent.  ## Proof of Concept The relevant area: https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Basket.sol#L71:#L80 ## Tools Used Manual analysis, hardhat gas estimator.  ## Recommended Mitigation Steps Change the check to the following: ``` for (uint i = 0; i < length; i++) {   require(_tokens[i] != address(0));   require(_weights[i] > 0);   for (uint256 x = 0; x < i; x++) {       require(_tokens[i] != _tokens[x]);   } } ```  
# Handle  kenzo   # Vulnerability details  After an auction has started, as time passes and according to the bondBlock, newRatio (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket. This is not capped, and after a while, newRatio can become smaller than current ibRatio.  ## Impact If for some reason nobody has bonded and settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio < ibRatio, or even until newRatio ~= 0 (for an initial ibRatio of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.  ## Proof of Concept These are the vulnerable lines: https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Auction.sol#L95:#L105 ```         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();         IERC20 basketAsERC20 = IERC20(address(basket));          for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         }  ``` The function verifies that ```pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE```. This is the formula that will be used later to mint/burn/withdraw user funds. As bondBlock increases, newRatio will get smaller, and there is no check on this. After a while we'll arrive at a point where ```newRatio ~= 0```, so ```tokensNeeded = newRatio*(...) ~= 0```, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Your needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in settleAuction: ``` require (newRatio > basket.ibRatio()); ``` Maybe you would require newRatio to be > BASE but not sure.  
# Handle  kenzo   # Vulnerability details  While handling the fees, the contract calculates the new ibRatio by dividing by totalSupply. This can be 0 leading to a division by 0.  ## Impact If everybody burns their shares, in the next mint, totalSupply will be 0, handleFees will revert, and so nobody will be able to use the basket anymore.  ## Proof of Concept Vulnerable line: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L124 You can add the following test to Basket.test.js and see that it reverts (..after you remove "nonReentrant" from "mint", see other issue): it("should divide by 0", async () => {     await basket.connect(addr1).burn(await basket.balanceOf(addr1.address));     await basket.connect(addr2).burn(await basket.balanceOf(addr2.address));      await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await basket.connect(addr1).mint(ethers.BigNumber.from(1)); });   ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to handleFees: if totalSupply= 0, you can just return, no need to calculate new ibRatio / fees. You might want to reset ibRatio to BASE at this point.  
# Handle  ye0lde   # Vulnerability details  ## Impact It is possible to minimize the number of storage slots used by rearranging the state variables in a more efficient way.  ## Proof of Concept In Auction.sol: https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Auction.sol#L16-L28  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Arrange the bool and address variables such that they fit into the same slot. For example: <code>     uint256 private constant BASE = 1e18;     uint256 private constant ONE_DAY = 4 * 60 * 24; // one day in blocks          bool public override auctionOngoing;     bool public override hasBonded;     bool public override initialized;     address public override auctionBonder;          uint256 public override auctionStart; </code>        
# Handle  pants   # Vulnerability details  The function `Basket.auctionBurn()` uses the `onlyAuction` and `nonReentrant` modifier, with this order.  ## Impact The `nonReentrant` modifier doesn't protect agains reentrancy during the execution of the first modifier. Practically, there cannot be any reentrancy there when considering the current implementation of `onlyAuction`, but it is still a best practice recommendation for safe programming.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Use the `nonReentrant` modifier before any other modifier.  
# Handle  pants   # Vulnerability details  The function `Factory.proposeBasketLicense()` claims to override `IFactory.proposeBasketLicense()`, but some of their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Factory.proposeBasketLicense()` and `IFactory.proposeBasketLicense()`.  
# Handle  pants   # Vulnerability details  The function `Basket.publishNewIndex()` claims to override `IBasket.publishNewIndex()`, but their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Basket.publishNewIndex()` and `IBasket.publishNewIndex()`.  
# Handle  pants   # Vulnerability details  The function `Auction.settleAuction()` claims to override `IAuction.settleAuction()`, but their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Auction.settleAuction()` and `IAuction.settleAuction()`.  
# Handle  pants   # Vulnerability details  The function `Basket.publishNewIndex()` contains the following code: ``` if (auction.auctionOngoing() == false) {  // ... } else if (auction.hasBonded()) {  } else {  // ... } ```  ## Impact Empty code blocks increase gas costs (add overheads) and make the code less readable.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Get rid of the empty block by changing this code to: ``` if (auction.auctionOngoing() == false) {  // ... } else if (!auction.hasBonded()) {  // ... } ```  
# Handle  pants   # Vulnerability details  There are many for loops that follows this for-each pattern: ``` for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` } ```  In such for loops, the `array.length` is read on every iteration, instead of caching it once in a local variable and read it from there.  ## Impact Storage reads are much more expensive than reading local variables. Memory reads are a bit more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage / memory once, cache them in local variables and then read them again from the local variables. For example: ``` uint256 length = array.length; for (uint256 i = 0; i < length; i++) {  // do something with `array[i]` } ```  
# Handle  pants   # Vulnerability details  The functions `Factory.getProposalWeights()` and `Factory.createBasket()` read values from storage multiple times instead of caching them in local variables: - `Factory.getProposalWeights()` reads `_proposals[id]` twice. - `Factory.createBasket()` reads `_proposals[idNumber]` twice.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  
# Handle  pants   # Vulnerability details  The functions `Basket.handleFees()`, `Basket.changePublisher()`, `Basket.changeLicenseFee()`, `Basket.publishNewIndex()`, `Basket.deleteNewIndex()`, `Basket.updateIBRatio()`, `Basket.approveUnderlying()`, `Basket.pushUnderlying()` and `Basket.pullUnderlying()` read values from storage multiple times instead of caching them in local variables: - `Basket.handleFees()` reads `lastFee` up to twice, `factory` 3 times and `ibRatio` once (when `newIbRatio` can be used). - `Basket.changePublisher()` reads `pendingPublisher.publisher` up to twice and `publisher` up to once (when `newPublisher` can be used). - `Basket.changeLicenseFee()` reads `pendingLicenseFee.licenseFee` up to twice and `licenseFee` up to once (when `newLicenseFee` can be used). - `Basket.publishNewIndex()` reads `auction` up to 3 times and `licenseFee` up to once (when `newLicenseFee` can be used). - `Basket.deleteNewIndex()` reads `publisher` twice and `auction` up to twice. - `Basket.updateIBRatio()` reads `ibRatio` twice. - `Basket.approveUnderlying()` reads `tokens[i]` twice. - `Basket.pushUnderlying()` reads `ibRatio` once per iteration. - `Basket.pullUnderlying()` reads `ibRatio` once per iteration.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  
# Handle  pants   # Vulnerability details  The functions `Auction.bondForRebalance()`, `Auction.settleAuction()`, `Auction.bondBurn()` and `Auction.withdrawBounty()` read values from storage multiple times instead of caching them in local variables: - `Auction.bondForRebalance()` reads `bondAmount` twice. - `Auction.settleAuction()` reads `bondBlock` twice, `basket` 8 times and `factory` twice. - `Auction.bondBurn()` reads `basket` twice and `bondAmount` twice. - `Auction.withdrawBounty()` reads `bounty.token` twice and `bounty.amount` twice.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  
# Handle  pants   # Vulnerability details  The function `Auction.withdrawBounty()` accept an argument called `bountyIds` and use it as indices to determine which elements in the `_bounties` array should be loaded and treated. However, this function don't check that the indices it receives as an argument actually fits the bounds of the `_bounties` array.  ## Impact If one of the indices exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to this function to validate that the given argument fits the `_bounties` array bounds.  
# Handle  pants   # Vulnerability details  The functions `Factory.proposal()`, `Factory.getProposalWeights()` and `Factory.createBasket()` accept an argument called `proposalId`, `id` or `idNumber`, respectively, and use it as an index to determine which element in the `_proposals` array should be loaded and treated. However, these functions don't check that the index they receive as an argument actually fits the bounds of the `_proposals` array.  ## Impact If the index exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_proposals` array bounds.  
# Handle  pants   # Vulnerability details  The functions `Auction.initialize()` and `Basket.initialize()` look like this: ``` require(address(factory) == address(0)); require(!initialized); // ... factory = ...; // ... initialized = true;  ```  The second require statement is enough to make sure that these functions can only be called once. The first require statement is redundent.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the first require statement in these functions.  
# Handle  pants   # Vulnerability details  The modifier `Basket.onlyPublisher()` casts `publisher` to type `address`, although it is already a variable of type `address`.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the cast to `address`.  
# Handle  pants   # Vulnerability details  The function `Factory.proposeBasketLicense()` casts `msg.sender` to type `address`, although it is already a variable of type `address`.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the cast to `address`.  
# Handle  pants   # Vulnerability details  The `internal` function `Auction.withdrawBounty()` is never called by a contract that inherits `Auction`. Therefore, its visibility can be reduced to `private`.  ## Impact `private` functions are cheaper than `internal` functions.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define this function as `private`.  
# Handle  pants   # Vulnerability details  The `public` functions `Factory.setMinLicenseFee()`, `Factory.setAuctionDecrement()`, `Factory.setAuctionMultiplier()`, `Factory.setBondPercentDiv()`, `Factory.setOwnerSplit()` and `Factory.proposeBasketLicense()` are never called by `Factory`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  
# Handle  pants   # Vulnerability details  The `public` functions `Basket.mint()`, `Basket.burn()`, `Basket.changePublisher()`, `Basket.changeLicenseFee()`, `Basket.publishNewIndex()` and `Basket.deleteNewIndex()` are never called by `Basket`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  
# Handle  pants   # Vulnerability details  The `public` functions `Auction.startAuction()`, `Auction.killAuction()`, `Auction.initialize()`, `Auction.bondForRebalance()`, `Auction.settleAuction()` and `Auction.addBounty()` are never called by `Auction`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  
# Handle  pants   # Vulnerability details  The state variables `Factory.auctionImpl` and `Factory.basketImpl` can be `immutable` since they are only set once, at the constructor.  ## Impact Reading from immutable state variables is much cheaper than from regular state variables.  ## Proof of Concept https://blog.soliditylang.org/2020/05/13/immutable-keyword/  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these state variables as `immutable`.  
