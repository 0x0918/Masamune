# Handle  0xsanson   # Vulnerability details  ## Impact In `rcMarket._processRentCollection` it's possible to save a SLOAD by rewriting the lines: ``` uint256 _rentOwed = (card[_card].cardPrice *     (_timeOfCollection - card[_card].timeLastCollected)) / 1 days; uint256 _timeHeldToIncrement = (_timeOfCollection -                    card[_card].timeLastCollected); ``` into: ``` uint256 _timeHeldToIncrement = (_timeOfCollection -                    card[_card].timeLastCollected); uint256 _rentOwed = (card[_card].cardPrice * _timeHeldToIncrement) / 1 days; ```  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1060-L1063  ## Tools Used editor  ## Recommended Mitigation Steps Consider changing the code as illustrated.  
# Handle  JMukesh   # Vulnerability details  ## Impact since the parameter in the constructor are used to initialize the state variable , proper check up should be done , other wise error in these state variable  can lead to redeployment of contract  ## Proof of Concept  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCLeaderboard.sol#L50  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCOrderbook.sol#L136  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L120  ## Tools Used manual review  ## Recommended Mitigation Steps add zero address validation  
# Handle  cmichel   # Vulnerability details  The `RCLeaderboard.market` storage variable is never used. Instead, the `MARKET` role seems to be used to implement authentication.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  
# Handle  JMukesh   # Vulnerability details  ## Impact   referenceContractAddress  is used in createMarket() to create newAddress  for the market , a necessary check should be there that referenceContractAddress exist or not, because if createMarket() is called before setReferenceContractAddress() address(0) will be passed as referenceContractAddress , since addMarket() of treasury and nfthub does not have address validation for the market  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCFactory.sol#L714  ## Tools Used  manual review  ## Recommended Mitigation Steps  add a condition to check the referenceContractAddress  
# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  - `seperate` → `separate` - `incase` → `in case`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  It might be operationally easier (eg. reading permissions via etherscan, saves a few seconds having to search for the bytes32 constant and copy its value) to take in the role of type `string` instead of `bytes32`. It also has an added benefit of overloading the `hasRole()` function, where overriding was desired.  ### Recommended Mitigation Steps  Perhaps add it as an additional function to avoid having to change all `treasury.checkPermissions()` function calls (since the role input has to be modified too).  ```jsx // TODO: add to interface function hasRole(string memory role, address account)  external  view  override  returns (bool) {  bytes32 _role = keccak256(abi.encodePacked(role));  return AccessControl.hasRole(_role, account); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  ```jsx /* setup AccessControl                   UBER_OWNER     ┌───────────┬────┴─────┬────────────┬─────────┐     │           │          │            │         │   OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD     │           │  GOVERNOR     MARKET     │  WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE */ ```  From this diagram, one might expect the existence of a `LEADERBOARD` role, but there is no such role. It should be removed from the diagram.  ### Recommended Mitigation Steps  ```jsx /* setup AccessControl                   UBER_OWNER     ┌───────────┬────┴─────┬────────────┐     │           │          │            │            OWNER      FACTORY    ORDERBOOK   TREASURY     │           │  GOVERNOR     MARKET     │  WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE */ ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The comments above the event declarations were probably copied over from RCOrderbook. They should be modified to refer to the leaderboard.  ### Recommended Mitigation Steps  ```jsx /// @dev emitted every time a user is added to the leaderboard event LogAddToLeaderboard(address _user, address _market, uint256 _card); /// @dev emitted every time a user is removed from the leaderboard event LogRemoveFromLeaderboard(     address _user,     address _market,     uint256 _card ); ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `marketInfoResults` is a parameter used by `getMarketInfo()` to determine the length of results to return. As the `setMarketInfoResults()` comments state, "(it) would be better to pass this as a parameter in getMarketInfo.. however we are limited because of stack too deep errors".  This limitation can be overcome by defining the return array variables as the function output, as suggested below.  The need for `marketInfoResults` and its setter function is then made redundant, whilst making querying results of possibly varying lengths more convenient.  ### Recommended Mitigation Steps  ```jsx function getMarketInfo(   IRCMarket.Mode _mode,   uint256 _state,   uint256 _skipResults,   uint256 _numResults // equivalent of marketInfoResults )   external   view   returns (     address[] memory _marketAddresses,     string[] memory _ipfsHashes,     string[] memory _slugs,     uint256[] memory _potSizes  )  {    uint256 _marketIndex = marketAddresses[_mode].length;        _marketAddresses = new address[](_numResults);    _ipfsHashes = new string[](_numResults);    _slugs = new string[](_numResults);    _potSizes = new uint256[](_numResults);   ... } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Solidity division rounds down, so doing `M / 2 <= N` checks mean that `M` can be at most `2N + 1`.  This affects the following checks:  ```jsx require(  (_tokenURIs.length / 2) <= cardLimit,  "Too many tokens to mint" );  require(   _cardAffiliateAddresses.length == 0 ||    _cardAffiliateAddresses.length == (_tokenURIs.length / 2),   "Card Affiliate Length Error" ) ```  Note that with the current implementation, if `_tokenURIs` is of odd length, its last element will be  redundant, but market creation will not revert.  The stricter checks will partially mitigate `_tokenURIs` having odd length because `_cardAffiliateAddresses` is now required to be exactly twice that of `_tokenURIs`.  ### Recommended Mitigation Steps  These checks should be modified to   ```jsx require(  _tokenURIs.length <= cardLimit * 2,  "Too many tokens to mint" );  require(   _cardAffiliateAddresses.length == 0 ||    _cardAffiliateAddresses.length * 2 == _tokenURIs.length,   "Card Affiliate Length Error" ); ```  In addition, consider adding a check for `_tokenURIs` to strictly be of even length.  `require(_tokenURIs.length % 2 == 0, "TokenURI Length Error");`  
# Handle  0xImpostor   # Vulnerability details  ## Impact  When the current owner of the card is still the new owner of the card, `transferCard` is called before the treasury is updated. While this does not currently pose a risk, it is not aligned with best practices of [check-effect-interations](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) and opens your code to a potential re-entrancy attack in the future.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```jsx // line 381 treasury.updateRentalRate(     _oldOwner,     _user,     user[_oldOwner][index[_oldOwner][_market][_card]].price,     _price,     block.timestamp ); transferCard(_market, _card, _oldOwner, _user, _price); ... // line 449 treasury.updateRentalRate(     _user,     _user,     _price,     _currUser.price,     block.timestamp ); transferCard(_market, _card, _user, _user, _currUser.price); ```  
# Handle  gpersoon   # Vulnerability details  ## Impact The uint32 conversion in setWinner of the RCMarket doesn't work as expected. The first statement: "uint32(block.timestamp)" already first the block.timestamp in a uint32. If it is larger than type(uint32).max it wraps around and starts with 0 again The testcode below shows this.  Check for "<= type(uint32).max" in the second statement is useless because _blockTimestamp is always  <= type(uint32).max  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L507  function setWinner(uint256 _winningOutcome) internal { ...             uint256 _blockTimestamp = uint32(block.timestamp);             require(_blockTimestamp <= type(uint32).max, "Overflow");   //Testcode: pragma solidity 0.8.7; contract Convert {    uint256 public a = uint256( type(uint32).max )+1; // a==4294967296    uint32  public b = uint32(a); // b==0    uint256 public c = uint32(a); // c==0 }     ## Tools Used  ## Recommended Mitigation Steps Do the require first (without a typecast to uint32):              require( block.timestamp <= type(uint32).max, "Overflow");             uint256 _blockTimestamp = uint32(block.timestamp);    
# Handle  gpersoon   # Vulnerability details  ## Impact In the function findNewOwner of RCOrderbook, as loop is done which included the check  _loopCounter < maxDeletions Afterwards a check is done for  "(_loopCounter != maxDeletions)" to determine if the processing is finished. If _loopCounter == maxDeletions then the conclusion is that it isn't finished yet.  However there is the edgecase that the processing might just be finished at the same time as _loopCounter == maxDeletions.  You can see this the best if you assume maxDeletions==1, in that case it will never draw the conclusion it is finished. Of course having maxDeletions==1 is very unlikely in practice.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L549  function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)  external  override  onlyMarkets  { ...         // delete current owner         do {             _newPrice = _removeBidFromOrderbookIgnoreOwner( _head.next, _market, _card );             _loopCounter++;             // delete next bid if foreclosed         } while (    treasury.foreclosureTimeUser( _head.next, _newPrice,  _timeOwnershipChanged ) <  minimumTimeToOwnTo &&                 _loopCounter < maxDeletions );          if (_loopCounter != maxDeletions) {   // the old owner is dead, long live the new owner             _newOwner = ....              ...         } else {             // we hit the limit, save the old owner, we'll try again next time            ...         }     }   ## Tools Used  ## Recommended Mitigation Steps Use a different way to determine that the processing is done. This could save some gas. Note: the additional check also costs gas, so you have the verify the end result.  Perhaps in setDeletionLimit doublecheck that _deletionLimit > 1.  
# Handle  leastwood   # Vulnerability details  ## Impact The `circuitBreaker()` function in `RCMarket.sol` is utilised in the event an oracle never provides a response to a RealityCards question. The function makes an external call to the `RCOrderbook.sol` contract through the `closeMarket()` function. If for some reason the orderbook was unable to be closed, this would never be checked in the `circuitBreaker()` function.  ## Proof of Concept  https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1215-L1223  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Ensure this is intended behaviour, or otherwise validate the response of `orderbook.closeMarket()`. Another option would be to emit the result of the external call in the `LogStateChange` event, alongside the state change.  
# Handle  leastwood   # Vulnerability details  ## Impact There are a number of functions in `RCTreasury.sol` which make external calls to another contract before updating the underlying market balances. More specifically, these affected functions are `deposit()`, `sponsor()`, and `topupMarketBalance()`. As a result, these functions would be prone to reentrancy exploits. However, as `safeTransferFrom()` operates on a trusted ERC20 token (RealityCard's token), this issue is of low severity.  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L385-L391 https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L561-L563 https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L459-L461  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Modify the aforementioned functions such that all state changes are made before a call to the ERC20 token using the `safeTransferFrom()` function.  
# Handle  gpersoon   # Vulnerability details  ## Impact The code has two implementations of msgSender:  -   msgSender() => uses meta transaction signer -  _msgSender() => maps to msg.sender  _msgSender() is used in a few locations - when using _setupRole, this seems legitimate - in function withdraw  (whereas the similar function withdrawWithMetadata uses msgSender() )  It is confusing to have multiple functions with almost the same name, this could easily lead to mistakes.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/lib/NativeMetaTransaction.sol#L105  function msgSender() internal view returns (address payable sender) {         if (msg.sender == address(this)) {             assembly {   sender := shr(96, calldataload(sub(calldatasize(), 20)))   }         } else {              sender = payable(msg.sender);         }         return sender;     }  // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol   function _msgSender() internal view virtual returns (address) {         return msg.sender;     }  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L164   function withdraw(uint256 tokenId) external override {         require(  _msgSender() == ownerOf(tokenId), "ChildMintableERC721: INVALID_TOKEN_OWNER" ); // _msgSender()          withdrawnTokens[tokenId] = true;         _burn(tokenId);     }      function withdrawWithMetadata(uint256 tokenId) external override {         require( msgSender() == ownerOf(tokenId), "ChildMintableERC721: INVALID_TOKEN_OWNER" );  // msgSender()          withdrawnTokens[tokenId] = true;         // Encoding metadata associated with tokenId & emitting event         emit TransferWithMetadata( ownerOf(tokenId), address(0), tokenId, this.encodeTokenMetadata(tokenId) );         _burn(tokenId);     }  RCNftHubL1.sol:      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCNftHubL2.sol:      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCTreasury.sol:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCTreasury.sol:        _setupRole(UBER_OWNER,               _msgSender()); RCTreasury.sol:        _setupRole(OWNER,                         _msgSender()); RCTreasury.sol:        _setupRole(GOVERNOR,                   _msgSender()); RCTreasury.sol:        _setupRole(WHITELIST,                    _msgSender());  ## Tools Used grep  ## Recommended Mitigation Steps Doublecheck the use of  _msgSender() in withdraw and adjust if necessary.  Add comments when using  _msgSender()   Consider overriding _msgSender(), as is done in the example below: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol    
# Handle  gpersoon   # Vulnerability details  ## Impact The function rentAllCards of RCMarket checks for _maxSumOfPrices to see you are not paying more that you want.  However the first part of the calculations (which calculate _actualSumOfPrices ), do not take in account the fact that you might  already own a card. (while the second part of the code does). If you already own the card you don't have to pay for it and you certainly don't have to pay the extra minimumPriceIncreasePercent.  The code at "Proof of Concept" shows a refactored version of the code (see other issue "make code of rentAllCards easier to read"). This immediately shows the issue.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L691 ==> simplified version  function calc(uint256 currentPrice) returns(uint256) {         if (currentPrice == 0)              return MIN_RENTAL_VALUE;         return (currentPrice *(minimumPriceIncreasePercent + 100)) / 100;     }          function rentAllCards(uint256 _maxSumOfPrices) external override {       ..         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             _actualSumOfPrices += calc(card[i].cardPrice);   // no check for  (ownerOf(i) != msgSender()) {         }         require(_actualSumOfPrices <= _maxSumOfPrices, "Prices too high");          for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice=calc(card[i].cardPrice);                 newRental(_newPrice, 0, address(0), i);             }         }     }  ## Tools Used  ## Recommended Mitigation Steps Add "if (ownerOf(i) != msgSender()) {" also in the first part of the code of rentAllCards          uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {              if (ownerOf(i) != msgSender()) {              // extra if statement                  _actualSumOfPrices += calc(card[i].cardPrice);                 }         }         
# Handle  gpersoon   # Vulnerability details  ## Impact The function rentAllCards or RCMarket contains a similar piece of code twice (mainly the formula: (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) / 100; )  The current code is somewhat difficult to read and maintain and hides potential issue (also see other issue about rentAllCards)  ## Proof of Concept //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L691   function rentAllCards(uint256 _maxSumOfPrices) external override {         _checkState(States.OPEN);         // check that not being front run         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             if (card[i].cardPrice == 0) {                 _actualSumOfPrices += MIN_RENTAL_VALUE;             } else {                 _actualSumOfPrices += (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) / 100;             }         }         require(_actualSumOfPrices <= _maxSumOfPrices, "Prices too high");          for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice;                 if (card[i].cardPrice > 0) {                     _newPrice =                         (card[i].cardPrice *                             (minimumPriceIncreasePercent + 100)) /                         100;                 } else {                     _newPrice = MIN_RENTAL_VALUE;                 }                 newRental(_newPrice, 0, address(0), i);             }         }     }   ## Tools Used  ## Recommended Mitigation Steps Suggestion to make the code easier to read and maintain:   function calc(uint256 currentPrice) returns(uint256) {         if (currentPrice == 0)              return MIN_RENTAL_VALUE;         return (currentPrice *(minimumPriceIncreasePercent + 100)) / 100;     }          function rentAllCards(uint256 _maxSumOfPrices) external override {       ..         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             _actualSumOfPrices += calc(card[i].cardPrice);         }         .....         for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice=calc(card[i].cardPrice);                 newRental(_newPrice, 0, address(0), i);             }         }     }   
# Handle  leastwood   # Vulnerability details  ## Impact The variable, `marketWhitelist`, is never initialized in the contract `RCTreasury.sol`. As a result, the function `marketWhitelistCheck()`  does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return `true`, even if a market wishes to restrict its users to a specific role.   ## Proof of Concept  The initial state variable is defined in the link below. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L75  The state variable `marketWhitelist` is accessed in the function `RCTreasury.marketWhitelistCheck()` as per below. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L269-L281  The function `RCTreasury.marketWhitelistCheck()` is called in `RCMarket.newRental()` as seen below. The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in `RCTreasury` that allow a market creator to enable this functionality. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L758-L761  ## Tools Used  `npx hardhat coverage` `slither` Manual code review  ## Recommended Mitigation Steps  Ensure this behaviour is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.  
# Handle  leastwood   # Vulnerability details  ## Impact This issue has no direct security implications, however, there may be some confusion when understanding what the `RCFactory.createMarket()` function actually does.  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L625  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Update the line (linked above) to include the `SAFE_MODE` option outline in the `enum` type in `IRCMarket.sol`. For example, the line `/// @param _mode 0 = normal, 1 = winner takes all` could be updated to `/// @param _mode 0 = normal, 1 = winner takes all, 2 = SAFE_MODE`  
# Handle  gpersoon   # Vulnerability details  ## Impact The function getMarketInfo of RCFactory only can give results back in the range 0...marketInfoResults  Supplying _skipResults doesn't help, it then just skips the first _skipResults  records.  Assume marketInfoResults == 10 and _skipResults == 20: Then no result will be given back because "_resultNumber < marketInfoResults" will never allow _resultNumber  to be bigger than 10  Note: this is low risk because getMarketInfo is a backup function (although you maybe want the backup to function as expected)  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L227   function getMarketInfo( IRCMarket.Mode _mode, uint256 _state, uint256 _skipResults  )  external view         returns ( address[] memory, string[] memory, string[] memory, uint256[] memory ) {            ..         uint256 _resultNumber = 0;        ..         while (_resultNumber < marketInfoResults && _marketIndex > 1) {            ...                 if (_resultNumber < _skipResults) {                     _resultNumber++;                 } else {                     _marketAddresses[_resultNumber] = _market;   // will never reach this part if _skipResults >= marketInfoResults                      ....                     _resultNumber++;                 }             }         }         return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);     }   ## Tools Used  ## Recommended Mitigation Steps Update the code to something like the following:       uint idx;  while (idx < marketInfoResults && _marketIndex > 1) {             _marketIndex--;             address _market = marketAddresses[_mode][_marketIndex];             if (IRCMarket(_market).state() == IRCMarket.States(_state)) {                 if (_resultNumber < _skipResults) {                     _resultNumber++;                 } else {                     _marketAddresses[idx] = _market;                     _ipfsHashes[idx] = ipfsHash[_market];                     _slugs[idx] = addressToSlug[_market];                     _potSizes[idx] = IRCMarket(_market).totalRentCollected();                     idx++;                 }             }         }        
# Handle  gpersoon   # Vulnerability details  ## Impact The function getMostRecentMarket of RCFactory.sol will revert if no markets of the specific mode are created yet.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L171     function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address)     {         return marketAddresses[_mode][marketAddresses[_mode].length - (1)];     }   ## Tools Used  ## Recommended Mitigation Steps Change the function getMostRecentMarket to something like:  function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address) {      if ( marketAddresses[_mode].length ==0) return address(0);      return marketAddresses[_mode][marketAddresses[_mode].length - (1)]; }   
# Handle  gpersoon   # Vulnerability details  ## Impact The function updateTokenURI of RCFactory.sol doesn't update the uris of RCNftHubL2. E.g. it doesn't call setTokenURI to try and update the already created NFT's. This way the URIs of already minted tokens are not updated.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L453  function updateTokenURI(  // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L101 function setTokenURI(uint256 _tokenId, string calldata _tokenURI) external onlyUberOwner {         _setTokenURI(_tokenId, _tokenURI);     }  ## Tools Used  ## Recommended Mitigation Steps Also call setTokenURI of RCNftHubL2 Or restrict updateTokenURI to the phase where no NFT's are minted yet. Or at least add comments to updateTokenURI   
# Handle  gpersoon   # Vulnerability details  ## Impact The contract RCNftHubL2 contains a function addMarket and an array isMarket. This was useful in the previous version of the contract, but now it is no longer used. Note: isMarket() could be used to retrieve the markets from RCNftHubL2, but there are also other ways to do that.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L31 /// @dev so only markets can move NFTs     mapping(address => bool) public isMarket;   /// @dev so only markets can change ownership     function addMarket(address _newMarket) external override {         require(msgSender() == address(factory), "Not factory");         isMarket[_newMarket] = true;     }      // MARKET ONLY     function transferNft( address _currentOwner,  address _newOwner,   uint256 _tokenId ) external override {         require(marketTracker[_tokenId] == msgSender(), "Not market");         _transfer(_currentOwner, _newOwner, _tokenId);     }  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L636 function createMarket( ...  nfthub.addMarket(_newAddress);  ## Tools Used  ## Recommended Mitigation Steps Double check if isMarket and addMarket have any use left. If not remove them from RCNftHubL2 Also remove the call to nfthub.addMarket(_newAddress) from RCFactory.sol  
# Handle  gpersoon   # Vulnerability details  ## Impact Several modifiers are defined, but not used: - onlyTokenOwner in RCMarket.sol - onlyFactory in RCOrderbook.sol and RCLeaderboard.sol  This clutters the code base  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L328     modifier onlyTokenOwner(uint256 _token) {     ...  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L104   modifier onlyFactory() {     ...  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCLeaderboard.sol#L61   modifier onlyFactory() {   ...  ## Tools Used  ## Recommended Mitigation Steps Remove the unused modifiers   
# Handle  gpersoon   # Vulnerability details  ## Impact The function tokenExists does only limited checks on the existence of cards. It doesn't doublecheck that tokenIds[_card] != 0   This is relevant because 0 is the default value of empty array elements. Although this isn't a problem in the current code,  future changes might accidentally introduce vulnerabilities.  Also cards are only valid if they are below numberOfCards. This has led to vulnerabilities in previous versions of the contract (e.g. previous contest)  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1139 function tokenExists(uint256 _card) internal view returns (bool) {         return tokenIds[_card] != type(uint256).max; }  ## Tools Used  ## Recommended Mitigation Steps Change the function to something like the following:  function tokenExists(uint256 _card) internal view returns (bool) {        if (_cardId >= numberOfCards) return false;        if (tokenIds[_card] == 0) return false;        return tokenIds[_card] != type(uint256).max; }   
# Handle  PierrickGT   # Vulnerability details  ## Impact  We can avoid 3 sload by storing `card[winningOutcome]` in a private variable.  We can also avoid 4 sload by storing `msgSender()` in a private variable.  We can also simplify the `_winningsToTransfer` calculation.  ## Proof of Concept  `card[winningOutcome]`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L574 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L589  `msgSender()`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L578 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L591 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L592  `_winningsToTransfer`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L587-L589  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  `card[winningOutcome]`:  ``` Card storage _cardWinningOutcome = card[winningOutcome]; ```  [L574](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L574): `_cardWinningOutcome.rentCollectedPerCard) *`  `msgSender()`:  ``` address _msgSender = msgSender(); ```  [L578](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L578): `(rentCollectedPerUserPerCard[_msgSender][winningOutcome] *`  [L591 to L592](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L591-L592):  ``` _payout(_msgSender, _winningsToTransfer); emit LogWinningsPaid(_msgSender, _winningsToTransfer); ```  `card[winningOutcome]` and `msgSender()`:  [L564](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564): `if (_cardWinningOutcome.longestOwner == _msgSender && winnerCut > 0) {`  [L585](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585): `uint256 _winnersTimeHeld = _cardWinningOutcome.timeHeld[_msgSender];`  `card[winningOutcome]` and `_winningsToTransfer`:  [L587 to L589](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L587-L589): `_winningsToTransfer += (_numerator / _cardWinningOutcome.totalTimeHeld);`   
# Handle  0xsanson   # Vulnerability details  ## Impact In `rcMarket._processRentCollection` it's possible to save a SLOAD by rewriting the lines: ``` uint256 _rentOwed = (card[_card].cardPrice *     (_timeOfCollection - card[_card].timeLastCollected)) / 1 days; uint256 _timeHeldToIncrement = (_timeOfCollection -                    card[_card].timeLastCollected); ``` into: ``` uint256 _timeHeldToIncrement = (_timeOfCollection -                    card[_card].timeLastCollected); uint256 _rentOwed = (card[_card].cardPrice * _timeHeldToIncrement) / 1 days; ```  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1060-L1063  ## Tools Used editor  ## Recommended Mitigation Steps Consider changing the code as illustrated.  
# Handle  JMukesh   # Vulnerability details  ## Impact since the parameter in the constructor are used to initialize the state variable , proper check up should be done , other wise error in these state variable  can lead to redeployment of contract  ## Proof of Concept  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCLeaderboard.sol#L50  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCOrderbook.sol#L136  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L120  ## Tools Used manual review  ## Recommended Mitigation Steps add zero address validation  
# Handle  cmichel   # Vulnerability details  The `RCLeaderboard.market` storage variable is never used. Instead, the `MARKET` role seems to be used to implement authentication.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  
# Handle  JMukesh   # Vulnerability details  ## Impact   referenceContractAddress  is used in createMarket() to create newAddress  for the market , a necessary check should be there that referenceContractAddress exist or not, because if createMarket() is called before setReferenceContractAddress() address(0) will be passed as referenceContractAddress , since addMarket() of treasury and nfthub does not have address validation for the market  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCFactory.sol#L714  ## Tools Used  manual review  ## Recommended Mitigation Steps  add a condition to check the referenceContractAddress  
# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  - `seperate` → `separate` - `incase` → `in case`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  It might be operationally easier (eg. reading permissions via etherscan, saves a few seconds having to search for the bytes32 constant and copy its value) to take in the role of type `string` instead of `bytes32`. It also has an added benefit of overloading the `hasRole()` function, where overriding was desired.  ### Recommended Mitigation Steps  Perhaps add it as an additional function to avoid having to change all `treasury.checkPermissions()` function calls (since the role input has to be modified too).  ```jsx // TODO: add to interface function hasRole(string memory role, address account)  external  view  override  returns (bool) {  bytes32 _role = keccak256(abi.encodePacked(role));  return AccessControl.hasRole(_role, account); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  ```jsx /* setup AccessControl                   UBER_OWNER     ┌───────────┬────┴─────┬────────────┬─────────┐     │           │          │            │         │   OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD     │           │  GOVERNOR     MARKET     │  WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE */ ```  From this diagram, one might expect the existence of a `LEADERBOARD` role, but there is no such role. It should be removed from the diagram.  ### Recommended Mitigation Steps  ```jsx /* setup AccessControl                   UBER_OWNER     ┌───────────┬────┴─────┬────────────┐     │           │          │            │            OWNER      FACTORY    ORDERBOOK   TREASURY     │           │  GOVERNOR     MARKET     │  WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE */ ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The comments above the event declarations were probably copied over from RCOrderbook. They should be modified to refer to the leaderboard.  ### Recommended Mitigation Steps  ```jsx /// @dev emitted every time a user is added to the leaderboard event LogAddToLeaderboard(address _user, address _market, uint256 _card); /// @dev emitted every time a user is removed from the leaderboard event LogRemoveFromLeaderboard(     address _user,     address _market,     uint256 _card ); ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `marketInfoResults` is a parameter used by `getMarketInfo()` to determine the length of results to return. As the `setMarketInfoResults()` comments state, "(it) would be better to pass this as a parameter in getMarketInfo.. however we are limited because of stack too deep errors".  This limitation can be overcome by defining the return array variables as the function output, as suggested below.  The need for `marketInfoResults` and its setter function is then made redundant, whilst making querying results of possibly varying lengths more convenient.  ### Recommended Mitigation Steps  ```jsx function getMarketInfo(   IRCMarket.Mode _mode,   uint256 _state,   uint256 _skipResults,   uint256 _numResults // equivalent of marketInfoResults )   external   view   returns (     address[] memory _marketAddresses,     string[] memory _ipfsHashes,     string[] memory _slugs,     uint256[] memory _potSizes  )  {    uint256 _marketIndex = marketAddresses[_mode].length;        _marketAddresses = new address[](_numResults);    _ipfsHashes = new string[](_numResults);    _slugs = new string[](_numResults);    _potSizes = new uint256[](_numResults);   ... } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Solidity division rounds down, so doing `M / 2 <= N` checks mean that `M` can be at most `2N + 1`.  This affects the following checks:  ```jsx require(  (_tokenURIs.length / 2) <= cardLimit,  "Too many tokens to mint" );  require(   _cardAffiliateAddresses.length == 0 ||    _cardAffiliateAddresses.length == (_tokenURIs.length / 2),   "Card Affiliate Length Error" ) ```  Note that with the current implementation, if `_tokenURIs` is of odd length, its last element will be  redundant, but market creation will not revert.  The stricter checks will partially mitigate `_tokenURIs` having odd length because `_cardAffiliateAddresses` is now required to be exactly twice that of `_tokenURIs`.  ### Recommended Mitigation Steps  These checks should be modified to   ```jsx require(  _tokenURIs.length <= cardLimit * 2,  "Too many tokens to mint" );  require(   _cardAffiliateAddresses.length == 0 ||    _cardAffiliateAddresses.length * 2 == _tokenURIs.length,   "Card Affiliate Length Error" ); ```  In addition, consider adding a check for `_tokenURIs` to strictly be of even length.  `require(_tokenURIs.length % 2 == 0, "TokenURI Length Error");`  
# Handle  0xImpostor   # Vulnerability details  ## Impact  When the current owner of the card is still the new owner of the card, `transferCard` is called before the treasury is updated. While this does not currently pose a risk, it is not aligned with best practices of [check-effect-interations](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) and opens your code to a potential re-entrancy attack in the future.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```jsx // line 381 treasury.updateRentalRate(     _oldOwner,     _user,     user[_oldOwner][index[_oldOwner][_market][_card]].price,     _price,     block.timestamp ); transferCard(_market, _card, _oldOwner, _user, _price); ... // line 449 treasury.updateRentalRate(     _user,     _user,     _price,     _currUser.price,     block.timestamp ); transferCard(_market, _card, _user, _user, _currUser.price); ```  
# Handle  gpersoon   # Vulnerability details  ## Impact The uint32 conversion in setWinner of the RCMarket doesn't work as expected. The first statement: "uint32(block.timestamp)" already first the block.timestamp in a uint32. If it is larger than type(uint32).max it wraps around and starts with 0 again The testcode below shows this.  Check for "<= type(uint32).max" in the second statement is useless because _blockTimestamp is always  <= type(uint32).max  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L507  function setWinner(uint256 _winningOutcome) internal { ...             uint256 _blockTimestamp = uint32(block.timestamp);             require(_blockTimestamp <= type(uint32).max, "Overflow");   //Testcode: pragma solidity 0.8.7; contract Convert {    uint256 public a = uint256( type(uint32).max )+1; // a==4294967296    uint32  public b = uint32(a); // b==0    uint256 public c = uint32(a); // c==0 }     ## Tools Used  ## Recommended Mitigation Steps Do the require first (without a typecast to uint32):              require( block.timestamp <= type(uint32).max, "Overflow");             uint256 _blockTimestamp = uint32(block.timestamp);    
# Handle  gpersoon   # Vulnerability details  ## Impact In the function findNewOwner of RCOrderbook, as loop is done which included the check  _loopCounter < maxDeletions Afterwards a check is done for  "(_loopCounter != maxDeletions)" to determine if the processing is finished. If _loopCounter == maxDeletions then the conclusion is that it isn't finished yet.  However there is the edgecase that the processing might just be finished at the same time as _loopCounter == maxDeletions.  You can see this the best if you assume maxDeletions==1, in that case it will never draw the conclusion it is finished. Of course having maxDeletions==1 is very unlikely in practice.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L549  function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)  external  override  onlyMarkets  { ...         // delete current owner         do {             _newPrice = _removeBidFromOrderbookIgnoreOwner( _head.next, _market, _card );             _loopCounter++;             // delete next bid if foreclosed         } while (    treasury.foreclosureTimeUser( _head.next, _newPrice,  _timeOwnershipChanged ) <  minimumTimeToOwnTo &&                 _loopCounter < maxDeletions );          if (_loopCounter != maxDeletions) {   // the old owner is dead, long live the new owner             _newOwner = ....              ...         } else {             // we hit the limit, save the old owner, we'll try again next time            ...         }     }   ## Tools Used  ## Recommended Mitigation Steps Use a different way to determine that the processing is done. This could save some gas. Note: the additional check also costs gas, so you have the verify the end result.  Perhaps in setDeletionLimit doublecheck that _deletionLimit > 1.  
# Handle  leastwood   # Vulnerability details  ## Impact The `circuitBreaker()` function in `RCMarket.sol` is utilised in the event an oracle never provides a response to a RealityCards question. The function makes an external call to the `RCOrderbook.sol` contract through the `closeMarket()` function. If for some reason the orderbook was unable to be closed, this would never be checked in the `circuitBreaker()` function.  ## Proof of Concept  https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1215-L1223  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Ensure this is intended behaviour, or otherwise validate the response of `orderbook.closeMarket()`. Another option would be to emit the result of the external call in the `LogStateChange` event, alongside the state change.  
# Handle  leastwood   # Vulnerability details  ## Impact There are a number of functions in `RCTreasury.sol` which make external calls to another contract before updating the underlying market balances. More specifically, these affected functions are `deposit()`, `sponsor()`, and `topupMarketBalance()`. As a result, these functions would be prone to reentrancy exploits. However, as `safeTransferFrom()` operates on a trusted ERC20 token (RealityCard's token), this issue is of low severity.  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L385-L391 https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L561-L563 https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L459-L461  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Modify the aforementioned functions such that all state changes are made before a call to the ERC20 token using the `safeTransferFrom()` function.  
# Handle  gpersoon   # Vulnerability details  ## Impact The code has two implementations of msgSender:  -   msgSender() => uses meta transaction signer -  _msgSender() => maps to msg.sender  _msgSender() is used in a few locations - when using _setupRole, this seems legitimate - in function withdraw  (whereas the similar function withdrawWithMetadata uses msgSender() )  It is confusing to have multiple functions with almost the same name, this could easily lead to mistakes.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/lib/NativeMetaTransaction.sol#L105  function msgSender() internal view returns (address payable sender) {         if (msg.sender == address(this)) {             assembly {   sender := shr(96, calldataload(sub(calldatasize(), 20)))   }         } else {              sender = payable(msg.sender);         }         return sender;     }  // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol   function _msgSender() internal view virtual returns (address) {         return msg.sender;     }  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L164   function withdraw(uint256 tokenId) external override {         require(  _msgSender() == ownerOf(tokenId), "ChildMintableERC721: INVALID_TOKEN_OWNER" ); // _msgSender()          withdrawnTokens[tokenId] = true;         _burn(tokenId);     }      function withdrawWithMetadata(uint256 tokenId) external override {         require( msgSender() == ownerOf(tokenId), "ChildMintableERC721: INVALID_TOKEN_OWNER" );  // msgSender()          withdrawnTokens[tokenId] = true;         // Encoding metadata associated with tokenId & emitting event         emit TransferWithMetadata( ownerOf(tokenId), address(0), tokenId, this.encodeTokenMetadata(tokenId) );         _burn(tokenId);     }  RCNftHubL1.sol:      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCNftHubL2.sol:      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCTreasury.sol:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCTreasury.sol:        _setupRole(UBER_OWNER,               _msgSender()); RCTreasury.sol:        _setupRole(OWNER,                         _msgSender()); RCTreasury.sol:        _setupRole(GOVERNOR,                   _msgSender()); RCTreasury.sol:        _setupRole(WHITELIST,                    _msgSender());  ## Tools Used grep  ## Recommended Mitigation Steps Doublecheck the use of  _msgSender() in withdraw and adjust if necessary.  Add comments when using  _msgSender()   Consider overriding _msgSender(), as is done in the example below: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol    
# Handle  gpersoon   # Vulnerability details  ## Impact The function rentAllCards of RCMarket checks for _maxSumOfPrices to see you are not paying more that you want.  However the first part of the calculations (which calculate _actualSumOfPrices ), do not take in account the fact that you might  already own a card. (while the second part of the code does). If you already own the card you don't have to pay for it and you certainly don't have to pay the extra minimumPriceIncreasePercent.  The code at "Proof of Concept" shows a refactored version of the code (see other issue "make code of rentAllCards easier to read"). This immediately shows the issue.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L691 ==> simplified version  function calc(uint256 currentPrice) returns(uint256) {         if (currentPrice == 0)              return MIN_RENTAL_VALUE;         return (currentPrice *(minimumPriceIncreasePercent + 100)) / 100;     }          function rentAllCards(uint256 _maxSumOfPrices) external override {       ..         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             _actualSumOfPrices += calc(card[i].cardPrice);   // no check for  (ownerOf(i) != msgSender()) {         }         require(_actualSumOfPrices <= _maxSumOfPrices, "Prices too high");          for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice=calc(card[i].cardPrice);                 newRental(_newPrice, 0, address(0), i);             }         }     }  ## Tools Used  ## Recommended Mitigation Steps Add "if (ownerOf(i) != msgSender()) {" also in the first part of the code of rentAllCards          uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {              if (ownerOf(i) != msgSender()) {              // extra if statement                  _actualSumOfPrices += calc(card[i].cardPrice);                 }         }         
# Handle  gpersoon   # Vulnerability details  ## Impact The function rentAllCards or RCMarket contains a similar piece of code twice (mainly the formula: (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) / 100; )  The current code is somewhat difficult to read and maintain and hides potential issue (also see other issue about rentAllCards)  ## Proof of Concept //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L691   function rentAllCards(uint256 _maxSumOfPrices) external override {         _checkState(States.OPEN);         // check that not being front run         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             if (card[i].cardPrice == 0) {                 _actualSumOfPrices += MIN_RENTAL_VALUE;             } else {                 _actualSumOfPrices += (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) / 100;             }         }         require(_actualSumOfPrices <= _maxSumOfPrices, "Prices too high");          for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice;                 if (card[i].cardPrice > 0) {                     _newPrice =                         (card[i].cardPrice *                             (minimumPriceIncreasePercent + 100)) /                         100;                 } else {                     _newPrice = MIN_RENTAL_VALUE;                 }                 newRental(_newPrice, 0, address(0), i);             }         }     }   ## Tools Used  ## Recommended Mitigation Steps Suggestion to make the code easier to read and maintain:   function calc(uint256 currentPrice) returns(uint256) {         if (currentPrice == 0)              return MIN_RENTAL_VALUE;         return (currentPrice *(minimumPriceIncreasePercent + 100)) / 100;     }          function rentAllCards(uint256 _maxSumOfPrices) external override {       ..         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             _actualSumOfPrices += calc(card[i].cardPrice);         }         .....         for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice=calc(card[i].cardPrice);                 newRental(_newPrice, 0, address(0), i);             }         }     }   
# Handle  leastwood   # Vulnerability details  ## Impact The variable, `marketWhitelist`, is never initialized in the contract `RCTreasury.sol`. As a result, the function `marketWhitelistCheck()`  does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return `true`, even if a market wishes to restrict its users to a specific role.   ## Proof of Concept  The initial state variable is defined in the link below. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L75  The state variable `marketWhitelist` is accessed in the function `RCTreasury.marketWhitelistCheck()` as per below. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L269-L281  The function `RCTreasury.marketWhitelistCheck()` is called in `RCMarket.newRental()` as seen below. The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in `RCTreasury` that allow a market creator to enable this functionality. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L758-L761  ## Tools Used  `npx hardhat coverage` `slither` Manual code review  ## Recommended Mitigation Steps  Ensure this behaviour is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.  
# Handle  leastwood   # Vulnerability details  ## Impact This issue has no direct security implications, however, there may be some confusion when understanding what the `RCFactory.createMarket()` function actually does.  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L625  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Update the line (linked above) to include the `SAFE_MODE` option outline in the `enum` type in `IRCMarket.sol`. For example, the line `/// @param _mode 0 = normal, 1 = winner takes all` could be updated to `/// @param _mode 0 = normal, 1 = winner takes all, 2 = SAFE_MODE`  
# Handle  gpersoon   # Vulnerability details  ## Impact The function getMarketInfo of RCFactory only can give results back in the range 0...marketInfoResults  Supplying _skipResults doesn't help, it then just skips the first _skipResults  records.  Assume marketInfoResults == 10 and _skipResults == 20: Then no result will be given back because "_resultNumber < marketInfoResults" will never allow _resultNumber  to be bigger than 10  Note: this is low risk because getMarketInfo is a backup function (although you maybe want the backup to function as expected)  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L227   function getMarketInfo( IRCMarket.Mode _mode, uint256 _state, uint256 _skipResults  )  external view         returns ( address[] memory, string[] memory, string[] memory, uint256[] memory ) {            ..         uint256 _resultNumber = 0;        ..         while (_resultNumber < marketInfoResults && _marketIndex > 1) {            ...                 if (_resultNumber < _skipResults) {                     _resultNumber++;                 } else {                     _marketAddresses[_resultNumber] = _market;   // will never reach this part if _skipResults >= marketInfoResults                      ....                     _resultNumber++;                 }             }         }         return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);     }   ## Tools Used  ## Recommended Mitigation Steps Update the code to something like the following:       uint idx;  while (idx < marketInfoResults && _marketIndex > 1) {             _marketIndex--;             address _market = marketAddresses[_mode][_marketIndex];             if (IRCMarket(_market).state() == IRCMarket.States(_state)) {                 if (_resultNumber < _skipResults) {                     _resultNumber++;                 } else {                     _marketAddresses[idx] = _market;                     _ipfsHashes[idx] = ipfsHash[_market];                     _slugs[idx] = addressToSlug[_market];                     _potSizes[idx] = IRCMarket(_market).totalRentCollected();                     idx++;                 }             }         }        
# Handle  gpersoon   # Vulnerability details  ## Impact The function getMostRecentMarket of RCFactory.sol will revert if no markets of the specific mode are created yet.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L171     function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address)     {         return marketAddresses[_mode][marketAddresses[_mode].length - (1)];     }   ## Tools Used  ## Recommended Mitigation Steps Change the function getMostRecentMarket to something like:  function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address) {      if ( marketAddresses[_mode].length ==0) return address(0);      return marketAddresses[_mode][marketAddresses[_mode].length - (1)]; }   
# Handle  gpersoon   # Vulnerability details  ## Impact The function updateTokenURI of RCFactory.sol doesn't update the uris of RCNftHubL2. E.g. it doesn't call setTokenURI to try and update the already created NFT's. This way the URIs of already minted tokens are not updated.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L453  function updateTokenURI(  // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L101 function setTokenURI(uint256 _tokenId, string calldata _tokenURI) external onlyUberOwner {         _setTokenURI(_tokenId, _tokenURI);     }  ## Tools Used  ## Recommended Mitigation Steps Also call setTokenURI of RCNftHubL2 Or restrict updateTokenURI to the phase where no NFT's are minted yet. Or at least add comments to updateTokenURI   
# Handle  gpersoon   # Vulnerability details  ## Impact The contract RCNftHubL2 contains a function addMarket and an array isMarket. This was useful in the previous version of the contract, but now it is no longer used. Note: isMarket() could be used to retrieve the markets from RCNftHubL2, but there are also other ways to do that.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L31 /// @dev so only markets can move NFTs     mapping(address => bool) public isMarket;   /// @dev so only markets can change ownership     function addMarket(address _newMarket) external override {         require(msgSender() == address(factory), "Not factory");         isMarket[_newMarket] = true;     }      // MARKET ONLY     function transferNft( address _currentOwner,  address _newOwner,   uint256 _tokenId ) external override {         require(marketTracker[_tokenId] == msgSender(), "Not market");         _transfer(_currentOwner, _newOwner, _tokenId);     }  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L636 function createMarket( ...  nfthub.addMarket(_newAddress);  ## Tools Used  ## Recommended Mitigation Steps Double check if isMarket and addMarket have any use left. If not remove them from RCNftHubL2 Also remove the call to nfthub.addMarket(_newAddress) from RCFactory.sol  
# Handle  gpersoon   # Vulnerability details  ## Impact Several modifiers are defined, but not used: - onlyTokenOwner in RCMarket.sol - onlyFactory in RCOrderbook.sol and RCLeaderboard.sol  This clutters the code base  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L328     modifier onlyTokenOwner(uint256 _token) {     ...  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L104   modifier onlyFactory() {     ...  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCLeaderboard.sol#L61   modifier onlyFactory() {   ...  ## Tools Used  ## Recommended Mitigation Steps Remove the unused modifiers   
# Handle  gpersoon   # Vulnerability details  ## Impact The function tokenExists does only limited checks on the existence of cards. It doesn't doublecheck that tokenIds[_card] != 0   This is relevant because 0 is the default value of empty array elements. Although this isn't a problem in the current code,  future changes might accidentally introduce vulnerabilities.  Also cards are only valid if they are below numberOfCards. This has led to vulnerabilities in previous versions of the contract (e.g. previous contest)  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1139 function tokenExists(uint256 _card) internal view returns (bool) {         return tokenIds[_card] != type(uint256).max; }  ## Tools Used  ## Recommended Mitigation Steps Change the function to something like the following:  function tokenExists(uint256 _card) internal view returns (bool) {        if (_cardId >= numberOfCards) return false;        if (tokenIds[_card] == 0) return false;        return tokenIds[_card] != type(uint256).max; }   
# Handle  PierrickGT   # Vulnerability details  ## Impact  We can avoid 3 sload by storing `card[winningOutcome]` in a private variable.  We can also avoid 4 sload by storing `msgSender()` in a private variable.  We can also simplify the `_winningsToTransfer` calculation.  ## Proof of Concept  `card[winningOutcome]`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L574 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L589  `msgSender()`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L578 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L591 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L592  `_winningsToTransfer`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L587-L589  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  `card[winningOutcome]`:  ``` Card storage _cardWinningOutcome = card[winningOutcome]; ```  [L574](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L574): `_cardWinningOutcome.rentCollectedPerCard) *`  `msgSender()`:  ``` address _msgSender = msgSender(); ```  [L578](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L578): `(rentCollectedPerUserPerCard[_msgSender][winningOutcome] *`  [L591 to L592](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L591-L592):  ``` _payout(_msgSender, _winningsToTransfer); emit LogWinningsPaid(_msgSender, _winningsToTransfer); ```  `card[winningOutcome]` and `msgSender()`:  [L564](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564): `if (_cardWinningOutcome.longestOwner == _msgSender && winnerCut > 0) {`  [L585](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585): `uint256 _winnersTimeHeld = _cardWinningOutcome.timeHeld[_msgSender];`  `card[winningOutcome]` and `_winningsToTransfer`:  [L587 to L589](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L587-L589): `_winningsToTransfer += (_numerator / _cardWinningOutcome.totalTimeHeld);`   
# Handle  0xsanson   # Vulnerability details  ## Impact In `rcMarket._processRentCollection` it's possible to save a SLOAD by rewriting the lines: ``` uint256 _rentOwed = (card[_card].cardPrice *     (_timeOfCollection - card[_card].timeLastCollected)) / 1 days; uint256 _timeHeldToIncrement = (_timeOfCollection -                    card[_card].timeLastCollected); ``` into: ``` uint256 _timeHeldToIncrement = (_timeOfCollection -                    card[_card].timeLastCollected); uint256 _rentOwed = (card[_card].cardPrice * _timeHeldToIncrement) / 1 days; ```  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1060-L1063  ## Tools Used editor  ## Recommended Mitigation Steps Consider changing the code as illustrated.  
# Handle  JMukesh   # Vulnerability details  ## Impact since the parameter in the constructor are used to initialize the state variable , proper check up should be done , other wise error in these state variable  can lead to redeployment of contract  ## Proof of Concept  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCLeaderboard.sol#L50  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCOrderbook.sol#L136  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L120  ## Tools Used manual review  ## Recommended Mitigation Steps add zero address validation  
# Handle  cmichel   # Vulnerability details  The `RCLeaderboard.market` storage variable is never used. Instead, the `MARKET` role seems to be used to implement authentication.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  
# Handle  JMukesh   # Vulnerability details  ## Impact   referenceContractAddress  is used in createMarket() to create newAddress  for the market , a necessary check should be there that referenceContractAddress exist or not, because if createMarket() is called before setReferenceContractAddress() address(0) will be passed as referenceContractAddress , since addMarket() of treasury and nfthub does not have address validation for the market  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCFactory.sol#L714  ## Tools Used  manual review  ## Recommended Mitigation Steps  add a condition to check the referenceContractAddress  
# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  - `seperate` → `separate` - `incase` → `in case`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  It might be operationally easier (eg. reading permissions via etherscan, saves a few seconds having to search for the bytes32 constant and copy its value) to take in the role of type `string` instead of `bytes32`. It also has an added benefit of overloading the `hasRole()` function, where overriding was desired.  ### Recommended Mitigation Steps  Perhaps add it as an additional function to avoid having to change all `treasury.checkPermissions()` function calls (since the role input has to be modified too).  ```jsx // TODO: add to interface function hasRole(string memory role, address account)  external  view  override  returns (bool) {  bytes32 _role = keccak256(abi.encodePacked(role));  return AccessControl.hasRole(_role, account); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  ```jsx /* setup AccessControl                   UBER_OWNER     ┌───────────┬────┴─────┬────────────┬─────────┐     │           │          │            │         │   OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD     │           │  GOVERNOR     MARKET     │  WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE */ ```  From this diagram, one might expect the existence of a `LEADERBOARD` role, but there is no such role. It should be removed from the diagram.  ### Recommended Mitigation Steps  ```jsx /* setup AccessControl                   UBER_OWNER     ┌───────────┬────┴─────┬────────────┐     │           │          │            │            OWNER      FACTORY    ORDERBOOK   TREASURY     │           │  GOVERNOR     MARKET     │  WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE */ ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The comments above the event declarations were probably copied over from RCOrderbook. They should be modified to refer to the leaderboard.  ### Recommended Mitigation Steps  ```jsx /// @dev emitted every time a user is added to the leaderboard event LogAddToLeaderboard(address _user, address _market, uint256 _card); /// @dev emitted every time a user is removed from the leaderboard event LogRemoveFromLeaderboard(     address _user,     address _market,     uint256 _card ); ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `marketInfoResults` is a parameter used by `getMarketInfo()` to determine the length of results to return. As the `setMarketInfoResults()` comments state, "(it) would be better to pass this as a parameter in getMarketInfo.. however we are limited because of stack too deep errors".  This limitation can be overcome by defining the return array variables as the function output, as suggested below.  The need for `marketInfoResults` and its setter function is then made redundant, whilst making querying results of possibly varying lengths more convenient.  ### Recommended Mitigation Steps  ```jsx function getMarketInfo(   IRCMarket.Mode _mode,   uint256 _state,   uint256 _skipResults,   uint256 _numResults // equivalent of marketInfoResults )   external   view   returns (     address[] memory _marketAddresses,     string[] memory _ipfsHashes,     string[] memory _slugs,     uint256[] memory _potSizes  )  {    uint256 _marketIndex = marketAddresses[_mode].length;        _marketAddresses = new address[](_numResults);    _ipfsHashes = new string[](_numResults);    _slugs = new string[](_numResults);    _potSizes = new uint256[](_numResults);   ... } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Solidity division rounds down, so doing `M / 2 <= N` checks mean that `M` can be at most `2N + 1`.  This affects the following checks:  ```jsx require(  (_tokenURIs.length / 2) <= cardLimit,  "Too many tokens to mint" );  require(   _cardAffiliateAddresses.length == 0 ||    _cardAffiliateAddresses.length == (_tokenURIs.length / 2),   "Card Affiliate Length Error" ) ```  Note that with the current implementation, if `_tokenURIs` is of odd length, its last element will be  redundant, but market creation will not revert.  The stricter checks will partially mitigate `_tokenURIs` having odd length because `_cardAffiliateAddresses` is now required to be exactly twice that of `_tokenURIs`.  ### Recommended Mitigation Steps  These checks should be modified to   ```jsx require(  _tokenURIs.length <= cardLimit * 2,  "Too many tokens to mint" );  require(   _cardAffiliateAddresses.length == 0 ||    _cardAffiliateAddresses.length * 2 == _tokenURIs.length,   "Card Affiliate Length Error" ); ```  In addition, consider adding a check for `_tokenURIs` to strictly be of even length.  `require(_tokenURIs.length % 2 == 0, "TokenURI Length Error");`  
# Handle  0xImpostor   # Vulnerability details  ## Impact  When the current owner of the card is still the new owner of the card, `transferCard` is called before the treasury is updated. While this does not currently pose a risk, it is not aligned with best practices of [check-effect-interations](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) and opens your code to a potential re-entrancy attack in the future.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```jsx // line 381 treasury.updateRentalRate(     _oldOwner,     _user,     user[_oldOwner][index[_oldOwner][_market][_card]].price,     _price,     block.timestamp ); transferCard(_market, _card, _oldOwner, _user, _price); ... // line 449 treasury.updateRentalRate(     _user,     _user,     _price,     _currUser.price,     block.timestamp ); transferCard(_market, _card, _user, _user, _currUser.price); ```  
# Handle  gpersoon   # Vulnerability details  ## Impact The uint32 conversion in setWinner of the RCMarket doesn't work as expected. The first statement: "uint32(block.timestamp)" already first the block.timestamp in a uint32. If it is larger than type(uint32).max it wraps around and starts with 0 again The testcode below shows this.  Check for "<= type(uint32).max" in the second statement is useless because _blockTimestamp is always  <= type(uint32).max  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L507  function setWinner(uint256 _winningOutcome) internal { ...             uint256 _blockTimestamp = uint32(block.timestamp);             require(_blockTimestamp <= type(uint32).max, "Overflow");   //Testcode: pragma solidity 0.8.7; contract Convert {    uint256 public a = uint256( type(uint32).max )+1; // a==4294967296    uint32  public b = uint32(a); // b==0    uint256 public c = uint32(a); // c==0 }     ## Tools Used  ## Recommended Mitigation Steps Do the require first (without a typecast to uint32):              require( block.timestamp <= type(uint32).max, "Overflow");             uint256 _blockTimestamp = uint32(block.timestamp);    
# Handle  gpersoon   # Vulnerability details  ## Impact In the function findNewOwner of RCOrderbook, as loop is done which included the check  _loopCounter < maxDeletions Afterwards a check is done for  "(_loopCounter != maxDeletions)" to determine if the processing is finished. If _loopCounter == maxDeletions then the conclusion is that it isn't finished yet.  However there is the edgecase that the processing might just be finished at the same time as _loopCounter == maxDeletions.  You can see this the best if you assume maxDeletions==1, in that case it will never draw the conclusion it is finished. Of course having maxDeletions==1 is very unlikely in practice.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L549  function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)  external  override  onlyMarkets  { ...         // delete current owner         do {             _newPrice = _removeBidFromOrderbookIgnoreOwner( _head.next, _market, _card );             _loopCounter++;             // delete next bid if foreclosed         } while (    treasury.foreclosureTimeUser( _head.next, _newPrice,  _timeOwnershipChanged ) <  minimumTimeToOwnTo &&                 _loopCounter < maxDeletions );          if (_loopCounter != maxDeletions) {   // the old owner is dead, long live the new owner             _newOwner = ....              ...         } else {             // we hit the limit, save the old owner, we'll try again next time            ...         }     }   ## Tools Used  ## Recommended Mitigation Steps Use a different way to determine that the processing is done. This could save some gas. Note: the additional check also costs gas, so you have the verify the end result.  Perhaps in setDeletionLimit doublecheck that _deletionLimit > 1.  
# Handle  leastwood   # Vulnerability details  ## Impact The `circuitBreaker()` function in `RCMarket.sol` is utilised in the event an oracle never provides a response to a RealityCards question. The function makes an external call to the `RCOrderbook.sol` contract through the `closeMarket()` function. If for some reason the orderbook was unable to be closed, this would never be checked in the `circuitBreaker()` function.  ## Proof of Concept  https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1215-L1223  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Ensure this is intended behaviour, or otherwise validate the response of `orderbook.closeMarket()`. Another option would be to emit the result of the external call in the `LogStateChange` event, alongside the state change.  
# Handle  leastwood   # Vulnerability details  ## Impact There are a number of functions in `RCTreasury.sol` which make external calls to another contract before updating the underlying market balances. More specifically, these affected functions are `deposit()`, `sponsor()`, and `topupMarketBalance()`. As a result, these functions would be prone to reentrancy exploits. However, as `safeTransferFrom()` operates on a trusted ERC20 token (RealityCard's token), this issue is of low severity.  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L385-L391 https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L561-L563 https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L459-L461  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Modify the aforementioned functions such that all state changes are made before a call to the ERC20 token using the `safeTransferFrom()` function.  
# Handle  gpersoon   # Vulnerability details  ## Impact The code has two implementations of msgSender:  -   msgSender() => uses meta transaction signer -  _msgSender() => maps to msg.sender  _msgSender() is used in a few locations - when using _setupRole, this seems legitimate - in function withdraw  (whereas the similar function withdrawWithMetadata uses msgSender() )  It is confusing to have multiple functions with almost the same name, this could easily lead to mistakes.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/lib/NativeMetaTransaction.sol#L105  function msgSender() internal view returns (address payable sender) {         if (msg.sender == address(this)) {             assembly {   sender := shr(96, calldataload(sub(calldatasize(), 20)))   }         } else {              sender = payable(msg.sender);         }         return sender;     }  // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol   function _msgSender() internal view virtual returns (address) {         return msg.sender;     }  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L164   function withdraw(uint256 tokenId) external override {         require(  _msgSender() == ownerOf(tokenId), "ChildMintableERC721: INVALID_TOKEN_OWNER" ); // _msgSender()          withdrawnTokens[tokenId] = true;         _burn(tokenId);     }      function withdrawWithMetadata(uint256 tokenId) external override {         require( msgSender() == ownerOf(tokenId), "ChildMintableERC721: INVALID_TOKEN_OWNER" );  // msgSender()          withdrawnTokens[tokenId] = true;         // Encoding metadata associated with tokenId & emitting event         emit TransferWithMetadata( ownerOf(tokenId), address(0), tokenId, this.encodeTokenMetadata(tokenId) );         _burn(tokenId);     }  RCNftHubL1.sol:      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCNftHubL2.sol:      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCTreasury.sol:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCTreasury.sol:        _setupRole(UBER_OWNER,               _msgSender()); RCTreasury.sol:        _setupRole(OWNER,                         _msgSender()); RCTreasury.sol:        _setupRole(GOVERNOR,                   _msgSender()); RCTreasury.sol:        _setupRole(WHITELIST,                    _msgSender());  ## Tools Used grep  ## Recommended Mitigation Steps Doublecheck the use of  _msgSender() in withdraw and adjust if necessary.  Add comments when using  _msgSender()   Consider overriding _msgSender(), as is done in the example below: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol    
# Handle  gpersoon   # Vulnerability details  ## Impact The function rentAllCards of RCMarket checks for _maxSumOfPrices to see you are not paying more that you want.  However the first part of the calculations (which calculate _actualSumOfPrices ), do not take in account the fact that you might  already own a card. (while the second part of the code does). If you already own the card you don't have to pay for it and you certainly don't have to pay the extra minimumPriceIncreasePercent.  The code at "Proof of Concept" shows a refactored version of the code (see other issue "make code of rentAllCards easier to read"). This immediately shows the issue.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L691 ==> simplified version  function calc(uint256 currentPrice) returns(uint256) {         if (currentPrice == 0)              return MIN_RENTAL_VALUE;         return (currentPrice *(minimumPriceIncreasePercent + 100)) / 100;     }          function rentAllCards(uint256 _maxSumOfPrices) external override {       ..         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             _actualSumOfPrices += calc(card[i].cardPrice);   // no check for  (ownerOf(i) != msgSender()) {         }         require(_actualSumOfPrices <= _maxSumOfPrices, "Prices too high");          for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice=calc(card[i].cardPrice);                 newRental(_newPrice, 0, address(0), i);             }         }     }  ## Tools Used  ## Recommended Mitigation Steps Add "if (ownerOf(i) != msgSender()) {" also in the first part of the code of rentAllCards          uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {              if (ownerOf(i) != msgSender()) {              // extra if statement                  _actualSumOfPrices += calc(card[i].cardPrice);                 }         }         
# Handle  gpersoon   # Vulnerability details  ## Impact The function rentAllCards or RCMarket contains a similar piece of code twice (mainly the formula: (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) / 100; )  The current code is somewhat difficult to read and maintain and hides potential issue (also see other issue about rentAllCards)  ## Proof of Concept //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L691   function rentAllCards(uint256 _maxSumOfPrices) external override {         _checkState(States.OPEN);         // check that not being front run         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             if (card[i].cardPrice == 0) {                 _actualSumOfPrices += MIN_RENTAL_VALUE;             } else {                 _actualSumOfPrices += (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) / 100;             }         }         require(_actualSumOfPrices <= _maxSumOfPrices, "Prices too high");          for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice;                 if (card[i].cardPrice > 0) {                     _newPrice =                         (card[i].cardPrice *                             (minimumPriceIncreasePercent + 100)) /                         100;                 } else {                     _newPrice = MIN_RENTAL_VALUE;                 }                 newRental(_newPrice, 0, address(0), i);             }         }     }   ## Tools Used  ## Recommended Mitigation Steps Suggestion to make the code easier to read and maintain:   function calc(uint256 currentPrice) returns(uint256) {         if (currentPrice == 0)              return MIN_RENTAL_VALUE;         return (currentPrice *(minimumPriceIncreasePercent + 100)) / 100;     }          function rentAllCards(uint256 _maxSumOfPrices) external override {       ..         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             _actualSumOfPrices += calc(card[i].cardPrice);         }         .....         for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice=calc(card[i].cardPrice);                 newRental(_newPrice, 0, address(0), i);             }         }     }   
# Handle  leastwood   # Vulnerability details  ## Impact The variable, `marketWhitelist`, is never initialized in the contract `RCTreasury.sol`. As a result, the function `marketWhitelistCheck()`  does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return `true`, even if a market wishes to restrict its users to a specific role.   ## Proof of Concept  The initial state variable is defined in the link below. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L75  The state variable `marketWhitelist` is accessed in the function `RCTreasury.marketWhitelistCheck()` as per below. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L269-L281  The function `RCTreasury.marketWhitelistCheck()` is called in `RCMarket.newRental()` as seen below. The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in `RCTreasury` that allow a market creator to enable this functionality. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L758-L761  ## Tools Used  `npx hardhat coverage` `slither` Manual code review  ## Recommended Mitigation Steps  Ensure this behaviour is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.  
# Handle  leastwood   # Vulnerability details  ## Impact This issue has no direct security implications, however, there may be some confusion when understanding what the `RCFactory.createMarket()` function actually does.  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L625  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Update the line (linked above) to include the `SAFE_MODE` option outline in the `enum` type in `IRCMarket.sol`. For example, the line `/// @param _mode 0 = normal, 1 = winner takes all` could be updated to `/// @param _mode 0 = normal, 1 = winner takes all, 2 = SAFE_MODE`  
# Handle  gpersoon   # Vulnerability details  ## Impact The function getMarketInfo of RCFactory only can give results back in the range 0...marketInfoResults  Supplying _skipResults doesn't help, it then just skips the first _skipResults  records.  Assume marketInfoResults == 10 and _skipResults == 20: Then no result will be given back because "_resultNumber < marketInfoResults" will never allow _resultNumber  to be bigger than 10  Note: this is low risk because getMarketInfo is a backup function (although you maybe want the backup to function as expected)  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L227   function getMarketInfo( IRCMarket.Mode _mode, uint256 _state, uint256 _skipResults  )  external view         returns ( address[] memory, string[] memory, string[] memory, uint256[] memory ) {            ..         uint256 _resultNumber = 0;        ..         while (_resultNumber < marketInfoResults && _marketIndex > 1) {            ...                 if (_resultNumber < _skipResults) {                     _resultNumber++;                 } else {                     _marketAddresses[_resultNumber] = _market;   // will never reach this part if _skipResults >= marketInfoResults                      ....                     _resultNumber++;                 }             }         }         return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);     }   ## Tools Used  ## Recommended Mitigation Steps Update the code to something like the following:       uint idx;  while (idx < marketInfoResults && _marketIndex > 1) {             _marketIndex--;             address _market = marketAddresses[_mode][_marketIndex];             if (IRCMarket(_market).state() == IRCMarket.States(_state)) {                 if (_resultNumber < _skipResults) {                     _resultNumber++;                 } else {                     _marketAddresses[idx] = _market;                     _ipfsHashes[idx] = ipfsHash[_market];                     _slugs[idx] = addressToSlug[_market];                     _potSizes[idx] = IRCMarket(_market).totalRentCollected();                     idx++;                 }             }         }        
# Handle  gpersoon   # Vulnerability details  ## Impact The function getMostRecentMarket of RCFactory.sol will revert if no markets of the specific mode are created yet.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L171     function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address)     {         return marketAddresses[_mode][marketAddresses[_mode].length - (1)];     }   ## Tools Used  ## Recommended Mitigation Steps Change the function getMostRecentMarket to something like:  function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address) {      if ( marketAddresses[_mode].length ==0) return address(0);      return marketAddresses[_mode][marketAddresses[_mode].length - (1)]; }   
# Handle  gpersoon   # Vulnerability details  ## Impact The function updateTokenURI of RCFactory.sol doesn't update the uris of RCNftHubL2. E.g. it doesn't call setTokenURI to try and update the already created NFT's. This way the URIs of already minted tokens are not updated.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L453  function updateTokenURI(  // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L101 function setTokenURI(uint256 _tokenId, string calldata _tokenURI) external onlyUberOwner {         _setTokenURI(_tokenId, _tokenURI);     }  ## Tools Used  ## Recommended Mitigation Steps Also call setTokenURI of RCNftHubL2 Or restrict updateTokenURI to the phase where no NFT's are minted yet. Or at least add comments to updateTokenURI   
# Handle  gpersoon   # Vulnerability details  ## Impact The contract RCNftHubL2 contains a function addMarket and an array isMarket. This was useful in the previous version of the contract, but now it is no longer used. Note: isMarket() could be used to retrieve the markets from RCNftHubL2, but there are also other ways to do that.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L31 /// @dev so only markets can move NFTs     mapping(address => bool) public isMarket;   /// @dev so only markets can change ownership     function addMarket(address _newMarket) external override {         require(msgSender() == address(factory), "Not factory");         isMarket[_newMarket] = true;     }      // MARKET ONLY     function transferNft( address _currentOwner,  address _newOwner,   uint256 _tokenId ) external override {         require(marketTracker[_tokenId] == msgSender(), "Not market");         _transfer(_currentOwner, _newOwner, _tokenId);     }  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L636 function createMarket( ...  nfthub.addMarket(_newAddress);  ## Tools Used  ## Recommended Mitigation Steps Double check if isMarket and addMarket have any use left. If not remove them from RCNftHubL2 Also remove the call to nfthub.addMarket(_newAddress) from RCFactory.sol  
# Handle  gpersoon   # Vulnerability details  ## Impact Several modifiers are defined, but not used: - onlyTokenOwner in RCMarket.sol - onlyFactory in RCOrderbook.sol and RCLeaderboard.sol  This clutters the code base  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L328     modifier onlyTokenOwner(uint256 _token) {     ...  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L104   modifier onlyFactory() {     ...  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCLeaderboard.sol#L61   modifier onlyFactory() {   ...  ## Tools Used  ## Recommended Mitigation Steps Remove the unused modifiers   
# Handle  gpersoon   # Vulnerability details  ## Impact The function tokenExists does only limited checks on the existence of cards. It doesn't doublecheck that tokenIds[_card] != 0   This is relevant because 0 is the default value of empty array elements. Although this isn't a problem in the current code,  future changes might accidentally introduce vulnerabilities.  Also cards are only valid if they are below numberOfCards. This has led to vulnerabilities in previous versions of the contract (e.g. previous contest)  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1139 function tokenExists(uint256 _card) internal view returns (bool) {         return tokenIds[_card] != type(uint256).max; }  ## Tools Used  ## Recommended Mitigation Steps Change the function to something like the following:  function tokenExists(uint256 _card) internal view returns (bool) {        if (_cardId >= numberOfCards) return false;        if (tokenIds[_card] == 0) return false;        return tokenIds[_card] != type(uint256).max; }   
# Handle  PierrickGT   # Vulnerability details  ## Impact  We can avoid 3 sload by storing `card[winningOutcome]` in a private variable.  We can also avoid 4 sload by storing `msgSender()` in a private variable.  We can also simplify the `_winningsToTransfer` calculation.  ## Proof of Concept  `card[winningOutcome]`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L574 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L589  `msgSender()`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L578 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L591 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L592  `_winningsToTransfer`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L587-L589  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  `card[winningOutcome]`:  ``` Card storage _cardWinningOutcome = card[winningOutcome]; ```  [L574](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L574): `_cardWinningOutcome.rentCollectedPerCard) *`  `msgSender()`:  ``` address _msgSender = msgSender(); ```  [L578](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L578): `(rentCollectedPerUserPerCard[_msgSender][winningOutcome] *`  [L591 to L592](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L591-L592):  ``` _payout(_msgSender, _winningsToTransfer); emit LogWinningsPaid(_msgSender, _winningsToTransfer); ```  `card[winningOutcome]` and `msgSender()`:  [L564](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564): `if (_cardWinningOutcome.longestOwner == _msgSender && winnerCut > 0) {`  [L585](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585): `uint256 _winnersTimeHeld = _cardWinningOutcome.timeHeld[_msgSender];`  `card[winningOutcome]` and `_winningsToTransfer`:  [L587 to L589](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L587-L589): `_winningsToTransfer += (_numerator / _cardWinningOutcome.totalTimeHeld);`   
