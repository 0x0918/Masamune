# Lines of code  https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/amplifier/MuteAmplifier.sol#L88-L121   # Vulnerability details  ## Impact Detailed description of the impact of this finding. There is a division-before-multiplication precision loss issue for update().  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  The update() function has a division-before-multiplication precision loss issue.   First, the calculation of ``perSecondReward`` uses a division:  ```javascript uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime)); ```  Then, the calculation of ``value`` uses a multiplication. ```javascript if (block.timestamp < endTime) {                 value = sinceLastCalc.mul(perSecondReward);             } else {                 uint256 sinceEndTime = block.timestamp.sub(endTime);                 value = (sinceLastCalc.sub(sinceEndTime)).mul(perSecondReward);             } ```  Suppose that the total reward time is one year = 31,536,000 seconds, then the precision loss could be up to 31,536,000, which is significant for ``perSecondReward``.   ## Tools Used VScode  ## Recommended Mitigation Steps Use the multiplication-after-division pattern  Mitigation: use multiplication-before-division instead ```diff modifier update() {         if (_mostRecentValueCalcTime == 0) {             _mostRecentValueCalcTime = firstStakeTime;         }          uint256 totalCurrentStake = totalStake();          if (totalCurrentStake > 0 && _mostRecentValueCalcTime < endTime) {             uint256 value = 0;             uint256 sinceLastCalc = block.timestamp.sub(_mostRecentValueCalcTime); -            uint256 perSecondReward = totalRewards.div(endTime.sub(firstStakeTime)); +            uint256 rewardPeriod = endTime.sub(firstStakeTime);              if (block.timestamp < endTime) { -                value = sinceLastCalc.mul(perSecondReward); +                 value = sinceLastCalc.mul(totalRewards).div(rewardPeriod);             } else {                 uint256 sinceEndTime = block.timestamp.sub(endTime); -                value = (sinceLastCalc.sub(sinceEndTime)).mul(perSecondReward); +                value = (sinceLastCalc.sub(sinceEndTime)).mul(totalRewards).div(rewardPeriod);             }              _totalWeight = _totalWeight.add(value.mul(10**18).div(totalCurrentStake));              _mostRecentValueCalcTime = block.timestamp;              (uint fee0, uint fee1) = IMuteSwitchPairDynamic(lpToken).claimFees();              _totalWeightFee0 = _totalWeightFee0.add(fee0.mul(10**18).div(totalCurrentStake));             _totalWeightFee1 = _totalWeightFee1.add(fee1.mul(10**18).div(totalCurrentStake));              totalFees0 = totalFees0.add(fee0);             totalFees1 = totalFees1.add(fee1);         }          _;     } ``` 
