1.  Title: Using delete statement to empty `rewardsAccrued` can save gas  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L123  Recommended Mitigation Steps: Change to: ```  delete rewardsAccrued[user]; ```  ========================================================================  2.  Title: Using != is more gas efficient  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L167 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L218  Recommended Mitigation Steps: Change to: ```  if (oldRewardBalance != 0) { ```  ========================================================================  3. Title: Using `storage` to declare Struct variable inside function  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L85 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L106  Recommended Mitigation Steps: instead of caching `RewardsState` to memory. read it directly from storage. ```  RewardsState storage state = strategyState[strategy]; ```  ========================================================================  4. Title: Using `calldata` on struct parameter  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L210 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L241  Recommended Mitigation Steps: Using `calldata` to store struct data type can save gas ```  function accrueStrategy(ERC20 strategy, RewardsState calldata state) ```  ========================================================================  5. Title: Using unchecked to calculate can save gas  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelStaticRewards.sol#L60  Recommended Mitigation Steps: `rewards.rewardsEndTimestamp` is checked that it won't `>` than `lastUpdatedTimestamp` ``` unchecked{  elapsed = rewards.rewardsEndTimestamp - lastUpdatedTimestamp; } ```  ========================================================================  6. Title: Using > is cheaper than >=  Proof of Concept: https://github.com/Rari-Capital/solmate/blob/9f16db2144cc9a7e2ffc5588d4bf0b66784283bd/src/tokens/ERC20.sol#L125  Recommended Mitigation Steps: just use `>` can save gas Change to: ```  require(deadline > block.timestamp, "PERMIT_DEADLINE_EXPIRED"); ```  ========================================================================  7. Title: Using `immutable` can save gas  Proof of Concept: https://github.com/Rari-Capital/solmate/blob/9f16db2144cc9a7e2ffc5588d4bf0b66784283bd/src/tokens/ERC20.sol#L23  Recommended Mitigation Steps: use `immutable` to declare variable which set once in constructor  ========================================================================  8. Title: Using multiple `require` instead `&&` can save gas  Proof of Concept: https://github.com/Rari-Capital/solmate/blob/9f16db2144cc9a7e2ffc5588d4bf0b66784283bd/src/tokens/ERC20.sol#L154  Recommended Mitigation Steps: Change to: ```  require(recoveredAddress != address(0), "INVALID_SIGNER");  require(recoveredAddress == owner, "INVALID_SIGNER"); ```  ========================================================================  9. Title: unnecessary value set. the default value of uint is 0.  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L134 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L184 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L307 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L384  Recommended Mitigation Steps: remove 0 value can save gas  ========================================================================
## 1. Put revert on the first line to save gas   ### Summary It is better to put revert before doing anything to save gas  ### POC https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/xERC4626.sol#L79  before '''   function syncRewards() public virtual {   uint192 lastRewardAmount_ = lastRewardAmount;   uint32 timestamp = block.timestamp.safeCastTo32();      if (timestamp < rewardsCycleEnd) revert SyncError();             //some code   } '''  after '''   function syncRewards() public virtual {      uint32 timestamp = block.timestamp.safeCastTo32();      if (timestamp < rewardsCycleEnd) revert SyncError();      uint192 lastRewardAmount_ = lastRewardAmount;      //some code   } '''  ==========================   ## 2. Separate revert condition so revert can be executed earlier to save gas  ### POC https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L461  Before '''   function _addGauge(address gauge) internal returns (uint112 weight) {          bool newAdd = _gauges.add(gauge);          bool previouslyDeprecated = _deprecatedGauges.remove(gauge);          if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGaugeError();          uint32 currentCycle = _getGaugeCycleEnd();   //some codes  }  '''  After '''   function _addGauge(address gauge) internal returns (uint112 weight) {   if(gauge == address(0)) revert InvalidGaugeError();          bool newAdd = _gauges.add(gauge);          bool previouslyDeprecated = _deprecatedGauges.remove(gauge);          if (!(newAdd || previouslyDeprecated)) revert InvalidGaugeError();          uint32 currentCycle = _getGaugeCycleEnd();   //some codes  }  '''  
# QA Report  ## Table of Contents  - [summary](#summary) - [Typos](#typos) - [Comment Missing function parameter](#comment-missing-function-parameter) - [Function missing comments](#function-missing-comments) - [Setters should emit an event](#setters-should-emit-an-event) - [Setters should check the input value](#setters-should-check-the-input-value) - [assert statement should not be used](#assert-statement-should-not-be-used)    # summary  > Few vulnerabilities were found examining the contracts. The main concerns are with the presence of two `assert` statements, which is bad practice. > > Setters should check the input value before updating a storage variable.   # Typos  ## PROBLEM  There are a few typos in the contracts.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  ``` FlywheelCore.sol:97: //user should be secondUser ```    ## TOOLS USED  Manual Analysis    ## MITIGATION  Correct the typos.   # Comment Missing function parameter  ## PROBLEM  Some of the function comments are missing function parameters or returns    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### xTRIBE.sol  ``` xTRIBE.sol:89 address[] calldata accounts ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:133: uint256 numRewards ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:97: address gauge ERC20Gauges.sol:102: address gauge ERC20Gauges.sol:143: address gauge ERC20Gauges.sol:163: address user ERC20Gauges.sol:168: address user, address gauge ERC20Gauges.sol:193: address user ERC20Gauges.sol:198: address user ERC20Gauges.sol:495: address oldGauge, address newGauge ERC20Gauges.sol:510: address account, bool canExceedMax ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:36: address account, uint32 pos ERC20MultiVotes.sol:41: address account ERC20MultiVotes.sol:114: uint256 newMax ERC20MultiVotes.sol:122: address account, bool canExceedMax ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Add a comment for these parameters   # Function missing comments  ## PROBLEM  Some functions are missing comments.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  ``` FlywheelCore.sol:146: _addStrategyForRewards(ERC20 strategy) FlywheelCore.sol:154: getAllStrategies() ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:179:_queueRewards(         address[] memory gauges,         uint32 currentCycle,         uint32 lastCycle,         uint256 totalQueuedForCycle     ) ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:251: _incrementGaugeWeight(         address user,         address gauge,         uint112 weight,         uint32 cycle     ) ERC20Gauges.sol:273: _incrementUserAndGlobalWeights(         address user,         uint112 weight,         uint32 cycle     ) ERC20Gauges.sol:334: _decrementGaugeWeight(         address user,         address gauge,         uint112 weight,         uint32 cycle     )  ERC20Gauges.sol:353: _decrementUserAndGlobalWeights(         address user,         uint112 weight,         uint32 cycle     ) ERC20Gauges.sol:457: _addGauge(address gauge) ERC20Gauges.sol:479: _removeGauge(address gauge) ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:236: _incrementDelegation(         address delegator,         address delegatee,         uint256 amount     ) ERC20MultiVotes.sol:258: _undelegate(         address delegator,         address delegatee,         uint256 amount     ) ERC20MultiVotes.sol:276: _writeCheckpoint(         address delegatee,         function(uint256, uint256) ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add comments to these functions  # Setters should emit an event  ## PROBLEM  All setters should emit an event, so the Dapps can detect important changes    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:273:setRewardsStream(IRewardsStream newRewardsStream)  ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add the following event to the contract, and emit it at the end of the function ``` event RewardsStreamUpdated(IRewardsStream newRewardsStream); ```  # Setters should check the input value  ## PROBLEM  Setters should check the input value - ie make revert if it is the zero address or zero    ## SEVERITY  Low     ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  ``` FlywheelCore.sol:165:setFlywheelRewards(IFlywheelRewards newFlywheelRewards) FlywheelCore.sol:183:setBooster(IFlywheelBooster newBooster) ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:273:setRewardsStream(IRewardsStream newRewardsStream) ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:502:setMaxGauges(uint256 newMax) ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:502:setMaxDelegates(uint256 newMax) ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add non-zero checks   # assert statement should not be used  ## IMPACT  Properly functioning code should never reach a failing assert statement. If it happened, it would indicate the presence of a bug in the contract. A failing assert uses all the remaining gas, which can be financially painful for a user.   ## SEVERITY  Low    ## PROOF OF CONCEPT  Instances include:  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:196: assert(queuedRewards.storedCycle == 0 || queuedRewards.storedCycle >= lastCycle); FlywheelGaugeRewards.sol:235: assert(queuedRewards.storedCycle >= cycle); ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace the assert statement with a require statement or a custom error   
# Gas Report  ## Table of Contents  - [Caching storage variables in memory to save gas](#caching-storage-variables-in-memory-to-save-gas) - [Calldata instead of memory for RO function parameters](#calldata-instead-of-memory-for-ro-function-parameters)  - [Comparison operators](#comparison-operators) - [Custom errors](#custom-errors) - [Default value initialization](#default-value-initialization) - [Prefix increments](#prefix-increments) - [Shifting cheaper than division](#shifting-cheaper-than-division) - [unnecessary computation](#unnecessary-computation)  # Caching storage variables in memory to save gas   ## IMPACT  Anytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable in memory: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.     ## PROOF OF CONCEPT  Instances include:  ### FlywheelCore.sol  scope: `setFlywheelRewards()`   - `flywheelRewards` is read twice:  ``` FlywheelCore.sol:166 FlywheelCore.sol:168 ```  scope: `accrueStrategy()`  - `flywheelBooster` is read twice:  ``` FlywheelCore.sol:220 FlywheelCore.sol:221 ```  scope: `accrueUser()`  - `flywheelBooster` is read twice:  ``` FlywheelCore.sol:258 FlywheelCore.sol:259 ```       ## TOOLS USED  Manual Analysis    ## MITIGATION  cache these storage variables in memory  # Calldata instead of memory for RO function parameters   ## PROBLEM  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.  Try to use calldata as a data location because it will avoid copies and also makes sure that the data cannot be modified.  ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  scope: `accrueStrategy()` ``` FlywheelCore.sol:210: RewardsState memory state ```  scope: `accrueUser()` ``` FlywheelCore.sol:241: RewardsState memory state ```  ### FlywheelGaugeRewards.sol  scope: `_queueRewards()` ``` FlywheelGaugeRewards.sol:180: address[] memory gauges ```   ## TOOLS USED  Manual Analysis   ## MITIGATION  Replace `memory` with `calldata`      # Comparison Operators   ## IMPACT  In the EVM, there is no opcode for ` >=` or `<=`. When using greater than or equal, two operations are performed: `>` and `=`.  Using strict comparison operators hence saves gas    ## PROOF OF CONCEPT  Instances include:  ### FlywheelGaugeRewards.sol ``` FlywheelGaugeRewards.sol:107 FlywheelGaugeRewards.sol:139 FlywheelGaugeRewards.sol:154 FlywheelGaugeRewards.sol:163 FlywheelGaugeRewards.sol:200 ```  ### ERC20Gauges.sol ``` ERC20Gauges.sol:259 ```  ### ERC20MultiVotes.sol ``` ERC20MultiVotes.sol:379 ```      ## TOOLS USED  Manual Analysis     ## MITIGATION  Replace `<=` with `<`, and `>=` with `>`. Do not forget to increment/decrement the compared variable  example:  ``` -cycle - block.timestamp <= incrementFreezeWindow; +cycle - block.timestamp < incrementFreezeWindow + 1; ```  However, if `1` is negligible compared to the value of the variable, we can omit the increment.  example:  ``` -cycle - block.timestamp <= incrementFreezeWindow; +cycle - block.timestamp < incrementFreezeWindow; ```   # Custom Errors   ## IMPACT  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information, as explained [here](https://blog.soliditylang.org/2021/04/21/custom-errors/)  Custom errors are defined using the error statement    ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  ``` FlywheelCore.sol:147 ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:114 FlywheelGaugeRewards.sol:153 FlywheelGaugeRewards.sol:154 FlywheelGaugeRewards.sol:195 FlywheelGaugeRewards.sol:200 ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:345 ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:266 ERC20MultiVotes.sol:352 ERC20MultiVotes.sol:379 ERC20MultiVotes.sol:392 ERC20MultiVotes.sol:393 ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace require and revert statements with custom errors.  For instance, in `FlywheelGaugeRewards.sol`:  Replace ``` require(newRewards <= type(uint112).max); ```  with  ``` if (newRewards > type(uint112).max) {   revert IsNotSafeCast(newRewards); } ```  and define the custom error in the contract ``` error IsNotSafeCast(uint256 newRewards); ```   # Default value initialization   ## IMPACT  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    ## PROOF OF CONCEPT  Instances include:    ### xTribe.sol  ``` xTribe.sol:95: uint256 i = 0; ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:189: uint256 i = 0; ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:134: uint256 i = 0; ERC20Gauges.sol:184: uint256 i = 0; ERC20Gauges.sol:307: uint256 i = 0; ERC20Gauges.sol:384: uint256 i = 0; ERC20Gauges.sol:564: uint256 i = 0; ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:79: uint256 low = 0; ERC20MultiVotes.sol:346: uint256 i = 0; ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Remove explicit initialization for default values.      # Prefix increments   ## IMPACT  Prefix increments are cheaper than postfix increments.     ## PROOF OF CONCEPT  Instances include:   ### xTRIBE.sol  ``` xTRIBE.sol:99 ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:189 ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:137 ERC20Gauges.sol:187 ERC20Gauges.sol:314 ERC20Gauges.sol:391 ERC20Gauges.sol:576 ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:346 ERC20MultiVotes.sol:392 ```     ## TOOLS USED  Manual Analysis    ## MITIGATION  change `variable++` to `++variable`.      # Shifting cheaper than division  ## IMPACT   A division by 2 can be calculated by shifting one to the right. While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.    ## PROOF OF CONCEPT  Instances include:  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes:94: return (a & b) + (a ^ b) / 2; ```    ## TOOLS USED  Manual Analysis    ## MITIGATION  ``` -return (a & b) + (a ^ b) / 2; +return (a & b) + (a ^ b) >> 1; ```    # Unnecessary computation  ## IMPACT  When emitting an event that includes a new and an old value, it is cheaper in gas to avoid caching the old value in memory. Instead, emit the event, then save the new value in storage.    ## PROOF OF CONCEPT  Instances include:    ### ERC20Gauges.sol  ``` ERC20Gauges.sol:506 ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:118 ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace ``` uint256 oldMax = maxDelegates; maxDelegates = newMax; emit MaxDelegatesUpdate(oldMax, newMax); ```  with  ``` emit MaxDelegatesUpdate(maxDelegates, newMax); maxDelegates = newMax; ```  
# Gas optimizations  * Use delete in the `claimRewards` function of the `FlywheelCore` contract and in the `_decrementVotesUntilFree` function of the `ERC20MultiVotes` contract in order to trigger a gas refund * Loops can be optimized in several ways. Let's take for example the loop in the `incrementGauges` function in `ERC20Gauges` (There is also a loop in the `decrementGauges` function which is similar).     ```sol     // Update gauge specific state     for (uint256 i = 0; i < size; ) {         address gauge = gaugeList[i];         uint112 weight = weights[i];         weightsSum += weight;          _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);         unchecked {             i++;         }     }     ```     We can do multiple things here:     1. Variables in solidity are already initialized to their default value, and initializing them to the same value actually costs more gas. So for example in the loop above, the code can be optimized using `uint i;` instead of `uint i = 0;`.     2. Use ++i instead of i++ to save some gas spent in every iteration.      Let's look at another example:      ```sol     uint256 size = gaugeList.length;     for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight; ) {         address gauge = gaugeList[i];         uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];         if (userGaugeWeight != 0) {             // If the gauge is live (not deprecated), include its weight in the total to remove             if (!_deprecatedGauges.contains(gauge)) {                 totalFreed += userGaugeWeight;             }             userFreed += userGaugeWeight;             _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);              unchecked {                 i++;             }         }     }     ```     First of all, the optimizations from the loop before can be done here too. In addition, there is another optimization that can be done here - the condition of the loop contains 2 conditions - `i < size && (userFreeWeight + totalFreed) < weight`.     In order to avoid calculating `userFreeWeight + totalFreed` in every iteration, you can calculate `weight - userFreeWeight` (let's assume that `weightLeftToFree == weight - userFreeWeight`) once and change the condition to `totalFreed < weightLeftToFree`. You can also use unchecked on the calculation of `weightLeftToFree` because you know for sure that `weight > userFreeWeight` (or there was no weight to free).    * Use unchecked in `_incrementDelegation` and `_undelegate` in `ERC20MultiVotes` In the `_incrementDelegation` function you increment both `_delegatesVotesCount[delegator][delegatee]` and `userDelegatedVotes[delegator]`. We know for sure that `_delegatesVotesCount[delegator][delegatee] <= userDelegatedVotes[delegator]`, because `userDelegatedVotes[delegator]` is incremented at least any time that `_delegatesVotesCount[delegator][delegatee]` (it's also incremented when delegating other delegatees), so unchecked can be used when incrementing `_delegatesVotesCount[delegator][delegatee]` because if it will overflow `userDelegatedVotes[delegator]` will overflow too.     We can see a similar thing in the `_undelegate` function. In that function we decrement both `_delegatesVotesCount[delegator][delegatee]` and `userDelegatedVotes[delegator]`, and for the same reason we know that if `userDelegatedVotes[delegator]` will underflow, `_delegatesVotesCount[delegator][delegatee]` will underflow too, so we can use unchecked when decrementing `userDelegatedVotes[delegator]`.      ```sol     function _incrementDelegation(         address delegator,         address delegatee,         uint256 amount     ) internal virtual {         // ...          userDelegatedVotes[delegator] += amount;         unchecked {             _delegatesVotesCount[delegator][delegatee] += amount;         }                  // ...     }      function _undelegate(             address delegator,             address delegatee,             uint256 amount         ) internal virtual {             uint256 newDelegates = _delegatesVotesCount[delegator][delegatee] - amount;                          // ...              _delegatesVotesCount[delegator][delegatee] = newDelegates;             unchecked {                 userDelegatedVotes[delegator] -= amount;             }     ``` 
# Lows and non critical * Typo in the `accrue` function of the `FlyWheelCore` contract - `@notice accrue rewards for a two users on a strategy` (`a` is not needed) * Pragmas should be locked to a specific compiler version, to avoid contracts getting deployed using a different version, which may have a greater risk of undiscovered bugs. * Remove the delegatee anyway (not only if the votes are not zero) - that will make the set not contain delegatees with zero votes     ```sol     function _decrementVotesUntilFree(address user, uint256 votes) internal {         // ...         for (uint256 i = 0; i < size && (userFreeVotes + totalFreed) < votes; i++) {             address delegatee = delegateList[i];             uint256 delegateVotes = _delegatesVotesCount[user][delegatee];             if (delegateVotes != 0) {                 totalFreed += delegateVotes;                                  require(_delegates[user].remove(delegatee)); // Remove from set. Should never fail.                                  _delegatesVotesCount[user][delegatee] = 0;                 _writeCheckpoint(delegatee, _subtract, delegateVotes);                                  emit Undelegation(user, delegatee, delegateVotes);             }         }         userDelegatedVotes[user] -= totalFreed;     }     ``` 
Issue: Duplicate import https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/StakerVault.sol#L9-L10 ```solidity import "../libraries/Errors.sol"; import "../libraries/Errors.sol"; ``` Remove duplicate import  Issue: Require message too long Explanation: The require errors below return error messages (found in Errors.sol) that can be shortened to 32 characters or fewer (as shown) to save gas.   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L67 ```solidity         require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); ``` Error string: "insufficient funds for updating the position"  Change to "insufficient funds to update pos"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L218 ```solidity         require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE); ``` Error string: "token not usable for the specific action"  Change to "token not usable for this action"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L578 ```solidity             Error.ESTIMATED_GAS_TOO_HIGH ``` Error string: "too much ETH will be used for gas"  Change to "too much ETH to be used for gas"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L585 ```solidity             Error.GAS_BANK_BALANCE_TOO_LOW ``` Error string: "not enough ETH in gas bank to cover gas"  Change to "gas bank lacks ETH to cover gas"  The following two lines use the same error message: https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L159 ```solidity         require(vars.poolImplementation != address(0), Error.INVALID_POOL_IMPLEMENTATION); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L182 ```solidity                 Error.INVALID_POOL_IMPLEMENTATION ``` Error string: "invalid pool implementation for given coin"  Change to "invalid pool imp for given coin"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L162 ```solidity         require(vars.lpTokenImplementation != address(0), Error.INVALID_LP_TOKEN_IMPLEMENTATION); ``` Error string: "invalid LP Token implementation for given coin"  Change to "inv LP Token imp for given coin"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L165 ```solidity         require(vars.vaultImplementation != address(0), Error.INVALID_VAULT_IMPLEMENTATION); ``` Error string: "invalid vault implementation for given coin"  Change to "invalid vault imp for given coin"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L172 ```solidity             Error.INVALID_STAKER_VAULT_IMPLEMENTATION ``` Error string: "invalid stakerVault implementation for given coin"  Change to "invalid stakerVault imp for coin"   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/Vault.sol#L165 ```solidity         require(IPausable(pool).isPaused(), Error.POOL_NOT_PAUSED); ``` Error string: "Pool must be paused to withdraw from reserve"  Change to "Pool must be paused to withdraw"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/AddressProvider.sol#L285 ```solidity         require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS); ``` Error string: "a staker vault already exists for the token"  Change to "a staker vault exists for token"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/CvxCrvRewardsLocker.sol#L85 ```solidity             Error.EXCEEDS_MAX_BOOST ``` Error string: "Not allowed to exceed maximum boost on Convex"  Change to "Can't exceed max boost on Convex"  Issue: Should use != 0 instead of > 0 in a require statement if variable is an unsigned integer (uint)  Explanation: != 0 should be used instead of > 0 where possible since > 0 costs more gas.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L210 ```solidity         require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT); ``` Change 'record.singleTopUpAmount > 0' to 'record.singleTopUpAmount != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L554 ```solidity         require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE); ``` Change 'position.totalTopUpAmount > 0' to 'position.totalTopUpAmount != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpActionFeeHandler.sol#L123 ```solidity         require(totalClaimable > 0, Error.NOTHING_TO_CLAIM); ``` Change 'totalClaimable > 0' to 'totalClaimable != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L401 ```solidity         require(_depositCap > 0, Error.INVALID_AMOUNT); ``` Change '_depositCap > 0' to '_depositCap != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L471 ```solidity         require(underlyingAmount > 0, Error.INVALID_AMOUNT); ``` Change 'underlyingAmount > 0' to 'underlyingAmount != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L549 ```solidity         require(redeemLpTokens > 0, Error.INVALID_AMOUNT); ``` Change 'redeemLpTokens > 0' to 'redeemLpTokens != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/Vault.sol#L164 ```solidity         require(amount > 0, Error.INVALID_AMOUNT); ``` Change 'amount > 0' to 'amount != 0'   Issue: Should use additional require instead of && within a require function Explanation: Using require instead of && saves gas   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L359-L363 ```solidity         require(             newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&                 newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,             Error.INVALID_AMOUNT         ); ``` Change to:         require(newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE, Error.INVALID_AMOUNT);         require(newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE, Error.INVALID_AMOUNT);    https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L676 ```solidity         require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED); ``` Change to:         require(vars.success, Error.TOP_UP_FAILED);         require(abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);    https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/ConvexStrategyBase.sol#L273-L276 ```solidity         require(             token_ != address(_CVX) && token_ != address(underlying) && token_ != address(_CRV),             Error.INVALID_TOKEN_TO_ADD         ); ``` Change to:         require(token_ != address(_CVX), Error.INVALID_TOKEN_TO_ADD);         require(token_ != address(underlying), Error.INVALID_TOKEN_TO_ADD);         require(token_ != address(_CRV), Error.INVALID_TOKEN_TO_ADD);   Issue: Variables should not be initialized to their default values Explanation: Initializing variables to their default values is unnecessary and costs gas.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L483 ```solidity         uint256 currentFeeRatio = 0; ``` Change 'uint256 currentFeeRatio = 0;' to 'uint256 currentFeeRatio;'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/StakerVault.sol#L144 ```solidity         uint256 startingAllowance = 0; ``` Change 'uint256 startingAllowance = 0;' to 'uint256 startingAllowance;'         
# Lines of code  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L547-L583   # Vulnerability details  ## Impact In `_decrementWeightUntilFree`, the free weight is calculated by `balanceOf[user] - getUserWeight[user]` plus weight freed from non-deprecated gauges. The non-deprecated criteria is unnecessary and lead to incorrect accounting of free weight.  ## Proof of Concept https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L547-L583 ```     function _decrementWeightUntilFree(address user, uint256 weight) internal {         uint256 userFreeWeight = balanceOf[user] - getUserWeight[user];          // early return if already free         if (userFreeWeight >= weight) return;          uint32 currentCycle = _getGaugeCycleEnd();          // cache totals for batch updates         uint112 userFreed;         uint112 totalFreed;          // Loop through all user gauges, live and deprecated         address[] memory gaugeList = _userGauges[user].values();          // Free gauges until through entire list or under weight         uint256 size = gaugeList.length;         for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight; ) {             address gauge = gaugeList[i];             uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];             if (userGaugeWeight != 0) {                 // If the gauge is live (not deprecated), include its weight in the total to remove                 if (!_deprecatedGauges.contains(gauge)) {                     totalFreed += userGaugeWeight;                 }                 userFreed += userGaugeWeight;                 _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);                  unchecked {                     i++;                 }             }         }          getUserWeight[user] -= userFreed;         _writeGaugeWeight(_totalWeight, _subtract, totalFreed, currentCycle);     } ``` Consider Alice allocated 3 weight to gauge D, gauge A and gauge B equally where gauge D is depricated 1. Alice call _decrementWeightUntilFree(alice, 2) 2. userFreeWeight = 0 3. gauge D is freed, totalFreed = 0, userFreed = 1 4. (userFreeWeight + totalFreed) < weight, continue to free next gauge 5. gauge A is freed, totalFreed = 1, userFreed = 2 6. (userFreeWeight + totalFreed) < weight, continue to free next gauge 7. gauge B is freed, totalFreed = 2, userFreed = 3 8. All gauge is freed  Alternatively, Alice can 1. Alice call _decrementWeightUntilFree(alice, 1) 2. userFreeWeight = balanceOf[alice] - getUserWeight[alice] = 3 - 3 = 0 3. gauge D is freed, totalFreed = 0, userFreed = 1 4. (userFreeWeight + totalFreed) < weight, continue to free next gauge 5. gauge A is freed, totalFreed = 1, userFreed = 2 6. (userFreeWeight + totalFreed) >= weight, break 7. getUserWeight[alice] -= totalFreed 8. Alice call _decrementWeightUntilFree(alice, 2) 9. userFreeWeight = balanceOf[alice] - getUserWeight[alice] = 3 - 1 = 2 10. (userFreeWeight + totalFreed) >= weight, break 11. Only 2 gauge is freed  ## Recommended Mitigation Steps No need to treat deprecated gauge seperately  
# Unnecessary checked arithmetic in for loops There is no risk of overflow caused by increments to the iteration index in for loops (the `i++` in `for (uint256 i = 0; i < numIterations; i++)`). Increments perform overflow checks that are not necessary in this case.  ### Recommendation Surround the increment expressions with an `unchecked { ... }` block to avoid the default overflow checks. For example, change the loop ``` for (uint256 i = 0; i < numIterations; i++) {  // ... } ``` to ``` for (uint256 i = 0; i < numIterations;) {  // ...  unchecked { i++; } } ``` It is a little less readable but it saves a significant amount of gas.  # Unnecessary SLOADs and MLOADs in for-each loops There are many for loops that follows this for-each pattern: ``` for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` } ``` In such for loops, the `array.length` is read on every iteration, instead of caching it once in a local variable and read it from there. Storage reads are much more expensive than reading local variables. Memory reads are a bit more expensive than reading local variables.  ### Recommendation Read these values from storage / memory once, cache them in local variables and then read them again from the local variables. For example: ``` uint256 length = array.length; for (uint256 i = 0; i < length; i++) {  // do something with `array[i]` } ```  # Prefix increments / decrements are cheaper than postfix increments / decrements Use prefix increments / decrements (++x / --x) instead of postfix increments / decrements (x++ / x--).  ### Recommendation Change all postfix increments / decrements to prefix increments / decrements.
# Save gas in for loops by unchecked arithmetic  The for loop has no overflow risk of `i`. Use an unchecked block to save gas.  ## Proof of Concept  ``` flywheel-v2/src/token/ERC20MultiVotes.sol 346:        for (uint256 i = 0; i < size && (userFreeVotes + totalFreed) < votes; i++) {  flywheel-v2/src/rewards/FlywheelGaugeRewards.sol 189:        for (uint256 i = 0; i < size; i++) { ```  ## Recommendation  Use `unchecked` blocks to avoid overflow checks, or use `++i` rather than `i++` if you don't use unchecked blocks.  ``` for (uint256 i = 0; i < length; ) {     ...     unchecked {         ++i;     } } ```  
# Summary We list 2 low-critical findings and 2 non-critical findings: * (Low) Doesn’t check whether `newFlywheelRewards` is valid in `setFlywheelRewards()` * (Low) floating pragma * (Non) Using ecrecover is against best practice * (Non) It’s better to emit an event in `setRewardsStream`  # (Low) Doesn’t check whether `newFlywheelRewards` is valid in `setFlywheelRewards()`   ## Impact  Doesn’t check whether `newFlywheelRewards` is valid in `setFlywheelRewards()`. It may be a invalid or malicious. it should add some kind of check  ## Proof of Concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L165  ```     function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {         uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));         if (oldRewardBalance > 0) {             rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);         }          flywheelRewards = newFlywheelRewards;          emit FlywheelRewardsUpdate(address(newFlywheelRewards));     }  ```  ## Tools Used  vim  ## Recommended Mitigation Steps  Check whether `newFlywheelRewards` is valid # (Low) floating pragma  ## Impact  Floating pragma may cause unexpected compilation time behaviour and introduce unintended bugs.  ## Proof of Concept  Contracts have floating pragma problems.  https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L4  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L3  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L4    ## Tools Used  vim  ## Recommended Mitigation Steps  Don't use `^`, lock pragma to ensure compiler version. e.g. `pragma solidity 0.8.0;`   # (Non) Using ecrecover is against best practice  ## Impact  Using ecrecover is against best practice. Preferably use ECDSA.recover instead. EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature unique. However it should be impossible to be a threat by now.   ## Proof of Concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L380  ## Tools Used  vim  ## Recommended Mitigation Steps  Take these implementation into consideration  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/cryptography/draft-EIP712.sol  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-ERC20Permit.sol  # (Non) It’s better to emit an event in `setRewardsStream`  ## Impact  In the function `setRewardsStream` in flywheel-v2/src/rewards/FlywheelGaugeRewards.sol, it’s better to emit an event.  ## Proof of Concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L273  ## Tools Used  vim, ethers.js  ## Recommended Mitigation Steps  Emit an event in set function:  ```      function setRewardsStream(IRewardsStream newRewardsStream) external requiresAuth {          rewardsStream = newRewardsStream; +        emit RewardsStreamUpdate(address(newRewardsStream));      } ``` 
## 1. `i++` can be replaced with `++i`   ++i consumes less gas than than i++, as the return value of post increment is not used, so it can be replaced with pre increment   ### Proof of concept  https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L99  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L137  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L187  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L314  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L391  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L576  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189  ### Mitigation  post increment can be replaced with pre-increment   ## 2. Avoid initialising variables with default values  When variables are created it contains the default values, explicit initialising with default values is unnecessary  ### Proof of concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L134  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L184  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L307  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L384  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L564  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189  ### Mitigation   Initialising default values can be avoided  ## 3. division can be replaced with shift operator  Shift operator consumed less gas when compared to division, so it can be replaced to save some gas  ### Proof of concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L94  ```     return (a & b) + (a ^ b) / 2; ```  ### Mitigation  Division can be replaced with shift operator  ```     return (a & b) + ((a ^ b) >> 1); ```  
  ## for loops can be optimized  Index increments in most of the for loops are unchecked, but a couple are still checked. Also, prefix increments are cheaper than postfix increments.   ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189     ## Redundant initialisation with default value  Some variables are initialised with their default values which cause unnecessary gas consumption  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L134 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L184 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L307 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L384 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L564 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L79 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189 https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L95     ## Error string longer than 32 characters  Error reason strings take space in the deployed bytecode. Every reason string takes at least 32 bytes so make sure your string fits in 32 bytes or it will become more expensive.   ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L379     ## Non-zero amount check missing before transfers  It is a good practice to apply non-zero amount checks for transfers to avoid unnecessary executions.  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L527 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L532 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L541 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L312 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L317 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L326 https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L121 https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L132 https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L147     ## Public state variables can be private  Private state variables are cheaper than public state variables. There are many instances where public variables can be private.  ### Lines of code There are many instances, some of which are: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L59 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L63 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L108 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L111 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L35 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L38 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L41 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L76 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L204 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L207     ## Booleans are more expensive than uint256  It is more expensive to operate using booleans because before every write operation an SLOAD is executed to read the contents of the slot. Therefore, it is cheaper to use uint256 instead of bool. On the other hand, using bool is better for the code readability. Hence, it is a tradeoff to be decided by the developers.  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L450 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L111  ### Recommended Mitigation Steps Consider replacing booleans with uint256 if gas efficiency overweighs code readability.     ## Constants can be made private  There is no need for these constants to be public. Changing them to private would save gas.   ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L368 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L201     ## Some internal functions can be made private  Calling private functions are cheaper than calling internal functions. Therefore, it is better to declare functions private if they are not called from inherited contracts.  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L89 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L108 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L256 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L277 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L339 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L357 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L457 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L479 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L92 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L216 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L236 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L262 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L146 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L184   ### Recommended Mitigation Steps Change the visibility to private where possible.     ## average() function can be eliminated  average() is used only once. Therefore, it can be eliminated and the calculation can be implemented where the function is called.  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L81 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L92  ### Recommended Mitigation Steps Line 81 can be changed as -->             uint256 mid = (low & high) + (low ^ high) / 2; And average() function can be deleted. 
# Lines of code  https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L65-L68   # Vulnerability details  https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L65-L68  ```solidity function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {     super.beforeWithdraw(amount, shares);     storedTotalAssets -= amount; } ```  https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L78-L87  ```solidity function syncRewards() public virtual {     uint192 lastRewardAmount_ = lastRewardAmount;     uint32 timestamp = block.timestamp.safeCastTo32();      if (timestamp < rewardsCycleEnd) revert SyncError();      uint256 storedTotalAssets_ = storedTotalAssets;     uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;      storedTotalAssets = storedTotalAssets_ + lastRewardAmount_; // SSTORE     ... ```  `storedTotalAssets` is a cached value of total assets which will only include the `unlockedRewards` when the whole cycle ends.  This makes it possible for `storedTotalAssets -= amount` to revert when the withdrawal amount exceeds `storedTotalAssets`, as the withdrawal amount may include part of the `unlockedRewards` in the current cycle.  ### PoC  Given:  - rewardsCycleLength = 100 days  1. Alice `deposit()` 100 TRIBE tokens; 2. The owner transferred 100 TRIBE tokens as rewards and called `syncRewards()`; 3. 1 day later, Alice `redeem()` with all shares, the transaction will revert at `xERC4626.beforeWithdraw()`.  Alice's shares worth 101 TRIBE at this moment, but `storedTotalAssets` = 100, making `storedTotalAssets -= amount` reverts due to underflow.  4. Bob `deposit()` 1 TRIBE tokens; 5. Alice `withdraw()` 101 TRIBE tokens, `storedTotalAssets` becomes `0`; 6. Bob can't even withdraw 1 wei of TRIBE token, as `storedTotalAssets` is now `0`.  If there are no new deposits, both Alice and Bob won't be able to withdraw any of their funds until `rewardsCycleEnd`.  ### Recommendation  Consider changing to:  ```solidity function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {     super.beforeWithdraw(amount, shares);     uint256 _storedTotalAssets = storedTotalAssets;     if (amount >= _storedTotalAssets) {         uint256 _totalAssets = totalAssets();         // _totalAssets - _storedTotalAssets == unlockedRewards         lastRewardAmount -= _totalAssets - _storedTotalAssets;         lastSync = block.timestamp;         storedTotalAssets = _totalAssets - amount;     } else {         storedTotalAssets = _storedTotalAssets - amount;     } } ```  
1.  Title: Using delete statement to empty `rewardsAccrued` can save gas  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L123  Recommended Mitigation Steps: Change to: ```  delete rewardsAccrued[user]; ```  ========================================================================  2.  Title: Using != is more gas efficient  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L167 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L218  Recommended Mitigation Steps: Change to: ```  if (oldRewardBalance != 0) { ```  ========================================================================  3. Title: Using `storage` to declare Struct variable inside function  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L85 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L106  Recommended Mitigation Steps: instead of caching `RewardsState` to memory. read it directly from storage. ```  RewardsState storage state = strategyState[strategy]; ```  ========================================================================  4. Title: Using `calldata` on struct parameter  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L210 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L241  Recommended Mitigation Steps: Using `calldata` to store struct data type can save gas ```  function accrueStrategy(ERC20 strategy, RewardsState calldata state) ```  ========================================================================  5. Title: Using unchecked to calculate can save gas  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelStaticRewards.sol#L60  Recommended Mitigation Steps: `rewards.rewardsEndTimestamp` is checked that it won't `>` than `lastUpdatedTimestamp` ``` unchecked{  elapsed = rewards.rewardsEndTimestamp - lastUpdatedTimestamp; } ```  ========================================================================  6. Title: Using > is cheaper than >=  Proof of Concept: https://github.com/Rari-Capital/solmate/blob/9f16db2144cc9a7e2ffc5588d4bf0b66784283bd/src/tokens/ERC20.sol#L125  Recommended Mitigation Steps: just use `>` can save gas Change to: ```  require(deadline > block.timestamp, "PERMIT_DEADLINE_EXPIRED"); ```  ========================================================================  7. Title: Using `immutable` can save gas  Proof of Concept: https://github.com/Rari-Capital/solmate/blob/9f16db2144cc9a7e2ffc5588d4bf0b66784283bd/src/tokens/ERC20.sol#L23  Recommended Mitigation Steps: use `immutable` to declare variable which set once in constructor  ========================================================================  8. Title: Using multiple `require` instead `&&` can save gas  Proof of Concept: https://github.com/Rari-Capital/solmate/blob/9f16db2144cc9a7e2ffc5588d4bf0b66784283bd/src/tokens/ERC20.sol#L154  Recommended Mitigation Steps: Change to: ```  require(recoveredAddress != address(0), "INVALID_SIGNER");  require(recoveredAddress == owner, "INVALID_SIGNER"); ```  ========================================================================  9. Title: unnecessary value set. the default value of uint is 0.  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L134 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L184 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L307 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L384  Recommended Mitigation Steps: remove 0 value can save gas  ========================================================================
## 1. Put revert on the first line to save gas   ### Summary It is better to put revert before doing anything to save gas  ### POC https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/xERC4626.sol#L79  before '''   function syncRewards() public virtual {   uint192 lastRewardAmount_ = lastRewardAmount;   uint32 timestamp = block.timestamp.safeCastTo32();      if (timestamp < rewardsCycleEnd) revert SyncError();             //some code   } '''  after '''   function syncRewards() public virtual {      uint32 timestamp = block.timestamp.safeCastTo32();      if (timestamp < rewardsCycleEnd) revert SyncError();      uint192 lastRewardAmount_ = lastRewardAmount;      //some code   } '''  ==========================   ## 2. Separate revert condition so revert can be executed earlier to save gas  ### POC https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L461  Before '''   function _addGauge(address gauge) internal returns (uint112 weight) {          bool newAdd = _gauges.add(gauge);          bool previouslyDeprecated = _deprecatedGauges.remove(gauge);          if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGaugeError();          uint32 currentCycle = _getGaugeCycleEnd();   //some codes  }  '''  After '''   function _addGauge(address gauge) internal returns (uint112 weight) {   if(gauge == address(0)) revert InvalidGaugeError();          bool newAdd = _gauges.add(gauge);          bool previouslyDeprecated = _deprecatedGauges.remove(gauge);          if (!(newAdd || previouslyDeprecated)) revert InvalidGaugeError();          uint32 currentCycle = _getGaugeCycleEnd();   //some codes  }  '''  
# QA Report  ## Table of Contents  - [summary](#summary) - [Typos](#typos) - [Comment Missing function parameter](#comment-missing-function-parameter) - [Function missing comments](#function-missing-comments) - [Setters should emit an event](#setters-should-emit-an-event) - [Setters should check the input value](#setters-should-check-the-input-value) - [assert statement should not be used](#assert-statement-should-not-be-used)    # summary  > Few vulnerabilities were found examining the contracts. The main concerns are with the presence of two `assert` statements, which is bad practice. > > Setters should check the input value before updating a storage variable.   # Typos  ## PROBLEM  There are a few typos in the contracts.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  ``` FlywheelCore.sol:97: //user should be secondUser ```    ## TOOLS USED  Manual Analysis    ## MITIGATION  Correct the typos.   # Comment Missing function parameter  ## PROBLEM  Some of the function comments are missing function parameters or returns    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### xTRIBE.sol  ``` xTRIBE.sol:89 address[] calldata accounts ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:133: uint256 numRewards ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:97: address gauge ERC20Gauges.sol:102: address gauge ERC20Gauges.sol:143: address gauge ERC20Gauges.sol:163: address user ERC20Gauges.sol:168: address user, address gauge ERC20Gauges.sol:193: address user ERC20Gauges.sol:198: address user ERC20Gauges.sol:495: address oldGauge, address newGauge ERC20Gauges.sol:510: address account, bool canExceedMax ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:36: address account, uint32 pos ERC20MultiVotes.sol:41: address account ERC20MultiVotes.sol:114: uint256 newMax ERC20MultiVotes.sol:122: address account, bool canExceedMax ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Add a comment for these parameters   # Function missing comments  ## PROBLEM  Some functions are missing comments.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  ``` FlywheelCore.sol:146: _addStrategyForRewards(ERC20 strategy) FlywheelCore.sol:154: getAllStrategies() ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:179:_queueRewards(         address[] memory gauges,         uint32 currentCycle,         uint32 lastCycle,         uint256 totalQueuedForCycle     ) ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:251: _incrementGaugeWeight(         address user,         address gauge,         uint112 weight,         uint32 cycle     ) ERC20Gauges.sol:273: _incrementUserAndGlobalWeights(         address user,         uint112 weight,         uint32 cycle     ) ERC20Gauges.sol:334: _decrementGaugeWeight(         address user,         address gauge,         uint112 weight,         uint32 cycle     )  ERC20Gauges.sol:353: _decrementUserAndGlobalWeights(         address user,         uint112 weight,         uint32 cycle     ) ERC20Gauges.sol:457: _addGauge(address gauge) ERC20Gauges.sol:479: _removeGauge(address gauge) ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:236: _incrementDelegation(         address delegator,         address delegatee,         uint256 amount     ) ERC20MultiVotes.sol:258: _undelegate(         address delegator,         address delegatee,         uint256 amount     ) ERC20MultiVotes.sol:276: _writeCheckpoint(         address delegatee,         function(uint256, uint256) ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add comments to these functions  # Setters should emit an event  ## PROBLEM  All setters should emit an event, so the Dapps can detect important changes    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:273:setRewardsStream(IRewardsStream newRewardsStream)  ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add the following event to the contract, and emit it at the end of the function ``` event RewardsStreamUpdated(IRewardsStream newRewardsStream); ```  # Setters should check the input value  ## PROBLEM  Setters should check the input value - ie make revert if it is the zero address or zero    ## SEVERITY  Low     ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  ``` FlywheelCore.sol:165:setFlywheelRewards(IFlywheelRewards newFlywheelRewards) FlywheelCore.sol:183:setBooster(IFlywheelBooster newBooster) ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:273:setRewardsStream(IRewardsStream newRewardsStream) ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:502:setMaxGauges(uint256 newMax) ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:502:setMaxDelegates(uint256 newMax) ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add non-zero checks   # assert statement should not be used  ## IMPACT  Properly functioning code should never reach a failing assert statement. If it happened, it would indicate the presence of a bug in the contract. A failing assert uses all the remaining gas, which can be financially painful for a user.   ## SEVERITY  Low    ## PROOF OF CONCEPT  Instances include:  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:196: assert(queuedRewards.storedCycle == 0 || queuedRewards.storedCycle >= lastCycle); FlywheelGaugeRewards.sol:235: assert(queuedRewards.storedCycle >= cycle); ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace the assert statement with a require statement or a custom error   
# Gas Report  ## Table of Contents  - [Caching storage variables in memory to save gas](#caching-storage-variables-in-memory-to-save-gas) - [Calldata instead of memory for RO function parameters](#calldata-instead-of-memory-for-ro-function-parameters)  - [Comparison operators](#comparison-operators) - [Custom errors](#custom-errors) - [Default value initialization](#default-value-initialization) - [Prefix increments](#prefix-increments) - [Shifting cheaper than division](#shifting-cheaper-than-division) - [unnecessary computation](#unnecessary-computation)  # Caching storage variables in memory to save gas   ## IMPACT  Anytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable in memory: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.     ## PROOF OF CONCEPT  Instances include:  ### FlywheelCore.sol  scope: `setFlywheelRewards()`   - `flywheelRewards` is read twice:  ``` FlywheelCore.sol:166 FlywheelCore.sol:168 ```  scope: `accrueStrategy()`  - `flywheelBooster` is read twice:  ``` FlywheelCore.sol:220 FlywheelCore.sol:221 ```  scope: `accrueUser()`  - `flywheelBooster` is read twice:  ``` FlywheelCore.sol:258 FlywheelCore.sol:259 ```       ## TOOLS USED  Manual Analysis    ## MITIGATION  cache these storage variables in memory  # Calldata instead of memory for RO function parameters   ## PROBLEM  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.  Try to use calldata as a data location because it will avoid copies and also makes sure that the data cannot be modified.  ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  scope: `accrueStrategy()` ``` FlywheelCore.sol:210: RewardsState memory state ```  scope: `accrueUser()` ``` FlywheelCore.sol:241: RewardsState memory state ```  ### FlywheelGaugeRewards.sol  scope: `_queueRewards()` ``` FlywheelGaugeRewards.sol:180: address[] memory gauges ```   ## TOOLS USED  Manual Analysis   ## MITIGATION  Replace `memory` with `calldata`      # Comparison Operators   ## IMPACT  In the EVM, there is no opcode for ` >=` or `<=`. When using greater than or equal, two operations are performed: `>` and `=`.  Using strict comparison operators hence saves gas    ## PROOF OF CONCEPT  Instances include:  ### FlywheelGaugeRewards.sol ``` FlywheelGaugeRewards.sol:107 FlywheelGaugeRewards.sol:139 FlywheelGaugeRewards.sol:154 FlywheelGaugeRewards.sol:163 FlywheelGaugeRewards.sol:200 ```  ### ERC20Gauges.sol ``` ERC20Gauges.sol:259 ```  ### ERC20MultiVotes.sol ``` ERC20MultiVotes.sol:379 ```      ## TOOLS USED  Manual Analysis     ## MITIGATION  Replace `<=` with `<`, and `>=` with `>`. Do not forget to increment/decrement the compared variable  example:  ``` -cycle - block.timestamp <= incrementFreezeWindow; +cycle - block.timestamp < incrementFreezeWindow + 1; ```  However, if `1` is negligible compared to the value of the variable, we can omit the increment.  example:  ``` -cycle - block.timestamp <= incrementFreezeWindow; +cycle - block.timestamp < incrementFreezeWindow; ```   # Custom Errors   ## IMPACT  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information, as explained [here](https://blog.soliditylang.org/2021/04/21/custom-errors/)  Custom errors are defined using the error statement    ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  ``` FlywheelCore.sol:147 ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:114 FlywheelGaugeRewards.sol:153 FlywheelGaugeRewards.sol:154 FlywheelGaugeRewards.sol:195 FlywheelGaugeRewards.sol:200 ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:345 ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:266 ERC20MultiVotes.sol:352 ERC20MultiVotes.sol:379 ERC20MultiVotes.sol:392 ERC20MultiVotes.sol:393 ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace require and revert statements with custom errors.  For instance, in `FlywheelGaugeRewards.sol`:  Replace ``` require(newRewards <= type(uint112).max); ```  with  ``` if (newRewards > type(uint112).max) {   revert IsNotSafeCast(newRewards); } ```  and define the custom error in the contract ``` error IsNotSafeCast(uint256 newRewards); ```   # Default value initialization   ## IMPACT  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    ## PROOF OF CONCEPT  Instances include:    ### xTribe.sol  ``` xTribe.sol:95: uint256 i = 0; ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:189: uint256 i = 0; ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:134: uint256 i = 0; ERC20Gauges.sol:184: uint256 i = 0; ERC20Gauges.sol:307: uint256 i = 0; ERC20Gauges.sol:384: uint256 i = 0; ERC20Gauges.sol:564: uint256 i = 0; ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:79: uint256 low = 0; ERC20MultiVotes.sol:346: uint256 i = 0; ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Remove explicit initialization for default values.      # Prefix increments   ## IMPACT  Prefix increments are cheaper than postfix increments.     ## PROOF OF CONCEPT  Instances include:   ### xTRIBE.sol  ``` xTRIBE.sol:99 ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:189 ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:137 ERC20Gauges.sol:187 ERC20Gauges.sol:314 ERC20Gauges.sol:391 ERC20Gauges.sol:576 ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:346 ERC20MultiVotes.sol:392 ```     ## TOOLS USED  Manual Analysis    ## MITIGATION  change `variable++` to `++variable`.      # Shifting cheaper than division  ## IMPACT   A division by 2 can be calculated by shifting one to the right. While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.    ## PROOF OF CONCEPT  Instances include:  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes:94: return (a & b) + (a ^ b) / 2; ```    ## TOOLS USED  Manual Analysis    ## MITIGATION  ``` -return (a & b) + (a ^ b) / 2; +return (a & b) + (a ^ b) >> 1; ```    # Unnecessary computation  ## IMPACT  When emitting an event that includes a new and an old value, it is cheaper in gas to avoid caching the old value in memory. Instead, emit the event, then save the new value in storage.    ## PROOF OF CONCEPT  Instances include:    ### ERC20Gauges.sol  ``` ERC20Gauges.sol:506 ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:118 ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace ``` uint256 oldMax = maxDelegates; maxDelegates = newMax; emit MaxDelegatesUpdate(oldMax, newMax); ```  with  ``` emit MaxDelegatesUpdate(maxDelegates, newMax); maxDelegates = newMax; ```  
# Gas optimizations  * Use delete in the `claimRewards` function of the `FlywheelCore` contract and in the `_decrementVotesUntilFree` function of the `ERC20MultiVotes` contract in order to trigger a gas refund * Loops can be optimized in several ways. Let's take for example the loop in the `incrementGauges` function in `ERC20Gauges` (There is also a loop in the `decrementGauges` function which is similar).     ```sol     // Update gauge specific state     for (uint256 i = 0; i < size; ) {         address gauge = gaugeList[i];         uint112 weight = weights[i];         weightsSum += weight;          _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);         unchecked {             i++;         }     }     ```     We can do multiple things here:     1. Variables in solidity are already initialized to their default value, and initializing them to the same value actually costs more gas. So for example in the loop above, the code can be optimized using `uint i;` instead of `uint i = 0;`.     2. Use ++i instead of i++ to save some gas spent in every iteration.      Let's look at another example:      ```sol     uint256 size = gaugeList.length;     for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight; ) {         address gauge = gaugeList[i];         uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];         if (userGaugeWeight != 0) {             // If the gauge is live (not deprecated), include its weight in the total to remove             if (!_deprecatedGauges.contains(gauge)) {                 totalFreed += userGaugeWeight;             }             userFreed += userGaugeWeight;             _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);              unchecked {                 i++;             }         }     }     ```     First of all, the optimizations from the loop before can be done here too. In addition, there is another optimization that can be done here - the condition of the loop contains 2 conditions - `i < size && (userFreeWeight + totalFreed) < weight`.     In order to avoid calculating `userFreeWeight + totalFreed` in every iteration, you can calculate `weight - userFreeWeight` (let's assume that `weightLeftToFree == weight - userFreeWeight`) once and change the condition to `totalFreed < weightLeftToFree`. You can also use unchecked on the calculation of `weightLeftToFree` because you know for sure that `weight > userFreeWeight` (or there was no weight to free).    * Use unchecked in `_incrementDelegation` and `_undelegate` in `ERC20MultiVotes` In the `_incrementDelegation` function you increment both `_delegatesVotesCount[delegator][delegatee]` and `userDelegatedVotes[delegator]`. We know for sure that `_delegatesVotesCount[delegator][delegatee] <= userDelegatedVotes[delegator]`, because `userDelegatedVotes[delegator]` is incremented at least any time that `_delegatesVotesCount[delegator][delegatee]` (it's also incremented when delegating other delegatees), so unchecked can be used when incrementing `_delegatesVotesCount[delegator][delegatee]` because if it will overflow `userDelegatedVotes[delegator]` will overflow too.     We can see a similar thing in the `_undelegate` function. In that function we decrement both `_delegatesVotesCount[delegator][delegatee]` and `userDelegatedVotes[delegator]`, and for the same reason we know that if `userDelegatedVotes[delegator]` will underflow, `_delegatesVotesCount[delegator][delegatee]` will underflow too, so we can use unchecked when decrementing `userDelegatedVotes[delegator]`.      ```sol     function _incrementDelegation(         address delegator,         address delegatee,         uint256 amount     ) internal virtual {         // ...          userDelegatedVotes[delegator] += amount;         unchecked {             _delegatesVotesCount[delegator][delegatee] += amount;         }                  // ...     }      function _undelegate(             address delegator,             address delegatee,             uint256 amount         ) internal virtual {             uint256 newDelegates = _delegatesVotesCount[delegator][delegatee] - amount;                          // ...              _delegatesVotesCount[delegator][delegatee] = newDelegates;             unchecked {                 userDelegatedVotes[delegator] -= amount;             }     ``` 
# Lows and non critical * Typo in the `accrue` function of the `FlyWheelCore` contract - `@notice accrue rewards for a two users on a strategy` (`a` is not needed) * Pragmas should be locked to a specific compiler version, to avoid contracts getting deployed using a different version, which may have a greater risk of undiscovered bugs. * Remove the delegatee anyway (not only if the votes are not zero) - that will make the set not contain delegatees with zero votes     ```sol     function _decrementVotesUntilFree(address user, uint256 votes) internal {         // ...         for (uint256 i = 0; i < size && (userFreeVotes + totalFreed) < votes; i++) {             address delegatee = delegateList[i];             uint256 delegateVotes = _delegatesVotesCount[user][delegatee];             if (delegateVotes != 0) {                 totalFreed += delegateVotes;                                  require(_delegates[user].remove(delegatee)); // Remove from set. Should never fail.                                  _delegatesVotesCount[user][delegatee] = 0;                 _writeCheckpoint(delegatee, _subtract, delegateVotes);                                  emit Undelegation(user, delegatee, delegateVotes);             }         }         userDelegatedVotes[user] -= totalFreed;     }     ``` 
Issue: Duplicate import https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/StakerVault.sol#L9-L10 ```solidity import "../libraries/Errors.sol"; import "../libraries/Errors.sol"; ``` Remove duplicate import  Issue: Require message too long Explanation: The require errors below return error messages (found in Errors.sol) that can be shortened to 32 characters or fewer (as shown) to save gas.   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L67 ```solidity         require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); ``` Error string: "insufficient funds for updating the position"  Change to "insufficient funds to update pos"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L218 ```solidity         require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE); ``` Error string: "token not usable for the specific action"  Change to "token not usable for this action"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L578 ```solidity             Error.ESTIMATED_GAS_TOO_HIGH ``` Error string: "too much ETH will be used for gas"  Change to "too much ETH to be used for gas"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L585 ```solidity             Error.GAS_BANK_BALANCE_TOO_LOW ``` Error string: "not enough ETH in gas bank to cover gas"  Change to "gas bank lacks ETH to cover gas"  The following two lines use the same error message: https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L159 ```solidity         require(vars.poolImplementation != address(0), Error.INVALID_POOL_IMPLEMENTATION); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L182 ```solidity                 Error.INVALID_POOL_IMPLEMENTATION ``` Error string: "invalid pool implementation for given coin"  Change to "invalid pool imp for given coin"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L162 ```solidity         require(vars.lpTokenImplementation != address(0), Error.INVALID_LP_TOKEN_IMPLEMENTATION); ``` Error string: "invalid LP Token implementation for given coin"  Change to "inv LP Token imp for given coin"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L165 ```solidity         require(vars.vaultImplementation != address(0), Error.INVALID_VAULT_IMPLEMENTATION); ``` Error string: "invalid vault implementation for given coin"  Change to "invalid vault imp for given coin"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L172 ```solidity             Error.INVALID_STAKER_VAULT_IMPLEMENTATION ``` Error string: "invalid stakerVault implementation for given coin"  Change to "invalid stakerVault imp for coin"   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/Vault.sol#L165 ```solidity         require(IPausable(pool).isPaused(), Error.POOL_NOT_PAUSED); ``` Error string: "Pool must be paused to withdraw from reserve"  Change to "Pool must be paused to withdraw"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/AddressProvider.sol#L285 ```solidity         require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS); ``` Error string: "a staker vault already exists for the token"  Change to "a staker vault exists for token"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/CvxCrvRewardsLocker.sol#L85 ```solidity             Error.EXCEEDS_MAX_BOOST ``` Error string: "Not allowed to exceed maximum boost on Convex"  Change to "Can't exceed max boost on Convex"  Issue: Should use != 0 instead of > 0 in a require statement if variable is an unsigned integer (uint)  Explanation: != 0 should be used instead of > 0 where possible since > 0 costs more gas.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L210 ```solidity         require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT); ``` Change 'record.singleTopUpAmount > 0' to 'record.singleTopUpAmount != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L554 ```solidity         require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE); ``` Change 'position.totalTopUpAmount > 0' to 'position.totalTopUpAmount != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpActionFeeHandler.sol#L123 ```solidity         require(totalClaimable > 0, Error.NOTHING_TO_CLAIM); ``` Change 'totalClaimable > 0' to 'totalClaimable != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L401 ```solidity         require(_depositCap > 0, Error.INVALID_AMOUNT); ``` Change '_depositCap > 0' to '_depositCap != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L471 ```solidity         require(underlyingAmount > 0, Error.INVALID_AMOUNT); ``` Change 'underlyingAmount > 0' to 'underlyingAmount != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L549 ```solidity         require(redeemLpTokens > 0, Error.INVALID_AMOUNT); ``` Change 'redeemLpTokens > 0' to 'redeemLpTokens != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/Vault.sol#L164 ```solidity         require(amount > 0, Error.INVALID_AMOUNT); ``` Change 'amount > 0' to 'amount != 0'   Issue: Should use additional require instead of && within a require function Explanation: Using require instead of && saves gas   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L359-L363 ```solidity         require(             newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&                 newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,             Error.INVALID_AMOUNT         ); ``` Change to:         require(newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE, Error.INVALID_AMOUNT);         require(newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE, Error.INVALID_AMOUNT);    https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L676 ```solidity         require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED); ``` Change to:         require(vars.success, Error.TOP_UP_FAILED);         require(abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);    https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/ConvexStrategyBase.sol#L273-L276 ```solidity         require(             token_ != address(_CVX) && token_ != address(underlying) && token_ != address(_CRV),             Error.INVALID_TOKEN_TO_ADD         ); ``` Change to:         require(token_ != address(_CVX), Error.INVALID_TOKEN_TO_ADD);         require(token_ != address(underlying), Error.INVALID_TOKEN_TO_ADD);         require(token_ != address(_CRV), Error.INVALID_TOKEN_TO_ADD);   Issue: Variables should not be initialized to their default values Explanation: Initializing variables to their default values is unnecessary and costs gas.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L483 ```solidity         uint256 currentFeeRatio = 0; ``` Change 'uint256 currentFeeRatio = 0;' to 'uint256 currentFeeRatio;'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/StakerVault.sol#L144 ```solidity         uint256 startingAllowance = 0; ``` Change 'uint256 startingAllowance = 0;' to 'uint256 startingAllowance;'         
# Lines of code  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L547-L583   # Vulnerability details  ## Impact In `_decrementWeightUntilFree`, the free weight is calculated by `balanceOf[user] - getUserWeight[user]` plus weight freed from non-deprecated gauges. The non-deprecated criteria is unnecessary and lead to incorrect accounting of free weight.  ## Proof of Concept https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L547-L583 ```     function _decrementWeightUntilFree(address user, uint256 weight) internal {         uint256 userFreeWeight = balanceOf[user] - getUserWeight[user];          // early return if already free         if (userFreeWeight >= weight) return;          uint32 currentCycle = _getGaugeCycleEnd();          // cache totals for batch updates         uint112 userFreed;         uint112 totalFreed;          // Loop through all user gauges, live and deprecated         address[] memory gaugeList = _userGauges[user].values();          // Free gauges until through entire list or under weight         uint256 size = gaugeList.length;         for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight; ) {             address gauge = gaugeList[i];             uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];             if (userGaugeWeight != 0) {                 // If the gauge is live (not deprecated), include its weight in the total to remove                 if (!_deprecatedGauges.contains(gauge)) {                     totalFreed += userGaugeWeight;                 }                 userFreed += userGaugeWeight;                 _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);                  unchecked {                     i++;                 }             }         }          getUserWeight[user] -= userFreed;         _writeGaugeWeight(_totalWeight, _subtract, totalFreed, currentCycle);     } ``` Consider Alice allocated 3 weight to gauge D, gauge A and gauge B equally where gauge D is depricated 1. Alice call _decrementWeightUntilFree(alice, 2) 2. userFreeWeight = 0 3. gauge D is freed, totalFreed = 0, userFreed = 1 4. (userFreeWeight + totalFreed) < weight, continue to free next gauge 5. gauge A is freed, totalFreed = 1, userFreed = 2 6. (userFreeWeight + totalFreed) < weight, continue to free next gauge 7. gauge B is freed, totalFreed = 2, userFreed = 3 8. All gauge is freed  Alternatively, Alice can 1. Alice call _decrementWeightUntilFree(alice, 1) 2. userFreeWeight = balanceOf[alice] - getUserWeight[alice] = 3 - 3 = 0 3. gauge D is freed, totalFreed = 0, userFreed = 1 4. (userFreeWeight + totalFreed) < weight, continue to free next gauge 5. gauge A is freed, totalFreed = 1, userFreed = 2 6. (userFreeWeight + totalFreed) >= weight, break 7. getUserWeight[alice] -= totalFreed 8. Alice call _decrementWeightUntilFree(alice, 2) 9. userFreeWeight = balanceOf[alice] - getUserWeight[alice] = 3 - 1 = 2 10. (userFreeWeight + totalFreed) >= weight, break 11. Only 2 gauge is freed  ## Recommended Mitigation Steps No need to treat deprecated gauge seperately  
# Unnecessary checked arithmetic in for loops There is no risk of overflow caused by increments to the iteration index in for loops (the `i++` in `for (uint256 i = 0; i < numIterations; i++)`). Increments perform overflow checks that are not necessary in this case.  ### Recommendation Surround the increment expressions with an `unchecked { ... }` block to avoid the default overflow checks. For example, change the loop ``` for (uint256 i = 0; i < numIterations; i++) {  // ... } ``` to ``` for (uint256 i = 0; i < numIterations;) {  // ...  unchecked { i++; } } ``` It is a little less readable but it saves a significant amount of gas.  # Unnecessary SLOADs and MLOADs in for-each loops There are many for loops that follows this for-each pattern: ``` for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` } ``` In such for loops, the `array.length` is read on every iteration, instead of caching it once in a local variable and read it from there. Storage reads are much more expensive than reading local variables. Memory reads are a bit more expensive than reading local variables.  ### Recommendation Read these values from storage / memory once, cache them in local variables and then read them again from the local variables. For example: ``` uint256 length = array.length; for (uint256 i = 0; i < length; i++) {  // do something with `array[i]` } ```  # Prefix increments / decrements are cheaper than postfix increments / decrements Use prefix increments / decrements (++x / --x) instead of postfix increments / decrements (x++ / x--).  ### Recommendation Change all postfix increments / decrements to prefix increments / decrements.
# Save gas in for loops by unchecked arithmetic  The for loop has no overflow risk of `i`. Use an unchecked block to save gas.  ## Proof of Concept  ``` flywheel-v2/src/token/ERC20MultiVotes.sol 346:        for (uint256 i = 0; i < size && (userFreeVotes + totalFreed) < votes; i++) {  flywheel-v2/src/rewards/FlywheelGaugeRewards.sol 189:        for (uint256 i = 0; i < size; i++) { ```  ## Recommendation  Use `unchecked` blocks to avoid overflow checks, or use `++i` rather than `i++` if you don't use unchecked blocks.  ``` for (uint256 i = 0; i < length; ) {     ...     unchecked {         ++i;     } } ```  
# Summary We list 2 low-critical findings and 2 non-critical findings: * (Low) Doesn’t check whether `newFlywheelRewards` is valid in `setFlywheelRewards()` * (Low) floating pragma * (Non) Using ecrecover is against best practice * (Non) It’s better to emit an event in `setRewardsStream`  # (Low) Doesn’t check whether `newFlywheelRewards` is valid in `setFlywheelRewards()`   ## Impact  Doesn’t check whether `newFlywheelRewards` is valid in `setFlywheelRewards()`. It may be a invalid or malicious. it should add some kind of check  ## Proof of Concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L165  ```     function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {         uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));         if (oldRewardBalance > 0) {             rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);         }          flywheelRewards = newFlywheelRewards;          emit FlywheelRewardsUpdate(address(newFlywheelRewards));     }  ```  ## Tools Used  vim  ## Recommended Mitigation Steps  Check whether `newFlywheelRewards` is valid # (Low) floating pragma  ## Impact  Floating pragma may cause unexpected compilation time behaviour and introduce unintended bugs.  ## Proof of Concept  Contracts have floating pragma problems.  https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L4  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L3  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L4    ## Tools Used  vim  ## Recommended Mitigation Steps  Don't use `^`, lock pragma to ensure compiler version. e.g. `pragma solidity 0.8.0;`   # (Non) Using ecrecover is against best practice  ## Impact  Using ecrecover is against best practice. Preferably use ECDSA.recover instead. EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature unique. However it should be impossible to be a threat by now.   ## Proof of Concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L380  ## Tools Used  vim  ## Recommended Mitigation Steps  Take these implementation into consideration  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/cryptography/draft-EIP712.sol  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-ERC20Permit.sol  # (Non) It’s better to emit an event in `setRewardsStream`  ## Impact  In the function `setRewardsStream` in flywheel-v2/src/rewards/FlywheelGaugeRewards.sol, it’s better to emit an event.  ## Proof of Concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L273  ## Tools Used  vim, ethers.js  ## Recommended Mitigation Steps  Emit an event in set function:  ```      function setRewardsStream(IRewardsStream newRewardsStream) external requiresAuth {          rewardsStream = newRewardsStream; +        emit RewardsStreamUpdate(address(newRewardsStream));      } ``` 
## 1. `i++` can be replaced with `++i`   ++i consumes less gas than than i++, as the return value of post increment is not used, so it can be replaced with pre increment   ### Proof of concept  https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L99  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L137  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L187  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L314  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L391  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L576  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189  ### Mitigation  post increment can be replaced with pre-increment   ## 2. Avoid initialising variables with default values  When variables are created it contains the default values, explicit initialising with default values is unnecessary  ### Proof of concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L134  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L184  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L307  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L384  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L564  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189  ### Mitigation   Initialising default values can be avoided  ## 3. division can be replaced with shift operator  Shift operator consumed less gas when compared to division, so it can be replaced to save some gas  ### Proof of concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L94  ```     return (a & b) + (a ^ b) / 2; ```  ### Mitigation  Division can be replaced with shift operator  ```     return (a & b) + ((a ^ b) >> 1); ```  
  ## for loops can be optimized  Index increments in most of the for loops are unchecked, but a couple are still checked. Also, prefix increments are cheaper than postfix increments.   ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189     ## Redundant initialisation with default value  Some variables are initialised with their default values which cause unnecessary gas consumption  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L134 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L184 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L307 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L384 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L564 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L79 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189 https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L95     ## Error string longer than 32 characters  Error reason strings take space in the deployed bytecode. Every reason string takes at least 32 bytes so make sure your string fits in 32 bytes or it will become more expensive.   ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L379     ## Non-zero amount check missing before transfers  It is a good practice to apply non-zero amount checks for transfers to avoid unnecessary executions.  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L527 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L532 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L541 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L312 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L317 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L326 https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L121 https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L132 https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L147     ## Public state variables can be private  Private state variables are cheaper than public state variables. There are many instances where public variables can be private.  ### Lines of code There are many instances, some of which are: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L59 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L63 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L108 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L111 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L35 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L38 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L41 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L76 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L204 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L207     ## Booleans are more expensive than uint256  It is more expensive to operate using booleans because before every write operation an SLOAD is executed to read the contents of the slot. Therefore, it is cheaper to use uint256 instead of bool. On the other hand, using bool is better for the code readability. Hence, it is a tradeoff to be decided by the developers.  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L450 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L111  ### Recommended Mitigation Steps Consider replacing booleans with uint256 if gas efficiency overweighs code readability.     ## Constants can be made private  There is no need for these constants to be public. Changing them to private would save gas.   ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L368 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L201     ## Some internal functions can be made private  Calling private functions are cheaper than calling internal functions. Therefore, it is better to declare functions private if they are not called from inherited contracts.  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L89 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L108 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L256 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L277 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L339 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L357 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L457 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L479 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L92 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L216 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L236 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L262 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L146 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L184   ### Recommended Mitigation Steps Change the visibility to private where possible.     ## average() function can be eliminated  average() is used only once. Therefore, it can be eliminated and the calculation can be implemented where the function is called.  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L81 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L92  ### Recommended Mitigation Steps Line 81 can be changed as -->             uint256 mid = (low & high) + (low ^ high) / 2; And average() function can be deleted. 
# Lines of code  https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L65-L68   # Vulnerability details  https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L65-L68  ```solidity function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {     super.beforeWithdraw(amount, shares);     storedTotalAssets -= amount; } ```  https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L78-L87  ```solidity function syncRewards() public virtual {     uint192 lastRewardAmount_ = lastRewardAmount;     uint32 timestamp = block.timestamp.safeCastTo32();      if (timestamp < rewardsCycleEnd) revert SyncError();      uint256 storedTotalAssets_ = storedTotalAssets;     uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;      storedTotalAssets = storedTotalAssets_ + lastRewardAmount_; // SSTORE     ... ```  `storedTotalAssets` is a cached value of total assets which will only include the `unlockedRewards` when the whole cycle ends.  This makes it possible for `storedTotalAssets -= amount` to revert when the withdrawal amount exceeds `storedTotalAssets`, as the withdrawal amount may include part of the `unlockedRewards` in the current cycle.  ### PoC  Given:  - rewardsCycleLength = 100 days  1. Alice `deposit()` 100 TRIBE tokens; 2. The owner transferred 100 TRIBE tokens as rewards and called `syncRewards()`; 3. 1 day later, Alice `redeem()` with all shares, the transaction will revert at `xERC4626.beforeWithdraw()`.  Alice's shares worth 101 TRIBE at this moment, but `storedTotalAssets` = 100, making `storedTotalAssets -= amount` reverts due to underflow.  4. Bob `deposit()` 1 TRIBE tokens; 5. Alice `withdraw()` 101 TRIBE tokens, `storedTotalAssets` becomes `0`; 6. Bob can't even withdraw 1 wei of TRIBE token, as `storedTotalAssets` is now `0`.  If there are no new deposits, both Alice and Bob won't be able to withdraw any of their funds until `rewardsCycleEnd`.  ### Recommendation  Consider changing to:  ```solidity function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {     super.beforeWithdraw(amount, shares);     uint256 _storedTotalAssets = storedTotalAssets;     if (amount >= _storedTotalAssets) {         uint256 _totalAssets = totalAssets();         // _totalAssets - _storedTotalAssets == unlockedRewards         lastRewardAmount -= _totalAssets - _storedTotalAssets;         lastSync = block.timestamp;         storedTotalAssets = _totalAssets - amount;     } else {         storedTotalAssets = _storedTotalAssets - amount;     } } ```  
