# Handle  leastwood   # Vulnerability details  ## Impact  `MochiTreasuryV0.sol` interacts with Curve's voting escrow contract to lock tokens for 90 days, where it can be later withdrawn by the governance role. However, `VotingEscrow.vy` does not allow contracts to call the following functions; `create_lock()`, `increase_amount()` and `increase_unlock_time()`. For these functions, `msg.sender` must be an EOA account or an approved smart wallet. As a result, any attempt to lock tokens will fail in `MochiTreasuryV0.sol`.  ## Proof of Concept  https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L418 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L438 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L455  ## Tools Used  Manual code review Discussions with the Mochi team  ## Recommended Mitigation Steps  Consider updating this contract to potentially use another escrow service that enables `msg.sender` to be a contract. Alternatively, this escrow functionality can be replaced with an internal contract which holds `usdm` tokens instead, removing the need to convert half of the tokens to Curve tokens. Holding Curve tokens for a minimum of 90 days may overly expose the Mochi treasury to Curve token price fluctuations.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `MochiTreasuryV0.sol` contract freely receives ETH from users/other contracts. In the event this does happen, ETH is permanently locked and unrecoverable by the protocol's governance framework.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol  ## Tools Used  Manual code review Slither  ## Recommended Mitigation Steps  Consider enabling ETH withdraws for the governance role.  
# Handle  leastwood   # Vulnerability details  ## Impact  `withdrawLock()` does not prevent users from calling this function when locking has been toggled. As a result, withdraws may be made unexpectedly.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L40-L42  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider adding `require(lockCrv, "!lock");` to `withdrawLock()` to ensure this function is not called unexpectedly. Alternatively if this is intended behaviour, it should be rather checked that the lock has not been toggled, otherwise users could maliciously relock tokens.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `BeaconProxyDeployer.deploy()` function is used to deploy lightweight proxy contracts that act as each asset's vault. The function does not revert properly if there is a failed contract deployment or revert from the `create2` opcode as it does not properly check the returned address for bytecode. The `create2` opcode returns the expected address which will never be the zero address (as is what is currently checked).  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-library/contracts/BeaconProxyDeployer.sol#L31  ## Tools Used  Manual code review Discussions with the Mochi team Discussions with library dev  ## Recommended Mitigation Steps  The recommended mitigation was to update `iszero(result)` to `iszero(extcodesize(result))` in the line mentioned above. This change has already been made in the corresponding library which can be found [here](https://github.com/Nipol/bean-contracts/pull/13), however, this needs to also be reflected in Mochi's contracts.  
# Handle  pauliax   # Vulnerability details  ## Impact contract USDM does not need to import IERC3156FlashLender again as it was already imported in IUSDM.   import "../interfaces/IERC3156FlashLender.sol";  contract DutchAuctionLiquidator makes no use of these imports:   import "@openzeppelin/contracts/token/ERC721/IERC721.sol";   import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";   import "@mochifi/library/contracts/BeaconProxyDeployer.sol";  ## Recommended Mitigation Steps Consider reviewing all the unused imports and removing them to reduce the size of the contract and thus save some deployment gas.  
# Handle  pauliax   # Vulnerability details  ## Impact Gas efficiency can be achieved by tightly packing the struct. Struct variables are stored in 32 bytes each so you can group smaller types to occupy less storage. For example, startedAt or boughtAt in Auction struct hold block.number so realistically this does not need uint256 and you can consider storing it in lower type. You can read more here: https://fravoll.github.io/solidity-patterns/tight_variable_packing.html or in the official documentation: https://docs.soliditylang.org/en/v0.4.21/miscellaneous.html  ## Recommended Mitigation Steps Search for an optimal size and order of structs to reduce gas usage.  
# Handle  pauliax   # Vulnerability details  ## Impact This not only loses some precision (cuz of multiplication and division) but also consumes more gas:     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     );  ## Recommended Mitigation Steps Proposed improvement:   // send Mochi to vMochi Vault   uint toVault = (mochiBalance * vMochiRatio) / 1e18;   mochi.transfer(       address(engine.vMochi()),       toVault   );   // send Mochi to veCRV Holders   mochi.transfer(       crvVoterRewardPool,       mochiBalance - toVault;   );  This way you the whole mochiBalance will be transferred and it will cost less to do that as fewer math operations are performed.  
# Handle  ye0lde   # Vulnerability details  ## Impact Open TODOs can point to programming or other errors that still need to be fixed.  ## Proof of Concept  These are TODOs written as comments: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L57 https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L163  ## Tools Used VS Code  ## Recommended Mitigation Steps Resolve the TODOs/open questions.   
# Handle  cmichel   # Vulnerability details  The `UniswapV2LPAdapter/SushiswapV2LPAdapter.update` function retrieves the `underlying` from the LP token pair (`_asset`) but then calls `router.update(_asset, _proof)` which is the LP token itself again. This will end up with the router calling this function again recursively.  ## Impact This function fails as there's an infinite recursion and eventually runs out of gas.  ## Recommendation The idea was most likely to update the `underlying` price which is used in `_getPrice` as `uint256 eAvg = cssr.getExchangeRatio(_underlying, weth);`.  Call `router.update(underlying, _proof)` instead. Note that the `_proof` does not necessarily update the `underlying <> WETH` pair, it could be any `underlying <> keyAsset` pair.   
# Handle  cmichel   # Vulnerability details  Governance can change the `engine.nft` address which is used by vaults to represent collateralized debt positions (CDP). When minting a vault using `MochiVault.mint` the address returned ID will be used and overwrite the state of an existing debt position and set its status to `Idle`.  ## Impact Changing the NFT address will allow overwriting existing CDPs.  ## Recommended Mitigation Steps Disallow setting a new NFT address. or ensure that the new NFT's IDs start at the old NFT's IDs.  
# Handle  cmichel   # Vulnerability details  The total `debt` in `MochiVault.accrueDebt` increases by the current `debt` times the debt index growth. This is correct but the total `debt` is then _reduced_ again by the calling _user's_ discounted debt, meaning, the total debt depends on which specific user performs the debt accrual.  This should not be the case.  ## POC Assume we have a total debt of `2000`, two users A and B, where A has a debt of 1000, and B has a debt of 100. The (previous) `debtIndex = 1.0` and accruing it now would increase it to `1.1`.  There's a difference if user A or B first does the accrual.  #### User A accrues first User A calls `accrueDebt`: `increased = 2000 * 1.1/1.0 - 2000 = 200`. Thus `debts` is first set to `2200`. The user's `increasedDebt = 1000 * 1.1 / 1.0 - 1000 = 100` and assume a discount of `10%`, thus `discountedDebt = 100 * 10% = 10`. Then `debts = 2200 - 10 = 2190`.  The next accrual will work with a total debt of `2190`.  #### User B accruess first User B calls `accrueDebt`: `increased = 2000 * 1.1/1.0 - 2000 = 200`. Thus `debts` is first set to `2200`. The user's `increasedDebt = 100 * 1.1 / 1.0 - 100 = 10` and assume a discount of `10%`, thus `discountedDebt = 10 * 10% = 1`. Then `debts = 2200 - 1 = 2199`.  The next accrual will work with a total debt of `2199`, leading to more debt overall.  ## Impact The total debt of a system depends on who performs the accruals which should ideally not be the case. The discrepancy compounds and can grow quite large if a whale always does the accrual compared to someone with almost no debt or no discount.  ## Recommended Mitigation Steps Don't use the discounts or track the weighted average discount across all users that is subtracted from the increased total debt each time, i.e., reduce it by the discount of **all users** (instead of current caller only) when accruing to correctly track the debt.   
# Handle  WatchPug   # Vulnerability details  In the current implementation, a liquidated position can be used for depositing and borrowing again.  However, if there is a liquidation auction ongoing, even if the position is now `liquidatable`, the call of `triggerLiquidation()` will still fail.   The liquidator must `settleLiquidation` first.  If the current auction is not profitable for the liquidator, say the value of the collateral can not even cover the gas cost, the liquidator may be tricked and not liquidate the new loan at all.  Considering if the liquidator bot is not as small to handle this situation (take the profit of the new liquidation and the gas cost loss of the current auction into consideration), a malicious user can create a dust amount position trigger the liquidation by themself.  Since the collateral of this position is so small that it can not even cover the gas cost, liquidators will most certainly ignore this auction.  The malicious user will then deposit borrow the actual loan.  When this loan becomes `liquidatable`, liquidators may:  1. confuse the current dust auction with the `liquidatable` position; 2. unable to proceed with such a complex liquidation.  As a result, the malicious user can potentially escape liquidation.  ### Recommendation  Consider making liquidated positions unable to be used (for depositing and borrowing) again.  
# Handle  cmichel   # Vulnerability details  The `MochiProfileV0` defines liquidation and collateral factors for different asset types. For the `AssetClass.Sigma` type, the liquidation factor is _less_ than the collateral factor:  ```solidity function liquidationFactor(address _asset)     public     view     override     returns (float memory) {     AssetClass class = assetClass(_asset);     if (class == AssetClass.Sigma) { // } else if (class == AssetClass.Sigma) {         return float({numerator: 40, denominator: 100});     } }  function maxCollateralFactor(address _asset)     public     view     override     returns (float memory) {     AssetClass class = assetClass(_asset);     if (class == AssetClass.Sigma) {         return float({numerator: 45, denominator: 100});     } } ```  This means that one can take a loan of up to 45% of their collateral but then immediately gets liquidated as the liquidation factor is only 40%. There should always be a buffer between these such that taking the max loan does not immediately lead to liquidations:  > A safety buffer is maintained between max CF and LF to protect users against liquidations due to normal volatility. [Docs](https://hackmd.io/@az-/mochi-whitepaper#Collateral-Factor-CF)   ## Recommended Mitigation Steps The max collateral factor for the Sigma type should be higher than its liquidation factor.   
# Handle  cmichel   # Vulnerability details  If a flashloan contract does not properly authenticate the `USDM` flashloan contract callbacks, anyone can perform a griefing attack which will lead to the caller losing tokens equal to the fees.  This is because the flashloan `receiver` is not authenticated and anyone can start flashloans on behalf of another contract. They don't even need to approve the `usdm` contract as it uses internal `_burn` and `_transfer` functions instead of `burnFrom`/`transferFrom`.  #### POC  1. Call `FlashLoan.flashLoan(receiver=victim, ...)`. 2. Loan amount + fees will be burned/transferred from the `receiver` in `_loan`.  If fees are non-zero, it's possible to drain the victim's balance if their contract is implemented incorrectly without proper authentication checks.  #### Recommendation This is an inherent issue with EIP-3156 which defines the interface with an arbitrary `receiver`. Contracts should be aware to revert if the flashloan was not initiated by them.  To mitigate this issue one could use functions that work with explicit approvals from the victim, instead of using internal `_burn` and `_transfer` functions. This way, the victim must first have approved the tokens for transfer.   
# Handle  WatchPug   # Vulnerability details  In `MochiProfileV0.sol`, `secPerYear` is defined as an immutable variable while it's not configured as a parameter of the constructor. Thus, it can be declared as constant to save gas.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L23-L28  ```solidity=23 uint256 public immutable secPerYear;  uint256 public override delay;  constructor(address _engine) {     secPerYear = 31536000; ```  ### Recommendation  Change to:  ```solidity=23 uint256 public constant SEC_PER_YEAR = 31536000; ```  
# Handle  WatchPug   # Vulnerability details  The check of `x > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `x <= 3`.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/UniswapV2LPAdapter.sol#L106-L117  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/SushiswapV2LPAdapter.sol#L106-L117  ```solidity=106 function sqrt(uint x) internal pure returns (uint y) {     if (x > 3) {         uint z = x / 2 + 1;         y = x;         while (z < y) {             y = z;             z = (x / z + z) / 2;         }     } else if (x != 0) {         y = 1;     } } ```  ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  
# Handle  WatchPug   # Vulnerability details  `distributeMochi()` will call `_buyMochi()` to convert `mochiShare` to Mochi token and call `_shareMochi()` to send Mochi to vMochi Vault and veCRV Holders. It wont touch the `treasuryShare`.  However, in the current implementation, `treasuryShare` will be reset to `0`. This is unexpected and will cause the protocol fee can not be properly accounted for and collected.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L79-L95  ```solidity=79 function _shareMochi() internal {     IMochi mochi = engine.mochi();     uint256 mochiBalance = mochi.balanceOf(address(this));     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     );     // flush mochiShare     mochiShare = 0;     treasuryShare = 0; } ```  ### Impact  Anyone can call `distributeMochi()` and reset `treasuryShare` to `0`, and then call `updateReserve()` to allocate part of the wrongfuly resetted `treasuryShare` to `mochiShare` and call `distributeMochi()`.  Repeat the steps above and the `treasuryShare` will be consumed to near zero, profits the vMochi Vault holders and veCRV Holders. The protocol suffers the loss of funds.  ### Recommendation  Change to:  ```solidity=64 function _buyMochi() internal {     IUSDM usdm = engine.usdm();     address[] memory path = new address[](2);     path[0] = address(usdm);     path[1] = address(engine.mochi());     usdm.approve(address(uniswapRouter), mochiShare);     uniswapRouter.swapExactTokensForTokens(         mochiShare,         1,         path,         address(this),         type(uint256).max     );     // flush mochiShare     mochiShare = 0; }  function _shareMochi() internal {     IMochi mochi = engine.mochi();     uint256 mochiBalance = mochi.balanceOf(address(this));     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     ); } ```  
# Handle  WatchPug   # Vulnerability details  `treasuryRatio` and `vMochiRatio` must be `<= 1e18` to make sure the contract works correctly. Therefore, the input should be checked in the setters.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L45-L53  ```solidity=45 function changeTreasuryRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), "!gov");     treasuryRatio = _ratio; }  function changevMochiRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), "!gov");     vMochiRatio = _ratio; } ```  ### Recommendation  Change to:  ```solidity=45 function changeTreasuryRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), "!gov");     require(_ratio <= 1e18, ">1e18");     treasuryRatio = _ratio; }  function changevMochiRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), "!gov");     require(_ratio <= 1e18, ">1e18");     vMochiRatio = _ratio; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L67-L68  ```solidity=67 mochi.transfer(msg.sender, _amount / 2); mochi.transfer(address(vMochi), _amount / 2); ```  Change to:  ```solidity=67 mochi.transfer(msg.sender, _amount / 2); mochi.transfer(address(vMochi), _amount - _amount / 2); ```  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L59-L65  ```solidity=63 operationShare += updatedFee / 2; veCRVShare += updatedFee / 2; ```  Change to:  ```solidity=63 operationShare += updatedFee / 2; veCRVShare += updatedFee - updatedFee / 2; ```  
# Handle  WatchPug   # Vulnerability details  When liquidators race to liquidate a position, all other besides the first liquidator will be handling an empty (liquidated) position.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#L69-L81  ```solidity=69 function triggerLiquidation(address _asset, uint256 _nftId)     external     override {     IMochiVault vault = engine.vaultFactory().getVault(_asset);     Auction storage auction = auctions[auctionId(_asset, _nftId)];     require(auction.startedAt == 0 || auction.boughtAt != 0, "on going");     uint256 debt = vault.currentDebt(_nftId);      (, uint256 collateral, , , ) = vault.details(_nftId);      vault.liquidate(_nftId, collateral, debt);     ... ```  In the current implementation, even if the position is liquidated, at L77 and L79, it still tries to get the details and call `vault.liquidate()`, until it reverts at L285-L288 on `MochiVault.sol#liquidate()`. That's going to cost a decent amount of gas due to these unnecessary external calls and code executions.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L277-L288  ```solidity=277{285-288} function liquidate(     uint256 _id,     uint256 _collateral,     uint256 _usdm ) external override updateDebt(_id) {     require(msg.sender == address(engine.liquidator()), "!liquidator");     require(engine.nft().asset(_id) == address(asset), "!asset");     float memory price = engine.cssr().getPrice(address(asset));     require(         _liquidatable(details[_id].collateral, price, currentDebt(_id)),         "healthy"     );     ... ```  Therefore, adding a precondition check can save gas.    ### Recommendation  Change to:  ```solidity=69{77} function triggerLiquidation(address _asset, uint256 _nftId)     external     override {     IMochiVault vault = engine.vaultFactory().getVault(_asset);     Auction storage auction = auctions[auctionId(_asset, _nftId)];     require(auction.startedAt == 0 || auction.boughtAt != 0, "on going");     uint256 debt = vault.currentDebt(_nftId);     require(debt > 0, "!debt");     (, uint256 collateral, , , ) = vault.details(_nftId);      vault.liquidate(_nftId, collateral, debt);     ... ```  
# Handle  WatchPug   # Vulnerability details  When the vesting ends, `vesting[recipient].ends` will be `0` which always passes the check of `vesting[recipient].ends < block.timestamp` and causes unnecessary code execution.  Adding a check of `vesting[recipient].ends > 0` can avoid unnecessary code execution and save gas.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L22-L29  ```solidity modifier checkClaimable(address recipient) {     if (vesting[recipient].ends < block.timestamp) {         vesting[recipient].claimable += vesting[recipient].vested;         vesting[recipient].vested = 0;         vesting[recipient].ends = 0;     }     _; } ```  ### Recommendation  Change to:  ```solidity modifier checkClaimable(address recipient) {     if (vesting[recipient].ends > 0 && vesting[recipient].ends < block.timestamp) {         vesting[recipient].claimable += vesting[recipient].vested;         vesting[recipient].vested = 0;         vesting[recipient].ends = 0;     }     _; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L42  ```solidity=28 function claimRewardAsMochi() external {     IUSDM usdm = engine.usdm();     address[] memory path = new address[](2);     path[0] = address(usdm);     path[1] = uniswapRouter.WETH();     path[2] = address(engine.mochi());     usdm.approve(address(uniswapRouter), reward[msg.sender]);     // we are going to ingore the slippages here     uniswapRouter.swapExactTokensForTokens(         reward[msg.sender],         1,         path,         address(this),         type(uint256).max     ); ```  In `ReferralFeePoolV0.sol#claimRewardAsMochi()`, `path` is defined as an array of length 2 while it should be length 3.  As a result, at L33, an out-of-bound exception will be thrown and revert the transaction.  ### Impact  `claimRewardAsMochi()` will not work as expected so that all the referral fees cannot be claimed but stuck in the contract.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `VestedRewardPool.sol` contract is a public facing contract aimed at vesting tokens for a minimum of 90 days before allowing the recipient to withdraw their `mochi`. The `vest()` function does not utilise `safeTransferFrom()` to ensure that vested tokens are correctly allocated to the recipient. As a result, it is possible to frontrun a call to `vest()` and effectively steal a recipient's vested tokens. The same issue applies to the `lock()` function.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46 https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L54-L64  ## Tools Used  Manual code review Discussions with the Mochi team  ## Recommended Mitigation Steps  Ensure that users understand that this function should not be interacted directly as this could result in lost `mochi` tokens. Additionally, it might be worthwhile creating a single externally facing function which calls `safeTransferFrom()`, `vest()` and `lock()` in a single transaction.   
# Handle  leastwood   # Vulnerability details  ## Impact  The `FeePoolV0.sol` contract accrues fees upon the liquidation of undercollaterised positions. These fees are split between treasury and `vMochi` contracts. However, when `distributeMochi()` is called to distribute `mochi` tokens to `veCRV` holders, both `mochiShare` and `treasuryShare` is flushed from the contract when there are still `usdm` tokens in the contract.   ## Proof of Concept  Consider the following scenario:   - The `FeePoolV0.sol` contract contains 100 `usdm` tokens at an exchange rate of 1:1 with `mochi` tokens.   - `updateReserve()` is called to set the split of `usdm` tokens such that `treasuryShare` has claim on 20 `usdm` tokens and `mochiShare` has claim on the other 80 tokens.   - A `veCRV` holder seeks to increase their earnings by calling `distributeMochi()` before `sendToTreasury()` has been called.   - As a result, 80 `usdm` tokens are converted to `mochi` tokens and  locked in a curve rewards pool.   - Consequently, `mochiShare` and `treasuryShare` is set to `0` (aka flushed).   - The same user calls `updateReserve()` to split the leftover 20 `usdm` tokens between `treasuryShare` and `mochiShare`.    - `mochiShare` is now set to 16 `usdm` tokens.   - The above process is repeated to distribute `mochi` tokens to `veCRV` holders again and again.   - The end result is that `veCRV` holders have been able to receive all tokens that were intended to be distributed to the treasury.  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L94  ## Tools Used  Manual code review Discussions with the Mochi team.  ## Recommended Mitigation Steps  Consider removing the line in `FeePoolV0.sol` (mentioned above), where `treasuryShare` is flushed.   
# Handle  nikitastupin   # Vulnerability details  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/ChainlinkAdapter.sol#L49   The `ChainlinkAdapter` calls out to a Chainlink oracle receiving the `latestRoundData()`. If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale or incorrect data (if oracles are unable to submit no new round is started).  ## Recommended Mitigation Steps  Add the following checks:  ``` ... ( roundId, rawPrice, , updateTime, answeredInRound ) = AggregatorV3Interface(XXXXX).latestRoundData(); require(rawPrice > 0, "Chainlink price <= 0"); require(updateTime != 0, "Incomplete round"); require(answeredInRound >= roundId, "Stale price"); ... ```  ## References  - https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/#chainlinkoraclewrapper-latestrounddata-might-return-stale-results - https://github.com/code-423n4/2021-05-fairside-findings/issues/70  
# Handle  ye0lde   # Vulnerability details  ## Impact  Redundant arithmetic underflow/overflow checks can be avoided when an underflow/overflow cannot happen.  ## Proof of Concept  The "unchecked" keyword can be applied here since there is an "if" statement before to ensure the arithmetic operations, would not cause an integer underflow or overflow. https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L267  Change the code at 267 to: <code> unchecked {    debts -= _amount; } </code>  A similar change can be made here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L269  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Add the "unchecked" keyword as shown above.  
# Handle  jonah1005   # Vulnerability details   ## Impact [MochiVaultFactory.sol#L26-L37](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVaultFactory.sol#L26-L37) There's no permission control in the vaultFactory. Anyone can create a vault. The transaction would be reverted when the government tries to deploy such an asset.  As the protocol checks whether the vault is a valid vault by comparing the contract's address with the computed address, the protocol would recognize the random vault as a valid one.    I consider this is a medium-risk issue.  ## Proof of Concept  Here's a web3.py script to trigger the bug. ```py vault_factory.functions.deployVault(usdt.address).transact() ## this tx would be reverted profile.functions.registerAssetByGov([usdt.address], [3]).transact() ```  ## Tools Used  None  ## Recommended Mitigation Steps Recommend to add a check. ```solidity require(msg.sender == engine, "!engine"); ```  
# Handle  ye0lde   # Vulnerability details  ## Impact  Cache the result of engine.usdm().balanceOf to simplify code and save gas.  ## Proof of Concept  engine.usdm().balanceOf is called twice in function updateReserve here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L32-L38  I suggest modifying the code as follows: <code> function updateReserve() external override {   uint256 balanceOf = engine.usdm().balanceOf(address(this));  treasuryShare += ((balanceOf - mochiShare - treasuryShare) * treasuryRatio) / 1e18;  mochiShare = balanceOf - treasuryShare; } </code>  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See POC   
# Handle  harleythedog   # Vulnerability details  ## Impact On line 100 of DutchAuctionLiquidator.sol (within settleLiquidation), there is a require statement for auction.boughtAt == 0. This is already checked on line 121 within the "buy" function, and this is the only function that can possibly call settleLiquidation, so this require statement always passes. Removing it would save gas.  ## Proof of Concept Link to require statement here: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#:~:text=require(auction.boughtAt%20%3D%3D%200%2C%20%22liquidated%22)%3B  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps Remove unnecessary require statement described above to save gas.  
# Handle  harleythedog   # Vulnerability details  ## Impact Right now, there is only one discount profile in the github repo: the "NoDiscountProfile" which does not discount the debt at all. This specific discount profile works correctly, but I claim that any other discount profile will result in liquidation never working.  Suppose that we instead have a discount profile where discount() returns any value strictly larger than 0. Now, suppose someone wants to trigger a liquidation on a position. First, triggerLiquidation will be called (within DutchAuctionLiquidator.sol). The variable "debt" is initialized as equal to vault.currentDebt(_nftId). Notice that currentDebt(_ndfId) (within MochiVault.sol) simply scales the current debt of the position using the liveDebtIndex() function, but there is no discounting being done within the function - this will be important. Back within the triggerLiquidation function, the variable "collateral" is  simply calculated as the total collateral of the position. Then, the function calls vault.liquidate(_nftId, collateral, debt), and I claim that this will never work due to underflow.  Indeed, the liquidate function will first update the debt of the position (due to the updateDebt(_id) modifier). The debt of the position is thus updated using lines 99-107 in MochiVault.sol. We can see that the details[_id].debt is updated in the exact same way as the calculations for currentDebt(_nftId), however, there is the extra subtraction of the discountedDebt on line 107.   Eventually we will reach line 293 in MochiVault.sol. However, since we discounted the debt in the calculation of details[_id].debt, but we did not discount the debt for the passed in parameter _usdm (and thus is strictly larger in value), line 293 will always error due to an underflow. In summary, any discount profile that actually discounts the debt of the position will result in all liquidations erroring out due to this underflow. Since no positions will be liquidatable, this represents a major flaw in the contract as then no collateral can be liquidated so the entire functionality of the contract is compromised.  ## Proof of Concept Liquidate function in MochiVault.sol: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#:~:text=function-,liquidate,-(  triggerLiquidation function in DutchAuctionLiquidator.sol: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#:~:text=function-,triggerLiquidation,-(address%20_asset%2C%20uint256  Retracing the steps as I have described above, we can see that any call to triggerLiquidation will result in:  details[_id].debt -= _usdm;  throwing an error since _usdm will be larger than details[_id].debt.  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps An easy fix is to simply change:  details[_id].debt -= _usdm;  to be:  details[_id].debt = 0;  as liquidating a position should probably just be equivalent to repaying all of the debt in the position.   Side Note: If there are no other discount profiles planned to be added other than "NoDiscountProfile", then I would recommend deleting all of the discount logic entirely, since NoDiscountProfile doesn't actually do anything  
# Handle  0x0x0x   # Vulnerability details   ## Impact Gas optimization.  ## Proof of Concept  ``` for (uint i = 0; i < arr.length; i++) {     //Operations not effecting the length of the array. } ``` Loading length for storage arrays cost 100 gas and for memory arrays it costs 3 gas. When arr.length is defined as the condition of for loop, at the start of every iteration the length is loaded from memory. If the length doesn't change during the loop, loading the length of arrays repeatedly can be avoided by saving the length to the stack. ``` uint length = arr.length; for (uint i = 0; i < length; i++) {     //Operations not effecting the length of the array. } ``` By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Locations ``` ./mochi-core/contracts/profile/MochiProfileV0.sol:68:        for (uint256 i = 0; i < _asset.length; i++) { ./mochi-core/contracts/profile/MochiProfileV0.sol:86:        for (uint256 i = 0; i < _assets.length; i++) { ./mochi-core/contracts/profile/MochiProfileV0.sol:95:        for (uint256 i = 0; i < _assets.length; i++) { ./mochi-cssr/contracts/MochiCSSRv0.sol:41:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:47:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:66:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:77:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/adapter/ChainlinkAdapter.sol:34:        for(uint256 i = 0; i<_assets.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:63:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:122:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:175:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:36:  for (uint i=0; i<parentNodes.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:78:  for(uint i=pathPtr; i<pathPtr+partialPath.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:108:  for(uint i=offset; i<nibbleArray.length; i++) { ./mochi-library/contracts/SushiswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./mochi-library/contracts/SushiswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) { ./mochi-library/contracts/UniswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./mochi-library/contracts/UniswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) { ``` ## A similar case  nibblePath.length is constant but it is read at every iteration for require statement.  ```./mochi-library/contracts/MerklePatriciaVerifier.sol:36: require(pathPtr <= nibblePath.length, "Path overflow");```    
# Handle  jonah1005   # Vulnerability details  ## Impact MochiEngine allows the operator to change the NFT contract. [MochiEngine.sol#L91-L93](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93) All the vaults would point to a different NFT address. As a result, users would not be access their positions. The entire protocol would be broken.  IMHO, A function that would break the entire protocol shouldn't exist.  I consider this is a high-risk issue. ## Proof of Concept [MochiEngine.sol#L91-L93](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93)  ## Tools Used None ## Recommended Mitigation Steps Remove the function.   
# Handle  jonah1005   # Vulnerability details  # regerralFeePool is vulnerable to MEV searcher  ## Impact `claimRewardAsMochi` in the `ReferralFeePoolV0` ignores slippage. This is not a desirable design. There are a lot of MEV searchers in the current network. Swapping assets with no slippage control would get rekted. Please refer to https://github.com/flashbots/pm.  Given the current state of the Ethereum network. Users would likely be sandwiched. I consider this is a high-risk issue.  ## Proof of Concept [ReferralFeePoolV0.sol#L28-L48](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L48)  Please refer to https://medium.com/immunefi/mushrooms-finance-theft-of-yield-bug-fix-postmortem-16bd6961388f  to see a possible attack pattern.   ## Tools Used  None  ## Recommended Mitigation Steps I recommend adding minReceivedAmount as a parameter.  ```solidity function claimRewardAsMochi(uint256 _minReceivedAmount) external {     // original logic here     require(engine.mochi().balanceOf(address(this)) > _minReceivedAmount, "!min");     engine.mochi().transfer(         msg.sender,         engine.mochi().balanceOf(address(this))     ); } ``` Also, the front-end should calculate the min amount with the current price.  
# Handle  jonah1005   # Vulnerability details  # treasury is vulnerable to sandwich attack.   ## Impact There's a permissionless function `veCRVlock` in MochiTreasury. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds. [MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)  Attackers can possibly steal all the funds in the treasury. I consider this is a high-risk issue.  ## Proof of Concept [MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)  Here's an exploit pattern 1. Flashloan and buy CRV the uniswap pool 2. Trigger `veCRVlock()` 3. The treasury buys CRV at a very high price. 4. Sell CRV and pay back the loan.  ## Tools Used  None  ## Recommended Mitigation Steps Recommend to add `onlyOwner` modifier.   
# Handle  gzeon   # Vulnerability details  ## Impact function claimRewardAsMochi in ReferralFeePoolV0.sol did not reduce user reward balance, allowing referrer to claim the same reward repeatedly and thus draining the fee pool.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol L28-47 did not reduce user reward balance  ## Tools Used None  ## Recommended Mitigation Steps Add the following lines > rewards -= reward[msg.sender]; > reward[msg.sender] = 0;   
# Handle  gzeon   # Vulnerability details  ## Impact Auction struct in DutchAuctionLiquidator.sol can be optimized to reduce 2 storage slot  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol L18-L25: the struct can changed into struct Auction {         uint256 nftId;         address vault;         uint48 startedAt;         uint48 boughtAt;         uint256 collateral;         uint256 debt;     } startedAt and boughtAt store block numbers, and 2^48 is be enough for a very long time.  ## Tools Used None  ## Recommended Mitigation Steps Change the struct as suggested above, also need to cast whenever startedAt and boughtAt is used.  
# Handle  gzeon   # Vulnerability details  ## Impact There is a status enum Liquidated but was not used anywhere in the code.   ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol L277-296 status was not set to Status.Liquidated after liquidation  ## Tools Used None  ## Recommended Mitigation Steps details[id].status = Status.Liquidated;  
# Handle  ye0lde   # Vulnerability details  ## Impact  Caching the "vesting" state variable instead of repeatedly reading and writing it will decrease deployment and runtime gas.  This is especially true for the modifier "checkClaimable" which is used on every function in the contract.   ## Proof of Concept  The checkClaimable function is here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L22-L29  An example of its use is here along with many other accesses to the "vesting" state variable. https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest modifying "checkClaimable as follows:     <code> function checkClaimable(Vesting memory v) internal pure returns(Vesting memory) {   if (v.ends < block.timestamp) {   v.claimable += v.vested;   v.vested = 0;   v.ends = 0;  }  return v; } </code>  and I suggest these changes to function "vest"   <code> function vest(address _recipient) external {  Vesting memory v = checkClaimable(vesting[_recipient]);  uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;  uint256 weightedEnd = (v.vested *   v.ends +   amount *   (block.timestamp + 90 days)) /   (v.vested + amount);  v.vested += amount;  v.ends = weightedEnd;  vesting[_recipient] = v;  mochiUnderManagement += amount; } </code>  These functions are also candidates for similar changes: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L48-L71   
# Handle  defsec   # Vulnerability details  ## Impact  This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract. Calling each function, we can see that the public function uses 496 gas, while the external function uses only 261.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.  Slither Detector:  external-function:  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L75  ## Tools Used  Slither  ## Recommended Mitigation Steps  1. Clone repository for Mochi Smart Contracts. 2. Create a python virtual environment with a stable python version. 3. Install Slither Analyzer on the python VEM. 4. Run Slither against all contracts. 5. Define public functions as an external for the gas optimization.  
# Handle  gzeon   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/interfaces/IMochiVault.sol L6-L12: the struct can be reordered into struct Detail {     Status status;     address referrer;     uint256 collateral;     uint256 debt;     uint256 debtIndex; }  such that status and referrer are put into the same slot, should save ~2000 gas per borrow  ## Tools Used None  ## Recommended Mitigation Steps Reorder the struct as suggested, and modify impacted code at  IMochiVault.sol L28-L34 DutchAuctionLiquidator.sol L77  ## Extra Realistically, the range of debtIndex (start at 1e18 and increase by fee per year) probably fit in a uint88(11bytes) so you can pack (status(1byte), referrer(20bytes), debtIndex(11bytes)) all in 32 bytes, saving another storage slot.   
# Handle  gzeon   # Vulnerability details  ## Impact Some of the require statements in MochiVault.sol can be placed earlier to reduce gas usage on revert  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol L226-227: can be placed at the very top of the function to avoid the expensive cssr call L237: can be placed before initialization of increasingDebt  ## Tools Used None  ## Recommended Mitigation Steps Relocate the said require statements  
# Handle  gpersoon   # Vulnerability details  ## Impact The value of the global variable debts in the contract MochiVault.sol is calculated in an inconsistent way.  In the function borrow() the variable debts is increased with a value excluding the fee. However in repay() and liquidate() it is decreased with the same value as details[_id].debt is decreased,, which is including the fee.  This would mean that debts will end up in a negative value when all debts are repay-ed. Luckily the function repay() prevents this from happening.  In the mean time the value of debts isn't accurate. This value is used directly or indirectly in:  - utilizationRatio(), stabilityFee() calculateFeeIndex() of MochiProfileV0.sol  - liveDebtIndex(), accrueDebt(), currentDebt() of MochiVault.sol  This means the entire debt and claimable calculations are slightly off.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol  function borrow(..)     details[_id].debt = totalDebt; // includes the fee     debts += _amount;     // excludes the fee   function repay(..)     debts -= _amount;       details[_id].debt -= _amount;  function liquidate(..)    debts -= _usdm;    details[_id].debt -= _usdm;  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L263-L268  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L272-L283  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L242-L256  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L258-L269  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L66-L73  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L79-L88  ## Tools Used  ## Recommended Mitigation Steps In function borrow(): replace     debts += _amount; with     debts += totalDebt  
# Handle  gpersoon   # Vulnerability details  ## Impact Every time you deposit some assets in the vault (via deposit() of MochiVault.sol) then "lastDeposit[_id]" is set to block.timestamp. The modifier wait() checks this value and makes sure you cannot withdraw for "delay()" blocks. The default value for delay() is 3 minutes.  Knowing this delay you can do a griefing attack: On chains with low gas fees: every 3 minutes deposit a tiny amount for a specific NFT-id (which has a large amount of assets). On chains with high gas fees: monitor the mempool for a withdraw() transaction and frontrun it with a deposit()  This way the owner of the NFT-id can never withdraw the funds.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L47-L54  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L171  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L33  ## Tools Used  ## Recommended Mitigation Steps Create a mechanism where you only block the withdraw of recently deposited funds   
# Handle  leastwood   # Vulnerability details  ## Impact  `MochiTreasuryV0.sol` interacts with Curve's voting escrow contract to lock tokens for 90 days, where it can be later withdrawn by the governance role. However, `VotingEscrow.vy` does not allow contracts to call the following functions; `create_lock()`, `increase_amount()` and `increase_unlock_time()`. For these functions, `msg.sender` must be an EOA account or an approved smart wallet. As a result, any attempt to lock tokens will fail in `MochiTreasuryV0.sol`.  ## Proof of Concept  https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L418 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L438 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L455  ## Tools Used  Manual code review Discussions with the Mochi team  ## Recommended Mitigation Steps  Consider updating this contract to potentially use another escrow service that enables `msg.sender` to be a contract. Alternatively, this escrow functionality can be replaced with an internal contract which holds `usdm` tokens instead, removing the need to convert half of the tokens to Curve tokens. Holding Curve tokens for a minimum of 90 days may overly expose the Mochi treasury to Curve token price fluctuations.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `MochiTreasuryV0.sol` contract freely receives ETH from users/other contracts. In the event this does happen, ETH is permanently locked and unrecoverable by the protocol's governance framework.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol  ## Tools Used  Manual code review Slither  ## Recommended Mitigation Steps  Consider enabling ETH withdraws for the governance role.  
# Handle  leastwood   # Vulnerability details  ## Impact  `withdrawLock()` does not prevent users from calling this function when locking has been toggled. As a result, withdraws may be made unexpectedly.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L40-L42  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider adding `require(lockCrv, "!lock");` to `withdrawLock()` to ensure this function is not called unexpectedly. Alternatively if this is intended behaviour, it should be rather checked that the lock has not been toggled, otherwise users could maliciously relock tokens.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `BeaconProxyDeployer.deploy()` function is used to deploy lightweight proxy contracts that act as each asset's vault. The function does not revert properly if there is a failed contract deployment or revert from the `create2` opcode as it does not properly check the returned address for bytecode. The `create2` opcode returns the expected address which will never be the zero address (as is what is currently checked).  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-library/contracts/BeaconProxyDeployer.sol#L31  ## Tools Used  Manual code review Discussions with the Mochi team Discussions with library dev  ## Recommended Mitigation Steps  The recommended mitigation was to update `iszero(result)` to `iszero(extcodesize(result))` in the line mentioned above. This change has already been made in the corresponding library which can be found [here](https://github.com/Nipol/bean-contracts/pull/13), however, this needs to also be reflected in Mochi's contracts.  
# Handle  pauliax   # Vulnerability details  ## Impact contract USDM does not need to import IERC3156FlashLender again as it was already imported in IUSDM.   import "../interfaces/IERC3156FlashLender.sol";  contract DutchAuctionLiquidator makes no use of these imports:   import "@openzeppelin/contracts/token/ERC721/IERC721.sol";   import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";   import "@mochifi/library/contracts/BeaconProxyDeployer.sol";  ## Recommended Mitigation Steps Consider reviewing all the unused imports and removing them to reduce the size of the contract and thus save some deployment gas.  
# Handle  pauliax   # Vulnerability details  ## Impact Gas efficiency can be achieved by tightly packing the struct. Struct variables are stored in 32 bytes each so you can group smaller types to occupy less storage. For example, startedAt or boughtAt in Auction struct hold block.number so realistically this does not need uint256 and you can consider storing it in lower type. You can read more here: https://fravoll.github.io/solidity-patterns/tight_variable_packing.html or in the official documentation: https://docs.soliditylang.org/en/v0.4.21/miscellaneous.html  ## Recommended Mitigation Steps Search for an optimal size and order of structs to reduce gas usage.  
# Handle  pauliax   # Vulnerability details  ## Impact This not only loses some precision (cuz of multiplication and division) but also consumes more gas:     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     );  ## Recommended Mitigation Steps Proposed improvement:   // send Mochi to vMochi Vault   uint toVault = (mochiBalance * vMochiRatio) / 1e18;   mochi.transfer(       address(engine.vMochi()),       toVault   );   // send Mochi to veCRV Holders   mochi.transfer(       crvVoterRewardPool,       mochiBalance - toVault;   );  This way you the whole mochiBalance will be transferred and it will cost less to do that as fewer math operations are performed.  
# Handle  ye0lde   # Vulnerability details  ## Impact Open TODOs can point to programming or other errors that still need to be fixed.  ## Proof of Concept  These are TODOs written as comments: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L57 https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L163  ## Tools Used VS Code  ## Recommended Mitigation Steps Resolve the TODOs/open questions.   
# Handle  cmichel   # Vulnerability details  The `UniswapV2LPAdapter/SushiswapV2LPAdapter.update` function retrieves the `underlying` from the LP token pair (`_asset`) but then calls `router.update(_asset, _proof)` which is the LP token itself again. This will end up with the router calling this function again recursively.  ## Impact This function fails as there's an infinite recursion and eventually runs out of gas.  ## Recommendation The idea was most likely to update the `underlying` price which is used in `_getPrice` as `uint256 eAvg = cssr.getExchangeRatio(_underlying, weth);`.  Call `router.update(underlying, _proof)` instead. Note that the `_proof` does not necessarily update the `underlying <> WETH` pair, it could be any `underlying <> keyAsset` pair.   
# Handle  cmichel   # Vulnerability details  Governance can change the `engine.nft` address which is used by vaults to represent collateralized debt positions (CDP). When minting a vault using `MochiVault.mint` the address returned ID will be used and overwrite the state of an existing debt position and set its status to `Idle`.  ## Impact Changing the NFT address will allow overwriting existing CDPs.  ## Recommended Mitigation Steps Disallow setting a new NFT address. or ensure that the new NFT's IDs start at the old NFT's IDs.  
# Handle  cmichel   # Vulnerability details  The total `debt` in `MochiVault.accrueDebt` increases by the current `debt` times the debt index growth. This is correct but the total `debt` is then _reduced_ again by the calling _user's_ discounted debt, meaning, the total debt depends on which specific user performs the debt accrual.  This should not be the case.  ## POC Assume we have a total debt of `2000`, two users A and B, where A has a debt of 1000, and B has a debt of 100. The (previous) `debtIndex = 1.0` and accruing it now would increase it to `1.1`.  There's a difference if user A or B first does the accrual.  #### User A accrues first User A calls `accrueDebt`: `increased = 2000 * 1.1/1.0 - 2000 = 200`. Thus `debts` is first set to `2200`. The user's `increasedDebt = 1000 * 1.1 / 1.0 - 1000 = 100` and assume a discount of `10%`, thus `discountedDebt = 100 * 10% = 10`. Then `debts = 2200 - 10 = 2190`.  The next accrual will work with a total debt of `2190`.  #### User B accruess first User B calls `accrueDebt`: `increased = 2000 * 1.1/1.0 - 2000 = 200`. Thus `debts` is first set to `2200`. The user's `increasedDebt = 100 * 1.1 / 1.0 - 100 = 10` and assume a discount of `10%`, thus `discountedDebt = 10 * 10% = 1`. Then `debts = 2200 - 1 = 2199`.  The next accrual will work with a total debt of `2199`, leading to more debt overall.  ## Impact The total debt of a system depends on who performs the accruals which should ideally not be the case. The discrepancy compounds and can grow quite large if a whale always does the accrual compared to someone with almost no debt or no discount.  ## Recommended Mitigation Steps Don't use the discounts or track the weighted average discount across all users that is subtracted from the increased total debt each time, i.e., reduce it by the discount of **all users** (instead of current caller only) when accruing to correctly track the debt.   
# Handle  WatchPug   # Vulnerability details  In the current implementation, a liquidated position can be used for depositing and borrowing again.  However, if there is a liquidation auction ongoing, even if the position is now `liquidatable`, the call of `triggerLiquidation()` will still fail.   The liquidator must `settleLiquidation` first.  If the current auction is not profitable for the liquidator, say the value of the collateral can not even cover the gas cost, the liquidator may be tricked and not liquidate the new loan at all.  Considering if the liquidator bot is not as small to handle this situation (take the profit of the new liquidation and the gas cost loss of the current auction into consideration), a malicious user can create a dust amount position trigger the liquidation by themself.  Since the collateral of this position is so small that it can not even cover the gas cost, liquidators will most certainly ignore this auction.  The malicious user will then deposit borrow the actual loan.  When this loan becomes `liquidatable`, liquidators may:  1. confuse the current dust auction with the `liquidatable` position; 2. unable to proceed with such a complex liquidation.  As a result, the malicious user can potentially escape liquidation.  ### Recommendation  Consider making liquidated positions unable to be used (for depositing and borrowing) again.  
# Handle  cmichel   # Vulnerability details  The `MochiProfileV0` defines liquidation and collateral factors for different asset types. For the `AssetClass.Sigma` type, the liquidation factor is _less_ than the collateral factor:  ```solidity function liquidationFactor(address _asset)     public     view     override     returns (float memory) {     AssetClass class = assetClass(_asset);     if (class == AssetClass.Sigma) { // } else if (class == AssetClass.Sigma) {         return float({numerator: 40, denominator: 100});     } }  function maxCollateralFactor(address _asset)     public     view     override     returns (float memory) {     AssetClass class = assetClass(_asset);     if (class == AssetClass.Sigma) {         return float({numerator: 45, denominator: 100});     } } ```  This means that one can take a loan of up to 45% of their collateral but then immediately gets liquidated as the liquidation factor is only 40%. There should always be a buffer between these such that taking the max loan does not immediately lead to liquidations:  > A safety buffer is maintained between max CF and LF to protect users against liquidations due to normal volatility. [Docs](https://hackmd.io/@az-/mochi-whitepaper#Collateral-Factor-CF)   ## Recommended Mitigation Steps The max collateral factor for the Sigma type should be higher than its liquidation factor.   
# Handle  cmichel   # Vulnerability details  If a flashloan contract does not properly authenticate the `USDM` flashloan contract callbacks, anyone can perform a griefing attack which will lead to the caller losing tokens equal to the fees.  This is because the flashloan `receiver` is not authenticated and anyone can start flashloans on behalf of another contract. They don't even need to approve the `usdm` contract as it uses internal `_burn` and `_transfer` functions instead of `burnFrom`/`transferFrom`.  #### POC  1. Call `FlashLoan.flashLoan(receiver=victim, ...)`. 2. Loan amount + fees will be burned/transferred from the `receiver` in `_loan`.  If fees are non-zero, it's possible to drain the victim's balance if their contract is implemented incorrectly without proper authentication checks.  #### Recommendation This is an inherent issue with EIP-3156 which defines the interface with an arbitrary `receiver`. Contracts should be aware to revert if the flashloan was not initiated by them.  To mitigate this issue one could use functions that work with explicit approvals from the victim, instead of using internal `_burn` and `_transfer` functions. This way, the victim must first have approved the tokens for transfer.   
# Handle  WatchPug   # Vulnerability details  In `MochiProfileV0.sol`, `secPerYear` is defined as an immutable variable while it's not configured as a parameter of the constructor. Thus, it can be declared as constant to save gas.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L23-L28  ```solidity=23 uint256 public immutable secPerYear;  uint256 public override delay;  constructor(address _engine) {     secPerYear = 31536000; ```  ### Recommendation  Change to:  ```solidity=23 uint256 public constant SEC_PER_YEAR = 31536000; ```  
# Handle  WatchPug   # Vulnerability details  The check of `x > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `x <= 3`.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/UniswapV2LPAdapter.sol#L106-L117  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/SushiswapV2LPAdapter.sol#L106-L117  ```solidity=106 function sqrt(uint x) internal pure returns (uint y) {     if (x > 3) {         uint z = x / 2 + 1;         y = x;         while (z < y) {             y = z;             z = (x / z + z) / 2;         }     } else if (x != 0) {         y = 1;     } } ```  ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  
# Handle  WatchPug   # Vulnerability details  `distributeMochi()` will call `_buyMochi()` to convert `mochiShare` to Mochi token and call `_shareMochi()` to send Mochi to vMochi Vault and veCRV Holders. It wont touch the `treasuryShare`.  However, in the current implementation, `treasuryShare` will be reset to `0`. This is unexpected and will cause the protocol fee can not be properly accounted for and collected.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L79-L95  ```solidity=79 function _shareMochi() internal {     IMochi mochi = engine.mochi();     uint256 mochiBalance = mochi.balanceOf(address(this));     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     );     // flush mochiShare     mochiShare = 0;     treasuryShare = 0; } ```  ### Impact  Anyone can call `distributeMochi()` and reset `treasuryShare` to `0`, and then call `updateReserve()` to allocate part of the wrongfuly resetted `treasuryShare` to `mochiShare` and call `distributeMochi()`.  Repeat the steps above and the `treasuryShare` will be consumed to near zero, profits the vMochi Vault holders and veCRV Holders. The protocol suffers the loss of funds.  ### Recommendation  Change to:  ```solidity=64 function _buyMochi() internal {     IUSDM usdm = engine.usdm();     address[] memory path = new address[](2);     path[0] = address(usdm);     path[1] = address(engine.mochi());     usdm.approve(address(uniswapRouter), mochiShare);     uniswapRouter.swapExactTokensForTokens(         mochiShare,         1,         path,         address(this),         type(uint256).max     );     // flush mochiShare     mochiShare = 0; }  function _shareMochi() internal {     IMochi mochi = engine.mochi();     uint256 mochiBalance = mochi.balanceOf(address(this));     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     ); } ```  
# Handle  WatchPug   # Vulnerability details  `treasuryRatio` and `vMochiRatio` must be `<= 1e18` to make sure the contract works correctly. Therefore, the input should be checked in the setters.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L45-L53  ```solidity=45 function changeTreasuryRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), "!gov");     treasuryRatio = _ratio; }  function changevMochiRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), "!gov");     vMochiRatio = _ratio; } ```  ### Recommendation  Change to:  ```solidity=45 function changeTreasuryRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), "!gov");     require(_ratio <= 1e18, ">1e18");     treasuryRatio = _ratio; }  function changevMochiRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), "!gov");     require(_ratio <= 1e18, ">1e18");     vMochiRatio = _ratio; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L67-L68  ```solidity=67 mochi.transfer(msg.sender, _amount / 2); mochi.transfer(address(vMochi), _amount / 2); ```  Change to:  ```solidity=67 mochi.transfer(msg.sender, _amount / 2); mochi.transfer(address(vMochi), _amount - _amount / 2); ```  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L59-L65  ```solidity=63 operationShare += updatedFee / 2; veCRVShare += updatedFee / 2; ```  Change to:  ```solidity=63 operationShare += updatedFee / 2; veCRVShare += updatedFee - updatedFee / 2; ```  
# Handle  WatchPug   # Vulnerability details  When liquidators race to liquidate a position, all other besides the first liquidator will be handling an empty (liquidated) position.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#L69-L81  ```solidity=69 function triggerLiquidation(address _asset, uint256 _nftId)     external     override {     IMochiVault vault = engine.vaultFactory().getVault(_asset);     Auction storage auction = auctions[auctionId(_asset, _nftId)];     require(auction.startedAt == 0 || auction.boughtAt != 0, "on going");     uint256 debt = vault.currentDebt(_nftId);      (, uint256 collateral, , , ) = vault.details(_nftId);      vault.liquidate(_nftId, collateral, debt);     ... ```  In the current implementation, even if the position is liquidated, at L77 and L79, it still tries to get the details and call `vault.liquidate()`, until it reverts at L285-L288 on `MochiVault.sol#liquidate()`. That's going to cost a decent amount of gas due to these unnecessary external calls and code executions.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L277-L288  ```solidity=277{285-288} function liquidate(     uint256 _id,     uint256 _collateral,     uint256 _usdm ) external override updateDebt(_id) {     require(msg.sender == address(engine.liquidator()), "!liquidator");     require(engine.nft().asset(_id) == address(asset), "!asset");     float memory price = engine.cssr().getPrice(address(asset));     require(         _liquidatable(details[_id].collateral, price, currentDebt(_id)),         "healthy"     );     ... ```  Therefore, adding a precondition check can save gas.    ### Recommendation  Change to:  ```solidity=69{77} function triggerLiquidation(address _asset, uint256 _nftId)     external     override {     IMochiVault vault = engine.vaultFactory().getVault(_asset);     Auction storage auction = auctions[auctionId(_asset, _nftId)];     require(auction.startedAt == 0 || auction.boughtAt != 0, "on going");     uint256 debt = vault.currentDebt(_nftId);     require(debt > 0, "!debt");     (, uint256 collateral, , , ) = vault.details(_nftId);      vault.liquidate(_nftId, collateral, debt);     ... ```  
# Handle  WatchPug   # Vulnerability details  When the vesting ends, `vesting[recipient].ends` will be `0` which always passes the check of `vesting[recipient].ends < block.timestamp` and causes unnecessary code execution.  Adding a check of `vesting[recipient].ends > 0` can avoid unnecessary code execution and save gas.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L22-L29  ```solidity modifier checkClaimable(address recipient) {     if (vesting[recipient].ends < block.timestamp) {         vesting[recipient].claimable += vesting[recipient].vested;         vesting[recipient].vested = 0;         vesting[recipient].ends = 0;     }     _; } ```  ### Recommendation  Change to:  ```solidity modifier checkClaimable(address recipient) {     if (vesting[recipient].ends > 0 && vesting[recipient].ends < block.timestamp) {         vesting[recipient].claimable += vesting[recipient].vested;         vesting[recipient].vested = 0;         vesting[recipient].ends = 0;     }     _; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L42  ```solidity=28 function claimRewardAsMochi() external {     IUSDM usdm = engine.usdm();     address[] memory path = new address[](2);     path[0] = address(usdm);     path[1] = uniswapRouter.WETH();     path[2] = address(engine.mochi());     usdm.approve(address(uniswapRouter), reward[msg.sender]);     // we are going to ingore the slippages here     uniswapRouter.swapExactTokensForTokens(         reward[msg.sender],         1,         path,         address(this),         type(uint256).max     ); ```  In `ReferralFeePoolV0.sol#claimRewardAsMochi()`, `path` is defined as an array of length 2 while it should be length 3.  As a result, at L33, an out-of-bound exception will be thrown and revert the transaction.  ### Impact  `claimRewardAsMochi()` will not work as expected so that all the referral fees cannot be claimed but stuck in the contract.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `VestedRewardPool.sol` contract is a public facing contract aimed at vesting tokens for a minimum of 90 days before allowing the recipient to withdraw their `mochi`. The `vest()` function does not utilise `safeTransferFrom()` to ensure that vested tokens are correctly allocated to the recipient. As a result, it is possible to frontrun a call to `vest()` and effectively steal a recipient's vested tokens. The same issue applies to the `lock()` function.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46 https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L54-L64  ## Tools Used  Manual code review Discussions with the Mochi team  ## Recommended Mitigation Steps  Ensure that users understand that this function should not be interacted directly as this could result in lost `mochi` tokens. Additionally, it might be worthwhile creating a single externally facing function which calls `safeTransferFrom()`, `vest()` and `lock()` in a single transaction.   
# Handle  leastwood   # Vulnerability details  ## Impact  The `FeePoolV0.sol` contract accrues fees upon the liquidation of undercollaterised positions. These fees are split between treasury and `vMochi` contracts. However, when `distributeMochi()` is called to distribute `mochi` tokens to `veCRV` holders, both `mochiShare` and `treasuryShare` is flushed from the contract when there are still `usdm` tokens in the contract.   ## Proof of Concept  Consider the following scenario:   - The `FeePoolV0.sol` contract contains 100 `usdm` tokens at an exchange rate of 1:1 with `mochi` tokens.   - `updateReserve()` is called to set the split of `usdm` tokens such that `treasuryShare` has claim on 20 `usdm` tokens and `mochiShare` has claim on the other 80 tokens.   - A `veCRV` holder seeks to increase their earnings by calling `distributeMochi()` before `sendToTreasury()` has been called.   - As a result, 80 `usdm` tokens are converted to `mochi` tokens and  locked in a curve rewards pool.   - Consequently, `mochiShare` and `treasuryShare` is set to `0` (aka flushed).   - The same user calls `updateReserve()` to split the leftover 20 `usdm` tokens between `treasuryShare` and `mochiShare`.    - `mochiShare` is now set to 16 `usdm` tokens.   - The above process is repeated to distribute `mochi` tokens to `veCRV` holders again and again.   - The end result is that `veCRV` holders have been able to receive all tokens that were intended to be distributed to the treasury.  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L94  ## Tools Used  Manual code review Discussions with the Mochi team.  ## Recommended Mitigation Steps  Consider removing the line in `FeePoolV0.sol` (mentioned above), where `treasuryShare` is flushed.   
# Handle  nikitastupin   # Vulnerability details  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/ChainlinkAdapter.sol#L49   The `ChainlinkAdapter` calls out to a Chainlink oracle receiving the `latestRoundData()`. If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale or incorrect data (if oracles are unable to submit no new round is started).  ## Recommended Mitigation Steps  Add the following checks:  ``` ... ( roundId, rawPrice, , updateTime, answeredInRound ) = AggregatorV3Interface(XXXXX).latestRoundData(); require(rawPrice > 0, "Chainlink price <= 0"); require(updateTime != 0, "Incomplete round"); require(answeredInRound >= roundId, "Stale price"); ... ```  ## References  - https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/#chainlinkoraclewrapper-latestrounddata-might-return-stale-results - https://github.com/code-423n4/2021-05-fairside-findings/issues/70  
# Handle  ye0lde   # Vulnerability details  ## Impact  Redundant arithmetic underflow/overflow checks can be avoided when an underflow/overflow cannot happen.  ## Proof of Concept  The "unchecked" keyword can be applied here since there is an "if" statement before to ensure the arithmetic operations, would not cause an integer underflow or overflow. https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L267  Change the code at 267 to: <code> unchecked {    debts -= _amount; } </code>  A similar change can be made here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L269  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Add the "unchecked" keyword as shown above.  
# Handle  jonah1005   # Vulnerability details   ## Impact [MochiVaultFactory.sol#L26-L37](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVaultFactory.sol#L26-L37) There's no permission control in the vaultFactory. Anyone can create a vault. The transaction would be reverted when the government tries to deploy such an asset.  As the protocol checks whether the vault is a valid vault by comparing the contract's address with the computed address, the protocol would recognize the random vault as a valid one.    I consider this is a medium-risk issue.  ## Proof of Concept  Here's a web3.py script to trigger the bug. ```py vault_factory.functions.deployVault(usdt.address).transact() ## this tx would be reverted profile.functions.registerAssetByGov([usdt.address], [3]).transact() ```  ## Tools Used  None  ## Recommended Mitigation Steps Recommend to add a check. ```solidity require(msg.sender == engine, "!engine"); ```  
# Handle  ye0lde   # Vulnerability details  ## Impact  Cache the result of engine.usdm().balanceOf to simplify code and save gas.  ## Proof of Concept  engine.usdm().balanceOf is called twice in function updateReserve here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L32-L38  I suggest modifying the code as follows: <code> function updateReserve() external override {   uint256 balanceOf = engine.usdm().balanceOf(address(this));  treasuryShare += ((balanceOf - mochiShare - treasuryShare) * treasuryRatio) / 1e18;  mochiShare = balanceOf - treasuryShare; } </code>  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See POC   
# Handle  harleythedog   # Vulnerability details  ## Impact On line 100 of DutchAuctionLiquidator.sol (within settleLiquidation), there is a require statement for auction.boughtAt == 0. This is already checked on line 121 within the "buy" function, and this is the only function that can possibly call settleLiquidation, so this require statement always passes. Removing it would save gas.  ## Proof of Concept Link to require statement here: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#:~:text=require(auction.boughtAt%20%3D%3D%200%2C%20%22liquidated%22)%3B  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps Remove unnecessary require statement described above to save gas.  
# Handle  harleythedog   # Vulnerability details  ## Impact Right now, there is only one discount profile in the github repo: the "NoDiscountProfile" which does not discount the debt at all. This specific discount profile works correctly, but I claim that any other discount profile will result in liquidation never working.  Suppose that we instead have a discount profile where discount() returns any value strictly larger than 0. Now, suppose someone wants to trigger a liquidation on a position. First, triggerLiquidation will be called (within DutchAuctionLiquidator.sol). The variable "debt" is initialized as equal to vault.currentDebt(_nftId). Notice that currentDebt(_ndfId) (within MochiVault.sol) simply scales the current debt of the position using the liveDebtIndex() function, but there is no discounting being done within the function - this will be important. Back within the triggerLiquidation function, the variable "collateral" is  simply calculated as the total collateral of the position. Then, the function calls vault.liquidate(_nftId, collateral, debt), and I claim that this will never work due to underflow.  Indeed, the liquidate function will first update the debt of the position (due to the updateDebt(_id) modifier). The debt of the position is thus updated using lines 99-107 in MochiVault.sol. We can see that the details[_id].debt is updated in the exact same way as the calculations for currentDebt(_nftId), however, there is the extra subtraction of the discountedDebt on line 107.   Eventually we will reach line 293 in MochiVault.sol. However, since we discounted the debt in the calculation of details[_id].debt, but we did not discount the debt for the passed in parameter _usdm (and thus is strictly larger in value), line 293 will always error due to an underflow. In summary, any discount profile that actually discounts the debt of the position will result in all liquidations erroring out due to this underflow. Since no positions will be liquidatable, this represents a major flaw in the contract as then no collateral can be liquidated so the entire functionality of the contract is compromised.  ## Proof of Concept Liquidate function in MochiVault.sol: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#:~:text=function-,liquidate,-(  triggerLiquidation function in DutchAuctionLiquidator.sol: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#:~:text=function-,triggerLiquidation,-(address%20_asset%2C%20uint256  Retracing the steps as I have described above, we can see that any call to triggerLiquidation will result in:  details[_id].debt -= _usdm;  throwing an error since _usdm will be larger than details[_id].debt.  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps An easy fix is to simply change:  details[_id].debt -= _usdm;  to be:  details[_id].debt = 0;  as liquidating a position should probably just be equivalent to repaying all of the debt in the position.   Side Note: If there are no other discount profiles planned to be added other than "NoDiscountProfile", then I would recommend deleting all of the discount logic entirely, since NoDiscountProfile doesn't actually do anything  
# Handle  0x0x0x   # Vulnerability details   ## Impact Gas optimization.  ## Proof of Concept  ``` for (uint i = 0; i < arr.length; i++) {     //Operations not effecting the length of the array. } ``` Loading length for storage arrays cost 100 gas and for memory arrays it costs 3 gas. When arr.length is defined as the condition of for loop, at the start of every iteration the length is loaded from memory. If the length doesn't change during the loop, loading the length of arrays repeatedly can be avoided by saving the length to the stack. ``` uint length = arr.length; for (uint i = 0; i < length; i++) {     //Operations not effecting the length of the array. } ``` By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Locations ``` ./mochi-core/contracts/profile/MochiProfileV0.sol:68:        for (uint256 i = 0; i < _asset.length; i++) { ./mochi-core/contracts/profile/MochiProfileV0.sol:86:        for (uint256 i = 0; i < _assets.length; i++) { ./mochi-core/contracts/profile/MochiProfileV0.sol:95:        for (uint256 i = 0; i < _assets.length; i++) { ./mochi-cssr/contracts/MochiCSSRv0.sol:41:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:47:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:66:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:77:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/adapter/ChainlinkAdapter.sol:34:        for(uint256 i = 0; i<_assets.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:63:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:122:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:175:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:36:  for (uint i=0; i<parentNodes.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:78:  for(uint i=pathPtr; i<pathPtr+partialPath.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:108:  for(uint i=offset; i<nibbleArray.length; i++) { ./mochi-library/contracts/SushiswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./mochi-library/contracts/SushiswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) { ./mochi-library/contracts/UniswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./mochi-library/contracts/UniswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) { ``` ## A similar case  nibblePath.length is constant but it is read at every iteration for require statement.  ```./mochi-library/contracts/MerklePatriciaVerifier.sol:36: require(pathPtr <= nibblePath.length, "Path overflow");```    
# Handle  jonah1005   # Vulnerability details  ## Impact MochiEngine allows the operator to change the NFT contract. [MochiEngine.sol#L91-L93](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93) All the vaults would point to a different NFT address. As a result, users would not be access their positions. The entire protocol would be broken.  IMHO, A function that would break the entire protocol shouldn't exist.  I consider this is a high-risk issue. ## Proof of Concept [MochiEngine.sol#L91-L93](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93)  ## Tools Used None ## Recommended Mitigation Steps Remove the function.   
# Handle  jonah1005   # Vulnerability details  # regerralFeePool is vulnerable to MEV searcher  ## Impact `claimRewardAsMochi` in the `ReferralFeePoolV0` ignores slippage. This is not a desirable design. There are a lot of MEV searchers in the current network. Swapping assets with no slippage control would get rekted. Please refer to https://github.com/flashbots/pm.  Given the current state of the Ethereum network. Users would likely be sandwiched. I consider this is a high-risk issue.  ## Proof of Concept [ReferralFeePoolV0.sol#L28-L48](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L48)  Please refer to https://medium.com/immunefi/mushrooms-finance-theft-of-yield-bug-fix-postmortem-16bd6961388f  to see a possible attack pattern.   ## Tools Used  None  ## Recommended Mitigation Steps I recommend adding minReceivedAmount as a parameter.  ```solidity function claimRewardAsMochi(uint256 _minReceivedAmount) external {     // original logic here     require(engine.mochi().balanceOf(address(this)) > _minReceivedAmount, "!min");     engine.mochi().transfer(         msg.sender,         engine.mochi().balanceOf(address(this))     ); } ``` Also, the front-end should calculate the min amount with the current price.  
# Handle  jonah1005   # Vulnerability details  # treasury is vulnerable to sandwich attack.   ## Impact There's a permissionless function `veCRVlock` in MochiTreasury. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds. [MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)  Attackers can possibly steal all the funds in the treasury. I consider this is a high-risk issue.  ## Proof of Concept [MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)  Here's an exploit pattern 1. Flashloan and buy CRV the uniswap pool 2. Trigger `veCRVlock()` 3. The treasury buys CRV at a very high price. 4. Sell CRV and pay back the loan.  ## Tools Used  None  ## Recommended Mitigation Steps Recommend to add `onlyOwner` modifier.   
# Handle  gzeon   # Vulnerability details  ## Impact function claimRewardAsMochi in ReferralFeePoolV0.sol did not reduce user reward balance, allowing referrer to claim the same reward repeatedly and thus draining the fee pool.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol L28-47 did not reduce user reward balance  ## Tools Used None  ## Recommended Mitigation Steps Add the following lines > rewards -= reward[msg.sender]; > reward[msg.sender] = 0;   
# Handle  gzeon   # Vulnerability details  ## Impact Auction struct in DutchAuctionLiquidator.sol can be optimized to reduce 2 storage slot  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol L18-L25: the struct can changed into struct Auction {         uint256 nftId;         address vault;         uint48 startedAt;         uint48 boughtAt;         uint256 collateral;         uint256 debt;     } startedAt and boughtAt store block numbers, and 2^48 is be enough for a very long time.  ## Tools Used None  ## Recommended Mitigation Steps Change the struct as suggested above, also need to cast whenever startedAt and boughtAt is used.  
# Handle  gzeon   # Vulnerability details  ## Impact There is a status enum Liquidated but was not used anywhere in the code.   ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol L277-296 status was not set to Status.Liquidated after liquidation  ## Tools Used None  ## Recommended Mitigation Steps details[id].status = Status.Liquidated;  
# Handle  ye0lde   # Vulnerability details  ## Impact  Caching the "vesting" state variable instead of repeatedly reading and writing it will decrease deployment and runtime gas.  This is especially true for the modifier "checkClaimable" which is used on every function in the contract.   ## Proof of Concept  The checkClaimable function is here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L22-L29  An example of its use is here along with many other accesses to the "vesting" state variable. https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest modifying "checkClaimable as follows:     <code> function checkClaimable(Vesting memory v) internal pure returns(Vesting memory) {   if (v.ends < block.timestamp) {   v.claimable += v.vested;   v.vested = 0;   v.ends = 0;  }  return v; } </code>  and I suggest these changes to function "vest"   <code> function vest(address _recipient) external {  Vesting memory v = checkClaimable(vesting[_recipient]);  uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;  uint256 weightedEnd = (v.vested *   v.ends +   amount *   (block.timestamp + 90 days)) /   (v.vested + amount);  v.vested += amount;  v.ends = weightedEnd;  vesting[_recipient] = v;  mochiUnderManagement += amount; } </code>  These functions are also candidates for similar changes: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L48-L71   
# Handle  defsec   # Vulnerability details  ## Impact  This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract. Calling each function, we can see that the public function uses 496 gas, while the external function uses only 261.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.  Slither Detector:  external-function:  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L75  ## Tools Used  Slither  ## Recommended Mitigation Steps  1. Clone repository for Mochi Smart Contracts. 2. Create a python virtual environment with a stable python version. 3. Install Slither Analyzer on the python VEM. 4. Run Slither against all contracts. 5. Define public functions as an external for the gas optimization.  
# Handle  gzeon   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/interfaces/IMochiVault.sol L6-L12: the struct can be reordered into struct Detail {     Status status;     address referrer;     uint256 collateral;     uint256 debt;     uint256 debtIndex; }  such that status and referrer are put into the same slot, should save ~2000 gas per borrow  ## Tools Used None  ## Recommended Mitigation Steps Reorder the struct as suggested, and modify impacted code at  IMochiVault.sol L28-L34 DutchAuctionLiquidator.sol L77  ## Extra Realistically, the range of debtIndex (start at 1e18 and increase by fee per year) probably fit in a uint88(11bytes) so you can pack (status(1byte), referrer(20bytes), debtIndex(11bytes)) all in 32 bytes, saving another storage slot.   
# Handle  gzeon   # Vulnerability details  ## Impact Some of the require statements in MochiVault.sol can be placed earlier to reduce gas usage on revert  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol L226-227: can be placed at the very top of the function to avoid the expensive cssr call L237: can be placed before initialization of increasingDebt  ## Tools Used None  ## Recommended Mitigation Steps Relocate the said require statements  
# Handle  gpersoon   # Vulnerability details  ## Impact The value of the global variable debts in the contract MochiVault.sol is calculated in an inconsistent way.  In the function borrow() the variable debts is increased with a value excluding the fee. However in repay() and liquidate() it is decreased with the same value as details[_id].debt is decreased,, which is including the fee.  This would mean that debts will end up in a negative value when all debts are repay-ed. Luckily the function repay() prevents this from happening.  In the mean time the value of debts isn't accurate. This value is used directly or indirectly in:  - utilizationRatio(), stabilityFee() calculateFeeIndex() of MochiProfileV0.sol  - liveDebtIndex(), accrueDebt(), currentDebt() of MochiVault.sol  This means the entire debt and claimable calculations are slightly off.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol  function borrow(..)     details[_id].debt = totalDebt; // includes the fee     debts += _amount;     // excludes the fee   function repay(..)     debts -= _amount;       details[_id].debt -= _amount;  function liquidate(..)    debts -= _usdm;    details[_id].debt -= _usdm;  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L263-L268  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L272-L283  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L242-L256  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L258-L269  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L66-L73  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L79-L88  ## Tools Used  ## Recommended Mitigation Steps In function borrow(): replace     debts += _amount; with     debts += totalDebt  
# Handle  gpersoon   # Vulnerability details  ## Impact Every time you deposit some assets in the vault (via deposit() of MochiVault.sol) then "lastDeposit[_id]" is set to block.timestamp. The modifier wait() checks this value and makes sure you cannot withdraw for "delay()" blocks. The default value for delay() is 3 minutes.  Knowing this delay you can do a griefing attack: On chains with low gas fees: every 3 minutes deposit a tiny amount for a specific NFT-id (which has a large amount of assets). On chains with high gas fees: monitor the mempool for a withdraw() transaction and frontrun it with a deposit()  This way the owner of the NFT-id can never withdraw the funds.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L47-L54  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L171  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L33  ## Tools Used  ## Recommended Mitigation Steps Create a mechanism where you only block the withdraw of recently deposited funds   
# Handle  leastwood   # Vulnerability details  ## Impact  `MochiTreasuryV0.sol` interacts with Curve's voting escrow contract to lock tokens for 90 days, where it can be later withdrawn by the governance role. However, `VotingEscrow.vy` does not allow contracts to call the following functions; `create_lock()`, `increase_amount()` and `increase_unlock_time()`. For these functions, `msg.sender` must be an EOA account or an approved smart wallet. As a result, any attempt to lock tokens will fail in `MochiTreasuryV0.sol`.  ## Proof of Concept  https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L418 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L438 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L455  ## Tools Used  Manual code review Discussions with the Mochi team  ## Recommended Mitigation Steps  Consider updating this contract to potentially use another escrow service that enables `msg.sender` to be a contract. Alternatively, this escrow functionality can be replaced with an internal contract which holds `usdm` tokens instead, removing the need to convert half of the tokens to Curve tokens. Holding Curve tokens for a minimum of 90 days may overly expose the Mochi treasury to Curve token price fluctuations.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `MochiTreasuryV0.sol` contract freely receives ETH from users/other contracts. In the event this does happen, ETH is permanently locked and unrecoverable by the protocol's governance framework.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol  ## Tools Used  Manual code review Slither  ## Recommended Mitigation Steps  Consider enabling ETH withdraws for the governance role.  
# Handle  leastwood   # Vulnerability details  ## Impact  `withdrawLock()` does not prevent users from calling this function when locking has been toggled. As a result, withdraws may be made unexpectedly.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L40-L42  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider adding `require(lockCrv, "!lock");` to `withdrawLock()` to ensure this function is not called unexpectedly. Alternatively if this is intended behaviour, it should be rather checked that the lock has not been toggled, otherwise users could maliciously relock tokens.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `BeaconProxyDeployer.deploy()` function is used to deploy lightweight proxy contracts that act as each asset's vault. The function does not revert properly if there is a failed contract deployment or revert from the `create2` opcode as it does not properly check the returned address for bytecode. The `create2` opcode returns the expected address which will never be the zero address (as is what is currently checked).  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-library/contracts/BeaconProxyDeployer.sol#L31  ## Tools Used  Manual code review Discussions with the Mochi team Discussions with library dev  ## Recommended Mitigation Steps  The recommended mitigation was to update `iszero(result)` to `iszero(extcodesize(result))` in the line mentioned above. This change has already been made in the corresponding library which can be found [here](https://github.com/Nipol/bean-contracts/pull/13), however, this needs to also be reflected in Mochi's contracts.  
# Handle  pauliax   # Vulnerability details  ## Impact contract USDM does not need to import IERC3156FlashLender again as it was already imported in IUSDM.   import "../interfaces/IERC3156FlashLender.sol";  contract DutchAuctionLiquidator makes no use of these imports:   import "@openzeppelin/contracts/token/ERC721/IERC721.sol";   import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";   import "@mochifi/library/contracts/BeaconProxyDeployer.sol";  ## Recommended Mitigation Steps Consider reviewing all the unused imports and removing them to reduce the size of the contract and thus save some deployment gas.  
# Handle  pauliax   # Vulnerability details  ## Impact Gas efficiency can be achieved by tightly packing the struct. Struct variables are stored in 32 bytes each so you can group smaller types to occupy less storage. For example, startedAt or boughtAt in Auction struct hold block.number so realistically this does not need uint256 and you can consider storing it in lower type. You can read more here: https://fravoll.github.io/solidity-patterns/tight_variable_packing.html or in the official documentation: https://docs.soliditylang.org/en/v0.4.21/miscellaneous.html  ## Recommended Mitigation Steps Search for an optimal size and order of structs to reduce gas usage.  
# Handle  pauliax   # Vulnerability details  ## Impact This not only loses some precision (cuz of multiplication and division) but also consumes more gas:     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     );  ## Recommended Mitigation Steps Proposed improvement:   // send Mochi to vMochi Vault   uint toVault = (mochiBalance * vMochiRatio) / 1e18;   mochi.transfer(       address(engine.vMochi()),       toVault   );   // send Mochi to veCRV Holders   mochi.transfer(       crvVoterRewardPool,       mochiBalance - toVault;   );  This way you the whole mochiBalance will be transferred and it will cost less to do that as fewer math operations are performed.  
# Handle  ye0lde   # Vulnerability details  ## Impact Open TODOs can point to programming or other errors that still need to be fixed.  ## Proof of Concept  These are TODOs written as comments: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L57 https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L163  ## Tools Used VS Code  ## Recommended Mitigation Steps Resolve the TODOs/open questions.   
# Handle  cmichel   # Vulnerability details  The `UniswapV2LPAdapter/SushiswapV2LPAdapter.update` function retrieves the `underlying` from the LP token pair (`_asset`) but then calls `router.update(_asset, _proof)` which is the LP token itself again. This will end up with the router calling this function again recursively.  ## Impact This function fails as there's an infinite recursion and eventually runs out of gas.  ## Recommendation The idea was most likely to update the `underlying` price which is used in `_getPrice` as `uint256 eAvg = cssr.getExchangeRatio(_underlying, weth);`.  Call `router.update(underlying, _proof)` instead. Note that the `_proof` does not necessarily update the `underlying <> WETH` pair, it could be any `underlying <> keyAsset` pair.   
# Handle  cmichel   # Vulnerability details  Governance can change the `engine.nft` address which is used by vaults to represent collateralized debt positions (CDP). When minting a vault using `MochiVault.mint` the address returned ID will be used and overwrite the state of an existing debt position and set its status to `Idle`.  ## Impact Changing the NFT address will allow overwriting existing CDPs.  ## Recommended Mitigation Steps Disallow setting a new NFT address. or ensure that the new NFT's IDs start at the old NFT's IDs.  
# Handle  cmichel   # Vulnerability details  The total `debt` in `MochiVault.accrueDebt` increases by the current `debt` times the debt index growth. This is correct but the total `debt` is then _reduced_ again by the calling _user's_ discounted debt, meaning, the total debt depends on which specific user performs the debt accrual.  This should not be the case.  ## POC Assume we have a total debt of `2000`, two users A and B, where A has a debt of 1000, and B has a debt of 100. The (previous) `debtIndex = 1.0` and accruing it now would increase it to `1.1`.  There's a difference if user A or B first does the accrual.  #### User A accrues first User A calls `accrueDebt`: `increased = 2000 * 1.1/1.0 - 2000 = 200`. Thus `debts` is first set to `2200`. The user's `increasedDebt = 1000 * 1.1 / 1.0 - 1000 = 100` and assume a discount of `10%`, thus `discountedDebt = 100 * 10% = 10`. Then `debts = 2200 - 10 = 2190`.  The next accrual will work with a total debt of `2190`.  #### User B accruess first User B calls `accrueDebt`: `increased = 2000 * 1.1/1.0 - 2000 = 200`. Thus `debts` is first set to `2200`. The user's `increasedDebt = 100 * 1.1 / 1.0 - 100 = 10` and assume a discount of `10%`, thus `discountedDebt = 10 * 10% = 1`. Then `debts = 2200 - 1 = 2199`.  The next accrual will work with a total debt of `2199`, leading to more debt overall.  ## Impact The total debt of a system depends on who performs the accruals which should ideally not be the case. The discrepancy compounds and can grow quite large if a whale always does the accrual compared to someone with almost no debt or no discount.  ## Recommended Mitigation Steps Don't use the discounts or track the weighted average discount across all users that is subtracted from the increased total debt each time, i.e., reduce it by the discount of **all users** (instead of current caller only) when accruing to correctly track the debt.   
# Handle  WatchPug   # Vulnerability details  In the current implementation, a liquidated position can be used for depositing and borrowing again.  However, if there is a liquidation auction ongoing, even if the position is now `liquidatable`, the call of `triggerLiquidation()` will still fail.   The liquidator must `settleLiquidation` first.  If the current auction is not profitable for the liquidator, say the value of the collateral can not even cover the gas cost, the liquidator may be tricked and not liquidate the new loan at all.  Considering if the liquidator bot is not as small to handle this situation (take the profit of the new liquidation and the gas cost loss of the current auction into consideration), a malicious user can create a dust amount position trigger the liquidation by themself.  Since the collateral of this position is so small that it can not even cover the gas cost, liquidators will most certainly ignore this auction.  The malicious user will then deposit borrow the actual loan.  When this loan becomes `liquidatable`, liquidators may:  1. confuse the current dust auction with the `liquidatable` position; 2. unable to proceed with such a complex liquidation.  As a result, the malicious user can potentially escape liquidation.  ### Recommendation  Consider making liquidated positions unable to be used (for depositing and borrowing) again.  
# Handle  cmichel   # Vulnerability details  The `MochiProfileV0` defines liquidation and collateral factors for different asset types. For the `AssetClass.Sigma` type, the liquidation factor is _less_ than the collateral factor:  ```solidity function liquidationFactor(address _asset)     public     view     override     returns (float memory) {     AssetClass class = assetClass(_asset);     if (class == AssetClass.Sigma) { // } else if (class == AssetClass.Sigma) {         return float({numerator: 40, denominator: 100});     } }  function maxCollateralFactor(address _asset)     public     view     override     returns (float memory) {     AssetClass class = assetClass(_asset);     if (class == AssetClass.Sigma) {         return float({numerator: 45, denominator: 100});     } } ```  This means that one can take a loan of up to 45% of their collateral but then immediately gets liquidated as the liquidation factor is only 40%. There should always be a buffer between these such that taking the max loan does not immediately lead to liquidations:  > A safety buffer is maintained between max CF and LF to protect users against liquidations due to normal volatility. [Docs](https://hackmd.io/@az-/mochi-whitepaper#Collateral-Factor-CF)   ## Recommended Mitigation Steps The max collateral factor for the Sigma type should be higher than its liquidation factor.   
# Handle  cmichel   # Vulnerability details  If a flashloan contract does not properly authenticate the `USDM` flashloan contract callbacks, anyone can perform a griefing attack which will lead to the caller losing tokens equal to the fees.  This is because the flashloan `receiver` is not authenticated and anyone can start flashloans on behalf of another contract. They don't even need to approve the `usdm` contract as it uses internal `_burn` and `_transfer` functions instead of `burnFrom`/`transferFrom`.  #### POC  1. Call `FlashLoan.flashLoan(receiver=victim, ...)`. 2. Loan amount + fees will be burned/transferred from the `receiver` in `_loan`.  If fees are non-zero, it's possible to drain the victim's balance if their contract is implemented incorrectly without proper authentication checks.  #### Recommendation This is an inherent issue with EIP-3156 which defines the interface with an arbitrary `receiver`. Contracts should be aware to revert if the flashloan was not initiated by them.  To mitigate this issue one could use functions that work with explicit approvals from the victim, instead of using internal `_burn` and `_transfer` functions. This way, the victim must first have approved the tokens for transfer.   
# Handle  WatchPug   # Vulnerability details  In `MochiProfileV0.sol`, `secPerYear` is defined as an immutable variable while it's not configured as a parameter of the constructor. Thus, it can be declared as constant to save gas.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L23-L28  ```solidity=23 uint256 public immutable secPerYear;  uint256 public override delay;  constructor(address _engine) {     secPerYear = 31536000; ```  ### Recommendation  Change to:  ```solidity=23 uint256 public constant SEC_PER_YEAR = 31536000; ```  
# Handle  WatchPug   # Vulnerability details  The check of `x > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `x <= 3`.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/UniswapV2LPAdapter.sol#L106-L117  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/SushiswapV2LPAdapter.sol#L106-L117  ```solidity=106 function sqrt(uint x) internal pure returns (uint y) {     if (x > 3) {         uint z = x / 2 + 1;         y = x;         while (z < y) {             y = z;             z = (x / z + z) / 2;         }     } else if (x != 0) {         y = 1;     } } ```  ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  
# Handle  WatchPug   # Vulnerability details  `distributeMochi()` will call `_buyMochi()` to convert `mochiShare` to Mochi token and call `_shareMochi()` to send Mochi to vMochi Vault and veCRV Holders. It wont touch the `treasuryShare`.  However, in the current implementation, `treasuryShare` will be reset to `0`. This is unexpected and will cause the protocol fee can not be properly accounted for and collected.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L79-L95  ```solidity=79 function _shareMochi() internal {     IMochi mochi = engine.mochi();     uint256 mochiBalance = mochi.balanceOf(address(this));     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     );     // flush mochiShare     mochiShare = 0;     treasuryShare = 0; } ```  ### Impact  Anyone can call `distributeMochi()` and reset `treasuryShare` to `0`, and then call `updateReserve()` to allocate part of the wrongfuly resetted `treasuryShare` to `mochiShare` and call `distributeMochi()`.  Repeat the steps above and the `treasuryShare` will be consumed to near zero, profits the vMochi Vault holders and veCRV Holders. The protocol suffers the loss of funds.  ### Recommendation  Change to:  ```solidity=64 function _buyMochi() internal {     IUSDM usdm = engine.usdm();     address[] memory path = new address[](2);     path[0] = address(usdm);     path[1] = address(engine.mochi());     usdm.approve(address(uniswapRouter), mochiShare);     uniswapRouter.swapExactTokensForTokens(         mochiShare,         1,         path,         address(this),         type(uint256).max     );     // flush mochiShare     mochiShare = 0; }  function _shareMochi() internal {     IMochi mochi = engine.mochi();     uint256 mochiBalance = mochi.balanceOf(address(this));     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     ); } ```  
# Handle  WatchPug   # Vulnerability details  `treasuryRatio` and `vMochiRatio` must be `<= 1e18` to make sure the contract works correctly. Therefore, the input should be checked in the setters.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L45-L53  ```solidity=45 function changeTreasuryRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), "!gov");     treasuryRatio = _ratio; }  function changevMochiRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), "!gov");     vMochiRatio = _ratio; } ```  ### Recommendation  Change to:  ```solidity=45 function changeTreasuryRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), "!gov");     require(_ratio <= 1e18, ">1e18");     treasuryRatio = _ratio; }  function changevMochiRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), "!gov");     require(_ratio <= 1e18, ">1e18");     vMochiRatio = _ratio; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L67-L68  ```solidity=67 mochi.transfer(msg.sender, _amount / 2); mochi.transfer(address(vMochi), _amount / 2); ```  Change to:  ```solidity=67 mochi.transfer(msg.sender, _amount / 2); mochi.transfer(address(vMochi), _amount - _amount / 2); ```  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L59-L65  ```solidity=63 operationShare += updatedFee / 2; veCRVShare += updatedFee / 2; ```  Change to:  ```solidity=63 operationShare += updatedFee / 2; veCRVShare += updatedFee - updatedFee / 2; ```  
# Handle  WatchPug   # Vulnerability details  When liquidators race to liquidate a position, all other besides the first liquidator will be handling an empty (liquidated) position.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#L69-L81  ```solidity=69 function triggerLiquidation(address _asset, uint256 _nftId)     external     override {     IMochiVault vault = engine.vaultFactory().getVault(_asset);     Auction storage auction = auctions[auctionId(_asset, _nftId)];     require(auction.startedAt == 0 || auction.boughtAt != 0, "on going");     uint256 debt = vault.currentDebt(_nftId);      (, uint256 collateral, , , ) = vault.details(_nftId);      vault.liquidate(_nftId, collateral, debt);     ... ```  In the current implementation, even if the position is liquidated, at L77 and L79, it still tries to get the details and call `vault.liquidate()`, until it reverts at L285-L288 on `MochiVault.sol#liquidate()`. That's going to cost a decent amount of gas due to these unnecessary external calls and code executions.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L277-L288  ```solidity=277{285-288} function liquidate(     uint256 _id,     uint256 _collateral,     uint256 _usdm ) external override updateDebt(_id) {     require(msg.sender == address(engine.liquidator()), "!liquidator");     require(engine.nft().asset(_id) == address(asset), "!asset");     float memory price = engine.cssr().getPrice(address(asset));     require(         _liquidatable(details[_id].collateral, price, currentDebt(_id)),         "healthy"     );     ... ```  Therefore, adding a precondition check can save gas.    ### Recommendation  Change to:  ```solidity=69{77} function triggerLiquidation(address _asset, uint256 _nftId)     external     override {     IMochiVault vault = engine.vaultFactory().getVault(_asset);     Auction storage auction = auctions[auctionId(_asset, _nftId)];     require(auction.startedAt == 0 || auction.boughtAt != 0, "on going");     uint256 debt = vault.currentDebt(_nftId);     require(debt > 0, "!debt");     (, uint256 collateral, , , ) = vault.details(_nftId);      vault.liquidate(_nftId, collateral, debt);     ... ```  
# Handle  WatchPug   # Vulnerability details  When the vesting ends, `vesting[recipient].ends` will be `0` which always passes the check of `vesting[recipient].ends < block.timestamp` and causes unnecessary code execution.  Adding a check of `vesting[recipient].ends > 0` can avoid unnecessary code execution and save gas.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L22-L29  ```solidity modifier checkClaimable(address recipient) {     if (vesting[recipient].ends < block.timestamp) {         vesting[recipient].claimable += vesting[recipient].vested;         vesting[recipient].vested = 0;         vesting[recipient].ends = 0;     }     _; } ```  ### Recommendation  Change to:  ```solidity modifier checkClaimable(address recipient) {     if (vesting[recipient].ends > 0 && vesting[recipient].ends < block.timestamp) {         vesting[recipient].claimable += vesting[recipient].vested;         vesting[recipient].vested = 0;         vesting[recipient].ends = 0;     }     _; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L42  ```solidity=28 function claimRewardAsMochi() external {     IUSDM usdm = engine.usdm();     address[] memory path = new address[](2);     path[0] = address(usdm);     path[1] = uniswapRouter.WETH();     path[2] = address(engine.mochi());     usdm.approve(address(uniswapRouter), reward[msg.sender]);     // we are going to ingore the slippages here     uniswapRouter.swapExactTokensForTokens(         reward[msg.sender],         1,         path,         address(this),         type(uint256).max     ); ```  In `ReferralFeePoolV0.sol#claimRewardAsMochi()`, `path` is defined as an array of length 2 while it should be length 3.  As a result, at L33, an out-of-bound exception will be thrown and revert the transaction.  ### Impact  `claimRewardAsMochi()` will not work as expected so that all the referral fees cannot be claimed but stuck in the contract.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `VestedRewardPool.sol` contract is a public facing contract aimed at vesting tokens for a minimum of 90 days before allowing the recipient to withdraw their `mochi`. The `vest()` function does not utilise `safeTransferFrom()` to ensure that vested tokens are correctly allocated to the recipient. As a result, it is possible to frontrun a call to `vest()` and effectively steal a recipient's vested tokens. The same issue applies to the `lock()` function.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46 https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L54-L64  ## Tools Used  Manual code review Discussions with the Mochi team  ## Recommended Mitigation Steps  Ensure that users understand that this function should not be interacted directly as this could result in lost `mochi` tokens. Additionally, it might be worthwhile creating a single externally facing function which calls `safeTransferFrom()`, `vest()` and `lock()` in a single transaction.   
# Handle  leastwood   # Vulnerability details  ## Impact  The `FeePoolV0.sol` contract accrues fees upon the liquidation of undercollaterised positions. These fees are split between treasury and `vMochi` contracts. However, when `distributeMochi()` is called to distribute `mochi` tokens to `veCRV` holders, both `mochiShare` and `treasuryShare` is flushed from the contract when there are still `usdm` tokens in the contract.   ## Proof of Concept  Consider the following scenario:   - The `FeePoolV0.sol` contract contains 100 `usdm` tokens at an exchange rate of 1:1 with `mochi` tokens.   - `updateReserve()` is called to set the split of `usdm` tokens such that `treasuryShare` has claim on 20 `usdm` tokens and `mochiShare` has claim on the other 80 tokens.   - A `veCRV` holder seeks to increase their earnings by calling `distributeMochi()` before `sendToTreasury()` has been called.   - As a result, 80 `usdm` tokens are converted to `mochi` tokens and  locked in a curve rewards pool.   - Consequently, `mochiShare` and `treasuryShare` is set to `0` (aka flushed).   - The same user calls `updateReserve()` to split the leftover 20 `usdm` tokens between `treasuryShare` and `mochiShare`.    - `mochiShare` is now set to 16 `usdm` tokens.   - The above process is repeated to distribute `mochi` tokens to `veCRV` holders again and again.   - The end result is that `veCRV` holders have been able to receive all tokens that were intended to be distributed to the treasury.  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L94  ## Tools Used  Manual code review Discussions with the Mochi team.  ## Recommended Mitigation Steps  Consider removing the line in `FeePoolV0.sol` (mentioned above), where `treasuryShare` is flushed.   
# Handle  nikitastupin   # Vulnerability details  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/ChainlinkAdapter.sol#L49   The `ChainlinkAdapter` calls out to a Chainlink oracle receiving the `latestRoundData()`. If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale or incorrect data (if oracles are unable to submit no new round is started).  ## Recommended Mitigation Steps  Add the following checks:  ``` ... ( roundId, rawPrice, , updateTime, answeredInRound ) = AggregatorV3Interface(XXXXX).latestRoundData(); require(rawPrice > 0, "Chainlink price <= 0"); require(updateTime != 0, "Incomplete round"); require(answeredInRound >= roundId, "Stale price"); ... ```  ## References  - https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/#chainlinkoraclewrapper-latestrounddata-might-return-stale-results - https://github.com/code-423n4/2021-05-fairside-findings/issues/70  
# Handle  ye0lde   # Vulnerability details  ## Impact  Redundant arithmetic underflow/overflow checks can be avoided when an underflow/overflow cannot happen.  ## Proof of Concept  The "unchecked" keyword can be applied here since there is an "if" statement before to ensure the arithmetic operations, would not cause an integer underflow or overflow. https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L267  Change the code at 267 to: <code> unchecked {    debts -= _amount; } </code>  A similar change can be made here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L269  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Add the "unchecked" keyword as shown above.  
# Handle  jonah1005   # Vulnerability details   ## Impact [MochiVaultFactory.sol#L26-L37](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVaultFactory.sol#L26-L37) There's no permission control in the vaultFactory. Anyone can create a vault. The transaction would be reverted when the government tries to deploy such an asset.  As the protocol checks whether the vault is a valid vault by comparing the contract's address with the computed address, the protocol would recognize the random vault as a valid one.    I consider this is a medium-risk issue.  ## Proof of Concept  Here's a web3.py script to trigger the bug. ```py vault_factory.functions.deployVault(usdt.address).transact() ## this tx would be reverted profile.functions.registerAssetByGov([usdt.address], [3]).transact() ```  ## Tools Used  None  ## Recommended Mitigation Steps Recommend to add a check. ```solidity require(msg.sender == engine, "!engine"); ```  
# Handle  ye0lde   # Vulnerability details  ## Impact  Cache the result of engine.usdm().balanceOf to simplify code and save gas.  ## Proof of Concept  engine.usdm().balanceOf is called twice in function updateReserve here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L32-L38  I suggest modifying the code as follows: <code> function updateReserve() external override {   uint256 balanceOf = engine.usdm().balanceOf(address(this));  treasuryShare += ((balanceOf - mochiShare - treasuryShare) * treasuryRatio) / 1e18;  mochiShare = balanceOf - treasuryShare; } </code>  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See POC   
# Handle  harleythedog   # Vulnerability details  ## Impact On line 100 of DutchAuctionLiquidator.sol (within settleLiquidation), there is a require statement for auction.boughtAt == 0. This is already checked on line 121 within the "buy" function, and this is the only function that can possibly call settleLiquidation, so this require statement always passes. Removing it would save gas.  ## Proof of Concept Link to require statement here: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#:~:text=require(auction.boughtAt%20%3D%3D%200%2C%20%22liquidated%22)%3B  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps Remove unnecessary require statement described above to save gas.  
# Handle  harleythedog   # Vulnerability details  ## Impact Right now, there is only one discount profile in the github repo: the "NoDiscountProfile" which does not discount the debt at all. This specific discount profile works correctly, but I claim that any other discount profile will result in liquidation never working.  Suppose that we instead have a discount profile where discount() returns any value strictly larger than 0. Now, suppose someone wants to trigger a liquidation on a position. First, triggerLiquidation will be called (within DutchAuctionLiquidator.sol). The variable "debt" is initialized as equal to vault.currentDebt(_nftId). Notice that currentDebt(_ndfId) (within MochiVault.sol) simply scales the current debt of the position using the liveDebtIndex() function, but there is no discounting being done within the function - this will be important. Back within the triggerLiquidation function, the variable "collateral" is  simply calculated as the total collateral of the position. Then, the function calls vault.liquidate(_nftId, collateral, debt), and I claim that this will never work due to underflow.  Indeed, the liquidate function will first update the debt of the position (due to the updateDebt(_id) modifier). The debt of the position is thus updated using lines 99-107 in MochiVault.sol. We can see that the details[_id].debt is updated in the exact same way as the calculations for currentDebt(_nftId), however, there is the extra subtraction of the discountedDebt on line 107.   Eventually we will reach line 293 in MochiVault.sol. However, since we discounted the debt in the calculation of details[_id].debt, but we did not discount the debt for the passed in parameter _usdm (and thus is strictly larger in value), line 293 will always error due to an underflow. In summary, any discount profile that actually discounts the debt of the position will result in all liquidations erroring out due to this underflow. Since no positions will be liquidatable, this represents a major flaw in the contract as then no collateral can be liquidated so the entire functionality of the contract is compromised.  ## Proof of Concept Liquidate function in MochiVault.sol: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#:~:text=function-,liquidate,-(  triggerLiquidation function in DutchAuctionLiquidator.sol: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#:~:text=function-,triggerLiquidation,-(address%20_asset%2C%20uint256  Retracing the steps as I have described above, we can see that any call to triggerLiquidation will result in:  details[_id].debt -= _usdm;  throwing an error since _usdm will be larger than details[_id].debt.  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps An easy fix is to simply change:  details[_id].debt -= _usdm;  to be:  details[_id].debt = 0;  as liquidating a position should probably just be equivalent to repaying all of the debt in the position.   Side Note: If there are no other discount profiles planned to be added other than "NoDiscountProfile", then I would recommend deleting all of the discount logic entirely, since NoDiscountProfile doesn't actually do anything  
# Handle  0x0x0x   # Vulnerability details   ## Impact Gas optimization.  ## Proof of Concept  ``` for (uint i = 0; i < arr.length; i++) {     //Operations not effecting the length of the array. } ``` Loading length for storage arrays cost 100 gas and for memory arrays it costs 3 gas. When arr.length is defined as the condition of for loop, at the start of every iteration the length is loaded from memory. If the length doesn't change during the loop, loading the length of arrays repeatedly can be avoided by saving the length to the stack. ``` uint length = arr.length; for (uint i = 0; i < length; i++) {     //Operations not effecting the length of the array. } ``` By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Locations ``` ./mochi-core/contracts/profile/MochiProfileV0.sol:68:        for (uint256 i = 0; i < _asset.length; i++) { ./mochi-core/contracts/profile/MochiProfileV0.sol:86:        for (uint256 i = 0; i < _assets.length; i++) { ./mochi-core/contracts/profile/MochiProfileV0.sol:95:        for (uint256 i = 0; i < _assets.length; i++) { ./mochi-cssr/contracts/MochiCSSRv0.sol:41:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:47:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:66:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:77:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/adapter/ChainlinkAdapter.sol:34:        for(uint256 i = 0; i<_assets.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:63:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:122:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:175:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:36:  for (uint i=0; i<parentNodes.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:78:  for(uint i=pathPtr; i<pathPtr+partialPath.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:108:  for(uint i=offset; i<nibbleArray.length; i++) { ./mochi-library/contracts/SushiswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./mochi-library/contracts/SushiswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) { ./mochi-library/contracts/UniswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./mochi-library/contracts/UniswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) { ``` ## A similar case  nibblePath.length is constant but it is read at every iteration for require statement.  ```./mochi-library/contracts/MerklePatriciaVerifier.sol:36: require(pathPtr <= nibblePath.length, "Path overflow");```    
# Handle  jonah1005   # Vulnerability details  ## Impact MochiEngine allows the operator to change the NFT contract. [MochiEngine.sol#L91-L93](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93) All the vaults would point to a different NFT address. As a result, users would not be access their positions. The entire protocol would be broken.  IMHO, A function that would break the entire protocol shouldn't exist.  I consider this is a high-risk issue. ## Proof of Concept [MochiEngine.sol#L91-L93](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93)  ## Tools Used None ## Recommended Mitigation Steps Remove the function.   
# Handle  jonah1005   # Vulnerability details  # regerralFeePool is vulnerable to MEV searcher  ## Impact `claimRewardAsMochi` in the `ReferralFeePoolV0` ignores slippage. This is not a desirable design. There are a lot of MEV searchers in the current network. Swapping assets with no slippage control would get rekted. Please refer to https://github.com/flashbots/pm.  Given the current state of the Ethereum network. Users would likely be sandwiched. I consider this is a high-risk issue.  ## Proof of Concept [ReferralFeePoolV0.sol#L28-L48](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L48)  Please refer to https://medium.com/immunefi/mushrooms-finance-theft-of-yield-bug-fix-postmortem-16bd6961388f  to see a possible attack pattern.   ## Tools Used  None  ## Recommended Mitigation Steps I recommend adding minReceivedAmount as a parameter.  ```solidity function claimRewardAsMochi(uint256 _minReceivedAmount) external {     // original logic here     require(engine.mochi().balanceOf(address(this)) > _minReceivedAmount, "!min");     engine.mochi().transfer(         msg.sender,         engine.mochi().balanceOf(address(this))     ); } ``` Also, the front-end should calculate the min amount with the current price.  
# Handle  jonah1005   # Vulnerability details  # treasury is vulnerable to sandwich attack.   ## Impact There's a permissionless function `veCRVlock` in MochiTreasury. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds. [MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)  Attackers can possibly steal all the funds in the treasury. I consider this is a high-risk issue.  ## Proof of Concept [MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)  Here's an exploit pattern 1. Flashloan and buy CRV the uniswap pool 2. Trigger `veCRVlock()` 3. The treasury buys CRV at a very high price. 4. Sell CRV and pay back the loan.  ## Tools Used  None  ## Recommended Mitigation Steps Recommend to add `onlyOwner` modifier.   
# Handle  gzeon   # Vulnerability details  ## Impact function claimRewardAsMochi in ReferralFeePoolV0.sol did not reduce user reward balance, allowing referrer to claim the same reward repeatedly and thus draining the fee pool.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol L28-47 did not reduce user reward balance  ## Tools Used None  ## Recommended Mitigation Steps Add the following lines > rewards -= reward[msg.sender]; > reward[msg.sender] = 0;   
# Handle  gzeon   # Vulnerability details  ## Impact Auction struct in DutchAuctionLiquidator.sol can be optimized to reduce 2 storage slot  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol L18-L25: the struct can changed into struct Auction {         uint256 nftId;         address vault;         uint48 startedAt;         uint48 boughtAt;         uint256 collateral;         uint256 debt;     } startedAt and boughtAt store block numbers, and 2^48 is be enough for a very long time.  ## Tools Used None  ## Recommended Mitigation Steps Change the struct as suggested above, also need to cast whenever startedAt and boughtAt is used.  
# Handle  gzeon   # Vulnerability details  ## Impact There is a status enum Liquidated but was not used anywhere in the code.   ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol L277-296 status was not set to Status.Liquidated after liquidation  ## Tools Used None  ## Recommended Mitigation Steps details[id].status = Status.Liquidated;  
# Handle  ye0lde   # Vulnerability details  ## Impact  Caching the "vesting" state variable instead of repeatedly reading and writing it will decrease deployment and runtime gas.  This is especially true for the modifier "checkClaimable" which is used on every function in the contract.   ## Proof of Concept  The checkClaimable function is here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L22-L29  An example of its use is here along with many other accesses to the "vesting" state variable. https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest modifying "checkClaimable as follows:     <code> function checkClaimable(Vesting memory v) internal pure returns(Vesting memory) {   if (v.ends < block.timestamp) {   v.claimable += v.vested;   v.vested = 0;   v.ends = 0;  }  return v; } </code>  and I suggest these changes to function "vest"   <code> function vest(address _recipient) external {  Vesting memory v = checkClaimable(vesting[_recipient]);  uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;  uint256 weightedEnd = (v.vested *   v.ends +   amount *   (block.timestamp + 90 days)) /   (v.vested + amount);  v.vested += amount;  v.ends = weightedEnd;  vesting[_recipient] = v;  mochiUnderManagement += amount; } </code>  These functions are also candidates for similar changes: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L48-L71   
# Handle  defsec   # Vulnerability details  ## Impact  This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract. Calling each function, we can see that the public function uses 496 gas, while the external function uses only 261.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.  Slither Detector:  external-function:  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L75  ## Tools Used  Slither  ## Recommended Mitigation Steps  1. Clone repository for Mochi Smart Contracts. 2. Create a python virtual environment with a stable python version. 3. Install Slither Analyzer on the python VEM. 4. Run Slither against all contracts. 5. Define public functions as an external for the gas optimization.  
# Handle  gzeon   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/interfaces/IMochiVault.sol L6-L12: the struct can be reordered into struct Detail {     Status status;     address referrer;     uint256 collateral;     uint256 debt;     uint256 debtIndex; }  such that status and referrer are put into the same slot, should save ~2000 gas per borrow  ## Tools Used None  ## Recommended Mitigation Steps Reorder the struct as suggested, and modify impacted code at  IMochiVault.sol L28-L34 DutchAuctionLiquidator.sol L77  ## Extra Realistically, the range of debtIndex (start at 1e18 and increase by fee per year) probably fit in a uint88(11bytes) so you can pack (status(1byte), referrer(20bytes), debtIndex(11bytes)) all in 32 bytes, saving another storage slot.   
# Handle  gzeon   # Vulnerability details  ## Impact Some of the require statements in MochiVault.sol can be placed earlier to reduce gas usage on revert  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol L226-227: can be placed at the very top of the function to avoid the expensive cssr call L237: can be placed before initialization of increasingDebt  ## Tools Used None  ## Recommended Mitigation Steps Relocate the said require statements  
# Handle  gpersoon   # Vulnerability details  ## Impact The value of the global variable debts in the contract MochiVault.sol is calculated in an inconsistent way.  In the function borrow() the variable debts is increased with a value excluding the fee. However in repay() and liquidate() it is decreased with the same value as details[_id].debt is decreased,, which is including the fee.  This would mean that debts will end up in a negative value when all debts are repay-ed. Luckily the function repay() prevents this from happening.  In the mean time the value of debts isn't accurate. This value is used directly or indirectly in:  - utilizationRatio(), stabilityFee() calculateFeeIndex() of MochiProfileV0.sol  - liveDebtIndex(), accrueDebt(), currentDebt() of MochiVault.sol  This means the entire debt and claimable calculations are slightly off.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol  function borrow(..)     details[_id].debt = totalDebt; // includes the fee     debts += _amount;     // excludes the fee   function repay(..)     debts -= _amount;       details[_id].debt -= _amount;  function liquidate(..)    debts -= _usdm;    details[_id].debt -= _usdm;  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L263-L268  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L272-L283  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L242-L256  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L258-L269  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L66-L73  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L79-L88  ## Tools Used  ## Recommended Mitigation Steps In function borrow(): replace     debts += _amount; with     debts += totalDebt  
# Handle  gpersoon   # Vulnerability details  ## Impact Every time you deposit some assets in the vault (via deposit() of MochiVault.sol) then "lastDeposit[_id]" is set to block.timestamp. The modifier wait() checks this value and makes sure you cannot withdraw for "delay()" blocks. The default value for delay() is 3 minutes.  Knowing this delay you can do a griefing attack: On chains with low gas fees: every 3 minutes deposit a tiny amount for a specific NFT-id (which has a large amount of assets). On chains with high gas fees: monitor the mempool for a withdraw() transaction and frontrun it with a deposit()  This way the owner of the NFT-id can never withdraw the funds.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L47-L54  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L171  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L33  ## Tools Used  ## Recommended Mitigation Steps Create a mechanism where you only block the withdraw of recently deposited funds   
