## G01 - Comparison ```> 0``` is less gas efficient than ```!= 0``` with ```uint256``` in ```require``` statement with optimizer  ```solidity protocol/contracts/BkdLocker.sol:91 require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/BkdLocker.sol:92 require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  protocol/contracts/BkdLocker.sol:137    require(length > 0, "No entries"); protocol/contracts/tokenomics/AmmGauge.sol:104  require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/AmmGauge.sol:125  require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/KeeperGauge.sol:140   require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); protocol/contracts/tokenomics/VestedEscrow.sol:84   require(unallocatedSupply > 0, "No reward tokens in contract");  ```  ## G02 - Too long revert string  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.  ```solidity protocol/contracts/tokenomics/Minter.sol:152    "Maximum non-inflation amount exceeded."  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L152  ## G03 - ```unchecked``` block can be used for gas efficiency of the expression that can't overflow/underflow  Check comments ```soldity  protocol/contracts/utils/CvxMintAmount.sol:21   uint256 currentCliff = cvxTotalSupply / _CLIFF_SIZE; // Could be unchecked since _CLIFF_SIZE is non-zero constant  protocol/contracts/zaps/PoolMigrationZap.sol:22 for (uint256 i; i < newPools_.length; ++i) { // Increment in for loop can be unchecked, it would never overflow with type uint256 protocol/contracts/tokenomics/VestedEscrow.sol:155  uint256 elapsed = _time - startTime; // Could be unchecked due to check on L152 protocol/contracts/BkdLocker.sol:140    i = i - 1; // Could be unchecked due to check on L139 protocol/contracts/BkdLocker.sol:144    stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1]; //  Could be unchecked since length of stashedWithdraws decrease in sync with counter "i" and loop will end after length 1 ```  ## G04 - Caching storage values in memory  Variables that are read multiple times in a code block can be cached and re-used instead of reading from storage to save gas.  ```solidity protocol/contracts/StakerVault.sol:338  uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal; // token 5 SLOADs ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L322-L349 ```solidity protocol/contracts/StakerVault.sol:383  uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this))); // token 4 SLOADs ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L359-L398  ## G05 - Redundant code  The following lines don't change the value of the variable since it's uint256: ```solidity protocol/contracts/tokenomics/InflationManager.sol:575  totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;  protocol/contracts/tokenomics/InflationManager.sol:589  totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;  protocol/contracts/tokenomics/InflationManager.sol:602  totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0; ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L575 
