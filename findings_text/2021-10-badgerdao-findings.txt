# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L73  https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L123  oracle can `0` as a price of the share, in that case, 0 will be the denominator in some calculations which can cause reverts from SafeMath (for e.g here: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L148 ) resulting in Denial Of Service.  Add a null check to ensure that on every update, the price is greater than 0.  
# Handle  hyh   # Vulnerability details  ## Impact If price feed is manipulated in any way or there is any malfunction based volatility on the market, both contracts will pass it on a user. In the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.  ## Proof of Concept In WrappedIbbtcEth pricePerShare variable is updated by externally run updatePricePerShare function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72, and then used in mint/burn/transfer functions without additional checks via balanceToShares function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155.  In WrappedIbbtc price is requested via pricePerShare function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L123, and used in the same way without additional checks via balanceToShares function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L147.   ## Recommended Mitigation Steps Introduce minting/burning query that runs on schedule, separating user funds contribution and actual mint/burn. With user deposit or burn the corresponding action to be added to commitment query, which execution for mint or redeem will later be sparked by off-chain script according to fixed schedule. This also can be open to public execution with gas compensation incentive, for example as it's done in Tracer protocol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/develop/contracts/implementation/PoolKeeper.sol#L131 Full code of an implementation is too big to include it in the report, but viable versions are available publicly (Tracer protocol version can be found at the same repo, https://github.com/tracer-protocol/perpetual-pools-contracts/blob/develop/contracts/implementation/PoolCommitter.sol).  Once the scheduled mint/redeem query is added, the additional logic to control for price outliers will become possible there, as in this case mint/redeem execution can be conditioned to happen on calm market only, where various definitions of calm can be implemented. One of the approaches is to keep track of recent prices and require that new price each time be within a threshold from median of their array.  Example:  // Introduce small price tracking arrays: uint256[] private times; uint256[] private prices;  // Current position in array uint8 curPos;  // Current length, grows from 0 to totalMaxPos as prices are being added uint8 curMaxPos;  // Maximum length, we track up to totalMaxPos prices uint8 totalMaxPos = 10;  // Price movement threshold uint256 moveThreshold = 0.1*1e18;  We omit the full implementation here as it is lengthy enough and can vary. The key steps are: * Run query for scheduled mint/redeem with logic: if next price is greater than median of currently recorded prices by threshold, add it to the records, but do not mint/redeem. * That is, when scheduled mint/redeem is run, on new price request, WrappedIbbtcEth.core.pricePerShare() or WrappedIbbtc.oracle.pricePerShare(), get newPrice and calculate current price array median, curMed * prices[curPos] = newPrice * if (curMaxPos < totalMaxPos) {curMaxPos += 1} * if (curPos == curMaxPos) {curPos = 0} else {curPos += 1} * if (absolute_value_of(newPrice - curMed) < moveThreshold * curMed / 1e18) {do_mint/redeem; return_0_status} * else {return_1_status}  Schedule should be frequent enough, say once per 30 minutes, which is kept while returned status is 0. While threshold condition isn't met and returned status is 1, it runs once per 10 minutes. The parameters here are subject to calibration. This way if the price movement is sustained the mint/redeem happens after price array median comes to a new equilibrium. If price reverts, the outbreak will not have material effect mint/burn operations. This way the contract vulnerability is considerably reduced as attacker would need to keep distorted price for period long enough, which will happen after the first part of deposit/withdraw cycle. I.e. deposit and mint, burn and redeem operations will happen not simultaneously, preventing flash loans to be used to elevate the quantities, and for price to be effectively distorted it would be needed to keep it so for substantial amount of time.  
# Handle  hyh   # Vulnerability details  ## Impact Malicious user can monitor SetPricePerShare event and, if it was run long enough time ago and market moved, but, since there were no SetPricePerShare fired, the contract's pricePerShare is outdated, so a user can mint() with pricePerShare that is current for contract, but outdated for market, then wait for price update and burn() with updated pricePerShare, yielding risk-free profit at expense of contract holdings.  ## Proof of Concept WrappedIbbtcEth updates pricePerShare variable by externally run updatePricePerShare function. The variable is then used in mint/burn/transfer functions without any additional checks, even if outdated/stalled. This can happen if the external function wasn't run for any reason. The variable is used via balanceToShares function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155  This is feasible as updatePricePerShare to be run by off-chain script being a part of the system, and malfunction of this script leads to contract exposure by stalling the price. The malfunction can happen both by internal reasons (bugs) and by external ones (any system-level dependencies, network outrages). updatePricePerShare function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72  ## Recommended Mitigation Steps The risk comes with system design. Wrapping price updates with contract level variable for gas costs minimization is a viable approach, but it needs to be paired with corner cases handling. One of the ways to reduce the risk is as follows:  Introduce a threshold variable for maximum time elapsed since last pricePerShare update to WrappedIbbtcEth contract.  Then 2 variants of transferFrom and transfer functions can be introduced, both check condition {now - time since last price update < threshold}. If condition holds both variants do the transfer. If it doesn't the first variant reverts, while the second do costly price update. I.e. it will be cheap transfer, that works only if price is recent, and full transfer, that is similar to the first when price is recent, but do price update on its own when price is stalled. This way this full transfer is guaranteed to run and is usually cheap, costing more if price is stalled and it does the update.  After this whenever scheduled price update malfunctions (for example because of network conditions), the risk will be limited by market volatility during threshold time at maximum, i.e. capped.  Example code:    // Added threshold      uint256 public pricePerShare;     uint256 public lastPricePerShareUpdate;   uint256 public priceUpdateThreshold;      event SetPriceUpdateThreshold(uint256 priceUpdateThreshold);        /// ===== Permissioned: Price update threshold =====     function setPriceUpdateThreshold(uint256 _priceUpdateThreshold) external onlyGovernance {         priceUpdateThreshold = _priceUpdateThreshold;         emit SetPriceUpdateThreshold(priceUpdateThreshold);     }      // The only difference with current transfer code is that Full versions call balanceToSharesFull      function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToShares(amount);          _transfer(sender, recipient, amountInShares);         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, "ERC20: transfer amount exceeds allowance"));         return true;     }      function transfer(address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToShares(amount);          _transfer(_msgSender(), recipient, amountInShares);         return true;     }        function transferFromFull(address sender, address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToSharesFull(amount);          _transfer(sender, recipient, amountInShares);         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, "ERC20: transfer amount exceeds allowance"));         return true;     }      function transferFull(address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToSharesFull(amount);          _transfer(_msgSender(), recipient, amountInShares);         return true;     }      // Now balanceToShares first checks if the price is stale   // And reverts if it is   // While balanceToSharesFull do the same check   // But asks for price instead of reverting   // Having guaranteed execution with increased costs sometimes   // Which is fully deterministic, as user can track SetPricePerShare event   // To understand whether it be usual or increased gas cost if the function be called now      function balanceToShares(uint256 balance) public view returns (uint256) {     require(block.timestamp < lastPricePerShareUpdate + priceUpdateThreshold, "Price is stalled");         return balance.mul(1e18).div(pricePerShare);     }        function balanceToSharesFull(uint256 balance) public view returns (uint256) {     if (block.timestamp >= lastPricePerShareUpdate + priceUpdateThreshold) {       updatePricePerShare();     }         return balance.mul(1e18).div(pricePerShare);     }  
# Handle  JMukesh   # Vulnerability details  ## Impact In updatePricePerShare() instead of "block.timestamp" , "now"  is used which is deprciated.  "block.timestamp" is way more explicit in showing the intent while "now"  relates to the timestamp of the block controlled by the miner  more on this -> https://github.com/ethereum/solidity/issues/4020    ## Tools Used manual review  ## Recommended Mitigation Steps use block.timestamp  
# Handle  pauliax   # Vulnerability details  ## Impact functions mint, burn, transfer and transferFrom could skip other steps if the amount is 0.   
# Handle  pauliax   # Vulnerability details  ## Impact modifier onlyOracle in WrappedIbbtc is never used, so can be removed to reduce deployment gas costs.   
# Handle  pauliax   # Vulnerability details  ## Impact You import ICore interface but actually need only one function from it: pricePerShare(). Consider importing a minimal ICore interface with only the functions that you actually use to reduce deployment gas costs. Or you can just simply re-use ICoreOracle.   
# Handle  pauliax   # Vulnerability details  ## Impact There are many external risks (mentioned https://github.com/code-423n4/2021-10-badgerdao#risks) so my suggestion is that you should consider making the contracts pausable, so in case of an unexpected event, the governance can pause transfers.  ## Recommended Mitigation Steps Consider making contracts Pausable https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol  
# Handle  JMukesh   # Vulnerability details  ## Impact when pendingGovernance  call acceptPendingGovernance() , governance value get updated  but pendingGovernance  remain same its not updated to address(0)   governance = pendingGovernance;  due to which pendingGovernace and Governace share same address which should not happen  ## Tools Used manual review  ## Recommended Mitigation Steps update pendingGovernance to address(0)  
# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept most of the contract use floating pragma  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed pragma  
# Handle  defsec   # Vulnerability details  ## Impact  On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn’t done.  Especially in the balanceToShares function div(pricePerShare) which isn’t checked.   That will cause to revert on the transfer and transferFrom function. Oracle pricePerShare variable should be cheked on the balance calculation.  ## Proof of Concept  1. Navigate to the following contracts,  "https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtcEth.sol#L156"  "https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtc.sol#L148"  2. If oracle fails, the pricePerShare variable will be equal to zero therefore div by zero will occur.  ## Tools Used  Review  ## Recommended Mitigation Steps  Recommend making sure division by 0 won’t occur by checking the variables beforehand and handling this edge case.  
# Handle  defsec   # Vulnerability details  ## Impact After pragma version, 0.7.0, the contract should use block.timestamp.  ## Proof of Concept  1. Navigate to the following contract.  "https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L74"  2. Now is used instead of block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  It is recommended to use block.timestamp instead of now.   
# Handle  kenzo   # Vulnerability details  pricePerShare is read either from an oracle or from ibBTC's core.  If one of these is bugged or exploited, there are no safety checks to prevent loss of funds.  ## Impact As pricePerShare is used to calculate transfer amount, a bug or wrong data which returns smaller pricePerShare than it really is could result in drainage of wibbtc from Curve pool.  ## Proof of Concept Curve's swap and remove liquidity functions will both call wibbtc's `transfer` function: https://etherscan.io/address/0xFbdCA68601f835b27790D98bbb8eC7f05FDEaA9B#code%23L790 https://etherscan.io/address/0xFbdCA68601f835b27790D98bbb8eC7f05FDEaA9B#code%23L831 The `transfer` function calculates the amount to send by calling `balanceToShares`: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L127 `balanceToShares` calculates the shares (=amount to send) by dividing in `pricePerShare`: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L156 Therefore, if due to a bug or exploit in ibBTC core / the trusted oracle pricePerShare is smaller than it really is, the amount that will be sent will grow larger. So Curve will send to the user/exploiter doing swap/remove liquidity more tokens that he deserves.  ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Add sanity check:  pricePerShare should never decrease but only increase with time (as ibbtc accrues interest) (validated with DefiDollar team). This means that on every pricePerShare read/update, if the new pricePerShare is smaller than the current one, we can discard the update as bad data.   This will prevent an exploiter from draining Curve pool's wibbtc reserves by decreasing pricePerShare.  
# Handle  WatchPug   # Vulnerability details  Per the documentation, `wibBTC` is designed for a Curve StableSwap pool. However, the design of `wibBTC` makes the balances change dynamically and automatically. This is unusual for an ERC20 token, and it's not fully compatible with the current Curve StableSwap pool.  Specifically, a Curve StableSwap pool will maintain the balances of its `coins` based on the amount of tokens added, removed, and exchanged each time. In another word, it can not adopt the dynamic changes of the balances that happened automatically.  The pool's actual dynamic balance of `wibBTC` will deviate from the recorded balance in the pool contract as the `pricePerShare` increases.  Furthermore, there is no such way in Curve StableSwap similar to the `sync()` function of UNI v2, which will force sync the stored `reserves` to match the balances.  ### PoC  Given:  - The current `pricePerShare` is: `1`; - The Curve pool is newly created with 0 liquidity;  1. Alice added `100 wibBTC` and `100 wBTC` to the Curve pool; Alice holds 100% of the pool; 2. After 1 month with no activity (no other users, no trading), and the `pricePerShare` of `ibBTC` increases to `1.2`; 3. Alice removes all the liquidity from the Curve pool.  While it's expected to receive `150 wibBTC` and `100 wBTC`, Alice actually can only receive `100 wibBTC` and `100 wBTC`.  ### Recommendation  Consider creating a revised version of the Curve StableSwap contract that can handle dynamic balances properly.  
# Handle  WatchPug   # Vulnerability details  Based on the context, the functions listed below are not expected to be overridden, thus the use of the keyword `virtual` is redundant.  - transfer() - updatePricePerShare() - transferFrom() - pricePerShare()  ### Recommendation  Consider removing `virtual` for these functions.  
# Handle  WatchPug   # Vulnerability details  Given that `setCore()` could potentially lead to a change of `pricePerShare`, and `pricePerShare` will not be updated until `updatePricePerShare()` is called separately.  To ensure `pricePerShare` is up-to-date, `updatePricePerShare` should be run atomically with `setCore()`.  ### Recommendation  Consider changing `setCore()` to:  ```solidity function setCore(address _core) external onlyGovernance {     core = ICore(_core);      updatePricePerShare();      emit SetCore(_core); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L69-L77  ```solidity /// @dev Update live ibBTC price per share from core /// @dev We cache this to reduce gas costs of mint / burn / transfer operations. /// @dev Update function is permissionless, and must be updated at least once every X time as a sanity check to ensure value is up-to-date function updatePricePerShare() public virtual returns (uint256) {     pricePerShare = core.pricePerShare();     lastPricePerShareUpdate = now;      emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate); } ```  Per the comment above `function updatePricePerShare()`, `updatePricePerShare()` may get called quite often when `wibBTC` token is being used more often.  There could potentially be multiple calls to `updatePricePerShare()` in one block. In that case, checking if `pricePerShare` was updated earlier in the same block can save some gas from unnecessary external calls and storage writes.  ### Recommendation  Change to:  ```solidity function updatePricePerShare() public virtual returns (uint256) {     if (lastPricePerShareUpdate < now) {         pricePerShare = core.pricePerShare();         lastPricePerShareUpdate = now;          emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);     } } ```  
# Handle  WatchPug   # Vulnerability details  It's a best practice to use constant variables rather than literal values to make the code easier to understand and maintain.  The literal `1e18` is used throughout the contracts multiple times.  Consider defining a constant variable for the literal value used and giving it a clear and self-explanatory name.  
# Handle  WatchPug   # Vulnerability details  Most of the interfaces defined in `ICore.sol` are unused. The only method used is `pricePerShare()` which is identical to `ICoreOracle.sol#pricePerShare()`.  Therefore, `ICore.sol` can be removed and replaced by `ICoreOracle.sol`.  
# Handle  WatchPug   # Vulnerability details  The current implementation of `WrappedIbbtc.sol` will do an external call `oracle.pricePerShare()` every time `pricePerShare` is used, it can be gas consuming considering that the basic features include: `balanceOf()`, `transfer()`, `transferFrom()` will be used very often.  ### Recommendation  Consider caching `pricePerShare` in storage.  
# Handle  WatchPug   # Vulnerability details  `msg.sender` vs internal call of `_msgSender()`.  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtc.sol#L23-L36  ```solidity modifier onlyPendingGovernance() {     require(msg.sender == pendingGovernance, "onlyPendingGovernance");     _; }  modifier onlyGovernance() {     require(msg.sender == governance, "onlyGovernance");     _; }  modifier onlyOracle() {     require(msg.sender == address(oracle), "onlyOracle");     _; } ```  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L123-L131  ```solidity function transfer(address recipient, uint256 amount) public virtual override returns (bool) {     /// The _balances mapping represents the underlying ibBTC shares ("non-rebased balances")     /// Some naming confusion emerges due to maintaining original ERC20 var names      uint256 amountInShares = balanceToShares(amount);      _transfer(_msgSender(), recipient, amountInShares);     return true; } ```  
# Handle  WatchPug   # Vulnerability details  For the result of an external call being written into a storage variable, cache and read from the stack rather than read from the storage variable can save gas.  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L72-L77  ```solidity function updatePricePerShare() public virtual returns (uint256) {     pricePerShare = core.pricePerShare();     lastPricePerShareUpdate = now;      emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate); } ```  ### Recommendation  Change to:  ```solidity function updatePricePerShare() public virtual returns (uint256) {     uint256 lastPricePerShare = core.pricePerShare();     pricePerShare = lastPricePerShare;     lastPricePerShareUpdate = now;      emit SetPricePerShare(lastPricePerShare, lastPricePerShareUpdate); } ```  
# Handle  cmichel   # Vulnerability details  The `approve` function has not been overridden and therefore uses the internal _shares_, whereas `transfer(From)` uses the rebalanced amount.  ## Impact The approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing with `pricePerShare`.  Many contracts also use the same amount for the `approve` call as for the amount they want to have transferred in a subsequent `transferFrom` call, and in this case, they approve an amount that is too large (as the approved `shares` amount yields a higher rebalanced amount).  ## Recommended Mitigation Steps The `_allowances` field should track the rebalanced amounts such that the approval value does not grow. (This does not actually require overriding the `approve` function.) In `transferFrom`, the approvals should then be subtracted by the _transferred_ `amount`, not the `amountInShares`:  ```solidity // _allowances are in rebalanced amounts such that they don't grow // need to subtract the transferred amount _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance")); ```  
# Handle  cmichel   # Vulnerability details  The `acceptPendingGovernance` function does not reset `pendingGovernance` to zero.  ## Impact The pending governor can repeatedly accept the governance, emitting an `AcceptPendingGovernance` event each time, bloating listeners for this event with unnecessary data.  ## Recommended Mitigation Steps Validate the parameters.   
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `WrappedIbbtcEth.initialize`: The parameters could be checked to be non-zero or even if they're contracts implementing the desired interfaces.  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  defsec   # Vulnerability details  ## Impact  Since the _pendingGovernance parameter in the setPendingGovernance are used to add governance. In the state variable , proper check up should be done , other wise error in these state variable can lead to redeployment of contract.  ## Proof of Concept  1. Navigate to the following contract functions.  "https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtcEth.sol#L50"  "https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtc.sol#L49"  2. Adding zero address into the pending governance leads to failure of governor only functions.   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add proper zero address validation.   
# Handle  pmerkleplant   # Vulnerability details  The arguments of type `address` in the following functions miss a zero-check.  - `initialize()` - `setPendingGovernance()` - `setOracle()`  In the case of `setPendingGovernance()`, where a zero-address could be legitim, it should be stated as such in the docs, or forbidden otherwise.  ## Tools Used slither  
# Handle  jonah1005   # Vulnerability details  ## Impact The contract does not allow users to transfer by share. It's hard for users to clear out all the shares. There will be users using this token with Metamask. There's likely the `pricePerShare` would increase after the user sends transactions. I consider this is a medium-risk issue.  ## Proof of Concept [WrappedIbbtc.sol#L110-L118](https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L110-L118)  ## Tools Used  ## Recommended Mitigation Steps I consider a new `transferShares` beside the original `transfer()` would build a better UX. I consider sushi's bento box would be a good ref [BentoBox.sol](https://github.com/sushiswap/bentobox/blob/master/contracts/BentoBox.sol)  
# Handle  ye0lde   # Vulnerability details  For "core", which can be changed by the governance process, an event is emitted when it is changed from 0 to a hopefully valid value in the initialize function.  In the same initialize function the _governance address itself is not verified nor is there an event emitted showing that the governance address has changed from 0 to a different address.  ## Proof of Concept  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L37-L46  Similar but with Oracle instead of Core. https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtc.sol#L38-L45  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Emit an event reporting governance change or if it is not important to report these initialization events remove the emit for the core initialization.  
# Handle  gzeon   # Vulnerability details  ## Impact In WrappedIbbtc, user will not be able to transfer if oracle.pricePerShare() (L124) revert. This is because balanceToShares() is called in both transfer and transferFrom, which included a call to pricePerShare().   If this is the expected behavior, note that WrappedIbbtcEth is behaving the opposite as it use the cached value in a local variable pricePerShare which is only updated upon call to updatePricePerShare().  ## Recommended Mitigation Steps Depending on the specification, one of them need to be changed.  
# Handle  pants   # Vulnerability details  ibbtc is ERC20Upgradeable. Not all ERC20 contracts supports "blind" transfer method - i.e transfer that you can ignore the return value. You should either check the return value or use openzeppilin safeTransfer   
# Handle  jah   # Vulnerability details  ## Impact The parameter that are used in initialize() function to initialize the state variable,these state variable are used in other function to perform operation. since it lacks zero address validation, it will be problematic if there is error in these state variable. some of the function will loss their functionality which can cause the redeployment of contract  ## Proof of Concept https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L37  ## Tools Used Manual Analysis ## Recommended Mitigation Steps add require condition which check zero address validation   
# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L73  https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L123  oracle can `0` as a price of the share, in that case, 0 will be the denominator in some calculations which can cause reverts from SafeMath (for e.g here: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L148 ) resulting in Denial Of Service.  Add a null check to ensure that on every update, the price is greater than 0.  
# Handle  hyh   # Vulnerability details  ## Impact If price feed is manipulated in any way or there is any malfunction based volatility on the market, both contracts will pass it on a user. In the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.  ## Proof of Concept In WrappedIbbtcEth pricePerShare variable is updated by externally run updatePricePerShare function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72, and then used in mint/burn/transfer functions without additional checks via balanceToShares function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155.  In WrappedIbbtc price is requested via pricePerShare function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L123, and used in the same way without additional checks via balanceToShares function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L147.   ## Recommended Mitigation Steps Introduce minting/burning query that runs on schedule, separating user funds contribution and actual mint/burn. With user deposit or burn the corresponding action to be added to commitment query, which execution for mint or redeem will later be sparked by off-chain script according to fixed schedule. This also can be open to public execution with gas compensation incentive, for example as it's done in Tracer protocol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/develop/contracts/implementation/PoolKeeper.sol#L131 Full code of an implementation is too big to include it in the report, but viable versions are available publicly (Tracer protocol version can be found at the same repo, https://github.com/tracer-protocol/perpetual-pools-contracts/blob/develop/contracts/implementation/PoolCommitter.sol).  Once the scheduled mint/redeem query is added, the additional logic to control for price outliers will become possible there, as in this case mint/redeem execution can be conditioned to happen on calm market only, where various definitions of calm can be implemented. One of the approaches is to keep track of recent prices and require that new price each time be within a threshold from median of their array.  Example:  // Introduce small price tracking arrays: uint256[] private times; uint256[] private prices;  // Current position in array uint8 curPos;  // Current length, grows from 0 to totalMaxPos as prices are being added uint8 curMaxPos;  // Maximum length, we track up to totalMaxPos prices uint8 totalMaxPos = 10;  // Price movement threshold uint256 moveThreshold = 0.1*1e18;  We omit the full implementation here as it is lengthy enough and can vary. The key steps are: * Run query for scheduled mint/redeem with logic: if next price is greater than median of currently recorded prices by threshold, add it to the records, but do not mint/redeem. * That is, when scheduled mint/redeem is run, on new price request, WrappedIbbtcEth.core.pricePerShare() or WrappedIbbtc.oracle.pricePerShare(), get newPrice and calculate current price array median, curMed * prices[curPos] = newPrice * if (curMaxPos < totalMaxPos) {curMaxPos += 1} * if (curPos == curMaxPos) {curPos = 0} else {curPos += 1} * if (absolute_value_of(newPrice - curMed) < moveThreshold * curMed / 1e18) {do_mint/redeem; return_0_status} * else {return_1_status}  Schedule should be frequent enough, say once per 30 minutes, which is kept while returned status is 0. While threshold condition isn't met and returned status is 1, it runs once per 10 minutes. The parameters here are subject to calibration. This way if the price movement is sustained the mint/redeem happens after price array median comes to a new equilibrium. If price reverts, the outbreak will not have material effect mint/burn operations. This way the contract vulnerability is considerably reduced as attacker would need to keep distorted price for period long enough, which will happen after the first part of deposit/withdraw cycle. I.e. deposit and mint, burn and redeem operations will happen not simultaneously, preventing flash loans to be used to elevate the quantities, and for price to be effectively distorted it would be needed to keep it so for substantial amount of time.  
# Handle  hyh   # Vulnerability details  ## Impact Malicious user can monitor SetPricePerShare event and, if it was run long enough time ago and market moved, but, since there were no SetPricePerShare fired, the contract's pricePerShare is outdated, so a user can mint() with pricePerShare that is current for contract, but outdated for market, then wait for price update and burn() with updated pricePerShare, yielding risk-free profit at expense of contract holdings.  ## Proof of Concept WrappedIbbtcEth updates pricePerShare variable by externally run updatePricePerShare function. The variable is then used in mint/burn/transfer functions without any additional checks, even if outdated/stalled. This can happen if the external function wasn't run for any reason. The variable is used via balanceToShares function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155  This is feasible as updatePricePerShare to be run by off-chain script being a part of the system, and malfunction of this script leads to contract exposure by stalling the price. The malfunction can happen both by internal reasons (bugs) and by external ones (any system-level dependencies, network outrages). updatePricePerShare function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72  ## Recommended Mitigation Steps The risk comes with system design. Wrapping price updates with contract level variable for gas costs minimization is a viable approach, but it needs to be paired with corner cases handling. One of the ways to reduce the risk is as follows:  Introduce a threshold variable for maximum time elapsed since last pricePerShare update to WrappedIbbtcEth contract.  Then 2 variants of transferFrom and transfer functions can be introduced, both check condition {now - time since last price update < threshold}. If condition holds both variants do the transfer. If it doesn't the first variant reverts, while the second do costly price update. I.e. it will be cheap transfer, that works only if price is recent, and full transfer, that is similar to the first when price is recent, but do price update on its own when price is stalled. This way this full transfer is guaranteed to run and is usually cheap, costing more if price is stalled and it does the update.  After this whenever scheduled price update malfunctions (for example because of network conditions), the risk will be limited by market volatility during threshold time at maximum, i.e. capped.  Example code:    // Added threshold      uint256 public pricePerShare;     uint256 public lastPricePerShareUpdate;   uint256 public priceUpdateThreshold;      event SetPriceUpdateThreshold(uint256 priceUpdateThreshold);        /// ===== Permissioned: Price update threshold =====     function setPriceUpdateThreshold(uint256 _priceUpdateThreshold) external onlyGovernance {         priceUpdateThreshold = _priceUpdateThreshold;         emit SetPriceUpdateThreshold(priceUpdateThreshold);     }      // The only difference with current transfer code is that Full versions call balanceToSharesFull      function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToShares(amount);          _transfer(sender, recipient, amountInShares);         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, "ERC20: transfer amount exceeds allowance"));         return true;     }      function transfer(address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToShares(amount);          _transfer(_msgSender(), recipient, amountInShares);         return true;     }        function transferFromFull(address sender, address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToSharesFull(amount);          _transfer(sender, recipient, amountInShares);         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, "ERC20: transfer amount exceeds allowance"));         return true;     }      function transferFull(address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToSharesFull(amount);          _transfer(_msgSender(), recipient, amountInShares);         return true;     }      // Now balanceToShares first checks if the price is stale   // And reverts if it is   // While balanceToSharesFull do the same check   // But asks for price instead of reverting   // Having guaranteed execution with increased costs sometimes   // Which is fully deterministic, as user can track SetPricePerShare event   // To understand whether it be usual or increased gas cost if the function be called now      function balanceToShares(uint256 balance) public view returns (uint256) {     require(block.timestamp < lastPricePerShareUpdate + priceUpdateThreshold, "Price is stalled");         return balance.mul(1e18).div(pricePerShare);     }        function balanceToSharesFull(uint256 balance) public view returns (uint256) {     if (block.timestamp >= lastPricePerShareUpdate + priceUpdateThreshold) {       updatePricePerShare();     }         return balance.mul(1e18).div(pricePerShare);     }  
# Handle  JMukesh   # Vulnerability details  ## Impact In updatePricePerShare() instead of "block.timestamp" , "now"  is used which is deprciated.  "block.timestamp" is way more explicit in showing the intent while "now"  relates to the timestamp of the block controlled by the miner  more on this -> https://github.com/ethereum/solidity/issues/4020    ## Tools Used manual review  ## Recommended Mitigation Steps use block.timestamp  
# Handle  pauliax   # Vulnerability details  ## Impact functions mint, burn, transfer and transferFrom could skip other steps if the amount is 0.   
# Handle  pauliax   # Vulnerability details  ## Impact modifier onlyOracle in WrappedIbbtc is never used, so can be removed to reduce deployment gas costs.   
# Handle  pauliax   # Vulnerability details  ## Impact You import ICore interface but actually need only one function from it: pricePerShare(). Consider importing a minimal ICore interface with only the functions that you actually use to reduce deployment gas costs. Or you can just simply re-use ICoreOracle.   
# Handle  pauliax   # Vulnerability details  ## Impact There are many external risks (mentioned https://github.com/code-423n4/2021-10-badgerdao#risks) so my suggestion is that you should consider making the contracts pausable, so in case of an unexpected event, the governance can pause transfers.  ## Recommended Mitigation Steps Consider making contracts Pausable https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol  
# Handle  JMukesh   # Vulnerability details  ## Impact when pendingGovernance  call acceptPendingGovernance() , governance value get updated  but pendingGovernance  remain same its not updated to address(0)   governance = pendingGovernance;  due to which pendingGovernace and Governace share same address which should not happen  ## Tools Used manual review  ## Recommended Mitigation Steps update pendingGovernance to address(0)  
# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept most of the contract use floating pragma  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed pragma  
# Handle  defsec   # Vulnerability details  ## Impact  On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn’t done.  Especially in the balanceToShares function div(pricePerShare) which isn’t checked.   That will cause to revert on the transfer and transferFrom function. Oracle pricePerShare variable should be cheked on the balance calculation.  ## Proof of Concept  1. Navigate to the following contracts,  "https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtcEth.sol#L156"  "https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtc.sol#L148"  2. If oracle fails, the pricePerShare variable will be equal to zero therefore div by zero will occur.  ## Tools Used  Review  ## Recommended Mitigation Steps  Recommend making sure division by 0 won’t occur by checking the variables beforehand and handling this edge case.  
# Handle  defsec   # Vulnerability details  ## Impact After pragma version, 0.7.0, the contract should use block.timestamp.  ## Proof of Concept  1. Navigate to the following contract.  "https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L74"  2. Now is used instead of block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  It is recommended to use block.timestamp instead of now.   
# Handle  kenzo   # Vulnerability details  pricePerShare is read either from an oracle or from ibBTC's core.  If one of these is bugged or exploited, there are no safety checks to prevent loss of funds.  ## Impact As pricePerShare is used to calculate transfer amount, a bug or wrong data which returns smaller pricePerShare than it really is could result in drainage of wibbtc from Curve pool.  ## Proof of Concept Curve's swap and remove liquidity functions will both call wibbtc's `transfer` function: https://etherscan.io/address/0xFbdCA68601f835b27790D98bbb8eC7f05FDEaA9B#code%23L790 https://etherscan.io/address/0xFbdCA68601f835b27790D98bbb8eC7f05FDEaA9B#code%23L831 The `transfer` function calculates the amount to send by calling `balanceToShares`: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L127 `balanceToShares` calculates the shares (=amount to send) by dividing in `pricePerShare`: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L156 Therefore, if due to a bug or exploit in ibBTC core / the trusted oracle pricePerShare is smaller than it really is, the amount that will be sent will grow larger. So Curve will send to the user/exploiter doing swap/remove liquidity more tokens that he deserves.  ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Add sanity check:  pricePerShare should never decrease but only increase with time (as ibbtc accrues interest) (validated with DefiDollar team). This means that on every pricePerShare read/update, if the new pricePerShare is smaller than the current one, we can discard the update as bad data.   This will prevent an exploiter from draining Curve pool's wibbtc reserves by decreasing pricePerShare.  
# Handle  WatchPug   # Vulnerability details  Per the documentation, `wibBTC` is designed for a Curve StableSwap pool. However, the design of `wibBTC` makes the balances change dynamically and automatically. This is unusual for an ERC20 token, and it's not fully compatible with the current Curve StableSwap pool.  Specifically, a Curve StableSwap pool will maintain the balances of its `coins` based on the amount of tokens added, removed, and exchanged each time. In another word, it can not adopt the dynamic changes of the balances that happened automatically.  The pool's actual dynamic balance of `wibBTC` will deviate from the recorded balance in the pool contract as the `pricePerShare` increases.  Furthermore, there is no such way in Curve StableSwap similar to the `sync()` function of UNI v2, which will force sync the stored `reserves` to match the balances.  ### PoC  Given:  - The current `pricePerShare` is: `1`; - The Curve pool is newly created with 0 liquidity;  1. Alice added `100 wibBTC` and `100 wBTC` to the Curve pool; Alice holds 100% of the pool; 2. After 1 month with no activity (no other users, no trading), and the `pricePerShare` of `ibBTC` increases to `1.2`; 3. Alice removes all the liquidity from the Curve pool.  While it's expected to receive `150 wibBTC` and `100 wBTC`, Alice actually can only receive `100 wibBTC` and `100 wBTC`.  ### Recommendation  Consider creating a revised version of the Curve StableSwap contract that can handle dynamic balances properly.  
# Handle  WatchPug   # Vulnerability details  Based on the context, the functions listed below are not expected to be overridden, thus the use of the keyword `virtual` is redundant.  - transfer() - updatePricePerShare() - transferFrom() - pricePerShare()  ### Recommendation  Consider removing `virtual` for these functions.  
# Handle  WatchPug   # Vulnerability details  Given that `setCore()` could potentially lead to a change of `pricePerShare`, and `pricePerShare` will not be updated until `updatePricePerShare()` is called separately.  To ensure `pricePerShare` is up-to-date, `updatePricePerShare` should be run atomically with `setCore()`.  ### Recommendation  Consider changing `setCore()` to:  ```solidity function setCore(address _core) external onlyGovernance {     core = ICore(_core);      updatePricePerShare();      emit SetCore(_core); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L69-L77  ```solidity /// @dev Update live ibBTC price per share from core /// @dev We cache this to reduce gas costs of mint / burn / transfer operations. /// @dev Update function is permissionless, and must be updated at least once every X time as a sanity check to ensure value is up-to-date function updatePricePerShare() public virtual returns (uint256) {     pricePerShare = core.pricePerShare();     lastPricePerShareUpdate = now;      emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate); } ```  Per the comment above `function updatePricePerShare()`, `updatePricePerShare()` may get called quite often when `wibBTC` token is being used more often.  There could potentially be multiple calls to `updatePricePerShare()` in one block. In that case, checking if `pricePerShare` was updated earlier in the same block can save some gas from unnecessary external calls and storage writes.  ### Recommendation  Change to:  ```solidity function updatePricePerShare() public virtual returns (uint256) {     if (lastPricePerShareUpdate < now) {         pricePerShare = core.pricePerShare();         lastPricePerShareUpdate = now;          emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);     } } ```  
# Handle  WatchPug   # Vulnerability details  It's a best practice to use constant variables rather than literal values to make the code easier to understand and maintain.  The literal `1e18` is used throughout the contracts multiple times.  Consider defining a constant variable for the literal value used and giving it a clear and self-explanatory name.  
# Handle  WatchPug   # Vulnerability details  Most of the interfaces defined in `ICore.sol` are unused. The only method used is `pricePerShare()` which is identical to `ICoreOracle.sol#pricePerShare()`.  Therefore, `ICore.sol` can be removed and replaced by `ICoreOracle.sol`.  
# Handle  WatchPug   # Vulnerability details  The current implementation of `WrappedIbbtc.sol` will do an external call `oracle.pricePerShare()` every time `pricePerShare` is used, it can be gas consuming considering that the basic features include: `balanceOf()`, `transfer()`, `transferFrom()` will be used very often.  ### Recommendation  Consider caching `pricePerShare` in storage.  
# Handle  WatchPug   # Vulnerability details  `msg.sender` vs internal call of `_msgSender()`.  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtc.sol#L23-L36  ```solidity modifier onlyPendingGovernance() {     require(msg.sender == pendingGovernance, "onlyPendingGovernance");     _; }  modifier onlyGovernance() {     require(msg.sender == governance, "onlyGovernance");     _; }  modifier onlyOracle() {     require(msg.sender == address(oracle), "onlyOracle");     _; } ```  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L123-L131  ```solidity function transfer(address recipient, uint256 amount) public virtual override returns (bool) {     /// The _balances mapping represents the underlying ibBTC shares ("non-rebased balances")     /// Some naming confusion emerges due to maintaining original ERC20 var names      uint256 amountInShares = balanceToShares(amount);      _transfer(_msgSender(), recipient, amountInShares);     return true; } ```  
# Handle  WatchPug   # Vulnerability details  For the result of an external call being written into a storage variable, cache and read from the stack rather than read from the storage variable can save gas.  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L72-L77  ```solidity function updatePricePerShare() public virtual returns (uint256) {     pricePerShare = core.pricePerShare();     lastPricePerShareUpdate = now;      emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate); } ```  ### Recommendation  Change to:  ```solidity function updatePricePerShare() public virtual returns (uint256) {     uint256 lastPricePerShare = core.pricePerShare();     pricePerShare = lastPricePerShare;     lastPricePerShareUpdate = now;      emit SetPricePerShare(lastPricePerShare, lastPricePerShareUpdate); } ```  
# Handle  cmichel   # Vulnerability details  The `approve` function has not been overridden and therefore uses the internal _shares_, whereas `transfer(From)` uses the rebalanced amount.  ## Impact The approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing with `pricePerShare`.  Many contracts also use the same amount for the `approve` call as for the amount they want to have transferred in a subsequent `transferFrom` call, and in this case, they approve an amount that is too large (as the approved `shares` amount yields a higher rebalanced amount).  ## Recommended Mitigation Steps The `_allowances` field should track the rebalanced amounts such that the approval value does not grow. (This does not actually require overriding the `approve` function.) In `transferFrom`, the approvals should then be subtracted by the _transferred_ `amount`, not the `amountInShares`:  ```solidity // _allowances are in rebalanced amounts such that they don't grow // need to subtract the transferred amount _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance")); ```  
# Handle  cmichel   # Vulnerability details  The `acceptPendingGovernance` function does not reset `pendingGovernance` to zero.  ## Impact The pending governor can repeatedly accept the governance, emitting an `AcceptPendingGovernance` event each time, bloating listeners for this event with unnecessary data.  ## Recommended Mitigation Steps Validate the parameters.   
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `WrappedIbbtcEth.initialize`: The parameters could be checked to be non-zero or even if they're contracts implementing the desired interfaces.  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  defsec   # Vulnerability details  ## Impact  Since the _pendingGovernance parameter in the setPendingGovernance are used to add governance. In the state variable , proper check up should be done , other wise error in these state variable can lead to redeployment of contract.  ## Proof of Concept  1. Navigate to the following contract functions.  "https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtcEth.sol#L50"  "https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtc.sol#L49"  2. Adding zero address into the pending governance leads to failure of governor only functions.   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add proper zero address validation.   
# Handle  pmerkleplant   # Vulnerability details  The arguments of type `address` in the following functions miss a zero-check.  - `initialize()` - `setPendingGovernance()` - `setOracle()`  In the case of `setPendingGovernance()`, where a zero-address could be legitim, it should be stated as such in the docs, or forbidden otherwise.  ## Tools Used slither  
# Handle  jonah1005   # Vulnerability details  ## Impact The contract does not allow users to transfer by share. It's hard for users to clear out all the shares. There will be users using this token with Metamask. There's likely the `pricePerShare` would increase after the user sends transactions. I consider this is a medium-risk issue.  ## Proof of Concept [WrappedIbbtc.sol#L110-L118](https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L110-L118)  ## Tools Used  ## Recommended Mitigation Steps I consider a new `transferShares` beside the original `transfer()` would build a better UX. I consider sushi's bento box would be a good ref [BentoBox.sol](https://github.com/sushiswap/bentobox/blob/master/contracts/BentoBox.sol)  
# Handle  ye0lde   # Vulnerability details  For "core", which can be changed by the governance process, an event is emitted when it is changed from 0 to a hopefully valid value in the initialize function.  In the same initialize function the _governance address itself is not verified nor is there an event emitted showing that the governance address has changed from 0 to a different address.  ## Proof of Concept  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L37-L46  Similar but with Oracle instead of Core. https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtc.sol#L38-L45  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Emit an event reporting governance change or if it is not important to report these initialization events remove the emit for the core initialization.  
# Handle  gzeon   # Vulnerability details  ## Impact In WrappedIbbtc, user will not be able to transfer if oracle.pricePerShare() (L124) revert. This is because balanceToShares() is called in both transfer and transferFrom, which included a call to pricePerShare().   If this is the expected behavior, note that WrappedIbbtcEth is behaving the opposite as it use the cached value in a local variable pricePerShare which is only updated upon call to updatePricePerShare().  ## Recommended Mitigation Steps Depending on the specification, one of them need to be changed.  
# Handle  pants   # Vulnerability details  ibbtc is ERC20Upgradeable. Not all ERC20 contracts supports "blind" transfer method - i.e transfer that you can ignore the return value. You should either check the return value or use openzeppilin safeTransfer   
# Handle  jah   # Vulnerability details  ## Impact The parameter that are used in initialize() function to initialize the state variable,these state variable are used in other function to perform operation. since it lacks zero address validation, it will be problematic if there is error in these state variable. some of the function will loss their functionality which can cause the redeployment of contract  ## Proof of Concept https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L37  ## Tools Used Manual Analysis ## Recommended Mitigation Steps add require condition which check zero address validation   
# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L73  https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L123  oracle can `0` as a price of the share, in that case, 0 will be the denominator in some calculations which can cause reverts from SafeMath (for e.g here: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L148 ) resulting in Denial Of Service.  Add a null check to ensure that on every update, the price is greater than 0.  
# Handle  hyh   # Vulnerability details  ## Impact If price feed is manipulated in any way or there is any malfunction based volatility on the market, both contracts will pass it on a user. In the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.  ## Proof of Concept In WrappedIbbtcEth pricePerShare variable is updated by externally run updatePricePerShare function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72, and then used in mint/burn/transfer functions without additional checks via balanceToShares function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155.  In WrappedIbbtc price is requested via pricePerShare function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L123, and used in the same way without additional checks via balanceToShares function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L147.   ## Recommended Mitigation Steps Introduce minting/burning query that runs on schedule, separating user funds contribution and actual mint/burn. With user deposit or burn the corresponding action to be added to commitment query, which execution for mint or redeem will later be sparked by off-chain script according to fixed schedule. This also can be open to public execution with gas compensation incentive, for example as it's done in Tracer protocol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/develop/contracts/implementation/PoolKeeper.sol#L131 Full code of an implementation is too big to include it in the report, but viable versions are available publicly (Tracer protocol version can be found at the same repo, https://github.com/tracer-protocol/perpetual-pools-contracts/blob/develop/contracts/implementation/PoolCommitter.sol).  Once the scheduled mint/redeem query is added, the additional logic to control for price outliers will become possible there, as in this case mint/redeem execution can be conditioned to happen on calm market only, where various definitions of calm can be implemented. One of the approaches is to keep track of recent prices and require that new price each time be within a threshold from median of their array.  Example:  // Introduce small price tracking arrays: uint256[] private times; uint256[] private prices;  // Current position in array uint8 curPos;  // Current length, grows from 0 to totalMaxPos as prices are being added uint8 curMaxPos;  // Maximum length, we track up to totalMaxPos prices uint8 totalMaxPos = 10;  // Price movement threshold uint256 moveThreshold = 0.1*1e18;  We omit the full implementation here as it is lengthy enough and can vary. The key steps are: * Run query for scheduled mint/redeem with logic: if next price is greater than median of currently recorded prices by threshold, add it to the records, but do not mint/redeem. * That is, when scheduled mint/redeem is run, on new price request, WrappedIbbtcEth.core.pricePerShare() or WrappedIbbtc.oracle.pricePerShare(), get newPrice and calculate current price array median, curMed * prices[curPos] = newPrice * if (curMaxPos < totalMaxPos) {curMaxPos += 1} * if (curPos == curMaxPos) {curPos = 0} else {curPos += 1} * if (absolute_value_of(newPrice - curMed) < moveThreshold * curMed / 1e18) {do_mint/redeem; return_0_status} * else {return_1_status}  Schedule should be frequent enough, say once per 30 minutes, which is kept while returned status is 0. While threshold condition isn't met and returned status is 1, it runs once per 10 minutes. The parameters here are subject to calibration. This way if the price movement is sustained the mint/redeem happens after price array median comes to a new equilibrium. If price reverts, the outbreak will not have material effect mint/burn operations. This way the contract vulnerability is considerably reduced as attacker would need to keep distorted price for period long enough, which will happen after the first part of deposit/withdraw cycle. I.e. deposit and mint, burn and redeem operations will happen not simultaneously, preventing flash loans to be used to elevate the quantities, and for price to be effectively distorted it would be needed to keep it so for substantial amount of time.  
# Handle  hyh   # Vulnerability details  ## Impact Malicious user can monitor SetPricePerShare event and, if it was run long enough time ago and market moved, but, since there were no SetPricePerShare fired, the contract's pricePerShare is outdated, so a user can mint() with pricePerShare that is current for contract, but outdated for market, then wait for price update and burn() with updated pricePerShare, yielding risk-free profit at expense of contract holdings.  ## Proof of Concept WrappedIbbtcEth updates pricePerShare variable by externally run updatePricePerShare function. The variable is then used in mint/burn/transfer functions without any additional checks, even if outdated/stalled. This can happen if the external function wasn't run for any reason. The variable is used via balanceToShares function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155  This is feasible as updatePricePerShare to be run by off-chain script being a part of the system, and malfunction of this script leads to contract exposure by stalling the price. The malfunction can happen both by internal reasons (bugs) and by external ones (any system-level dependencies, network outrages). updatePricePerShare function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72  ## Recommended Mitigation Steps The risk comes with system design. Wrapping price updates with contract level variable for gas costs minimization is a viable approach, but it needs to be paired with corner cases handling. One of the ways to reduce the risk is as follows:  Introduce a threshold variable for maximum time elapsed since last pricePerShare update to WrappedIbbtcEth contract.  Then 2 variants of transferFrom and transfer functions can be introduced, both check condition {now - time since last price update < threshold}. If condition holds both variants do the transfer. If it doesn't the first variant reverts, while the second do costly price update. I.e. it will be cheap transfer, that works only if price is recent, and full transfer, that is similar to the first when price is recent, but do price update on its own when price is stalled. This way this full transfer is guaranteed to run and is usually cheap, costing more if price is stalled and it does the update.  After this whenever scheduled price update malfunctions (for example because of network conditions), the risk will be limited by market volatility during threshold time at maximum, i.e. capped.  Example code:    // Added threshold      uint256 public pricePerShare;     uint256 public lastPricePerShareUpdate;   uint256 public priceUpdateThreshold;      event SetPriceUpdateThreshold(uint256 priceUpdateThreshold);        /// ===== Permissioned: Price update threshold =====     function setPriceUpdateThreshold(uint256 _priceUpdateThreshold) external onlyGovernance {         priceUpdateThreshold = _priceUpdateThreshold;         emit SetPriceUpdateThreshold(priceUpdateThreshold);     }      // The only difference with current transfer code is that Full versions call balanceToSharesFull      function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToShares(amount);          _transfer(sender, recipient, amountInShares);         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, "ERC20: transfer amount exceeds allowance"));         return true;     }      function transfer(address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToShares(amount);          _transfer(_msgSender(), recipient, amountInShares);         return true;     }        function transferFromFull(address sender, address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToSharesFull(amount);          _transfer(sender, recipient, amountInShares);         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, "ERC20: transfer amount exceeds allowance"));         return true;     }      function transferFull(address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToSharesFull(amount);          _transfer(_msgSender(), recipient, amountInShares);         return true;     }      // Now balanceToShares first checks if the price is stale   // And reverts if it is   // While balanceToSharesFull do the same check   // But asks for price instead of reverting   // Having guaranteed execution with increased costs sometimes   // Which is fully deterministic, as user can track SetPricePerShare event   // To understand whether it be usual or increased gas cost if the function be called now      function balanceToShares(uint256 balance) public view returns (uint256) {     require(block.timestamp < lastPricePerShareUpdate + priceUpdateThreshold, "Price is stalled");         return balance.mul(1e18).div(pricePerShare);     }        function balanceToSharesFull(uint256 balance) public view returns (uint256) {     if (block.timestamp >= lastPricePerShareUpdate + priceUpdateThreshold) {       updatePricePerShare();     }         return balance.mul(1e18).div(pricePerShare);     }  
# Handle  JMukesh   # Vulnerability details  ## Impact In updatePricePerShare() instead of "block.timestamp" , "now"  is used which is deprciated.  "block.timestamp" is way more explicit in showing the intent while "now"  relates to the timestamp of the block controlled by the miner  more on this -> https://github.com/ethereum/solidity/issues/4020    ## Tools Used manual review  ## Recommended Mitigation Steps use block.timestamp  
# Handle  pauliax   # Vulnerability details  ## Impact functions mint, burn, transfer and transferFrom could skip other steps if the amount is 0.   
# Handle  pauliax   # Vulnerability details  ## Impact modifier onlyOracle in WrappedIbbtc is never used, so can be removed to reduce deployment gas costs.   
# Handle  pauliax   # Vulnerability details  ## Impact You import ICore interface but actually need only one function from it: pricePerShare(). Consider importing a minimal ICore interface with only the functions that you actually use to reduce deployment gas costs. Or you can just simply re-use ICoreOracle.   
# Handle  pauliax   # Vulnerability details  ## Impact There are many external risks (mentioned https://github.com/code-423n4/2021-10-badgerdao#risks) so my suggestion is that you should consider making the contracts pausable, so in case of an unexpected event, the governance can pause transfers.  ## Recommended Mitigation Steps Consider making contracts Pausable https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol  
# Handle  JMukesh   # Vulnerability details  ## Impact when pendingGovernance  call acceptPendingGovernance() , governance value get updated  but pendingGovernance  remain same its not updated to address(0)   governance = pendingGovernance;  due to which pendingGovernace and Governace share same address which should not happen  ## Tools Used manual review  ## Recommended Mitigation Steps update pendingGovernance to address(0)  
# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept most of the contract use floating pragma  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed pragma  
# Handle  defsec   # Vulnerability details  ## Impact  On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn’t done.  Especially in the balanceToShares function div(pricePerShare) which isn’t checked.   That will cause to revert on the transfer and transferFrom function. Oracle pricePerShare variable should be cheked on the balance calculation.  ## Proof of Concept  1. Navigate to the following contracts,  "https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtcEth.sol#L156"  "https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtc.sol#L148"  2. If oracle fails, the pricePerShare variable will be equal to zero therefore div by zero will occur.  ## Tools Used  Review  ## Recommended Mitigation Steps  Recommend making sure division by 0 won’t occur by checking the variables beforehand and handling this edge case.  
# Handle  defsec   # Vulnerability details  ## Impact After pragma version, 0.7.0, the contract should use block.timestamp.  ## Proof of Concept  1. Navigate to the following contract.  "https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L74"  2. Now is used instead of block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  It is recommended to use block.timestamp instead of now.   
# Handle  kenzo   # Vulnerability details  pricePerShare is read either from an oracle or from ibBTC's core.  If one of these is bugged or exploited, there are no safety checks to prevent loss of funds.  ## Impact As pricePerShare is used to calculate transfer amount, a bug or wrong data which returns smaller pricePerShare than it really is could result in drainage of wibbtc from Curve pool.  ## Proof of Concept Curve's swap and remove liquidity functions will both call wibbtc's `transfer` function: https://etherscan.io/address/0xFbdCA68601f835b27790D98bbb8eC7f05FDEaA9B#code%23L790 https://etherscan.io/address/0xFbdCA68601f835b27790D98bbb8eC7f05FDEaA9B#code%23L831 The `transfer` function calculates the amount to send by calling `balanceToShares`: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L127 `balanceToShares` calculates the shares (=amount to send) by dividing in `pricePerShare`: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L156 Therefore, if due to a bug or exploit in ibBTC core / the trusted oracle pricePerShare is smaller than it really is, the amount that will be sent will grow larger. So Curve will send to the user/exploiter doing swap/remove liquidity more tokens that he deserves.  ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Add sanity check:  pricePerShare should never decrease but only increase with time (as ibbtc accrues interest) (validated with DefiDollar team). This means that on every pricePerShare read/update, if the new pricePerShare is smaller than the current one, we can discard the update as bad data.   This will prevent an exploiter from draining Curve pool's wibbtc reserves by decreasing pricePerShare.  
# Handle  WatchPug   # Vulnerability details  Per the documentation, `wibBTC` is designed for a Curve StableSwap pool. However, the design of `wibBTC` makes the balances change dynamically and automatically. This is unusual for an ERC20 token, and it's not fully compatible with the current Curve StableSwap pool.  Specifically, a Curve StableSwap pool will maintain the balances of its `coins` based on the amount of tokens added, removed, and exchanged each time. In another word, it can not adopt the dynamic changes of the balances that happened automatically.  The pool's actual dynamic balance of `wibBTC` will deviate from the recorded balance in the pool contract as the `pricePerShare` increases.  Furthermore, there is no such way in Curve StableSwap similar to the `sync()` function of UNI v2, which will force sync the stored `reserves` to match the balances.  ### PoC  Given:  - The current `pricePerShare` is: `1`; - The Curve pool is newly created with 0 liquidity;  1. Alice added `100 wibBTC` and `100 wBTC` to the Curve pool; Alice holds 100% of the pool; 2. After 1 month with no activity (no other users, no trading), and the `pricePerShare` of `ibBTC` increases to `1.2`; 3. Alice removes all the liquidity from the Curve pool.  While it's expected to receive `150 wibBTC` and `100 wBTC`, Alice actually can only receive `100 wibBTC` and `100 wBTC`.  ### Recommendation  Consider creating a revised version of the Curve StableSwap contract that can handle dynamic balances properly.  
# Handle  WatchPug   # Vulnerability details  Based on the context, the functions listed below are not expected to be overridden, thus the use of the keyword `virtual` is redundant.  - transfer() - updatePricePerShare() - transferFrom() - pricePerShare()  ### Recommendation  Consider removing `virtual` for these functions.  
# Handle  WatchPug   # Vulnerability details  Given that `setCore()` could potentially lead to a change of `pricePerShare`, and `pricePerShare` will not be updated until `updatePricePerShare()` is called separately.  To ensure `pricePerShare` is up-to-date, `updatePricePerShare` should be run atomically with `setCore()`.  ### Recommendation  Consider changing `setCore()` to:  ```solidity function setCore(address _core) external onlyGovernance {     core = ICore(_core);      updatePricePerShare();      emit SetCore(_core); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L69-L77  ```solidity /// @dev Update live ibBTC price per share from core /// @dev We cache this to reduce gas costs of mint / burn / transfer operations. /// @dev Update function is permissionless, and must be updated at least once every X time as a sanity check to ensure value is up-to-date function updatePricePerShare() public virtual returns (uint256) {     pricePerShare = core.pricePerShare();     lastPricePerShareUpdate = now;      emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate); } ```  Per the comment above `function updatePricePerShare()`, `updatePricePerShare()` may get called quite often when `wibBTC` token is being used more often.  There could potentially be multiple calls to `updatePricePerShare()` in one block. In that case, checking if `pricePerShare` was updated earlier in the same block can save some gas from unnecessary external calls and storage writes.  ### Recommendation  Change to:  ```solidity function updatePricePerShare() public virtual returns (uint256) {     if (lastPricePerShareUpdate < now) {         pricePerShare = core.pricePerShare();         lastPricePerShareUpdate = now;          emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);     } } ```  
# Handle  WatchPug   # Vulnerability details  It's a best practice to use constant variables rather than literal values to make the code easier to understand and maintain.  The literal `1e18` is used throughout the contracts multiple times.  Consider defining a constant variable for the literal value used and giving it a clear and self-explanatory name.  
# Handle  WatchPug   # Vulnerability details  Most of the interfaces defined in `ICore.sol` are unused. The only method used is `pricePerShare()` which is identical to `ICoreOracle.sol#pricePerShare()`.  Therefore, `ICore.sol` can be removed and replaced by `ICoreOracle.sol`.  
# Handle  WatchPug   # Vulnerability details  The current implementation of `WrappedIbbtc.sol` will do an external call `oracle.pricePerShare()` every time `pricePerShare` is used, it can be gas consuming considering that the basic features include: `balanceOf()`, `transfer()`, `transferFrom()` will be used very often.  ### Recommendation  Consider caching `pricePerShare` in storage.  
# Handle  WatchPug   # Vulnerability details  `msg.sender` vs internal call of `_msgSender()`.  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtc.sol#L23-L36  ```solidity modifier onlyPendingGovernance() {     require(msg.sender == pendingGovernance, "onlyPendingGovernance");     _; }  modifier onlyGovernance() {     require(msg.sender == governance, "onlyGovernance");     _; }  modifier onlyOracle() {     require(msg.sender == address(oracle), "onlyOracle");     _; } ```  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L123-L131  ```solidity function transfer(address recipient, uint256 amount) public virtual override returns (bool) {     /// The _balances mapping represents the underlying ibBTC shares ("non-rebased balances")     /// Some naming confusion emerges due to maintaining original ERC20 var names      uint256 amountInShares = balanceToShares(amount);      _transfer(_msgSender(), recipient, amountInShares);     return true; } ```  
# Handle  WatchPug   # Vulnerability details  For the result of an external call being written into a storage variable, cache and read from the stack rather than read from the storage variable can save gas.  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L72-L77  ```solidity function updatePricePerShare() public virtual returns (uint256) {     pricePerShare = core.pricePerShare();     lastPricePerShareUpdate = now;      emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate); } ```  ### Recommendation  Change to:  ```solidity function updatePricePerShare() public virtual returns (uint256) {     uint256 lastPricePerShare = core.pricePerShare();     pricePerShare = lastPricePerShare;     lastPricePerShareUpdate = now;      emit SetPricePerShare(lastPricePerShare, lastPricePerShareUpdate); } ```  
# Handle  cmichel   # Vulnerability details  The `approve` function has not been overridden and therefore uses the internal _shares_, whereas `transfer(From)` uses the rebalanced amount.  ## Impact The approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing with `pricePerShare`.  Many contracts also use the same amount for the `approve` call as for the amount they want to have transferred in a subsequent `transferFrom` call, and in this case, they approve an amount that is too large (as the approved `shares` amount yields a higher rebalanced amount).  ## Recommended Mitigation Steps The `_allowances` field should track the rebalanced amounts such that the approval value does not grow. (This does not actually require overriding the `approve` function.) In `transferFrom`, the approvals should then be subtracted by the _transferred_ `amount`, not the `amountInShares`:  ```solidity // _allowances are in rebalanced amounts such that they don't grow // need to subtract the transferred amount _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance")); ```  
# Handle  cmichel   # Vulnerability details  The `acceptPendingGovernance` function does not reset `pendingGovernance` to zero.  ## Impact The pending governor can repeatedly accept the governance, emitting an `AcceptPendingGovernance` event each time, bloating listeners for this event with unnecessary data.  ## Recommended Mitigation Steps Validate the parameters.   
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `WrappedIbbtcEth.initialize`: The parameters could be checked to be non-zero or even if they're contracts implementing the desired interfaces.  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  defsec   # Vulnerability details  ## Impact  Since the _pendingGovernance parameter in the setPendingGovernance are used to add governance. In the state variable , proper check up should be done , other wise error in these state variable can lead to redeployment of contract.  ## Proof of Concept  1. Navigate to the following contract functions.  "https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtcEth.sol#L50"  "https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtc.sol#L49"  2. Adding zero address into the pending governance leads to failure of governor only functions.   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add proper zero address validation.   
# Handle  pmerkleplant   # Vulnerability details  The arguments of type `address` in the following functions miss a zero-check.  - `initialize()` - `setPendingGovernance()` - `setOracle()`  In the case of `setPendingGovernance()`, where a zero-address could be legitim, it should be stated as such in the docs, or forbidden otherwise.  ## Tools Used slither  
# Handle  jonah1005   # Vulnerability details  ## Impact The contract does not allow users to transfer by share. It's hard for users to clear out all the shares. There will be users using this token with Metamask. There's likely the `pricePerShare` would increase after the user sends transactions. I consider this is a medium-risk issue.  ## Proof of Concept [WrappedIbbtc.sol#L110-L118](https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L110-L118)  ## Tools Used  ## Recommended Mitigation Steps I consider a new `transferShares` beside the original `transfer()` would build a better UX. I consider sushi's bento box would be a good ref [BentoBox.sol](https://github.com/sushiswap/bentobox/blob/master/contracts/BentoBox.sol)  
# Handle  ye0lde   # Vulnerability details  For "core", which can be changed by the governance process, an event is emitted when it is changed from 0 to a hopefully valid value in the initialize function.  In the same initialize function the _governance address itself is not verified nor is there an event emitted showing that the governance address has changed from 0 to a different address.  ## Proof of Concept  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L37-L46  Similar but with Oracle instead of Core. https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtc.sol#L38-L45  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Emit an event reporting governance change or if it is not important to report these initialization events remove the emit for the core initialization.  
# Handle  gzeon   # Vulnerability details  ## Impact In WrappedIbbtc, user will not be able to transfer if oracle.pricePerShare() (L124) revert. This is because balanceToShares() is called in both transfer and transferFrom, which included a call to pricePerShare().   If this is the expected behavior, note that WrappedIbbtcEth is behaving the opposite as it use the cached value in a local variable pricePerShare which is only updated upon call to updatePricePerShare().  ## Recommended Mitigation Steps Depending on the specification, one of them need to be changed.  
# Handle  pants   # Vulnerability details  ibbtc is ERC20Upgradeable. Not all ERC20 contracts supports "blind" transfer method - i.e transfer that you can ignore the return value. You should either check the return value or use openzeppilin safeTransfer   
# Handle  jah   # Vulnerability details  ## Impact The parameter that are used in initialize() function to initialize the state variable,these state variable are used in other function to perform operation. since it lacks zero address validation, it will be problematic if there is error in these state variable. some of the function will loss their functionality which can cause the redeployment of contract  ## Proof of Concept https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L37  ## Tools Used Manual Analysis ## Recommended Mitigation Steps add require condition which check zero address validation   
