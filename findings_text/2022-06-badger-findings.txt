## Use bytes32 rather than string/bytes. ~300 gas (with optimization we spend 314 gas less while without it we spend 426 gas)  If you can fit your data in 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. [From the docs](https://docs.soliditylang.org/en/v0.5.8/types.html#bytes-and-strings-as-arrays), As a general rule, use bytes for arbitrary-length raw byte data and string for arbitrary-length string (UTF-8) data. If you can limit the length to a certain number of bytes, always use one of the value types bytes1 to bytes32 because they are much cheaper.  File: MyStrategy.sol [line 131-133](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L131-L133)  ```     function version() external pure returns (string memory) {         return "1.0";     } ```  **Tests for the above function** **Using strings** 21805 gas without optimization 21530 gas with optimization  **Using bytes32** 21379 gas without optimization 21216 gas with optimization  **Gas Estimates with optimization turned on**  ``` // 21530 gas     function version() external pure returns (string memory) {         return "1.0";     } // 21216 gas       function version() external pure returns (bytes32) {         return bytes32("1.0");     } ```  ## ++i costs less gas compared to i++ or i += 1  (~5 gas per iteration)  ++i costs less gas compared to i++ or i += 1 for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  i++ increments i and returns the initial value of i. Which means:  ``` uint i = 1;   i++; // == 1 but i == 2   ```  But ++i returns the actual incremented value:  ``` uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```  In the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2  Instances include:  File: MyStrategy.sol [line 118](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L118)  ```         for(uint i = 0; i < length; i++){ ```  Similar thing to my proposal was implemented in the following line  File: MyStrategy.sol [line 153](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L153)  ```         for (uint256 i; i < numRewards; ++i) { ```  **Other instances to modify** File: MyStrategy.sol [line 300](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L300) ```         for (uint256 i = 0; i < _claims.length; i++) { ```  File: MyStrategy.sol [line 317](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L317) ```         for (uint256 i = 0; i < _claims.length; i++) { ```   ## Splitting require() statements that use && saves gas - 8 gas per &&  Instead of using the && operator in a single require statement to check multiple conditions,using multiple require statements with 1 condition per require statement will save 8 GAS per && The gas difference would only be realized if the revert condition is realized(met).  File: MyStrategy.sol [line 184-187](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L184-L187)  ```         require(             balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,             "You have to wait for unlock or have to manually rebalance out of it"         ); ```  The above should be modified to:  ```   require(balanceOfPool() == 0,"You have to wait for unlock or have to manually rebalance out of it" );     require(LOCKER.balanceOf(address(this)) == 0,"You have to wait for unlock or have to manually rebalance out of it"); ```  **Proof** **The following tests were carried out in remix with both optimization turned on and off**  ```function     require ( a > 1 && a < 5, "Initialized");     return  a + 2; } ```  **Execution cost** 21617 with optimization and using && 21976 without optimization and using &&  After splitting the require statement  ```function     require (a > 1 ,"Initialized");     require (a < 5 , "Initialized");     return a + 2; } ```  **Execution cost** 21609 with optimization and split require 21968 without optimization and using split require   ## Cache the length of arrays in loops ~6 gas per iteration Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  The solidity compiler will always read the length of the array during each iteration. That is,     1.if it is a storage array, this is an extra sload operation (100 additional extra gas (EIP-2929 2) for each iteration except for the first),    2.if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first),    3.if it is a calldata array, this is an extra calldataload operation (3 additional gas for each iteration except for the first)  This extra costs can be avoided by caching the array length (in stack):  When reading the length of an array,  **sload** or **mload** or **calldataload** operation is only called once and subsequently replaced by a cheap **dupN** instruction. Even though mload , calldataload and dupN have the same gas cost, mload and calldataload needs an additional dupN to put the offset in the stack, i.e., an extra 3 gas. which brings this to 6 gas   Here, I suggest storing the array’s length in a variable before the for-loop, and use it instead:   File: MyStrategy.sol [line 300](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L300)  ```         for (uint256 i = 0; i < _claims.length; i++) { ```   File: MyStrategy.sol [line 317](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L317)  ```         for (uint256 i = 0; i < _claims.length; i++) { ```   Something similar to my propasal has been implemented already on [line 153](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L153)  ```     function balanceOfRewards() external view override returns (TokenAmount[] memory rewards) {         IAuraLocker.EarnedData[] memory earnedData = LOCKER.claimableRewards(address(this));         uint256 numRewards = earnedData.length;         rewards = new TokenAmount[](numRewards);         for (uint256 i; i < numRewards; ++i) {             rewards[i] = TokenAmount(earnedData[i].token, earnedData[i].amount);         }     } ```  ### No need to initialize variables with their default values  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). If you explicitly initialize it with its default value, you are just wasting gas. It costs more gas to initialize variables to zero than to let the default of zero be applied  File: MyStrategy.sol [line 115-121](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L115-L121)  ```     /// @dev Bulk function for sweepRewardToken     function sweepRewards(address[] calldata tokens) external {         uint256 length = tokens.length;         for(uint i = 0; i < length; i++){             sweepRewardToken(tokens[i]);         }     } ```  Similar thing was done on the following line: File:MyStrategy.sol [line 153-155](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L153-L155)  ```         for (uint256 i; i < numRewards; ++i) {             rewards[i] = TokenAmount(earnedData[i].token, earnedData[i].amount);         } ```  **Other instances to modify** File:MyStrategy.sol [line 317](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L317)  ```         for (uint256 i = 0; i < _claims.length; i++) { ```  ## use shorter revert strings(less than 32 bytes)   You can (and should) attach error reason strings along with require statements to make it easier to understand why a contract call reverted. These strings, however, take space in the deployed bytecode. Every reason string takes at least 32 bytes so make sure your string fits in 32 bytes or it will become more expensive.  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   File: MyStrategy.sol [line 184](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L184-L187)  ```         require(             balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,             "You have to wait for unlock or have to manually rebalance out of it"         ); ``` 
# Gas Optimizations  The following sections detail the gas optimizations found throughout the codebase. Each optimization is documented with the setup, an explainer for the optimization, a gas report and line identifiers for each optimization across the codebase. For each section's gas report, the optimizer was turned on and set to 10000 runs. You can replicate any tests/gas reports by heading to [0xKitsune/gas-lab](https://github.com/0xKitsune/gas-lab) and cloning the repo. Then, simply copy/paste the contract examples from any section and run `forge test --gas-report`. You can also easily update the optimizer runs in the `foundry.toml`.  ---   ## Use assembly to write storage values  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public {         c0.updateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);         c1.assemblyUpdateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);     } }  contract Contract0 {     address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;      function updateOwner(address newOwner) public {         owner = newOwner;     } }  contract Contract1 {     address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;      function assemblyUpdateOwner(address newOwner) public {         assembly {             sstore(owner.slot, newOwner)         }     } }  ```  ### Gas Report ```js ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 60623              ┆ 261             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ updateOwner        ┆ 5302            ┆ 5302 ┆ 5302   ┆ 5302 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 54823              ┆ 232             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyUpdateOwner┆ 5236            ┆ 5236 ┆ 5236   ┆ 5236 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ``` ### Lines - MyStrategy.sol:71  - MyStrategy.sol:88  - MyStrategy.sol:94  - MyStrategy.sol:310  - MyStrategy.sol:312   --- ## Use assembly when getting a contract's balance of ETH.  You can use `selfbalance()` instead of `address(this).balance` when getting your contract's balance of ETH to save gas. Additionally, you can use `balance(address)` instead of `address.balance()` when getting an external contract's balance of ETH.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();     }      function testGas() public {         c0.addressInternalBalance();         c1.assemblyInternalBalance();         c2.addressExternalBalance(address(this));         c3.assemblyExternalBalance(address(this));     } }  contract Contract0 {     function addressInternalBalance() public returns (uint256) {         return address(this).balance;     } }  contract Contract1 {     function assemblyInternalBalance() public returns (uint256) {         assembly {             let c := selfbalance()             mstore(0x00, c)             return(0x00, 0x20)         }     } }  contract Contract2 {     function addressExternalBalance(address addr) public {         uint256 bal = address(addr).balance;         bal++;     } }  contract Contract3 {     function assemblyExternalBalance(address addr) public {         uint256 bal;         assembly {             bal := balance(addr)         }         bal++;     } } ```  ### Gas Report  ```js ╭────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract     ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 23675                  ┆ 147             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addressInternalBalance ┆ 148             ┆ 148 ┆ 148    ┆ 148 ┆ 1       │ ╰────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭─────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract      ┆                 ┆     ┆        ┆     ┆         │ ╞═════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost         ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 27081                   ┆ 165             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name           ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyInternalBalance ┆ 133             ┆ 133 ┆ 133    ┆ 133 ┆ 1       │ ╰─────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract2 contract     ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 61511                  ┆ 339             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addressExternalBalance ┆ 417             ┆ 417 ┆ 417    ┆ 417 ┆ 1       │ ╰────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭─────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract3 contract      ┆                 ┆     ┆        ┆     ┆         │ ╞═════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost         ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 57105                   ┆ 317             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name           ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyExternalBalance ┆ 411             ┆ 411 ┆ 411    ┆ 411 ┆ 1       │ ╰─────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines - MyStrategy.sol:303  - MyStrategy.sol:322   --- ## `unchecked{++i}` instead of `i++` (or use assembly when applicable)  Use `++i` instead of `i++`. This is especially useful in for loops but this optimization can be used anywhere in your code. You can also use `unchecked{++i;}` for even more gas savings but this will not check to see if `i` overflows. For extra safety if you are worried about this, you can add a require statement after the loop checking if `i` is equal to the final incremented value. For best gas savings, use inline assembly, however this limits the functionality you can achieve. For example you cant use Solidity syntax to internally call your own contract within an assembly block and external calls must be done with the `call()` or `delegatecall()` instruction. However when applicable, inline assembly will save much more gas.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();     }      function testGas() public {         c0.iPlusPlus();         c1.plusPlusI();         c2.uncheckedPlusPlusI();         c3.safeUncheckedPlusPlusI();         c4.inlineAssemblyLoop();     } }  contract Contract0 {     //loop with i++     function iPlusPlus() public pure {         uint256 j = 0;         for (uint256 i; i < 10; i++) {             j++;         }     } }  contract Contract1 {     //loop with ++i     function plusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ++i) {             j++;         }     } }  contract Contract2 {     //loop with unchecked{++i}     function uncheckedPlusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }     } }  contract Contract3 {     //loop with unchecked{++i} with additional overflow check     function safeUncheckedPlusPlusI() public pure {         uint256 j = 0;         uint256 i = 0;         for (i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }          //check for overflow         assembly {             if lt(i, 10) {                 mstore(0x00, "loop overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //loop with inline assembly     function inlineAssemblyLoop() public pure {         assembly {             let j := 0              for {                 let i := 0             } lt(i, 10) {                 i := add(i, 0x01)             } {                 j := add(j, 0x01)             }         }     } }  ```  ### Gas Report  ```js  ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37687              ┆ 219             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ iPlusPlus          ┆ 2039            ┆ 2039 ┆ 2039   ┆ 2039 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ plusPlusI          ┆ 1989            ┆ 1989 ┆ 1989   ┆ 1989 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract3 contract     ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 42693                  ┆ 244             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ safeUncheckedPlusPlusI ┆ 1355            ┆ 1355 ┆ 1355   ┆ 1355 ┆ 1       │ ╰────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract2 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 35887              ┆ 210             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ uncheckedPlusPlusI ┆ 1329            ┆ 1329 ┆ 1329   ┆ 1329 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract4 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 26881              ┆ 164             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ inlineAssemblyLoop ┆ 709             ┆ 709 ┆ 709    ┆ 709 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines - MyStrategy.sol:118  - MyStrategy.sol:153  - MyStrategy.sol:300  - MyStrategy.sol:317   --- ## Use multiple `require()` statments insted of `require(expression && expression && ...)`  ```js contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public {         c0.singleRequire(3);         c1.multipleRequire(3);     } }  contract Contract0 {     function singleRequire(uint256 num) public {         require(num > 1 && num < 10 && num == 3);     } }  contract Contract1 {     function multipleRequire(uint256 num) public {         require(num > 1);         require(num < 10);         require(num == 3);     } } ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 35487              ┆ 208             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ singleRequire      ┆ 286             ┆ 286 ┆ 286    ┆ 286 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 35887              ┆ 210             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ multipleRequire    ┆ 270             ┆ 270 ┆ 270    ┆ 270 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines - MyStrategy.sol:185   --- ## Use assembly to check for address(0)  ```js   contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.ownerNotZero(address(this));         c1.assemblyOwnerNotZero(address(this));     } }  contract Contract0 {     function ownerNotZero(address _addr) public pure {         require(_addr != address(0), "zero address)");     } }  contract Contract1 {     function assemblyOwnerNotZero(address _addr) public pure {         assembly {             if iszero(_addr) {                 mstore(0x00, "zero address")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 61311              ┆ 338             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ ownerNotZero       ┆ 258             ┆ 258 ┆ 258    ┆ 258 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭──────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract   ┆                 ┆     ┆        ┆     ┆         │ ╞══════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost      ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 44893                ┆ 255             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name        ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyOwnerNotZero ┆ 252             ┆ 252 ┆ 252    ┆ 252 ┆ 1       │ ╰──────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines - MyStrategy.sol:290   --- 
# Lines of code  https://github.com/Badger-Finance/vested-aura/blob/v0.0.2/contracts/MyStrategy.sol#L220-L228 https://github.com/Badger-Finance/vested-aura/blob/v0.0.2/contracts/MyStrategy.sol#L288   # Vulnerability details  ## Impact The internal `_harvest()` function defined is responsible to claim auraBAL from the aura locker and within the function it swaps them to auraBAL -> BAL/ETH BPT -> WETH -> AURA, finally it locks AURA to the locker to increase the position. For claiming auraBAL it calls `LOCKER.getReward(address(this))` and it calculates the tokes earned, checking the balance before and after the claiming.  The function to get the rewards is public and any address can call it for the strategy address, and it will transfer all rewards tokens to the strategy, but in this scenario the auraBAL will remain in stuck into the contract, because they won't be counted as auraBAL earned during the next `_harvest()`. Also they could not sweep because auraBAL is a protected token.  Also, the aura Locker will be able to add other token as reward apart of auraBAL, but the harvest function won't be able to manage them, so they will need to be sweep every time.  The same scenario can happen during the `claimBribesFromHiddenHand()` call, the `IRewardDistributor.Claim[] calldata _claims` pass as input parameters could be frontrunned, and another address can call the `hiddenHandDistributor.claim(_claims)` (except for ETH rewards) for the strategy address, and like during the `_harvest()` only the tokens received during the call will be counted as earned. However every token, except auraBAL can be sweep, but the `_notifyBribesProcessor()` may never be called.  ## Proof of Concept At every `_harvest()` it checks the balance before the claim and after, to calculate the auraBAL earned, so every auraBAL transferred to the strategy address not during this call, won't be swapped to AURA.   ## Recommended Mitigation Steps Instead of calculating the balance before and after the claim, for both `harvest≠ and `claimBribesFromHiddenHand()`, the whole balance could be taken, directly after the claim.  
### Condition in `receive` function can be bypassed with self-destruct of another contract  **Details**: The logic in [L436-L438](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L436-L438) implies that the contract should only receive ether if `isClaimingBribes` is `true`. However, this check can be bypassed by deploying a contract (say, Attacker) and setting up the address of MyStrategy contract as the destination of a `selfdestruct` in the Attacker contract — for more information and otherway to bypass the require of [L437](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L437), see [this link](https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function).  **Impact**: Informational (could possibly break internal calculations of the protocol though)  ### **Re-entrancy guard upgradeable contract is not initialized**  **Details**: As stated in OpenZeppelin [docs](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#:~:text=When%20writing%20an%20initializer%2C%20you%20need%20to%20take%20special%20care%20to%20manually%20call%20the%20initializers%20of%20all%20parent%20contracts), “when writing an initializer, you need to take special care to manually call the initializers of all parent contracts”. However, the initializer of `ReentrancyGuardUpgradeable` is not called.  **Mitigation**: Ensure that all necessary functions are inherited from the upgradeable contracts.  **Impact**: Code QA  ### TODOs are left in comments  **Details**: In [L284](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L284) and [L422](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L422) of ****MyStrategy.sol**** there are comments with TODOs. These should be resolved and removed from the code before deployment.  **Mitigation**: Check the TODOs and fix/remove them.  **Impact**: Code QA  ### Usage of deprecated function safeApprove  **Details**: In [L65-68](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L65-L68) of ****MyStrategy.sol**** the function `safeApprove` from OpenZeppelin contracts are used, however these functions have been deprecated according to [OpenZeppelin 3.x docs](https://docs.openzeppelin.com/contracts/3.x/api/token/erc20#SafeERC20-safeApprove-contract-IERC20-address-uint256-) (note that ****MyStrategy.sol**** correctly use OpenZeppelin 3.4.0).  **Impact**: Code QA  ### Alert developers that OpenZeppelin contract cannot be bumped to 4.x  **Note to judges**: I think this issue is out-of-scope, but worthy to inform anyway 🙂  **Details**: According to [brownie config file](https://github.com/Badger-Finance/vested-aura/blob/v0.0.2/brownie-config.yaml), the contract **MyStrategy.sol** imports version 3.4.0 of OpenZeppelin’s SafeMath, and this is the recommend version to use with Solidity 0.6.12.  Unware developers, however, may want to bump OpenZeppelin version to the lastest one, and running `brownie compile` will compile the contract without errors (at least for 4.6.0). However, as alerted by the comments in [L6-8](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/51e11611c40ec1ad772e2a075cdc8487bbadf8ad/contracts/utils/math/SafeMathUpgradeable.sol#L6-L8), recent versions of SafeMath *should only be used with Solidity 0.8 or later, because it relies on the compiler's built in overflow checks*. This implies that checks of overflow/underflow will not be used, and this could be further exploited in other attacks.   This could also be particularly dangerous in the scenario wherein a developer does this bumping while writing his own MyStrategy contract, since he will probably use the SafeMath functions assuming that underflow/overflow checks are being used in his code.  **Mitigation**: Consider adding a comment in brownie config file alerting the users that OpenZeppelin version should not be bumped.  **Impact**: Informational (probably out-of-scope)
[GAS - 01] In `claimBribesFromHiddenHand`, `token` could be reused  The same external call is made twice:  https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L318 https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L301  Therefore gas could saved using a memory array to avoid doing the same external call twice.
# Lines of code  https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L428-L430 https://github.com/Badger-Finance/badger-vaults-1.5/blob/3c96bd83e9400671256b235422f63644f1ae3d2a/contracts/BaseStrategy.sol#L351 https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L407-L408   # Vulnerability details  ## Impact If the contract receives rewards from the hidden hand marketplace in BADGER then the contract tries to transfer the same amount of tokens twice to two different accounts, once with `_sendBadgerToTree()` in `MyStrategy` and again with `_processExtraToken()` in the `BasicStrategy` contract. As it is very likely that the strategy will not start with any BADGER tokens, the second transfer will revert (as we are using safeTransfer). This means that `claimBribesFromHiddenHand()` will always revert preventing any other bribes from being received. ## Proof of Concept 1. `claimBribesFromHiddenHand()` is called by strategist 2. Multiple bribes are sent to the strategy including BADGER. For example lets say 50 USDT And 50 BADGER 3. Strategy receives BADGER and calls `_handleRewardTransfer()` which calls `_sendBadgerToTree()`. 50 BADGER is sent to the Badger Tree so balance has dropped to 0. 4. 50 Badger is then again sent to Vault however balance is 0 so the command fails and reverts 5. No more tokens can be claimed anymore  ## Tools Used VS Code ## Recommended Mitigation Steps `_processExtraToken()` eventually sends the badger to the badger tree through the `Vault` contract. Change ```     function _sendBadgerToTree(uint256 amount) internal {         IERC20Upgradeable(BADGER).safeTransfer(BADGER_TREE, amount);         _processExtraToken(address(BADGER), amount);     } ``` to ```     function _sendBadgerToTree(uint256 amount) internal {         _processExtraToken(address(BADGER), amount);     } ```  
# Lines of code  https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L184-L187   # Vulnerability details  ## Impact  All funds can be migrated (withdrawn) at once to the caller vault by using the `BaseStrategy.withdrawToVault` function which internally calls `MyStrategy._withdrawAll`.  The latter function has the following check in place:  [MyStrategy.sol#L184-L187](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L184-L187)  ```solidity require(     balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,     "You have to wait for unlock or have to manually rebalance out of it" ); ```  Funds can only be withdrawn (migrated) if the balance in `LOCKER` is fully unlocked.  By locking a small amount of want tokens via `AuraLocker.lock` with the `strategy` address, a malicious individual can cause DoS and prevent withdrawing and migrating funds to the vault.  ## Proof of Concept  The following test case will replicate the DoS attack by locking "dust" want tokens for the `strategy` address. This causes `vault.withdrawToVault` to revert.  ```python def test_frontrun_migration(locker, deployer, vault, strategy, want, governance, keeper):     # Setup     randomUser = accounts[6]     snap = SnapshotManager(vault, strategy, "StrategySnapshot")      startingBalance = want.balanceOf(deployer)     depositAmount = startingBalance // 2     assert startingBalance >= depositAmount     # End Setup      # Deposit     want.approve(vault, MaxUint256, {"from": deployer})     snap.settDeposit(depositAmount, {"from": deployer})      chain.sleep(15)     chain.mine()      vault.earn({"from": keeper})      chain.snapshot()      # Test no harvests     chain.sleep(86400 * 250)  ## Wait 250 days so we can withdraw later     chain.mine()      before = {"settWant": want.balanceOf(vault), "stratWant": strategy.balanceOf()}      strategy.prepareWithdrawAll({"from": governance})      want.approve(locker, 1, {"from": deployer})     locker.lock(strategy, 1, { "from": deployer }) # Donate "dust" want tokens to strategy      vault.withdrawToVault({"from": governance}) # @audit-info reverts with "You have to wait for unlock or have to manually rebalance"      after = {"settWant": want.balanceOf(vault), "stratWant": strategy.balanceOf()}      assert after["settWant"] > before["settWant"]     assert after["stratWant"] < before["stratWant"]     assert after["stratWant"] == 0 ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Call `LOCKER.processExpiredLocks(false);` in `MyStrategy._withdrawAll` directly and remove the check which enforces unlocking all want tokens on L184-L187.   
# Lines of code  https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L107-L113 https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L405-L413 https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L421-L425   # Vulnerability details  ## Impact If the value of `bribesProcessor` was `0x0` (the default is `0x0` and `governance()`  can set to `0x0`) then attacker can call `sweepRewardToken()` make contract to send his total balance in attacker specified token to `0x0` address.  ## Proof of Concept the default value of `bribesProcessor` is `0x0` and `governance` can set the value to `0x0` at any time. rewards are stacking in contract address and they are supposed to send to `bribesProcessor`. This is `sweepRewardToken()` and `_handleRewardTransfer()` and `_sendTokenToBribesProcessor()` code: ```   /// @dev Function to move rewards that are not protected   /// @notice Only not protected, moves the whole amount using _handleRewardTransfer   /// @notice because token paths are hardcoded, this function is safe to be called by anyone   /// @notice Will not notify the BRIBES_PROCESSOR as this could be triggered outside bribes   function sweepRewardToken(address token) public nonReentrant {       _onlyGovernanceOrStrategist();       _onlyNotProtectedTokens(token);        uint256 toSend = IERC20Upgradeable(token).balanceOf(address(this));       _handleRewardTransfer(token, toSend);   }    function _handleRewardTransfer(address token, uint256 amount) internal {       // NOTE: BADGER is emitted through the tree       if (token == BADGER) {           _sendBadgerToTree(amount);       } else {           // NOTE: All other tokens are sent to bribes processor           _sendTokenToBribesProcessor(token, amount);       }   }    function _sendTokenToBribesProcessor(address token, uint256 amount) internal {       // TODO: Too many SLOADs       IERC20Upgradeable(token).safeTransfer(address(bribesProcessor), amount);       emit RewardsCollected(token, amount);   } ``` As you can see calling `sweepRewardToken()` eventually (`sweepRewardToken() -> _handleRewardTransfer() -> _sendTokenToBribesProcessor()`) would transfer reward funds to `bribesProcessor` and there is no check that `bribesProcessor!=0x0` in execution follow. so attacker can call `sweepRewardToken()` when `bribesProcessor` is `0x0` and contract will lose all reward tokens.   ## Tools Used VIM  ## Recommended Mitigation Steps check the value of `bribesProcessor` in `_sendTokenToBribesProcessor()`  
## Use bytes32 rather than string/bytes. ~300 gas (with optimization we spend 314 gas less while without it we spend 426 gas)  If you can fit your data in 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. [From the docs](https://docs.soliditylang.org/en/v0.5.8/types.html#bytes-and-strings-as-arrays), As a general rule, use bytes for arbitrary-length raw byte data and string for arbitrary-length string (UTF-8) data. If you can limit the length to a certain number of bytes, always use one of the value types bytes1 to bytes32 because they are much cheaper.  File: MyStrategy.sol [line 131-133](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L131-L133)  ```     function version() external pure returns (string memory) {         return "1.0";     } ```  **Tests for the above function** **Using strings** 21805 gas without optimization 21530 gas with optimization  **Using bytes32** 21379 gas without optimization 21216 gas with optimization  **Gas Estimates with optimization turned on**  ``` // 21530 gas     function version() external pure returns (string memory) {         return "1.0";     } // 21216 gas       function version() external pure returns (bytes32) {         return bytes32("1.0");     } ```  ## ++i costs less gas compared to i++ or i += 1  (~5 gas per iteration)  ++i costs less gas compared to i++ or i += 1 for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  i++ increments i and returns the initial value of i. Which means:  ``` uint i = 1;   i++; // == 1 but i == 2   ```  But ++i returns the actual incremented value:  ``` uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```  In the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2  Instances include:  File: MyStrategy.sol [line 118](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L118)  ```         for(uint i = 0; i < length; i++){ ```  Similar thing to my proposal was implemented in the following line  File: MyStrategy.sol [line 153](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L153)  ```         for (uint256 i; i < numRewards; ++i) { ```  **Other instances to modify** File: MyStrategy.sol [line 300](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L300) ```         for (uint256 i = 0; i < _claims.length; i++) { ```  File: MyStrategy.sol [line 317](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L317) ```         for (uint256 i = 0; i < _claims.length; i++) { ```   ## Splitting require() statements that use && saves gas - 8 gas per &&  Instead of using the && operator in a single require statement to check multiple conditions,using multiple require statements with 1 condition per require statement will save 8 GAS per && The gas difference would only be realized if the revert condition is realized(met).  File: MyStrategy.sol [line 184-187](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L184-L187)  ```         require(             balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,             "You have to wait for unlock or have to manually rebalance out of it"         ); ```  The above should be modified to:  ```   require(balanceOfPool() == 0,"You have to wait for unlock or have to manually rebalance out of it" );     require(LOCKER.balanceOf(address(this)) == 0,"You have to wait for unlock or have to manually rebalance out of it"); ```  **Proof** **The following tests were carried out in remix with both optimization turned on and off**  ```function     require ( a > 1 && a < 5, "Initialized");     return  a + 2; } ```  **Execution cost** 21617 with optimization and using && 21976 without optimization and using &&  After splitting the require statement  ```function     require (a > 1 ,"Initialized");     require (a < 5 , "Initialized");     return a + 2; } ```  **Execution cost** 21609 with optimization and split require 21968 without optimization and using split require   ## Cache the length of arrays in loops ~6 gas per iteration Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  The solidity compiler will always read the length of the array during each iteration. That is,     1.if it is a storage array, this is an extra sload operation (100 additional extra gas (EIP-2929 2) for each iteration except for the first),    2.if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first),    3.if it is a calldata array, this is an extra calldataload operation (3 additional gas for each iteration except for the first)  This extra costs can be avoided by caching the array length (in stack):  When reading the length of an array,  **sload** or **mload** or **calldataload** operation is only called once and subsequently replaced by a cheap **dupN** instruction. Even though mload , calldataload and dupN have the same gas cost, mload and calldataload needs an additional dupN to put the offset in the stack, i.e., an extra 3 gas. which brings this to 6 gas   Here, I suggest storing the array’s length in a variable before the for-loop, and use it instead:   File: MyStrategy.sol [line 300](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L300)  ```         for (uint256 i = 0; i < _claims.length; i++) { ```   File: MyStrategy.sol [line 317](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L317)  ```         for (uint256 i = 0; i < _claims.length; i++) { ```   Something similar to my propasal has been implemented already on [line 153](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L153)  ```     function balanceOfRewards() external view override returns (TokenAmount[] memory rewards) {         IAuraLocker.EarnedData[] memory earnedData = LOCKER.claimableRewards(address(this));         uint256 numRewards = earnedData.length;         rewards = new TokenAmount[](numRewards);         for (uint256 i; i < numRewards; ++i) {             rewards[i] = TokenAmount(earnedData[i].token, earnedData[i].amount);         }     } ```  ### No need to initialize variables with their default values  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). If you explicitly initialize it with its default value, you are just wasting gas. It costs more gas to initialize variables to zero than to let the default of zero be applied  File: MyStrategy.sol [line 115-121](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L115-L121)  ```     /// @dev Bulk function for sweepRewardToken     function sweepRewards(address[] calldata tokens) external {         uint256 length = tokens.length;         for(uint i = 0; i < length; i++){             sweepRewardToken(tokens[i]);         }     } ```  Similar thing was done on the following line: File:MyStrategy.sol [line 153-155](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L153-L155)  ```         for (uint256 i; i < numRewards; ++i) {             rewards[i] = TokenAmount(earnedData[i].token, earnedData[i].amount);         } ```  **Other instances to modify** File:MyStrategy.sol [line 317](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L317)  ```         for (uint256 i = 0; i < _claims.length; i++) { ```  ## use shorter revert strings(less than 32 bytes)   You can (and should) attach error reason strings along with require statements to make it easier to understand why a contract call reverted. These strings, however, take space in the deployed bytecode. Every reason string takes at least 32 bytes so make sure your string fits in 32 bytes or it will become more expensive.  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   File: MyStrategy.sol [line 184](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L184-L187)  ```         require(             balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,             "You have to wait for unlock or have to manually rebalance out of it"         ); ``` 
# Gas Optimizations  The following sections detail the gas optimizations found throughout the codebase. Each optimization is documented with the setup, an explainer for the optimization, a gas report and line identifiers for each optimization across the codebase. For each section's gas report, the optimizer was turned on and set to 10000 runs. You can replicate any tests/gas reports by heading to [0xKitsune/gas-lab](https://github.com/0xKitsune/gas-lab) and cloning the repo. Then, simply copy/paste the contract examples from any section and run `forge test --gas-report`. You can also easily update the optimizer runs in the `foundry.toml`.  ---   ## Use assembly to write storage values  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public {         c0.updateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);         c1.assemblyUpdateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);     } }  contract Contract0 {     address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;      function updateOwner(address newOwner) public {         owner = newOwner;     } }  contract Contract1 {     address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;      function assemblyUpdateOwner(address newOwner) public {         assembly {             sstore(owner.slot, newOwner)         }     } }  ```  ### Gas Report ```js ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 60623              ┆ 261             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ updateOwner        ┆ 5302            ┆ 5302 ┆ 5302   ┆ 5302 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 54823              ┆ 232             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyUpdateOwner┆ 5236            ┆ 5236 ┆ 5236   ┆ 5236 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ``` ### Lines - MyStrategy.sol:71  - MyStrategy.sol:88  - MyStrategy.sol:94  - MyStrategy.sol:310  - MyStrategy.sol:312   --- ## Use assembly when getting a contract's balance of ETH.  You can use `selfbalance()` instead of `address(this).balance` when getting your contract's balance of ETH to save gas. Additionally, you can use `balance(address)` instead of `address.balance()` when getting an external contract's balance of ETH.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();     }      function testGas() public {         c0.addressInternalBalance();         c1.assemblyInternalBalance();         c2.addressExternalBalance(address(this));         c3.assemblyExternalBalance(address(this));     } }  contract Contract0 {     function addressInternalBalance() public returns (uint256) {         return address(this).balance;     } }  contract Contract1 {     function assemblyInternalBalance() public returns (uint256) {         assembly {             let c := selfbalance()             mstore(0x00, c)             return(0x00, 0x20)         }     } }  contract Contract2 {     function addressExternalBalance(address addr) public {         uint256 bal = address(addr).balance;         bal++;     } }  contract Contract3 {     function assemblyExternalBalance(address addr) public {         uint256 bal;         assembly {             bal := balance(addr)         }         bal++;     } } ```  ### Gas Report  ```js ╭────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract     ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 23675                  ┆ 147             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addressInternalBalance ┆ 148             ┆ 148 ┆ 148    ┆ 148 ┆ 1       │ ╰────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭─────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract      ┆                 ┆     ┆        ┆     ┆         │ ╞═════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost         ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 27081                   ┆ 165             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name           ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyInternalBalance ┆ 133             ┆ 133 ┆ 133    ┆ 133 ┆ 1       │ ╰─────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract2 contract     ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 61511                  ┆ 339             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addressExternalBalance ┆ 417             ┆ 417 ┆ 417    ┆ 417 ┆ 1       │ ╰────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭─────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract3 contract      ┆                 ┆     ┆        ┆     ┆         │ ╞═════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost         ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 57105                   ┆ 317             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name           ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyExternalBalance ┆ 411             ┆ 411 ┆ 411    ┆ 411 ┆ 1       │ ╰─────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines - MyStrategy.sol:303  - MyStrategy.sol:322   --- ## `unchecked{++i}` instead of `i++` (or use assembly when applicable)  Use `++i` instead of `i++`. This is especially useful in for loops but this optimization can be used anywhere in your code. You can also use `unchecked{++i;}` for even more gas savings but this will not check to see if `i` overflows. For extra safety if you are worried about this, you can add a require statement after the loop checking if `i` is equal to the final incremented value. For best gas savings, use inline assembly, however this limits the functionality you can achieve. For example you cant use Solidity syntax to internally call your own contract within an assembly block and external calls must be done with the `call()` or `delegatecall()` instruction. However when applicable, inline assembly will save much more gas.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();     }      function testGas() public {         c0.iPlusPlus();         c1.plusPlusI();         c2.uncheckedPlusPlusI();         c3.safeUncheckedPlusPlusI();         c4.inlineAssemblyLoop();     } }  contract Contract0 {     //loop with i++     function iPlusPlus() public pure {         uint256 j = 0;         for (uint256 i; i < 10; i++) {             j++;         }     } }  contract Contract1 {     //loop with ++i     function plusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ++i) {             j++;         }     } }  contract Contract2 {     //loop with unchecked{++i}     function uncheckedPlusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }     } }  contract Contract3 {     //loop with unchecked{++i} with additional overflow check     function safeUncheckedPlusPlusI() public pure {         uint256 j = 0;         uint256 i = 0;         for (i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }          //check for overflow         assembly {             if lt(i, 10) {                 mstore(0x00, "loop overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //loop with inline assembly     function inlineAssemblyLoop() public pure {         assembly {             let j := 0              for {                 let i := 0             } lt(i, 10) {                 i := add(i, 0x01)             } {                 j := add(j, 0x01)             }         }     } }  ```  ### Gas Report  ```js  ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37687              ┆ 219             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ iPlusPlus          ┆ 2039            ┆ 2039 ┆ 2039   ┆ 2039 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ plusPlusI          ┆ 1989            ┆ 1989 ┆ 1989   ┆ 1989 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract3 contract     ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 42693                  ┆ 244             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ safeUncheckedPlusPlusI ┆ 1355            ┆ 1355 ┆ 1355   ┆ 1355 ┆ 1       │ ╰────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract2 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 35887              ┆ 210             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ uncheckedPlusPlusI ┆ 1329            ┆ 1329 ┆ 1329   ┆ 1329 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract4 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 26881              ┆ 164             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ inlineAssemblyLoop ┆ 709             ┆ 709 ┆ 709    ┆ 709 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines - MyStrategy.sol:118  - MyStrategy.sol:153  - MyStrategy.sol:300  - MyStrategy.sol:317   --- ## Use multiple `require()` statments insted of `require(expression && expression && ...)`  ```js contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public {         c0.singleRequire(3);         c1.multipleRequire(3);     } }  contract Contract0 {     function singleRequire(uint256 num) public {         require(num > 1 && num < 10 && num == 3);     } }  contract Contract1 {     function multipleRequire(uint256 num) public {         require(num > 1);         require(num < 10);         require(num == 3);     } } ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 35487              ┆ 208             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ singleRequire      ┆ 286             ┆ 286 ┆ 286    ┆ 286 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 35887              ┆ 210             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ multipleRequire    ┆ 270             ┆ 270 ┆ 270    ┆ 270 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines - MyStrategy.sol:185   --- ## Use assembly to check for address(0)  ```js   contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.ownerNotZero(address(this));         c1.assemblyOwnerNotZero(address(this));     } }  contract Contract0 {     function ownerNotZero(address _addr) public pure {         require(_addr != address(0), "zero address)");     } }  contract Contract1 {     function assemblyOwnerNotZero(address _addr) public pure {         assembly {             if iszero(_addr) {                 mstore(0x00, "zero address")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 61311              ┆ 338             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ ownerNotZero       ┆ 258             ┆ 258 ┆ 258    ┆ 258 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭──────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract   ┆                 ┆     ┆        ┆     ┆         │ ╞══════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost      ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 44893                ┆ 255             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name        ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyOwnerNotZero ┆ 252             ┆ 252 ┆ 252    ┆ 252 ┆ 1       │ ╰──────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines - MyStrategy.sol:290   --- 
# Lines of code  https://github.com/Badger-Finance/vested-aura/blob/v0.0.2/contracts/MyStrategy.sol#L220-L228 https://github.com/Badger-Finance/vested-aura/blob/v0.0.2/contracts/MyStrategy.sol#L288   # Vulnerability details  ## Impact The internal `_harvest()` function defined is responsible to claim auraBAL from the aura locker and within the function it swaps them to auraBAL -> BAL/ETH BPT -> WETH -> AURA, finally it locks AURA to the locker to increase the position. For claiming auraBAL it calls `LOCKER.getReward(address(this))` and it calculates the tokes earned, checking the balance before and after the claiming.  The function to get the rewards is public and any address can call it for the strategy address, and it will transfer all rewards tokens to the strategy, but in this scenario the auraBAL will remain in stuck into the contract, because they won't be counted as auraBAL earned during the next `_harvest()`. Also they could not sweep because auraBAL is a protected token.  Also, the aura Locker will be able to add other token as reward apart of auraBAL, but the harvest function won't be able to manage them, so they will need to be sweep every time.  The same scenario can happen during the `claimBribesFromHiddenHand()` call, the `IRewardDistributor.Claim[] calldata _claims` pass as input parameters could be frontrunned, and another address can call the `hiddenHandDistributor.claim(_claims)` (except for ETH rewards) for the strategy address, and like during the `_harvest()` only the tokens received during the call will be counted as earned. However every token, except auraBAL can be sweep, but the `_notifyBribesProcessor()` may never be called.  ## Proof of Concept At every `_harvest()` it checks the balance before the claim and after, to calculate the auraBAL earned, so every auraBAL transferred to the strategy address not during this call, won't be swapped to AURA.   ## Recommended Mitigation Steps Instead of calculating the balance before and after the claim, for both `harvest≠ and `claimBribesFromHiddenHand()`, the whole balance could be taken, directly after the claim.  
### Condition in `receive` function can be bypassed with self-destruct of another contract  **Details**: The logic in [L436-L438](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L436-L438) implies that the contract should only receive ether if `isClaimingBribes` is `true`. However, this check can be bypassed by deploying a contract (say, Attacker) and setting up the address of MyStrategy contract as the destination of a `selfdestruct` in the Attacker contract — for more information and otherway to bypass the require of [L437](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L437), see [this link](https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function).  **Impact**: Informational (could possibly break internal calculations of the protocol though)  ### **Re-entrancy guard upgradeable contract is not initialized**  **Details**: As stated in OpenZeppelin [docs](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#:~:text=When%20writing%20an%20initializer%2C%20you%20need%20to%20take%20special%20care%20to%20manually%20call%20the%20initializers%20of%20all%20parent%20contracts), “when writing an initializer, you need to take special care to manually call the initializers of all parent contracts”. However, the initializer of `ReentrancyGuardUpgradeable` is not called.  **Mitigation**: Ensure that all necessary functions are inherited from the upgradeable contracts.  **Impact**: Code QA  ### TODOs are left in comments  **Details**: In [L284](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L284) and [L422](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L422) of ****MyStrategy.sol**** there are comments with TODOs. These should be resolved and removed from the code before deployment.  **Mitigation**: Check the TODOs and fix/remove them.  **Impact**: Code QA  ### Usage of deprecated function safeApprove  **Details**: In [L65-68](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L65-L68) of ****MyStrategy.sol**** the function `safeApprove` from OpenZeppelin contracts are used, however these functions have been deprecated according to [OpenZeppelin 3.x docs](https://docs.openzeppelin.com/contracts/3.x/api/token/erc20#SafeERC20-safeApprove-contract-IERC20-address-uint256-) (note that ****MyStrategy.sol**** correctly use OpenZeppelin 3.4.0).  **Impact**: Code QA  ### Alert developers that OpenZeppelin contract cannot be bumped to 4.x  **Note to judges**: I think this issue is out-of-scope, but worthy to inform anyway 🙂  **Details**: According to [brownie config file](https://github.com/Badger-Finance/vested-aura/blob/v0.0.2/brownie-config.yaml), the contract **MyStrategy.sol** imports version 3.4.0 of OpenZeppelin’s SafeMath, and this is the recommend version to use with Solidity 0.6.12.  Unware developers, however, may want to bump OpenZeppelin version to the lastest one, and running `brownie compile` will compile the contract without errors (at least for 4.6.0). However, as alerted by the comments in [L6-8](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/51e11611c40ec1ad772e2a075cdc8487bbadf8ad/contracts/utils/math/SafeMathUpgradeable.sol#L6-L8), recent versions of SafeMath *should only be used with Solidity 0.8 or later, because it relies on the compiler's built in overflow checks*. This implies that checks of overflow/underflow will not be used, and this could be further exploited in other attacks.   This could also be particularly dangerous in the scenario wherein a developer does this bumping while writing his own MyStrategy contract, since he will probably use the SafeMath functions assuming that underflow/overflow checks are being used in his code.  **Mitigation**: Consider adding a comment in brownie config file alerting the users that OpenZeppelin version should not be bumped.  **Impact**: Informational (probably out-of-scope)
[GAS - 01] In `claimBribesFromHiddenHand`, `token` could be reused  The same external call is made twice:  https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L318 https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L301  Therefore gas could saved using a memory array to avoid doing the same external call twice.
# Lines of code  https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L428-L430 https://github.com/Badger-Finance/badger-vaults-1.5/blob/3c96bd83e9400671256b235422f63644f1ae3d2a/contracts/BaseStrategy.sol#L351 https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L407-L408   # Vulnerability details  ## Impact If the contract receives rewards from the hidden hand marketplace in BADGER then the contract tries to transfer the same amount of tokens twice to two different accounts, once with `_sendBadgerToTree()` in `MyStrategy` and again with `_processExtraToken()` in the `BasicStrategy` contract. As it is very likely that the strategy will not start with any BADGER tokens, the second transfer will revert (as we are using safeTransfer). This means that `claimBribesFromHiddenHand()` will always revert preventing any other bribes from being received. ## Proof of Concept 1. `claimBribesFromHiddenHand()` is called by strategist 2. Multiple bribes are sent to the strategy including BADGER. For example lets say 50 USDT And 50 BADGER 3. Strategy receives BADGER and calls `_handleRewardTransfer()` which calls `_sendBadgerToTree()`. 50 BADGER is sent to the Badger Tree so balance has dropped to 0. 4. 50 Badger is then again sent to Vault however balance is 0 so the command fails and reverts 5. No more tokens can be claimed anymore  ## Tools Used VS Code ## Recommended Mitigation Steps `_processExtraToken()` eventually sends the badger to the badger tree through the `Vault` contract. Change ```     function _sendBadgerToTree(uint256 amount) internal {         IERC20Upgradeable(BADGER).safeTransfer(BADGER_TREE, amount);         _processExtraToken(address(BADGER), amount);     } ``` to ```     function _sendBadgerToTree(uint256 amount) internal {         _processExtraToken(address(BADGER), amount);     } ```  
# Lines of code  https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L184-L187   # Vulnerability details  ## Impact  All funds can be migrated (withdrawn) at once to the caller vault by using the `BaseStrategy.withdrawToVault` function which internally calls `MyStrategy._withdrawAll`.  The latter function has the following check in place:  [MyStrategy.sol#L184-L187](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L184-L187)  ```solidity require(     balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,     "You have to wait for unlock or have to manually rebalance out of it" ); ```  Funds can only be withdrawn (migrated) if the balance in `LOCKER` is fully unlocked.  By locking a small amount of want tokens via `AuraLocker.lock` with the `strategy` address, a malicious individual can cause DoS and prevent withdrawing and migrating funds to the vault.  ## Proof of Concept  The following test case will replicate the DoS attack by locking "dust" want tokens for the `strategy` address. This causes `vault.withdrawToVault` to revert.  ```python def test_frontrun_migration(locker, deployer, vault, strategy, want, governance, keeper):     # Setup     randomUser = accounts[6]     snap = SnapshotManager(vault, strategy, "StrategySnapshot")      startingBalance = want.balanceOf(deployer)     depositAmount = startingBalance // 2     assert startingBalance >= depositAmount     # End Setup      # Deposit     want.approve(vault, MaxUint256, {"from": deployer})     snap.settDeposit(depositAmount, {"from": deployer})      chain.sleep(15)     chain.mine()      vault.earn({"from": keeper})      chain.snapshot()      # Test no harvests     chain.sleep(86400 * 250)  ## Wait 250 days so we can withdraw later     chain.mine()      before = {"settWant": want.balanceOf(vault), "stratWant": strategy.balanceOf()}      strategy.prepareWithdrawAll({"from": governance})      want.approve(locker, 1, {"from": deployer})     locker.lock(strategy, 1, { "from": deployer }) # Donate "dust" want tokens to strategy      vault.withdrawToVault({"from": governance}) # @audit-info reverts with "You have to wait for unlock or have to manually rebalance"      after = {"settWant": want.balanceOf(vault), "stratWant": strategy.balanceOf()}      assert after["settWant"] > before["settWant"]     assert after["stratWant"] < before["stratWant"]     assert after["stratWant"] == 0 ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Call `LOCKER.processExpiredLocks(false);` in `MyStrategy._withdrawAll` directly and remove the check which enforces unlocking all want tokens on L184-L187.   
# Lines of code  https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L107-L113 https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L405-L413 https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L421-L425   # Vulnerability details  ## Impact If the value of `bribesProcessor` was `0x0` (the default is `0x0` and `governance()`  can set to `0x0`) then attacker can call `sweepRewardToken()` make contract to send his total balance in attacker specified token to `0x0` address.  ## Proof of Concept the default value of `bribesProcessor` is `0x0` and `governance` can set the value to `0x0` at any time. rewards are stacking in contract address and they are supposed to send to `bribesProcessor`. This is `sweepRewardToken()` and `_handleRewardTransfer()` and `_sendTokenToBribesProcessor()` code: ```   /// @dev Function to move rewards that are not protected   /// @notice Only not protected, moves the whole amount using _handleRewardTransfer   /// @notice because token paths are hardcoded, this function is safe to be called by anyone   /// @notice Will not notify the BRIBES_PROCESSOR as this could be triggered outside bribes   function sweepRewardToken(address token) public nonReentrant {       _onlyGovernanceOrStrategist();       _onlyNotProtectedTokens(token);        uint256 toSend = IERC20Upgradeable(token).balanceOf(address(this));       _handleRewardTransfer(token, toSend);   }    function _handleRewardTransfer(address token, uint256 amount) internal {       // NOTE: BADGER is emitted through the tree       if (token == BADGER) {           _sendBadgerToTree(amount);       } else {           // NOTE: All other tokens are sent to bribes processor           _sendTokenToBribesProcessor(token, amount);       }   }    function _sendTokenToBribesProcessor(address token, uint256 amount) internal {       // TODO: Too many SLOADs       IERC20Upgradeable(token).safeTransfer(address(bribesProcessor), amount);       emit RewardsCollected(token, amount);   } ``` As you can see calling `sweepRewardToken()` eventually (`sweepRewardToken() -> _handleRewardTransfer() -> _sendTokenToBribesProcessor()`) would transfer reward funds to `bribesProcessor` and there is no check that `bribesProcessor!=0x0` in execution follow. so attacker can call `sweepRewardToken()` when `bribesProcessor` is `0x0` and contract will lose all reward tokens.   ## Tools Used VIM  ## Recommended Mitigation Steps check the value of `bribesProcessor` in `_sendTokenToBribesProcessor()`  
