# Handle  shw   # Vulnerability details  ## Impact  Some methods declared in the interfaces are not implemented. Specifically, the `withdrawRepay` method of `ILendingPair` and the `liqFeePool` method of `Controller`.  ## Proof of Concept  Referenced code: [IController.sol#L14](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/interfaces/IController.sol#L14) [ILendingPair.sol#L22](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/interfaces/ILendingPair.sol#L22)  ## Recommended Mitigation Steps  Remove the unimplemented methods.  
# Handle  0xsanson   # Vulnerability details  ## Impact The line `return (rate < MIN_RATE) ? MIN_RATE : rate;` can be written as `return Math.max(rate, MIN_RATE);` for an easier reading, since the Math library is already imported.  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/InterestRateModel.sol#L37  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Rewrite using the Math.max function  
# Handle  0xsanson   # Vulnerability details  ## Impact Simple typo: totalAccountBorrrow instead of totalAccountBorrow  ## Proof of Concept In LendingPair.sol: ```     uint totalAccountBorrrow = _borrowBalance(_account, tokenA, tokenA) + _borrowBalance(_account, tokenB, tokenA);      return totalAccountSupply * 1e18 / totalAccountBorrrow; ```  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Correct the typo  
# Handle  0xsanson   # Vulnerability details  ## Impact The './interfaces/IInterestRateModel.sol' imported in LendingPair.sol isn't actually used and can be removed  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L13  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove the import line.  
# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The repayAll() and repayAllETH() functions allow any user to pay off debt of another user. Since all of the debt is going to be paid, no amount is specified, allowing the recipient of the repayment to frontrun the transaction to increase their debt. The risk of this issued was lowered as it depended on the user having enough tokens and allowance in the case of repayAll(), or having a msg.sender higher than the current debt in the case of repayAllEth().  ## Proof of Concept The affected lines are the following:  https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L147 https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156  The scenario for repayAll() is the following:  1. Alice pays off 5 of Bob's Dai debt using repayAll(). 2. Bob monitors the mempool for Alice's transaction, and front-runs it by taking out as much debt as Alice's allowance (and therefore balance) to the contract. 3. `debtOf[_token][_account]` now returns the higher amount and pays off Bob's new debt.   The scenario for repayAllEth() is similar:  1. Alice pays off 0.5 of Bob's Weth debt using repayAllEth(). 2. Bob monitors the mempool for Alice's transaction, and frontruns it by taking out as much debt as Alice's msg.value amount used. 3. `debtOf[address(WETH)][_account]` now returns the higher amount and pays off Bob's new debt.  ## Recommended Mitigation Steps This issue can be mitigated by enforcing a minimum time to hold debt - e.g. not allowed to repay debt for at least 6 blocks. Alternatively, the repay() function could be used to replace the 2 affected functions by passing in the _amount as the total debt (looked up off-chain and used in the dapp, for example) so that only up to a certain amount of debt is paid. This also means the repay() function would need to be made `payable`, and that the `msg.value` is validated to equal the _amount parameter.  
# Handle  cmichel   # Vulnerability details  The `LendingPair.pendingSupplyInterest` does not accrue the new interest since the last update.  ## Impact The returned value is not accurate.  ## Recommendation Accrue it first such that `cumulativeInterestRate` updates and `_newInterest` returns the updated value.  
# Handle  cmichel   # Vulnerability details  The `LendingPair.liquidateAccount` function tries to pay out underlying supply tokens to the liquidator using `_safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput)` but there's no reason why there should be enough `supplyOutput` amount in the contract, the contract only ensures `minReserve`.  ## Impact No liquidations can be performed if all tokens are lent out. Example: User A supplies 1k$ WETH, User B supplies 1.5k$ DAI and borrows the ~1k$ WETH (only leaves `minReserve`). The ETH price drops but user B cannot be liquidated as there's not enough WETH in the pool anymore to pay out the liquidator.  ## Recommendation Mint LP supply tokens to `msg.sender` instead, these are the LP supply tokens that were burnt from the borrower. This way the liquidator basically seizes the borrower's LP tokens.  
# Handle  cmichel   # Vulnerability details  The `LendingPair.liquidateAccount` function does not accrue and update the `cumulativeInterestRate` first, it only calls `_accrueAccountInterest` which does not update and instead uses the old `cumulativeInterestRate`.  ## Impact The liquidatee (borrower)'s state will not be up to date. I could skip some interest payments by liquidating myself instead of repaying if I'm under-water. As the market interest index is not accrued, the borrower does not need to pay any interest accrued from the time of the last accrual until now.  ## Recommendation It should call `accrueAccount` instead of `_accrueAccountInterest`   
# Handle  cmichel   # Vulnerability details  The `InterestRateModel.borrowRatePerBlock` function has a literal jump at target ratio and does not form a continuous function. Usually (as in Compound) it's a piece-wise continuous function with a linear function `f` on `[0%; TARGET%]` and a second linear function `g` on [`TARGET%; 100%]` where `f(TARGET) = g(TARGET)` and `g`'s slope is much higher than `f` to discourage further borrows.  Example: Assuming a `TARGET_UTILIZATION` of 80%, the `borrowRatePerBlock` for a utilisation ratio slightly less than `TARGET_UTILIZATION` (`if` branch) would be: `LOW_RATE * TARGET_UTILIZATION`. However, when borrowing **at** `TARGET_UTILIZATION` (`else` branch), the `borrowRatePerBlock` suddenly becomes `TARGET_UTILIZATION`, i.e., a `(1-LOW_RATE) * TARGET_UTILIZATION` increase.  This is because `debt - (supply * TARGET_UTILIZATION / 100e18) = 0` (as `debt * 100e18 / supply = TARGET_UTILIZATION`) and thus the inner `utilization = 0`.   ## Impact Borrowing a single wei more that pushes the utilization ratio to the `TARGET_UTILIZATION` (going from `if` to `else` branch)  leads to suddenly having to pay 20% (1 - target) more interest **on the overall debt position**.  ## Recommended Mitigation Steps I think the expected behavior for the `else` case should be something like `TARGET_UTILIZATION * LOW_RATE + (HIGH_RATE - TARGET_UTILIZATION * LOW_RATE) * utilization / 100e18` such that it's a continuous function at utiisation ratio of `TARGET_UTILIZATION`.  
# Handle  hrkrshnn   # Vulnerability details  ## Variables that can be converted into immutables  ``` txt Warning: Variable declaration can be converted into an immutable.   --> contracts/external/ERC20.sol:17:3:    | 17 |   uint8 public decimals;    |   ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:17:3:    | 17 |   uint MAX_INT = 2**256 - 1;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:22:3:    | 22 |   address public lendingPairMaster;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:23:3:    | 23 |   address public lpTokenMaster;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:24:3:    | 24 |   IController public controller;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:35:3:    | 35 |   IPairFactory public factory;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:36:3:    | 36 |   IController  public controller;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:37:3:    | 37 |   IERC20  public rewardToken;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ ```  Instead of the expensive `sload`, to read from storage, these would be transformed into a cheap `push value`, when the variables are converted into immutable.  ## Tools Used  A custom compiler.    
# Handle  JMukesh   # Vulnerability details  ## Impact Due to lack of zero address validation funds can be lost in following case  ex - No checking of address(0) in constructor        No checking of address(0) while using low-level call to transfer eth  ## Proof of Concept  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/TransferHelper.sol#L25  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L49  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/RewardDistribution.sol#L57  ## Tools Used manual review  ## Recommended Mitigation Steps  add zero address validation  
# Handle  JMukesh   # Vulnerability details  ## Impact  https://swcregistry.io/docs/SWC-103  ## Proof of Concept Most of  listed files uses floating pragma, some are  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/LPTokenMaster.sol#L6  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L3  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/InterestRateModel.sol#L6  ## Tools Used  manual review  ## Recommended Mitigation Steps use fixed solidity version  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Multiple contracts: Controller, LPTokenMaster, RewardDistribution and UniswapV3Oracle use onlyOwner authorized functions. Given that this is derived from Ownable, the ownership management of these contracts defaults to Ownable’s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the onlyOwner() functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing onlyOwner() function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.   ## Proof of Concept  See similar High Risk severity finding from Trail-of-Bits Audit of Hermez: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  See similar Medium Risk severity finding from Trail-of-Bits Audit of Uniswap V3: https://github.com/Uniswap/uniswap-v3-core/blob/main/audits/tob/audit.pdf  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/external/Ownable.sol#L25-L38  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L11  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/LPTokenMaster.sol#L12  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/RewardDistribution.sol#L17  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/UniswapV3Oracle.sol#L12  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Override the inherited methods to null functions and use separate functions for a two-step address change: 1) Approve a new address as a pendingOwner 2) A transaction from the pendingOwner address claims the pending ownership change. This mitigates risk because if an incorrect address is used in step (1) then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.  Also, consider adding a timelock delay for such sensitive actions. And at a minimum, use a multisig (with mutually independent and trustworthy owners) and not an EOA.  
# Handle  a_delamo   # Vulnerability details  ## Impact  `UniswapV3Oracle.sol` is calling `latestAnswer` to get the last WETH price. This method will return the last value, but you won't be able to check if the data is fresh. On the other hand, calling the method `latestRoundData` allow you to run some extra validations  ```        (           roundId,           rawPrice,           ,           updateTime,           answeredInRound         ) = AggregatorV3Interface(XXXXX).latestRoundData();         require(rawPrice > 0, "Chainlink price <= 0");         require(updateTime != 0, "Incomplete round");         require(answeredInRound >= roundId, "Stale price"); ```  More information:  https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  
# Handle  pauliax   # Vulnerability details  ## Impact function withdrawBorrowETH invokes _wethWithdrawTo and later _checkMinReserve, however, the check of reserve is not necessary here, as function _wethWithdrawTo also does that after transferring the ether. However, this reserve check might be bypassed as TransferHelper._wethWithdrawTo uses a low level call that is vulnerable to re-entrancy attacks. As this MIN_RESERVE sounds like an important value, you should consider preventing re-entrancy attacks here.   // Prevents division by zero and other undesirable behavior   uint public constant MIN_RESERVE = 1000;  ## Recommended Mitigation Steps Consider using re-entrancy guard on all main action functions (e.g. deposit, withdraw, borrow, repay, etc): https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol  
# Handle  pauliax   # Vulnerability details  ## Impact function setReward does not check if pid actually exists. Provided wrong _pair, _token and _isSupply params it will return a default value of 0, thus the first pool will be updated even though the caller may intended to update another pool. The risk is very low as this function can only be called by onlyOwner but I still think the code should prevent such scenarios from accidentally happening.  ## Recommended Mitigation Steps Check that pidByPairToken added value is true.  
# Handle  pauliax   # Vulnerability details  ## Impact Function addPool emits event PoolUpdate passing pools.length as pid while the actual pid is pools.length-1.  ## Recommended Mitigation Steps    emit PoolUpdate(pools.length-1, _pair, _token, _isSupply, _points); or even better store it in a temporary variable and re-use multiple times.  
# Handle  jonah1005   # Vulnerability details  ## Impact A non standard erc20 token would always raise error when calling `_safeTransferFrom`.  If a user creates a USDT/DAI pool and deposit into the pool he would find out there's never a counterpart deposit.  ## Proof of Concept  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/TransferHelper.sol#L19  TransferHelper does not uses `SafeERC20` library as the function name implies.   A sample POC: script: ``` usdt.functions.approve(lending_pair.address, deposit_amount).transact({'from': w3.eth.accounts[0]}) lending_pair.functions.deposit(w3.eth.accounts[0], usdt.address, deposit_amount).transact({'from': w3.eth.accounts[0]}) ```  Error Message: ```   Error: Transaction reverted: function returned an unexpected amount of data       at LendingPair._safeTransferFrom (contracts/TransferHelper.sol:20)       at LendingPair.deposit (contracts/LendingPair.sol:95) ``` ## Tools Used  Hardhat  ## Recommended Mitigation Steps Uses openzeppelin `SafeERC20` in transfer helper (and any other contract that uses IERC20).  
# Handle  greiart   # Vulnerability details  ## Impact  The `depositRepayETH()`, `withdrawBorrowETH()`, `withdrawAllETH()` and `repayAllETH()` fail to check if ETH is an asset of the lending pair (ie. if ETH is either tokenA or tokenB).  From manually tracing the `depositRepayETH()` function, attempts to call it will revert in `_mintSupply()` when `lpToken[_token].mint(_account, _amount);` is called, since the `lpToken` is only initialized for only tokenA and tokenB.  Nevertheless, it is recommended to perform token validation for the ETH methods as well, since it should be treated like other ERC20 tokens. It also helps to avoid wasting gas.  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L83](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L83)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L131](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L131)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156)  ## Recommended Mitigation Steps  Include `_validateToken()` in the equivalent ETH functions. An alternative suggestion is to drop the ETH methods (eg. combine `depositRepayETH()` into `depositRepay()` and doing a bit of refactoring to make native ETH deposits / withdrawals possible.  ```jsx // public constant ETH_ADDRESS = ''; // define a special constant address for ether != WETH address function depositRepay(address _account, address _token, uint _amount) external payable {     _validateTokenAndValue(_token, msg.value, _amount);     accrueAccount(_account);      _depositRepay(_account, _token, _amount);   _handleDeposit{value:msg.value}(_token, _amount); }  function _validateTokenAndValue(address _token, uint etherWei, uint amount) internal view {   address token;   if (_token == ETH_ADDRESS) {    token = WETH;    require(etherWei == amount, "LendingPair: invalid etherWei");   } else {    token = _token;    require(etherWei == 0, "LendingPair: invalid etherWei");   }     require(token == tokenA || token == tokenB, "LendingPair: invalid token"); }  function _handleDeposit(address _token, uint _amount) internal payable {  (_token == ETH_ADDRESS) ?    WETH.deposit{ value: msg.value }() :    _safeTransferFrom(_token, msg.sender, _amount); } ```  
# Handle  greiart   # Vulnerability details  ## Impact  The address casting of `_token` in `lpToken[address(_token)]` can be removed in the `withdrawAll()`, `_withdraw()` and `_borrow()` functions, since `_token` is already an address in these functions.   In other words, `lpToken[address(_token)]` *→* `lpToken[token]`  
# Handle  defsec   # Vulnerability details  ## Impact  There is occurrence in the code of the TransferHelper contract where amount is checked after the external call.  ## Proof of Concept  - Navigate to [TransferHelper.sol](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol) -  Amount is checked after an external call. [TransferHelper.sol amount check](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol#L22)  -  To favor readability and avoid confusions, consider applying check at the beginning of function.  ## Tools Used  None  ## Recommended Mitigation Steps  To favor readability and avoid confusions, consider applying check at the beginning of function.  ```sh   function _safeTransferFrom(address _token, address _sender, uint _amount) internal virtual {     require(_amount > 0, "TransferHelper: amount must be > 0");     ...   } ```  
# Handle  greiart   # Vulnerability details  ## Impact  Will help prevent erraneous `minObservations` values from being set (ie. `> 65535`) by the owner without needing checks. Otherwise, the `isPoolValid` will always return false, causing reverts in calling `tokenPrice` and `addPool` functions (and other functions calling these).  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L25](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L25)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L101](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L101)  ## Proof Of Concept  The maximum number of observations available is `65535` (see [https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Pool.sol#L39](https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Pool.sol#L39)), which is equivalent to `type(uint16).max`.  Hence,   - `uint public minObservations` can be reduced to `uint16 public minObservations`. - `(, , , , uint observationSlots , ,) = IUniswapV3Pool(poolAddress).slot0();` becomes `(, , , , uint16 observationSlots , ,) = IUniswapV3Pool(poolAddress).slot0();`  
# Handle  greiart   # Vulnerability details  ## Impact  No impact but personally, I think it's good practice to emit an event whenever you update the state of the contract via a setter function.  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L65-L75](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L65-L75)  
# Handle  greiart   # Vulnerability details  ## Impact  A repeated call to `pidByPairToken[_pair][_token][_isSupply]` can be avoided since it is stored in `poolPosition`. Simply return [poolPosition.pid](http://poolposition.pid).   ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L245-L250](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L245-L250)  ## Proof of Concept  ```jsx function _getPid(address _pair, address _token, bool _isSupply) internal view returns(uint) {     PoolPosition memory poolPosition = pidByPairToken[_pair][_token][_isSupply];     require(poolPosition.added, "RewardDistribution: invalid pool");      return poolPosition.pid; } ```  
# Handle  greiart   # Vulnerability details  ## Impact  It would be better to perform the allowance check before handling the token transfer. This is in line with the best practice of the CEI (checks-effects-interactions) pattern to avoid possible re-entrancy attacks.  [https://dev.to/mxmaster2s/quick-guide-to-the-checks-effect-interactions-pattern-to-remember-when-writing-your-smart-contracts-gfk](https://dev.to/mxmaster2s/quick-guide-to-the-checks-effect-interactions-pattern-to-remember-when-writing-your-smart-contracts-gfk)  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LPTokenMaster.sol#L42-L46](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LPTokenMaster.sol#L42-L46)  ## Recommended Mitigation Steps  ```jsx function transferFrom(address _sender, address _recipient, uint _amount) external returns (bool) {     _approve(_sender, msg.sender, allowance[_sender][msg.sender] - _amount);     _transfer(_sender, _recipient, _amount);     return true; } ```  
# Handle  gpersoon   # Vulnerability details  ## Impact   The functions _safeTransferFrom and _safeTransfer are similar but there is one difference: _safeTransferFrom reverts when _amount == 0 _safeTransfer  doesn't do any action when _amount == 0  I don't see any reason for the different behavior.  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol function _safeTransferFrom(address _token, address _sender, uint _amount) internal virtual {     bool success = IERC20(_token).transferFrom(_sender, address(this), _amount);     require(success, "TransferHelper: transfer failed");     require(_amount > 0, "TransferHelper: amount must be > 0");   }  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L468   function _safeTransfer(IERC20 _token, address _recipient, uint _amount) internal {     if (_amount > 0) {       bool success = _token.transfer(_recipient, _amount);       require(success, "LendingPair: transfer failed");       _checkMinReserve(address(_token));     }   }  ## Tools Used  ## Recommended Mitigation Steps Double check the difference and perhaps apply the same logic for amount==0 to both functions.  
# Handle  gpersoon   # Vulnerability details  ## Impact Some of the constructors set values that are never changed. See proof of concept. Its best to use the immutable keyword to make sure they aren't changed by accident.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L38 address public tokenA; address public tokenB;  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L37 IPairFactory public factory; IController  public controller; IERC20  public rewardToken;  ## Tools Used  ## Recommended Mitigation Steps Add the immutable keyword where possible   
# Handle  gpersoon   # Vulnerability details  ## Impact The function withdrawBorrowETH of the contract LendingPair calls _wethWithdrawTo and then calls _checkMinReserve. However _wethWithdrawTo also calls _checkMinReserve  (except when _amount but then not much happens anyway.  So the call to _checkMinReserve in withdrawBorrowETH is redundant and uses some extra gas.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106  function withdrawBorrowETH(uint _amount) external {    ..     _wethWithdrawTo(msg.sender, _amount);     _checkMinReserve(address(WETH)); // is also called in _wethWithdrawTo   }   function _wethWithdrawTo(address _to, uint _amount) internal override {     if (_amount > 0) {       TransferHelper._wethWithdrawTo(_to, _amount);       _checkMinReserve(address(WETH));     }   }  ## Tools Used  ## Recommended Mitigation Steps Consider removing the _checkMinReserve in withdrawBorrowETH Or consider moving the _checkMinReserve to all functions where _wethWithdrawTo is called  
# Handle  gpersoon   # Vulnerability details  ## Impact The parameter minBorrowUSD of the contract Controller isn't initialized. If someone is able to Borrow before the function setMinBorrowUSD is called, he might be able to borrow a very small amount. This might be unwanted.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L27   uint public minBorrowUSD;    function setMinBorrowUSD(uint _value) external onlyOwner {     minBorrowUSD = _value;   }  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L553 function _checkBorrowLimits(address _token, address _account) internal view {    ...     require(accountBorrowUSD >= controller.minBorrowUSD(), "LendingPair: borrow amount below minimum");   ## Tools Used  ## Recommended Mitigation Steps Initialize minBorrowUSD via the constructor or set a reasonable default in the contract.  
# Handle  gpersoon   # Vulnerability details  ## Impact Both the functions setLiqParamsToken and setLiqParamsDefault have a check to make sure that _liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES  However the constructor of Controller sets the same parameters and doesn't have this check. It seems logical to also do the check in the controller otherwise the parameters could be set outside of the wanted range.  ## Proof of Concept // https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L49 constructor( address _interestRateModel, uint _liqFeeSystemDefault, uint _liqFeeCallerDefault) {     ...     liqFeeSystemDefault = _liqFeeSystemDefault;     liqFeeCallerDefault = _liqFeeCallerDefault;  function setLiqParamsToken( address _token, uint    _liqFeeSystem, uint    _liqFeeCaller ) external onlyOwner {     require(_liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES, "Controller: fees too high"); ...     liqFeeSystemToken[_token] = _liqFeeSystem;     liqFeeCallerToken[_token] = _liqFeeCaller;  function setLiqParamsDefault( uint    _liqFeeSystem, uint    _liqFeeCaller) external onlyOwner {     require(_liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES, "Controller: fees too high");     liqFeeSystemDefault = _liqFeeSystem;     liqFeeCallerDefault = _liqFeeCaller;  ## Tools Used  ## Recommended Mitigation Steps Add something like the following in the constructor of Controller  require(liqFeeCallerDefault + liqFeeSystemDefault <= MAX_LIQ_FEES, "Controller: fees too high");  
# Handle  defsec   # Vulnerability details  ## Impact  Without Event, it is difficult to identify in real-time whether correct values are recorded on the blockchain. In this case, it becomes problematic to determine whether the corresponding value has been changed in the application and whether the corresponding function has been called. setMinBorrowUSD function is missing event.  ## Proof of Concept  1. Go to following the function [setMinBorrowUSD Function](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L137) 2. There is missing event definition on the function.   ## Tools Used  None  ## Recommended Mitigation Steps  Add Event corresponding to the change occurring in the function.  <code>Add `emit NewMinBorrowUSD(_value);`</code>  
# Handle  shw   # Vulnerability details  ## Impact  Some methods declared in the interfaces are not implemented. Specifically, the `withdrawRepay` method of `ILendingPair` and the `liqFeePool` method of `Controller`.  ## Proof of Concept  Referenced code: [IController.sol#L14](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/interfaces/IController.sol#L14) [ILendingPair.sol#L22](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/interfaces/ILendingPair.sol#L22)  ## Recommended Mitigation Steps  Remove the unimplemented methods.  
# Handle  0xsanson   # Vulnerability details  ## Impact The line `return (rate < MIN_RATE) ? MIN_RATE : rate;` can be written as `return Math.max(rate, MIN_RATE);` for an easier reading, since the Math library is already imported.  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/InterestRateModel.sol#L37  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Rewrite using the Math.max function  
# Handle  0xsanson   # Vulnerability details  ## Impact Simple typo: totalAccountBorrrow instead of totalAccountBorrow  ## Proof of Concept In LendingPair.sol: ```     uint totalAccountBorrrow = _borrowBalance(_account, tokenA, tokenA) + _borrowBalance(_account, tokenB, tokenA);      return totalAccountSupply * 1e18 / totalAccountBorrrow; ```  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Correct the typo  
# Handle  0xsanson   # Vulnerability details  ## Impact The './interfaces/IInterestRateModel.sol' imported in LendingPair.sol isn't actually used and can be removed  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L13  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove the import line.  
# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The repayAll() and repayAllETH() functions allow any user to pay off debt of another user. Since all of the debt is going to be paid, no amount is specified, allowing the recipient of the repayment to frontrun the transaction to increase their debt. The risk of this issued was lowered as it depended on the user having enough tokens and allowance in the case of repayAll(), or having a msg.sender higher than the current debt in the case of repayAllEth().  ## Proof of Concept The affected lines are the following:  https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L147 https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156  The scenario for repayAll() is the following:  1. Alice pays off 5 of Bob's Dai debt using repayAll(). 2. Bob monitors the mempool for Alice's transaction, and front-runs it by taking out as much debt as Alice's allowance (and therefore balance) to the contract. 3. `debtOf[_token][_account]` now returns the higher amount and pays off Bob's new debt.   The scenario for repayAllEth() is similar:  1. Alice pays off 0.5 of Bob's Weth debt using repayAllEth(). 2. Bob monitors the mempool for Alice's transaction, and frontruns it by taking out as much debt as Alice's msg.value amount used. 3. `debtOf[address(WETH)][_account]` now returns the higher amount and pays off Bob's new debt.  ## Recommended Mitigation Steps This issue can be mitigated by enforcing a minimum time to hold debt - e.g. not allowed to repay debt for at least 6 blocks. Alternatively, the repay() function could be used to replace the 2 affected functions by passing in the _amount as the total debt (looked up off-chain and used in the dapp, for example) so that only up to a certain amount of debt is paid. This also means the repay() function would need to be made `payable`, and that the `msg.value` is validated to equal the _amount parameter.  
# Handle  cmichel   # Vulnerability details  The `LendingPair.pendingSupplyInterest` does not accrue the new interest since the last update.  ## Impact The returned value is not accurate.  ## Recommendation Accrue it first such that `cumulativeInterestRate` updates and `_newInterest` returns the updated value.  
# Handle  cmichel   # Vulnerability details  The `LendingPair.liquidateAccount` function tries to pay out underlying supply tokens to the liquidator using `_safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput)` but there's no reason why there should be enough `supplyOutput` amount in the contract, the contract only ensures `minReserve`.  ## Impact No liquidations can be performed if all tokens are lent out. Example: User A supplies 1k$ WETH, User B supplies 1.5k$ DAI and borrows the ~1k$ WETH (only leaves `minReserve`). The ETH price drops but user B cannot be liquidated as there's not enough WETH in the pool anymore to pay out the liquidator.  ## Recommendation Mint LP supply tokens to `msg.sender` instead, these are the LP supply tokens that were burnt from the borrower. This way the liquidator basically seizes the borrower's LP tokens.  
# Handle  cmichel   # Vulnerability details  The `LendingPair.liquidateAccount` function does not accrue and update the `cumulativeInterestRate` first, it only calls `_accrueAccountInterest` which does not update and instead uses the old `cumulativeInterestRate`.  ## Impact The liquidatee (borrower)'s state will not be up to date. I could skip some interest payments by liquidating myself instead of repaying if I'm under-water. As the market interest index is not accrued, the borrower does not need to pay any interest accrued from the time of the last accrual until now.  ## Recommendation It should call `accrueAccount` instead of `_accrueAccountInterest`   
# Handle  cmichel   # Vulnerability details  The `InterestRateModel.borrowRatePerBlock` function has a literal jump at target ratio and does not form a continuous function. Usually (as in Compound) it's a piece-wise continuous function with a linear function `f` on `[0%; TARGET%]` and a second linear function `g` on [`TARGET%; 100%]` where `f(TARGET) = g(TARGET)` and `g`'s slope is much higher than `f` to discourage further borrows.  Example: Assuming a `TARGET_UTILIZATION` of 80%, the `borrowRatePerBlock` for a utilisation ratio slightly less than `TARGET_UTILIZATION` (`if` branch) would be: `LOW_RATE * TARGET_UTILIZATION`. However, when borrowing **at** `TARGET_UTILIZATION` (`else` branch), the `borrowRatePerBlock` suddenly becomes `TARGET_UTILIZATION`, i.e., a `(1-LOW_RATE) * TARGET_UTILIZATION` increase.  This is because `debt - (supply * TARGET_UTILIZATION / 100e18) = 0` (as `debt * 100e18 / supply = TARGET_UTILIZATION`) and thus the inner `utilization = 0`.   ## Impact Borrowing a single wei more that pushes the utilization ratio to the `TARGET_UTILIZATION` (going from `if` to `else` branch)  leads to suddenly having to pay 20% (1 - target) more interest **on the overall debt position**.  ## Recommended Mitigation Steps I think the expected behavior for the `else` case should be something like `TARGET_UTILIZATION * LOW_RATE + (HIGH_RATE - TARGET_UTILIZATION * LOW_RATE) * utilization / 100e18` such that it's a continuous function at utiisation ratio of `TARGET_UTILIZATION`.  
# Handle  hrkrshnn   # Vulnerability details  ## Variables that can be converted into immutables  ``` txt Warning: Variable declaration can be converted into an immutable.   --> contracts/external/ERC20.sol:17:3:    | 17 |   uint8 public decimals;    |   ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:17:3:    | 17 |   uint MAX_INT = 2**256 - 1;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:22:3:    | 22 |   address public lendingPairMaster;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:23:3:    | 23 |   address public lpTokenMaster;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:24:3:    | 24 |   IController public controller;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:35:3:    | 35 |   IPairFactory public factory;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:36:3:    | 36 |   IController  public controller;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:37:3:    | 37 |   IERC20  public rewardToken;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ ```  Instead of the expensive `sload`, to read from storage, these would be transformed into a cheap `push value`, when the variables are converted into immutable.  ## Tools Used  A custom compiler.    
# Handle  JMukesh   # Vulnerability details  ## Impact Due to lack of zero address validation funds can be lost in following case  ex - No checking of address(0) in constructor        No checking of address(0) while using low-level call to transfer eth  ## Proof of Concept  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/TransferHelper.sol#L25  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L49  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/RewardDistribution.sol#L57  ## Tools Used manual review  ## Recommended Mitigation Steps  add zero address validation  
# Handle  JMukesh   # Vulnerability details  ## Impact  https://swcregistry.io/docs/SWC-103  ## Proof of Concept Most of  listed files uses floating pragma, some are  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/LPTokenMaster.sol#L6  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L3  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/InterestRateModel.sol#L6  ## Tools Used  manual review  ## Recommended Mitigation Steps use fixed solidity version  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Multiple contracts: Controller, LPTokenMaster, RewardDistribution and UniswapV3Oracle use onlyOwner authorized functions. Given that this is derived from Ownable, the ownership management of these contracts defaults to Ownable’s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the onlyOwner() functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing onlyOwner() function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.   ## Proof of Concept  See similar High Risk severity finding from Trail-of-Bits Audit of Hermez: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  See similar Medium Risk severity finding from Trail-of-Bits Audit of Uniswap V3: https://github.com/Uniswap/uniswap-v3-core/blob/main/audits/tob/audit.pdf  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/external/Ownable.sol#L25-L38  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L11  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/LPTokenMaster.sol#L12  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/RewardDistribution.sol#L17  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/UniswapV3Oracle.sol#L12  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Override the inherited methods to null functions and use separate functions for a two-step address change: 1) Approve a new address as a pendingOwner 2) A transaction from the pendingOwner address claims the pending ownership change. This mitigates risk because if an incorrect address is used in step (1) then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.  Also, consider adding a timelock delay for such sensitive actions. And at a minimum, use a multisig (with mutually independent and trustworthy owners) and not an EOA.  
# Handle  a_delamo   # Vulnerability details  ## Impact  `UniswapV3Oracle.sol` is calling `latestAnswer` to get the last WETH price. This method will return the last value, but you won't be able to check if the data is fresh. On the other hand, calling the method `latestRoundData` allow you to run some extra validations  ```        (           roundId,           rawPrice,           ,           updateTime,           answeredInRound         ) = AggregatorV3Interface(XXXXX).latestRoundData();         require(rawPrice > 0, "Chainlink price <= 0");         require(updateTime != 0, "Incomplete round");         require(answeredInRound >= roundId, "Stale price"); ```  More information:  https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  
# Handle  pauliax   # Vulnerability details  ## Impact function withdrawBorrowETH invokes _wethWithdrawTo and later _checkMinReserve, however, the check of reserve is not necessary here, as function _wethWithdrawTo also does that after transferring the ether. However, this reserve check might be bypassed as TransferHelper._wethWithdrawTo uses a low level call that is vulnerable to re-entrancy attacks. As this MIN_RESERVE sounds like an important value, you should consider preventing re-entrancy attacks here.   // Prevents division by zero and other undesirable behavior   uint public constant MIN_RESERVE = 1000;  ## Recommended Mitigation Steps Consider using re-entrancy guard on all main action functions (e.g. deposit, withdraw, borrow, repay, etc): https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol  
# Handle  pauliax   # Vulnerability details  ## Impact function setReward does not check if pid actually exists. Provided wrong _pair, _token and _isSupply params it will return a default value of 0, thus the first pool will be updated even though the caller may intended to update another pool. The risk is very low as this function can only be called by onlyOwner but I still think the code should prevent such scenarios from accidentally happening.  ## Recommended Mitigation Steps Check that pidByPairToken added value is true.  
# Handle  pauliax   # Vulnerability details  ## Impact Function addPool emits event PoolUpdate passing pools.length as pid while the actual pid is pools.length-1.  ## Recommended Mitigation Steps    emit PoolUpdate(pools.length-1, _pair, _token, _isSupply, _points); or even better store it in a temporary variable and re-use multiple times.  
# Handle  jonah1005   # Vulnerability details  ## Impact A non standard erc20 token would always raise error when calling `_safeTransferFrom`.  If a user creates a USDT/DAI pool and deposit into the pool he would find out there's never a counterpart deposit.  ## Proof of Concept  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/TransferHelper.sol#L19  TransferHelper does not uses `SafeERC20` library as the function name implies.   A sample POC: script: ``` usdt.functions.approve(lending_pair.address, deposit_amount).transact({'from': w3.eth.accounts[0]}) lending_pair.functions.deposit(w3.eth.accounts[0], usdt.address, deposit_amount).transact({'from': w3.eth.accounts[0]}) ```  Error Message: ```   Error: Transaction reverted: function returned an unexpected amount of data       at LendingPair._safeTransferFrom (contracts/TransferHelper.sol:20)       at LendingPair.deposit (contracts/LendingPair.sol:95) ``` ## Tools Used  Hardhat  ## Recommended Mitigation Steps Uses openzeppelin `SafeERC20` in transfer helper (and any other contract that uses IERC20).  
# Handle  greiart   # Vulnerability details  ## Impact  The `depositRepayETH()`, `withdrawBorrowETH()`, `withdrawAllETH()` and `repayAllETH()` fail to check if ETH is an asset of the lending pair (ie. if ETH is either tokenA or tokenB).  From manually tracing the `depositRepayETH()` function, attempts to call it will revert in `_mintSupply()` when `lpToken[_token].mint(_account, _amount);` is called, since the `lpToken` is only initialized for only tokenA and tokenB.  Nevertheless, it is recommended to perform token validation for the ETH methods as well, since it should be treated like other ERC20 tokens. It also helps to avoid wasting gas.  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L83](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L83)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L131](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L131)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156)  ## Recommended Mitigation Steps  Include `_validateToken()` in the equivalent ETH functions. An alternative suggestion is to drop the ETH methods (eg. combine `depositRepayETH()` into `depositRepay()` and doing a bit of refactoring to make native ETH deposits / withdrawals possible.  ```jsx // public constant ETH_ADDRESS = ''; // define a special constant address for ether != WETH address function depositRepay(address _account, address _token, uint _amount) external payable {     _validateTokenAndValue(_token, msg.value, _amount);     accrueAccount(_account);      _depositRepay(_account, _token, _amount);   _handleDeposit{value:msg.value}(_token, _amount); }  function _validateTokenAndValue(address _token, uint etherWei, uint amount) internal view {   address token;   if (_token == ETH_ADDRESS) {    token = WETH;    require(etherWei == amount, "LendingPair: invalid etherWei");   } else {    token = _token;    require(etherWei == 0, "LendingPair: invalid etherWei");   }     require(token == tokenA || token == tokenB, "LendingPair: invalid token"); }  function _handleDeposit(address _token, uint _amount) internal payable {  (_token == ETH_ADDRESS) ?    WETH.deposit{ value: msg.value }() :    _safeTransferFrom(_token, msg.sender, _amount); } ```  
# Handle  greiart   # Vulnerability details  ## Impact  The address casting of `_token` in `lpToken[address(_token)]` can be removed in the `withdrawAll()`, `_withdraw()` and `_borrow()` functions, since `_token` is already an address in these functions.   In other words, `lpToken[address(_token)]` *→* `lpToken[token]`  
# Handle  defsec   # Vulnerability details  ## Impact  There is occurrence in the code of the TransferHelper contract where amount is checked after the external call.  ## Proof of Concept  - Navigate to [TransferHelper.sol](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol) -  Amount is checked after an external call. [TransferHelper.sol amount check](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol#L22)  -  To favor readability and avoid confusions, consider applying check at the beginning of function.  ## Tools Used  None  ## Recommended Mitigation Steps  To favor readability and avoid confusions, consider applying check at the beginning of function.  ```sh   function _safeTransferFrom(address _token, address _sender, uint _amount) internal virtual {     require(_amount > 0, "TransferHelper: amount must be > 0");     ...   } ```  
# Handle  greiart   # Vulnerability details  ## Impact  Will help prevent erraneous `minObservations` values from being set (ie. `> 65535`) by the owner without needing checks. Otherwise, the `isPoolValid` will always return false, causing reverts in calling `tokenPrice` and `addPool` functions (and other functions calling these).  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L25](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L25)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L101](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L101)  ## Proof Of Concept  The maximum number of observations available is `65535` (see [https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Pool.sol#L39](https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Pool.sol#L39)), which is equivalent to `type(uint16).max`.  Hence,   - `uint public minObservations` can be reduced to `uint16 public minObservations`. - `(, , , , uint observationSlots , ,) = IUniswapV3Pool(poolAddress).slot0();` becomes `(, , , , uint16 observationSlots , ,) = IUniswapV3Pool(poolAddress).slot0();`  
# Handle  greiart   # Vulnerability details  ## Impact  No impact but personally, I think it's good practice to emit an event whenever you update the state of the contract via a setter function.  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L65-L75](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L65-L75)  
# Handle  greiart   # Vulnerability details  ## Impact  A repeated call to `pidByPairToken[_pair][_token][_isSupply]` can be avoided since it is stored in `poolPosition`. Simply return [poolPosition.pid](http://poolposition.pid).   ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L245-L250](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L245-L250)  ## Proof of Concept  ```jsx function _getPid(address _pair, address _token, bool _isSupply) internal view returns(uint) {     PoolPosition memory poolPosition = pidByPairToken[_pair][_token][_isSupply];     require(poolPosition.added, "RewardDistribution: invalid pool");      return poolPosition.pid; } ```  
# Handle  greiart   # Vulnerability details  ## Impact  It would be better to perform the allowance check before handling the token transfer. This is in line with the best practice of the CEI (checks-effects-interactions) pattern to avoid possible re-entrancy attacks.  [https://dev.to/mxmaster2s/quick-guide-to-the-checks-effect-interactions-pattern-to-remember-when-writing-your-smart-contracts-gfk](https://dev.to/mxmaster2s/quick-guide-to-the-checks-effect-interactions-pattern-to-remember-when-writing-your-smart-contracts-gfk)  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LPTokenMaster.sol#L42-L46](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LPTokenMaster.sol#L42-L46)  ## Recommended Mitigation Steps  ```jsx function transferFrom(address _sender, address _recipient, uint _amount) external returns (bool) {     _approve(_sender, msg.sender, allowance[_sender][msg.sender] - _amount);     _transfer(_sender, _recipient, _amount);     return true; } ```  
# Handle  gpersoon   # Vulnerability details  ## Impact   The functions _safeTransferFrom and _safeTransfer are similar but there is one difference: _safeTransferFrom reverts when _amount == 0 _safeTransfer  doesn't do any action when _amount == 0  I don't see any reason for the different behavior.  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol function _safeTransferFrom(address _token, address _sender, uint _amount) internal virtual {     bool success = IERC20(_token).transferFrom(_sender, address(this), _amount);     require(success, "TransferHelper: transfer failed");     require(_amount > 0, "TransferHelper: amount must be > 0");   }  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L468   function _safeTransfer(IERC20 _token, address _recipient, uint _amount) internal {     if (_amount > 0) {       bool success = _token.transfer(_recipient, _amount);       require(success, "LendingPair: transfer failed");       _checkMinReserve(address(_token));     }   }  ## Tools Used  ## Recommended Mitigation Steps Double check the difference and perhaps apply the same logic for amount==0 to both functions.  
# Handle  gpersoon   # Vulnerability details  ## Impact Some of the constructors set values that are never changed. See proof of concept. Its best to use the immutable keyword to make sure they aren't changed by accident.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L38 address public tokenA; address public tokenB;  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L37 IPairFactory public factory; IController  public controller; IERC20  public rewardToken;  ## Tools Used  ## Recommended Mitigation Steps Add the immutable keyword where possible   
# Handle  gpersoon   # Vulnerability details  ## Impact The function withdrawBorrowETH of the contract LendingPair calls _wethWithdrawTo and then calls _checkMinReserve. However _wethWithdrawTo also calls _checkMinReserve  (except when _amount but then not much happens anyway.  So the call to _checkMinReserve in withdrawBorrowETH is redundant and uses some extra gas.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106  function withdrawBorrowETH(uint _amount) external {    ..     _wethWithdrawTo(msg.sender, _amount);     _checkMinReserve(address(WETH)); // is also called in _wethWithdrawTo   }   function _wethWithdrawTo(address _to, uint _amount) internal override {     if (_amount > 0) {       TransferHelper._wethWithdrawTo(_to, _amount);       _checkMinReserve(address(WETH));     }   }  ## Tools Used  ## Recommended Mitigation Steps Consider removing the _checkMinReserve in withdrawBorrowETH Or consider moving the _checkMinReserve to all functions where _wethWithdrawTo is called  
# Handle  gpersoon   # Vulnerability details  ## Impact The parameter minBorrowUSD of the contract Controller isn't initialized. If someone is able to Borrow before the function setMinBorrowUSD is called, he might be able to borrow a very small amount. This might be unwanted.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L27   uint public minBorrowUSD;    function setMinBorrowUSD(uint _value) external onlyOwner {     minBorrowUSD = _value;   }  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L553 function _checkBorrowLimits(address _token, address _account) internal view {    ...     require(accountBorrowUSD >= controller.minBorrowUSD(), "LendingPair: borrow amount below minimum");   ## Tools Used  ## Recommended Mitigation Steps Initialize minBorrowUSD via the constructor or set a reasonable default in the contract.  
# Handle  gpersoon   # Vulnerability details  ## Impact Both the functions setLiqParamsToken and setLiqParamsDefault have a check to make sure that _liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES  However the constructor of Controller sets the same parameters and doesn't have this check. It seems logical to also do the check in the controller otherwise the parameters could be set outside of the wanted range.  ## Proof of Concept // https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L49 constructor( address _interestRateModel, uint _liqFeeSystemDefault, uint _liqFeeCallerDefault) {     ...     liqFeeSystemDefault = _liqFeeSystemDefault;     liqFeeCallerDefault = _liqFeeCallerDefault;  function setLiqParamsToken( address _token, uint    _liqFeeSystem, uint    _liqFeeCaller ) external onlyOwner {     require(_liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES, "Controller: fees too high"); ...     liqFeeSystemToken[_token] = _liqFeeSystem;     liqFeeCallerToken[_token] = _liqFeeCaller;  function setLiqParamsDefault( uint    _liqFeeSystem, uint    _liqFeeCaller) external onlyOwner {     require(_liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES, "Controller: fees too high");     liqFeeSystemDefault = _liqFeeSystem;     liqFeeCallerDefault = _liqFeeCaller;  ## Tools Used  ## Recommended Mitigation Steps Add something like the following in the constructor of Controller  require(liqFeeCallerDefault + liqFeeSystemDefault <= MAX_LIQ_FEES, "Controller: fees too high");  
# Handle  defsec   # Vulnerability details  ## Impact  Without Event, it is difficult to identify in real-time whether correct values are recorded on the blockchain. In this case, it becomes problematic to determine whether the corresponding value has been changed in the application and whether the corresponding function has been called. setMinBorrowUSD function is missing event.  ## Proof of Concept  1. Go to following the function [setMinBorrowUSD Function](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L137) 2. There is missing event definition on the function.   ## Tools Used  None  ## Recommended Mitigation Steps  Add Event corresponding to the change occurring in the function.  <code>Add `emit NewMinBorrowUSD(_value);`</code>  
# Handle  shw   # Vulnerability details  ## Impact  Some methods declared in the interfaces are not implemented. Specifically, the `withdrawRepay` method of `ILendingPair` and the `liqFeePool` method of `Controller`.  ## Proof of Concept  Referenced code: [IController.sol#L14](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/interfaces/IController.sol#L14) [ILendingPair.sol#L22](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/interfaces/ILendingPair.sol#L22)  ## Recommended Mitigation Steps  Remove the unimplemented methods.  
# Handle  0xsanson   # Vulnerability details  ## Impact The line `return (rate < MIN_RATE) ? MIN_RATE : rate;` can be written as `return Math.max(rate, MIN_RATE);` for an easier reading, since the Math library is already imported.  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/InterestRateModel.sol#L37  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Rewrite using the Math.max function  
# Handle  0xsanson   # Vulnerability details  ## Impact Simple typo: totalAccountBorrrow instead of totalAccountBorrow  ## Proof of Concept In LendingPair.sol: ```     uint totalAccountBorrrow = _borrowBalance(_account, tokenA, tokenA) + _borrowBalance(_account, tokenB, tokenA);      return totalAccountSupply * 1e18 / totalAccountBorrrow; ```  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Correct the typo  
# Handle  0xsanson   # Vulnerability details  ## Impact The './interfaces/IInterestRateModel.sol' imported in LendingPair.sol isn't actually used and can be removed  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L13  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove the import line.  
# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The repayAll() and repayAllETH() functions allow any user to pay off debt of another user. Since all of the debt is going to be paid, no amount is specified, allowing the recipient of the repayment to frontrun the transaction to increase their debt. The risk of this issued was lowered as it depended on the user having enough tokens and allowance in the case of repayAll(), or having a msg.sender higher than the current debt in the case of repayAllEth().  ## Proof of Concept The affected lines are the following:  https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L147 https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156  The scenario for repayAll() is the following:  1. Alice pays off 5 of Bob's Dai debt using repayAll(). 2. Bob monitors the mempool for Alice's transaction, and front-runs it by taking out as much debt as Alice's allowance (and therefore balance) to the contract. 3. `debtOf[_token][_account]` now returns the higher amount and pays off Bob's new debt.   The scenario for repayAllEth() is similar:  1. Alice pays off 0.5 of Bob's Weth debt using repayAllEth(). 2. Bob monitors the mempool for Alice's transaction, and frontruns it by taking out as much debt as Alice's msg.value amount used. 3. `debtOf[address(WETH)][_account]` now returns the higher amount and pays off Bob's new debt.  ## Recommended Mitigation Steps This issue can be mitigated by enforcing a minimum time to hold debt - e.g. not allowed to repay debt for at least 6 blocks. Alternatively, the repay() function could be used to replace the 2 affected functions by passing in the _amount as the total debt (looked up off-chain and used in the dapp, for example) so that only up to a certain amount of debt is paid. This also means the repay() function would need to be made `payable`, and that the `msg.value` is validated to equal the _amount parameter.  
# Handle  cmichel   # Vulnerability details  The `LendingPair.pendingSupplyInterest` does not accrue the new interest since the last update.  ## Impact The returned value is not accurate.  ## Recommendation Accrue it first such that `cumulativeInterestRate` updates and `_newInterest` returns the updated value.  
# Handle  cmichel   # Vulnerability details  The `LendingPair.liquidateAccount` function tries to pay out underlying supply tokens to the liquidator using `_safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput)` but there's no reason why there should be enough `supplyOutput` amount in the contract, the contract only ensures `minReserve`.  ## Impact No liquidations can be performed if all tokens are lent out. Example: User A supplies 1k$ WETH, User B supplies 1.5k$ DAI and borrows the ~1k$ WETH (only leaves `minReserve`). The ETH price drops but user B cannot be liquidated as there's not enough WETH in the pool anymore to pay out the liquidator.  ## Recommendation Mint LP supply tokens to `msg.sender` instead, these are the LP supply tokens that were burnt from the borrower. This way the liquidator basically seizes the borrower's LP tokens.  
# Handle  cmichel   # Vulnerability details  The `LendingPair.liquidateAccount` function does not accrue and update the `cumulativeInterestRate` first, it only calls `_accrueAccountInterest` which does not update and instead uses the old `cumulativeInterestRate`.  ## Impact The liquidatee (borrower)'s state will not be up to date. I could skip some interest payments by liquidating myself instead of repaying if I'm under-water. As the market interest index is not accrued, the borrower does not need to pay any interest accrued from the time of the last accrual until now.  ## Recommendation It should call `accrueAccount` instead of `_accrueAccountInterest`   
# Handle  cmichel   # Vulnerability details  The `InterestRateModel.borrowRatePerBlock` function has a literal jump at target ratio and does not form a continuous function. Usually (as in Compound) it's a piece-wise continuous function with a linear function `f` on `[0%; TARGET%]` and a second linear function `g` on [`TARGET%; 100%]` where `f(TARGET) = g(TARGET)` and `g`'s slope is much higher than `f` to discourage further borrows.  Example: Assuming a `TARGET_UTILIZATION` of 80%, the `borrowRatePerBlock` for a utilisation ratio slightly less than `TARGET_UTILIZATION` (`if` branch) would be: `LOW_RATE * TARGET_UTILIZATION`. However, when borrowing **at** `TARGET_UTILIZATION` (`else` branch), the `borrowRatePerBlock` suddenly becomes `TARGET_UTILIZATION`, i.e., a `(1-LOW_RATE) * TARGET_UTILIZATION` increase.  This is because `debt - (supply * TARGET_UTILIZATION / 100e18) = 0` (as `debt * 100e18 / supply = TARGET_UTILIZATION`) and thus the inner `utilization = 0`.   ## Impact Borrowing a single wei more that pushes the utilization ratio to the `TARGET_UTILIZATION` (going from `if` to `else` branch)  leads to suddenly having to pay 20% (1 - target) more interest **on the overall debt position**.  ## Recommended Mitigation Steps I think the expected behavior for the `else` case should be something like `TARGET_UTILIZATION * LOW_RATE + (HIGH_RATE - TARGET_UTILIZATION * LOW_RATE) * utilization / 100e18` such that it's a continuous function at utiisation ratio of `TARGET_UTILIZATION`.  
# Handle  hrkrshnn   # Vulnerability details  ## Variables that can be converted into immutables  ``` txt Warning: Variable declaration can be converted into an immutable.   --> contracts/external/ERC20.sol:17:3:    | 17 |   uint8 public decimals;    |   ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:17:3:    | 17 |   uint MAX_INT = 2**256 - 1;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:22:3:    | 22 |   address public lendingPairMaster;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:23:3:    | 23 |   address public lpTokenMaster;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:24:3:    | 24 |   IController public controller;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:35:3:    | 35 |   IPairFactory public factory;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:36:3:    | 36 |   IController  public controller;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:37:3:    | 37 |   IERC20  public rewardToken;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ ```  Instead of the expensive `sload`, to read from storage, these would be transformed into a cheap `push value`, when the variables are converted into immutable.  ## Tools Used  A custom compiler.    
# Handle  JMukesh   # Vulnerability details  ## Impact Due to lack of zero address validation funds can be lost in following case  ex - No checking of address(0) in constructor        No checking of address(0) while using low-level call to transfer eth  ## Proof of Concept  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/TransferHelper.sol#L25  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L49  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/RewardDistribution.sol#L57  ## Tools Used manual review  ## Recommended Mitigation Steps  add zero address validation  
# Handle  JMukesh   # Vulnerability details  ## Impact  https://swcregistry.io/docs/SWC-103  ## Proof of Concept Most of  listed files uses floating pragma, some are  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/LPTokenMaster.sol#L6  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L3  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/InterestRateModel.sol#L6  ## Tools Used  manual review  ## Recommended Mitigation Steps use fixed solidity version  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Multiple contracts: Controller, LPTokenMaster, RewardDistribution and UniswapV3Oracle use onlyOwner authorized functions. Given that this is derived from Ownable, the ownership management of these contracts defaults to Ownable’s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the onlyOwner() functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing onlyOwner() function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.   ## Proof of Concept  See similar High Risk severity finding from Trail-of-Bits Audit of Hermez: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  See similar Medium Risk severity finding from Trail-of-Bits Audit of Uniswap V3: https://github.com/Uniswap/uniswap-v3-core/blob/main/audits/tob/audit.pdf  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/external/Ownable.sol#L25-L38  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L11  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/LPTokenMaster.sol#L12  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/RewardDistribution.sol#L17  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/UniswapV3Oracle.sol#L12  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Override the inherited methods to null functions and use separate functions for a two-step address change: 1) Approve a new address as a pendingOwner 2) A transaction from the pendingOwner address claims the pending ownership change. This mitigates risk because if an incorrect address is used in step (1) then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.  Also, consider adding a timelock delay for such sensitive actions. And at a minimum, use a multisig (with mutually independent and trustworthy owners) and not an EOA.  
# Handle  a_delamo   # Vulnerability details  ## Impact  `UniswapV3Oracle.sol` is calling `latestAnswer` to get the last WETH price. This method will return the last value, but you won't be able to check if the data is fresh. On the other hand, calling the method `latestRoundData` allow you to run some extra validations  ```        (           roundId,           rawPrice,           ,           updateTime,           answeredInRound         ) = AggregatorV3Interface(XXXXX).latestRoundData();         require(rawPrice > 0, "Chainlink price <= 0");         require(updateTime != 0, "Incomplete round");         require(answeredInRound >= roundId, "Stale price"); ```  More information:  https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  
# Handle  pauliax   # Vulnerability details  ## Impact function withdrawBorrowETH invokes _wethWithdrawTo and later _checkMinReserve, however, the check of reserve is not necessary here, as function _wethWithdrawTo also does that after transferring the ether. However, this reserve check might be bypassed as TransferHelper._wethWithdrawTo uses a low level call that is vulnerable to re-entrancy attacks. As this MIN_RESERVE sounds like an important value, you should consider preventing re-entrancy attacks here.   // Prevents division by zero and other undesirable behavior   uint public constant MIN_RESERVE = 1000;  ## Recommended Mitigation Steps Consider using re-entrancy guard on all main action functions (e.g. deposit, withdraw, borrow, repay, etc): https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol  
# Handle  pauliax   # Vulnerability details  ## Impact function setReward does not check if pid actually exists. Provided wrong _pair, _token and _isSupply params it will return a default value of 0, thus the first pool will be updated even though the caller may intended to update another pool. The risk is very low as this function can only be called by onlyOwner but I still think the code should prevent such scenarios from accidentally happening.  ## Recommended Mitigation Steps Check that pidByPairToken added value is true.  
# Handle  pauliax   # Vulnerability details  ## Impact Function addPool emits event PoolUpdate passing pools.length as pid while the actual pid is pools.length-1.  ## Recommended Mitigation Steps    emit PoolUpdate(pools.length-1, _pair, _token, _isSupply, _points); or even better store it in a temporary variable and re-use multiple times.  
# Handle  jonah1005   # Vulnerability details  ## Impact A non standard erc20 token would always raise error when calling `_safeTransferFrom`.  If a user creates a USDT/DAI pool and deposit into the pool he would find out there's never a counterpart deposit.  ## Proof of Concept  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/TransferHelper.sol#L19  TransferHelper does not uses `SafeERC20` library as the function name implies.   A sample POC: script: ``` usdt.functions.approve(lending_pair.address, deposit_amount).transact({'from': w3.eth.accounts[0]}) lending_pair.functions.deposit(w3.eth.accounts[0], usdt.address, deposit_amount).transact({'from': w3.eth.accounts[0]}) ```  Error Message: ```   Error: Transaction reverted: function returned an unexpected amount of data       at LendingPair._safeTransferFrom (contracts/TransferHelper.sol:20)       at LendingPair.deposit (contracts/LendingPair.sol:95) ``` ## Tools Used  Hardhat  ## Recommended Mitigation Steps Uses openzeppelin `SafeERC20` in transfer helper (and any other contract that uses IERC20).  
# Handle  greiart   # Vulnerability details  ## Impact  The `depositRepayETH()`, `withdrawBorrowETH()`, `withdrawAllETH()` and `repayAllETH()` fail to check if ETH is an asset of the lending pair (ie. if ETH is either tokenA or tokenB).  From manually tracing the `depositRepayETH()` function, attempts to call it will revert in `_mintSupply()` when `lpToken[_token].mint(_account, _amount);` is called, since the `lpToken` is only initialized for only tokenA and tokenB.  Nevertheless, it is recommended to perform token validation for the ETH methods as well, since it should be treated like other ERC20 tokens. It also helps to avoid wasting gas.  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L83](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L83)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L131](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L131)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156)  ## Recommended Mitigation Steps  Include `_validateToken()` in the equivalent ETH functions. An alternative suggestion is to drop the ETH methods (eg. combine `depositRepayETH()` into `depositRepay()` and doing a bit of refactoring to make native ETH deposits / withdrawals possible.  ```jsx // public constant ETH_ADDRESS = ''; // define a special constant address for ether != WETH address function depositRepay(address _account, address _token, uint _amount) external payable {     _validateTokenAndValue(_token, msg.value, _amount);     accrueAccount(_account);      _depositRepay(_account, _token, _amount);   _handleDeposit{value:msg.value}(_token, _amount); }  function _validateTokenAndValue(address _token, uint etherWei, uint amount) internal view {   address token;   if (_token == ETH_ADDRESS) {    token = WETH;    require(etherWei == amount, "LendingPair: invalid etherWei");   } else {    token = _token;    require(etherWei == 0, "LendingPair: invalid etherWei");   }     require(token == tokenA || token == tokenB, "LendingPair: invalid token"); }  function _handleDeposit(address _token, uint _amount) internal payable {  (_token == ETH_ADDRESS) ?    WETH.deposit{ value: msg.value }() :    _safeTransferFrom(_token, msg.sender, _amount); } ```  
# Handle  greiart   # Vulnerability details  ## Impact  The address casting of `_token` in `lpToken[address(_token)]` can be removed in the `withdrawAll()`, `_withdraw()` and `_borrow()` functions, since `_token` is already an address in these functions.   In other words, `lpToken[address(_token)]` *→* `lpToken[token]`  
# Handle  defsec   # Vulnerability details  ## Impact  There is occurrence in the code of the TransferHelper contract where amount is checked after the external call.  ## Proof of Concept  - Navigate to [TransferHelper.sol](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol) -  Amount is checked after an external call. [TransferHelper.sol amount check](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol#L22)  -  To favor readability and avoid confusions, consider applying check at the beginning of function.  ## Tools Used  None  ## Recommended Mitigation Steps  To favor readability and avoid confusions, consider applying check at the beginning of function.  ```sh   function _safeTransferFrom(address _token, address _sender, uint _amount) internal virtual {     require(_amount > 0, "TransferHelper: amount must be > 0");     ...   } ```  
# Handle  greiart   # Vulnerability details  ## Impact  Will help prevent erraneous `minObservations` values from being set (ie. `> 65535`) by the owner without needing checks. Otherwise, the `isPoolValid` will always return false, causing reverts in calling `tokenPrice` and `addPool` functions (and other functions calling these).  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L25](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L25)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L101](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L101)  ## Proof Of Concept  The maximum number of observations available is `65535` (see [https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Pool.sol#L39](https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Pool.sol#L39)), which is equivalent to `type(uint16).max`.  Hence,   - `uint public minObservations` can be reduced to `uint16 public minObservations`. - `(, , , , uint observationSlots , ,) = IUniswapV3Pool(poolAddress).slot0();` becomes `(, , , , uint16 observationSlots , ,) = IUniswapV3Pool(poolAddress).slot0();`  
# Handle  greiart   # Vulnerability details  ## Impact  No impact but personally, I think it's good practice to emit an event whenever you update the state of the contract via a setter function.  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L65-L75](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L65-L75)  
# Handle  greiart   # Vulnerability details  ## Impact  A repeated call to `pidByPairToken[_pair][_token][_isSupply]` can be avoided since it is stored in `poolPosition`. Simply return [poolPosition.pid](http://poolposition.pid).   ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L245-L250](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L245-L250)  ## Proof of Concept  ```jsx function _getPid(address _pair, address _token, bool _isSupply) internal view returns(uint) {     PoolPosition memory poolPosition = pidByPairToken[_pair][_token][_isSupply];     require(poolPosition.added, "RewardDistribution: invalid pool");      return poolPosition.pid; } ```  
# Handle  greiart   # Vulnerability details  ## Impact  It would be better to perform the allowance check before handling the token transfer. This is in line with the best practice of the CEI (checks-effects-interactions) pattern to avoid possible re-entrancy attacks.  [https://dev.to/mxmaster2s/quick-guide-to-the-checks-effect-interactions-pattern-to-remember-when-writing-your-smart-contracts-gfk](https://dev.to/mxmaster2s/quick-guide-to-the-checks-effect-interactions-pattern-to-remember-when-writing-your-smart-contracts-gfk)  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LPTokenMaster.sol#L42-L46](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LPTokenMaster.sol#L42-L46)  ## Recommended Mitigation Steps  ```jsx function transferFrom(address _sender, address _recipient, uint _amount) external returns (bool) {     _approve(_sender, msg.sender, allowance[_sender][msg.sender] - _amount);     _transfer(_sender, _recipient, _amount);     return true; } ```  
# Handle  gpersoon   # Vulnerability details  ## Impact   The functions _safeTransferFrom and _safeTransfer are similar but there is one difference: _safeTransferFrom reverts when _amount == 0 _safeTransfer  doesn't do any action when _amount == 0  I don't see any reason for the different behavior.  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol function _safeTransferFrom(address _token, address _sender, uint _amount) internal virtual {     bool success = IERC20(_token).transferFrom(_sender, address(this), _amount);     require(success, "TransferHelper: transfer failed");     require(_amount > 0, "TransferHelper: amount must be > 0");   }  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L468   function _safeTransfer(IERC20 _token, address _recipient, uint _amount) internal {     if (_amount > 0) {       bool success = _token.transfer(_recipient, _amount);       require(success, "LendingPair: transfer failed");       _checkMinReserve(address(_token));     }   }  ## Tools Used  ## Recommended Mitigation Steps Double check the difference and perhaps apply the same logic for amount==0 to both functions.  
# Handle  gpersoon   # Vulnerability details  ## Impact Some of the constructors set values that are never changed. See proof of concept. Its best to use the immutable keyword to make sure they aren't changed by accident.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L38 address public tokenA; address public tokenB;  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L37 IPairFactory public factory; IController  public controller; IERC20  public rewardToken;  ## Tools Used  ## Recommended Mitigation Steps Add the immutable keyword where possible   
# Handle  gpersoon   # Vulnerability details  ## Impact The function withdrawBorrowETH of the contract LendingPair calls _wethWithdrawTo and then calls _checkMinReserve. However _wethWithdrawTo also calls _checkMinReserve  (except when _amount but then not much happens anyway.  So the call to _checkMinReserve in withdrawBorrowETH is redundant and uses some extra gas.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106  function withdrawBorrowETH(uint _amount) external {    ..     _wethWithdrawTo(msg.sender, _amount);     _checkMinReserve(address(WETH)); // is also called in _wethWithdrawTo   }   function _wethWithdrawTo(address _to, uint _amount) internal override {     if (_amount > 0) {       TransferHelper._wethWithdrawTo(_to, _amount);       _checkMinReserve(address(WETH));     }   }  ## Tools Used  ## Recommended Mitigation Steps Consider removing the _checkMinReserve in withdrawBorrowETH Or consider moving the _checkMinReserve to all functions where _wethWithdrawTo is called  
# Handle  gpersoon   # Vulnerability details  ## Impact The parameter minBorrowUSD of the contract Controller isn't initialized. If someone is able to Borrow before the function setMinBorrowUSD is called, he might be able to borrow a very small amount. This might be unwanted.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L27   uint public minBorrowUSD;    function setMinBorrowUSD(uint _value) external onlyOwner {     minBorrowUSD = _value;   }  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L553 function _checkBorrowLimits(address _token, address _account) internal view {    ...     require(accountBorrowUSD >= controller.minBorrowUSD(), "LendingPair: borrow amount below minimum");   ## Tools Used  ## Recommended Mitigation Steps Initialize minBorrowUSD via the constructor or set a reasonable default in the contract.  
# Handle  gpersoon   # Vulnerability details  ## Impact Both the functions setLiqParamsToken and setLiqParamsDefault have a check to make sure that _liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES  However the constructor of Controller sets the same parameters and doesn't have this check. It seems logical to also do the check in the controller otherwise the parameters could be set outside of the wanted range.  ## Proof of Concept // https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L49 constructor( address _interestRateModel, uint _liqFeeSystemDefault, uint _liqFeeCallerDefault) {     ...     liqFeeSystemDefault = _liqFeeSystemDefault;     liqFeeCallerDefault = _liqFeeCallerDefault;  function setLiqParamsToken( address _token, uint    _liqFeeSystem, uint    _liqFeeCaller ) external onlyOwner {     require(_liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES, "Controller: fees too high"); ...     liqFeeSystemToken[_token] = _liqFeeSystem;     liqFeeCallerToken[_token] = _liqFeeCaller;  function setLiqParamsDefault( uint    _liqFeeSystem, uint    _liqFeeCaller) external onlyOwner {     require(_liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES, "Controller: fees too high");     liqFeeSystemDefault = _liqFeeSystem;     liqFeeCallerDefault = _liqFeeCaller;  ## Tools Used  ## Recommended Mitigation Steps Add something like the following in the constructor of Controller  require(liqFeeCallerDefault + liqFeeSystemDefault <= MAX_LIQ_FEES, "Controller: fees too high");  
# Handle  defsec   # Vulnerability details  ## Impact  Without Event, it is difficult to identify in real-time whether correct values are recorded on the blockchain. In this case, it becomes problematic to determine whether the corresponding value has been changed in the application and whether the corresponding function has been called. setMinBorrowUSD function is missing event.  ## Proof of Concept  1. Go to following the function [setMinBorrowUSD Function](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L137) 2. There is missing event definition on the function.   ## Tools Used  None  ## Recommended Mitigation Steps  Add Event corresponding to the change occurring in the function.  <code>Add `emit NewMinBorrowUSD(_value);`</code>  
