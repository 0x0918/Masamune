# Handle  0xsanson   # Vulnerability details  ## Impact In `StablesConverter.convert` there are multiple storage reads of `tokens[i]` that add up gas. Consider saving the variable in memory.   ## Tools Used editor  ## Recommended Mitigation Steps Rewrite  ```js IERC20 _token;    // add this for (uint8 i = 0; i < 3; i++) {  _token = tokens[i];  // add this     //if (_output == address(tokens[i])) {     if (_output == address(_token)) {         //uint256 _before = tokens[i].balanceOf(address(this));         uint256 _before = _token.balanceOf(address(this));         stableSwap3Pool.remove_liquidity_one_coin(             _inputAmount,             i,             _estimatedOutput         );         //uint256 _after = tokens[i].balanceOf(address(this));         uint256 _after = _token.balanceOf(address(this));         _outputAmount = _after.sub(_before);         //tokens[i].safeTransfer(msg.sender, _outputAmount);         _token.safeTransfer(msg.sender, _outputAmount);         return _outputAmount;     } } ```  
# Handle  0xsanson   # Vulnerability details  ## Impact During the `_harvest` function in NativeStrategyCurve3Crv.sol, there's a call to `_deposit()` only `if (balanceOfWant() > 0)`. This if-statement can be removed since `_deposit` calculates again `balanceOfWant()` and makes the same check. This way the function saves a `.balanceOf` call.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L123  ## Tools Used editor  
# Handle  0xsanson   # Vulnerability details  ## Impact `NativeStrategyCurve3Crv._harvest` calls `getMostPremium` to get the best stablecoin to convert to. This function however is wrong in the case of `balancesUSDC = balancesUSDT < balancesDAI`, because it returns DAI, when it should be USDC or USDT. This is naturally a rare occasion, but a bad actor can set the balances (by depositing/withdrawing the Curve pool) like this just before the harvest function is called. Since this would imbalance even more the pool, the bad actor could also gain a profit by making the right swaps after the harvest.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L83  ## Tools Used editor  ## Recommended Mitigation Steps Convert all `<` into `<=` inside `getMostPremium()`.  
# Handle  0xsanson   # Vulnerability details  ## Impact The harvester can initiate the earn process by calling the `Vault.earn`. At the end of this function an `Earn(_token, _balance)` event is emitted. Before this, the execution is passed to the `Controller.earn` function, which emits another event `Earn(_token, _strategy)`. Since these two events are emitted _always_ together (`Controller.earn` can be called only inside `Vault.earn`), it's more efficient to emit a single event `Earn(_token, _strategy, _amount)` at the end of `Controller.earn`. This should gain a little gas (one less indexed data) and it's less confusing.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L437 https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L157  ## Tools Used editor  
# Handle  cmichel   # Vulnerability details  When doing swaps with a Uniswap router from within a contract, there's no need to compute any offset from the current block for the `deadline` parameter. The router just checks if `deadline >= block.timestamp`.  See `BaseStrategy._swapTokens` which does an unnecessary `block.timestamp` read and another unnecessary addition of `1800`.  ## Recommended Mitigation Steps The most efficient way to provide deadlines for a router swap is to use a hardcoded value that is far in the future, for example, `1e10`.   
# Handle  cmichel   # Vulnerability details  The `Withdraw` event in `LegacyController.withdraw` emits the `_amount` variable which is the _initial, desired_ amount to withdraw. It should emit the actual withdrawn amount instead, which is transferred in the last `token.balanceOf(address(this))` call.  ## Impact The actual withdrawn amount, which can be lower than `_amount`, is part of the event. This is usually not what you want (and it can already be decoded from the function argument).  ## Recommended Mitigation Steps Use it or remove it.   
# Handle  pauliax   # Vulnerability details  ## Impact function _checkToken can be moved to modifier checkToken as it is a private function that is only used by this modifier. This will reduce the number of extra calls and thus reduce the gas.  ## Recommended Mitigation Steps Consider moving this function inside the modifier to reduce gas usage.  
# Handle  pauliax   # Vulnerability details  ## Impact functions depositVault, depositMultipleVault and withdrawVault in VaultHelper could require _amount > 0 to prevent useless transfers.  ## Recommended Mitigation Steps Add require _amount > 0 statements to mentioned functions.  
# Handle  pauliax   # Vulnerability details  ## Impact A theoretical issue is that the decimals of USDC may change as they use an upgradeable contract so you cannot assume that it stays 6 decimals forever:   balances[1] = stableSwap3Pool.balances(1).mul(10**12); // USDC  ## Recommended Mitigation Steps A simple solution would be to call .decimals() on token contract to query it on the go. Then you will not need to hardcode it but gas usage will increase.  
# Handle  pauliax   # Vulnerability details  ## Impact function setMinter should validate that _minter is not an empty (0x0) address.  ## Recommended Mitigation Steps require(_minter != address(0), "!_minter");  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `notHalted` modifier in `depositMultiple()` is redundant because it is checked (multiple times) by the underlying function call to `deposit()`.  Further optimizations may be done to implement an internal `_deposit()` function that will be called by both `deposit()` and `depositMultiple()` so that `notHalted` is only checked once.  ### Recommended Mitigation Steps  Remove the `notHalted` modifier in `depositMultiple()`.  
# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  The negation of the disjunction form of the `canHarvest()` function will help save gas. In other words, instead of `!(A || B)`, return `(!A && !B)`.  ```jsx function canHarvest(  address _vault )   public   view   returns (bool) {   Strategy storage strategy = strategies[_vault];   // only can harvest if there are strategies, and when sufficient time has elapsed   // solhint-disable-next-line not-rely-on-time  return (strategy.addresses.length > 0 && strategy.lastCalled <= block.timestamp.sub(strategy.timeout)); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `_vaultDetails[_vault].balance` in L367 can be changed to the already fetched value `_balance`.  ### Recommended Mitigation Steps  `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_amount);`  
# Handle  0xRajeev   # Vulnerability details  ## Impact OpenZeppelinâ€™s safeApprove reverts for non-0 to non-0 approvals. This is considered in a few places where safeApprove is performed twice with the first one for 0 and then for the desired allowance. However, there are uses of safeApprove where it is called only once for the desired allowance but it is not clear that the current allowance is guaranteed to be zero. In such cases, safeApprove may revert.  ## Proof of Concept  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6241995ad323952e38f8d405103ed994a2dcde8e/contracts/token/ERC20/utils/SafeERC20.sol#L49-L55  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/converters/StablesConverter.sol#L78  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/strategies/BaseStrategy.sol#L88  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Approve to 0 first while using safeApprove or use increaseAllowance instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact The manager.allowedVaults check is missing for add/remove strategy like how it is used in reorderStrategies(). This will allow a strategist to accidentally/maliciously add/remove strategies on unauthorized vaults.  Given the critical access control that is missing on vaults here, this is classified as medium severity.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L101-L130  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L172-L207  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L224  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L210-L221   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add manager.allowedVaults check in addStrategy() and removeStrategy()  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Events that are declared but not used may be indicative of unused declarations where it makes sense to remove them for better readability/maintainability/auditability, or worse indicative of a missing emit which is bad for monitoring or missing logic that would have emitted that event.  Event InsuranceClaimed is missing an emit.  Event ControllerSet is missing an emit.  Event VaultManagerSet is missing an emit.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L56  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Harvester.sol#L44  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Harvester.sol#L72  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add emit or remove event declaration.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Storage slots are allocated based on the declaration order of state variables in contract definitions. For types less than 256 bits, they can be packed by the compiler if more than one fit into the same 32B storage slot. This reduces the number of storage slots but may increase runtime gas consumption because of masking the other shared variables in slot. However, if variables used together in function logic are packed in the same slot, it allows the compiler to optimize SLOADs/SSTOREs.  Example: An example of this is the declaration of the halted boolean state variable. Given the current declaration order, this occupies a full slot because booleans are internally represented by uint8 and the neighbouring declarations are uint256 which need a full slot for themselves.  Moving the halted bool next to governance address variable declaration will allow those two to share a slot. This reduces one slot and also should not incur extra masking gas overhead at runtime because governor and halted are used in onlyGovernance and notHalted modifiers respectively which are typically used together.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L33-L49   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move halted declaration to immediately after governance declaration. Also, consider the declaration order of all state variables across contracts for such packing possibilities.  
# Handle  jonah1005   # Vulnerability details  ## Impact There's no safety check in controller's `addStrategy`. When the same strategy is added to a vault twice, the protocol breakdowns in several ways.   1. Removing that strategy would always raise errors. 2. `_vaultDetails[_vault].balances[_strategy]` would not track strategy's balance correctly; `getBestStrategyWithdraw` would have a wrong answer and makes withdrawing from the strategy to raise error in certain scenarios.  I consider this a low-risk issue.  ## Proof of Concept This is the web3.py script: ```python controller.functions.addStrategy(vault.address, strategy.address, cap, 0).transact() controller.functions.addStrategy(vault.address, strategy.address, cap, 0).transact()  # would not be able to removestrategy controller.functions.removeStrategy(vault.address, strategy.address, 0).transact() ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps  The controller should raise an error if the strategy has been added to the protocol(any vault). As adding the same strategy to two different vaults would have worse results, the controller can maintain a map to record each strategy's status.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function depositMultipleVault of VaultHelper doesn't check the array size of _tokens and _amounts are the same length. In previous version of solidity there were bugs with giving an enormous large array to a function which accepted memory arrays.  Although depositMultipleVault uses calldata arrays, it is probably better to add a check on the length.  On the other hand the function depositMultiple of Vault.sol does check it.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/VaultHelper.sol#L57 ```JS  function depositMultipleVault(         address _vault,         address[] calldata _tokens,         uint256[] calldata _amounts     )  external {         for (uint8 i = 0; i < _amounts.length; i++) {         ... ```  https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L188 ```JS  function depositMultiple(         address[] calldata _tokens,         uint256[] calldata _amounts     )  external override notHalted returns (uint256 _shares) {         require(_tokens.length == _amounts.length, "!length");          for (uint8 i; i < _amounts.length; i++) {            ...  ```   ## Tools Used  ## Recommended Mitigation Steps Add something like the following in depositMultipleVault:    require(_tokens.length == _amounts.length, "!length");  
# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that harvesting and fundings progress is not checked when the contract is halted. This can cause misfunctionality and locking user funds during the halt progress.  ## Proof of Concept  1-) Navigate to "https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol" contract. 2-) Observe the following code on the Controller.sol.  Functions earn and HarvestStrategy ```     function harvestStrategy(address _strategy,uint256 _estimatedWETH,uint256 _estimatedYAXIS)         external         override         onlyHarvester         onlyStrategy(_strategy)              function earn(         address _strategy,         address _token,         uint256 _amount     )         external         override         onlyStrategy(_strategy)         onlyVault(_token)  ```  ## Tools Used  None   ## Recommended Mitigation Steps  Implement the notHalt modifier into the functions. Only withdraw functions should be allowed on the contract.   
# Handle  jonah1005   # Vulnerability details  ## removeToken would break the vault.   ## Impact There's no safety check in Manager.sol's removeToken. [Manager.sol#L454-L487](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Manager.sol#L454-L487) 1. The token would be locked in the original vault. Given the current design, the vault would keep a ratio of total amount to save the gas. Once the token is removed at manager contract, these token would lost. 2. Controller's balanceOf would no longer reflects the real value. [Controller.sol#L488-L495](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L488-L495) While `_vaultDetails[msg.sender].balance;` remains the same, user can nolonger withdraw those amount. 3. Share price in the vault would decrease drastically. The share price is calculated as `totalValue / totalSupply` [Vault.sol#L217](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L217). While the `totalSupply` of the share remains the same, the total balance has drastically decreased.  Calling removeToken way would almost break the whole protocol if the vault has already started. I consider this is a high-risk issue.   ## Proof of Concept  We can see how the vault would be affected with below web3.py script. ```python print(vault.functions.balanceOfThis().call()) print(vault.functions.totalSupply().call()) manager.functions.removeToken(vault.address, dai.address).transact() print(vault.functions.balanceOfThis().call()) print(vault.functions.totalSupply().call()) ```  output ``` 100000000000000000000000 100000000000000000000000 0 100000000000000000000000 ``` ## Tools Used Hardhat  ## Recommended Mitigation Steps Remove tokens from a vault would be a really critical job. I recommend the team cover all possible cases and check all components' states (all vault/ strategy/ controller's state) in the test.   Some steps that I try to come up with that is required to remove TokenA from a vault.  1. Withdraw all tokenA from all strategies (and handle it correctly in the controller).  2. Withdraw all tokenA from the vault.  3. Convert all tokenA that's collected in the previous step into tokenB.  4. Transfer tokenB to the vault and compensate the transaction fee/slippage cost to the vault.    
# Handle  jonah1005   # Vulnerability details  ## Impact There's no safety check in `Manager.sol` `addToken`. There are two possible cases that might happen. 1. One token being added twice in a Vault. Token would be counted doubly in the vault. Ref: [Vault.sol#L293-L303](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L293-L303). There would be two item in the array when querying `manager.getTokens(address(this));`.  2. A token first being added to two vaults. The value calculation of the first vault would be broken. As `vaults[_token] = _vault;` would point to the other vault.  Permission keys should always be treated cautiously. However, calling the same initialize function twice should not be able to destroy the vault. Also, as the protocol develops, there's likely that one token is supported in two vaults. The DAO may mistakenly add the same token twice. I consider this a high-risk issue.   ## Proof of Concept Adding same token twice would not raise any error here. ``` manager.functions.addToken(vault.address, dai.address).transact() manager.functions.addToken(vault.address, dai.address).transact() ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps I recommend to add two checks ```solidity require(vaults[_token] == address(0)); bool notFound = True; for(uint256 i; i < tokens[_vault].length; i++) {     if (tokens[_vault] == _token) {         notFound = False;     } } require(notFound, "duplicate token"); ```  
# Handle  jonah1005   # Vulnerability details  ## Impact In controller.sol's function `setCap`, the contract wrongly handles `_vaultDetails[_vault].balance`. While the balance should be decreased by the difference of strategies balance, it subtracts the remaining balance of the strategy. [Controller.sol#L262-L278](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278)  `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);`  This would result in `vaultDetails[_vault].balance` being far smaller than the strategy's value. A user would trigger the assertion at [Contreller.sol#475](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L475) and the fund would be locked in the strategy.  Though `setCap` is a permission function that only the operator can call, it's likely to be called and the fund would be locked in the contract. I consider this a high severity issue.  ## Proof of Concept We can trigger the issue by setting the cap 1 wei smaller than the strategy's balance.   ```python strategy_balance = strategy.functions.balanceOf().call() controller.functions.setCap(vault.address, strategy.address, strategy_balance - 1, dai.address).transact()  ## this would be reverted vault.functions.withdrawAll(dai.address).transact() ```   [Controller.sol#L262-L278](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278)  ## Tools Used Hardhat  ## Recommended Mitigation Steps  I believe the dev would spot the issue in the test if `_vaultDetails[_vault].balance` is a public variable.  One possile fix is to subtract the difference of the balance. ```solidity uint previousBalance = IStrategy(_strategy).balanceOf(); _vaultDetails[_vault].balance.sub(previousBalance.sub(_amount)); ```   
# Handle  0xsanson   # Vulnerability details  ## Impact In `StablesConverter.convert` there are multiple storage reads of `tokens[i]` that add up gas. Consider saving the variable in memory.   ## Tools Used editor  ## Recommended Mitigation Steps Rewrite  ```js IERC20 _token;    // add this for (uint8 i = 0; i < 3; i++) {  _token = tokens[i];  // add this     //if (_output == address(tokens[i])) {     if (_output == address(_token)) {         //uint256 _before = tokens[i].balanceOf(address(this));         uint256 _before = _token.balanceOf(address(this));         stableSwap3Pool.remove_liquidity_one_coin(             _inputAmount,             i,             _estimatedOutput         );         //uint256 _after = tokens[i].balanceOf(address(this));         uint256 _after = _token.balanceOf(address(this));         _outputAmount = _after.sub(_before);         //tokens[i].safeTransfer(msg.sender, _outputAmount);         _token.safeTransfer(msg.sender, _outputAmount);         return _outputAmount;     } } ```  
# Handle  0xsanson   # Vulnerability details  ## Impact During the `_harvest` function in NativeStrategyCurve3Crv.sol, there's a call to `_deposit()` only `if (balanceOfWant() > 0)`. This if-statement can be removed since `_deposit` calculates again `balanceOfWant()` and makes the same check. This way the function saves a `.balanceOf` call.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L123  ## Tools Used editor  
# Handle  0xsanson   # Vulnerability details  ## Impact `NativeStrategyCurve3Crv._harvest` calls `getMostPremium` to get the best stablecoin to convert to. This function however is wrong in the case of `balancesUSDC = balancesUSDT < balancesDAI`, because it returns DAI, when it should be USDC or USDT. This is naturally a rare occasion, but a bad actor can set the balances (by depositing/withdrawing the Curve pool) like this just before the harvest function is called. Since this would imbalance even more the pool, the bad actor could also gain a profit by making the right swaps after the harvest.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L83  ## Tools Used editor  ## Recommended Mitigation Steps Convert all `<` into `<=` inside `getMostPremium()`.  
# Handle  0xsanson   # Vulnerability details  ## Impact The harvester can initiate the earn process by calling the `Vault.earn`. At the end of this function an `Earn(_token, _balance)` event is emitted. Before this, the execution is passed to the `Controller.earn` function, which emits another event `Earn(_token, _strategy)`. Since these two events are emitted _always_ together (`Controller.earn` can be called only inside `Vault.earn`), it's more efficient to emit a single event `Earn(_token, _strategy, _amount)` at the end of `Controller.earn`. This should gain a little gas (one less indexed data) and it's less confusing.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L437 https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L157  ## Tools Used editor  
# Handle  cmichel   # Vulnerability details  When doing swaps with a Uniswap router from within a contract, there's no need to compute any offset from the current block for the `deadline` parameter. The router just checks if `deadline >= block.timestamp`.  See `BaseStrategy._swapTokens` which does an unnecessary `block.timestamp` read and another unnecessary addition of `1800`.  ## Recommended Mitigation Steps The most efficient way to provide deadlines for a router swap is to use a hardcoded value that is far in the future, for example, `1e10`.   
# Handle  cmichel   # Vulnerability details  The `Withdraw` event in `LegacyController.withdraw` emits the `_amount` variable which is the _initial, desired_ amount to withdraw. It should emit the actual withdrawn amount instead, which is transferred in the last `token.balanceOf(address(this))` call.  ## Impact The actual withdrawn amount, which can be lower than `_amount`, is part of the event. This is usually not what you want (and it can already be decoded from the function argument).  ## Recommended Mitigation Steps Use it or remove it.   
# Handle  pauliax   # Vulnerability details  ## Impact function _checkToken can be moved to modifier checkToken as it is a private function that is only used by this modifier. This will reduce the number of extra calls and thus reduce the gas.  ## Recommended Mitigation Steps Consider moving this function inside the modifier to reduce gas usage.  
# Handle  pauliax   # Vulnerability details  ## Impact functions depositVault, depositMultipleVault and withdrawVault in VaultHelper could require _amount > 0 to prevent useless transfers.  ## Recommended Mitigation Steps Add require _amount > 0 statements to mentioned functions.  
# Handle  pauliax   # Vulnerability details  ## Impact A theoretical issue is that the decimals of USDC may change as they use an upgradeable contract so you cannot assume that it stays 6 decimals forever:   balances[1] = stableSwap3Pool.balances(1).mul(10**12); // USDC  ## Recommended Mitigation Steps A simple solution would be to call .decimals() on token contract to query it on the go. Then you will not need to hardcode it but gas usage will increase.  
# Handle  pauliax   # Vulnerability details  ## Impact function setMinter should validate that _minter is not an empty (0x0) address.  ## Recommended Mitigation Steps require(_minter != address(0), "!_minter");  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `notHalted` modifier in `depositMultiple()` is redundant because it is checked (multiple times) by the underlying function call to `deposit()`.  Further optimizations may be done to implement an internal `_deposit()` function that will be called by both `deposit()` and `depositMultiple()` so that `notHalted` is only checked once.  ### Recommended Mitigation Steps  Remove the `notHalted` modifier in `depositMultiple()`.  
# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  The negation of the disjunction form of the `canHarvest()` function will help save gas. In other words, instead of `!(A || B)`, return `(!A && !B)`.  ```jsx function canHarvest(  address _vault )   public   view   returns (bool) {   Strategy storage strategy = strategies[_vault];   // only can harvest if there are strategies, and when sufficient time has elapsed   // solhint-disable-next-line not-rely-on-time  return (strategy.addresses.length > 0 && strategy.lastCalled <= block.timestamp.sub(strategy.timeout)); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `_vaultDetails[_vault].balance` in L367 can be changed to the already fetched value `_balance`.  ### Recommended Mitigation Steps  `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_amount);`  
# Handle  0xRajeev   # Vulnerability details  ## Impactâ€¨ OpenZeppelinâ€™s safeApprove reverts for non-0 to non-0 approvals. This is considered in a few places where safeApprove is performed twice with the first one for 0 and then for the desired allowance. However, there are uses of safeApprove where it is called only once for the desired allowance but it is not clear that the current allowance is guaranteed to be zero. In such cases, safeApprove may revert.  ## Proof of Concept  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6241995ad323952e38f8d405103ed994a2dcde8e/contracts/token/ERC20/utils/SafeERC20.sol#L49-L55  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/converters/StablesConverter.sol#L78  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/strategies/BaseStrategy.sol#L88  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Approve to 0 first while using safeApprove or use increaseAllowance instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact The manager.allowedVaults check is missing for add/remove strategy like how it is used in reorderStrategies(). This will allow a strategist to accidentally/maliciously add/remove strategies on unauthorized vaults.  Given the critical access control that is missing on vaults here, this is classified as medium severity.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L101-L130  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L172-L207  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L224  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L210-L221   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add manager.allowedVaults check in addStrategy() and removeStrategy()  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Events that are declared but not used may be indicative of unused declarations where it makes sense to remove them for better readability/maintainability/auditability, or worse indicative of a missing emit which is bad for monitoring or missing logic that would have emitted that event.  Event InsuranceClaimed is missing an emit.  Event ControllerSet is missing an emit.  Event VaultManagerSet is missing an emit.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L56  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Harvester.sol#L44  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Harvester.sol#L72  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add emit or remove event declaration.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Storage slots are allocated based on the declaration order of state variables in contract definitions. For types less than 256 bits, they can be packed by the compiler if more than one fit into the same 32B storage slot. This reduces the number of storage slots but may increase runtime gas consumption because of masking the other shared variables in slot. However, if variables used together in function logic are packed in the same slot, it allows the compiler to optimize SLOADs/SSTOREs.  Example: An example of this is the declaration of the halted boolean state variable. Given the current declaration order, this occupies a full slot because booleans are internally represented by uint8 and the neighbouring declarations are uint256 which need a full slot for themselves.  Moving the halted bool next to governance address variable declaration will allow those two to share a slot. This reduces one slot and also should not incur extra masking gas overhead at runtime because governor and halted are used in onlyGovernance and notHalted modifiers respectively which are typically used together.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L33-L49   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move halted declaration to immediately after governance declaration. Also, consider the declaration order of all state variables across contracts for such packing possibilities.  
# Handle  jonah1005   # Vulnerability details  ## Impact There's no safety check in controller's `addStrategy`. When the same strategy is added to a vault twice, the protocol breakdowns in several ways.   1. Removing that strategy would always raise errors. 2. `_vaultDetails[_vault].balances[_strategy]` would not track strategy's balance correctly; `getBestStrategyWithdraw` would have a wrong answer and makes withdrawing from the strategy to raise error in certain scenarios.  I consider this a low-risk issue.  ## Proof of Concept This is the web3.py script: ```python controller.functions.addStrategy(vault.address, strategy.address, cap, 0).transact() controller.functions.addStrategy(vault.address, strategy.address, cap, 0).transact()  # would not be able to removestrategy controller.functions.removeStrategy(vault.address, strategy.address, 0).transact() ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps  The controller should raise an error if the strategy has been added to the protocol(any vault). As adding the same strategy to two different vaults would have worse results, the controller can maintain a map to record each strategy's status.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function depositMultipleVault of VaultHelper doesn't check the array size of _tokens and _amounts are the same length. In previous version of solidity there were bugs with giving an enormous large array to a function which accepted memory arrays.  Although depositMultipleVault uses calldata arrays, it is probably better to add a check on the length.  On the other hand the function depositMultiple of Vault.sol does check it.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/VaultHelper.sol#L57 ```JS  function depositMultipleVault(         address _vault,         address[] calldata _tokens,         uint256[] calldata _amounts     )  external {         for (uint8 i = 0; i < _amounts.length; i++) {         ... ```  https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L188 ```JS  function depositMultiple(         address[] calldata _tokens,         uint256[] calldata _amounts     )  external override notHalted returns (uint256 _shares) {         require(_tokens.length == _amounts.length, "!length");          for (uint8 i; i < _amounts.length; i++) {            ...  ```   ## Tools Used  ## Recommended Mitigation Steps Add something like the following in depositMultipleVault:    require(_tokens.length == _amounts.length, "!length");  
# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that harvesting and fundings progress is not checked when the contract is halted. This can cause misfunctionality and locking user funds during the halt progress.  ## Proof of Concept  1-) Navigate to "https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol" contract. 2-) Observe the following code on the Controller.sol.  Functions earn and HarvestStrategy ```     function harvestStrategy(address _strategy,uint256 _estimatedWETH,uint256 _estimatedYAXIS)         external         override         onlyHarvester         onlyStrategy(_strategy)              function earn(         address _strategy,         address _token,         uint256 _amount     )         external         override         onlyStrategy(_strategy)         onlyVault(_token)  ```  ## Tools Used  None   ## Recommended Mitigation Steps  Implement the notHalt modifier into the functions. Only withdraw functions should be allowed on the contract.   
# Handle  jonah1005   # Vulnerability details  ## removeToken would break the vault.   ## Impact There's no safety check in Manager.sol's removeToken. [Manager.sol#L454-L487](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Manager.sol#L454-L487) 1. The token would be locked in the original vault. Given the current design, the vault would keep a ratio of total amount to save the gas. Once the token is removed at manager contract, these token would lost. 2. Controller's balanceOf would no longer reflects the real value. [Controller.sol#L488-L495](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L488-L495) While `_vaultDetails[msg.sender].balance;` remains the same, user can nolonger withdraw those amount. 3. Share price in the vault would decrease drastically. The share price is calculated as `totalValue / totalSupply` [Vault.sol#L217](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L217). While the `totalSupply` of the share remains the same, the total balance has drastically decreased.  Calling removeToken way would almost break the whole protocol if the vault has already started. I consider this is a high-risk issue.   ## Proof of Concept  We can see how the vault would be affected with below web3.py script. ```python print(vault.functions.balanceOfThis().call()) print(vault.functions.totalSupply().call()) manager.functions.removeToken(vault.address, dai.address).transact() print(vault.functions.balanceOfThis().call()) print(vault.functions.totalSupply().call()) ```  output ``` 100000000000000000000000 100000000000000000000000 0 100000000000000000000000 ``` ## Tools Used Hardhat  ## Recommended Mitigation Steps Remove tokens from a vault would be a really critical job. I recommend the team cover all possible cases and check all components' states (all vault/ strategy/ controller's state) in the test.   Some steps that I try to come up with that is required to remove TokenA from a vault.  1. Withdraw all tokenA from all strategies (and handle it correctly in the controller).  2. Withdraw all tokenA from the vault.  3. Convert all tokenA that's collected in the previous step into tokenB.  4. Transfer tokenB to the vault and compensate the transaction fee/slippage cost to the vault.    
# Handle  jonah1005   # Vulnerability details  ## Impact There's no safety check in `Manager.sol` `addToken`. There are two possible cases that might happen. 1. One token being added twice in a Vault. Token would be counted doubly in the vault. Ref: [Vault.sol#L293-L303](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L293-L303). There would be two item in the array when querying `manager.getTokens(address(this));`.  2. A token first being added to two vaults. The value calculation of the first vault would be broken. As `vaults[_token] = _vault;` would point to the other vault.  Permission keys should always be treated cautiously. However, calling the same initialize function twice should not be able to destroy the vault. Also, as the protocol develops, there's likely that one token is supported in two vaults. The DAO may mistakenly add the same token twice. I consider this a high-risk issue.   ## Proof of Concept Adding same token twice would not raise any error here. ``` manager.functions.addToken(vault.address, dai.address).transact() manager.functions.addToken(vault.address, dai.address).transact() ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps I recommend to add two checks ```solidity require(vaults[_token] == address(0)); bool notFound = True; for(uint256 i; i < tokens[_vault].length; i++) {     if (tokens[_vault] == _token) {         notFound = False;     } } require(notFound, "duplicate token"); ```  
# Handle  jonah1005   # Vulnerability details  ## Impact In controller.sol's function `setCap`, the contract wrongly handles `_vaultDetails[_vault].balance`. While the balance should be decreased by the difference of strategies balance, it subtracts the remaining balance of the strategy. [Controller.sol#L262-L278](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278)  `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);`  This would result in `vaultDetails[_vault].balance` being far smaller than the strategy's value. A user would trigger the assertion at [Contreller.sol#475](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L475) and the fund would be locked in the strategy.  Though `setCap` is a permission function that only the operator can call, it's likely to be called and the fund would be locked in the contract. I consider this a high severity issue.  ## Proof of Concept We can trigger the issue by setting the cap 1 wei smaller than the strategy's balance.   ```python strategy_balance = strategy.functions.balanceOf().call() controller.functions.setCap(vault.address, strategy.address, strategy_balance - 1, dai.address).transact()  ## this would be reverted vault.functions.withdrawAll(dai.address).transact() ```   [Controller.sol#L262-L278](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278)  ## Tools Used Hardhat  ## Recommended Mitigation Steps  I believe the dev would spot the issue in the test if `_vaultDetails[_vault].balance` is a public variable.  One possile fix is to subtract the difference of the balance. ```solidity uint previousBalance = IStrategy(_strategy).balanceOf(); _vaultDetails[_vault].balance.sub(previousBalance.sub(_amount)); ```   
# Handle  0xsanson   # Vulnerability details  ## Impact In `StablesConverter.convert` there are multiple storage reads of `tokens[i]` that add up gas. Consider saving the variable in memory.   ## Tools Used editor  ## Recommended Mitigation Steps Rewrite  ```js IERC20 _token;    // add this for (uint8 i = 0; i < 3; i++) {  _token = tokens[i];  // add this     //if (_output == address(tokens[i])) {     if (_output == address(_token)) {         //uint256 _before = tokens[i].balanceOf(address(this));         uint256 _before = _token.balanceOf(address(this));         stableSwap3Pool.remove_liquidity_one_coin(             _inputAmount,             i,             _estimatedOutput         );         //uint256 _after = tokens[i].balanceOf(address(this));         uint256 _after = _token.balanceOf(address(this));         _outputAmount = _after.sub(_before);         //tokens[i].safeTransfer(msg.sender, _outputAmount);         _token.safeTransfer(msg.sender, _outputAmount);         return _outputAmount;     } } ```  
# Handle  0xsanson   # Vulnerability details  ## Impact During the `_harvest` function in NativeStrategyCurve3Crv.sol, there's a call to `_deposit()` only `if (balanceOfWant() > 0)`. This if-statement can be removed since `_deposit` calculates again `balanceOfWant()` and makes the same check. This way the function saves a `.balanceOf` call.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L123  ## Tools Used editor  
# Handle  0xsanson   # Vulnerability details  ## Impact `NativeStrategyCurve3Crv._harvest` calls `getMostPremium` to get the best stablecoin to convert to. This function however is wrong in the case of `balancesUSDC = balancesUSDT < balancesDAI`, because it returns DAI, when it should be USDC or USDT. This is naturally a rare occasion, but a bad actor can set the balances (by depositing/withdrawing the Curve pool) like this just before the harvest function is called. Since this would imbalance even more the pool, the bad actor could also gain a profit by making the right swaps after the harvest.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L83  ## Tools Used editor  ## Recommended Mitigation Steps Convert all `<` into `<=` inside `getMostPremium()`.  
# Handle  0xsanson   # Vulnerability details  ## Impact The harvester can initiate the earn process by calling the `Vault.earn`. At the end of this function an `Earn(_token, _balance)` event is emitted. Before this, the execution is passed to the `Controller.earn` function, which emits another event `Earn(_token, _strategy)`. Since these two events are emitted _always_ together (`Controller.earn` can be called only inside `Vault.earn`), it's more efficient to emit a single event `Earn(_token, _strategy, _amount)` at the end of `Controller.earn`. This should gain a little gas (one less indexed data) and it's less confusing.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L437 https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L157  ## Tools Used editor  
# Handle  cmichel   # Vulnerability details  When doing swaps with a Uniswap router from within a contract, there's no need to compute any offset from the current block for the `deadline` parameter. The router just checks if `deadline >= block.timestamp`.  See `BaseStrategy._swapTokens` which does an unnecessary `block.timestamp` read and another unnecessary addition of `1800`.  ## Recommended Mitigation Steps The most efficient way to provide deadlines for a router swap is to use a hardcoded value that is far in the future, for example, `1e10`.   
# Handle  cmichel   # Vulnerability details  The `Withdraw` event in `LegacyController.withdraw` emits the `_amount` variable which is the _initial, desired_ amount to withdraw. It should emit the actual withdrawn amount instead, which is transferred in the last `token.balanceOf(address(this))` call.  ## Impact The actual withdrawn amount, which can be lower than `_amount`, is part of the event. This is usually not what you want (and it can already be decoded from the function argument).  ## Recommended Mitigation Steps Use it or remove it.   
# Handle  pauliax   # Vulnerability details  ## Impact function _checkToken can be moved to modifier checkToken as it is a private function that is only used by this modifier. This will reduce the number of extra calls and thus reduce the gas.  ## Recommended Mitigation Steps Consider moving this function inside the modifier to reduce gas usage.  
# Handle  pauliax   # Vulnerability details  ## Impact functions depositVault, depositMultipleVault and withdrawVault in VaultHelper could require _amount > 0 to prevent useless transfers.  ## Recommended Mitigation Steps Add require _amount > 0 statements to mentioned functions.  
# Handle  pauliax   # Vulnerability details  ## Impact A theoretical issue is that the decimals of USDC may change as they use an upgradeable contract so you cannot assume that it stays 6 decimals forever:   balances[1] = stableSwap3Pool.balances(1).mul(10**12); // USDC  ## Recommended Mitigation Steps A simple solution would be to call .decimals() on token contract to query it on the go. Then you will not need to hardcode it but gas usage will increase.  
# Handle  pauliax   # Vulnerability details  ## Impact function setMinter should validate that _minter is not an empty (0x0) address.  ## Recommended Mitigation Steps require(_minter != address(0), "!_minter");  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `notHalted` modifier in `depositMultiple()` is redundant because it is checked (multiple times) by the underlying function call to `deposit()`.  Further optimizations may be done to implement an internal `_deposit()` function that will be called by both `deposit()` and `depositMultiple()` so that `notHalted` is only checked once.  ### Recommended Mitigation Steps  Remove the `notHalted` modifier in `depositMultiple()`.  
# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  The negation of the disjunction form of the `canHarvest()` function will help save gas. In other words, instead of `!(A || B)`, return `(!A && !B)`.  ```jsx function canHarvest(  address _vault )   public   view   returns (bool) {   Strategy storage strategy = strategies[_vault];   // only can harvest if there are strategies, and when sufficient time has elapsed   // solhint-disable-next-line not-rely-on-time  return (strategy.addresses.length > 0 && strategy.lastCalled <= block.timestamp.sub(strategy.timeout)); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  `_vaultDetails[_vault].balance` in L367 can be changed to the already fetched value `_balance`.  ### Recommended Mitigation Steps  `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_amount);`  
# Handle  0xRajeev   # Vulnerability details  ## Impactâ€¨ OpenZeppelinâ€™s safeApprove reverts for non-0 to non-0 approvals. This is considered in a few places where safeApprove is performed twice with the first one for 0 and then for the desired allowance. However, there are uses of safeApprove where it is called only once for the desired allowance but it is not clear that the current allowance is guaranteed to be zero. In such cases, safeApprove may revert.  ## Proof of Concept  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6241995ad323952e38f8d405103ed994a2dcde8e/contracts/token/ERC20/utils/SafeERC20.sol#L49-L55  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/converters/StablesConverter.sol#L78  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/strategies/BaseStrategy.sol#L88  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Approve to 0 first while using safeApprove or use increaseAllowance instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact The manager.allowedVaults check is missing for add/remove strategy like how it is used in reorderStrategies(). This will allow a strategist to accidentally/maliciously add/remove strategies on unauthorized vaults.  Given the critical access control that is missing on vaults here, this is classified as medium severity.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L101-L130  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L172-L207  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L224  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L210-L221   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add manager.allowedVaults check in addStrategy() and removeStrategy()  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Events that are declared but not used may be indicative of unused declarations where it makes sense to remove them for better readability/maintainability/auditability, or worse indicative of a missing emit which is bad for monitoring or missing logic that would have emitted that event.  Event InsuranceClaimed is missing an emit.  Event ControllerSet is missing an emit.  Event VaultManagerSet is missing an emit.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L56  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Harvester.sol#L44  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Harvester.sol#L72  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add emit or remove event declaration.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Storage slots are allocated based on the declaration order of state variables in contract definitions. For types less than 256 bits, they can be packed by the compiler if more than one fit into the same 32B storage slot. This reduces the number of storage slots but may increase runtime gas consumption because of masking the other shared variables in slot. However, if variables used together in function logic are packed in the same slot, it allows the compiler to optimize SLOADs/SSTOREs.  Example: An example of this is the declaration of the halted boolean state variable. Given the current declaration order, this occupies a full slot because booleans are internally represented by uint8 and the neighbouring declarations are uint256 which need a full slot for themselves.  Moving the halted bool next to governance address variable declaration will allow those two to share a slot. This reduces one slot and also should not incur extra masking gas overhead at runtime because governor and halted are used in onlyGovernance and notHalted modifiers respectively which are typically used together.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L33-L49   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move halted declaration to immediately after governance declaration. Also, consider the declaration order of all state variables across contracts for such packing possibilities.  
# Handle  jonah1005   # Vulnerability details  ## Impact There's no safety check in controller's `addStrategy`. When the same strategy is added to a vault twice, the protocol breakdowns in several ways.   1. Removing that strategy would always raise errors. 2. `_vaultDetails[_vault].balances[_strategy]` would not track strategy's balance correctly; `getBestStrategyWithdraw` would have a wrong answer and makes withdrawing from the strategy to raise error in certain scenarios.  I consider this a low-risk issue.  ## Proof of Concept This is the web3.py script: ```python controller.functions.addStrategy(vault.address, strategy.address, cap, 0).transact() controller.functions.addStrategy(vault.address, strategy.address, cap, 0).transact()  # would not be able to removestrategy controller.functions.removeStrategy(vault.address, strategy.address, 0).transact() ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps  The controller should raise an error if the strategy has been added to the protocol(any vault). As adding the same strategy to two different vaults would have worse results, the controller can maintain a map to record each strategy's status.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function depositMultipleVault of VaultHelper doesn't check the array size of _tokens and _amounts are the same length. In previous version of solidity there were bugs with giving an enormous large array to a function which accepted memory arrays.  Although depositMultipleVault uses calldata arrays, it is probably better to add a check on the length.  On the other hand the function depositMultiple of Vault.sol does check it.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/VaultHelper.sol#L57 ```JS  function depositMultipleVault(         address _vault,         address[] calldata _tokens,         uint256[] calldata _amounts     )  external {         for (uint8 i = 0; i < _amounts.length; i++) {         ... ```  https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L188 ```JS  function depositMultiple(         address[] calldata _tokens,         uint256[] calldata _amounts     )  external override notHalted returns (uint256 _shares) {         require(_tokens.length == _amounts.length, "!length");          for (uint8 i; i < _amounts.length; i++) {            ...  ```   ## Tools Used  ## Recommended Mitigation Steps Add something like the following in depositMultipleVault:    require(_tokens.length == _amounts.length, "!length");  
# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that harvesting and fundings progress is not checked when the contract is halted. This can cause misfunctionality and locking user funds during the halt progress.  ## Proof of Concept  1-) Navigate to "https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol" contract. 2-) Observe the following code on the Controller.sol.  Functions earn and HarvestStrategy ```     function harvestStrategy(address _strategy,uint256 _estimatedWETH,uint256 _estimatedYAXIS)         external         override         onlyHarvester         onlyStrategy(_strategy)              function earn(         address _strategy,         address _token,         uint256 _amount     )         external         override         onlyStrategy(_strategy)         onlyVault(_token)  ```  ## Tools Used  None   ## Recommended Mitigation Steps  Implement the notHalt modifier into the functions. Only withdraw functions should be allowed on the contract.   
# Handle  jonah1005   # Vulnerability details  ## removeToken would break the vault.   ## Impact There's no safety check in Manager.sol's removeToken. [Manager.sol#L454-L487](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Manager.sol#L454-L487) 1. The token would be locked in the original vault. Given the current design, the vault would keep a ratio of total amount to save the gas. Once the token is removed at manager contract, these token would lost. 2. Controller's balanceOf would no longer reflects the real value. [Controller.sol#L488-L495](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L488-L495) While `_vaultDetails[msg.sender].balance;` remains the same, user can nolonger withdraw those amount. 3. Share price in the vault would decrease drastically. The share price is calculated as `totalValue / totalSupply` [Vault.sol#L217](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L217). While the `totalSupply` of the share remains the same, the total balance has drastically decreased.  Calling removeToken way would almost break the whole protocol if the vault has already started. I consider this is a high-risk issue.   ## Proof of Concept  We can see how the vault would be affected with below web3.py script. ```python print(vault.functions.balanceOfThis().call()) print(vault.functions.totalSupply().call()) manager.functions.removeToken(vault.address, dai.address).transact() print(vault.functions.balanceOfThis().call()) print(vault.functions.totalSupply().call()) ```  output ``` 100000000000000000000000 100000000000000000000000 0 100000000000000000000000 ``` ## Tools Used Hardhat  ## Recommended Mitigation Steps Remove tokens from a vault would be a really critical job. I recommend the team cover all possible cases and check all components' states (all vault/ strategy/ controller's state) in the test.   Some steps that I try to come up with that is required to remove TokenA from a vault.  1. Withdraw all tokenA from all strategies (and handle it correctly in the controller).  2. Withdraw all tokenA from the vault.  3. Convert all tokenA that's collected in the previous step into tokenB.  4. Transfer tokenB to the vault and compensate the transaction fee/slippage cost to the vault.    
# Handle  jonah1005   # Vulnerability details  ## Impact There's no safety check in `Manager.sol` `addToken`. There are two possible cases that might happen. 1. One token being added twice in a Vault. Token would be counted doubly in the vault. Ref: [Vault.sol#L293-L303](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L293-L303). There would be two item in the array when querying `manager.getTokens(address(this));`.  2. A token first being added to two vaults. The value calculation of the first vault would be broken. As `vaults[_token] = _vault;` would point to the other vault.  Permission keys should always be treated cautiously. However, calling the same initialize function twice should not be able to destroy the vault. Also, as the protocol develops, there's likely that one token is supported in two vaults. The DAO may mistakenly add the same token twice. I consider this a high-risk issue.   ## Proof of Concept Adding same token twice would not raise any error here. ``` manager.functions.addToken(vault.address, dai.address).transact() manager.functions.addToken(vault.address, dai.address).transact() ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps I recommend to add two checks ```solidity require(vaults[_token] == address(0)); bool notFound = True; for(uint256 i; i < tokens[_vault].length; i++) {     if (tokens[_vault] == _token) {         notFound = False;     } } require(notFound, "duplicate token"); ```  
# Handle  jonah1005   # Vulnerability details  ## Impact In controller.sol's function `setCap`, the contract wrongly handles `_vaultDetails[_vault].balance`. While the balance should be decreased by the difference of strategies balance, it subtracts the remaining balance of the strategy. [Controller.sol#L262-L278](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278)  `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);`  This would result in `vaultDetails[_vault].balance` being far smaller than the strategy's value. A user would trigger the assertion at [Contreller.sol#475](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L475) and the fund would be locked in the strategy.  Though `setCap` is a permission function that only the operator can call, it's likely to be called and the fund would be locked in the contract. I consider this a high severity issue.  ## Proof of Concept We can trigger the issue by setting the cap 1 wei smaller than the strategy's balance.   ```python strategy_balance = strategy.functions.balanceOf().call() controller.functions.setCap(vault.address, strategy.address, strategy_balance - 1, dai.address).transact()  ## this would be reverted vault.functions.withdrawAll(dai.address).transact() ```   [Controller.sol#L262-L278](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278)  ## Tools Used Hardhat  ## Recommended Mitigation Steps  I believe the dev would spot the issue in the test if `_vaultDetails[_vault].balance` is a public variable.  One possile fix is to subtract the difference of the balance. ```solidity uint previousBalance = IStrategy(_strategy).balanceOf(); _vaultDetails[_vault].balance.sub(previousBalance.sub(_amount)); ```   
