# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L679   # Vulnerability details  ## Impact The important states including `long0Balance, long1Balance, long1FeeGrowth, long1ProtocolFees` are wrongly calculated and it breaks the pool's invariant.  ## Proof of Concept The protocol provides a rebalancing functionality and the main logic is implemented in the library `Pool.sol`. If `param.isLong0ToLong1` is true and the transaction is `TimeswapV2PoolRebalance.GivenLong1`, the protocol calculates the `long1AmountAdjustFees` first and the actual `long0Amount, longFees` and the final `long1Balance` is decided accordingly. The problem is it is using the wrong parameter `pool.long0Balance` while it is supposed to use `pool.long1Balance` in the line L679.  This leads to wrong state calculation in the following logic. (especially L685 is setting the `long1Balance` to zero). Furthermore, the protocol is designed as a permission-less one and anyone can call `TimeswapV2Pool.rebalance()`. An attacker can abuse this to break the pool's invariant and take profit leveraging that.  ```solidity packages\v2-pool\src\structs\Pool.sol 665:     function rebalance(Pool storage pool, TimeswapV2PoolRebalanceParam memory param, uint256 transactionFee, uint256 protocolFee) external returns (uint256 long0Amount, uint256 long1Amount) { 666:         if (pool.liquidity == 0) Error.requireLiquidity(); 667: 668:         // No need to update short fee growth. 669: 670:         uint256 longFees; 671:         if (param.isLong0ToLong1) { 672:             if (param.transaction == TimeswapV2PoolRebalance.GivenLong0) { 673:                 (long1Amount, longFees) = ConstantSum.calculateGivenLongIn(param.strike, long0Amount = param.delta, transactionFee, true); 674: 675:                 if (long1Amount == 0) Error.zeroOutput(); 676: 677:                 pool.long1Balance -= (long1Amount + longFees); 678:             } else if (param.transaction == TimeswapV2PoolRebalance.GivenLong1) {     //************************************************************ 679:                 uint256 long1AmountAdjustFees = FeeCalculation.removeFees(pool.long0Balance, transactionFee);//@audit-info long0Balance -> long1Balance     //************************************************************ 680: 681:                 if ((long1Amount = param.delta) == long1AmountAdjustFees) { 682:                     long0Amount = ConstantSum.calculateGivenLongOutAlreadyAdjustFees(param.strike, pool.long1Balance, true); 683: 684:                     longFees = pool.long1Balance.unsafeSub(long1Amount); 685:                     pool.long1Balance = 0; 686:                 } else { 687:                     (long0Amount, longFees) = ConstantSum.calculateGivenLongOut(param.strike, long1Amount, transactionFee, true); 688: 689:                     pool.long1Balance -= (long1Amount + longFees); 690:                 } 691: 692:                 if (long0Amount == 0) Error.zeroOutput(); 693:             } 694: 695:             pool.long0Balance += long0Amount; 696: 697:             (pool.long1FeeGrowth, pool.long1ProtocolFees) = FeeCalculation.update(pool.liquidity, pool.long1FeeGrowth, pool.long1ProtocolFees, longFees, protocolFee); 698:         } else { 699:             if (param.transaction == TimeswapV2PoolRebalance.GivenLong0) { 700:                 uint256 long0AmountAdjustFees = FeeCalculation.removeFees(pool.long0Balance, transactionFee);//@audit-info 701: 702:                 if ((long0Amount = param.delta) == long0AmountAdjustFees) { 703:                     long1Amount = ConstantSum.calculateGivenLongOutAlreadyAdjustFees(param.strike, pool.long0Balance, false); 704: 705:                     longFees = pool.long0Balance.unsafeSub(long0Amount); 706:                     pool.long0Balance = 0; 707:                 } else { 708:                     (long1Amount, longFees) = ConstantSum.calculateGivenLongOut(param.strike, long0Amount, transactionFee, false); 709: 710:                     pool.long0Balance -= (long0Amount + longFees); 711:                 } 712: 713:                 if (long1Amount == 0) Error.zeroOutput(); 714:             } else if (param.transaction == TimeswapV2PoolRebalance.GivenLong1) { 715:                 (long0Amount, longFees) = ConstantSum.calculateGivenLongIn(param.strike, long1Amount = param.delta, transactionFee, false); 716: 717:                 if (long0Amount == 0) Error.zeroOutput(); 718: 719:                 pool.long0Balance -= (long0Amount + longFees); 720:             } 721: 722:             pool.long1Balance += long1Amount; 723: 724:             (pool.long0FeeGrowth, pool.long0ProtocolFees) = FeeCalculation.update(pool.liquidity, pool.long0FeeGrowth, pool.long0ProtocolFees, longFees, protocolFee); 725:         } 726:     } ``` ## Tools Used Manual Review  ## Recommended Mitigation Steps Fix the L679 as below. ```solidity uint256 long1AmountAdjustFees = FeeCalculation.removeFees(pool.long1Balance, transactionFee); ```
# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-library/src/Math.sol#L69-L79   # Vulnerability details  ## Impact Due to the wrong calculation of short and long tokens during the `leverage` and `deleverage` process, the users can suffer financial loss while the protocol will lose fees  ## Proof of Concept The protocol uses `leverage` function to deposit short tokens and receive long tokens. On the opposite, `deleverage` function serves for depositing long tokens and receiving short tokens.  [Leverage Function of TimeswapV2Pool contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L430-L466) [Deleverage Function of TimeswapV2Pool contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L377-L418)  Both functions call the PoolLibrary's `leverage` and `deleverage` functions after input sanitization.  [Leverage Function of PoolLibrary contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L552-L655) [Deleverage Function of PoolLibrary contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L469-L539)   PoolLibrary's `leverage` and `deleverage` functions update the state of the pool first for the fee growth and compute the `long0Amount`, `long1Amount`, and `shortAmount`. It also checks the transaction type according to the passed parameter types as per the `Transaction` contract's enum types below and calls `ConstantProduct`'s appropriate function accordingly;  ```solidity /// @dev The different kind of deleverage transactions. enum TimeswapV2PoolDeleverage {     GivenDeltaSqrtInterestRate,     GivenLong,     GivenShort,     GivenSum }  /// @dev The different kind of leverage transactions. enum TimeswapV2PoolLeverage {     GivenDeltaSqrtInterestRate,     GivenLong,     GivenShort,     GivenSum } ```  If the transaction type is  `GivenSum`, both `leverage` and `deleverage` functions of PoolLibrary call `ConstantProduct.updateGivenSumLong` for the sum amount of the long position in the base denomination to be withdrawn, and the short position to be deposited.   ```solidity  } else if (param.transaction == TimeswapV2PoolDeleverage.GivenSum) {  (pool.sqrtInterestRate, longAmount, shortAmount, shortFees) = ConstantProduct.updateGivenSumLong( ... ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L516-L517)  ```solidity } else if (param.transaction == TimeswapV2PoolLeverage.GivenSum) {  (pool.sqrtInterestRate, longAmount, shortAmount, ) = ConstantProduct.updateGivenSumLong( ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L602-L603)     `updateGivenSumLong` updates the new square root interest rate given the sum of long positions in base denomination change and short position change;     ```solidity     function updateGivenSumLong(         uint160 liquidity,         uint160 rate,         uint256 sumAmount,         uint96 duration,         uint256 transactionFee,         bool isAdd     ) internal pure returns (uint160 newRate, uint256 longAmount, uint256 shortAmount, uint256 fees) {         uint256 amount = getShortOrLongFromGivenSum(liquidity, rate, sumAmount, duration, transactionFee, isAdd);          if (isAdd) (newRate, ) = getNewSqrtInterestRateGivenShort(liquidity, rate, amount, duration, false);         else newRate = getNewSqrtInterestRateGivenLong(liquidity, rate, amount, false);          fees = FeeCalculation.getFeesRemoval(amount, transactionFee);         amount -= fees;          if (isAdd) {             shortAmount = amount;             longAmount = sumAmount - shortAmount;         } else {             longAmount = amount;             shortAmount = sumAmount - longAmount;         }     } ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L230-L253)  And `updateGivenSumLong` calls `getShortOrLongFromGivenSum` in order to return the `amount` which represents the short amount or long amount calculated.  ```solidity     function getShortOrLongFromGivenSum(uint160 liquidity, uint160 rate, uint256 sumAmount, uint96 duration, uint256 transactionFee, bool isShort) private pure returns (uint256 amount) {         uint256 negativeB = calculateNegativeB(liquidity, rate, sumAmount, duration, transactionFee, isShort);         uint256 sqrtDiscriminant = calculateSqrtDiscriminant(liquidity, rate, sumAmount, duration, transactionFee, negativeB, isShort);         amount = (negativeB - sqrtDiscriminant).shr(1, false);     } ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L356-L362)  And the formula needs `sqrtDiscriminant` value to calculate the `amount` and it calls `calculateSqrtDiscriminant` [accordingly](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L395)  `calculateSqrtDiscriminant` function performs a bunch of checks and carries out mathematical functions to return the SqrtDiscriminant by utilizing FullMath and Math libraries.    ```solidity  sqrtDiscriminant = FullMath.sqrt512(b0, b1, true);  ```  [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L430)  The `sqrt` formula in the Math contract uses the modified version of [Babylonian Method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method) when flags are included.  ```solidity     function sqrt(uint256 value, bool roundUp) internal pure returns (uint256 result) {          if (value == type(uint256).max) return result = type(uint128).max;         if (value == 0) return 0;         unchecked {             uint256 estimate = (value + 1) >> 1;             result = value;             while (estimate < result) {                 result = estimate;                 estimate = (value / estimate + estimate) >> 1;             }         }          if (roundUp && value % result != 0) result++;     } ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-library/src/Math.sol#L69-L79)  However, when the parameter `roundUp` is passed as `true`, this results in inconsistent behavior for different values. And it's being passed as true as can be seen [here](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L430)).  In order to show some examples let's pass the numbers as values and flag them true by using Math's `sqrt` function.   Values |1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30| --- | --- | --- | --- |--- |--- |--- |--- |--- |--- |--- |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|--- Results |1|1|1|2|3|**2**|3|**2**|3|4|4|**3**|4|4|**3**|4|5|5|5|**4**|5|5|5|**4**|5|6|6|6|6|**5**|     As can be seen from the table, the results are not distributed logically. And many times the result is steeply lesser than its neighbor results. (E.g Sqrt(6) ->2, Sqrt(15)->3 etc.)  The phenomenon occurs most if the values are small numbers.   So if the parameter  `value1` in `FullMath.sqrt512` is passed/calculated as zero value, it has a high chance of providing a wrong calculation as a result with the line below; ```solidity     function sqrt512(uint256 value0, uint256 value1, bool roundUp) internal pure returns (uint256 result) {         if (value1 == 0) result = value0.sqrt(roundUp); ``` This may lead wrong calculation of the `sqrtDiscriminant`, hence the wrong calculation of short or long amounts for the given transaction. The users might lose financial value due to this. Accordingly, the protocol might lose unspent fees as well.  While the fewer values are affected more on this one, the pools with fewer token decimals and fewer token amounts are more affected by this error. As an example, a [Gemini Dollar](https://coinmarketcap.com/currencies/gemini-dollar/) pool (59th rank on CMC and having 2 decimals) would be subject to false returns.  ## Tools Used Manual Review, Remix, Excel ## Recommended Mitigation Steps The team might consider not using `true` flag for `Math.sqrt` function.
# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2PoolFactory.sol#L37 https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L184-L199 https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/base/OwnableTwoSteps.sol#L23-L32   # Vulnerability details  ## Impact If the pool factory gets deployed with `chosenOwner` as address(0) the factory owner will be address(0) and there will be no way of changing the owner address back to the intended owner. If this factory owner did not realize the mistake and deployed lots of pools through the factory, the protocol fees will be locked forever.  There will be no way for the intended factory owner to collect the protocol fees.  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L184-L199  ```     function collectProtocolFees(TimeswapV2PoolCollectParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {         ParamLibrary.check(param);         raiseGuard(param.strike, param.maturity);          // Can only be called by the TimeswapV2Pool factory owner.         ITimeswapV2PoolFactory(poolFactory).owner().checkIfOwner();          // Calculate the main logic of protocol fee.         (long0Amount, long1Amount, shortAmount) = pools[param.strike][param.maturity].collectProtocolFees(param.long0Requested, param.long1Requested, param.shortRequested);          collect(param.strike, param.maturity, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);          lowerGuard(param.strike, param.maturity);          emit CollectProtocolFees(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);     } ```  ## Proof of Concept  ``` //SPDX-License-Identifier: Unlicense pragma solidity 0.8.8;  import "forge-std/Test.sol";  //import "@timeswap-labs/v2-pool/src/TimeswapV2Pool.sol"; import "@timeswap-labs/v2-option/src/TimeswapV2OptionFactory.sol"; import "@timeswap-labs/v2-pool/src/interfaces/ITimeswapV2Pool.sol"; import "@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol"; import "@timeswap-labs/v2-pool/src/TimeswapV2PoolFactory.sol";  import "@helpers/HelperERC20.sol";  contract ContractTest is Test {     TimeswapV2OptionFactory optionFactory;     TimeswapV2PoolFactory poolFactory;      ITimeswapV2Option opPair;     ITimeswapV2Pool pool;      HelperERC20 tokenA;     HelperERC20 tokenB;      // random values     uint256 chosenTransactionFee = 5;     uint256 chosenProtocolFee = 4;      address deployer = vm.addr(1);      address alice = vm.addr(2);      function setUp() public {}      function testOwner() public {         optionFactory = new TimeswapV2OptionFactory();         tokenA = new HelperERC20("Token A", "A");         tokenB = new HelperERC20("Token B", "B");         address opAddress = optionFactory.create(             address(tokenA),             address(tokenB)         );         opPair = ITimeswapV2Option(opAddress);         poolFactory = new TimeswapV2PoolFactory(             address(0),             chosenTransactionFee,             chosenProtocolFee         );         pool = ITimeswapV2Pool(poolFactory.create(opAddress));          console.log("pool factory owner", poolFactory.owner());         console.log("pool factory pending owner", poolFactory.pendingOwner());          console.log("Setting pending owner to alice");         poolFactory.setPendingOwner(address(alice));                   console.log("pool factory owner", poolFactory.owner());         console.log("pool factory pending owner", poolFactory.pendingOwner());     } } ```  and the output: ```   pool factory owner 0x0000000000000000000000000000000000000000   pool factory pending owner 0x0000000000000000000000000000000000000000   Setting pending owner to alice  Test result: FAILED. 0 passed; 1 failed; finished in 9.22ms  Failing tests: Encountered 1 failing test in test/m01.t.sol:ContractTest [FAIL. Reason: NotTheOwner(0x34A1D3fff3958843C43aD80F30b94c510645C316, 0x0000000000000000000000000000000000000000)] testOwner() (gas: 15246385)  Encountered a total of 1 failing tests, 0 tests succeeded ```  ## Tools Used Manual review  ## Recommended Mitigation Steps In the constructor check for zero address or make the owner msg.sender, where the deployer could the call the setPendingOwner function to set the new owner. setPendingOwner checks for zero address.  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/base/OwnableTwoSteps.sol#L23-L32  ```     function setPendingOwner(address chosenPendingOwner) external override {         Ownership.checkIfOwner(owner);          if (chosenPendingOwner == address(0)) Error.zeroAddress();         chosenPendingOwner.checkIfAlreadyOwner(owner);          pendingOwner = chosenPendingOwner;          emit SetOwner(pendingOwner);     } ``` 
# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-library/src/FullMath.sol#L62   # Vulnerability details  ## Impact The vulnerability originate from insufficient checking in add512 function, where the AddOverflow revert gets bypassed, essentially the function assumes that an overflow only happen if (addendA1 > sum1), where in the case that it's possible for it overflow in the case that addendA1 == sum1, which can be resulted through assigning a value that makes ( lt(sum0, addendA0) == 1 ) <=> sum0 < addendA0, which can only be achieved normally by overflowing the least significant addition. then we can simply break the overflow check by assigning an overflowing values which results in add(addendA1, addendB1) > type(256).max && addendA1 <= sum1, then we will manage to bypass the revert check and overflow the most significant part of add512 values.  the previous attack vector can lead to a manipulation in leverage and deleverage functions, in a way that it would result in more tokens for the user ## Proof of Concept inputing the following values result in an overflow: uint256 addendA0 = 1 uint256 addendA1 = 100 uint256 addendB0 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 (uint256 max value) uint256 addendB1 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 (uint256 max value)  results in: sum0 = 0 sum1 = 100  the expected behavior is to revert since, A1 + B1 result in a value that overflows, but instead consider it as a valid behavior due to the insufficient checking.  Abstraction: A1 - A0                  + B1 - B0                 = S1 - S0  S0 = A0 + B0 S1 = A1 + B1 + ( if S0 overflows [+ 1]) ensure A1 <= S1 revert only on A1 > S1  in the case of S0 overflows: S1 = A1 + B1 + 1  require(A1 <= S1) is not most suited check, due to the fact that in the case of A1 == S1 check, it can still overflows if S1 = A1 + B1 + 1 overflows. which would bypass A1 > S1 revert check.  the major impact affects the leverage() and deleverage() result in values which are not expected.  ## Tools Used  ## Recommended Mitigation Steps  add a an equality check for if statement in add512 function.  ```    function add512(uint256 addendA0, uint256 addendA1, uint256 addendB0, uint256 addendB1) public pure returns (uint256 sum0, uint256 sum1) {         assembly {             sum0 := add(addendA0, addendB0)             carry  := lt(sum0, addendA0)             sum1 := add(add(addendA1, addendB1), carry)         }         if (addendA1 > sum1 ||      ((sum1 == addendA1 || sum1 == addendB1) && (carry < addendA0 || carry < addendB0)) ) revert AddOverflow(addendA0, addendA1, addendB0, addendB1); //      } ```
# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302 https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/LiquidityPosition.sol#L60   # Vulnerability details  ## Impact When a LP mints V2 Pool tokens, `mint` function in [PoolLibrary](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302) gets called. Inside this function,  `updateDurationWeightBeforeMaturity` updates global `short`, `long0` and `long1` fee growth.   Change in global fee growth necessitates an update to `LiquidityPosition` state of caller (specifically updating fees & fee growth rates) when there are state changes made to that position (in this case, increasing liquidity). This principle is followed in functions such as `burn`, `transferLiquidity`, `transferFees`. However when calling `mint`, this update is missing. As a result, `growth` & `fee` levels in liquidity position of caller are inconsistent with global fee growth rates.   Inconsistent state leads to incorrect calculations of long0/long1 and short fees of LP holders which inturn can lead to loss of fees. Since this impacts actual rewards for users, I've marked it as MEDIUM risk  ## Proof of Concept  Let's say, Bob has following sequence of events  - MINT at T0: Bob is a LP who mints N pool tokens at T0  - MINT at T1: Bob mints another M pool tokens at T1. At this point, had the protocol correctly updated fees before minting new pool tokens, Bob's fees & growth rate would be a function of current liquidity (N), global updated short fee growth rate at t1 (s_t1) and Bob's previous growth rate at t_0 (b_t0)  - BURN at T2: Bob burns N + M tokens at T2. At this point, Bob's fees should be a function of previous liquidity (N+M), global short fee growth rate (s_t2) and Bob's previous growth rate at t_1(b_t1) -> since this update never happened, Bob's previous growth rate is wrongly referenced b_t0 instead of b_t1.   Bob could collect a lower fees because of this state inconsistency  ## Tools Used  ## Recommended Mitigation Steps Update the liquidity position state right before minting.  After [line 302 of Pool.sol](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302), update the LiquidityPosition by adding  ```   liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth); ```
# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-token/src/TimeswapV2LiquidityToken.sol#L193   # Vulnerability details  ## Impact Detailed description of the impact of this finding. The ``collect()`` function will always transfer ZERO fees. At the same time, non-zero ``_fessPosition`` will be burned.  ``` _feesPositions[id][msg.sender].burn(long0Fees, long1Fees, shortFees); ``` As a result, the contracts will be left in an inconsistent state. The user will burn ``_feesPositions`` without receiving the the  fees!  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. The ``collect()`` function will always transfer ZERO fees   in the following line:  ```  // transfer the fees amount to the recipient         ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);  ``` This is because, at this moment, the values of  ``long0Fees``, ``long1Fees``, ``shortFees`` have not been calculated yet, actually, they will be equal to zero. Therefore, no fees will be transferred. The values of  ``long0Fees``, ``long1Fees``, ``shortFees`` are calculated afterwards by the following line: ``` (long0Fees, long1Fees, shortFees) = _feesPositions[id][msg.sender].getFees(param.long0FeesDesired, param.long1FeesDesired, param.shortFeesDesired);  ``` Therefore, ``ITimeswapV2Pool(poolPair).transferFees`` must be called after this line to be correct.   ## Tools Used Remix  ## Recommended Mitigation Steps We moved the line  ``ITimeswapV2Pool(poolPair).transferFees`` after ``long0Fees``, ``long1Fees``, ``shortFees`` have been calculated first.   ``` function collect(TimeswapV2LiquidityTokenCollectParam calldata param) external returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees, bytes memory data) {         ParamLibrary.check(param);          bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();          // start the reentrancy guard         raiseGuard(key);          (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);           uint256 id = _timeswapV2LiquidityTokenPositionIds[key];          _updateFeesPositions(msg.sender, address(0), id);          (long0Fees, long1Fees, shortFees) = _feesPositions[id][msg.sender].getFees(param.long0FeesDesired, param.long1FeesDesired, param.shortFeesDesired);          if (param.data.length != 0)             data = ITimeswapV2LiquidityTokenCollectCallback(msg.sender).timeswapV2LiquidityTokenCollectCallback(                 TimeswapV2LiquidityTokenCollectCallbackParam({                     token0: param.token0,                     token1: param.token1,                     strike: param.strike,                     maturity: param.maturity,                     long0Fees: long0Fees,                     long1Fees: long1Fees,                     shortFees: shortFees,                     data: param.data                 })             );                  // transfer the fees amount to the recipient         ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);           // burn the desired fees from the fees position         _feesPositions[id][msg.sender].burn(long0Fees, long1Fees, shortFees);          if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _removeTokenEnumeration(msg.sender, address(0), id, 0);          // stop the reentrancy guard         lowerGuard(key);     } ```
# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L679   # Vulnerability details  ## Impact The important states including `long0Balance, long1Balance, long1FeeGrowth, long1ProtocolFees` are wrongly calculated and it breaks the pool's invariant.  ## Proof of Concept The protocol provides a rebalancing functionality and the main logic is implemented in the library `Pool.sol`. If `param.isLong0ToLong1` is true and the transaction is `TimeswapV2PoolRebalance.GivenLong1`, the protocol calculates the `long1AmountAdjustFees` first and the actual `long0Amount, longFees` and the final `long1Balance` is decided accordingly. The problem is it is using the wrong parameter `pool.long0Balance` while it is supposed to use `pool.long1Balance` in the line L679.  This leads to wrong state calculation in the following logic. (especially L685 is setting the `long1Balance` to zero). Furthermore, the protocol is designed as a permission-less one and anyone can call `TimeswapV2Pool.rebalance()`. An attacker can abuse this to break the pool's invariant and take profit leveraging that.  ```solidity packages\v2-pool\src\structs\Pool.sol 665:     function rebalance(Pool storage pool, TimeswapV2PoolRebalanceParam memory param, uint256 transactionFee, uint256 protocolFee) external returns (uint256 long0Amount, uint256 long1Amount) { 666:         if (pool.liquidity == 0) Error.requireLiquidity(); 667: 668:         // No need to update short fee growth. 669: 670:         uint256 longFees; 671:         if (param.isLong0ToLong1) { 672:             if (param.transaction == TimeswapV2PoolRebalance.GivenLong0) { 673:                 (long1Amount, longFees) = ConstantSum.calculateGivenLongIn(param.strike, long0Amount = param.delta, transactionFee, true); 674: 675:                 if (long1Amount == 0) Error.zeroOutput(); 676: 677:                 pool.long1Balance -= (long1Amount + longFees); 678:             } else if (param.transaction == TimeswapV2PoolRebalance.GivenLong1) {     //************************************************************ 679:                 uint256 long1AmountAdjustFees = FeeCalculation.removeFees(pool.long0Balance, transactionFee);//@audit-info long0Balance -> long1Balance     //************************************************************ 680: 681:                 if ((long1Amount = param.delta) == long1AmountAdjustFees) { 682:                     long0Amount = ConstantSum.calculateGivenLongOutAlreadyAdjustFees(param.strike, pool.long1Balance, true); 683: 684:                     longFees = pool.long1Balance.unsafeSub(long1Amount); 685:                     pool.long1Balance = 0; 686:                 } else { 687:                     (long0Amount, longFees) = ConstantSum.calculateGivenLongOut(param.strike, long1Amount, transactionFee, true); 688: 689:                     pool.long1Balance -= (long1Amount + longFees); 690:                 } 691: 692:                 if (long0Amount == 0) Error.zeroOutput(); 693:             } 694: 695:             pool.long0Balance += long0Amount; 696: 697:             (pool.long1FeeGrowth, pool.long1ProtocolFees) = FeeCalculation.update(pool.liquidity, pool.long1FeeGrowth, pool.long1ProtocolFees, longFees, protocolFee); 698:         } else { 699:             if (param.transaction == TimeswapV2PoolRebalance.GivenLong0) { 700:                 uint256 long0AmountAdjustFees = FeeCalculation.removeFees(pool.long0Balance, transactionFee);//@audit-info 701: 702:                 if ((long0Amount = param.delta) == long0AmountAdjustFees) { 703:                     long1Amount = ConstantSum.calculateGivenLongOutAlreadyAdjustFees(param.strike, pool.long0Balance, false); 704: 705:                     longFees = pool.long0Balance.unsafeSub(long0Amount); 706:                     pool.long0Balance = 0; 707:                 } else { 708:                     (long1Amount, longFees) = ConstantSum.calculateGivenLongOut(param.strike, long0Amount, transactionFee, false); 709: 710:                     pool.long0Balance -= (long0Amount + longFees); 711:                 } 712: 713:                 if (long1Amount == 0) Error.zeroOutput(); 714:             } else if (param.transaction == TimeswapV2PoolRebalance.GivenLong1) { 715:                 (long0Amount, longFees) = ConstantSum.calculateGivenLongIn(param.strike, long1Amount = param.delta, transactionFee, false); 716: 717:                 if (long0Amount == 0) Error.zeroOutput(); 718: 719:                 pool.long0Balance -= (long0Amount + longFees); 720:             } 721: 722:             pool.long1Balance += long1Amount; 723: 724:             (pool.long0FeeGrowth, pool.long0ProtocolFees) = FeeCalculation.update(pool.liquidity, pool.long0FeeGrowth, pool.long0ProtocolFees, longFees, protocolFee); 725:         } 726:     } ``` ## Tools Used Manual Review  ## Recommended Mitigation Steps Fix the L679 as below. ```solidity uint256 long1AmountAdjustFees = FeeCalculation.removeFees(pool.long1Balance, transactionFee); ```
# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-library/src/Math.sol#L69-L79   # Vulnerability details  ## Impact Due to the wrong calculation of short and long tokens during the `leverage` and `deleverage` process, the users can suffer financial loss while the protocol will lose fees  ## Proof of Concept The protocol uses `leverage` function to deposit short tokens and receive long tokens. On the opposite, `deleverage` function serves for depositing long tokens and receiving short tokens.  [Leverage Function of TimeswapV2Pool contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L430-L466) [Deleverage Function of TimeswapV2Pool contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L377-L418)  Both functions call the PoolLibrary's `leverage` and `deleverage` functions after input sanitization.  [Leverage Function of PoolLibrary contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L552-L655) [Deleverage Function of PoolLibrary contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L469-L539)   PoolLibrary's `leverage` and `deleverage` functions update the state of the pool first for the fee growth and compute the `long0Amount`, `long1Amount`, and `shortAmount`. It also checks the transaction type according to the passed parameter types as per the `Transaction` contract's enum types below and calls `ConstantProduct`'s appropriate function accordingly;  ```solidity /// @dev The different kind of deleverage transactions. enum TimeswapV2PoolDeleverage {     GivenDeltaSqrtInterestRate,     GivenLong,     GivenShort,     GivenSum }  /// @dev The different kind of leverage transactions. enum TimeswapV2PoolLeverage {     GivenDeltaSqrtInterestRate,     GivenLong,     GivenShort,     GivenSum } ```  If the transaction type is  `GivenSum`, both `leverage` and `deleverage` functions of PoolLibrary call `ConstantProduct.updateGivenSumLong` for the sum amount of the long position in the base denomination to be withdrawn, and the short position to be deposited.   ```solidity  } else if (param.transaction == TimeswapV2PoolDeleverage.GivenSum) {  (pool.sqrtInterestRate, longAmount, shortAmount, shortFees) = ConstantProduct.updateGivenSumLong( ... ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L516-L517)  ```solidity } else if (param.transaction == TimeswapV2PoolLeverage.GivenSum) {  (pool.sqrtInterestRate, longAmount, shortAmount, ) = ConstantProduct.updateGivenSumLong( ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L602-L603)     `updateGivenSumLong` updates the new square root interest rate given the sum of long positions in base denomination change and short position change;     ```solidity     function updateGivenSumLong(         uint160 liquidity,         uint160 rate,         uint256 sumAmount,         uint96 duration,         uint256 transactionFee,         bool isAdd     ) internal pure returns (uint160 newRate, uint256 longAmount, uint256 shortAmount, uint256 fees) {         uint256 amount = getShortOrLongFromGivenSum(liquidity, rate, sumAmount, duration, transactionFee, isAdd);          if (isAdd) (newRate, ) = getNewSqrtInterestRateGivenShort(liquidity, rate, amount, duration, false);         else newRate = getNewSqrtInterestRateGivenLong(liquidity, rate, amount, false);          fees = FeeCalculation.getFeesRemoval(amount, transactionFee);         amount -= fees;          if (isAdd) {             shortAmount = amount;             longAmount = sumAmount - shortAmount;         } else {             longAmount = amount;             shortAmount = sumAmount - longAmount;         }     } ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L230-L253)  And `updateGivenSumLong` calls `getShortOrLongFromGivenSum` in order to return the `amount` which represents the short amount or long amount calculated.  ```solidity     function getShortOrLongFromGivenSum(uint160 liquidity, uint160 rate, uint256 sumAmount, uint96 duration, uint256 transactionFee, bool isShort) private pure returns (uint256 amount) {         uint256 negativeB = calculateNegativeB(liquidity, rate, sumAmount, duration, transactionFee, isShort);         uint256 sqrtDiscriminant = calculateSqrtDiscriminant(liquidity, rate, sumAmount, duration, transactionFee, negativeB, isShort);         amount = (negativeB - sqrtDiscriminant).shr(1, false);     } ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L356-L362)  And the formula needs `sqrtDiscriminant` value to calculate the `amount` and it calls `calculateSqrtDiscriminant` [accordingly](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L395)  `calculateSqrtDiscriminant` function performs a bunch of checks and carries out mathematical functions to return the SqrtDiscriminant by utilizing FullMath and Math libraries.    ```solidity  sqrtDiscriminant = FullMath.sqrt512(b0, b1, true);  ```  [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L430)  The `sqrt` formula in the Math contract uses the modified version of [Babylonian Method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method) when flags are included.  ```solidity     function sqrt(uint256 value, bool roundUp) internal pure returns (uint256 result) {          if (value == type(uint256).max) return result = type(uint128).max;         if (value == 0) return 0;         unchecked {             uint256 estimate = (value + 1) >> 1;             result = value;             while (estimate < result) {                 result = estimate;                 estimate = (value / estimate + estimate) >> 1;             }         }          if (roundUp && value % result != 0) result++;     } ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-library/src/Math.sol#L69-L79)  However, when the parameter `roundUp` is passed as `true`, this results in inconsistent behavior for different values. And it's being passed as true as can be seen [here](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L430)).  In order to show some examples let's pass the numbers as values and flag them true by using Math's `sqrt` function.   Values |1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30| --- | --- | --- | --- |--- |--- |--- |--- |--- |--- |--- |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|--- Results |1|1|1|2|3|**2**|3|**2**|3|4|4|**3**|4|4|**3**|4|5|5|5|**4**|5|5|5|**4**|5|6|6|6|6|**5**|     As can be seen from the table, the results are not distributed logically. And many times the result is steeply lesser than its neighbor results. (E.g Sqrt(6) ->2, Sqrt(15)->3 etc.)  The phenomenon occurs most if the values are small numbers.   So if the parameter  `value1` in `FullMath.sqrt512` is passed/calculated as zero value, it has a high chance of providing a wrong calculation as a result with the line below; ```solidity     function sqrt512(uint256 value0, uint256 value1, bool roundUp) internal pure returns (uint256 result) {         if (value1 == 0) result = value0.sqrt(roundUp); ``` This may lead wrong calculation of the `sqrtDiscriminant`, hence the wrong calculation of short or long amounts for the given transaction. The users might lose financial value due to this. Accordingly, the protocol might lose unspent fees as well.  While the fewer values are affected more on this one, the pools with fewer token decimals and fewer token amounts are more affected by this error. As an example, a [Gemini Dollar](https://coinmarketcap.com/currencies/gemini-dollar/) pool (59th rank on CMC and having 2 decimals) would be subject to false returns.  ## Tools Used Manual Review, Remix, Excel ## Recommended Mitigation Steps The team might consider not using `true` flag for `Math.sqrt` function.
# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2PoolFactory.sol#L37 https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L184-L199 https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/base/OwnableTwoSteps.sol#L23-L32   # Vulnerability details  ## Impact If the pool factory gets deployed with `chosenOwner` as address(0) the factory owner will be address(0) and there will be no way of changing the owner address back to the intended owner. If this factory owner did not realize the mistake and deployed lots of pools through the factory, the protocol fees will be locked forever.  There will be no way for the intended factory owner to collect the protocol fees.  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L184-L199  ```     function collectProtocolFees(TimeswapV2PoolCollectParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {         ParamLibrary.check(param);         raiseGuard(param.strike, param.maturity);          // Can only be called by the TimeswapV2Pool factory owner.         ITimeswapV2PoolFactory(poolFactory).owner().checkIfOwner();          // Calculate the main logic of protocol fee.         (long0Amount, long1Amount, shortAmount) = pools[param.strike][param.maturity].collectProtocolFees(param.long0Requested, param.long1Requested, param.shortRequested);          collect(param.strike, param.maturity, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);          lowerGuard(param.strike, param.maturity);          emit CollectProtocolFees(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);     } ```  ## Proof of Concept  ``` //SPDX-License-Identifier: Unlicense pragma solidity 0.8.8;  import "forge-std/Test.sol";  //import "@timeswap-labs/v2-pool/src/TimeswapV2Pool.sol"; import "@timeswap-labs/v2-option/src/TimeswapV2OptionFactory.sol"; import "@timeswap-labs/v2-pool/src/interfaces/ITimeswapV2Pool.sol"; import "@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol"; import "@timeswap-labs/v2-pool/src/TimeswapV2PoolFactory.sol";  import "@helpers/HelperERC20.sol";  contract ContractTest is Test {     TimeswapV2OptionFactory optionFactory;     TimeswapV2PoolFactory poolFactory;      ITimeswapV2Option opPair;     ITimeswapV2Pool pool;      HelperERC20 tokenA;     HelperERC20 tokenB;      // random values     uint256 chosenTransactionFee = 5;     uint256 chosenProtocolFee = 4;      address deployer = vm.addr(1);      address alice = vm.addr(2);      function setUp() public {}      function testOwner() public {         optionFactory = new TimeswapV2OptionFactory();         tokenA = new HelperERC20("Token A", "A");         tokenB = new HelperERC20("Token B", "B");         address opAddress = optionFactory.create(             address(tokenA),             address(tokenB)         );         opPair = ITimeswapV2Option(opAddress);         poolFactory = new TimeswapV2PoolFactory(             address(0),             chosenTransactionFee,             chosenProtocolFee         );         pool = ITimeswapV2Pool(poolFactory.create(opAddress));          console.log("pool factory owner", poolFactory.owner());         console.log("pool factory pending owner", poolFactory.pendingOwner());          console.log("Setting pending owner to alice");         poolFactory.setPendingOwner(address(alice));                   console.log("pool factory owner", poolFactory.owner());         console.log("pool factory pending owner", poolFactory.pendingOwner());     } } ```  and the output: ```   pool factory owner 0x0000000000000000000000000000000000000000   pool factory pending owner 0x0000000000000000000000000000000000000000   Setting pending owner to alice  Test result: FAILED. 0 passed; 1 failed; finished in 9.22ms  Failing tests: Encountered 1 failing test in test/m01.t.sol:ContractTest [FAIL. Reason: NotTheOwner(0x34A1D3fff3958843C43aD80F30b94c510645C316, 0x0000000000000000000000000000000000000000)] testOwner() (gas: 15246385)  Encountered a total of 1 failing tests, 0 tests succeeded ```  ## Tools Used Manual review  ## Recommended Mitigation Steps In the constructor check for zero address or make the owner msg.sender, where the deployer could the call the setPendingOwner function to set the new owner. setPendingOwner checks for zero address.  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/base/OwnableTwoSteps.sol#L23-L32  ```     function setPendingOwner(address chosenPendingOwner) external override {         Ownership.checkIfOwner(owner);          if (chosenPendingOwner == address(0)) Error.zeroAddress();         chosenPendingOwner.checkIfAlreadyOwner(owner);          pendingOwner = chosenPendingOwner;          emit SetOwner(pendingOwner);     } ``` 
# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-library/src/FullMath.sol#L62   # Vulnerability details  ## Impact The vulnerability originate from insufficient checking in add512 function, where the AddOverflow revert gets bypassed, essentially the function assumes that an overflow only happen if (addendA1 > sum1), where in the case that it's possible for it overflow in the case that addendA1 == sum1, which can be resulted through assigning a value that makes ( lt(sum0, addendA0) == 1 ) <=> sum0 < addendA0, which can only be achieved normally by overflowing the least significant addition. then we can simply break the overflow check by assigning an overflowing values which results in add(addendA1, addendB1) > type(256).max && addendA1 <= sum1, then we will manage to bypass the revert check and overflow the most significant part of add512 values.  the previous attack vector can lead to a manipulation in leverage and deleverage functions, in a way that it would result in more tokens for the user ## Proof of Concept inputing the following values result in an overflow: uint256 addendA0 = 1 uint256 addendA1 = 100 uint256 addendB0 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 (uint256 max value) uint256 addendB1 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 (uint256 max value)  results in: sum0 = 0 sum1 = 100  the expected behavior is to revert since, A1 + B1 result in a value that overflows, but instead consider it as a valid behavior due to the insufficient checking.  Abstraction: A1 - A0                  + B1 - B0                 = S1 - S0  S0 = A0 + B0 S1 = A1 + B1 + ( if S0 overflows [+ 1]) ensure A1 <= S1 revert only on A1 > S1  in the case of S0 overflows: S1 = A1 + B1 + 1  require(A1 <= S1) is not most suited check, due to the fact that in the case of A1 == S1 check, it can still overflows if S1 = A1 + B1 + 1 overflows. which would bypass A1 > S1 revert check.  the major impact affects the leverage() and deleverage() result in values which are not expected.  ## Tools Used  ## Recommended Mitigation Steps  add a an equality check for if statement in add512 function.  ```    function add512(uint256 addendA0, uint256 addendA1, uint256 addendB0, uint256 addendB1) public pure returns (uint256 sum0, uint256 sum1) {         assembly {             sum0 := add(addendA0, addendB0)             carry  := lt(sum0, addendA0)             sum1 := add(add(addendA1, addendB1), carry)         }         if (addendA1 > sum1 ||      ((sum1 == addendA1 || sum1 == addendB1) && (carry < addendA0 || carry < addendB0)) ) revert AddOverflow(addendA0, addendA1, addendB0, addendB1); //      } ```
# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302 https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/LiquidityPosition.sol#L60   # Vulnerability details  ## Impact When a LP mints V2 Pool tokens, `mint` function in [PoolLibrary](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302) gets called. Inside this function,  `updateDurationWeightBeforeMaturity` updates global `short`, `long0` and `long1` fee growth.   Change in global fee growth necessitates an update to `LiquidityPosition` state of caller (specifically updating fees & fee growth rates) when there are state changes made to that position (in this case, increasing liquidity). This principle is followed in functions such as `burn`, `transferLiquidity`, `transferFees`. However when calling `mint`, this update is missing. As a result, `growth` & `fee` levels in liquidity position of caller are inconsistent with global fee growth rates.   Inconsistent state leads to incorrect calculations of long0/long1 and short fees of LP holders which inturn can lead to loss of fees. Since this impacts actual rewards for users, I've marked it as MEDIUM risk  ## Proof of Concept  Let's say, Bob has following sequence of events  - MINT at T0: Bob is a LP who mints N pool tokens at T0  - MINT at T1: Bob mints another M pool tokens at T1. At this point, had the protocol correctly updated fees before minting new pool tokens, Bob's fees & growth rate would be a function of current liquidity (N), global updated short fee growth rate at t1 (s_t1) and Bob's previous growth rate at t_0 (b_t0)  - BURN at T2: Bob burns N + M tokens at T2. At this point, Bob's fees should be a function of previous liquidity (N+M), global short fee growth rate (s_t2) and Bob's previous growth rate at t_1(b_t1) -> since this update never happened, Bob's previous growth rate is wrongly referenced b_t0 instead of b_t1.   Bob could collect a lower fees because of this state inconsistency  ## Tools Used  ## Recommended Mitigation Steps Update the liquidity position state right before minting.  After [line 302 of Pool.sol](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302), update the LiquidityPosition by adding  ```   liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth); ```
# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-token/src/TimeswapV2LiquidityToken.sol#L193   # Vulnerability details  ## Impact Detailed description of the impact of this finding. The ``collect()`` function will always transfer ZERO fees. At the same time, non-zero ``_fessPosition`` will be burned.  ``` _feesPositions[id][msg.sender].burn(long0Fees, long1Fees, shortFees); ``` As a result, the contracts will be left in an inconsistent state. The user will burn ``_feesPositions`` without receiving the the  fees!  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. The ``collect()`` function will always transfer ZERO fees   in the following line:  ```  // transfer the fees amount to the recipient         ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);  ``` This is because, at this moment, the values of  ``long0Fees``, ``long1Fees``, ``shortFees`` have not been calculated yet, actually, they will be equal to zero. Therefore, no fees will be transferred. The values of  ``long0Fees``, ``long1Fees``, ``shortFees`` are calculated afterwards by the following line: ``` (long0Fees, long1Fees, shortFees) = _feesPositions[id][msg.sender].getFees(param.long0FeesDesired, param.long1FeesDesired, param.shortFeesDesired);  ``` Therefore, ``ITimeswapV2Pool(poolPair).transferFees`` must be called after this line to be correct.   ## Tools Used Remix  ## Recommended Mitigation Steps We moved the line  ``ITimeswapV2Pool(poolPair).transferFees`` after ``long0Fees``, ``long1Fees``, ``shortFees`` have been calculated first.   ``` function collect(TimeswapV2LiquidityTokenCollectParam calldata param) external returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees, bytes memory data) {         ParamLibrary.check(param);          bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();          // start the reentrancy guard         raiseGuard(key);          (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);           uint256 id = _timeswapV2LiquidityTokenPositionIds[key];          _updateFeesPositions(msg.sender, address(0), id);          (long0Fees, long1Fees, shortFees) = _feesPositions[id][msg.sender].getFees(param.long0FeesDesired, param.long1FeesDesired, param.shortFeesDesired);          if (param.data.length != 0)             data = ITimeswapV2LiquidityTokenCollectCallback(msg.sender).timeswapV2LiquidityTokenCollectCallback(                 TimeswapV2LiquidityTokenCollectCallbackParam({                     token0: param.token0,                     token1: param.token1,                     strike: param.strike,                     maturity: param.maturity,                     long0Fees: long0Fees,                     long1Fees: long1Fees,                     shortFees: shortFees,                     data: param.data                 })             );                  // transfer the fees amount to the recipient         ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);           // burn the desired fees from the fees position         _feesPositions[id][msg.sender].burn(long0Fees, long1Fees, shortFees);          if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _removeTokenEnumeration(msg.sender, address(0), id, 0);          // stop the reentrancy guard         lowerGuard(key);     } ```
