# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259 https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566 https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142   # Vulnerability details  If the reserved rate of a tier is set to a value > `JBConstants.MAX_RESERVED_RATE`, the `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor` function will return way more outstanding reserved tokens (up to ~6 times more than allowed - **2^16 - 1** due to the manual cast of `reservedRate` to `uint16` divided by `JBConstants.MAX_RESERVED_RATE = 10_000`). This inflated value is used in the `JBTiered721DelegateStore.totalRedemptionWeight` function to calculate the cumulative redemption weight of all tokens across all tiers.  This higher-than-expected redemption weight will lower the `reclaimAmount` calculated in the `JB721Delegate.redeemParams` function. Depending on the values of `_data.overflow` and `_redemptionWeight`, the calculated `reclaimAmount` can be **0** (due to rounding down, [see here](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142)) or a smaller than anticipated value, leading to burned NFT tokens from the user and no redemptions.  ## Impact  The owner of an NFT contract can add tiers with higher than usual reserved rates (and mint an appropriate number of NFTs to bypass all conditions in the `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor`), which will lead to a lower-than-expected redemption amount for users.  ## Proof of Concept  [JBTiered721DelegateStore.\_numberOfReservedTokensOutstandingFor](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259)  ```solidity function _numberOfReservedTokensOutstandingFor(   address _nft,   uint256 _tierId,   JBStored721Tier memory _storedTier ) internal view returns (uint256) {   // Invalid tier or no reserved rate?   if (_storedTier.initialQuantity == 0 || _storedTier.reservedRate == 0) return 0;    // No token minted yet? Round up to 1.   if (_storedTier.initialQuantity == _storedTier.remainingQuantity) return 1;    // The number of reserved tokens of the tier already minted.   uint256 _reserveTokensMinted = numberOfReservesMintedFor[_nft][_tierId];    // If only the reserved token (from the rounding up) has been minted so far, return 0.   if (_storedTier.initialQuantity - _reserveTokensMinted == _storedTier.remainingQuantity)     return 0;    // Get a reference to the number of tokens already minted in the tier, not counting reserves or burned tokens.   uint256 _numberOfNonReservesMinted = _storedTier.initialQuantity -     _storedTier.remainingQuantity -     _reserveTokensMinted;    // Store the numerator common to the next two calculations.   uint256 _numerator = uint256(_numberOfNonReservesMinted * _storedTier.reservedRate);    // Get the number of reserved tokens mintable given the number of non reserved tokens minted. This will round down.   uint256 _numberReservedTokensMintable = _numerator / JBConstants.MAX_RESERVED_RATE;    // Round up.   if (_numerator - JBConstants.MAX_RESERVED_RATE * _numberReservedTokensMintable > 0)     ++_numberReservedTokensMintable;    // Return the difference between the amount mintable and the amount already minted.   return _numberReservedTokensMintable - _reserveTokensMinted; } ```  [JBTiered721DelegateStore.totalRedemptionWeight](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566)  The `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor` function is called from within the `JBTiered721DelegateStore.totalRedemptionWeight` function. This allows for inflating the total redemption weight.  ```solidity function totalRedemptionWeight(address _nft) public view override returns (uint256 weight) {   // Keep a reference to the greatest tier ID.   uint256 _maxTierId = maxTierIdOf[_nft];    // Keep a reference to the tier being iterated on.   JBStored721Tier memory _storedTier;    // Add each token's tier's contribution floor to the weight.   for (uint256 _i; _i < _maxTierId; ) {     // Keep a reference to the stored tier.     _storedTier = _storedTierOf[_nft][_i + 1];      // Add the tier's contribution floor multiplied by the quantity minted.     weight +=       (_storedTier.contributionFloor *         (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +       _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);      unchecked {       ++_i;     }   } } ```  [JBTiered721Delegate.\_totalRedemptionWeight](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L712)  `JBTiered721DelegateStore.totalRedemptionWeight` is called in the `JBTiered721Delegate._totalRedemptionWeight` function.  ```solidity function _totalRedemptionWeight() internal view virtual override returns (uint256) {   return store.totalRedemptionWeight(address(this)); } ```  [abstract/JB721Delegate.redeemParams](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L139)  This `JBTiered721Delegate._totalRedemptionWeight` function is then called in the `JB721Delegate.redeemParams` function, which ultimately calculates the `reclaimAmount` given an overflow and `_decodedTokenIds`.  `uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);` in [line 142](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142) will lead to a lower `_base` due to the inflated denumerator `_total`.  ```solidity function redeemParams(JBRedeemParamsData calldata _data)   external   view   override   returns (     uint256 reclaimAmount,     string memory memo,     JBRedemptionDelegateAllocation[] memory delegateAllocations   ) {   // Make sure fungible project tokens aren't being redeemed too.   if (_data.tokenCount > 0) revert UNEXPECTED_TOKEN_REDEEMED();    // Check the 4 bytes interfaceId and handle the case where the metadata was not intended for this contract   if (     _data.metadata.length < 4 || bytes4(_data.metadata[0:4]) != type(IJB721Delegate).interfaceId   ) {     revert INVALID_REDEMPTION_METADATA();   }    // Set the only delegate allocation to be a callback to this contract.   delegateAllocations = new JBRedemptionDelegateAllocation[](1);   delegateAllocations[0] = JBRedemptionDelegateAllocation(this, 0);    // If redemption rate is 0, nothing can be reclaimed from the treasury   if (_data.redemptionRate == 0) return (0, _data.memo, delegateAllocations);    // Decode the metadata   (, uint256[] memory _decodedTokenIds) = abi.decode(_data.metadata, (bytes4, uint256[]));    // Get a reference to the redemption rate of the provided tokens.   uint256 _redemptionWeight = _redemptionWeightOf(_decodedTokenIds);    // Get a reference to the total redemption weight.   uint256 _total = _totalRedemptionWeight(); // @audit-info Uses the inflated total redemption weight    // Get a reference to the linear proportion.   uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.   if (_data.redemptionRate == JBConstants.MAX_REDEMPTION_RATE)     return (_base, _data.memo, delegateAllocations);    // Return the weighted overflow, and this contract as the delegate so that tokens can be deleted.   return (     PRBMath.mulDiv(       _base,       _data.redemptionRate +         PRBMath.mulDiv(           _redemptionWeight,           JBConstants.MAX_REDEMPTION_RATE - _data.redemptionRate,           _total         ),       JBConstants.MAX_REDEMPTION_RATE     ),     _data.memo,     delegateAllocations   ); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider validating the tier reserved rate `reservedRate` in the `JBTiered721DelegateStore.recordAddTiers` function to ensure the reserved rate is not greater than `JBConstants.MAX_RESERVED_RATE`. 
# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566   # Vulnerability details  ## Description  Redemption weight is a concept used in Juicebox to determine investor's eligible percentage of the non-locked funds. In redeemParams, JB721Delegate calculates user's share using:  ``` uint256 _redemptionWeight = _redemptionWeightOf(_decodedTokenIds); uint256 _total = _totalRedemptionWeight(); uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total); ```  _totalRedemptionWeight eventually is implemented in DelegateStore:  ``` for (uint256 _i; _i < _maxTierId; ) {   // Keep a reference to the stored tier.   _storedTier = _storedTierOf[_nft][_i + 1];   // Add the tier's contribution floor multiplied by the quantity minted.   weight +=     (_storedTier.contributionFloor *       (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +     _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);   unchecked {     ++_i;   } } ```  If we pay attention to _numberOfReservedTokensOutstandingFor() call, we can see it is called with tierId = i, yet storedTier of i+1. It is definitely not the intention as for example, recordMintReservesFor() uses the function correctly:  ``` function recordMintReservesFor(uint256 _tierId, uint256 _count)   external   override   returns (uint256[] memory tokenIds) {   // Get a reference to the tier.   JBStored721Tier storage _storedTier = _storedTierOf[msg.sender][_tierId];   // Get a reference to the number of reserved tokens mintable for the tier.   uint256 _numberOfReservedTokensOutstanding = _numberOfReservedTokensOutstandingFor(     msg.sender,     _tierId,     _storedTier   );   ... ```  The impact of this bug is incorrect calculation of the weight of user's contributions. The `initialQuantity` and `remainingQuantity` values are taken from the correct tier, but `_reserveTokensMinted` minted is taken from previous tier. In the case where `_reserveTokensMinted` is smaller than correct value, for example tierID=0 which is empty, the outstanding value returned is larger, meaning weight is larger and redemptions are worth less. In the opposite case, where lower tierID has higher `_reserveTokensMinted`, the redemptions will receive *more* payout than they should.  ## Impact  Users of projects can receive less or more funds than they are eligible for when redeeming NFT rewards.  ## Proof of Concept  1\. Suppose we have a project with 2 tiers, reserve ratio = 50%, redemption ratio = 100%:  |     |     |     |     |     |     | | --- | --- | --- | --- | --- | --- | | Tier | Contribution | Initial quantity | Remaining quantity | Reserves minted | Reserves outstanding | | Tier 1 | 50  | 10  | 3   | 1   | 2   | | Tier 2 | 100 | 30  | 2   | 8   | 2   |  When calculating totalRedemptionWeight(), the correct result is  50 * (10 - 3) + 2 + 100 * (30-2) + 2 = 3154  The wrong result will be:  50 * (10 -3) + **4** \+ 100 * (30-2) + **13**  = 3167  Therefore, when users redeem NFT rewards, they will get less value than they are eligible for. Note that totalRedemptionWeight() has an *additional* bug where the reserve amount is not multiplied by the contribution, which is discussed in another submission. If it would be calculated correctly, the correct weight would be 3450.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Change the calculation to:  ``` _numberOfReservedTokensOutstandingFor(_nft, _i+1, _storedTier); ```  ## Additional discussion  Likelihood of impact is very high, because the conditions will arise naturally (different tiers, different reserve minted count for each tier, user calls redeem).  Severity of impact is high because users receive less or more tokens than they are eligible for.  Initially I thought this bug could allow attacker to steal entire unlocked project funds, using a mint/burn loop. However, this would not be profitable because their calculated share of the funds would always be at most what they put in, because reserve tokens are printed out of thin air.
# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566   # Vulnerability details  ## Impact The amounts redeemed in overflow redemption can be calculated incorrectly due to incorrect accounting of the outstanding number of reserved tokens. ## Proof of Concept Project contributors are allowed to redeem their NFT tokens for a portion of the overflow (excessive funded amounts). The amount a contributor receives is calculated as [overflow * (user's redemption rate / total redemption weight)](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L135-L142), where user's redemption weight is [the total contribution floor of all their NFTs](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L532-L539) and total redemption weight is [the total contribution floor of all minted NFTs](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566). Since the total redemption weight is the sum of individual contributor redemption weights, the amount they can redeem is proportional to their contribution.  However, the total redemption weight calculation incorrectly accounts outstanding reserved tokens ([JBTiered721DelegateStore.sol#L563-L566](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566)): ```solidity // Add the tier's contribution floor multiplied by the quantity minted. weight +=   (_storedTier.contributionFloor *     (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +   _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier); ``` Specifically, the *number* of reserved tokens is added to the *weight* of minted tokens. This disrupts the redemption amount calculation formula since the total redemption weight is in fact not the sum of individual contributor redemption weights. ## Tools Used Manual review ## Recommended Mitigation Steps Two options can be seen: 1. if the outstanding number of reserved tokens is considered minted (which seems to be so, judging by [this logic](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1058-L1063)) then it needs to be added to the quantity, i.e.:     ```diff     --- a/contracts/JBTiered721DelegateStore.sol     +++ b/contracts/JBTiered721DelegateStore.sol     @@ -562,8 +562,7 @@ contract JBTiered721DelegateStore is IJBTiered721DelegateStore {           // Add the tier's contribution floor multiplied by the quantity minted.           weight +=             (_storedTier.contributionFloor *     -          (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +     -        _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);     +          (_storedTier.initialQuantity - _storedTier.remainingQuantity +     +           _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier)));            unchecked {             ++_i;     ``` 1. if it's not considered minted, then it shouldn't be counted at all.
# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259   # Vulnerability details  ## Impact  Minting and redeeming become impossible  ## Proof of Concept      uint256 _numberOfNonReservesMinted = _storedTier.initialQuantity -       _storedTier.remainingQuantity -       _reserveTokensMinted;      uint256 _numerator = uint256(_numberOfNonReservesMinted * _storedTier.reservedRate);      uint256 _numberReservedTokensMintable = _numerator / JBConstants.MAX_RESERVED_RATE;      if (_numerator - JBConstants.MAX_RESERVED_RATE * _numberReservedTokensMintable > 0)       ++_numberReservedTokensMintable;      return _numberReservedTokensMintable - _reserveTokensMinted;  The lines above are taken from JBTiered721DelegateStore#_numberOfReservedTokensOutstandingFor and used to calculate and return the available number of reserve tokens that can be minted. Since the return statement doesn't check that _numberReservedTokensMintable >= _reserveTokensMinted, it will revert under those circumstances. The issue is that there are legitimate circumstances in which this becomes false. If a tier is fully minted then all reserve tokens are mintable. When the tier begins to redeem, _numberReservedTokensMintable will fall under _reserveTokensMinted, permanently breaking minting and redeeming. Minting is broken because all mint functions directly call _numberOfReservedTokensOutstandingFor. Redeeming is broken because the redeem callback (JB721Delegate#redeemParams) calls _totalRedemtionWeight which calls _numberOfReservedTokensOutstandingFor.   Example:  A tier has a reserveRate of 100 (1/100 tokens reserved) and an initialQuantity of 10000. We assume that the tier has been fully minted, that is, _reserveTokensMinted is 100 and remainingQuantity = 0. Now we begin burning the tokens. Let's run through the lines above after 100 tokens have been burned (remainingQuantity = 100):  _numberOfNonReservedMinted = 10000 - 100 - 100 = 9800  _numerator = 9800 * 100 = 980000  _numberReservedTokensMintable = 980000 / 10000 = 98  Since _numberReservedTokensMintable < _reserveTokensMinted the line will underflow and revert.  JBTiered721DelegateStore#_numberOfReservedTokensOutstandingFor will now revert every time it is called. This affects all minting functions as well as totalRedemptionWeight. Since those functions now revert when called, it is impossible to mint or redeem anymore NFTs.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Add a check before returning:      +   if (_reserveTokensMinted > _numberReservedTokensMintable) {     +       return 0;     +   }          return _numberReservedTokensMintable - _reserveTokensMinted;
# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/89cea0e2a942a9dc9e8d98ae2c5f1b8f4d916438/contracts/JBTiered721DelegateStore.sol#L701   # Vulnerability details  ## Impact When the `reservedTokenBeneficiary` of a tier is equal to `defaultReservedTokenBeneficiaryOf[msg.sender]`, it is not explicitly set for this tier. This generally works well because in the function `reservedTokenBeneficiaryOf(address _nft, uint256 _tierId)`, `defaultReservedTokenBeneficiaryOf[_nft]` is used as a backup when `_reservedTokenBeneficiaryOf[_nft][_tierId]` is not set. However, it will lead to the wrong beneficiary when `defaultReservedTokenBeneficiaryOf[msg.sender]` is later changed, as this new beneficiary will be used for the tier, which is not the intended one.  ## Proof Of Concept `defaultReservedTokenBeneficiaryOf[address(delegate)]` is originally set to `address(Bob)` when the following happens: 1.) A new tier 42 is added with `_tierToAdd.reservedTokenBeneficiary = address(Bob)`. Because this is equal to `defaultReservedTokenBeneficiaryOf[address(delegate)]`, `_reservedTokenBeneficiaryOf[msg.sender][_tierId]` is not set. 2.) The owner calls `setDefaultReservedTokenBeneficiary` to change the default beneficiary (i.e., the value `defaultReservedTokenBeneficiaryOf[address(delegate)]`) to `address(Alice)`. 3.) Now, every call to `reservedTokenBeneficiaryOf(address(delegate), 42)` will return `address(Alice)`, meaning she will get these reserved tokens. This is of course wrong, the tier was explicitly created with Bob as the beneficiary.  ## Recommended Mitigation Steps Also set `_reservedTokenBeneficiaryOf[msg.sender][_tierId]` when it is equal to the current default beneficiary.
# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259 https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566 https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142   # Vulnerability details  If the reserved rate of a tier is set to a value > `JBConstants.MAX_RESERVED_RATE`, the `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor` function will return way more outstanding reserved tokens (up to ~6 times more than allowed - **2^16 - 1** due to the manual cast of `reservedRate` to `uint16` divided by `JBConstants.MAX_RESERVED_RATE = 10_000`). This inflated value is used in the `JBTiered721DelegateStore.totalRedemptionWeight` function to calculate the cumulative redemption weight of all tokens across all tiers.  This higher-than-expected redemption weight will lower the `reclaimAmount` calculated in the `JB721Delegate.redeemParams` function. Depending on the values of `_data.overflow` and `_redemptionWeight`, the calculated `reclaimAmount` can be **0** (due to rounding down, [see here](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142)) or a smaller than anticipated value, leading to burned NFT tokens from the user and no redemptions.  ## Impact  The owner of an NFT contract can add tiers with higher than usual reserved rates (and mint an appropriate number of NFTs to bypass all conditions in the `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor`), which will lead to a lower-than-expected redemption amount for users.  ## Proof of Concept  [JBTiered721DelegateStore.\_numberOfReservedTokensOutstandingFor](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259)  ```solidity function _numberOfReservedTokensOutstandingFor(   address _nft,   uint256 _tierId,   JBStored721Tier memory _storedTier ) internal view returns (uint256) {   // Invalid tier or no reserved rate?   if (_storedTier.initialQuantity == 0 || _storedTier.reservedRate == 0) return 0;    // No token minted yet? Round up to 1.   if (_storedTier.initialQuantity == _storedTier.remainingQuantity) return 1;    // The number of reserved tokens of the tier already minted.   uint256 _reserveTokensMinted = numberOfReservesMintedFor[_nft][_tierId];    // If only the reserved token (from the rounding up) has been minted so far, return 0.   if (_storedTier.initialQuantity - _reserveTokensMinted == _storedTier.remainingQuantity)     return 0;    // Get a reference to the number of tokens already minted in the tier, not counting reserves or burned tokens.   uint256 _numberOfNonReservesMinted = _storedTier.initialQuantity -     _storedTier.remainingQuantity -     _reserveTokensMinted;    // Store the numerator common to the next two calculations.   uint256 _numerator = uint256(_numberOfNonReservesMinted * _storedTier.reservedRate);    // Get the number of reserved tokens mintable given the number of non reserved tokens minted. This will round down.   uint256 _numberReservedTokensMintable = _numerator / JBConstants.MAX_RESERVED_RATE;    // Round up.   if (_numerator - JBConstants.MAX_RESERVED_RATE * _numberReservedTokensMintable > 0)     ++_numberReservedTokensMintable;    // Return the difference between the amount mintable and the amount already minted.   return _numberReservedTokensMintable - _reserveTokensMinted; } ```  [JBTiered721DelegateStore.totalRedemptionWeight](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566)  The `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor` function is called from within the `JBTiered721DelegateStore.totalRedemptionWeight` function. This allows for inflating the total redemption weight.  ```solidity function totalRedemptionWeight(address _nft) public view override returns (uint256 weight) {   // Keep a reference to the greatest tier ID.   uint256 _maxTierId = maxTierIdOf[_nft];    // Keep a reference to the tier being iterated on.   JBStored721Tier memory _storedTier;    // Add each token's tier's contribution floor to the weight.   for (uint256 _i; _i < _maxTierId; ) {     // Keep a reference to the stored tier.     _storedTier = _storedTierOf[_nft][_i + 1];      // Add the tier's contribution floor multiplied by the quantity minted.     weight +=       (_storedTier.contributionFloor *         (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +       _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);      unchecked {       ++_i;     }   } } ```  [JBTiered721Delegate.\_totalRedemptionWeight](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L712)  `JBTiered721DelegateStore.totalRedemptionWeight` is called in the `JBTiered721Delegate._totalRedemptionWeight` function.  ```solidity function _totalRedemptionWeight() internal view virtual override returns (uint256) {   return store.totalRedemptionWeight(address(this)); } ```  [abstract/JB721Delegate.redeemParams](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L139)  This `JBTiered721Delegate._totalRedemptionWeight` function is then called in the `JB721Delegate.redeemParams` function, which ultimately calculates the `reclaimAmount` given an overflow and `_decodedTokenIds`.  `uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);` in [line 142](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142) will lead to a lower `_base` due to the inflated denumerator `_total`.  ```solidity function redeemParams(JBRedeemParamsData calldata _data)   external   view   override   returns (     uint256 reclaimAmount,     string memory memo,     JBRedemptionDelegateAllocation[] memory delegateAllocations   ) {   // Make sure fungible project tokens aren't being redeemed too.   if (_data.tokenCount > 0) revert UNEXPECTED_TOKEN_REDEEMED();    // Check the 4 bytes interfaceId and handle the case where the metadata was not intended for this contract   if (     _data.metadata.length < 4 || bytes4(_data.metadata[0:4]) != type(IJB721Delegate).interfaceId   ) {     revert INVALID_REDEMPTION_METADATA();   }    // Set the only delegate allocation to be a callback to this contract.   delegateAllocations = new JBRedemptionDelegateAllocation[](1);   delegateAllocations[0] = JBRedemptionDelegateAllocation(this, 0);    // If redemption rate is 0, nothing can be reclaimed from the treasury   if (_data.redemptionRate == 0) return (0, _data.memo, delegateAllocations);    // Decode the metadata   (, uint256[] memory _decodedTokenIds) = abi.decode(_data.metadata, (bytes4, uint256[]));    // Get a reference to the redemption rate of the provided tokens.   uint256 _redemptionWeight = _redemptionWeightOf(_decodedTokenIds);    // Get a reference to the total redemption weight.   uint256 _total = _totalRedemptionWeight(); // @audit-info Uses the inflated total redemption weight    // Get a reference to the linear proportion.   uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.   if (_data.redemptionRate == JBConstants.MAX_REDEMPTION_RATE)     return (_base, _data.memo, delegateAllocations);    // Return the weighted overflow, and this contract as the delegate so that tokens can be deleted.   return (     PRBMath.mulDiv(       _base,       _data.redemptionRate +         PRBMath.mulDiv(           _redemptionWeight,           JBConstants.MAX_REDEMPTION_RATE - _data.redemptionRate,           _total         ),       JBConstants.MAX_REDEMPTION_RATE     ),     _data.memo,     delegateAllocations   ); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider validating the tier reserved rate `reservedRate` in the `JBTiered721DelegateStore.recordAddTiers` function to ensure the reserved rate is not greater than `JBConstants.MAX_RESERVED_RATE`. 
# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566   # Vulnerability details  ## Description  Redemption weight is a concept used in Juicebox to determine investor's eligible percentage of the non-locked funds. In redeemParams, JB721Delegate calculates user's share using:  ``` uint256 _redemptionWeight = _redemptionWeightOf(_decodedTokenIds); uint256 _total = _totalRedemptionWeight(); uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total); ```  _totalRedemptionWeight eventually is implemented in DelegateStore:  ``` for (uint256 _i; _i < _maxTierId; ) {   // Keep a reference to the stored tier.   _storedTier = _storedTierOf[_nft][_i + 1];   // Add the tier's contribution floor multiplied by the quantity minted.   weight +=     (_storedTier.contributionFloor *       (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +     _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);   unchecked {     ++_i;   } } ```  If we pay attention to _numberOfReservedTokensOutstandingFor() call, we can see it is called with tierId = i, yet storedTier of i+1. It is definitely not the intention as for example, recordMintReservesFor() uses the function correctly:  ``` function recordMintReservesFor(uint256 _tierId, uint256 _count)   external   override   returns (uint256[] memory tokenIds) {   // Get a reference to the tier.   JBStored721Tier storage _storedTier = _storedTierOf[msg.sender][_tierId];   // Get a reference to the number of reserved tokens mintable for the tier.   uint256 _numberOfReservedTokensOutstanding = _numberOfReservedTokensOutstandingFor(     msg.sender,     _tierId,     _storedTier   );   ... ```  The impact of this bug is incorrect calculation of the weight of user's contributions. The `initialQuantity` and `remainingQuantity` values are taken from the correct tier, but `_reserveTokensMinted` minted is taken from previous tier. In the case where `_reserveTokensMinted` is smaller than correct value, for example tierID=0 which is empty, the outstanding value returned is larger, meaning weight is larger and redemptions are worth less. In the opposite case, where lower tierID has higher `_reserveTokensMinted`, the redemptions will receive *more* payout than they should.  ## Impact  Users of projects can receive less or more funds than they are eligible for when redeeming NFT rewards.  ## Proof of Concept  1\. Suppose we have a project with 2 tiers, reserve ratio = 50%, redemption ratio = 100%:  |     |     |     |     |     |     | | --- | --- | --- | --- | --- | --- | | Tier | Contribution | Initial quantity | Remaining quantity | Reserves minted | Reserves outstanding | | Tier 1 | 50  | 10  | 3   | 1   | 2   | | Tier 2 | 100 | 30  | 2   | 8   | 2   |  When calculating totalRedemptionWeight(), the correct result is  50 * (10 - 3) + 2 + 100 * (30-2) + 2 = 3154  The wrong result will be:  50 * (10 -3) + **4** \+ 100 * (30-2) + **13**  = 3167  Therefore, when users redeem NFT rewards, they will get less value than they are eligible for. Note that totalRedemptionWeight() has an *additional* bug where the reserve amount is not multiplied by the contribution, which is discussed in another submission. If it would be calculated correctly, the correct weight would be 3450.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Change the calculation to:  ``` _numberOfReservedTokensOutstandingFor(_nft, _i+1, _storedTier); ```  ## Additional discussion  Likelihood of impact is very high, because the conditions will arise naturally (different tiers, different reserve minted count for each tier, user calls redeem).  Severity of impact is high because users receive less or more tokens than they are eligible for.  Initially I thought this bug could allow attacker to steal entire unlocked project funds, using a mint/burn loop. However, this would not be profitable because their calculated share of the funds would always be at most what they put in, because reserve tokens are printed out of thin air.
# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566   # Vulnerability details  ## Impact The amounts redeemed in overflow redemption can be calculated incorrectly due to incorrect accounting of the outstanding number of reserved tokens. ## Proof of Concept Project contributors are allowed to redeem their NFT tokens for a portion of the overflow (excessive funded amounts). The amount a contributor receives is calculated as [overflow * (user's redemption rate / total redemption weight)](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L135-L142), where user's redemption weight is [the total contribution floor of all their NFTs](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L532-L539) and total redemption weight is [the total contribution floor of all minted NFTs](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566). Since the total redemption weight is the sum of individual contributor redemption weights, the amount they can redeem is proportional to their contribution.  However, the total redemption weight calculation incorrectly accounts outstanding reserved tokens ([JBTiered721DelegateStore.sol#L563-L566](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566)): ```solidity // Add the tier's contribution floor multiplied by the quantity minted. weight +=   (_storedTier.contributionFloor *     (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +   _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier); ``` Specifically, the *number* of reserved tokens is added to the *weight* of minted tokens. This disrupts the redemption amount calculation formula since the total redemption weight is in fact not the sum of individual contributor redemption weights. ## Tools Used Manual review ## Recommended Mitigation Steps Two options can be seen: 1. if the outstanding number of reserved tokens is considered minted (which seems to be so, judging by [this logic](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1058-L1063)) then it needs to be added to the quantity, i.e.:     ```diff     --- a/contracts/JBTiered721DelegateStore.sol     +++ b/contracts/JBTiered721DelegateStore.sol     @@ -562,8 +562,7 @@ contract JBTiered721DelegateStore is IJBTiered721DelegateStore {           // Add the tier's contribution floor multiplied by the quantity minted.           weight +=             (_storedTier.contributionFloor *     -          (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +     -        _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);     +          (_storedTier.initialQuantity - _storedTier.remainingQuantity +     +           _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier)));            unchecked {             ++_i;     ``` 1. if it's not considered minted, then it shouldn't be counted at all.
# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259   # Vulnerability details  ## Impact  Minting and redeeming become impossible  ## Proof of Concept      uint256 _numberOfNonReservesMinted = _storedTier.initialQuantity -       _storedTier.remainingQuantity -       _reserveTokensMinted;      uint256 _numerator = uint256(_numberOfNonReservesMinted * _storedTier.reservedRate);      uint256 _numberReservedTokensMintable = _numerator / JBConstants.MAX_RESERVED_RATE;      if (_numerator - JBConstants.MAX_RESERVED_RATE * _numberReservedTokensMintable > 0)       ++_numberReservedTokensMintable;      return _numberReservedTokensMintable - _reserveTokensMinted;  The lines above are taken from JBTiered721DelegateStore#_numberOfReservedTokensOutstandingFor and used to calculate and return the available number of reserve tokens that can be minted. Since the return statement doesn't check that _numberReservedTokensMintable >= _reserveTokensMinted, it will revert under those circumstances. The issue is that there are legitimate circumstances in which this becomes false. If a tier is fully minted then all reserve tokens are mintable. When the tier begins to redeem, _numberReservedTokensMintable will fall under _reserveTokensMinted, permanently breaking minting and redeeming. Minting is broken because all mint functions directly call _numberOfReservedTokensOutstandingFor. Redeeming is broken because the redeem callback (JB721Delegate#redeemParams) calls _totalRedemtionWeight which calls _numberOfReservedTokensOutstandingFor.   Example:  A tier has a reserveRate of 100 (1/100 tokens reserved) and an initialQuantity of 10000. We assume that the tier has been fully minted, that is, _reserveTokensMinted is 100 and remainingQuantity = 0. Now we begin burning the tokens. Let's run through the lines above after 100 tokens have been burned (remainingQuantity = 100):  _numberOfNonReservedMinted = 10000 - 100 - 100 = 9800  _numerator = 9800 * 100 = 980000  _numberReservedTokensMintable = 980000 / 10000 = 98  Since _numberReservedTokensMintable < _reserveTokensMinted the line will underflow and revert.  JBTiered721DelegateStore#_numberOfReservedTokensOutstandingFor will now revert every time it is called. This affects all minting functions as well as totalRedemptionWeight. Since those functions now revert when called, it is impossible to mint or redeem anymore NFTs.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Add a check before returning:      +   if (_reserveTokensMinted > _numberReservedTokensMintable) {     +       return 0;     +   }          return _numberReservedTokensMintable - _reserveTokensMinted;
# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/89cea0e2a942a9dc9e8d98ae2c5f1b8f4d916438/contracts/JBTiered721DelegateStore.sol#L701   # Vulnerability details  ## Impact When the `reservedTokenBeneficiary` of a tier is equal to `defaultReservedTokenBeneficiaryOf[msg.sender]`, it is not explicitly set for this tier. This generally works well because in the function `reservedTokenBeneficiaryOf(address _nft, uint256 _tierId)`, `defaultReservedTokenBeneficiaryOf[_nft]` is used as a backup when `_reservedTokenBeneficiaryOf[_nft][_tierId]` is not set. However, it will lead to the wrong beneficiary when `defaultReservedTokenBeneficiaryOf[msg.sender]` is later changed, as this new beneficiary will be used for the tier, which is not the intended one.  ## Proof Of Concept `defaultReservedTokenBeneficiaryOf[address(delegate)]` is originally set to `address(Bob)` when the following happens: 1.) A new tier 42 is added with `_tierToAdd.reservedTokenBeneficiary = address(Bob)`. Because this is equal to `defaultReservedTokenBeneficiaryOf[address(delegate)]`, `_reservedTokenBeneficiaryOf[msg.sender][_tierId]` is not set. 2.) The owner calls `setDefaultReservedTokenBeneficiary` to change the default beneficiary (i.e., the value `defaultReservedTokenBeneficiaryOf[address(delegate)]`) to `address(Alice)`. 3.) Now, every call to `reservedTokenBeneficiaryOf(address(delegate), 42)` will return `address(Alice)`, meaning she will get these reserved tokens. This is of course wrong, the tier was explicitly created with Bob as the beneficiary.  ## Recommended Mitigation Steps Also set `_reservedTokenBeneficiaryOf[msg.sender][_tierId]` when it is equal to the current default beneficiary.
