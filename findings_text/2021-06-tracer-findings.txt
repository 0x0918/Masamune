# Handle  shw   # Vulnerability details  ## Impact  The `recordTrade` function in `Pricing` updates the `currentHour` variable by 1 every hour. However, if there is no trade (i.e., the `recordTrade` is not called) during this hour, the `currentHour` is out of sync with the actual hour. As a result, the `averagePriceForPeriod` function uses the prices before 24 hours and causes errors on the average price.  ## Proof of Concept  Referenced code: [Pricing.sol#L90-L94](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L90-L94)  ## Recommended Mitigation Steps  Calculate how much time passed (e.g., `(block.timestamp - startLastHour) / 3600`) to update the `currentHour` variable correctly.  
# Handle  shw   # Vulnerability details  ## Impact  The `averagePriceForPeriod` function of `LibPrices` does not handle the case where `j` equals 0 (i.e., no trades happened in the last 24 hours). The transaction reverts due to dividing by 0 without a proper error message returned.  ## Proof of Concept  Referenced code: [LibPrices.sol#L73](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibPrices.sol#L73)  ## Recommended Mitigation Steps  Add `require(j > 0, "...")` before line 73 to handle this special case.  
# Handle  shw   # Vulnerability details  ## Impact  The `getHourlyAvgTracerPrice` and `getHourlyAvgOraclePrice` functions in `Pricing` return 0 if there is no trade during the given `hour` because of the design of `averagePrice`, which could mislead users that the hourly average price is 0. The same problem happens when emitting the old hourly average in the `recordTrade` function.  ## Proof of Concept  Referenced code: [Pricing.sol#L254-L256](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L254-L256) [Pricing.sol#L262-L264](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L262-L264) [Pricing.sol#L74](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L74)  ## Recommended Mitigation Steps  Return a special value (e.g., `type(uint256).max`) from `averagePrice` if there is no trade during the specified hour to distinguish from an actual zero price. Handle this particular value whenever the `averagePrice` function is called by others.  
# Handle  shw   # Vulnerability details  ## Impact  Most of the contracts use an unlocked pragma (e.g., `pragma solidity ^0.8.0`) which is not fixed to a specific Solidity version. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler version with which they have been tested the most.  ## Proof of Concept  Referenced code: Please use `grep -R pragma .` to find the unlocked pragma statements.  ## Recommended Mitigation Steps  Lock pragmas to a specific Solidity version. Consider the compiler bugs in the following lists and ensure the contracts are not affected by them. It is also recommended to use the latest version of Solidity when deploying contracts (see [Solidity docs](https://docs.soliditylang.org/en/v0.8.6/)).  Solidity compiler bugs: [Solidity repo - known bugs](https://github.com/ethereum/solidity/blob/develop/docs/bugs.json) [Solidity repo - bugs by version](https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json)  
# Handle  0xsanson   # Vulnerability details  ## Impact In Liquidation.verifyAndSubmitLiquidation(...) we can save the minimumMargin to memory since it's called two times.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L171  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Save the result of Balances.minimumMargin(...) to memory.  
# Handle  0xsanson   # Vulnerability details  ## Impact The claimEscrow(...) function in Liquidation.sol can be set external instead of public since it's not used in the contract. (code clarity and gas savings)  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L109  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change public to external.  
# Handle  0xsanson   # Vulnerability details  ## Impact In LibBalances.applyTrade() we need to collect a fee from the trade. The current code however subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (see TracerPerpetualSwaps.sol#L272). This issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L187  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change +fee to -fee in the highlighted line.  
# Handle  0xsanson   # Vulnerability details  ## Impact We can save gas by substituting getPoolTarget() with levNotionalValue/100, since tracer.leveragedNotionalValue() is already saved in memory.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L216  ## Tools Used Manual analysis.  ## Recommended Mitigation Steps Substitute getPoolTarget() with levNotionalValue/100.  
# Handle  0xsanson   # Vulnerability details  ## Impact State variable perpsFactory is not used in the Insurance contract.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L18  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Just delete it.  
# Handle  0xsanson   # Vulnerability details  ## Impact In the trader contract isValidSignature(...) and verifySignature(...) serve the same purpose. Suggested keep only one for code clarity.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L206 https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L231  ## Tools Used Manual analysys  ## Recommended Mitigation Steps Suggested keep only one function for code clarity.  
# Handle  a_delamo   # Vulnerability details  ## Impact  For every new TracerPerpetualSwaps contract, we need to deploy a new Liquidation, Insurance, and Pricing contract.  All these deployments are really gas-intensive, so it would be recommended to use EIP-1167: Minimal Proxy Contract to reduce the gas cost of the deployments.  ```solidity function _deployTracer(         bytes calldata _data,         address tracerOwner,         address oracle,         address fastGasOracle,         uint256 maxLiquidationSlippage     ) internal returns (address) {         // Create and link tracer to factory         address market = IPerpsDeployer(perpsDeployer).deploy(_data);         ITracerPerpetualSwaps tracer = ITracerPerpetualSwaps(market);          validTracers[market] = true;         tracersByIndex[tracerCounter] = market;         tracerCounter++;          // Instantiate Insurance contract for tracer         address insurance = IInsuranceDeployer(insuranceDeployer).deploy(market);         address pricing = IPricingDeployer(pricingDeployer).deploy(market, insurance, oracle);         address liquidation = ILiquidationDeployer(liquidationDeployer).deploy(             pricing,             market,             insurance,             fastGasOracle,             maxLiquidationSlippage         );          // Perform admin operations on the tracer to finalise linking         tracer.setInsuranceContract(insurance);         tracer.setPricingContract(pricing);         tracer.setLiquidationContract(liquidation);          // Ownership either to the deployer or the DAO         tracer.transferOwnership(tracerOwner);         ILiquidation(liquidation).transferOwnership(tracerOwner);         emit TracerDeployed(tracer.marketId(), address(tracer));         return market;     } ```   More info: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/ https://eips.ethereum.org/EIPS/eip-1167   
# Handle  0xsanson   # Vulnerability details  ## Impact In the Pricing contract, an agent can manipulate the trading prices by spamming an high amount of trades.  Indeed an agent can create an high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn't even need large funds); next he/she pairs the orders with another account and calls Trader.executeTrade; now every order calls a Pricing.recordTrade using the arbitrary price set by the agent.  Since the trades are all made in the same hour, by the way hourlyTracerPrices[currentHour] is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate the fundingRates and the fairPrice, letting a malicious agent get the ability to manipulate the market.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L129  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Pass the fillAmount parameter to recordTrade(...), and calculate hourlyTracerPrices[currentHour].trades summing fillAmount instead of 1 every trade.  
# Handle  tensors   # Vulnerability details  ## Impact Superfluous type conversions.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L229-L230 The type conversion here is not necessary.  ## Recommended Mitigation Steps Remove the type conversion.  
# Handle  0xsanson   # Vulnerability details  ## Impact The contract TracerPerpetualSwaps introduces these four state variables (lowestMaxLeverage,  maxLeverage, insurancePoolSwitchStage and deleveragingCliff) and four respective set functions. Logically the following relations are needed: lowestMaxLeverage < maxLeverage and insurancePoolSwitchStage < deleveragingCliff, but the code doesn't check for them.  Non-critical because needs an error by the owner.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L552 Also lines L560, L564, L568  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add appropriate requires to the set functions and the constructor.  
# Handle  tensors   # Vulnerability details  ## Impact The contracts assume that all tokens will have <=18 decimals. If the Tracer team are the only people deploying the contracts, and they keep this in mind, this isn't a problem. If the contracts are to be deployed by other people, this assumption should be made explicit and hard-coded.   ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L220-L232 We can see that the scaler computations will underflow and be defined when it should not be.  ## Recommended Mitigation Steps Write a require check that ensures tokenDecimals <= 18 before running the above functions.  
# Handle  s1m0   # Vulnerability details  ## Impact The smart contract doesn't check the return value of token.transfer() and token.transferFrom(), some erc20 token might not revert in case of error but return false. In the [TracerPerpetualSwaps:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L151) and [Insurance:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L51) this would allow a user to deposit for free. Other places: [TracerPerpetualSwaps: withdraw](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L203) [TracerPerpetualSwaps:withdrawFees](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L514) [SafetyWithdraw:withdrawERC20Token](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/SafetyWithdraw.sol#L13) [Insurance:withdraw](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L97)  ## Recommended Mitigation Steps Wrap the call into a require() or use openzeppelin's [SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) library.  
# Handle  pauliax   # Vulnerability details  ## Impact Here the check currentMargin < Balances.minimumMargin should be inclusive <= to indicate the account is not above minimum margin:     require(         currentMargin <= 0 ||             uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),         "LIQ: Account above margin"     );  ## Recommended Mitigation Steps uint256(currentMargin) <= Balances.minimumMargin ...  
# Handle  pauliax   # Vulnerability details  ## Impact Could save some gas here when amountToReturn = receipt.escrowedAmount:     if (amountToReturn > receipt.escrowedAmount) {        liquidationReceipts[receiptId].escrowedAmount = 0;     } else {        liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;     }  ## Recommended Mitigation Steps  if (amountToReturn >= receipt.escrowedAmount) { ...  
# Handle  cmichel   # Vulnerability details  The `TracerPerpetualSwaps.settle` function updates the user's last index to `currentGlobalFundingIndex`, however a comment states:  > "// Note: global rates reference the last fully established rate (hence the -1), and not the current global rate. User rates reference the last saved user rate"  The code for the `else` branch also updates the last index to `currentGlobalFundingIndex - 1` instead of `currentGlobalFundingIndex`.  ```solidity if (accountBalance.position.base == 0) {     // set to the last fully established index     // @audit shouldn't this be global - 1 like below?     accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;     accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer(); } ```   ## Impact It might be possible that first-time depositors skip having to pay the first funding rate period as the `accountLastUpdatedIndex + 1 < currentGlobalFundingIndex` check will still return `false` when the funding rates are updated the next time.  ## Recommended Mitigation Steps Check if setting it to `currentGlobalFundingIndex` or to `currentGlobalFundingIndex - 1` is correct.  
# Handle  cmichel   # Vulnerability details  The `Liquidation` contract allows the liquidator to submit "bad" trade orders and the insurance reimburses them from the insurance fund, see `Liquidation.claimReceipt`. The function can be called with an `orders` array which does not check for duplicate orders. An attacker can abuse this to make a profit by liquidating themselves, making a small bad trade and repeatedly submitting this bad trade for slippage reimbursement.  Example: - Attacker uses two accounts, one as the liquidator and one as the liquidatee. - They run some high-leverage trades such that the liquidatee gets liquidated with the next price update. (If not cash out and make a profit this way through trading, and try again.) - Liquidator liquidates liquidatee - They now do two trades:   - One "good" trade at the market price that fills 99% of the liquidation amount. The slippage protection should not kick in for this trade   - One "bad" trade at a horrible market price that fills only 1% of the liquidation amount. This way the slippage protection kicks in for this trade - The liquidator now calls `claimReceipt(orders)` where `orders` is an array that contains many duplicates of the "bad" trade, for example 100 times. The `calcUnitsSold` function will return `unitsSold = receipt.amountLiquidated` and a bad `avgPrice`. They are now reimbursed the price difference on the full liquidation amount (instead of only on 1% of it) making an overall profit  This can be repeated until the insurance fund is drained.  ## Impact  The attacker has an incentive to do this attack as it's profitable and the insurance fund will be completely drained.  ## Recommended Mitigation Steps Disallow duplicate orders in the `orders` argument of `claimReceipt`. This should make the attack at least unprofitable, but it could still be a griefing attack. A quick way to ensure that `orders` does not contain duplicates is by having liquidators submit the orders in a sorted way (by order ID) and then checking in the `calcUnitsSold` `for` loop that the current order ID is strictly greater than the previous one.  
# Handle  cmichel   # Vulnerability details  There are several setter functions that do not check if the amount is less than 100%.  - `TracerPerpetualSwaps`: `setFeeRate`, `setDeleveragingCliff`, `setInsurancePoolSwitchStage` - `Insurance`: `setFeeRate`, `setDeleveragingCliff`, `setInsurancePoolSwitchStage`  ## Impact Setting values to more than 100% might lead to unintended functionality.  ## Recommended Mitigation Steps Ensure that the parameters are less than 100%.  
# Handle  cmichel   # Vulnerability details  The pool holdings of `Insurance` (`publicCollateralAmount` and `bufferCollateralAmount`) is in WAD (18 decimals) but it's used as a raw token value in `drainPool`  ```solidity // amount is a mix of pool holdings, i.e., 18 decimals // this requires amount to be in RAW! if tracerMarginToken has > 18 decimals, it'll break, < 18 decimals will approve too much tracerMarginToken.approve(address(tracer), amount); // this requires amount to be in WAD which is correct tracer.deposit(amount); ```  ## Impact  If `tracerMarginToken` has less than 18 decimals, the approval approves orders of magnitude more tokens than required for the `deposit` call that follows. If `tracerMarginToken` has more than 18 decimals, the `deposit` that follows would fail as fewer tokens were approved, but the protocol seems to disallow tokens in general with more than 18 decimals.  ## Recommended Mitigation Steps Convert the `amount` to a "raw token value" and approve this one instead.   
# Handle  cmichel   # Vulnerability details  The `GasOracle` uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD.  However, the scaling depends on the underlying decimals of the two oracles and could be anything. But the code assumes it's in 18 decimals.  > "Returned value is USD/Gas * 10^18 for compatibility with rest of calculations"  There is a `toWad` function that seems to involve scaling but it is never used.  ## Impact** If the scale is wrong, the gas price can be heavily inflated or under-reported.   ## Recommended Mitigation Steps Check `chainlink.decimals()` to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the `latestAnswer` function always returns the answer in 18 decimals.  
# Handle  cmichel   # Vulnerability details  When `LibMath.sumN` function does not check if `n <= arr.length` and can therefore fail if called with `n > arr.length`.  ## Impact The caller must always check that it's called with an argument that is less than `n` which is inconvenient.  ## Recommendation Change the condition to iterate up to `min(n, arr.length)`.   
# Handle  cmichel   # Vulnerability details   When `LibMath.abs` is called with -2^255 (`type(int256).min`), it tries to multiply it by `-1` but it'll fail as it exceeds the max signed 256-bit integers.  ## Impact The function will fail with an implicit error that might be hard to locate.  ## Recommendation Throw an error similar to `toInt256` like `int256 overflow`.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  In function minimumMargin(), maximumLeverage being zero is not handled because it will result in div by zero as PRBMathUD60x18.div expects non-zero divisor.   Impact: Various critical market functions will revert if maximumLeverage is zero.  ## Proof of Concept  https://github.com/hifi-finance/prb-math/blob/c4dea7d0e6ae246fbb631f7fb4be4072d1da9a07/contracts/PRBMathUD60x18.sol#L71-L77   https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L118  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L135  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L186  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L242  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L248  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add checks to make sure maximumLeverage is never zero or handle appropriately.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The withdrawERC20Token() in SafetyWithdraw inherited in TracerPerpetualSwaps is presumably a guarded launch emergency withdrawal mechanism. However, given the trust model where the market creator/owner is potentially untrusted/malicious, this is a dangerous approach to emergency withdrawal in the context of guarded launch.   Alternatively, if this is meant for the owner to withdraw “external” ERC20 tokens mistakenly deposited to the Tracer market then the function should exclude tracerQuoteToken from being the tokenAddress that can be used as a parameter to withdrawERC20Token().  Impact: Malicious owner of a market withdraws/rugs all tracerQuoteTokens deposited at any time after market launch. All users lose deposits. Protocol takes a reputational hit and has to refund the users from treasury.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/SafetyWithdraw.sol#L8-L14  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L20   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  For a guarded launch circuit breaker, design a pause/unpause feature where deposits are paused  (in emergency situations) but withdrawals are allowed by the depositors themselves instead of the owner. Alternatively, if this is meant to be for removing external ERC20 tokens accidentally deposited to market, exclude the tracerQuoteToken from being given as the tokenAddress.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The sumN() library function expects to calculate the sum of n elements of the supplied array but there is no check to see if the array indeed has n elements. A smaller array could lead to reading out of bounds memory resulting in undefined values.  Impact: The current usage of the library does not indicate an out of bounds access but any new code using this library could be impacted.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibMath.sol#L38-L46  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibMath.sol#L68  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibPrices.sol#L73   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add require(n <= arr.length) at the beginning of sumN() to be safe.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The setDecimals() in the sample Gas Price Oracle implementation allows anyone to set the decimals value used by the contract but is not used anywhere.  Impact: It is unclear if this should be set by anyone and if that value should be used in determining the precision of the values returned.  ## Proof of Concept   https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/oracle/GasOracle.sol#L64-L66   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate if this access and missing logic is correct.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Time ranges are typically open-ended which includes the start & end times, and not close-ended. So the releaseTime would be interpreted as the time it would be released i.e. block.timestamp >= releaseTime would be the expected check here instead of ‘>’. Similarly, on L406, it should be ‘<=‘ instead of ‘<‘.  Impact: Claims of escrow and receipts are expected to succeed in a particular block but they revert and have to wait until the next block.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L112  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L406  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Unless justified, change the strict inequality and make it ‘>=‘ and ‘<=‘ to convert open ranges to closed ranges for block.timestamp comparisons.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The updateFundingRate() function updates the funding rate and insurance funding rate. While the instant/new funding rates are calculated correctly, the cumulative funding rate calculation is incorrect because it is always adding the instant to 0, not the previous value. This is due to the use of [currentFundingIndex] which has been updated since the previous call to this function while it should really be using [currentFundingIndex-1] to reference the previous funding rate.  Impact: The cumulative funding rate and insurance funding rates are calculated incorrectly without considering the correct previous values. This affects the settling of accounts across the entire protocol. The protocol logic is significantly impacted, accounts will not be settled as expected, protocol shutdown and contracts will need to be redeployed. Users may lose funds and protocol takes a reputation hit.   ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L155-L160  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L168  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L77  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L196-L215  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L221-L230  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L445-L446  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use [currentFundingIndex-1] for non-zero values of currentFundingIndex to get the value updated in the previous call on lines L155 and L159 of Pricing.sol.  
# Handle  0xRajeev   # Vulnerability details  ## Impact Trading function executeTrade() batch executes maker/taker orders against a market. The trader/interface provides arrays of makers/takers which is unbounded. As a result, if the number of orders is too many, there is a risk of this transaction exceeding the block gas limit (which is 15 million currently).  Impact: executeTrade() is called with too many orders in the batch. Tx exceeds block gas limit and reverts. None of the orders are executed.  ## Proof of Concept  See similar Medium-severity finding from ConsenSys's Audit of Growth DeFi: https://consensys.net/diligence/audits/2020/12/growth-defi-v1/#potential-resource-exhaustion-by-external-calls-performed-within-an-unbounded-loop  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Trader.sol#L67  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Trader.sol#L78  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Limit the number or orders executed based on gasleft() after every iteration or estimate the gas cost and enforce an upper bound on the number of orders allowed in maker/taker arrays.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Tracer protocol like any other allows market creators to charge fees for trades. However, a malicious/greedy owner can arbitrarily change fee to any % value and without an event to observe this change or a timelock to react, there is no easy way for users to monitor this via front-end or off-chain monitoring tools.  Impact: Users trade on a market with 0.1% fees. The owner suddenly changes this to 100%. Users realise this only after their trades are executed. Market loses confidence. Protocol takes a reputational hit.  ## Proof of Concept  See similar Medium-severity finding in ConsenSys's Audit of 1inch Liquidity Protocol (https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L548-L550  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L198-L214  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit event, provide time lock for users to react and establish an upper threshold for fees that is decided across markets by governance.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  withdrawFees() is an external function which can be called by anyone to transfer the accumulated fees to the feeReceiver account. However, there is no data validation to check if fees are non-zero.  Impact: One can keep calling withdrawFees(), even if the fees is zero, to grief the system with 0 amount transfers and emission of events recording the same. This leads to what is known as event log poisoning where malicious external users spam the Tracer contract to generate arbitrary FeeWithdrawn events.  ## Proof of Concept  See similar Finding from Sigma Prime’s audit of Synthetix Unipool: https://github.com/sigp/public-audits/blob/master/synthetix/unipool/review.pdf  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L508-L516  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider adding a require or if statement preventing the withdrawFees() function from emitting the event when the amount variable is zero, i.e. check if fees != 0 before transfer+emit.  
# Handle  JMukesh   # Vulnerability details  ## Impact public function which are not called within contract should be declared as external to save gas  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L572  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L470  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/InsurancePoolToken.sol#L14  ## Tools Used  manual review  ## Recommended Mitigation Steps  Declare public function as external which are not called in the contract  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Reference type local variables require an explicit data location specified indicating if they need to be in storage or memory. Assigning state variables to storage local variables creates a reference  (instead of a copy) to the state variable and modifications to the local variable will be reflected in the state variable. This is required if the intention is to make updates to state variables. Unnecessarily using storage specifiers may lead to unintentional updates of state variables and has led to vulnerabilities.  In L457 of settle(), a local variable insuranceBalance is created in storage to point to balances[address(insuranceContract)] but is never updated. Instead balances[address(insuranceContract)] itself is updated on L474.  Impact: While there is no immediate impact, any modifications to the code with insuranceBalance will be dangerous because it will update the critical state variable balances[address(insuranceContract)]. It is safer to use a memory specifier for insuranceBalance.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L456-L457  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L467  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L474  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace the use of storage specifier on L457 with memory.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The tvl calculation in deposit() uses convertedWadAmount but the one in withdraw() uses the parameter amount. While amount is still in WAD format, it may contain dust which is what the conversion to rawTokenAmount and then back to convertedWadAmount removes.  Impact: Use of amount in tvl during withdraw() will consider dust while the one in deposit() will not, which is inconsistent.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L200  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L176-L177  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L162  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L153-L155  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use convertedWadAmount instead of amount to be consistent with the increment during withdraw() tvl calculation.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The Deposit event uses the function parameter amount instead of the convertedWadAmount which is what is used to update the user’s position and tvl because it prevents any dust deposited in amount. This will also make it consistent with the emit event in withdraw function.  Impact: Deposit event amount reflects the value with dust while the user position does not. This may lead to confusion.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L163  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L153-L162  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L204  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use uint256(convertedWadAmount) instead of amount in Deposit event.  
# Handle  pauliax   # Vulnerability details  ## Impact Trader function executeTrade calculates executionPrice, newMakeAverage, newTakeAverage, then calls the market, and only if it succeeds it uses these variables.  ## Recommended Mitigation Steps Better first call the market and only then calculate and use these variables to avoid useless calculations and gas costs.  
# Handle  pauliax   # Vulnerability details  ## Impact Insurance function drainPool calculates 10**18 many times. To reduce the number of calculations and save gas, this number can be extracted as a constant variable and used everywhere where necessary.  ## Recommended Mitigation Steps Extract 10**18 as a constant.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The gas cost for liquidation may change if code is updated/optimized, compiler changed or profiling improved. The developers may forget to update this constant in code.  Impact: The margin validity calculation which uses this value may be affected if this changes and hence is not as declared in the constant. This may adversely impact validation.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L26  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L244  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L250  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L494  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L159  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L193  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  It is safer to make this a constructor-set immutable value that will force usage of an updated accurate value at deployment time. Evaluate if the sensitivity to this value is great enough to justify a setter to change it if incorrectly initialized at deployment.  
# Handle  pauliax   # Vulnerability details  ## Impact Contract Trader has 2 mappings: orders and orderToSig. I see that orderToSig also stores Perpetuals.Order inside it, so I wonder if it really was necessary to separate these mappings as some state (order) is duplicated among them. It may be a bit more efficient to access orders without signatures but it also makes it more error-prone as you need to keep the invariant that orders match in these mappings. Currently I don't see an exact problem as orderToSig are only set in function grabOrder and never used in code anywhere but I am not sure if it is really necessary.   Tracer representetive's answer on Discord: 'Yeah thats a good point on the Trader mapping, one does look redundant now as they both store the order itself. I think originally one was mutated and one wasn't, but then that functionality got moved into the filled mapping anyway. Seems safe to remove orders and simply reference the orderToSig mapping'.  ## Recommended Mitigation Steps Remove orders and simply reference the orderToSig mapping.  
# Handle  JMukesh   # Vulnerability details  ## Impact state variable which have to initialise in constructor can be declared as immutable to save gas  ## Proof of Concept  https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Insurance.sol#L23  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Insurance.sol#L20  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L30  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L31  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L17  ## Tools Used  manual review  
# Handle  JMukesh   # Vulnerability details  ## Impact Unused state variable will increase unnecessarily code size and use the memory  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/oracle/GasOracle.sol#L19  ## Tools Used  manual review  ## Recommended Mitigation Steps  remove the variable which are unused  
# Handle  hrkrshnn   # Vulnerability details  ## Impact  Gas optimization.  ## Use at least 0.8.4 instead of 0.8.0  It has an important optimization improvement: a low level inliner. Especially since you have several small functions.  The current hardhat config indicates that version `0.8.0` is being used.    
# Handle  hrkrshnn   # Vulnerability details  ## Impact  Gas optimization.  ## For function arguments, change `memory` to `calldata`  There are several places where this is applicable, however, will point out one such occasion:  ``` diff modified   src/contracts/Trader.sol @@ -64,7 +64,7 @@ contract Trader is ITrader {       * @param makers An array of signed make orders       * @param takers An array of signed take orders       */ -    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) +    function executeTrade(Types.SignedLimitOrder[] calldata makers, Types.SignedLimitOrder[] calldata takers)          external          override      { @@ -144,7 +144,7 @@ contract Trader is ITrader {       * @dev Should only be called with a verified signedOrder and with index       *      < signedOrders.length       */ -    function grabOrder(Types.SignedLimitOrder[] memory signedOrders, uint256 index) +    function grabOrder(Types.SignedLimitOrder[] calldata signedOrders, uint256 index)          internal          returns (Perpetuals.Order memory)      { ```  Reason: when you specify `memory` for a (non value type) function-parameter for an external function, the following happens: the compiler would copy elements from `calldata` to `memory` (using the opcode `calldatacopy`.) Then later on, the internal call (here `grabOrder`) would pass a memory reference. However, this is a great example of where copying to memory is unnecessary. Note that there is also the opcode `calldataload` to read an offset from `calldata`. By changing the location from `memory` to `calldata`, you avoid this expensive copy from `calldata` to `memory`, while managing to do exactly what's needed.  You would only have to use `memory` if the function has to modify the parameter, in which case a copy is really needed as `calldata` cannot be modified.    
# Handle  JMukesh   # Vulnerability details  ## Impact These array memory parameter can be  problematic if not used properly , if the array is very large it may overlap over other part of memory.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L274  This an example to show the exploit: // based on https://github.com/paradigm-operations/paradigm-ctf-2021/blob/master/swap/private/Exploit.sol pragma solidity ^0.4.24; // only works with low solidity version  contract test{ struct Overlap { uint field0; } event log(uint);  function mint(uint[] memory amounts) public returns (uint) {  // this can be in any solidity version Overlap memory v; v.field0 = 1234; emit log(amounts[0]); // would expect to be 0 however is 1234 return 1; }  function go() public { // this part requires the low solidity version uint x=0x800000000000000000000000000000000000000000000000000000000000000; // 2^251 bytes memory payload = abi.encodeWithSelector(this.mint.selector, 0x20, x); bool success=address(this).call(payload); } } ## Tools Used  manual review  ## Recommended Mitigation Steps  check array length before using it  
# Handle  gpersoon   # Vulnerability details  ## Impact It's possible to avoid paying insurance in the following way: - once per hour (at the right moment), do the following: ----using a flash loan, or with a large amount of tokens, call deposit of Insurance.sol to make sure that the pool is sufficiently filled (poolHoldings > poolTarget) ----call the function executeTrade of Trader.sol with a minimal trade (possibly of value 0, see finding "executeTrade with same trades") ----executeTrade calls matchOrders, which calls recordTrade ----recordTrade calls updateFundingRate();   (once per hour, so you have to be sure you do it in time before other trades trigger this) ----updateFundingRate calls getPoolFundingRate ----getPoolFundingRate determines the insurance rate, but because the insurance pool is sufficiently full (due to the flash loan), the rate is 0 ----updateFundingRate stores the 0 rate via setInsuranceFundingRate  (which is used later on to calculate the amounts for the insurances) ----withdraw from the Insurance and pay back the flash loan  The insurance rates are 0 now and no-one pays insurance. The gas costs relative to the insurance costs + the flash loan fees determine if this is an economically viable attack. Otherwise it is still a grief attack This will probably be detected pretty soon because the insurance pool will stay empty. However its difficult to prevent.  ## Proof of Concept  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L45 function deposit(uint256 amount) external override {  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L74 function withdraw(uint256 amount) external override {  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L69      function recordTrade(uint256 tradePrice) external override onlyTracer {       ..         if (startLastHour <= block.timestamp - 1 hours) {            ..             updateFundingRate();  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L141 function updateFundingRate() internal {       ..         int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();       ..         int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;      ..         setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L204 function getPoolFundingRate() external view override returns (uint256) {      ..         // If the pool is above the target, we don't pay the insurance funding rate         if (poolTarget <= poolHoldings) {             return 0;         }  ## Tools Used  ## Recommended Mitigation Steps Set a timelock on withdrawing insurance   
# Handle  gpersoon   # Vulnerability details  ## Impact Some of the contracts set variables in the initialize function that are never changed. See for examples in the "proof of concept" section. Here the solidity keyword "immutable" could be added to the variables as an extra security measure.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L17     address public tracer;     IInsurance public insurance;     IOracle public oracle;          https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L24     uint256 public override maxSlippage;     IPricing public pricing;     ITracerPerpetualSwaps public tracer;     address public insuranceContract;     address public fastGasOracle;          //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L20       address public collateralAsset; // Address of collateral asset      address public token; // token representation of a users holding in the pool      ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool   ## Tools Used  ## Recommended Mitigation Steps Add immutable where possible  
# Handle  gpersoon   # Vulnerability details  ## Impact The function claimEscrow of Liquidation.sol can be called by everyone. The claimed funds go to the trader so there are no funds at risk. However the comment says the traders is doing this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L106 /**      * @notice Allows a trader to claim escrowed funds after the escrow period has expired      * @param receiptId The ID number of the insurance receipt from which funds are being claimed from      */     function claimEscrow(uint256 receiptId) public override {   ## Tools Used  ## Recommended Mitigation Steps Double check and it the code works as intended adapt the comment. Otherwise add check that only the trader can call the function.  
# Handle  hrkrshnn   # Vulnerability details  ## Impact  Several variables can be converted into immutables. Doing so can save 2100 gas for storage reads when the slot is warm and 100 otherwise.  ``` Notice: Variable declaration can be converted into an immutable.   --> @openzeppelin/contracts/token/ERC20/ERC20.sol:38:5:    | 38 |     uint256 private _totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:18:5:    | 18 |     ITracerPerpetualsFactory public perpsFactory;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:20:5:    | 20 |     address public collateralAsset; // Address of collateral asset    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:23:5:    | 23 |     address public token; // token representation of a users holding in the pool    |     ^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:25:5:    | 25 |     ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:28:5:    | 28 |     IPricing public pricing;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:29:5:    | 29 |     ITracerPerpetualSwaps public tracer;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:30:5:    | 30 |     address public insuranceContract;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:31:5:    | 31 |     address public fastGasOracle;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Pricing.sol:17:5:    | 17 |     address public tracer;    |     ^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Pricing.sol:18:5:    | 18 |     IInsurance public insurance;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Pricing.sol:19:5:    | 19 |     IOracle public oracle;    |     ^^^^^^^^^^^^^^^^^^^^^ ```  ## Proof of Concept  References to source file and line numbers can be seen above.  ## Tools Used  A custom solidity compiler.  ## Recommended Mitigation Steps  As explained above, these variables can be converted into immutables.  
# Handle  gpersoon   # Vulnerability details  ## Impact If you call the function withdrawFees and the "tvl" would not be enough for the fee then the code would revert. In this case the fees cannot be withdrawn. Although it is unlikely that the tvl would be wrong it is probably better to be able to withdraw the remaining fees.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L508 function withdrawFees() external override {         uint256 tempFees = fees;         fees = 0;         tvl = tvl - tempFees;          // Withdraw from the account         IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);         emit FeeWithdrawn(feeReceiver, tempFees);     }  ## Tools Used  ## Recommended Mitigation Steps Add something like: tempFees = min (fees, tvl); and change fees=0 to: fees -= tempFees;  
# Handle  gpersoon   # Vulnerability details  ## Impact The comments for partialLiquidationIsValid indicate that the params are in WAD format (except liquidationGasCost) However the parameter minimumLeftoverGasCostMultiplier originates from Liquidation.sol and has the value 10. So it is not in WAD format and the comment is misleading.  ## Proof of Concept //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L149  @dev Assumes params are WAD except liquidationGasCost  function partialLiquidationIsValid(         Balances.Position memory updatedPosition,         uint256 lastUpdatedGasPrice,         uint256 liquidationGasCost,         uint256 price,         uint256 minimumLeftoverGasCostMultiplier     )   //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L27 uint256 public override minimumLeftoverGasCostMultiplier = 10;  ## Tools Used  ## Recommended Mitigation Steps Update the comment   
# Handle  gpersoon   # Vulnerability details  ## Impact In function calculateSlippage of LibLiquidation.sol, the value of amountToReturn is calculated by subtracting to numbers. Later on it is check if this value is negative. However amountToReturn is an unsigned integer so it can never be negative. If a negative number would be attempted to be assigned, the code will revert, because solidity 0.8 checks for this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L106 function calculateSlippage( ...             uint256 amountToReturn = 0;             uint256 percentSlippage = 0;             if (avgPrice < receipt.price && receipt.liquidationSide == Perpetuals.Side.Long) {                 amountToReturn = amountExpectedFor - amountSoldFor;             } else if (avgPrice > receipt.price && receipt.liquidationSide == Perpetuals.Side.Short) {                 amountToReturn = amountSoldFor - amountExpectedFor;             }             if (amountToReturn <= 0) {    // can never be smaller than 0, because amountToReturn is uint256                 return 0;             }  ## Tools Used  ## Recommended Mitigation Steps Double check if amountToReturn could be negative. If this is the case change the type of amountToReturn to int256 and add the appropriate type casts   
# Handle  gpersoon   # Vulnerability details  ## Impact The comment for the formula in calcEscrowLiquidationAmount is:  currentMargin - (minMargin - currentMargin) * portion  however it is coded as:  {currentMargin - (minMargin - currentMargin)} * portion  According to Ray/Lions mane the comment is wrong  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L32 //       Calculated as currentMargin - (minMargin - currentMargin) * portion of whole position being liquidated function calcEscrowLiquidationAmount( ..         int256 amountToEscrow = currentMargin - (minMargin.toInt256() - currentMargin);         int256 amountToEscrowProportional = PRBMathSD59x18.mul(amountToEscrow, PRBMathSD59x18.div(amount, totalBase));   ## Tools Used  ## Recommended Mitigation Steps Fix the comment  
# Handle  gpersoon   # Vulnerability details  ## Impact Solidity allows some tricks to make the code easier to read:     LibMath.sol:     uint256 public constant POSITIVE_INT256_MAX = 2**255 - 1;     uint256 public constant POSITIVE_INT256_MAX = uint(type(int256).max);   // alternative coding  Insurance.sol:     uint256 public multiplyFactor = 36523 * (10**11);     uint256 public multiplyFactor = 0.0036523e18;   // alternative coding   ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps Use the most readable coding   
# Handle  gpersoon   # Vulnerability details  ## Impact At several places constants are hardcoded as numbers. It's more readable and more maintainable to turn them into explicit constants. That also lowers to risk to change it on one place and forget is on another place. See examples in proof of concept  ## Proof of Concept .\Insurance.sol:            if (publicCollateralAmount > 10**18) { .\Insurance.sol:                amount = poolHoldings - 10**18; .\Insurance.sol:                publicCollateralAmount = 10**18; .\Insurance.sol:            if (publicCollateralAmount < 10**18) { .\Insurance.sol:            } else if (poolHoldings - amount < 10**18) { .\Insurance.sol:                amount = poolHoldings - 10**18; .\Insurance.sol:                publicCollateralAmount = 10**18; .\Insurance.sol:            uint256 multiplyFactor = 36523 * (10**11); .\Insurance.sol:        return tracer.leveragedNotionalValue() / 100; .\oracle\GasOracle.sol:    uint8 public override decimals = 18; .\lib\libprices.sol:       for (uint256 i = 0; i < 8; i++) { .\lib\libprices.sol:           uint256 currTimeWeight = 8 - i; .\lib\LibPrices.sol:        return (averageTracerPrice.toInt256() - averageOraclePrice.toInt256()) / 90; .\lib\LibBalances.sol:        uint256 adjustedLiquidationGasCost = liquidationGasCost * 6; .\lib\LibPerpetuals.sol:        percentFull = percentFull * 100; // To bring it up to the same percentage units as everything else .\Liquidation.sol:    uint256 public override minimumLeftoverGasCostMultiplier = 10;  ## Tools Used  ## Recommended Mitigation Steps Replace numeric values with constants   
# Handle  gpersoon   # Vulnerability details  ## Impact There are several todos left in the code.  ## Proof of Concept .\Pricing.sol:                     // todo by using public variables lots of these can be removed .\Trader.sol:                      // todo this could be succeptible to re-entrancy as .\lib\LibLiquidation.sol:    // todo with the below * -1, note ints can overflow as 2^-127 is valid but 2^127 is not. .\lib\LibPrices.sol:             // todo double check safety of this.  ## Tools Used  ## Recommended Mitigation Steps Check, fix and remove the todos before it is deployed in production    
# Handle  gpersoon   # Vulnerability details  ## Impact The library prb-math documents that it is not audited by a security researcher.  This means its more risky to rely on this library.  ## Proof of Concept // https://github.com/hifi-finance/prb-math#security The contracts have not been audited by a security researcher.      ## Tools Used  ## Recommended Mitigation Steps Consider (crowdsourcing) an audit for prb-math   
# Handle  gpersoon   # Vulnerability details  ## Impact The constructor of Insurance.so does an emit. However the constructors of the other contracts (InsurancePoolToken.sol, Liquidation.sol, Pricing.sol, TracerPerpetualSwaps.sol, TracerPerpetualsFactory.sol, Trader.sol) don't do an emit in the constructor.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L31 constructor(address _tracer) {      ...         emit InsurancePoolDeployed(_tracer, tracer.tracerQuoteToken());     }  ## Tools Used  ## Recommended Mitigation Steps Perhaps it's useful for other constructor to also include an emit   
# Handle  gpersoon   # Vulnerability details  ## Impact The function matchOrders of TracerPerpetualSwaps.sol doesn't check that the contract itself is indeed equal to order1.market and order2.market. The function executeTrade Trader.sol, which calls the matchOrders, can deal with multiple markets. Suppose there would be a mistake in executeTrade,  or in a future version, the matchOrders would be done in the wrong market.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L216 function matchOrders( Perpetuals.Order memory order1, Perpetuals.Order memory order2, uint256 fillAmount )   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67  function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external  override { ...  (bool success, ) = makeOrder.market.call(                 abi.encodePacked(                     ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,                     abi.encode(makeOrder, takeOrder, fillAmount)                 )             );   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibPerpetuals.sol#L128 function canMatch( Order memory a, uint256 aFilled,Order memory b, uint256 bFilled ) internal view returns (bool) {     ...         bool marketsMatch = a.market == b.market;  ## Tools Used  ## Recommended Mitigation Steps Add something like: require ( order1.market == address(this), "Wrong market");  Note: canMatch already verifies that  order1.market== order2.market   
# Handle  gpersoon   # Vulnerability details  ## Impact A liquidator can always claim the liquidation escrow in the following way: - create a second account - setup a complimentary trade in that second account, which will result in a large slippage when executed - call executeTrade (which everyone can call), to execute a trade between his own two accounts with a large slippage - the slippage doesn't hurt because the liquidator owns both accounts - call claimReceipt with the receiptId of the executed order, within the required period (e.g. 15 minutes)  ## Proof of Concept   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67 function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external override {  https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L394  function claimReceipt( uint256 receiptId, Perpetuals.Order[] memory orders, address traderContract) external override {  ## Tools Used  ## Recommended Mitigation Steps perhaps limit who can call executeTrade   
# Handle  shw   # Vulnerability details  ## Impact  The `recordTrade` function in `Pricing` updates the `currentHour` variable by 1 every hour. However, if there is no trade (i.e., the `recordTrade` is not called) during this hour, the `currentHour` is out of sync with the actual hour. As a result, the `averagePriceForPeriod` function uses the prices before 24 hours and causes errors on the average price.  ## Proof of Concept  Referenced code: [Pricing.sol#L90-L94](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L90-L94)  ## Recommended Mitigation Steps  Calculate how much time passed (e.g., `(block.timestamp - startLastHour) / 3600`) to update the `currentHour` variable correctly.  
# Handle  shw   # Vulnerability details  ## Impact  The `averagePriceForPeriod` function of `LibPrices` does not handle the case where `j` equals 0 (i.e., no trades happened in the last 24 hours). The transaction reverts due to dividing by 0 without a proper error message returned.  ## Proof of Concept  Referenced code: [LibPrices.sol#L73](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibPrices.sol#L73)  ## Recommended Mitigation Steps  Add `require(j > 0, "...")` before line 73 to handle this special case.  
# Handle  shw   # Vulnerability details  ## Impact  The `getHourlyAvgTracerPrice` and `getHourlyAvgOraclePrice` functions in `Pricing` return 0 if there is no trade during the given `hour` because of the design of `averagePrice`, which could mislead users that the hourly average price is 0. The same problem happens when emitting the old hourly average in the `recordTrade` function.  ## Proof of Concept  Referenced code: [Pricing.sol#L254-L256](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L254-L256) [Pricing.sol#L262-L264](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L262-L264) [Pricing.sol#L74](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L74)  ## Recommended Mitigation Steps  Return a special value (e.g., `type(uint256).max`) from `averagePrice` if there is no trade during the specified hour to distinguish from an actual zero price. Handle this particular value whenever the `averagePrice` function is called by others.  
# Handle  shw   # Vulnerability details  ## Impact  Most of the contracts use an unlocked pragma (e.g., `pragma solidity ^0.8.0`) which is not fixed to a specific Solidity version. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler version with which they have been tested the most.  ## Proof of Concept  Referenced code: Please use `grep -R pragma .` to find the unlocked pragma statements.  ## Recommended Mitigation Steps  Lock pragmas to a specific Solidity version. Consider the compiler bugs in the following lists and ensure the contracts are not affected by them. It is also recommended to use the latest version of Solidity when deploying contracts (see [Solidity docs](https://docs.soliditylang.org/en/v0.8.6/)).  Solidity compiler bugs: [Solidity repo - known bugs](https://github.com/ethereum/solidity/blob/develop/docs/bugs.json) [Solidity repo - bugs by version](https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json)  
# Handle  0xsanson   # Vulnerability details  ## Impact In Liquidation.verifyAndSubmitLiquidation(...) we can save the minimumMargin to memory since it's called two times.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L171  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Save the result of Balances.minimumMargin(...) to memory.  
# Handle  0xsanson   # Vulnerability details  ## Impact The claimEscrow(...) function in Liquidation.sol can be set external instead of public since it's not used in the contract. (code clarity and gas savings)  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L109  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change public to external.  
# Handle  0xsanson   # Vulnerability details  ## Impact In LibBalances.applyTrade() we need to collect a fee from the trade. The current code however subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (see TracerPerpetualSwaps.sol#L272). This issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L187  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change +fee to -fee in the highlighted line.  
# Handle  0xsanson   # Vulnerability details  ## Impact We can save gas by substituting getPoolTarget() with levNotionalValue/100, since tracer.leveragedNotionalValue() is already saved in memory.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L216  ## Tools Used Manual analysis.  ## Recommended Mitigation Steps Substitute getPoolTarget() with levNotionalValue/100.  
# Handle  0xsanson   # Vulnerability details  ## Impact State variable perpsFactory is not used in the Insurance contract.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L18  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Just delete it.  
# Handle  0xsanson   # Vulnerability details  ## Impact In the trader contract isValidSignature(...) and verifySignature(...) serve the same purpose. Suggested keep only one for code clarity.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L206 https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L231  ## Tools Used Manual analysys  ## Recommended Mitigation Steps Suggested keep only one function for code clarity.  
# Handle  a_delamo   # Vulnerability details  ## Impact  For every new TracerPerpetualSwaps contract, we need to deploy a new Liquidation, Insurance, and Pricing contract.  All these deployments are really gas-intensive, so it would be recommended to use EIP-1167: Minimal Proxy Contract to reduce the gas cost of the deployments.  ```solidity function _deployTracer(         bytes calldata _data,         address tracerOwner,         address oracle,         address fastGasOracle,         uint256 maxLiquidationSlippage     ) internal returns (address) {         // Create and link tracer to factory         address market = IPerpsDeployer(perpsDeployer).deploy(_data);         ITracerPerpetualSwaps tracer = ITracerPerpetualSwaps(market);          validTracers[market] = true;         tracersByIndex[tracerCounter] = market;         tracerCounter++;          // Instantiate Insurance contract for tracer         address insurance = IInsuranceDeployer(insuranceDeployer).deploy(market);         address pricing = IPricingDeployer(pricingDeployer).deploy(market, insurance, oracle);         address liquidation = ILiquidationDeployer(liquidationDeployer).deploy(             pricing,             market,             insurance,             fastGasOracle,             maxLiquidationSlippage         );          // Perform admin operations on the tracer to finalise linking         tracer.setInsuranceContract(insurance);         tracer.setPricingContract(pricing);         tracer.setLiquidationContract(liquidation);          // Ownership either to the deployer or the DAO         tracer.transferOwnership(tracerOwner);         ILiquidation(liquidation).transferOwnership(tracerOwner);         emit TracerDeployed(tracer.marketId(), address(tracer));         return market;     } ```   More info: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/ https://eips.ethereum.org/EIPS/eip-1167   
# Handle  0xsanson   # Vulnerability details  ## Impact In the Pricing contract, an agent can manipulate the trading prices by spamming an high amount of trades.  Indeed an agent can create an high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn't even need large funds); next he/she pairs the orders with another account and calls Trader.executeTrade; now every order calls a Pricing.recordTrade using the arbitrary price set by the agent.  Since the trades are all made in the same hour, by the way hourlyTracerPrices[currentHour] is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate the fundingRates and the fairPrice, letting a malicious agent get the ability to manipulate the market.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L129  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Pass the fillAmount parameter to recordTrade(...), and calculate hourlyTracerPrices[currentHour].trades summing fillAmount instead of 1 every trade.  
# Handle  tensors   # Vulnerability details  ## Impact Superfluous type conversions.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L229-L230 The type conversion here is not necessary.  ## Recommended Mitigation Steps Remove the type conversion.  
# Handle  0xsanson   # Vulnerability details  ## Impact The contract TracerPerpetualSwaps introduces these four state variables (lowestMaxLeverage,  maxLeverage, insurancePoolSwitchStage and deleveragingCliff) and four respective set functions. Logically the following relations are needed: lowestMaxLeverage < maxLeverage and insurancePoolSwitchStage < deleveragingCliff, but the code doesn't check for them.  Non-critical because needs an error by the owner.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L552 Also lines L560, L564, L568  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add appropriate requires to the set functions and the constructor.  
# Handle  tensors   # Vulnerability details  ## Impact The contracts assume that all tokens will have <=18 decimals. If the Tracer team are the only people deploying the contracts, and they keep this in mind, this isn't a problem. If the contracts are to be deployed by other people, this assumption should be made explicit and hard-coded.   ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L220-L232 We can see that the scaler computations will underflow and be defined when it should not be.  ## Recommended Mitigation Steps Write a require check that ensures tokenDecimals <= 18 before running the above functions.  
# Handle  s1m0   # Vulnerability details  ## Impact The smart contract doesn't check the return value of token.transfer() and token.transferFrom(), some erc20 token might not revert in case of error but return false. In the [TracerPerpetualSwaps:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L151) and [Insurance:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L51) this would allow a user to deposit for free. Other places: [TracerPerpetualSwaps: withdraw](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L203) [TracerPerpetualSwaps:withdrawFees](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L514) [SafetyWithdraw:withdrawERC20Token](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/SafetyWithdraw.sol#L13) [Insurance:withdraw](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L97)  ## Recommended Mitigation Steps Wrap the call into a require() or use openzeppelin's [SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) library.  
# Handle  pauliax   # Vulnerability details  ## Impact Here the check currentMargin < Balances.minimumMargin should be inclusive <= to indicate the account is not above minimum margin:     require(         currentMargin <= 0 ||             uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),         "LIQ: Account above margin"     );  ## Recommended Mitigation Steps uint256(currentMargin) <= Balances.minimumMargin ...  
# Handle  pauliax   # Vulnerability details  ## Impact Could save some gas here when amountToReturn = receipt.escrowedAmount:     if (amountToReturn > receipt.escrowedAmount) {        liquidationReceipts[receiptId].escrowedAmount = 0;     } else {        liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;     }  ## Recommended Mitigation Steps  if (amountToReturn >= receipt.escrowedAmount) { ...  
# Handle  cmichel   # Vulnerability details  The `TracerPerpetualSwaps.settle` function updates the user's last index to `currentGlobalFundingIndex`, however a comment states:  > "// Note: global rates reference the last fully established rate (hence the -1), and not the current global rate. User rates reference the last saved user rate"  The code for the `else` branch also updates the last index to `currentGlobalFundingIndex - 1` instead of `currentGlobalFundingIndex`.  ```solidity if (accountBalance.position.base == 0) {     // set to the last fully established index     // @audit shouldn't this be global - 1 like below?     accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;     accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer(); } ```   ## Impact It might be possible that first-time depositors skip having to pay the first funding rate period as the `accountLastUpdatedIndex + 1 < currentGlobalFundingIndex` check will still return `false` when the funding rates are updated the next time.  ## Recommended Mitigation Steps Check if setting it to `currentGlobalFundingIndex` or to `currentGlobalFundingIndex - 1` is correct.  
# Handle  cmichel   # Vulnerability details  The `Liquidation` contract allows the liquidator to submit "bad" trade orders and the insurance reimburses them from the insurance fund, see `Liquidation.claimReceipt`. The function can be called with an `orders` array which does not check for duplicate orders. An attacker can abuse this to make a profit by liquidating themselves, making a small bad trade and repeatedly submitting this bad trade for slippage reimbursement.  Example: - Attacker uses two accounts, one as the liquidator and one as the liquidatee. - They run some high-leverage trades such that the liquidatee gets liquidated with the next price update. (If not cash out and make a profit this way through trading, and try again.) - Liquidator liquidates liquidatee - They now do two trades:   - One "good" trade at the market price that fills 99% of the liquidation amount. The slippage protection should not kick in for this trade   - One "bad" trade at a horrible market price that fills only 1% of the liquidation amount. This way the slippage protection kicks in for this trade - The liquidator now calls `claimReceipt(orders)` where `orders` is an array that contains many duplicates of the "bad" trade, for example 100 times. The `calcUnitsSold` function will return `unitsSold = receipt.amountLiquidated` and a bad `avgPrice`. They are now reimbursed the price difference on the full liquidation amount (instead of only on 1% of it) making an overall profit  This can be repeated until the insurance fund is drained.  ## Impact  The attacker has an incentive to do this attack as it's profitable and the insurance fund will be completely drained.  ## Recommended Mitigation Steps Disallow duplicate orders in the `orders` argument of `claimReceipt`. This should make the attack at least unprofitable, but it could still be a griefing attack. A quick way to ensure that `orders` does not contain duplicates is by having liquidators submit the orders in a sorted way (by order ID) and then checking in the `calcUnitsSold` `for` loop that the current order ID is strictly greater than the previous one.  
# Handle  cmichel   # Vulnerability details  There are several setter functions that do not check if the amount is less than 100%.  - `TracerPerpetualSwaps`: `setFeeRate`, `setDeleveragingCliff`, `setInsurancePoolSwitchStage` - `Insurance`: `setFeeRate`, `setDeleveragingCliff`, `setInsurancePoolSwitchStage`  ## Impact Setting values to more than 100% might lead to unintended functionality.  ## Recommended Mitigation Steps Ensure that the parameters are less than 100%.  
# Handle  cmichel   # Vulnerability details  The pool holdings of `Insurance` (`publicCollateralAmount` and `bufferCollateralAmount`) is in WAD (18 decimals) but it's used as a raw token value in `drainPool`  ```solidity // amount is a mix of pool holdings, i.e., 18 decimals // this requires amount to be in RAW! if tracerMarginToken has > 18 decimals, it'll break, < 18 decimals will approve too much tracerMarginToken.approve(address(tracer), amount); // this requires amount to be in WAD which is correct tracer.deposit(amount); ```  ## Impact  If `tracerMarginToken` has less than 18 decimals, the approval approves orders of magnitude more tokens than required for the `deposit` call that follows. If `tracerMarginToken` has more than 18 decimals, the `deposit` that follows would fail as fewer tokens were approved, but the protocol seems to disallow tokens in general with more than 18 decimals.  ## Recommended Mitigation Steps Convert the `amount` to a "raw token value" and approve this one instead.   
# Handle  cmichel   # Vulnerability details  The `GasOracle` uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD.  However, the scaling depends on the underlying decimals of the two oracles and could be anything. But the code assumes it's in 18 decimals.  > "Returned value is USD/Gas * 10^18 for compatibility with rest of calculations"  There is a `toWad` function that seems to involve scaling but it is never used.  ## Impact** If the scale is wrong, the gas price can be heavily inflated or under-reported.   ## Recommended Mitigation Steps Check `chainlink.decimals()` to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the `latestAnswer` function always returns the answer in 18 decimals.  
# Handle  cmichel   # Vulnerability details  When `LibMath.sumN` function does not check if `n <= arr.length` and can therefore fail if called with `n > arr.length`.  ## Impact The caller must always check that it's called with an argument that is less than `n` which is inconvenient.  ## Recommendation Change the condition to iterate up to `min(n, arr.length)`.   
# Handle  cmichel   # Vulnerability details   When `LibMath.abs` is called with -2^255 (`type(int256).min`), it tries to multiply it by `-1` but it'll fail as it exceeds the max signed 256-bit integers.  ## Impact The function will fail with an implicit error that might be hard to locate.  ## Recommendation Throw an error similar to `toInt256` like `int256 overflow`.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  In function minimumMargin(), maximumLeverage being zero is not handled because it will result in div by zero as PRBMathUD60x18.div expects non-zero divisor.   Impact: Various critical market functions will revert if maximumLeverage is zero.  ## Proof of Concept  https://github.com/hifi-finance/prb-math/blob/c4dea7d0e6ae246fbb631f7fb4be4072d1da9a07/contracts/PRBMathUD60x18.sol#L71-L77   https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L118  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L135  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L186  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L242  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L248  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add checks to make sure maximumLeverage is never zero or handle appropriately.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The withdrawERC20Token() in SafetyWithdraw inherited in TracerPerpetualSwaps is presumably a guarded launch emergency withdrawal mechanism. However, given the trust model where the market creator/owner is potentially untrusted/malicious, this is a dangerous approach to emergency withdrawal in the context of guarded launch.   Alternatively, if this is meant for the owner to withdraw “external” ERC20 tokens mistakenly deposited to the Tracer market then the function should exclude tracerQuoteToken from being the tokenAddress that can be used as a parameter to withdrawERC20Token().  Impact: Malicious owner of a market withdraws/rugs all tracerQuoteTokens deposited at any time after market launch. All users lose deposits. Protocol takes a reputational hit and has to refund the users from treasury.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/SafetyWithdraw.sol#L8-L14  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L20   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  For a guarded launch circuit breaker, design a pause/unpause feature where deposits are paused  (in emergency situations) but withdrawals are allowed by the depositors themselves instead of the owner. Alternatively, if this is meant to be for removing external ERC20 tokens accidentally deposited to market, exclude the tracerQuoteToken from being given as the tokenAddress.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The sumN() library function expects to calculate the sum of n elements of the supplied array but there is no check to see if the array indeed has n elements. A smaller array could lead to reading out of bounds memory resulting in undefined values.  Impact: The current usage of the library does not indicate an out of bounds access but any new code using this library could be impacted.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibMath.sol#L38-L46  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibMath.sol#L68  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibPrices.sol#L73   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add require(n <= arr.length) at the beginning of sumN() to be safe.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The setDecimals() in the sample Gas Price Oracle implementation allows anyone to set the decimals value used by the contract but is not used anywhere.  Impact: It is unclear if this should be set by anyone and if that value should be used in determining the precision of the values returned.  ## Proof of Concept   https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/oracle/GasOracle.sol#L64-L66   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate if this access and missing logic is correct.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Time ranges are typically open-ended which includes the start & end times, and not close-ended. So the releaseTime would be interpreted as the time it would be released i.e. block.timestamp >= releaseTime would be the expected check here instead of ‘>’. Similarly, on L406, it should be ‘<=‘ instead of ‘<‘.  Impact: Claims of escrow and receipts are expected to succeed in a particular block but they revert and have to wait until the next block.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L112  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L406  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Unless justified, change the strict inequality and make it ‘>=‘ and ‘<=‘ to convert open ranges to closed ranges for block.timestamp comparisons.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The updateFundingRate() function updates the funding rate and insurance funding rate. While the instant/new funding rates are calculated correctly, the cumulative funding rate calculation is incorrect because it is always adding the instant to 0, not the previous value. This is due to the use of [currentFundingIndex] which has been updated since the previous call to this function while it should really be using [currentFundingIndex-1] to reference the previous funding rate.  Impact: The cumulative funding rate and insurance funding rates are calculated incorrectly without considering the correct previous values. This affects the settling of accounts across the entire protocol. The protocol logic is significantly impacted, accounts will not be settled as expected, protocol shutdown and contracts will need to be redeployed. Users may lose funds and protocol takes a reputation hit.   ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L155-L160  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L168  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L77  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L196-L215  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L221-L230  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L445-L446  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use [currentFundingIndex-1] for non-zero values of currentFundingIndex to get the value updated in the previous call on lines L155 and L159 of Pricing.sol.  
# Handle  0xRajeev   # Vulnerability details  ## Impact Trading function executeTrade() batch executes maker/taker orders against a market. The trader/interface provides arrays of makers/takers which is unbounded. As a result, if the number of orders is too many, there is a risk of this transaction exceeding the block gas limit (which is 15 million currently).  Impact: executeTrade() is called with too many orders in the batch. Tx exceeds block gas limit and reverts. None of the orders are executed.  ## Proof of Concept  See similar Medium-severity finding from ConsenSys's Audit of Growth DeFi: https://consensys.net/diligence/audits/2020/12/growth-defi-v1/#potential-resource-exhaustion-by-external-calls-performed-within-an-unbounded-loop  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Trader.sol#L67  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Trader.sol#L78  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Limit the number or orders executed based on gasleft() after every iteration or estimate the gas cost and enforce an upper bound on the number of orders allowed in maker/taker arrays.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Tracer protocol like any other allows market creators to charge fees for trades. However, a malicious/greedy owner can arbitrarily change fee to any % value and without an event to observe this change or a timelock to react, there is no easy way for users to monitor this via front-end or off-chain monitoring tools.  Impact: Users trade on a market with 0.1% fees. The owner suddenly changes this to 100%. Users realise this only after their trades are executed. Market loses confidence. Protocol takes a reputational hit.  ## Proof of Concept  See similar Medium-severity finding in ConsenSys's Audit of 1inch Liquidity Protocol (https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L548-L550  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L198-L214  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit event, provide time lock for users to react and establish an upper threshold for fees that is decided across markets by governance.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  withdrawFees() is an external function which can be called by anyone to transfer the accumulated fees to the feeReceiver account. However, there is no data validation to check if fees are non-zero.  Impact: One can keep calling withdrawFees(), even if the fees is zero, to grief the system with 0 amount transfers and emission of events recording the same. This leads to what is known as event log poisoning where malicious external users spam the Tracer contract to generate arbitrary FeeWithdrawn events.  ## Proof of Concept  See similar Finding from Sigma Prime’s audit of Synthetix Unipool: https://github.com/sigp/public-audits/blob/master/synthetix/unipool/review.pdf  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L508-L516  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider adding a require or if statement preventing the withdrawFees() function from emitting the event when the amount variable is zero, i.e. check if fees != 0 before transfer+emit.  
# Handle  JMukesh   # Vulnerability details  ## Impact public function which are not called within contract should be declared as external to save gas  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L572  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L470  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/InsurancePoolToken.sol#L14  ## Tools Used  manual review  ## Recommended Mitigation Steps  Declare public function as external which are not called in the contract  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Reference type local variables require an explicit data location specified indicating if they need to be in storage or memory. Assigning state variables to storage local variables creates a reference  (instead of a copy) to the state variable and modifications to the local variable will be reflected in the state variable. This is required if the intention is to make updates to state variables. Unnecessarily using storage specifiers may lead to unintentional updates of state variables and has led to vulnerabilities.  In L457 of settle(), a local variable insuranceBalance is created in storage to point to balances[address(insuranceContract)] but is never updated. Instead balances[address(insuranceContract)] itself is updated on L474.  Impact: While there is no immediate impact, any modifications to the code with insuranceBalance will be dangerous because it will update the critical state variable balances[address(insuranceContract)]. It is safer to use a memory specifier for insuranceBalance.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L456-L457  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L467  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L474  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace the use of storage specifier on L457 with memory.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The tvl calculation in deposit() uses convertedWadAmount but the one in withdraw() uses the parameter amount. While amount is still in WAD format, it may contain dust which is what the conversion to rawTokenAmount and then back to convertedWadAmount removes.  Impact: Use of amount in tvl during withdraw() will consider dust while the one in deposit() will not, which is inconsistent.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L200  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L176-L177  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L162  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L153-L155  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use convertedWadAmount instead of amount to be consistent with the increment during withdraw() tvl calculation.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The Deposit event uses the function parameter amount instead of the convertedWadAmount which is what is used to update the user’s position and tvl because it prevents any dust deposited in amount. This will also make it consistent with the emit event in withdraw function.  Impact: Deposit event amount reflects the value with dust while the user position does not. This may lead to confusion.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L163  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L153-L162  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L204  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use uint256(convertedWadAmount) instead of amount in Deposit event.  
# Handle  pauliax   # Vulnerability details  ## Impact Trader function executeTrade calculates executionPrice, newMakeAverage, newTakeAverage, then calls the market, and only if it succeeds it uses these variables.  ## Recommended Mitigation Steps Better first call the market and only then calculate and use these variables to avoid useless calculations and gas costs.  
# Handle  pauliax   # Vulnerability details  ## Impact Insurance function drainPool calculates 10**18 many times. To reduce the number of calculations and save gas, this number can be extracted as a constant variable and used everywhere where necessary.  ## Recommended Mitigation Steps Extract 10**18 as a constant.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The gas cost for liquidation may change if code is updated/optimized, compiler changed or profiling improved. The developers may forget to update this constant in code.  Impact: The margin validity calculation which uses this value may be affected if this changes and hence is not as declared in the constant. This may adversely impact validation.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L26  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L244  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L250  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L494  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L159  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L193  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  It is safer to make this a constructor-set immutable value that will force usage of an updated accurate value at deployment time. Evaluate if the sensitivity to this value is great enough to justify a setter to change it if incorrectly initialized at deployment.  
# Handle  pauliax   # Vulnerability details  ## Impact Contract Trader has 2 mappings: orders and orderToSig. I see that orderToSig also stores Perpetuals.Order inside it, so I wonder if it really was necessary to separate these mappings as some state (order) is duplicated among them. It may be a bit more efficient to access orders without signatures but it also makes it more error-prone as you need to keep the invariant that orders match in these mappings. Currently I don't see an exact problem as orderToSig are only set in function grabOrder and never used in code anywhere but I am not sure if it is really necessary.   Tracer representetive's answer on Discord: 'Yeah thats a good point on the Trader mapping, one does look redundant now as they both store the order itself. I think originally one was mutated and one wasn't, but then that functionality got moved into the filled mapping anyway. Seems safe to remove orders and simply reference the orderToSig mapping'.  ## Recommended Mitigation Steps Remove orders and simply reference the orderToSig mapping.  
# Handle  JMukesh   # Vulnerability details  ## Impact state variable which have to initialise in constructor can be declared as immutable to save gas  ## Proof of Concept  https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Insurance.sol#L23  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Insurance.sol#L20  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L30  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L31  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L17  ## Tools Used  manual review  
# Handle  JMukesh   # Vulnerability details  ## Impact Unused state variable will increase unnecessarily code size and use the memory  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/oracle/GasOracle.sol#L19  ## Tools Used  manual review  ## Recommended Mitigation Steps  remove the variable which are unused  
# Handle  hrkrshnn   # Vulnerability details  ## Impact  Gas optimization.  ## Use at least 0.8.4 instead of 0.8.0  It has an important optimization improvement: a low level inliner. Especially since you have several small functions.  The current hardhat config indicates that version `0.8.0` is being used.    
# Handle  hrkrshnn   # Vulnerability details  ## Impact  Gas optimization.  ## For function arguments, change `memory` to `calldata`  There are several places where this is applicable, however, will point out one such occasion:  ``` diff modified   src/contracts/Trader.sol @@ -64,7 +64,7 @@ contract Trader is ITrader {       * @param makers An array of signed make orders       * @param takers An array of signed take orders       */ -    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) +    function executeTrade(Types.SignedLimitOrder[] calldata makers, Types.SignedLimitOrder[] calldata takers)          external          override      { @@ -144,7 +144,7 @@ contract Trader is ITrader {       * @dev Should only be called with a verified signedOrder and with index       *      < signedOrders.length       */ -    function grabOrder(Types.SignedLimitOrder[] memory signedOrders, uint256 index) +    function grabOrder(Types.SignedLimitOrder[] calldata signedOrders, uint256 index)          internal          returns (Perpetuals.Order memory)      { ```  Reason: when you specify `memory` for a (non value type) function-parameter for an external function, the following happens: the compiler would copy elements from `calldata` to `memory` (using the opcode `calldatacopy`.) Then later on, the internal call (here `grabOrder`) would pass a memory reference. However, this is a great example of where copying to memory is unnecessary. Note that there is also the opcode `calldataload` to read an offset from `calldata`. By changing the location from `memory` to `calldata`, you avoid this expensive copy from `calldata` to `memory`, while managing to do exactly what's needed.  You would only have to use `memory` if the function has to modify the parameter, in which case a copy is really needed as `calldata` cannot be modified.    
# Handle  JMukesh   # Vulnerability details  ## Impact These array memory parameter can be  problematic if not used properly , if the array is very large it may overlap over other part of memory.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L274  This an example to show the exploit: // based on https://github.com/paradigm-operations/paradigm-ctf-2021/blob/master/swap/private/Exploit.sol pragma solidity ^0.4.24; // only works with low solidity version  contract test{ struct Overlap { uint field0; } event log(uint);  function mint(uint[] memory amounts) public returns (uint) {  // this can be in any solidity version Overlap memory v; v.field0 = 1234; emit log(amounts[0]); // would expect to be 0 however is 1234 return 1; }  function go() public { // this part requires the low solidity version uint x=0x800000000000000000000000000000000000000000000000000000000000000; // 2^251 bytes memory payload = abi.encodeWithSelector(this.mint.selector, 0x20, x); bool success=address(this).call(payload); } } ## Tools Used  manual review  ## Recommended Mitigation Steps  check array length before using it  
# Handle  gpersoon   # Vulnerability details  ## Impact It's possible to avoid paying insurance in the following way: - once per hour (at the right moment), do the following: ----using a flash loan, or with a large amount of tokens, call deposit of Insurance.sol to make sure that the pool is sufficiently filled (poolHoldings > poolTarget) ----call the function executeTrade of Trader.sol with a minimal trade (possibly of value 0, see finding "executeTrade with same trades") ----executeTrade calls matchOrders, which calls recordTrade ----recordTrade calls updateFundingRate();   (once per hour, so you have to be sure you do it in time before other trades trigger this) ----updateFundingRate calls getPoolFundingRate ----getPoolFundingRate determines the insurance rate, but because the insurance pool is sufficiently full (due to the flash loan), the rate is 0 ----updateFundingRate stores the 0 rate via setInsuranceFundingRate  (which is used later on to calculate the amounts for the insurances) ----withdraw from the Insurance and pay back the flash loan  The insurance rates are 0 now and no-one pays insurance. The gas costs relative to the insurance costs + the flash loan fees determine if this is an economically viable attack. Otherwise it is still a grief attack This will probably be detected pretty soon because the insurance pool will stay empty. However its difficult to prevent.  ## Proof of Concept  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L45 function deposit(uint256 amount) external override {  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L74 function withdraw(uint256 amount) external override {  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L69      function recordTrade(uint256 tradePrice) external override onlyTracer {       ..         if (startLastHour <= block.timestamp - 1 hours) {            ..             updateFundingRate();  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L141 function updateFundingRate() internal {       ..         int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();       ..         int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;      ..         setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L204 function getPoolFundingRate() external view override returns (uint256) {      ..         // If the pool is above the target, we don't pay the insurance funding rate         if (poolTarget <= poolHoldings) {             return 0;         }  ## Tools Used  ## Recommended Mitigation Steps Set a timelock on withdrawing insurance   
# Handle  gpersoon   # Vulnerability details  ## Impact Some of the contracts set variables in the initialize function that are never changed. See for examples in the "proof of concept" section. Here the solidity keyword "immutable" could be added to the variables as an extra security measure.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L17     address public tracer;     IInsurance public insurance;     IOracle public oracle;          https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L24     uint256 public override maxSlippage;     IPricing public pricing;     ITracerPerpetualSwaps public tracer;     address public insuranceContract;     address public fastGasOracle;          //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L20       address public collateralAsset; // Address of collateral asset      address public token; // token representation of a users holding in the pool      ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool   ## Tools Used  ## Recommended Mitigation Steps Add immutable where possible  
# Handle  gpersoon   # Vulnerability details  ## Impact The function claimEscrow of Liquidation.sol can be called by everyone. The claimed funds go to the trader so there are no funds at risk. However the comment says the traders is doing this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L106 /**      * @notice Allows a trader to claim escrowed funds after the escrow period has expired      * @param receiptId The ID number of the insurance receipt from which funds are being claimed from      */     function claimEscrow(uint256 receiptId) public override {   ## Tools Used  ## Recommended Mitigation Steps Double check and it the code works as intended adapt the comment. Otherwise add check that only the trader can call the function.  
# Handle  hrkrshnn   # Vulnerability details  ## Impact  Several variables can be converted into immutables. Doing so can save 2100 gas for storage reads when the slot is warm and 100 otherwise.  ``` Notice: Variable declaration can be converted into an immutable.   --> @openzeppelin/contracts/token/ERC20/ERC20.sol:38:5:    | 38 |     uint256 private _totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:18:5:    | 18 |     ITracerPerpetualsFactory public perpsFactory;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:20:5:    | 20 |     address public collateralAsset; // Address of collateral asset    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:23:5:    | 23 |     address public token; // token representation of a users holding in the pool    |     ^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:25:5:    | 25 |     ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:28:5:    | 28 |     IPricing public pricing;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:29:5:    | 29 |     ITracerPerpetualSwaps public tracer;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:30:5:    | 30 |     address public insuranceContract;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:31:5:    | 31 |     address public fastGasOracle;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Pricing.sol:17:5:    | 17 |     address public tracer;    |     ^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Pricing.sol:18:5:    | 18 |     IInsurance public insurance;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Pricing.sol:19:5:    | 19 |     IOracle public oracle;    |     ^^^^^^^^^^^^^^^^^^^^^ ```  ## Proof of Concept  References to source file and line numbers can be seen above.  ## Tools Used  A custom solidity compiler.  ## Recommended Mitigation Steps  As explained above, these variables can be converted into immutables.  
# Handle  gpersoon   # Vulnerability details  ## Impact If you call the function withdrawFees and the "tvl" would not be enough for the fee then the code would revert. In this case the fees cannot be withdrawn. Although it is unlikely that the tvl would be wrong it is probably better to be able to withdraw the remaining fees.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L508 function withdrawFees() external override {         uint256 tempFees = fees;         fees = 0;         tvl = tvl - tempFees;          // Withdraw from the account         IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);         emit FeeWithdrawn(feeReceiver, tempFees);     }  ## Tools Used  ## Recommended Mitigation Steps Add something like: tempFees = min (fees, tvl); and change fees=0 to: fees -= tempFees;  
# Handle  gpersoon   # Vulnerability details  ## Impact The comments for partialLiquidationIsValid indicate that the params are in WAD format (except liquidationGasCost) However the parameter minimumLeftoverGasCostMultiplier originates from Liquidation.sol and has the value 10. So it is not in WAD format and the comment is misleading.  ## Proof of Concept //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L149  @dev Assumes params are WAD except liquidationGasCost  function partialLiquidationIsValid(         Balances.Position memory updatedPosition,         uint256 lastUpdatedGasPrice,         uint256 liquidationGasCost,         uint256 price,         uint256 minimumLeftoverGasCostMultiplier     )   //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L27 uint256 public override minimumLeftoverGasCostMultiplier = 10;  ## Tools Used  ## Recommended Mitigation Steps Update the comment   
# Handle  gpersoon   # Vulnerability details  ## Impact In function calculateSlippage of LibLiquidation.sol, the value of amountToReturn is calculated by subtracting to numbers. Later on it is check if this value is negative. However amountToReturn is an unsigned integer so it can never be negative. If a negative number would be attempted to be assigned, the code will revert, because solidity 0.8 checks for this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L106 function calculateSlippage( ...             uint256 amountToReturn = 0;             uint256 percentSlippage = 0;             if (avgPrice < receipt.price && receipt.liquidationSide == Perpetuals.Side.Long) {                 amountToReturn = amountExpectedFor - amountSoldFor;             } else if (avgPrice > receipt.price && receipt.liquidationSide == Perpetuals.Side.Short) {                 amountToReturn = amountSoldFor - amountExpectedFor;             }             if (amountToReturn <= 0) {    // can never be smaller than 0, because amountToReturn is uint256                 return 0;             }  ## Tools Used  ## Recommended Mitigation Steps Double check if amountToReturn could be negative. If this is the case change the type of amountToReturn to int256 and add the appropriate type casts   
# Handle  gpersoon   # Vulnerability details  ## Impact The comment for the formula in calcEscrowLiquidationAmount is:  currentMargin - (minMargin - currentMargin) * portion  however it is coded as:  {currentMargin - (minMargin - currentMargin)} * portion  According to Ray/Lions mane the comment is wrong  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L32 //       Calculated as currentMargin - (minMargin - currentMargin) * portion of whole position being liquidated function calcEscrowLiquidationAmount( ..         int256 amountToEscrow = currentMargin - (minMargin.toInt256() - currentMargin);         int256 amountToEscrowProportional = PRBMathSD59x18.mul(amountToEscrow, PRBMathSD59x18.div(amount, totalBase));   ## Tools Used  ## Recommended Mitigation Steps Fix the comment  
# Handle  gpersoon   # Vulnerability details  ## Impact Solidity allows some tricks to make the code easier to read:     LibMath.sol:     uint256 public constant POSITIVE_INT256_MAX = 2**255 - 1;     uint256 public constant POSITIVE_INT256_MAX = uint(type(int256).max);   // alternative coding  Insurance.sol:     uint256 public multiplyFactor = 36523 * (10**11);     uint256 public multiplyFactor = 0.0036523e18;   // alternative coding   ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps Use the most readable coding   
# Handle  gpersoon   # Vulnerability details  ## Impact At several places constants are hardcoded as numbers. It's more readable and more maintainable to turn them into explicit constants. That also lowers to risk to change it on one place and forget is on another place. See examples in proof of concept  ## Proof of Concept .\Insurance.sol:            if (publicCollateralAmount > 10**18) { .\Insurance.sol:                amount = poolHoldings - 10**18; .\Insurance.sol:                publicCollateralAmount = 10**18; .\Insurance.sol:            if (publicCollateralAmount < 10**18) { .\Insurance.sol:            } else if (poolHoldings - amount < 10**18) { .\Insurance.sol:                amount = poolHoldings - 10**18; .\Insurance.sol:                publicCollateralAmount = 10**18; .\Insurance.sol:            uint256 multiplyFactor = 36523 * (10**11); .\Insurance.sol:        return tracer.leveragedNotionalValue() / 100; .\oracle\GasOracle.sol:    uint8 public override decimals = 18; .\lib\libprices.sol:       for (uint256 i = 0; i < 8; i++) { .\lib\libprices.sol:           uint256 currTimeWeight = 8 - i; .\lib\LibPrices.sol:        return (averageTracerPrice.toInt256() - averageOraclePrice.toInt256()) / 90; .\lib\LibBalances.sol:        uint256 adjustedLiquidationGasCost = liquidationGasCost * 6; .\lib\LibPerpetuals.sol:        percentFull = percentFull * 100; // To bring it up to the same percentage units as everything else .\Liquidation.sol:    uint256 public override minimumLeftoverGasCostMultiplier = 10;  ## Tools Used  ## Recommended Mitigation Steps Replace numeric values with constants   
# Handle  gpersoon   # Vulnerability details  ## Impact There are several todos left in the code.  ## Proof of Concept .\Pricing.sol:                     // todo by using public variables lots of these can be removed .\Trader.sol:                      // todo this could be succeptible to re-entrancy as .\lib\LibLiquidation.sol:    // todo with the below * -1, note ints can overflow as 2^-127 is valid but 2^127 is not. .\lib\LibPrices.sol:             // todo double check safety of this.  ## Tools Used  ## Recommended Mitigation Steps Check, fix and remove the todos before it is deployed in production    
# Handle  gpersoon   # Vulnerability details  ## Impact The library prb-math documents that it is not audited by a security researcher.  This means its more risky to rely on this library.  ## Proof of Concept // https://github.com/hifi-finance/prb-math#security The contracts have not been audited by a security researcher.      ## Tools Used  ## Recommended Mitigation Steps Consider (crowdsourcing) an audit for prb-math   
# Handle  gpersoon   # Vulnerability details  ## Impact The constructor of Insurance.so does an emit. However the constructors of the other contracts (InsurancePoolToken.sol, Liquidation.sol, Pricing.sol, TracerPerpetualSwaps.sol, TracerPerpetualsFactory.sol, Trader.sol) don't do an emit in the constructor.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L31 constructor(address _tracer) {      ...         emit InsurancePoolDeployed(_tracer, tracer.tracerQuoteToken());     }  ## Tools Used  ## Recommended Mitigation Steps Perhaps it's useful for other constructor to also include an emit   
# Handle  gpersoon   # Vulnerability details  ## Impact The function matchOrders of TracerPerpetualSwaps.sol doesn't check that the contract itself is indeed equal to order1.market and order2.market. The function executeTrade Trader.sol, which calls the matchOrders, can deal with multiple markets. Suppose there would be a mistake in executeTrade,  or in a future version, the matchOrders would be done in the wrong market.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L216 function matchOrders( Perpetuals.Order memory order1, Perpetuals.Order memory order2, uint256 fillAmount )   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67  function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external  override { ...  (bool success, ) = makeOrder.market.call(                 abi.encodePacked(                     ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,                     abi.encode(makeOrder, takeOrder, fillAmount)                 )             );   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibPerpetuals.sol#L128 function canMatch( Order memory a, uint256 aFilled,Order memory b, uint256 bFilled ) internal view returns (bool) {     ...         bool marketsMatch = a.market == b.market;  ## Tools Used  ## Recommended Mitigation Steps Add something like: require ( order1.market == address(this), "Wrong market");  Note: canMatch already verifies that  order1.market== order2.market   
# Handle  gpersoon   # Vulnerability details  ## Impact A liquidator can always claim the liquidation escrow in the following way: - create a second account - setup a complimentary trade in that second account, which will result in a large slippage when executed - call executeTrade (which everyone can call), to execute a trade between his own two accounts with a large slippage - the slippage doesn't hurt because the liquidator owns both accounts - call claimReceipt with the receiptId of the executed order, within the required period (e.g. 15 minutes)  ## Proof of Concept   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67 function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external override {  https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L394  function claimReceipt( uint256 receiptId, Perpetuals.Order[] memory orders, address traderContract) external override {  ## Tools Used  ## Recommended Mitigation Steps perhaps limit who can call executeTrade   
# Handle  shw   # Vulnerability details  ## Impact  The `recordTrade` function in `Pricing` updates the `currentHour` variable by 1 every hour. However, if there is no trade (i.e., the `recordTrade` is not called) during this hour, the `currentHour` is out of sync with the actual hour. As a result, the `averagePriceForPeriod` function uses the prices before 24 hours and causes errors on the average price.  ## Proof of Concept  Referenced code: [Pricing.sol#L90-L94](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L90-L94)  ## Recommended Mitigation Steps  Calculate how much time passed (e.g., `(block.timestamp - startLastHour) / 3600`) to update the `currentHour` variable correctly.  
# Handle  shw   # Vulnerability details  ## Impact  The `averagePriceForPeriod` function of `LibPrices` does not handle the case where `j` equals 0 (i.e., no trades happened in the last 24 hours). The transaction reverts due to dividing by 0 without a proper error message returned.  ## Proof of Concept  Referenced code: [LibPrices.sol#L73](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibPrices.sol#L73)  ## Recommended Mitigation Steps  Add `require(j > 0, "...")` before line 73 to handle this special case.  
# Handle  shw   # Vulnerability details  ## Impact  The `getHourlyAvgTracerPrice` and `getHourlyAvgOraclePrice` functions in `Pricing` return 0 if there is no trade during the given `hour` because of the design of `averagePrice`, which could mislead users that the hourly average price is 0. The same problem happens when emitting the old hourly average in the `recordTrade` function.  ## Proof of Concept  Referenced code: [Pricing.sol#L254-L256](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L254-L256) [Pricing.sol#L262-L264](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L262-L264) [Pricing.sol#L74](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L74)  ## Recommended Mitigation Steps  Return a special value (e.g., `type(uint256).max`) from `averagePrice` if there is no trade during the specified hour to distinguish from an actual zero price. Handle this particular value whenever the `averagePrice` function is called by others.  
# Handle  shw   # Vulnerability details  ## Impact  Most of the contracts use an unlocked pragma (e.g., `pragma solidity ^0.8.0`) which is not fixed to a specific Solidity version. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler version with which they have been tested the most.  ## Proof of Concept  Referenced code: Please use `grep -R pragma .` to find the unlocked pragma statements.  ## Recommended Mitigation Steps  Lock pragmas to a specific Solidity version. Consider the compiler bugs in the following lists and ensure the contracts are not affected by them. It is also recommended to use the latest version of Solidity when deploying contracts (see [Solidity docs](https://docs.soliditylang.org/en/v0.8.6/)).  Solidity compiler bugs: [Solidity repo - known bugs](https://github.com/ethereum/solidity/blob/develop/docs/bugs.json) [Solidity repo - bugs by version](https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json)  
# Handle  0xsanson   # Vulnerability details  ## Impact In Liquidation.verifyAndSubmitLiquidation(...) we can save the minimumMargin to memory since it's called two times.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L171  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Save the result of Balances.minimumMargin(...) to memory.  
# Handle  0xsanson   # Vulnerability details  ## Impact The claimEscrow(...) function in Liquidation.sol can be set external instead of public since it's not used in the contract. (code clarity and gas savings)  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L109  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change public to external.  
# Handle  0xsanson   # Vulnerability details  ## Impact In LibBalances.applyTrade() we need to collect a fee from the trade. The current code however subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (see TracerPerpetualSwaps.sol#L272). This issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L187  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change +fee to -fee in the highlighted line.  
# Handle  0xsanson   # Vulnerability details  ## Impact We can save gas by substituting getPoolTarget() with levNotionalValue/100, since tracer.leveragedNotionalValue() is already saved in memory.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L216  ## Tools Used Manual analysis.  ## Recommended Mitigation Steps Substitute getPoolTarget() with levNotionalValue/100.  
# Handle  0xsanson   # Vulnerability details  ## Impact State variable perpsFactory is not used in the Insurance contract.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L18  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Just delete it.  
# Handle  0xsanson   # Vulnerability details  ## Impact In the trader contract isValidSignature(...) and verifySignature(...) serve the same purpose. Suggested keep only one for code clarity.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L206 https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L231  ## Tools Used Manual analysys  ## Recommended Mitigation Steps Suggested keep only one function for code clarity.  
# Handle  a_delamo   # Vulnerability details  ## Impact  For every new TracerPerpetualSwaps contract, we need to deploy a new Liquidation, Insurance, and Pricing contract.  All these deployments are really gas-intensive, so it would be recommended to use EIP-1167: Minimal Proxy Contract to reduce the gas cost of the deployments.  ```solidity function _deployTracer(         bytes calldata _data,         address tracerOwner,         address oracle,         address fastGasOracle,         uint256 maxLiquidationSlippage     ) internal returns (address) {         // Create and link tracer to factory         address market = IPerpsDeployer(perpsDeployer).deploy(_data);         ITracerPerpetualSwaps tracer = ITracerPerpetualSwaps(market);          validTracers[market] = true;         tracersByIndex[tracerCounter] = market;         tracerCounter++;          // Instantiate Insurance contract for tracer         address insurance = IInsuranceDeployer(insuranceDeployer).deploy(market);         address pricing = IPricingDeployer(pricingDeployer).deploy(market, insurance, oracle);         address liquidation = ILiquidationDeployer(liquidationDeployer).deploy(             pricing,             market,             insurance,             fastGasOracle,             maxLiquidationSlippage         );          // Perform admin operations on the tracer to finalise linking         tracer.setInsuranceContract(insurance);         tracer.setPricingContract(pricing);         tracer.setLiquidationContract(liquidation);          // Ownership either to the deployer or the DAO         tracer.transferOwnership(tracerOwner);         ILiquidation(liquidation).transferOwnership(tracerOwner);         emit TracerDeployed(tracer.marketId(), address(tracer));         return market;     } ```   More info: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/ https://eips.ethereum.org/EIPS/eip-1167   
# Handle  0xsanson   # Vulnerability details  ## Impact In the Pricing contract, an agent can manipulate the trading prices by spamming an high amount of trades.  Indeed an agent can create an high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn't even need large funds); next he/she pairs the orders with another account and calls Trader.executeTrade; now every order calls a Pricing.recordTrade using the arbitrary price set by the agent.  Since the trades are all made in the same hour, by the way hourlyTracerPrices[currentHour] is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate the fundingRates and the fairPrice, letting a malicious agent get the ability to manipulate the market.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L129  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Pass the fillAmount parameter to recordTrade(...), and calculate hourlyTracerPrices[currentHour].trades summing fillAmount instead of 1 every trade.  
# Handle  tensors   # Vulnerability details  ## Impact Superfluous type conversions.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L229-L230 The type conversion here is not necessary.  ## Recommended Mitigation Steps Remove the type conversion.  
# Handle  0xsanson   # Vulnerability details  ## Impact The contract TracerPerpetualSwaps introduces these four state variables (lowestMaxLeverage,  maxLeverage, insurancePoolSwitchStage and deleveragingCliff) and four respective set functions. Logically the following relations are needed: lowestMaxLeverage < maxLeverage and insurancePoolSwitchStage < deleveragingCliff, but the code doesn't check for them.  Non-critical because needs an error by the owner.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L552 Also lines L560, L564, L568  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add appropriate requires to the set functions and the constructor.  
# Handle  tensors   # Vulnerability details  ## Impact The contracts assume that all tokens will have <=18 decimals. If the Tracer team are the only people deploying the contracts, and they keep this in mind, this isn't a problem. If the contracts are to be deployed by other people, this assumption should be made explicit and hard-coded.   ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L220-L232 We can see that the scaler computations will underflow and be defined when it should not be.  ## Recommended Mitigation Steps Write a require check that ensures tokenDecimals <= 18 before running the above functions.  
# Handle  s1m0   # Vulnerability details  ## Impact The smart contract doesn't check the return value of token.transfer() and token.transferFrom(), some erc20 token might not revert in case of error but return false. In the [TracerPerpetualSwaps:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L151) and [Insurance:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L51) this would allow a user to deposit for free. Other places: [TracerPerpetualSwaps: withdraw](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L203) [TracerPerpetualSwaps:withdrawFees](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L514) [SafetyWithdraw:withdrawERC20Token](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/SafetyWithdraw.sol#L13) [Insurance:withdraw](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L97)  ## Recommended Mitigation Steps Wrap the call into a require() or use openzeppelin's [SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) library.  
# Handle  pauliax   # Vulnerability details  ## Impact Here the check currentMargin < Balances.minimumMargin should be inclusive <= to indicate the account is not above minimum margin:     require(         currentMargin <= 0 ||             uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),         "LIQ: Account above margin"     );  ## Recommended Mitigation Steps uint256(currentMargin) <= Balances.minimumMargin ...  
# Handle  pauliax   # Vulnerability details  ## Impact Could save some gas here when amountToReturn = receipt.escrowedAmount:     if (amountToReturn > receipt.escrowedAmount) {        liquidationReceipts[receiptId].escrowedAmount = 0;     } else {        liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;     }  ## Recommended Mitigation Steps  if (amountToReturn >= receipt.escrowedAmount) { ...  
# Handle  cmichel   # Vulnerability details  The `TracerPerpetualSwaps.settle` function updates the user's last index to `currentGlobalFundingIndex`, however a comment states:  > "// Note: global rates reference the last fully established rate (hence the -1), and not the current global rate. User rates reference the last saved user rate"  The code for the `else` branch also updates the last index to `currentGlobalFundingIndex - 1` instead of `currentGlobalFundingIndex`.  ```solidity if (accountBalance.position.base == 0) {     // set to the last fully established index     // @audit shouldn't this be global - 1 like below?     accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;     accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer(); } ```   ## Impact It might be possible that first-time depositors skip having to pay the first funding rate period as the `accountLastUpdatedIndex + 1 < currentGlobalFundingIndex` check will still return `false` when the funding rates are updated the next time.  ## Recommended Mitigation Steps Check if setting it to `currentGlobalFundingIndex` or to `currentGlobalFundingIndex - 1` is correct.  
# Handle  cmichel   # Vulnerability details  The `Liquidation` contract allows the liquidator to submit "bad" trade orders and the insurance reimburses them from the insurance fund, see `Liquidation.claimReceipt`. The function can be called with an `orders` array which does not check for duplicate orders. An attacker can abuse this to make a profit by liquidating themselves, making a small bad trade and repeatedly submitting this bad trade for slippage reimbursement.  Example: - Attacker uses two accounts, one as the liquidator and one as the liquidatee. - They run some high-leverage trades such that the liquidatee gets liquidated with the next price update. (If not cash out and make a profit this way through trading, and try again.) - Liquidator liquidates liquidatee - They now do two trades:   - One "good" trade at the market price that fills 99% of the liquidation amount. The slippage protection should not kick in for this trade   - One "bad" trade at a horrible market price that fills only 1% of the liquidation amount. This way the slippage protection kicks in for this trade - The liquidator now calls `claimReceipt(orders)` where `orders` is an array that contains many duplicates of the "bad" trade, for example 100 times. The `calcUnitsSold` function will return `unitsSold = receipt.amountLiquidated` and a bad `avgPrice`. They are now reimbursed the price difference on the full liquidation amount (instead of only on 1% of it) making an overall profit  This can be repeated until the insurance fund is drained.  ## Impact  The attacker has an incentive to do this attack as it's profitable and the insurance fund will be completely drained.  ## Recommended Mitigation Steps Disallow duplicate orders in the `orders` argument of `claimReceipt`. This should make the attack at least unprofitable, but it could still be a griefing attack. A quick way to ensure that `orders` does not contain duplicates is by having liquidators submit the orders in a sorted way (by order ID) and then checking in the `calcUnitsSold` `for` loop that the current order ID is strictly greater than the previous one.  
# Handle  cmichel   # Vulnerability details  There are several setter functions that do not check if the amount is less than 100%.  - `TracerPerpetualSwaps`: `setFeeRate`, `setDeleveragingCliff`, `setInsurancePoolSwitchStage` - `Insurance`: `setFeeRate`, `setDeleveragingCliff`, `setInsurancePoolSwitchStage`  ## Impact Setting values to more than 100% might lead to unintended functionality.  ## Recommended Mitigation Steps Ensure that the parameters are less than 100%.  
# Handle  cmichel   # Vulnerability details  The pool holdings of `Insurance` (`publicCollateralAmount` and `bufferCollateralAmount`) is in WAD (18 decimals) but it's used as a raw token value in `drainPool`  ```solidity // amount is a mix of pool holdings, i.e., 18 decimals // this requires amount to be in RAW! if tracerMarginToken has > 18 decimals, it'll break, < 18 decimals will approve too much tracerMarginToken.approve(address(tracer), amount); // this requires amount to be in WAD which is correct tracer.deposit(amount); ```  ## Impact  If `tracerMarginToken` has less than 18 decimals, the approval approves orders of magnitude more tokens than required for the `deposit` call that follows. If `tracerMarginToken` has more than 18 decimals, the `deposit` that follows would fail as fewer tokens were approved, but the protocol seems to disallow tokens in general with more than 18 decimals.  ## Recommended Mitigation Steps Convert the `amount` to a "raw token value" and approve this one instead.   
# Handle  cmichel   # Vulnerability details  The `GasOracle` uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD.  However, the scaling depends on the underlying decimals of the two oracles and could be anything. But the code assumes it's in 18 decimals.  > "Returned value is USD/Gas * 10^18 for compatibility with rest of calculations"  There is a `toWad` function that seems to involve scaling but it is never used.  ## Impact** If the scale is wrong, the gas price can be heavily inflated or under-reported.   ## Recommended Mitigation Steps Check `chainlink.decimals()` to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the `latestAnswer` function always returns the answer in 18 decimals.  
# Handle  cmichel   # Vulnerability details  When `LibMath.sumN` function does not check if `n <= arr.length` and can therefore fail if called with `n > arr.length`.  ## Impact The caller must always check that it's called with an argument that is less than `n` which is inconvenient.  ## Recommendation Change the condition to iterate up to `min(n, arr.length)`.   
# Handle  cmichel   # Vulnerability details   When `LibMath.abs` is called with -2^255 (`type(int256).min`), it tries to multiply it by `-1` but it'll fail as it exceeds the max signed 256-bit integers.  ## Impact The function will fail with an implicit error that might be hard to locate.  ## Recommendation Throw an error similar to `toInt256` like `int256 overflow`.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  In function minimumMargin(), maximumLeverage being zero is not handled because it will result in div by zero as PRBMathUD60x18.div expects non-zero divisor.   Impact: Various critical market functions will revert if maximumLeverage is zero.  ## Proof of Concept  https://github.com/hifi-finance/prb-math/blob/c4dea7d0e6ae246fbb631f7fb4be4072d1da9a07/contracts/PRBMathUD60x18.sol#L71-L77   https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L118  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L135  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L186  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L242  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L248  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add checks to make sure maximumLeverage is never zero or handle appropriately.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The withdrawERC20Token() in SafetyWithdraw inherited in TracerPerpetualSwaps is presumably a guarded launch emergency withdrawal mechanism. However, given the trust model where the market creator/owner is potentially untrusted/malicious, this is a dangerous approach to emergency withdrawal in the context of guarded launch.   Alternatively, if this is meant for the owner to withdraw “external” ERC20 tokens mistakenly deposited to the Tracer market then the function should exclude tracerQuoteToken from being the tokenAddress that can be used as a parameter to withdrawERC20Token().  Impact: Malicious owner of a market withdraws/rugs all tracerQuoteTokens deposited at any time after market launch. All users lose deposits. Protocol takes a reputational hit and has to refund the users from treasury.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/SafetyWithdraw.sol#L8-L14  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L20   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  For a guarded launch circuit breaker, design a pause/unpause feature where deposits are paused  (in emergency situations) but withdrawals are allowed by the depositors themselves instead of the owner. Alternatively, if this is meant to be for removing external ERC20 tokens accidentally deposited to market, exclude the tracerQuoteToken from being given as the tokenAddress.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The sumN() library function expects to calculate the sum of n elements of the supplied array but there is no check to see if the array indeed has n elements. A smaller array could lead to reading out of bounds memory resulting in undefined values.  Impact: The current usage of the library does not indicate an out of bounds access but any new code using this library could be impacted.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibMath.sol#L38-L46  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibMath.sol#L68  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibPrices.sol#L73   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add require(n <= arr.length) at the beginning of sumN() to be safe.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The setDecimals() in the sample Gas Price Oracle implementation allows anyone to set the decimals value used by the contract but is not used anywhere.  Impact: It is unclear if this should be set by anyone and if that value should be used in determining the precision of the values returned.  ## Proof of Concept   https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/oracle/GasOracle.sol#L64-L66   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate if this access and missing logic is correct.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Time ranges are typically open-ended which includes the start & end times, and not close-ended. So the releaseTime would be interpreted as the time it would be released i.e. block.timestamp >= releaseTime would be the expected check here instead of ‘>’. Similarly, on L406, it should be ‘<=‘ instead of ‘<‘.  Impact: Claims of escrow and receipts are expected to succeed in a particular block but they revert and have to wait until the next block.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L112  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L406  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Unless justified, change the strict inequality and make it ‘>=‘ and ‘<=‘ to convert open ranges to closed ranges for block.timestamp comparisons.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The updateFundingRate() function updates the funding rate and insurance funding rate. While the instant/new funding rates are calculated correctly, the cumulative funding rate calculation is incorrect because it is always adding the instant to 0, not the previous value. This is due to the use of [currentFundingIndex] which has been updated since the previous call to this function while it should really be using [currentFundingIndex-1] to reference the previous funding rate.  Impact: The cumulative funding rate and insurance funding rates are calculated incorrectly without considering the correct previous values. This affects the settling of accounts across the entire protocol. The protocol logic is significantly impacted, accounts will not be settled as expected, protocol shutdown and contracts will need to be redeployed. Users may lose funds and protocol takes a reputation hit.   ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L155-L160  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L168  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L77  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L196-L215  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L221-L230  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L445-L446  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use [currentFundingIndex-1] for non-zero values of currentFundingIndex to get the value updated in the previous call on lines L155 and L159 of Pricing.sol.  
# Handle  0xRajeev   # Vulnerability details  ## Impact Trading function executeTrade() batch executes maker/taker orders against a market. The trader/interface provides arrays of makers/takers which is unbounded. As a result, if the number of orders is too many, there is a risk of this transaction exceeding the block gas limit (which is 15 million currently).  Impact: executeTrade() is called with too many orders in the batch. Tx exceeds block gas limit and reverts. None of the orders are executed.  ## Proof of Concept  See similar Medium-severity finding from ConsenSys's Audit of Growth DeFi: https://consensys.net/diligence/audits/2020/12/growth-defi-v1/#potential-resource-exhaustion-by-external-calls-performed-within-an-unbounded-loop  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Trader.sol#L67  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Trader.sol#L78  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Limit the number or orders executed based on gasleft() after every iteration or estimate the gas cost and enforce an upper bound on the number of orders allowed in maker/taker arrays.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Tracer protocol like any other allows market creators to charge fees for trades. However, a malicious/greedy owner can arbitrarily change fee to any % value and without an event to observe this change or a timelock to react, there is no easy way for users to monitor this via front-end or off-chain monitoring tools.  Impact: Users trade on a market with 0.1% fees. The owner suddenly changes this to 100%. Users realise this only after their trades are executed. Market loses confidence. Protocol takes a reputational hit.  ## Proof of Concept  See similar Medium-severity finding in ConsenSys's Audit of 1inch Liquidity Protocol (https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L548-L550  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L198-L214  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit event, provide time lock for users to react and establish an upper threshold for fees that is decided across markets by governance.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  withdrawFees() is an external function which can be called by anyone to transfer the accumulated fees to the feeReceiver account. However, there is no data validation to check if fees are non-zero.  Impact: One can keep calling withdrawFees(), even if the fees is zero, to grief the system with 0 amount transfers and emission of events recording the same. This leads to what is known as event log poisoning where malicious external users spam the Tracer contract to generate arbitrary FeeWithdrawn events.  ## Proof of Concept  See similar Finding from Sigma Prime’s audit of Synthetix Unipool: https://github.com/sigp/public-audits/blob/master/synthetix/unipool/review.pdf  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L508-L516  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider adding a require or if statement preventing the withdrawFees() function from emitting the event when the amount variable is zero, i.e. check if fees != 0 before transfer+emit.  
# Handle  JMukesh   # Vulnerability details  ## Impact public function which are not called within contract should be declared as external to save gas  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L572  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L470  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/InsurancePoolToken.sol#L14  ## Tools Used  manual review  ## Recommended Mitigation Steps  Declare public function as external which are not called in the contract  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Reference type local variables require an explicit data location specified indicating if they need to be in storage or memory. Assigning state variables to storage local variables creates a reference  (instead of a copy) to the state variable and modifications to the local variable will be reflected in the state variable. This is required if the intention is to make updates to state variables. Unnecessarily using storage specifiers may lead to unintentional updates of state variables and has led to vulnerabilities.  In L457 of settle(), a local variable insuranceBalance is created in storage to point to balances[address(insuranceContract)] but is never updated. Instead balances[address(insuranceContract)] itself is updated on L474.  Impact: While there is no immediate impact, any modifications to the code with insuranceBalance will be dangerous because it will update the critical state variable balances[address(insuranceContract)]. It is safer to use a memory specifier for insuranceBalance.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L456-L457  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L467  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L474  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace the use of storage specifier on L457 with memory.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The tvl calculation in deposit() uses convertedWadAmount but the one in withdraw() uses the parameter amount. While amount is still in WAD format, it may contain dust which is what the conversion to rawTokenAmount and then back to convertedWadAmount removes.  Impact: Use of amount in tvl during withdraw() will consider dust while the one in deposit() will not, which is inconsistent.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L200  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L176-L177  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L162  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L153-L155  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use convertedWadAmount instead of amount to be consistent with the increment during withdraw() tvl calculation.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The Deposit event uses the function parameter amount instead of the convertedWadAmount which is what is used to update the user’s position and tvl because it prevents any dust deposited in amount. This will also make it consistent with the emit event in withdraw function.  Impact: Deposit event amount reflects the value with dust while the user position does not. This may lead to confusion.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L163  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L153-L162  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L204  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use uint256(convertedWadAmount) instead of amount in Deposit event.  
# Handle  pauliax   # Vulnerability details  ## Impact Trader function executeTrade calculates executionPrice, newMakeAverage, newTakeAverage, then calls the market, and only if it succeeds it uses these variables.  ## Recommended Mitigation Steps Better first call the market and only then calculate and use these variables to avoid useless calculations and gas costs.  
# Handle  pauliax   # Vulnerability details  ## Impact Insurance function drainPool calculates 10**18 many times. To reduce the number of calculations and save gas, this number can be extracted as a constant variable and used everywhere where necessary.  ## Recommended Mitigation Steps Extract 10**18 as a constant.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The gas cost for liquidation may change if code is updated/optimized, compiler changed or profiling improved. The developers may forget to update this constant in code.  Impact: The margin validity calculation which uses this value may be affected if this changes and hence is not as declared in the constant. This may adversely impact validation.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L26  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L244  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L250  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L494  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L159  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L193  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  It is safer to make this a constructor-set immutable value that will force usage of an updated accurate value at deployment time. Evaluate if the sensitivity to this value is great enough to justify a setter to change it if incorrectly initialized at deployment.  
# Handle  pauliax   # Vulnerability details  ## Impact Contract Trader has 2 mappings: orders and orderToSig. I see that orderToSig also stores Perpetuals.Order inside it, so I wonder if it really was necessary to separate these mappings as some state (order) is duplicated among them. It may be a bit more efficient to access orders without signatures but it also makes it more error-prone as you need to keep the invariant that orders match in these mappings. Currently I don't see an exact problem as orderToSig are only set in function grabOrder and never used in code anywhere but I am not sure if it is really necessary.   Tracer representetive's answer on Discord: 'Yeah thats a good point on the Trader mapping, one does look redundant now as they both store the order itself. I think originally one was mutated and one wasn't, but then that functionality got moved into the filled mapping anyway. Seems safe to remove orders and simply reference the orderToSig mapping'.  ## Recommended Mitigation Steps Remove orders and simply reference the orderToSig mapping.  
# Handle  JMukesh   # Vulnerability details  ## Impact state variable which have to initialise in constructor can be declared as immutable to save gas  ## Proof of Concept  https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Insurance.sol#L23  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Insurance.sol#L20  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L30  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L31  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L17  ## Tools Used  manual review  
# Handle  JMukesh   # Vulnerability details  ## Impact Unused state variable will increase unnecessarily code size and use the memory  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/oracle/GasOracle.sol#L19  ## Tools Used  manual review  ## Recommended Mitigation Steps  remove the variable which are unused  
# Handle  hrkrshnn   # Vulnerability details  ## Impact  Gas optimization.  ## Use at least 0.8.4 instead of 0.8.0  It has an important optimization improvement: a low level inliner. Especially since you have several small functions.  The current hardhat config indicates that version `0.8.0` is being used.    
# Handle  hrkrshnn   # Vulnerability details  ## Impact  Gas optimization.  ## For function arguments, change `memory` to `calldata`  There are several places where this is applicable, however, will point out one such occasion:  ``` diff modified   src/contracts/Trader.sol @@ -64,7 +64,7 @@ contract Trader is ITrader {       * @param makers An array of signed make orders       * @param takers An array of signed take orders       */ -    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) +    function executeTrade(Types.SignedLimitOrder[] calldata makers, Types.SignedLimitOrder[] calldata takers)          external          override      { @@ -144,7 +144,7 @@ contract Trader is ITrader {       * @dev Should only be called with a verified signedOrder and with index       *      < signedOrders.length       */ -    function grabOrder(Types.SignedLimitOrder[] memory signedOrders, uint256 index) +    function grabOrder(Types.SignedLimitOrder[] calldata signedOrders, uint256 index)          internal          returns (Perpetuals.Order memory)      { ```  Reason: when you specify `memory` for a (non value type) function-parameter for an external function, the following happens: the compiler would copy elements from `calldata` to `memory` (using the opcode `calldatacopy`.) Then later on, the internal call (here `grabOrder`) would pass a memory reference. However, this is a great example of where copying to memory is unnecessary. Note that there is also the opcode `calldataload` to read an offset from `calldata`. By changing the location from `memory` to `calldata`, you avoid this expensive copy from `calldata` to `memory`, while managing to do exactly what's needed.  You would only have to use `memory` if the function has to modify the parameter, in which case a copy is really needed as `calldata` cannot be modified.    
# Handle  JMukesh   # Vulnerability details  ## Impact These array memory parameter can be  problematic if not used properly , if the array is very large it may overlap over other part of memory.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L274  This an example to show the exploit: // based on https://github.com/paradigm-operations/paradigm-ctf-2021/blob/master/swap/private/Exploit.sol pragma solidity ^0.4.24; // only works with low solidity version  contract test{ struct Overlap { uint field0; } event log(uint);  function mint(uint[] memory amounts) public returns (uint) {  // this can be in any solidity version Overlap memory v; v.field0 = 1234; emit log(amounts[0]); // would expect to be 0 however is 1234 return 1; }  function go() public { // this part requires the low solidity version uint x=0x800000000000000000000000000000000000000000000000000000000000000; // 2^251 bytes memory payload = abi.encodeWithSelector(this.mint.selector, 0x20, x); bool success=address(this).call(payload); } } ## Tools Used  manual review  ## Recommended Mitigation Steps  check array length before using it  
# Handle  gpersoon   # Vulnerability details  ## Impact It's possible to avoid paying insurance in the following way: - once per hour (at the right moment), do the following: ----using a flash loan, or with a large amount of tokens, call deposit of Insurance.sol to make sure that the pool is sufficiently filled (poolHoldings > poolTarget) ----call the function executeTrade of Trader.sol with a minimal trade (possibly of value 0, see finding "executeTrade with same trades") ----executeTrade calls matchOrders, which calls recordTrade ----recordTrade calls updateFundingRate();   (once per hour, so you have to be sure you do it in time before other trades trigger this) ----updateFundingRate calls getPoolFundingRate ----getPoolFundingRate determines the insurance rate, but because the insurance pool is sufficiently full (due to the flash loan), the rate is 0 ----updateFundingRate stores the 0 rate via setInsuranceFundingRate  (which is used later on to calculate the amounts for the insurances) ----withdraw from the Insurance and pay back the flash loan  The insurance rates are 0 now and no-one pays insurance. The gas costs relative to the insurance costs + the flash loan fees determine if this is an economically viable attack. Otherwise it is still a grief attack This will probably be detected pretty soon because the insurance pool will stay empty. However its difficult to prevent.  ## Proof of Concept  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L45 function deposit(uint256 amount) external override {  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L74 function withdraw(uint256 amount) external override {  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L69      function recordTrade(uint256 tradePrice) external override onlyTracer {       ..         if (startLastHour <= block.timestamp - 1 hours) {            ..             updateFundingRate();  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L141 function updateFundingRate() internal {       ..         int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();       ..         int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;      ..         setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L204 function getPoolFundingRate() external view override returns (uint256) {      ..         // If the pool is above the target, we don't pay the insurance funding rate         if (poolTarget <= poolHoldings) {             return 0;         }  ## Tools Used  ## Recommended Mitigation Steps Set a timelock on withdrawing insurance   
# Handle  gpersoon   # Vulnerability details  ## Impact Some of the contracts set variables in the initialize function that are never changed. See for examples in the "proof of concept" section. Here the solidity keyword "immutable" could be added to the variables as an extra security measure.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L17     address public tracer;     IInsurance public insurance;     IOracle public oracle;          https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L24     uint256 public override maxSlippage;     IPricing public pricing;     ITracerPerpetualSwaps public tracer;     address public insuranceContract;     address public fastGasOracle;          //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L20       address public collateralAsset; // Address of collateral asset      address public token; // token representation of a users holding in the pool      ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool   ## Tools Used  ## Recommended Mitigation Steps Add immutable where possible  
# Handle  gpersoon   # Vulnerability details  ## Impact The function claimEscrow of Liquidation.sol can be called by everyone. The claimed funds go to the trader so there are no funds at risk. However the comment says the traders is doing this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L106 /**      * @notice Allows a trader to claim escrowed funds after the escrow period has expired      * @param receiptId The ID number of the insurance receipt from which funds are being claimed from      */     function claimEscrow(uint256 receiptId) public override {   ## Tools Used  ## Recommended Mitigation Steps Double check and it the code works as intended adapt the comment. Otherwise add check that only the trader can call the function.  
# Handle  hrkrshnn   # Vulnerability details  ## Impact  Several variables can be converted into immutables. Doing so can save 2100 gas for storage reads when the slot is warm and 100 otherwise.  ``` Notice: Variable declaration can be converted into an immutable.   --> @openzeppelin/contracts/token/ERC20/ERC20.sol:38:5:    | 38 |     uint256 private _totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:18:5:    | 18 |     ITracerPerpetualsFactory public perpsFactory;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:20:5:    | 20 |     address public collateralAsset; // Address of collateral asset    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:23:5:    | 23 |     address public token; // token representation of a users holding in the pool    |     ^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Insurance.sol:25:5:    | 25 |     ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:28:5:    | 28 |     IPricing public pricing;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:29:5:    | 29 |     ITracerPerpetualSwaps public tracer;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:30:5:    | 30 |     address public insuranceContract;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Liquidation.sol:31:5:    | 31 |     address public fastGasOracle;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Pricing.sol:17:5:    | 17 |     address public tracer;    |     ^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Pricing.sol:18:5:    | 18 |     IInsurance public insurance;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Notice: Variable declaration can be converted into an immutable.   --> contracts/Pricing.sol:19:5:    | 19 |     IOracle public oracle;    |     ^^^^^^^^^^^^^^^^^^^^^ ```  ## Proof of Concept  References to source file and line numbers can be seen above.  ## Tools Used  A custom solidity compiler.  ## Recommended Mitigation Steps  As explained above, these variables can be converted into immutables.  
# Handle  gpersoon   # Vulnerability details  ## Impact If you call the function withdrawFees and the "tvl" would not be enough for the fee then the code would revert. In this case the fees cannot be withdrawn. Although it is unlikely that the tvl would be wrong it is probably better to be able to withdraw the remaining fees.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L508 function withdrawFees() external override {         uint256 tempFees = fees;         fees = 0;         tvl = tvl - tempFees;          // Withdraw from the account         IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);         emit FeeWithdrawn(feeReceiver, tempFees);     }  ## Tools Used  ## Recommended Mitigation Steps Add something like: tempFees = min (fees, tvl); and change fees=0 to: fees -= tempFees;  
# Handle  gpersoon   # Vulnerability details  ## Impact The comments for partialLiquidationIsValid indicate that the params are in WAD format (except liquidationGasCost) However the parameter minimumLeftoverGasCostMultiplier originates from Liquidation.sol and has the value 10. So it is not in WAD format and the comment is misleading.  ## Proof of Concept //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L149  @dev Assumes params are WAD except liquidationGasCost  function partialLiquidationIsValid(         Balances.Position memory updatedPosition,         uint256 lastUpdatedGasPrice,         uint256 liquidationGasCost,         uint256 price,         uint256 minimumLeftoverGasCostMultiplier     )   //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L27 uint256 public override minimumLeftoverGasCostMultiplier = 10;  ## Tools Used  ## Recommended Mitigation Steps Update the comment   
# Handle  gpersoon   # Vulnerability details  ## Impact In function calculateSlippage of LibLiquidation.sol, the value of amountToReturn is calculated by subtracting to numbers. Later on it is check if this value is negative. However amountToReturn is an unsigned integer so it can never be negative. If a negative number would be attempted to be assigned, the code will revert, because solidity 0.8 checks for this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L106 function calculateSlippage( ...             uint256 amountToReturn = 0;             uint256 percentSlippage = 0;             if (avgPrice < receipt.price && receipt.liquidationSide == Perpetuals.Side.Long) {                 amountToReturn = amountExpectedFor - amountSoldFor;             } else if (avgPrice > receipt.price && receipt.liquidationSide == Perpetuals.Side.Short) {                 amountToReturn = amountSoldFor - amountExpectedFor;             }             if (amountToReturn <= 0) {    // can never be smaller than 0, because amountToReturn is uint256                 return 0;             }  ## Tools Used  ## Recommended Mitigation Steps Double check if amountToReturn could be negative. If this is the case change the type of amountToReturn to int256 and add the appropriate type casts   
# Handle  gpersoon   # Vulnerability details  ## Impact The comment for the formula in calcEscrowLiquidationAmount is:  currentMargin - (minMargin - currentMargin) * portion  however it is coded as:  {currentMargin - (minMargin - currentMargin)} * portion  According to Ray/Lions mane the comment is wrong  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L32 //       Calculated as currentMargin - (minMargin - currentMargin) * portion of whole position being liquidated function calcEscrowLiquidationAmount( ..         int256 amountToEscrow = currentMargin - (minMargin.toInt256() - currentMargin);         int256 amountToEscrowProportional = PRBMathSD59x18.mul(amountToEscrow, PRBMathSD59x18.div(amount, totalBase));   ## Tools Used  ## Recommended Mitigation Steps Fix the comment  
# Handle  gpersoon   # Vulnerability details  ## Impact Solidity allows some tricks to make the code easier to read:     LibMath.sol:     uint256 public constant POSITIVE_INT256_MAX = 2**255 - 1;     uint256 public constant POSITIVE_INT256_MAX = uint(type(int256).max);   // alternative coding  Insurance.sol:     uint256 public multiplyFactor = 36523 * (10**11);     uint256 public multiplyFactor = 0.0036523e18;   // alternative coding   ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps Use the most readable coding   
# Handle  gpersoon   # Vulnerability details  ## Impact At several places constants are hardcoded as numbers. It's more readable and more maintainable to turn them into explicit constants. That also lowers to risk to change it on one place and forget is on another place. See examples in proof of concept  ## Proof of Concept .\Insurance.sol:            if (publicCollateralAmount > 10**18) { .\Insurance.sol:                amount = poolHoldings - 10**18; .\Insurance.sol:                publicCollateralAmount = 10**18; .\Insurance.sol:            if (publicCollateralAmount < 10**18) { .\Insurance.sol:            } else if (poolHoldings - amount < 10**18) { .\Insurance.sol:                amount = poolHoldings - 10**18; .\Insurance.sol:                publicCollateralAmount = 10**18; .\Insurance.sol:            uint256 multiplyFactor = 36523 * (10**11); .\Insurance.sol:        return tracer.leveragedNotionalValue() / 100; .\oracle\GasOracle.sol:    uint8 public override decimals = 18; .\lib\libprices.sol:       for (uint256 i = 0; i < 8; i++) { .\lib\libprices.sol:           uint256 currTimeWeight = 8 - i; .\lib\LibPrices.sol:        return (averageTracerPrice.toInt256() - averageOraclePrice.toInt256()) / 90; .\lib\LibBalances.sol:        uint256 adjustedLiquidationGasCost = liquidationGasCost * 6; .\lib\LibPerpetuals.sol:        percentFull = percentFull * 100; // To bring it up to the same percentage units as everything else .\Liquidation.sol:    uint256 public override minimumLeftoverGasCostMultiplier = 10;  ## Tools Used  ## Recommended Mitigation Steps Replace numeric values with constants   
# Handle  gpersoon   # Vulnerability details  ## Impact There are several todos left in the code.  ## Proof of Concept .\Pricing.sol:                     // todo by using public variables lots of these can be removed .\Trader.sol:                      // todo this could be succeptible to re-entrancy as .\lib\LibLiquidation.sol:    // todo with the below * -1, note ints can overflow as 2^-127 is valid but 2^127 is not. .\lib\LibPrices.sol:             // todo double check safety of this.  ## Tools Used  ## Recommended Mitigation Steps Check, fix and remove the todos before it is deployed in production    
# Handle  gpersoon   # Vulnerability details  ## Impact The library prb-math documents that it is not audited by a security researcher.  This means its more risky to rely on this library.  ## Proof of Concept // https://github.com/hifi-finance/prb-math#security The contracts have not been audited by a security researcher.      ## Tools Used  ## Recommended Mitigation Steps Consider (crowdsourcing) an audit for prb-math   
# Handle  gpersoon   # Vulnerability details  ## Impact The constructor of Insurance.so does an emit. However the constructors of the other contracts (InsurancePoolToken.sol, Liquidation.sol, Pricing.sol, TracerPerpetualSwaps.sol, TracerPerpetualsFactory.sol, Trader.sol) don't do an emit in the constructor.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L31 constructor(address _tracer) {      ...         emit InsurancePoolDeployed(_tracer, tracer.tracerQuoteToken());     }  ## Tools Used  ## Recommended Mitigation Steps Perhaps it's useful for other constructor to also include an emit   
# Handle  gpersoon   # Vulnerability details  ## Impact The function matchOrders of TracerPerpetualSwaps.sol doesn't check that the contract itself is indeed equal to order1.market and order2.market. The function executeTrade Trader.sol, which calls the matchOrders, can deal with multiple markets. Suppose there would be a mistake in executeTrade,  or in a future version, the matchOrders would be done in the wrong market.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L216 function matchOrders( Perpetuals.Order memory order1, Perpetuals.Order memory order2, uint256 fillAmount )   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67  function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external  override { ...  (bool success, ) = makeOrder.market.call(                 abi.encodePacked(                     ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,                     abi.encode(makeOrder, takeOrder, fillAmount)                 )             );   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibPerpetuals.sol#L128 function canMatch( Order memory a, uint256 aFilled,Order memory b, uint256 bFilled ) internal view returns (bool) {     ...         bool marketsMatch = a.market == b.market;  ## Tools Used  ## Recommended Mitigation Steps Add something like: require ( order1.market == address(this), "Wrong market");  Note: canMatch already verifies that  order1.market== order2.market   
# Handle  gpersoon   # Vulnerability details  ## Impact A liquidator can always claim the liquidation escrow in the following way: - create a second account - setup a complimentary trade in that second account, which will result in a large slippage when executed - call executeTrade (which everyone can call), to execute a trade between his own two accounts with a large slippage - the slippage doesn't hurt because the liquidator owns both accounts - call claimReceipt with the receiptId of the executed order, within the required period (e.g. 15 minutes)  ## Proof of Concept   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67 function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external override {  https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L394  function claimReceipt( uint256 receiptId, Perpetuals.Order[] memory orders, address traderContract) external override {  ## Tools Used  ## Recommended Mitigation Steps perhaps limit who can call executeTrade   
