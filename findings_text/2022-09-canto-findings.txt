# Lines of code  https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-core.sol#L260-L269   # Vulnerability details  ## Impact BaseV1-core.sol#L260 `totalSupplyAvg` may not provide the average value when `granularity` is lesser than or greater(too away from median value) than the total number of `_totalSupplyAvg`  ## Proof of Concept https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-core.sol#L260-L269      function totalSupplyAvg(uint granularity) external view returns(uint) {         uint[] memory _totalSupplyAvg = sampleSupply(granularity, 1);         uint totalSupplyCumulativeAvg;           for (uint i = 0; i < _totalSupplyAvg.length; ++i) {             totalSupplyCumulativeAvg += _totalSupplyAvg[i]; //totalSupply denominated in terms of 1e18          }           return (totalSupplyCumulativeAvg / granularity);     }  In above code the average is computed based on `granularity` but thie `granularity` can be a value which is too far away from the median value. say, it could be too away from `_totalSupplyAvg.length`  ## Tools Used VS code and Manual code review  ## Recommended Mitigation Steps It is suggested to calculate the average value based on `_totalSupplyAvg.length` `totalSupplyCumulativeAvg / _totalSupplyAvg.length` 
# Lines of code  https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L487-L522   # Vulnerability details  ## Impact  The `Comptroller` is expecting `oracle.getUnderlyingPrice` to return `0` for errors (Compound style returns, no revert). The current implementation will throw errors, resulting in the consumer of the oracle getting unexpected errors.  ## Proof of Concept  ```solidity function getUnderlyingPrice(CToken ctoken) external override view returns(uint) {          address underlying;         { //manual scope to pop symbol off of stack         string memory symbol = ctoken.symbol();         if (compareStrings(symbol, "cCANTO")) {             underlying = address(wcanto);             return getPriceNote(address(wcanto), false);         } else {             underlying = address(ICErc20(address(ctoken)).underlying()); // We are getting the price for a CErc20 lending market         }         //set price statically to 1 when the Comptroller is retrieving Price         if (compareStrings(symbol, "cNOTE")) { // note in terms of note will always be 1              return 1e18; // Stable coins supported by the lending market are instantiated by governance and their price will always be 1 note         }          else if (compareStrings(symbol, "cUSDT") && (msg.sender == Comptroller )) {             uint decimals = erc20(underlying).decimals();             return 1e18 * 1e18 / (10 ** decimals); //Scale Price as a mantissa to maintain precision in comptroller         }          else if (compareStrings(symbol, "cUSDC") && (msg.sender == Comptroller)) {             uint decimals = erc20(underlying).decimals();             return 1e18 * 1e18 / (10 ** decimals); //Scale Price as a mantissa to maintain precision in comptroller         }         }                  if (isPair(underlying)) { // this is an LP Token             return getPriceLP(IBaseV1Pair(underlying));         }         // this is not an LP Token         else {             if (isStable[underlying]) {                 return getPriceNote(underlying, true); // value has already been scaled             }              return getPriceCanto(underlying) * getPriceNote(address(wcanto), false) / 1e18;         }        } ```   The `Comptroller` is expecting `oracle.getUnderlyingPrice` to return `0` for errors (Compound style returns, no revert).  However, the current implementation will revert when errored:  https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L549-L593  ```solidity function getPriceLP(IBaseV1Pair pair) internal view returns(uint) {         uint[] memory supply = pair.sampleSupply(8, 1);         uint[] memory prices;          uint[] memory unitReserves;          uint[] memory assetReserves;          address token0 = pair.token0();         address token1 = pair.token1();         uint decimals; ```  https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-core.sol#L271-L289  ```solidity function sampleSupply(uint points, uint window) public view returns (uint[] memory) {         uint[] memory _totalSupply = new uint[](points);                  uint lastIndex = observations.length-1;         require(lastIndex >= points * window, "PAIR::NOT READY FOR PRICING");         uint i = lastIndex - (points * window); // point from which to begin the sample         uint nextIndex = 0;         uint index = 0;         uint timeElapsed;          for(; i < lastIndex; i+=window) {             nextIndex = i + window;             timeElapsed = observations[nextIndex].timestamp - observations[i].timestamp;             _totalSupply[index] = (observations[nextIndex].totalSupplyCumulative - observations[i].totalSupplyCumulative) / timeElapsed;             index = index + 1;         }          return _totalSupply;     } ```  ## Recommended Mitigation Steps  Consider using `try catch` and return 0 when errored.
# Lines of code  https://github.com/code-423n4/2022-09-canto/blob/main/src/Swap/BaseV1-core.sol#L598   # Vulnerability details  ## Impact The period size is not update to current while creating a new pair. This means even if period size has been reduced from default value, this new pair will still point to the higher default value  ## Proof of Concept  1. Assume Pair P1,P2 exists in BaseV1Factory with default period size as 1800  2. Admin decides to decrease the period size to 900 using [setPeriodSize](https://github.com/code-423n4/2022-09-canto/blob/main/src/Swap/BaseV1-core.sol#L560) function  ``` function setPeriodSize(uint newPeriod) external {         require(msg.sender == admin);         require(newPeriod <= MaxPeriod);          for (uint i; i < allPairs.length; ) {             BaseV1Pair(allPairs[i]).setPeriodSize(newPeriod);             unchecked {++i;}         }     } ```  3. This changes period size of P1, P2 to 900  4. Admin creates a new Pair P3 using [createPair](https://github.com/code-423n4/2022-09-canto/blob/main/src/Swap/BaseV1-core.sol#L598) function  ``` function createPair(address tokenA, address tokenB, bool stable) external returns (address pair) {         require(tokenA != tokenB, "IA"); // BaseV1: IDENTICAL_ADDRESSES         (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);         require(token0 != address(0), "ZA"); // BaseV1: ZERO_ADDRESS         require(getPair[token0][token1][stable] == address(0), "PE"); // BaseV1: PAIR_EXISTS - single check is sufficient         bytes32 salt = keccak256(abi.encodePacked(token0, token1, stable)); // notice salt includes stable as well, 3 parameters         (_temp0, _temp1, _temp) = (token0, token1, stable);         pair = address(new BaseV1Pair{salt:salt}());         getPair[token0][token1][stable] = pair;         getPair[token1][token0][stable] = pair; // populate mapping in the reverse direction         allPairs.push(pair);         isPair[pair] = true;         emit PairCreated(token0, token1, stable, pair, allPairs.length);     } ```  5. A new Pair is created but the period size is not updated which means P3's period size will be 1800 instead of 900 which is incorrect  ## Recommended Mitigation Steps Add a new variable which stores the updated period size. Once a pair is created, update its period size using this new variable  ``` uint periodSizeUpdated=1800;  function setPeriodSize(uint newPeriod) external {         ... periodSizeUpdated=newPeriod;     }  function createPair(address tokenA, address tokenB, bool stable) external returns (address pair) { ... BaseV1Pair(pair).setPeriodSize(newPeriod);  } ```
# Lines of code  https://github.com/code-423n4/2022-09-canto/blob/main/src/Swap/BaseV1-periphery.sol#L582   # Vulnerability details  ## Details & Impact  ```solidity uint token0TVL = assetReserves[i] * (prices[i] / decimals); ```  Because of the brackets, the division of `prices[i] / decimals` is executed before multiplication, causing `token0TVL` to potentially be zero.  ## Proof of Concept  Add the following test in `oracle.test.ts`. Note: `getPriceLP()` should have its visibility changed from internal to public as the test relies on it.  To summarise what the test is doing, a stablecoin of 24 decimals is deployed, whose address will be greater than the `note` address so that `token0 = note`. It will enter the following case:  ```solidity if (pair.stable()) { // stable pairs will be priced in terms of Note   if (token0 == note) { //token0 is the unit, token1 will be priced with respect to this asset initially       decimals = 10 ** (erc20(token1).decimals()); // we must normalize the price of token1 to 18 decimals       prices = pair.sample(token1, decimals, 8, 1);       (unitReserves, assetReserves) = pair.sampleReserves(8, 1); ```  such that the `prices`’s denomination is smaller than the stablecoin’s decimals of 24.  To see the difference in test results, apply the recommended fix after running the test once. In essence, the LP’s price will double from `999500000001499` to `1999999998838589`, which is expected since the LP token should be worth the combined value of both stablecoins.  ```solidity it.only("will have 0 token0TVL", async () => {   // NOTE: change getPriceLP() from internal to public so that function can be called   let tokenFactory = await ethers.getContractFactory("ERC20", dep)   let stablecoin = await tokenFactory.deploy("STABLE","STABLE",ethers.utils.parseUnits("100000", "24"), 24)   await stablecoin.deployed()   // we want note to be token0   // redeploy till it is   while (stablecoin.address < note.address) {       stablecoin = await tokenFactory.deploy("STABLE","STABLE",ethers.utils.parseUnits("100000", "24"), 24)       await stablecoin.deployed()   }   // give token approvals to router   let noteIn = ethers.utils.parseUnits("10000", "18")   let stableIn = ethers.utils.parseUnits("10000", "24")   await (await note.approve(router.address, ethers.constants.MaxUint256)).wait()   await (await stablecoin.approve(router.address, ethers.constants.MaxUint256)).wait()    // borrow note   await (await comptroller._supportMarket(cUsdc.address)).wait()   // set collateral factors for cCanto    await (await comptroller._setCollateralFactor(cUsdc.address, ethers.utils.parseUnits("0.9", "18"))).wait()   // borrow note against usdc    await (await comptroller.enterMarkets([cUsdc.address, cNote.address])).wait()   await (await usdc.approve(cUsdc.address, ethers.utils.parseUnits("1000"))).wait()   // supply usdc   await (await cUsdc.mint(ethers.utils.parseUnits("100000000", "6"))).wait()   // borrow note   await (await cNote.borrow(ethers.utils.parseUnits("9000000", "18"))).wait()    // add liquidity   await (await router.addLiquidity(       note.address,       stablecoin.address,       true,       noteIn,       stableIn,       0,       0,       dep.address,       9999999999,       )).wait()   // get pair address   let pairAddr = await factory.getPair(note.address, stablecoin.address, true)   pair = await ethers.getContractAt("BaseV1Pair", pairAddr)    //set period size to zero for instant observations   await (await factory.setPeriodSize(0)).wait()    // swap 10 times for price observations   for(var i = 0; i < 10; i++) {       if (i % 2) {           //swap 0.01 note for stable           await (await router.swapExactTokensForTokensSimple(               ethers.utils.parseUnits("10", "18"),               0,               note.address,               stablecoin.address,               true,               dep.address,               9999999999999           )).wait()       } else {           //swap stable for note           await (await router.swapExactTokensForTokensSimple(               ethers.utils.parseUnits("10", "24"),               0,               stablecoin.address,               note.address,               true,               dep.address,               9999999999999           )).wait()       }   }   // check lpToken price   // Actual price calculated is 999500000001499   // But expected price (after removing brackets) is 1999999998838589   console.log((await router.getPriceLP(pairAddr)).toString()); }); ```  ## Recommended Mitigation Steps  ```diff - uint token0TVL = assetReserves[i] * (prices[i] / decimals); + uint token0TVL = assetReserves[i] * prices[i] / decimals; ```
