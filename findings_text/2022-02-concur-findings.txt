1) Use != instead of > for uint256 in StakingReward.sol:   Both amount and reward are of type uin256 comparing, checking for inequality instead of a greater than relation saves gas. The comparisons can be found in the lines below  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L94  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L119  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L119  Cache length before for loop ConcurRewardPool.sol:  2) The length can be cached before the loop avoid calling length many times to save gas.  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L35  3) Assignment to default value   In L51 uint totalAllocPoint is being declared with the default value of 0. Just totalAllocPoint; will save gas. The same thing can also be observed in StakingRewards.sol L21 and L22. Also in ConvexStakingWrapper.sol L36  Similarly bool transferSuccess is also being assigned False in L204  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L51  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L204  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L21  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L22  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L36  4) Resturcture if-else statement to remove else in StakingRewards.sol L142:  if (block.timestamp >= periodFinish) {             rewardRate = reward / rewardsDuration;         } else {             uint256 remaining = periodFinish - block.timestamp;             uint256 leftover = remaining * rewardRate;             rewardRate = (reward + leftover) / rewardsDuration;         }  can be reformulated as:  rewardRate = reward / rewardsDuration; if (block.timestamp < periodFinish) {             uint256 remaining = periodFinish - block.timestamp;             uint256 leftover = remaining * rewardRate;             rewardRate += (leftover / rewardsDuration);         }   https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L142   5) use unchecked{...} to save gas  uint256 is way too big to realistically lead to overflows, unchecked can be used to save gas in the following situations.   https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L121  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L219  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L34        
# QA Report **Table of Contents:**  - [QA Report](#qa-report)   - [Transfers](#transfers)     - [Prevent accidentally burning tokens](#prevent-accidentally-burning-tokens)     - [Use safeTransfer or require()/conditional instead of transfer/transferFrom](#use-safetransfer-or-requireconditional-instead-of-transfertransferfrom)     - [Use SafeERC20.safeApprove()](#use-safeerc20safeapprove)   - [Libraries](#libraries)     - [Deprecated library used for Solidity 0.8.11: SafeMath](#deprecated-library-used-for-solidity-0811-safemath)   - [Variables](#variables)     - [Missing Address(0) checks](#missing-address0-checks)     - [Variables that should be constant](#variables-that-should-be-constant)     - [Variables that are assumed to be initialized before a function call, but might not be](#variables-that-are-assumed-to-be-initialized-before-a-function-call-but-might-not-be)     - [Variables that should be bounded](#variables-that-should-be-bounded)     - [Variables that should be grouped together in a struct](#variables-that-should-be-grouped-together-in-a-struct)       - [File: ConvexStakingWrapper.sol](#file-convexstakingwrappersol)       - [File: Shelter.sol](#file-sheltersol)   - [Functions](#functions)     - [Functions that should be declared external](#functions-that-should-be-declared-external)   - [Arithmetics](#arithmetics)     - [Possible division by 0](#possible-division-by-0)  ## Transfers ### Prevent accidentally burning tokens  Transferring tokens to the zero address is usually prohibited to accidentally avoid "burning" tokens by sending them to an unrecoverable zero address.  Places where I couldn't find a zero address check (or where the destination isn't a zero-checked address): ``` ConvexStakingWrapper.sol:179:            IERC20(reward.token).transfer(treasury, d_reward / 5); //@audit treasury isn't address(0) checked ConvexStakingWrapper.sol:182:        IERC20(reward.token).transfer(address(claimContract), d_reward);//@audit claimContract isn't address(0) checked MasterChef.sol:206:            transferSuccess = concur.transfer(_to, concurBalance);//@audit _to == _recipient and isn't address(0) checked MasterChef.sol:208:            transferSuccess = concur.transfer(_to, _amount); //@audit _to == _recipient and isn't address(0) checked ```   I suggest adding a check to prevent accidentally burning tokens.  ### Use safeTransfer or require()/conditional instead of transfer/transferFrom  Silent failures (lack of failure detection / revert in case of failure) may happen here: ``` File: ConvexStakingWrapper.sol 178:         if (reward.token == cvx || reward.token == crv) { 179:             IERC20(reward.token).transfer(treasury, d_reward / 5); //@audit return value ignored 180:             d_reward = (d_reward * 4) / 5; 181:         } 182:         IERC20(reward.token).transfer(address(claimContract), d_reward);//@audit return value ignored ``` Consider using safeTransfer. That's already the case at other places on the same contract  ### Use SafeERC20.safeApprove() `approve()` will fail for certain token implementations that do not return a boolean value. It is recommended to use OpenZeppelin's SafeERC20's safeApprove().  Instances include: ``` USDMPegRecovery.sol:79:        usdm.approve(address(usdm3crv), addingLiquidity); USDMPegRecovery.sol:80:        pool3.approve(address(usdm3crv), addingLiquidity); ```  ## Libraries  ### Deprecated library used for Solidity 0.8.11: SafeMath Use Solidity 0.8.*'s default checks instead:  ``` MasterChef.sol:10:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; MasterChef.sol:14:    using SafeMath for uint; ```  ## Variables  ### Missing Address(0) checks ```   - rewardNotifier = _notifier (contracts/ConcurRewardPool.sol#16)   - treasury = _treasury (contracts/ConvexStakingWrapper.sol#70)   - treasury = _treasury (contracts/ConvexStakingWrapper.sol#83)   - rewardsDistribution = _rewardsDistribution (contracts/StakingRewards.sol#45)   - rewardsDistribution = _rewardsDistribution (contracts/StakingRewards.sol#195)   - kpiOracle = _kpiOracle (contracts/USDMPegRecovery.sol#57)   - (success,result) = _to.call{value: _value}(_data) (contracts/VoteProxy.sol#33) ```  ### Variables that should be constant ``` MasterChef._concurShareMultiplier (contracts/MasterChef.sol#56) MasterChef._perMille (contracts/MasterChef.sol#57) MasterChef.concurPerBlock (contracts/MasterChef.sol#50) ```  ### Variables that are assumed to be initialized before a function call, but might not be ``` File: ConvexStakingWrapper.sol 50:     IConcurRewardClaim public claimContract; ... 86:     function setRewardPool(address _claimContract) external onlyOwner { 87:         claimContract = IConcurRewardClaim(_claimContract); 88:     } ``` ### Variables that should be bounded  The variable `MasterChef.sol:43: uint16 depositFeeBP;  // Deposit fee in basis points` is never bounded, and UInt16.MaxValue is 65535  ### Variables that should be grouped together in a struct  For maps that use the same key value: having separate fields is error prone (like in case of deletion or future new fields).  #### File: ConvexStakingWrapper.sol  6 maps can be grouped together, as they use the same `pid`: ``` 41:     //convex rewards 42:     mapping(uint256 => address) public convexPool; 43:     mapping(uint256 => RewardType[]) public rewards; 44:     mapping(uint256 => mapping(uint256 => mapping(address => Reward))) 45:         public userReward; 46:     mapping(uint256 => mapping(address => uint256)) public registeredRewards; ... 63:     mapping(uint256 => mapping(address => Deposit)) public deposits; 64:     mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest; ``` I'd suggest these 3 related data get grouped in a struct, let's name it `RewardInfo`:   ``` struct RewardInfo {     address convexPool;     RewardType[] rewards;     mapping(uint256 => mapping(address => Reward)) userReward;     mapping(address => uint256) registeredRewards;     mapping(address => Deposit) deposits;     mapping(address => WithdrawRequest) withdrawRequest;   }   ``` And it would be used as a state variable in this manner (where `uint256` is `pid`):   ```   mapping(uint256 => RewardInfo) rewardInfo;   ```    #### File: Shelter.sol 3 maps can be grouped together, as they use the same `_token`: ```   17:     mapping(IERC20 => mapping(address => bool)) public override claimed; 18:  19:     mapping(IERC20 => uint256) public activated; 20:  21:     mapping(IERC20 => uint256) public savedTokens; ``` I'd suggest these 3 related data get grouped in a struct, let's name it `TokenInfo`:   ``` struct TokenInfo {     mapping(address => bool) claimed;     uint256 activated;     uint256 savedTokens;   }   ``` And it would be used as a state variable in this manner (where `IERC20` is `_token`):   ```   mapping(IERC20 => TokenInfo) tokenInfo;   ```    ## Functions  ### Functions that should be declared external ```  - ConvexStakingWrapper.addRewards(uint256) (contracts/ConvexStakingWrapper.sol#93-140)  - MasterChef.add(address,uint256,uint16,uint256) (contracts/MasterChef.sol#86-101)  - MasterChef.massUpdatePools() (contracts/MasterChef.sol#127-132) ```  ## Arithmetics  ### Possible division by 0 There are no checks that the denominator is `!= 0` at thoses lines: ``` library\CvxMining.sol:16:        uint256 cliff = supply / reductionPerCliff; MasterChef.sol:120:            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint); MasterChef.sol:121:            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply)); MasterChef.sol:151:        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint); MasterChef.sol:152:        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply)); Shelter.sol:54:        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token); ```
## Do not recalculate constant results  Since results are constant, the code should not calculate them over and over again.  [https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L116-L117](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L116-L117)  ```  registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1 registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1  ```  ## `StakingRewards.sol` cache variables to save gas  By caching variables, loads from storage can be avoided to save gas.  ```  rewardPerToken() — rewardPerTokenStored  notifyRewardAmount() — rewardsDuration, periodFinish  updateReward() — rewardPerTokenStored (cache the new value)  ```  ## `USDMPegRecovery.sol` cache variables to save gas  By caching variables, loads from storage can be avoided to save gas.  ```  provide() -- step, usdm3crv  ```  ## At setters emit input rather than from storage to save gas  In `StakingRewards.sol`:  ```  setRewardsDuration  setRewardsDistribution  ```
* Repeated external call to usdm.balanceOf(address(this): ```solidity   require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, "<liquidity");   ...   uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step; ```  * Don't need to call owner() here, you can just use msg.sender: ```solidity   function recoverERC20(address tokenAddress, uint256 tokenAmount)       external       onlyOwner   {       ...       IERC20(tokenAddress).safeTransfer(owner(), tokenAmount); ```  * Long revert messages, e.g.: "Previous rewards period must be complete before changing the duration for the new period" Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.  * Variables that are set in the constructor and can't be changed can be marked as immutable: ```solidity     uint256 public step;     uint256 public startLiquidity;     uint public startBlock;     uint public endBlock; ```  * Should be constant: ```solidity     uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block     uint private _concurShareMultiplier = 1e18;     uint private _perMille = 1000; // 100% ```  * Variables and events that are not used in any meaningful way can be removed or used where they were intended: ```solidity     uint256 public startLiquidity;     event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount); ```  * Would be cheapier to use local variables when emitting events, e.g.: ```solidity   rewardsDuration = _rewardsDuration;   emit RewardsDurationUpdated(rewardsDuration);    rewardsDistribution = _rewardsDistribution;   emit RewardsDistributionUpdated(rewardsDistribution); ```  * Usually under normal conditions, the first check is not neccessary, as GRACE_PERIOD > block.timestamp should always revert: ```solidity   require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, "too late"); ```  * This could be inlined to optimize for gas usage, from: ```solidity   bool transferSuccess = false;   if (_amount > concurBalance) {       transferSuccess = concur.transfer(_to, concurBalance);   } else {       transferSuccess = concur.transfer(_to, _amount);   }   require(transferSuccess, "safeConcurTransfer: transfer failed"); ``` to: ```solidity   if (_amount > concurBalance) {       require(concur.transfer(_to, concurBalance), "safeConcurTransfer: transfer failed");   } else {       require(transferSuccess = concur.transfer(_to, _amount), "safeConcurTransfer: transfer failed");   } ```  * Repeated access of storage variables should be cached, e.g. convexBooster is accessed 3 times: ```solidity   lpToken.safeApprove(convexBooster, _amount);   IConvexDeposits(convexBooster).deposit(_pid, _amount, true);   lpToken.safeApprove(convexBooster, 0); ``` masterChef twice: ```solidity   uint256 pid = masterChef.pid(address(lpToken));   masterChef.deposit(msg.sender, pid, _amount); ``` convexPool[_pid] twice: ```solidity   IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);   IERC20 lpToken = IERC20(     IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken   ); ``` registeredRewards[_pid] twice: ```solidity   registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1   registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1 ```  * The initialization to default variables is not neccessary: ```solidity     uint256 public periodFinish = 0;     uint256 public rewardRate = 0; ```  * If the same MasterChef implementation will be used, then the pid of the token can't change, so you should cache it once (in the constructor call), and do not make the external calls again and again in stake and withdraw functions of StakingRewards: ```solidity   uint256 pid = masterChef.pid(address(stakingToken)); ```  * Contract MasterChef has declared a compiler version of ^0.8.11 but it still uses the SafeMath library: ```solidity   using SafeMath for uint;   // e.g.:   return _to.sub(_from);   uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);   accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply)); ``` Overflow/underflow protection is built-in starting from version 0.8, so you don't need to use SafeMath here.  * Would be cheaper if you checked not the storage but the _amount paramater against 0 in the first sentence: ```solidity   require(user.amount > 0, "MasterChef: nothing to withdraw");   require(user.amount >= _amount, "MasterChef: withdraw not allowed"); ```  * currentEpoch() is called twice, should cache after the first call: ```solidity   require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), "wait"); ```  * You already have the address of rewardToken() here, no need to fetch it again:  ```solidity   address extraToken = IRewardStaking(extraPool).rewardToken();     ...     else if (registeredRewards[_pid][extraToken] == 0) {       //add new token to list       rewards[_pid].push(           RewardType({               token: IRewardStaking(extraPool).rewardToken() ```  * In _calcRewardIntegral I think these statements: ```solidity     //update remaining reward here since balance could have changed if claiming     if (bal != reward.remaining) {         reward.remaining = uint128(bal);     } ``` should be placed right after this: ```solidity     uint256 d_reward = bal - reward.remaining; ``` or you can even return and skip all the heavy calculations and 0 value transfers if the balance hasn't changed.
* Function recoverERC20 in StakingRewards allows an owner to transfer out any token except stakingToken. I see 2 problems with this: 1) It should also forbid transferring of rewardsToken, otherwise an owner can drain the rewards and DDOS users withdrawals because there is no way to get back your stake tokens without claiming the rewards. 2) It may be possible that someone accidentally sent stake tokens directly to the contract and these tokens will not be accounted in _totalSupply, thus it makes sense that an owner should be able to rescue these unaccounted tokens: stakingToken.balanceOf(address(this) - _totalSupply).  I assigned this issue a severity of low because I assume we can trust the owner not to exploit this :?  You should forbid recoverERC20 of rewardsToken, and may also allow transferring the surplus from _totalSupply of stakingToken. Usually, it is a good practice in such contracts to have an emergency withdrawal function, where users can get back their stake tokens but forfeit the rewards.  * Function setRewardsDistribution has a misleading revert message:  "... changing the duration ..."  * A small loss in precision due to multiplication and division: ```solidity   IERC20(reward.token).transfer(treasury, d_reward / 5);   d_reward = (d_reward * 4) / 5; ``` A more accurate approach would be something like this: ```solidity   uint toTreasury = d_reward / 5;   IERC20(reward.token).transfer(treasury, toTreasury);   d_reward -= toTreasury; ```  * Consider introducing a reasonable upper limit for the rewards[_pid] array in ConvexStakingWrapper, otherwise if it grows too large it may exceed the gas limit when performing the _checkpoint and there is no way to remove it once added.  * ConvexStakingWrapper function addRewards fetches extraRewards and adds them to the list of rewards, but please note that extra rewards can change: https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L109-L119 Currently, ConvexStakingWrapper has no function to (sync) delete extra rewards. Consider implementing it.  * You should use safe casts here: ```solidity   deposits[_pid][msg.sender].amount += uint192(_amount);   deposits[_pid][msg.sender].amount -= uint192(_amount);   amount : uint192(_amount) ``` Otherwise, if token amounts are exceeding these limits (e.g. rebasing tokens) the accounted and transferred amounts will differ. For instance, in function deposit it will add less to the user's balance but charge the full amount: ```solidity   deposits[_pid][msg.sender].amount += uint192(_amount);   ...   lpToken.safeTransferFrom(msg.sender, address(this), _amount); ```  * I don't think this check in function provide of contract USDMPegRecovery is correct: ```solidity   require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, "<liquidity"); ``` After you provide the liquidity (usdm3crv.add_liquidity), the balance of usdm will decrease, but totalLiquidity.usdm, will not, so the next time it will need to increase even more to reach this condition again. But not sure what was the exact intention here, so submitting this as of low severity FYI.  * Consider introducing a withdrawal deadline to indicate when it is too late and the user has to requestWithdraw again.  * I think the comment and the actual code is misleading here: ```solidity    if (extraToken == cvx) {         //no-op for cvx, crv rewards         rewards[_pid][CVX_INDEX].pool = extraPool;     }  ```
1. LOW: Solidity version pragma uses caret.  [Example](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L3) Note that this issue is present in pretty much every other contract in the project.  This is a bad practice because `^0.8.11` means that the contracts can be compiled with solidity versions greater than or equal to 0.8.11 but less than 0.9.0. Because any number of solidity versions can be used, it is possible that the contracts are tested with one version of solidity and deployed to production using another version of solidity, which can lead to issues if there are bugs in the solidity compiler. Instead, the lines should be replaced with `pragma solidity 0.8.11;`  so that 0.8.11 is used in production and testing.  3. informational: `safeTransfer` to `msg.sender` in `StakingRewards.withdraw` should come after all effects. [location](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L111) This follows the check-effects-interactions pattern, and is good defense-in-depth (since there function uses `nonReentrant` modifier).  4. Informational: Code layout in StakingRewards doesn't obey conventions, events are on the bottom. [Example](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L213) They should come before functions. Putting events at the end is inconsistent with the other contracts in this repo. [It is also inconsistent with solidity's standard conventions](https://docs.soliditylang.org/en/v0.8.11/style-guide.html#order-of-layout) 
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L34 https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L54   # Vulnerability details  ## Impact Function donate in Shelter shouldn't allow new deposits after the grace period ends, when the claim period begins.  Otherwise, it will be possible to increase savedTokens[_token], and thus new user claim amounts will increase after some users might already have withdrawn their shares.  ## Recommended Mitigation Steps Based on my understanding, it should contain this check: ```solidity   require(activated[_token] + GRACE_PERIOD > block.timestamp, "too late"); ```  
###GAS OPTIMIZATION --1 -unnecessary `i` value set https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L35 unnecessary value set. the default value of uint is zero. just use: ``` uint i; ``` --2 -better increment https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L35 change i++ to ++i --3 -Best way to use `SafeERC20.function` for gas opt https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L10 by not declare: ``` using SafeERC20 for IERC20; ``` and use: ``` SafeERC20.safeTransfer(IERC20(_tokens[i]), msg.sender, getting); ``` can safe gas usage. --4 -unnecessary variable declaration -Unnecessary (uint) `getting` variable declaration https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L36 instead of caching `reward[msg.sender][_tokens[i]]` in `getting`, better just pass it directly into `safeTransfer()` function. `getting` was declared and called once per loop. It cost more gas.  recommended mitigation: ``` IERC20(_tokens[i]).safeTransfer(msg.sender, reward[msg.sender][_tokens[i]]); // L 36 ``` ##ConvexStakingWrapper.sol --5 -Using `storage` to declare Struct variable inside function https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L171 instead of caching `rewardType` to memory. read it directly from storage. ``` RewardType storage reward = rewards[_pid][_index]; ``` --6 -Using `uint` instead `struct` https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L24 The `Reward` struct merely contain 1 property. Instead of declaring it as struct, better as a uint example: uint128 integralReward(example name); https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L44 then modify the `userReward` mapping output from `Reward` to `uint`. ##MasterChef.sol --7 -unnecessary `totalAllocPoint` & `_pid` value set  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L51 https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L129 unnecessary value set. the default value of uint is zero. just use: ``` uint public totalAllocPoint; ``` --8 -use constant for gas saving https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L57 use `constant` to declare `_perMille` & ` _concurShareMultiplier` uint --9 -Unused library https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L15 unused SafeERC20 lib ##Shelter.sol --10 -`&&` is more expensive gas https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L45 using multiple `require()` is cheaper than use && ``` require(activated[_token] != 0 , "too late"); require(activated[_token] + GRACE_PERIOD > block.timestamp, "too late"); ``` --11 -unnecessary value set https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L21-L22 unnecessary value set. the default value of uint is zero for `rewardRate` & `periodFinish`. uint default value is 0 --12 -`step` declaration https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L22 setting the `step` value directly and use `constant` can save gas. then remove the line: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L56 --13 -using storage to declare struct inside function https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L91 instead of caching `Liquidity` in memory. just read it directly to storage ``` Liquidity storage total = totalLiquidity; ``` it can save gas. And same for `user` variable right below it. --14 -unnecessary math operation https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L116-L117 the value of `registeredRewards[_pid][crv]` and `registeredRewards[_pid][cvx]` is fixed, Set the value(1 and 2) directly then add additional info which explain the math operation behind it: ```             registeredRewards[_pid][crv] = 1; //mark registered CRV_INDEX + 1             registeredRewards[_pid][cvx] = 2; //mark registered CVX_INDEX + 1 ``` --15 -use calldata to store `signature` https://github.com/code-423n4/2022-02-concur/blob/main/contracts/EasySign.sol#L51 replace memory with calldata to save gas --16 -Using `immutable` to declare variable which set once at constructor https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L52-L54 `startBlock`, `endBlock` & `concur` are set once in constructor. Use `immutable` --17 -use `require()` to validate instead `if()` https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L137 by using: ```  require(block.number > pool.lastRewardBlock); ``` to replace: ```         if (block.number <= pool.lastRewardBlock) {             return;         } ``` can save gas with the same output 18-- -Unncessary `multiplier` (uint) declaration https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L150-L151 `multiplier` is called once in `updatePool()`. Its gas consuming to cache `getMultiplier` return in `multiplier`. Remove line 150, and change line it to: ``` uint concurReward = getMultiplier(pool.lastRewardBlock, block.number).mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint); ```     
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L52-L57   # Vulnerability details  ## Impact tl;dr Anyone who can call `withdraw` to withdraw their own funds can call it repeatedly to withdraw the funds of others. `withdraw` should only succeed if the user hasn't withdrawn the token already.  The shelter can be used for users to withdraw funds in the event of an emergency. The `withdraw` function allows callers to withdraw tokens based on the tokens they have deposited into the shelter client: ConvexStakingWrapper. However, `withdraw` does not check if a user has already withdrawn their tokens. Thus a user that can `withdraw` tokens, can call withdraw repeatedly to steal the tokens of others.  ## Proof of Concept  tl;dr an attacker that can successfully call `withdraw` once on a shelter, can call it repeatedly to steal the funds of others. Below is a detailed scenario where this situation can be exploited.  1. Mallory deposits 1 `wETH` into `ConvexStakingWrapper` using [`deposit`](https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L280). Let's also assume that other users have deposited 2 `wETH` into the same contract. 2. An emergency happens and the owner of `ConvexStakingWrapper` calls `setShelter(shelter)` and `enterShelter([pidOfWETHToken, ...])`. Now `shelter` has 3 `wETH` and is activated for `wETH`. 3. Mallory calls `shelter.withdraw(wETHAddr, MalloryAddr)`, mallory will rightfully receive 1 wETH because her share of wETH in the shelter is 1/3. 4. Mallory calls `shelter.withdraw(wETHAddr, MalloryAddr)` again, receiving 1/3*2 = 2/3 wETH. `withdraw` does not check that she has already withdrawn. This time, the wETH does not belong to her, she has stolen the wETH of the other users. She can continue calling `withdraw` to steal the rest of the funds   ## Tools Used  Manual inspection.  ## Recommended Mitigation Steps  To mitigate this, `withdraw` must first check that `msg.sender` has not withdrawn this token before and `withdraw` must also record that `msg.sender` has withdrawn the token. The exact steps for this are below: 1. Add the following line to the beginning of `withdraw` (line 53): ``` require(!claimed[_token][msg.sender], "already claimed") ``` 2.  Replace [line 55](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L55) with the following: ``` claimed[_token][msg.sender] = true; ``` This replacement is necessary because we want to record who is withdrawing, not where they are sending the token which isn't really useful info.  
 1. considered using != instead of > can save gas https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L236 // gas cost 45422  Change to: ```  if (_amount != 0) { ``` // gas cost 45419  ========================================================================  2. using calldata can save gas https://github.com/code-423n4/2022-02-concur/blob/main/contracts/EasySign.sol#L51 // gas cost 23523  Change to: ``` function tryRecover(bytes32 hash, bytes calldata signature) ``` // gas cost 23056  ========================================================================  3. considered using require instead of `if` can save gas https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L118 // gas cost 24404  Change to: ```         require (block.number > pool.lastRewardBlock);         require (lpSupply != 0);  ``` // gas cost 24392  ========================================================================  4. considered using require instead of && can save gas  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L45 // gas cost 24475  Change to: ```         require(activated[_token] != 0);         require (activated[_token] + GRACE_PERIOD > block.timestamp, "too late"); ``` // gas cost 24162
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86-L101   # Vulnerability details  ## Impact  Token fee in `MasterChef` can be set to more than 100%, (for example by accident) causing all `deposit` calls to fail due to underflow on subtraction when reward is lowered by the fee, thus breaking essential mechanics. Note that after the fee has been set to any value, it cannot be undone. A token cannot be removed, added, or added the second time. Thus, mistakenly (or deliberately, maliciously) added fee that is larger than 100% will make the contract impossible to recover from not being able to use the token.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  On setting fee ensure that it is below a set maximum, which is set to no more than 100%.   
1. Tittle Changing memory to storage can safe gas.  ## Impact Bye changing memory pointer to storage pointer and delete line ``https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L206.`` ``https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L105.``, can safe gas.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L206. https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L105.
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L182   # Vulnerability details  ## Impact  If deposits and withdraws are done frequently enough, the reward update operation they invoke will deal mostly with the case when there is nothing to add yet, i.e. `reward.remaining` match the reward token balance.  If reward token doesn't allow for zero value transfers, the reward update function will fail on an empty incremental reward transfer, which is now done unconditionally, reverting the caller deposit/withdrawal functionality  ## Proof of Concept  When ConvexStakingWrapper isn't paused, every deposit and withdraw update current rewards via `_checkpoint` function before proceeding:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L233  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L260  `_checkpoint` calls `_calcRewardIntegral` for each of the reward tokens of the pid:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L220  `_calcRewardIntegral` updates the incremental reward for the token, running the logic even if reward is zero, which is frequently the case:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L182  If the reward token doesn't allow zero value transfers, this transfer will fail, reverting the corresponding deposit or withdraw  ## Recommended Mitigation Steps  Consider checking the reward before doing transfer (and the related computations as an efficiency measure):  Now: ``` IERC20(reward.token).transfer(address(claimContract), d_reward); ```  To be: ``` if (d_reward > 0)  IERC20(reward.token).transfer(address(claimContract), d_reward); ```   
1. Tittle execute() should revert, instead of returning false on failing low level call   # Vulnerability details  ## Impact When an owner want to execute something, make sure to revert the transaction when the low level call is failing, this execute() will still returning a success transaction, eventhough the actual execution is failing when doing the low level call  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/VoteProxy.sol#L33 --------------------------------------------------------------------------------------------------------------------------- 2. Tittle claimRewards() didnt follow the safe check effect pattern  ## Impact a user can claim a reward by calling the claimRewards(), however this function didnt follow the correct check effect pattern, where the zero address is set after making an external call, lets say the reward token is erc777 which will make an external during transfer, the user can reenter this function since this function didnt follow the check effect pattern and didnt have a noreentrant modifier, the user can claim token with reentrancy.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L37 --------------------------------------------------------------------------------------------------------------------------- 3. Tittle Unsafe cast from uint256 to uint192  ## Impact  the max value of uint192 is 6277101735386680763835789423207666416102355444464034512895, however when you input the _amount to 6277101735386680763835789423207666416102355444464034512896 value, since it doing an unsafe cast from uint256 to uint192, the _amount value would be 0.  ##Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L235 --------------------------------------------------------------------------------------------------------------------------- 4. Tittle this check can be bypassed  ## Impact this check is useless, since the usdm is allowed a user to flashmint the token, in the usdm contract, the usdm is allowed the user to flashmint the token instead of the usual flashloan, in flashmint you are minting a token instead of borrowing an existing token, therefore the flashmint is allowed the user to borrow up to 115792089237316195423570985008687907853269984665640517394379403123841238667621 usdm token, then deposit the pool3 token.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L100 1. unlockable state is true and totalliquidity usdm is bellow 4m 2. a user/whale is flashmint 4m usdm 3. user deposit 4m usdm token 4. user deposit pool3 token 5. withdraw the 4m usdm that was already deposited 6. pay the fee 7. now the user/whale has deposited the pool3 token eventhough the totalliqudity of usdm still below 4m ------------------------------------------------------------------------------------------------------------------------- 5. Tittle mismatch between description and actual code  ## Impact the actual value in the https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L100 is 4m usdm, but the description said that it is 40m usdm.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L100 
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L178-185   # Vulnerability details  ## Impact  notifyRewardAmount will be inoperable if rewardsDuration bet set to zero. If will cease to produce meaningful results if rewardsDuration be too small or too big  ## Proof of Concept  The setter do not control the value, allowing zero/near zero/enormous duration:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L178-185  Division by the duration is used in notifyRewardAmount:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L143-156  ## Recommended Mitigation Steps  Check for min and max range in the rewardsDuration setter, as too small or too big rewardsDuration breaks the logic  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol   # Vulnerability details  ## Impact There is no functionality for removing pools/setting pool's allocPoints. Therefore `totalAllocPoint` only increases and rewards for pool decreases.  ## Proof of Concept Scenario: 1. Owner adds new pool (first pool) for staking with points = 900 (totalAllocPoint=900). 2. 1 week passes 3. First pool staking period ends (or for other reasons that pool is not meaningfully anymore). 4. Owner adds new pool (second pool) for staking with points = 100 (totalAllocPoint=1000) 5. 1 block later Alice stake 10 tokens there (at the same time). 6. 1 week passes 7. After some time Alice claims rewards. But she is eligible only for 10% of the rewards. 90% goes to unused pool.  ## Tools Used Manual review  ## Recommended Mitigation Steps Add functionality for removing pool or functionality for setting pool's `totalAllocPoint` param.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86   # Vulnerability details  ## Impact When adding new token pool for staking in MasterChef contract ```javascript function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) ``` All other, already added, pools should be updated but currently they are not. Instead, only totalPoints is updated. Therefore, old (and not updated) pools will lose it's share during the next update. Therefore, user rewards are not computed correctly (will be always smaller).  ## Proof of Concept Scenario 1: 1. Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100)    and 1 block later Alice stakes 10 tokens in the first pool. 2. 1 week passes 3. Alice withdraws her 10 tokens and claims X amount of reward tokens.    and 1 block later Bob stakes 10 tokens in the first pool. 4. 1 week passes 5. Owner adds new pool (second pool) for staking with points = 100 (totalPoints=200)    and 1 block later Bob withdraws his 10 tokens and claims X/2 amount of reward tokens.    But he should get X amount  Scenario 2: 1. Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100). 2. 1 block later Alice, Bob and Charlie stake 10 tokens there (at the same time). 3. 1 week passes 4. Owner adds new pool (second pool) for staking with points = 400 (totalPoints=500) 5. Right after that, when Alice, Bob or Charlie wants to withdraw tokens and claim rewards they will only be able to claim 20% of what they should be eligible for, because their pool is updated with 20% (100/500) rewards instead of 100% (100/100) rewards for the past week.  ## Tools Used Manual review  ## Recommended Mitigation Steps Update all existing pools before adding new pool. Use the massUdpate() function which is already present ... but unused.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110-L128   # Vulnerability details  Per the doc:  > USDM deposits are locked based on the KPI’s from carrot.eth.  > 3Crv deposits are not locked.  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110-L128  ```solidity function withdraw(Liquidity calldata _withdrawal) external {         Liquidity memory total = totalLiquidity;         Liquidity memory user = userLiquidity[msg.sender];         if(_withdrawal.usdm > 0) {             require(unlockable, "!unlock usdm");             usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));             total.usdm -= _withdrawal.usdm;             user.usdm -= _withdrawal.usdm;         }          if(_withdrawal.pool3 > 0) {             pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));             total.pool3 -= _withdrawal.pool3;             user.pool3 -= _withdrawal.pool3;         }         totalLiquidity = total;         userLiquidity[msg.sender] = user;         emit Withdraw(msg.sender, _withdrawal);     } ```  However, because the `withdraw()` function takes funds from the balance of the contract, once the majority of the funds are added to the curve pool via `provide()`. The `withdraw()` may often fail due to insufficient funds in the balance.  ### PoC  1. Alice deposits `4M` USDM and `4M` pool3 tokens; 2. Guardian calls `provide()` and all the `usdm` and `pool3` to `usdm3crv`; 3. Alice calls `withdraw()`, the tx will fail, due to insufficient balance.  ### Recommendation  Consider calling `usdm3crv.remove_liquidity_one_coin()`  when the balance is insufficient for the user's withdrawal.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L166-L176   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L166-L176  ```solidity     function recoverERC20(address tokenAddress, uint256 tokenAmount)         external         onlyOwner     {         require(             tokenAddress != address(stakingToken),             "Cannot withdraw the staking token"         );         IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);         emit Recovered(tokenAddress, tokenAmount);     } ```  ### Impact  Users can lose all the rewards to the malicious/compromised `owner`.  ### Recommendation  Change to:  ```solidity  function recoverERC20(     address tokenAddress,     address to,     uint256 amount ) external onlyOwner {     require(tokenAddress != address(stakingToken) && tokenAddress != address(rewardsToken), "20");      IERC20(tokenAddress).safeTransfer(to, amount);     emit Recovered(tokenAddress, to, amount); } ```  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L154-L158   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L154-L158  ```solidity     uint256 balance = rewardsToken.balanceOf(address(this));     require(         rewardRate <= balance / rewardsDuration,         "Provided reward too high"     ); ```  In the current implementation, the contract only checks if balanceOf `rewardsToken` is greater than or equal to the future rewards.  However, under normal circumstances, since users can not withdraw all their rewards in time, the balance in the contract contains rewards that belong to the users but have not been withdrawn yet. This means the current checks can not be sufficient enough to make sure the contract has enough amount of rewardsToken.  As a result, if the `rewardsDistribution` mistakenly `notifyRewardAmount` with a larger amount, the contract may end up in a wrong state that makes some users unable to claim their rewards.  ### PoC  Given:  - rewardsDuration = 7 days;  1. Alice stakes `1,000` stakingToken; 2. `rewardsDistribution` sends `100` rewardsToken to the contract; 3. `rewardsDistribution` calls `notifyRewardAmount()` with `amount` = `100`; 4. 7 days later, Alice calls `earned()` and it returns `100` rewardsToken, but Alice choose not to `getReward()` for now; 5. `rewardsDistribution` calls `notifyRewardAmount()` with `amount` = `100` without send any fund to contract, the tx will succees; 6. 7 days later, Alice calls `earned()` `200` rewardsToken, when Alice tries to call `getReward()`, the transaction will fail due to insufficient balance of rewardsToken.  Expected Results:  The tx in step 5 should revert.  ### Recommendation  Consider changing the function `notifyRewardAmount` to `addRward` and use `transferFrom` to transfer rewardsToken into the contract:  ```solidity function addRward(uint256 reward)     external     updateReward(address(0)) {     require(         msg.sender == rewardsDistribution,         "Caller is not RewardsDistribution contract"     );      if (block.timestamp >= periodFinish) {         rewardRate = reward / rewardsDuration;     } else {         uint256 remaining = periodFinish - block.timestamp;         uint256 leftover = remaining * rewardRate;         rewardRate = (reward + leftover) / rewardsDuration;     }      rewardsToken.safeTransferFrom(msg.sender, address(this), reward);      lastUpdateTime = block.timestamp;     periodFinish = block.timestamp + rewardsDuration;     emit RewardAdded(reward); } ```  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L135-L154   # Vulnerability details  According to:  -   README https://github.com/code-423n4/2022-02-concur#-masterchef -   Implementation of `deposit()`: [/contracts/MasterChef.sol#L157-L180](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L157-L180)  MasterChef is only recording the deposited amount in the states, it's not actually holding the `depositToken`.  `depositToken` won't be transferred from `_msgSender()` to the MasterChef contract.  Therefore, in `updatePool()` L140 `lpSupply = pool.depositToken.balanceOf(address(this))` will always be `0`. And the `updatePool()` will be returned at L147.  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L135-L154  ```solidity function updatePool(uint _pid) public {     PoolInfo storage pool = poolInfo[_pid];     if (block.number <= pool.lastRewardBlock) {         return;     }     uint lpSupply = pool.depositToken.balanceOf(address(this));     if (lpSupply == 0 || pool.allocPoint == 0) {         pool.lastRewardBlock = block.number;         return;     }     if(block.number >= endBlock) {         pool.lastRewardBlock = block.number;         return;     }              uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);     uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);     pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));     pool.lastRewardBlock = block.number; } ```   ### Impact  - The MasterChef contract fail to implement the most essential function; - Users won't be able to receive any `Concur` rewards from MasterChef;  ### Recommendation  Consider creating a receipt token to represent the invested token and use the receipt tokens in MasterChef.  See: https://github.com/convex-eth/platform/blob/883ffd4ebcaee12e64d18f75bdfe404bcd900616/contracts/contracts/Booster.sol#L272-L277  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L175-L204   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L175-L204  ```solidity     uint256 bal = IERC20(reward.token).balanceOf(address(this));     uint256 d_reward = bal - reward.remaining;     // send 20 % of cvx / crv reward to treasury     if (reward.token == cvx || reward.token == crv) {         IERC20(reward.token).transfer(treasury, d_reward / 5);         d_reward = (d_reward * 4) / 5;     }     IERC20(reward.token).transfer(address(claimContract), d_reward);      if (_supply > 0 && d_reward > 0) {         reward.integral =             reward.integral +             uint128((d_reward * 1e20) / _supply);     }      //update user integrals     uint256 userI = userReward[_pid][_index][_account].integral;     if (userI < reward.integral) {         userReward[_pid][_index][_account].integral = reward.integral;         claimContract.pushReward(             _account,             reward.token,             (_balance * (reward.integral - userI)) / 1e20         );     }      //update remaining reward here since balance could have changed if claiming     if (bal != reward.remaining) {         reward.remaining = uint128(bal);     } ```  The problems in the current implementation:  - `reward.remaining` is not a global state; the `reward.remaining` of other `reward`s with the same rewardToken are not updated; - `bal` should be refreshed before `reward.remaining = uint128(bal);`; - L175 should not use `balanceOf` but take the diff before and after `getReward()`.  ### PoC  - convexPool[1] is incentivized with CRV as the reward token, `1000 lpToken` can get `10 CRV` per day; - convexPool[2] is incentivized with CRV as the reward token, `1000 lpToken` can get `20 CRV` per day.  1. Alice deposits `1,000` lpToken to `_pid` = `1` 2. 1 day later, Alice deposits `500` lpToken to `_pid` = `1`   - convexPool `getReward()` sends `10 CRV` as reward to contract - `d_reward` = 10, `2 CRV` sends to `treasury`, `8 CRV` send to `claimContract` - `rewards[1][0].remaining` = 10  3. 0.5 day later, Alice deposits `500` lpToken to `_pid` = `1`, and the tx will fail:  - convexPool `getReward()` sends `7.5 CRV` as reward to contract - `reward.remaining` = 10 - `bal` = 7.5 - `bal - reward.remaining` will fail due to underflow  4. 0.5 day later, Alice deposits `500` lpToken to `_pid` = `1`, most of the reward tokens will be left in the contract:  - convexPool `getReward()` sends `15 CRV` as reward to the contract; - `d_reward = bal - reward.remaining` = 5 - `1 CRV` got sent to `treasury`, `4 CRV` sent to `claimContract`, `10 CRV` left in the contract; - `rewards[1][0].remaining` = 15  Expected Results:  All the `15 CRV` get distributed: `3 CRV` to the `treasury`, and `12 CRV` to `claimContract`.  Actual Results:  Only `5 CRV` got distributed. The other `10 CRV` got left in the contract which can be frozen in the contract, see below for the details:  5. Bob deposits `1,000` lpToken to `_pid` = `2`  - convexPool `getReward()` sends `0 CRV` as reward to the contract - `d_reward = bal - reward.remaining` = 10 - `2 CRV` sent to `treasury`, `8 CRV` sent to `claimContract` without calling `pushReward()`, so the `8 CRV` are now frozen in `claimContract`; - `rewards[2][0].remaining` = 10  ### Impact  - The two most important methods: `deposit()` and `withdraw()` will frequently fail as the tx will revert at `_calcRewardIntegral()`; - Rewards distributed to users can often be fewer than expected; - If there are different pools that use the same token as rewards, part of the rewards can be frozen at `claimContract` and no one can claim them.  ### Recommendation  Consider comparing the `balanceOf` reward token before and after `getReward()` to get the actual rewarded amount, and `reward.remaining` should be removed.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/ConvexStakingWrapper.sol#L184-L188   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/ConvexStakingWrapper.sol#L184-L188  ```solidity if (_supply > 0 && d_reward > 0) {     reward.integral =         reward.integral +         uint128((d_reward * 1e20) / _supply); } ```  `reward.integral` is `uint128`, if an early user deposits with just `1` Wei of `lpToken`, and make `_supply == 1`, and then transferring `5e18` of `reward_token` to the contract.  As a result, `reward.integral` can exceed `type(uint128).max` and overflow, causing the rewards distribution to be disrupted.  ### Recommendation  Consider `wrap` a certain amount of initial totalSupply at deployment, e.g. `1e8`, and never burn it. And consider using uint256 instead of uint128 for `reward.integral`. Also, consdier lower `1e20` down to `1e12`.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/USDMPegRecovery.sol#L73-L82   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/USDMPegRecovery.sol#L73-L82  ```solidity function provide(uint256 _minimumLP) external onlyGuardian {     require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, "<liquidity");     // truncate amounts under step     uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;     // match usdm : pool3 = 1 : 1     uint256[2] memory amounts = [addingLiquidity, addingLiquidity];     usdm.approve(address(usdm3crv), addingLiquidity);     pool3.approve(address(usdm3crv), addingLiquidity);     usdm3crv.add_liquidity(amounts, _minimumLP); } ```  In the current implementation of `USDMPegRecovery.sol#provide()`, `addingLiquidity` is calculated solely based on `usdm` balance (truncate at a step of 250k), and it always uses the same amount of 3pool tokens to add_liquidity with.  Based on other functions of the contract, the balance of `usdm` can usually be more than the `pool3` balance, in that case, `usdm3crv.add_liquidity()` will fail.  ### Impact  When the balance of `pool3` is less than `usdm` (which is can be a common scenario), funds cannot be added to the curve pool.  For example:  When the contract got 5M of USDM and 4.2M of `pool3` tokens, it won't be possible to call `provide()` and add liquidity to the `usdm3crv` pool, as there are not enough pool3 tokens to match the 5M of USDM yet.  We expect it to add liquidity with 4M of USDM and 4M of pool3 tokens in that case.  ### Recommendation  Change to:  ```solidity function provide(uint256 _minimumLP) external onlyGuardian {     require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, "<liquidity");     uint256 tokenBalance = Math.min(usdm.balanceOf(address(this), pool3.balanceOf(address(this));     // truncate amounts under step     uint256 addingLiquidity = (tokenBalance / step) * step;     // match usdm : pool3 = 1 : 1     uint256[2] memory amounts = [addingLiquidity, addingLiquidity];     usdm.approve(address(usdm3crv), addingLiquidity);     pool3.approve(address(usdm3crv), addingLiquidity);     usdm3crv.add_liquidity(amounts, _minimumLP); } ```  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90   # Vulnerability details  ## Impact In README.me: > USDM deposits are locked based on the KPI’s from carrot.eth  However, USDM deposits are also locked until guardian remove liquidity because there are no mechanism to remove deposited USDM in `withdraw`  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L216-L259   # Vulnerability details  ## Impact  The `ConvexStakingWrapper.sol` implementation makes several modifications to the original design. One of the key changes is the ability to add multiple pools into the wrapper contract, where each pool is represented by a unique `_pid`. By doing this, we are able to aggregate pools and their LP tokens to simplify the token distribution process.   However, the interdependence between pools introduces new problems. Because the original implementation uses the contract's reward token balance to track newly claimed tokens, it is possible for a malicious user to abuse the unguarded `getReward` function to maximise the profit they are able to generate. By calling `getReward` on multiple pools with the same reward token (i.e. `cvx`), users are able to siphon rewards from other pools. This inevitably leads to certain loss of rewards for users who have deposited LP tokens into these victim pools. As `crv` and `cvx` are reward tokens by default, it is very likely that someone will want to exploit this issue.  ## Proof of Concept  Let's consider the following scenario: - There are two convex pools with `_pid` 0 and 1. - Both pools currently only distribute `cvx` tokens. - Alice deposits LP tokens into the pool with `_pid` 0. - Both pools earn 100 `cvx` tokens which are to be distributed to the holders of the two pools. - While Alice is a sole staker of the pool with `_pid` 0, the pool with `_pid` 1 has several stakers. -  Alice decides she wants to maximise her potential rewards, so she directly calls the unguarded `IRewardStaking(convexPool[_pid]).getReward` function on both pools, resulting in 200 `cvx` tokens being sent to the contract. - She then decides to deposit the 0 amount to execute the `_calcRewardIntegral` function on the pool with `_pid` 0. However, this function will calculate `d_reward` as `bal - reward.remaining` which is effectively the change in contract balance. As we have directly claimed `cvx` tokens over the two pools, this `d_reward` will be equal to 200. - Alice is then entitled to the entire 200 tokens as she is the sole staker of her pool. So instead of receiving 100 tokens, she is able to siphon rewards from other pools.  Altogether, this will lead to the loss of rewards for other stakers as they are unable to then claim their rewards.  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L216-L259 ``` function _calcRewardIntegral(     uint256 _pid,     uint256 _index,     address _account,     uint256 _balance,     uint256 _supply ) internal {     RewardType memory reward = rewards[_pid][_index];      //get difference in balance and remaining rewards     //getReward is unguarded so we use remaining to keep track of how much was actually claimed     uint256 bal = IERC20(reward.token).balanceOf(address(this));     uint256 d_reward = bal - reward.remaining;     // send 20 % of cvx / crv reward to treasury     if (reward.token == cvx || reward.token == crv) {         IERC20(reward.token).transfer(treasury, d_reward / 5);         d_reward = (d_reward * 4) / 5;     }     IERC20(reward.token).transfer(address(claimContract), d_reward);      if (_supply > 0 && d_reward > 0) {         reward.integral =             reward.integral +             uint128((d_reward * 1e20) / _supply);     }      //update user integrals     uint256 userI = userReward[_pid][_index][_account].integral;     if (userI < reward.integral) {         userReward[_pid][_index][_account].integral = reward.integral;         claimContract.pushReward(             _account,             reward.token,             (_balance * (reward.integral - userI)) / 1e20         );     }      //update remaining reward here since balance could have changed if claiming     if (bal != reward.remaining) {         reward.remaining = uint128(bal);     }      rewards[_pid][_index] = reward; } ```  ## Tools Used  Manual code review. Confirmation from Taek.  ## Recommended Mitigation Steps  Consider redesigning this mechanism such that all pools have their `getReward` function called in `_checkpoint`. The `_calcRewardIntegral` function can then ensure that each pool is allocated only a fraction of the total rewards instead of the change in contract balance. Other implementations might be more ideal, so it is important that careful consideration is taken when making these changes.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L121-L130 https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L309-L331   # Vulnerability details  ## Impact  The shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. Conversely, the `exitShelter` function will deactivate the shelter and transfer all LP tokens back to the `ConvexStakingWrapper.sol` contract.  Unfortunately, LP tokens aren't restaked in the pool, causing LP tokens to be stuck within the contract. Users will be unable to withdraw their LP tokens as the `withdraw` function attempts to `withdrawAndUnwrap` LP tokens from the staking pool. As a result, this function will always revert due to insufficient staked balance. If other users decide to deposit their LP tokens, then these tokens can be swiped by users who have had their LP tokens locked in the contract.  This guarantees poor UX for the protocol and will most definitely lead to LP token loss.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L121-L130 ``` function exitShelter(uint256[] calldata _pids) external onlyOwner {     for(uint256 i = 0; i<_pids.length; i++){         IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);         IERC20 lpToken = IERC20(             pool.poolInfo(_pids[i]).lptoken         );         amountInShelter[lpToken] = 0;         shelter.deactivate(lpToken);     } } ```  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L309-L331 ``` function withdraw(uint256 _pid, uint256 _amount)     external     nonReentrant     whenNotInShelter(_pid) {     WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];     require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), "wait");     require(request.amount >= _amount, "too much");     _checkpoint(_pid, msg.sender);     deposits[_pid][msg.sender].amount -= uint192(_amount);     if (_amount > 0) {         IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);         IERC20 lpToken = IERC20(             IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken         );         lpToken.safeTransfer(msg.sender, _amount);         uint256 pid = masterChef.pid(address(lpToken));         masterChef.withdraw(msg.sender, pid, _amount);     }     delete withdrawRequest[_pid][msg.sender];     //events     emit Withdrawn(msg.sender, _amount); } ```  ## Tools Used  Manual code review. Confirmation from Taek.  ## Recommended Mitigation Steps  Consider re-depositing LP tokens upon calling `exitShelter`. This should ensure the same tokens can be reclaimed by users wishing to exit the `ConvexStakingWrapper.sol` contract.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L170-L172   # Vulnerability details  ## Impact  If a pool’s deposit fee is non-zero, it is subtracted from the amount to be credited to the user.  ```jsx if (pool.depositFeeBP > 0) {   uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);   user.amount = SafeCast.toUint128(user.amount + _amount - depositFee); } ```  However, the deposit fee is not credited to anyone, leading to permanent lockups of deposit fees in the relevant depositor contracts (StakingRewards and ConvexStakingWrapper for now).  ## Proof of Concept  ### Example 1: ConvexStakingWrapper  Assume the following  - The [curve cDai / cUSDC / cUSDT LP token](https://etherscan.io/address/0x9fC689CCaDa600B6DF723D9E47D84d76664a1F23) corresponds to `pid = 1` in the convex booster contract. - Pool is added in Masterchef with `depositFeeBP = 100 (10%)`. 1. Alice deposits 1000 LP tokens via the ConvexStakingWrapper contract. A deposit fee of 100 LP tokens is charged. Note that the `deposits` mapping of the ConvexStakingWrapper contract credits 1000 LP tokens to her. 2. However, Alice will only be able to withdraw 900 LP tokens. The 100 LP tokens is not credited to any party, and is therefore locked up permanently (essentially becomes protocol-owned liquidity). While she is able to do `requestWithdraw()` for 1000 LP tokens, attempts to execute `withdraw()` with amount = 1000 will revert because she is only credited 900 LP tokens in the Masterchef contract.  ### Example 2: StakingRewards  - CRV pool is added in Masterchef with `depositFeeBP = 100 (10%)`. 1. Alice deposits 1000 CRV into the StakingRewards contract. A deposit fee of 100 CRV is charged. 2. Alice is only able to withdraw 900 CRV tokens, while the 100 CRV is not credited to any party, and is therefore locked up permanently.  These examples are non-exhaustive as more depositors can be added / removed from the Masterchef contract.  ## Recommended Mitigation Steps  I recommend shifting the deposit fee logic out of the masterchef contract into the depositor contracts themselves, as additional logic would have to be added in the masterchef to update the fee recipient’s state (rewardDebt, send pending concur rewards, update amount), which further complicates matters. As the fee recipient is likely to be the treasury, it is also not desirable for it to accrue concur rewards.  ```jsx if (pool.depositFeeBP > 0) {   uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);   user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);   UserInfo storage feeRecipient = userInfo[_pid][feeRecipient];   // TODO: update and send feeRecipient pending concur rewards   feeRecipient.amount = SafeCast.toUint128(feeRecipient.amount + depositFee);   // TODO: update fee recipient's rewardDebt } ```  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L256   # Vulnerability details  ``` ConcurRewardPool.constructor(address)._notifier (contracts/ConcurRewardPool.sol#15) lacks a zero-check on :   - rewardNotifier = _notifier (contracts/ConcurRewardPool.sol#16) ConvexStakingWrapper.constructor(address,MasterChef)._treasury (contracts/ConvexStakingWrapper.sol#69) lacks a zero-check on :   - treasury = _treasury (contracts/ConvexStakingWrapper.sol#70) ConvexStakingWrapper.changeTreasury(address)._treasury (contracts/ConvexStakingWrapper.sol#82) lacks a zero-check on :   - treasury = _treasury (contracts/ConvexStakingWrapper.sol#83) StakingRewards.constructor(address,address,address,MasterChef)._rewardsDistribution (contracts/StakingRewards.sol#38) lacks a zero-check on :   - rewardsDistribution = _rewardsDistribution (contracts/StakingRewards.sol#45) StakingRewards.setRewardsDistribution(address)._rewardsDistribution (contracts/StakingRewards.sol#187) lacks a zero-check on :   - rewardsDistribution = _rewardsDistribution (contracts/StakingRewards.sol#195) USDMPegRecovery.constructor(uint256,address)._kpiOracle (contracts/USDMPegRecovery.sol#50) lacks a zero-check on :   - kpiOracle = _kpiOracle (contracts/USDMPegRecovery.sol#57) VoteProxy.execute(address,uint256,bytes)._to (contracts/VoteProxy.sol#29) lacks a zero-check on :   - (success,result) = _to.call{value: _value}(_data) (contracts/VoteProxy.sol#33) ```  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/StakingRewards.sol   # Vulnerability details  ## Impact  Staking tokens are used to deposit into the `StakingRewards.sol` and `ConvexStakingWrapper.sol` contracts. Once deposited, the user is entitled to Concur rewards in proportion to their staked balance and the underlying pool's `allocPoint` in the `MasterChef.sol` contract.  The `Shelter.sol` mechanism allows the owner of the `ConvexStakingWrapper.sol` to react to emergency events and protect depositor's assets. The staking tokens can be withdrawn after the grace period has passed. However, these staking tokens can be deposited into the `StakingRewards.sol` contract to continue receiving Concur rewards not only for `StakingRewards.sol` but also for their `ConvexStakingWrapper.sol` deposited balance which has not been wiped. As a result, users are able to effectively claim double the amount of Concur rewards they should be receiving.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/StakingRewards.sol  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Ensure that staking tokens cannot be deposited in both the `StakingRewards.sol` and `ConvexStakingWrapper.sol` contracts. If this is intended behaviour, it may be worthwhile to ensure that the sheltered users have their deposited balance wiped from the `MasterChef.sol` contract upon being sheltered.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol   # Vulnerability details  ## Impact  The shelter mechanism aims to protect the protocol's users by draining funds into a separate contract in the event of an emergency. However, while users are able to reclaim their funds through the `Shelter.sol` contract, they will still have a deposited balance from the perspective of `ConvexStakingWrapper.sol`.  However, if the shelter mechanism is enacted before users are able to claim their Concur rewards, any accrued tokens will be lost and the `MasterChef.sol` contract will continue to allocate tokens to the sheltered pool which will be forever locked within this contract.  There is currently no way to remove sheltered pools from the `MasterChef.sol` contract, hence any balance lost in the contract cannot be recovered due to a lack of a sweep mechanism which can be called by the contract owner.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing sheltered pools from the `MasterChef.sol` Concur token distribution. It is important to ensure `massUpdatePools` is called before making any changes to the list of pools. Additionally, removing pools from this list may also create issues with how `_pid` is produced on each new pool. Therefore, it may be worthwhile to rethink this mechanism such that `_pid` tracks some counter variable and not `poolInfo.length - 1`.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol   # Vulnerability details  ## Impact  The shelter mechanism aims to protect the protocol's users by draining funds into a separate contract in the event of an emergency. However, while users are able to reclaim their funds through the `Shelter.sol` contract, they will still have a deposited balance from the perspective of `ConvexStakingWrapper.sol`.  Because users will only receive their rewards upon depositing/withdrawing their funds due to how the checkpointing mechanism works, it is likely that by draining funds to the `Shelter.sol` contract, users will lose out on any rewards they had accrued up and until that point. These rewards are unrecoverable and can potentially be locked within the contract if the reward token is unique and only belongs to the sheltered `_pid`.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider allowing users to call a public facing `_checkpoint` function once their funds have been drained to the `Shelter.sol` contract. This should ensure they receive their fair share of rewards. Careful consideration needs to be made when designing this mechanism, as by giving users full control of the `_checkpoint` function may allow them to continue receiving rewards after they have withdrawn their LP tokens.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L107-L119 https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L132-L135   # Vulnerability details  ## Impact  The shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. If this function is called again on the same LP token, the `amountInShelter` value is overwritten, potentially by the zero amount. As a result  its possible that the shelter is put in a state where no users can withdraw from it or only a select few users with a finite number of shares are able to. Once the shelter has passed its grace period, these tokens may forever be locked in the shelter contract.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L107-L119 ``` function enterShelter(uint256[] calldata _pids) external onlyOwner {     for(uint256 i = 0; i<_pids.length; i++){         IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);         uint256 amount = pool.balanceOf(address(this));         pool.withdrawAndUnwrap(amount, false);         IERC20 lpToken = IERC20(             pool.poolInfo(_pids[i]).lptoken         );         amountInShelter[lpToken] = amount;         lpToken.safeTransfer(address(shelter), amount);         shelter.activate(lpToken);     } } ```  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L132-L135 ``` function totalShare(IERC20 _token) external view override returns(uint256) {     // this will be zero if shelter is not activated     return amountInShelter[_token]; } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding to the `amountInShelter[lpToken]` mapping instead of overwriting it altogether. This will allow `enterShelter` to be called multiple times with no loss of funds for the protocol's users.  
# Lines of code   https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L55   # Vulnerability details  # Impact  Any user can withdraw all the funds from the shelter. This is done by calling withdraw repeatedly until all funds are drained. You only need to have a small share.  Even if the `claimed` mapping was checked, there would still be a vulnerability. This is because the `claimed` mapping is updated with the `_to` address, not the `msg.sender` address.  Remediation is to change the `_to` to `msg.sender`. https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L55   
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L73-L82   # Vulnerability details  ## Impact  The `provide` function does not take a `_steps` argument and will instead calculate `addingLiquidity` by truncating amounts under `step`. As a result, if there is an excess of `usdm` such that the truncated amount exceeds the contract's `pool3` truncated balance, then the function will revert due to insufficient `pool3` collateral.  This will prevent guardians from effectively providing liquidity whenever tokens are available. Consider the following example: - The contract has `500000e18` `usdm` tokens and `250000e18` `pool3` tokens. - `addingLiquidity` will be calculated as `500000e18 / 250000e18 * 250000e18`. - The function will attempt to add `500000e18` `usdm` and `pool3` tokens in which there are insufficient `pool3` tokens in the contract. As a result, it will revert even though there is an abundance of tokens that satisfy the `step` amount.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L73-L82 ``` function provide(uint256 _minimumLP) external onlyGuardian {     require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, "<liquidity");     // truncate amounts under step     uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;     // match usdm : pool3 = 1 : 1     uint256[2] memory amounts = [addingLiquidity, addingLiquidity];     usdm.approve(address(usdm3crv), addingLiquidity);     pool3.approve(address(usdm3crv), addingLiquidity);     usdm3crv.add_liquidity(amounts, _minimumLP); } ```  ## Tools Used  Manual code review. Discussions with Taek.  ## Recommended Mitigation Steps  Consider modifying the `provide` function such that a `_steps` argument can be supplied. This will allow guardians to maximise the amount of liquidity provided to the Curve pool.  
# Non critical  ## Lack of events  The method [ConcurRewardPool.pushReward](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L23) should emit an event in order to be detectable by the `_recipient`.  ## Non exploitable reentrancy  The method [ConcurRewardPool.claimRewards](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L34-L37) allow the reentrancy, it seems that it's not vulnerable but it should be protected in order to be resilient.  # Low  ## Contract management risks  The following contracts are `Ownable` and `Pausable`, so the owner could resign while the contract is paused, causing a Denial of Service. Owner resignation while paused should be avoided: - [ConvexStakingWrapper](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L14) - [StakingRewards](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L12)  ## contracts\ConvexStakingWrapper.sol  1. It was found some `transfer`, `approve` or `transferFrom` without checking the boolean result, ERC20 standard specify that the token can return false if this call was not made, so it's mandatory to check the result of these methods.  As following you can see the affected locations: - [ConvexStakingWrapper.sol#L179](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L179) - [ConvexStakingWrapper.sol#L182](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L182)  2. There are a lack of checks in the method [requestWithdraw](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L287) that allow to create a request for `_amount=0` it should be denied in order to avoid possible errors. 
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L73 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L84   # Vulnerability details  ## Impact In `USDMPegRecovery` `deposit` and `withdraw` allow for direct deposits of a specific token (3crv or usdm)  The balances are directly changed and tracked in storage.  `provide` seems to be using the real balances (not the ones store) to provide liquidity. Because of how curve works, you'll be able (first deposit) to provide exactly matching liquidity.  But after (even just 1 or) multiple swaps, the pool will be slightly imbalanced, adding or removing liquidity at that point will drastically change the balances in the contract from the ones tracked in storage.  Eventually users won't be able to withdraw the exact amounts they deposited.  This will culminate with real balances not matching user deposits, sometimes to user advantage and other times to user disadvantage, ultimately to the protocol dismay.    ## Proof of Concept Deposit equal usdm and 3crv LP Do one trade on CRV Withdraw the LP  The real balances are not matching the balances in storage  User tries to withdraw all their balances, inevitable revert  ## Recommended Mitigation Steps Either find a way to price the user contribution based on the LP tokens (use virtual_price) Or simply have people deposit the LP token directly (avoiding the IL math which is a massive headache)  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L166   # Vulnerability details  ## Impact `StakingRewards.recoverERC20` rightfully checks against the `stakingToken` being sweeped away. However there's no check against the `rewardsToken` which over time will sit in this contract.  This is the case of an admin privilege, which allows the owner to sweep the rewards tokens, perhaps as a way to rug depositors  ## Proof of Concept calling `StakingRewards.recoverERC20(rewardsToken, rewardsToken.balanceOf(this))` enables the `owner` to sweep the token  ## Recommended Mitigation Steps Add an additional check ```         require(             tokenAddress != address(rewardsToken),             "Cannot withdraw the rewards token"         ); ```  
# Report  * [cache values from external function calls](#cache-values-from-external-function-calls) * [remove unnecessary `safeApprove()`](#remove-unnecessary-safeapprove) * [use constant state variables wherever you can](#use-constant-state-variables-wherever-you-can) * [use immutable state variables wherever you can](#use-immutable-state-variables-wherever-you-can)  ## cache values from external function calls  Instead of calling the same function twice, cache the return value and use that.  Example:   - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L131  Replace the call with `extraToken` which was cached here: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L123  ## remove unnecessary `safeApprove()`  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L242-L244  The second `safeApprove()` call can be removed. After the `deposit()` the `convexBooster`'s allowance should be `0` already.  ## use constant state variables wherever you can  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L56-L57 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L50  ## use immutable state variables wherever you can  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L19-L20 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L22-L24
# Report    * [Non-Critical](#non-critical)     * [emit events for address or important state changes](#emit-events-for-address-or-important-state-changes)     * [don't convert to a smaller bit uint without verifying its value](#dont-convert-to-a-smaller-bit-uint-without-verifying-its-value)   * [Low](#low)     * [use SafeERC20 or check return value of ERC20 functions](#use-safeerc20-or-check-return-value-of-erc20-functions)     * [Shelter donations result in wrong internal balance if fee-on-transfer token is used](#shelter-donations-result-in-wrong-internal-balance-if-fee-on-transfer-token-is-used)     * [Shelter can delay the user's ability to withdraw their funds indefinitely](#shelter-can-delay-the-users-ability-to-withdraw-their-funds-indefinitely)      ## Non-Critical  ### emit events for address or important state changes  Stuff like a guardian being added to the contract or the treasury address being changed. All of that should be accompanied by an event.  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L60-L66 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L83  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L87 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L70  ### don't convert to a smaller bit uint without verifying its value  When converting to a smaller bit uint it might result in a smaller number if the value is higher than the maximum value of that uint type. Before converting it check whether the passed value is small enough.  ```sol require(x <= type(uint192).max); uint192 y = uint192(x); ```  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L235  It shouldn't really be an issue here tho and since I don't expect anybody to have more than `2 ** 196 - 1` tokens to abuse this.  ## Low  ### use SafeERC20 or check return value of ERC20 functions  Some tokens don't revert if a transfer fails. Instead they just return `false`. Since the `ConvexStakingWrapper` contract [potentially works with arbitrary ERC20 tokens](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L129-L136) it's recommended to use SafeERC20 when working with it. Or at least check the return values:  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L179 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L182   ### Shelter donations result in wrong internal balance if fee-on-transfer token is used  In case of a fee-on-transfer ERC20 token the `savedTokens` balance will not represent the actual balance of the contract:  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L34-L35  You can either disable the use of fee-on-transfer tokens for donations or use the actual balance:  ```sol // disable uint oldBalance = _token.balanceOf(address(this)); _token.safeTransferFrom(msg.sender, address(this), _amount); uint newBalance = _token.balanceOf(address(this)); require(_amount == (newBalance - oldBalance)); savedTokens[_token] += _amount; ```  ```sol // use actual balance _token.safeTransferFrom(msg.sender, address(this), _amount); savedTokens[_token] = _token.balanceOf(address(this)); ```  ### Shelter can delay the user's ability to withdraw their funds indefinitely  By repedeatly calling the `activate()` function for a specific token they can extend the timestamp at which withdrawal by users is enabled.  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L39 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L53  With each call `activated[_token]` is reset to `block.timestamp`. Thus the require statement in `withdraw()` will fail for another week. There's nothing stopping the client from calling the function multiple times to keep delaying the withdrawal.  Fix it by not allowing already activated tokens to be reactivated. But with the current implementation of the contract, the client could deactivate and reactivate it.  ```sol function activate(IERC20 _token) external override onlyClient {     require(!activated[_token]);     activated[_token] = block.timestamp;     savedTokens[_token] = _token.balanceOf(address(this));     emit ShelterActivated(_token); } ``` 
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description In the codebase for the protocol **concur**, There was many places where code do suffer from non-critical findings. Following security best practices can help in mitigating these issues.  # Impact code quality.  ## Proof of Concept  ### Unchecked ERC20 operations https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L179 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L182 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L79 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L80  ### floating pragma compiler version on contracts https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/EasySign.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L4 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/VoteProxy.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/interfaces/Iauction.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/interfaces/IShelterClient.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/interfaces/IShelter.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/interfaces/IConcurRewardClaim.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/external/ConvexInterfaces.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/external/CurveInterfaces.sol#L3  ### Unused event or missed emit https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L19  ### Hardcoded addresses for external protocols https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L29 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L31 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L33 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L53-L55 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/library/CvxMining.sol#L8  ### Public visibility functions https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L93 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L127  ### Missing parameter validation https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L82 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L86  ## Tools Used c4udit and manual review.  ## Recommended Mitigation Steps - check for ERC20 operation functions return value or wrap it inside require(). - restrict pragma for compiler version unless it's a library. - each declared event should have a corresponding emit statement or remove it from the codebase.  - consider passing value of external protocol addresses instead for hardcoding them since blockchains differ.  - set functions visibility to external if not used inside the same contract file. - missing input validations can lead to contract redeployment or wasted gas.   
# Handle  kenta   # Vulnerability details  ## Impact The default value of uint256 is 0 and we do not initialize it and save a little bit of gas.   ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L121  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L219  ## Tools Used  ## Recommended Mitigation Steps for (unit256 i; i < length; i++) {}  
# Handle  robee   # Vulnerability details  Title: Unnecessary equals boolean Severity: GAS   Boolean variables can be checked within conditionals directly without the use of equality operators to true/false.          VoteProxy.sol, 21: if (auctioneer.isWinningSignature(_hash, _signature) == true) {    Title: State variables that could be set immutable Severity: GAS  In the following files there are state variables that could be set immutable to save gas.           startBlock in MasterChef.sol         client in Shelter.sol         masterChef in ConvexStakingWrapper.sol         endBlock in MasterChef.sol         rewardNotifier in ConcurRewardPool.sol         concur in MasterChef.sol    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           ConcurRewardPool.sol, _tokens, 35    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           just change to unchecked: MasterChef.sol, _pid, 129         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 219         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 121         change to prefix increment and unchecked: ConcurRewardPool.sol, i, 35    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          ConcurRewardPool.sol, 35         ConvexStakingWrapper.sol, 219         MasterChef.sol, 129         ConvexStakingWrapper.sol, 121    Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          EasySign.sol, tryRecover         ConvexStakingWrapper.sol, _calcRewardIntegral         ConvexStakingWrapper.sol, _checkpoint         ConvexStakingWrapper.sol, _getDepositedBalance         ConvexStakingWrapper.sol, _getTotalSupply         EasySign.sol, recover    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           MasterChef.sol, massUpdatePools         MasterChef.sol, add         ConvexStakingWrapper.sol, addRewards    Title: Unnecessary default assignment Severity: GAS   Unnecessary default assignments, you can just declare and it will save gas and have the same meaning.               StakingRewards.sol (L#22) : uint256 public rewardRate = 0;         ConvexStakingWrapper.sol (L#36) : uint256 public constant CRV_INDEX = 0;         MasterChef.sol (L#51) : uint public totalAllocPoint = 0;         StakingRewards.sol (L#21) : uint256 public periodFinish = 0;    Title: Rearrange state variables Severity: GAS  You can change the order of the storage variables to decrease memory uses.  In USDMPegRecovery.sol,rearranging the storage fields can optimize to: 7 slots from: 8 slots. The new order of types (you choose the actual variables):         1. IERC20         2. IERC20         3. ICurveMetaPool         4. uint256         5. uint256         6. Liquidity         7. address         8. bool     Title: Short the following require messages Severity: GAS  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: StakingRewards.sol, In line 170, Require message length to shorten: 33, The message: Cannot withdraw the staking token         Solidity file: MasterChef.sol, In line 210, Require message length to shorten: 35, The message: safeConcurTransfer: transfer failed    Title: Unused imports Severity: GAS   In the following files there are contract imports that aren't used Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore)          ConvexStakingWrapper.sol, line 9, import "./external/ConvexInterfaces.sol";         USDMPegRecovery.sol, line 7, import { ICurveMetaPool } from "./external/CurveInterfaces.sol";    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           MasterChef.sol, 169: change '_amount > 0' to '_amount != 0'         ConvexStakingWrapper.sol, 262: change '_amount > 0' to '_amount != 0'         MasterChef.sol, 194: change '_amount > 0' to '_amount != 0'         USDMPegRecovery.sol, 74: change 'balance > 0' to 'balance != 0'         ConvexStakingWrapper.sol, 236: change '_amount > 0' to '_amount != 0'         StakingRewards.sol, 94: change 'amount > 0' to 'amount != 0'         StakingRewards.sol, 108: change 'amount > 0' to 'amount != 0'         ConvexStakingWrapper.sol, 184: change '_supply > 0' to '_supply != 0'    Title: Use unchecked to save gas for certain additive calculations that cannot overflow Severity: GAS   You can use unchecked in the following calculations since there is no risk to overflow:          StakingRewards.sol (L#161) - periodFinish = block.timestamp + rewardsDuration;         Shelter.sol (L#53) - require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, "shelter not activated");         ConvexStakingWrapper.sol (L#279) - return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;         Shelter.sol (L#45) - require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, "too late");    Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               EasySign.isWinningSignature (_signature)    Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               ConvexStakingWrapper.sol, _getDepositedBalance, { return deposits[_pid][_account].amount; }         ConvexStakingWrapper.sol, _getTotalSupply, { return IRewardStaking(convexPool[_pid]).balanceOf(address(this)); }    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               ConvexStakingWrapper.sol, _calcRewardIntegral         ConvexStakingWrapper.sol, _getDepositedBalance         ConvexStakingWrapper.sol, _getTotalSupply    Title: Check if amount is not zero to save gas Severity: GAS  The following functions could skip other steps if the amount is 0. (A similar issue: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82)           StakingRewards.sol, recoverERC20    
# Handle  0x510c   # Vulnerability details  ## Impact The function definition of "add" is marked "public". However, it is never directly called by another function in the same contract or in any of its descendants. Consider to mark it as "external" instead.  ## Proof of Concept  MasterChef.sol  function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {         require(_token != address(0), "zero address");         uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;         totalAllocPoint = totalAllocPoint.add(_allocationPoints);         require(pid[_token] == 0, "already registered"); // pid starts from 0         poolInfo.push(             PoolInfo({                 depositToken: IERC20(_token),                 allocPoint: _allocationPoints,                 lastRewardBlock: lastRewardBlock,                 accConcurPerShare: 0,                 depositFeeBP: _depositFee             })         );         pid[_token] = poolInfo.length - 1;     }  ## Tools Used Manual Review  ## Recommended Mitigation Steps It recommended to change the visibility of the function to External to optimize the usage of gas.  
# Handle  wuwe1   # Vulnerability details  # Cache array length in for loops can save gas  ## POC > Caching the array length in the stack saves around 3 gas per iteration.  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L35  ```solidity function claimRewards(address[] calldata _tokens) external override {     for (uint256 i = 0; i < _tokens.length; i++) {         uint256 getting = reward[msg.sender][_tokens[i]];         IERC20(_tokens[i]).safeTransfer(msg.sender, getting);         reward[msg.sender][_tokens[i]] = 0;     } } ```  # Dead code  Remove dead code in  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L19  # public to external  These function can be external.  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L93  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L127  # state can be constant  These state variables can be constant  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L50  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L56  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L57  
# Handle  wuwe1   # Vulnerability details  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L94-L99  ```solidity         address mainPool = IRewardStaking(convexBooster)             .poolInfo(_pid)             .crvRewards;         if (rewards[_pid].length == 0) {             pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;             convexPool[_pid] = mainPool; ```  `convexPool[_pid]` is set to `IRewardStaking(convexBooster).poolInfo(_pid).crvRewards;`  `crvRewards` is a `BaseRewardPool` like this one https://etherscan.io/address/0x8B55351ea358e5Eda371575B031ee24F462d503e#code.  `BaseRewardPool` does not implement `poolInfo`   https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L238  ```solidity IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken ```  Above line calls `poolInfo` of  `crvRewards` which causes revert.  ## Recommended Mitigation Steps  According to Booster's code   https://etherscan.io/address/0xF403C135812408BFbE8713b5A23a04b3D48AAE31#code  ```solidity     //deposit lp tokens and stake     function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){         require(!isShutdown,"shutdown");         PoolInfo storage pool = poolInfo[_pid];         require(pool.shutdown == false, "pool is closed");          //send to proxy to stake         address lptoken = pool.lptoken;         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount); ```  `convexBooster` requires `poolInfo[_pid].lptoken`.  change L238 to   ```solidity IRewardStaking(convexBooster).poolInfo(_pid).lptoken ```  
# Handle  csanuragjain   # Vulnerability details  ## Impact onlyClient can deactivate a token even after deadline is passed and transfer all token balance to itself  ## Proof of Concept 1. Navigate to contract at https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol  2. Observe that token can only be deactivated if activated[_token] + GRACE_PERIOD > block.timestamp. We will bypass this  3. onlyClient activates a token X using the activate function  4. Assume Grace period is crossed such that activated[_token] + GRACE_PERIOD < block.timestamp  5. Now if onlyClient calls deactivate function, it fails with "too late"  6. But onlyClient can bypass this by calling activate function again on token X which will reset the timestamp to latest in activated[_token] and hence onlyClient can now call deactivate function to disable the token and retrieve all funds present in the contract to his own address  ## Recommended Mitigation Steps Add below condition to activate function  ``` function activate(IERC20 _token) external override onlyClient { require(activated[_token]==0, "Already activated");         activated[_token] = block.timestamp;         savedTokens[_token] = _token.balanceOf(address(this));         emit ShelterActivated(_token);     } ```  
# Handle  csanuragjain   # Vulnerability details  ## Low findings  ****  1.  Incorrect Condition Finding:   Contract - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol  In deactivate function, deactivation is rejected even if activated[_token] + GRACE_PERIOD = block.timestamp even when it should be allowed till Grace period.   Remediation: This should be corrected by changing require condition to below:  ``` require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD >= block.timestamp, "too late"); ```  2. Zero Address check missing   Contract - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol  In withdraw function, Zero address checks can be added for **to** address which can prevent losses  Remediation:  ``` require(to!=address(0), "Incorrect address"); ```  3. User fund stuck  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol  In withdraw function, Funds will stuck if user deposited a amount and then isDepositor[_depositor] is set to false by Admin. Now user cannot withdraw the amount since onlyDepositor will fail  Remediation: Withdraw should be independent of onlyDepositor  4. Incorrect PID updation  Contract : https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol  In massUpdatePools function, pid 0 should not be updated as poolInfo[_pid] is filled by dummy zero address token in constructor  ``` constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {         startBlock = _startBlock;         endBlock = _endBlock;         concur = _concur;         poolInfo.push(             PoolInfo({             depositToken: IERC20(address(0)),             allocPoint : 0,             lastRewardBlock : _startBlock,             accConcurPerShare : 0,             depositFeeBP : 0         }));     } ```  Remediation: The loop in massUpdatePools function should start with value 1 instead of 0  5. Insecure transfer method used  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol  In safeConcurTransfer function, transfer function is used  Remediation: use safeTransfer instead of transfer which is more secure  6. User funds can be added to 0 or non-existent pid with 0 rewards  Contract : https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol  a. In deposit & withdraw function, both accepts 0 pid which is zero address pool added by constructor, which means user funds would get added to incorrect pool.   b. Similarly non existent pid will also be accepted by both of these functions.   c. Offcourse these incorrect pid will not incur any reward since pool.accConcurPerShare will always be 0 which means user amount is added to a pool without any reward  Remediation: Add a check to see if pid>0 and pid<poolInfo.length  7. Extra reward will be given to users  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol  In notifyRewardAmount function, Since block.timestamp value will change slightly while calculating periodFinish (when compared to lastUpdateTime) so periodFinish will actually become lastUpdateTime+rewardsDuration+x which is incorrect and would impact rewardPerToken by making it slightly higher  ``` lastUpdateTime = block.timestamp;         periodFinish = block.timestamp + rewardsDuration; ```  Remediation: Store block.timestamp locally and then use local variable to update periodFinish and lastUpdateTime  8. Missing condition:  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol  In addRewards function, it is not checked if extraToken is crv. Only cvx check is present  Remediation: Add below check  ``` if (extraToken == crv) {rewards[_pid][CRV_INDEX].pool = extraPool;} ```  9. rewards entries are made even for incorrect/non-existent pid  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol  Non existent pid will create crv and cvx entries for rewards[_pid] since rewards[_pid].length == 0  Remediation: Revert if mainPool is zero address, require (mainPool!=address(0));  ## Non critical findings  10. Missing events  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol  In claimRewards function observe that No emit event is fired after successful reward claim by user. Ideally a new event should be triggered showing that reward was claimed successfully by user  11. Reward lost  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol  In notifyRewardAmount function, if Admin added a reward 100 once block.timestamp >= periodFinish. Now if Admin decides to add 200 rewards calling this function at block.timestamp >= periodFinish then contract considers total reward as 200 and discards the reward 100 added initially  ``` if (block.timestamp >= periodFinish) {             rewardRate = reward / rewardsDuration; // old reward is not considered         } ```  
# Handle  wuwe1   # Vulnerability details  ## Impact `execute` will revert when `msg.value > 0`  ## Proof of Concept Lacking `payable` mutability specifier.  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/VoteProxy.sol#L28-L35  ```solidity     function execute(         address _to,         uint256 _value,         bytes calldata _data     ) external onlyOwner returns (bool, bytes memory) {         (bool success, bytes memory result) = _to.call{value: _value}(_data);         return (success, result);     } ```   ## Recommended Mitigation Steps  Add `payable` mutability specifier.  
# Handle  Heartless   # Vulnerability details  ## Impact external visibility uses less gas than public visibility. addRewards is never called internally in this project so does not need public visibility. addRewards was public in the original source from convex because they called addRewards() internally in the initialize() function, which ConvexStakingWrapper does not have.  ## Proof of Concept Line 93 in ConvexStakingWrapper.sol  ## Tools Used  ## Recommended Mitigation Steps Change addRewards visibility to external.  
1) Use != instead of > for uint256 in StakingReward.sol:   Both amount and reward are of type uin256 comparing, checking for inequality instead of a greater than relation saves gas. The comparisons can be found in the lines below  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L94  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L119  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L119  Cache length before for loop ConcurRewardPool.sol:  2) The length can be cached before the loop avoid calling length many times to save gas.  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L35  3) Assignment to default value   In L51 uint totalAllocPoint is being declared with the default value of 0. Just totalAllocPoint; will save gas. The same thing can also be observed in StakingRewards.sol L21 and L22. Also in ConvexStakingWrapper.sol L36  Similarly bool transferSuccess is also being assigned False in L204  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L51  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L204  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L21  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L22  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L36  4) Resturcture if-else statement to remove else in StakingRewards.sol L142:  if (block.timestamp >= periodFinish) {             rewardRate = reward / rewardsDuration;         } else {             uint256 remaining = periodFinish - block.timestamp;             uint256 leftover = remaining * rewardRate;             rewardRate = (reward + leftover) / rewardsDuration;         }  can be reformulated as:  rewardRate = reward / rewardsDuration; if (block.timestamp < periodFinish) {             uint256 remaining = periodFinish - block.timestamp;             uint256 leftover = remaining * rewardRate;             rewardRate += (leftover / rewardsDuration);         }   https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L142   5) use unchecked{...} to save gas  uint256 is way too big to realistically lead to overflows, unchecked can be used to save gas in the following situations.   https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L121  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L219  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L34        
# QA Report **Table of Contents:**  - [QA Report](#qa-report)   - [Transfers](#transfers)     - [Prevent accidentally burning tokens](#prevent-accidentally-burning-tokens)     - [Use safeTransfer or require()/conditional instead of transfer/transferFrom](#use-safetransfer-or-requireconditional-instead-of-transfertransferfrom)     - [Use SafeERC20.safeApprove()](#use-safeerc20safeapprove)   - [Libraries](#libraries)     - [Deprecated library used for Solidity 0.8.11: SafeMath](#deprecated-library-used-for-solidity-0811-safemath)   - [Variables](#variables)     - [Missing Address(0) checks](#missing-address0-checks)     - [Variables that should be constant](#variables-that-should-be-constant)     - [Variables that are assumed to be initialized before a function call, but might not be](#variables-that-are-assumed-to-be-initialized-before-a-function-call-but-might-not-be)     - [Variables that should be bounded](#variables-that-should-be-bounded)     - [Variables that should be grouped together in a struct](#variables-that-should-be-grouped-together-in-a-struct)       - [File: ConvexStakingWrapper.sol](#file-convexstakingwrappersol)       - [File: Shelter.sol](#file-sheltersol)   - [Functions](#functions)     - [Functions that should be declared external](#functions-that-should-be-declared-external)   - [Arithmetics](#arithmetics)     - [Possible division by 0](#possible-division-by-0)  ## Transfers ### Prevent accidentally burning tokens  Transferring tokens to the zero address is usually prohibited to accidentally avoid "burning" tokens by sending them to an unrecoverable zero address.  Places where I couldn't find a zero address check (or where the destination isn't a zero-checked address): ``` ConvexStakingWrapper.sol:179:            IERC20(reward.token).transfer(treasury, d_reward / 5); //@audit treasury isn't address(0) checked ConvexStakingWrapper.sol:182:        IERC20(reward.token).transfer(address(claimContract), d_reward);//@audit claimContract isn't address(0) checked MasterChef.sol:206:            transferSuccess = concur.transfer(_to, concurBalance);//@audit _to == _recipient and isn't address(0) checked MasterChef.sol:208:            transferSuccess = concur.transfer(_to, _amount); //@audit _to == _recipient and isn't address(0) checked ```   I suggest adding a check to prevent accidentally burning tokens.  ### Use safeTransfer or require()/conditional instead of transfer/transferFrom  Silent failures (lack of failure detection / revert in case of failure) may happen here: ``` File: ConvexStakingWrapper.sol 178:         if (reward.token == cvx || reward.token == crv) { 179:             IERC20(reward.token).transfer(treasury, d_reward / 5); //@audit return value ignored 180:             d_reward = (d_reward * 4) / 5; 181:         } 182:         IERC20(reward.token).transfer(address(claimContract), d_reward);//@audit return value ignored ``` Consider using safeTransfer. That's already the case at other places on the same contract  ### Use SafeERC20.safeApprove() `approve()` will fail for certain token implementations that do not return a boolean value. It is recommended to use OpenZeppelin's SafeERC20's safeApprove().  Instances include: ``` USDMPegRecovery.sol:79:        usdm.approve(address(usdm3crv), addingLiquidity); USDMPegRecovery.sol:80:        pool3.approve(address(usdm3crv), addingLiquidity); ```  ## Libraries  ### Deprecated library used for Solidity 0.8.11: SafeMath Use Solidity 0.8.*'s default checks instead:  ``` MasterChef.sol:10:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; MasterChef.sol:14:    using SafeMath for uint; ```  ## Variables  ### Missing Address(0) checks ```   - rewardNotifier = _notifier (contracts/ConcurRewardPool.sol#16)   - treasury = _treasury (contracts/ConvexStakingWrapper.sol#70)   - treasury = _treasury (contracts/ConvexStakingWrapper.sol#83)   - rewardsDistribution = _rewardsDistribution (contracts/StakingRewards.sol#45)   - rewardsDistribution = _rewardsDistribution (contracts/StakingRewards.sol#195)   - kpiOracle = _kpiOracle (contracts/USDMPegRecovery.sol#57)   - (success,result) = _to.call{value: _value}(_data) (contracts/VoteProxy.sol#33) ```  ### Variables that should be constant ``` MasterChef._concurShareMultiplier (contracts/MasterChef.sol#56) MasterChef._perMille (contracts/MasterChef.sol#57) MasterChef.concurPerBlock (contracts/MasterChef.sol#50) ```  ### Variables that are assumed to be initialized before a function call, but might not be ``` File: ConvexStakingWrapper.sol 50:     IConcurRewardClaim public claimContract; ... 86:     function setRewardPool(address _claimContract) external onlyOwner { 87:         claimContract = IConcurRewardClaim(_claimContract); 88:     } ``` ### Variables that should be bounded  The variable `MasterChef.sol:43: uint16 depositFeeBP;  // Deposit fee in basis points` is never bounded, and UInt16.MaxValue is 65535  ### Variables that should be grouped together in a struct  For maps that use the same key value: having separate fields is error prone (like in case of deletion or future new fields).  #### File: ConvexStakingWrapper.sol  6 maps can be grouped together, as they use the same `pid`: ``` 41:     //convex rewards 42:     mapping(uint256 => address) public convexPool; 43:     mapping(uint256 => RewardType[]) public rewards; 44:     mapping(uint256 => mapping(uint256 => mapping(address => Reward))) 45:         public userReward; 46:     mapping(uint256 => mapping(address => uint256)) public registeredRewards; ... 63:     mapping(uint256 => mapping(address => Deposit)) public deposits; 64:     mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest; ``` I'd suggest these 3 related data get grouped in a struct, let's name it `RewardInfo`:   ``` struct RewardInfo {     address convexPool;     RewardType[] rewards;     mapping(uint256 => mapping(address => Reward)) userReward;     mapping(address => uint256) registeredRewards;     mapping(address => Deposit) deposits;     mapping(address => WithdrawRequest) withdrawRequest;   }   ``` And it would be used as a state variable in this manner (where `uint256` is `pid`):   ```   mapping(uint256 => RewardInfo) rewardInfo;   ```    #### File: Shelter.sol 3 maps can be grouped together, as they use the same `_token`: ```   17:     mapping(IERC20 => mapping(address => bool)) public override claimed; 18:  19:     mapping(IERC20 => uint256) public activated; 20:  21:     mapping(IERC20 => uint256) public savedTokens; ``` I'd suggest these 3 related data get grouped in a struct, let's name it `TokenInfo`:   ``` struct TokenInfo {     mapping(address => bool) claimed;     uint256 activated;     uint256 savedTokens;   }   ``` And it would be used as a state variable in this manner (where `IERC20` is `_token`):   ```   mapping(IERC20 => TokenInfo) tokenInfo;   ```    ## Functions  ### Functions that should be declared external ```  - ConvexStakingWrapper.addRewards(uint256) (contracts/ConvexStakingWrapper.sol#93-140)  - MasterChef.add(address,uint256,uint16,uint256) (contracts/MasterChef.sol#86-101)  - MasterChef.massUpdatePools() (contracts/MasterChef.sol#127-132) ```  ## Arithmetics  ### Possible division by 0 There are no checks that the denominator is `!= 0` at thoses lines: ``` library\CvxMining.sol:16:        uint256 cliff = supply / reductionPerCliff; MasterChef.sol:120:            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint); MasterChef.sol:121:            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply)); MasterChef.sol:151:        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint); MasterChef.sol:152:        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply)); Shelter.sol:54:        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token); ```
## Do not recalculate constant results  Since results are constant, the code should not calculate them over and over again.  [https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L116-L117](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L116-L117)  ```  registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1 registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1  ```  ## `StakingRewards.sol` cache variables to save gas  By caching variables, loads from storage can be avoided to save gas.  ```  rewardPerToken() — rewardPerTokenStored  notifyRewardAmount() — rewardsDuration, periodFinish  updateReward() — rewardPerTokenStored (cache the new value)  ```  ## `USDMPegRecovery.sol` cache variables to save gas  By caching variables, loads from storage can be avoided to save gas.  ```  provide() -- step, usdm3crv  ```  ## At setters emit input rather than from storage to save gas  In `StakingRewards.sol`:  ```  setRewardsDuration  setRewardsDistribution  ```
* Repeated external call to usdm.balanceOf(address(this): ```solidity   require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, "<liquidity");   ...   uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step; ```  * Don't need to call owner() here, you can just use msg.sender: ```solidity   function recoverERC20(address tokenAddress, uint256 tokenAmount)       external       onlyOwner   {       ...       IERC20(tokenAddress).safeTransfer(owner(), tokenAmount); ```  * Long revert messages, e.g.: "Previous rewards period must be complete before changing the duration for the new period" Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.  * Variables that are set in the constructor and can't be changed can be marked as immutable: ```solidity     uint256 public step;     uint256 public startLiquidity;     uint public startBlock;     uint public endBlock; ```  * Should be constant: ```solidity     uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block     uint private _concurShareMultiplier = 1e18;     uint private _perMille = 1000; // 100% ```  * Variables and events that are not used in any meaningful way can be removed or used where they were intended: ```solidity     uint256 public startLiquidity;     event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount); ```  * Would be cheapier to use local variables when emitting events, e.g.: ```solidity   rewardsDuration = _rewardsDuration;   emit RewardsDurationUpdated(rewardsDuration);    rewardsDistribution = _rewardsDistribution;   emit RewardsDistributionUpdated(rewardsDistribution); ```  * Usually under normal conditions, the first check is not neccessary, as GRACE_PERIOD > block.timestamp should always revert: ```solidity   require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, "too late"); ```  * This could be inlined to optimize for gas usage, from: ```solidity   bool transferSuccess = false;   if (_amount > concurBalance) {       transferSuccess = concur.transfer(_to, concurBalance);   } else {       transferSuccess = concur.transfer(_to, _amount);   }   require(transferSuccess, "safeConcurTransfer: transfer failed"); ``` to: ```solidity   if (_amount > concurBalance) {       require(concur.transfer(_to, concurBalance), "safeConcurTransfer: transfer failed");   } else {       require(transferSuccess = concur.transfer(_to, _amount), "safeConcurTransfer: transfer failed");   } ```  * Repeated access of storage variables should be cached, e.g. convexBooster is accessed 3 times: ```solidity   lpToken.safeApprove(convexBooster, _amount);   IConvexDeposits(convexBooster).deposit(_pid, _amount, true);   lpToken.safeApprove(convexBooster, 0); ``` masterChef twice: ```solidity   uint256 pid = masterChef.pid(address(lpToken));   masterChef.deposit(msg.sender, pid, _amount); ``` convexPool[_pid] twice: ```solidity   IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);   IERC20 lpToken = IERC20(     IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken   ); ``` registeredRewards[_pid] twice: ```solidity   registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1   registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1 ```  * The initialization to default variables is not neccessary: ```solidity     uint256 public periodFinish = 0;     uint256 public rewardRate = 0; ```  * If the same MasterChef implementation will be used, then the pid of the token can't change, so you should cache it once (in the constructor call), and do not make the external calls again and again in stake and withdraw functions of StakingRewards: ```solidity   uint256 pid = masterChef.pid(address(stakingToken)); ```  * Contract MasterChef has declared a compiler version of ^0.8.11 but it still uses the SafeMath library: ```solidity   using SafeMath for uint;   // e.g.:   return _to.sub(_from);   uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);   accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply)); ``` Overflow/underflow protection is built-in starting from version 0.8, so you don't need to use SafeMath here.  * Would be cheaper if you checked not the storage but the _amount paramater against 0 in the first sentence: ```solidity   require(user.amount > 0, "MasterChef: nothing to withdraw");   require(user.amount >= _amount, "MasterChef: withdraw not allowed"); ```  * currentEpoch() is called twice, should cache after the first call: ```solidity   require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), "wait"); ```  * You already have the address of rewardToken() here, no need to fetch it again:  ```solidity   address extraToken = IRewardStaking(extraPool).rewardToken();     ...     else if (registeredRewards[_pid][extraToken] == 0) {       //add new token to list       rewards[_pid].push(           RewardType({               token: IRewardStaking(extraPool).rewardToken() ```  * In _calcRewardIntegral I think these statements: ```solidity     //update remaining reward here since balance could have changed if claiming     if (bal != reward.remaining) {         reward.remaining = uint128(bal);     } ``` should be placed right after this: ```solidity     uint256 d_reward = bal - reward.remaining; ``` or you can even return and skip all the heavy calculations and 0 value transfers if the balance hasn't changed.
* Function recoverERC20 in StakingRewards allows an owner to transfer out any token except stakingToken. I see 2 problems with this: 1) It should also forbid transferring of rewardsToken, otherwise an owner can drain the rewards and DDOS users withdrawals because there is no way to get back your stake tokens without claiming the rewards. 2) It may be possible that someone accidentally sent stake tokens directly to the contract and these tokens will not be accounted in _totalSupply, thus it makes sense that an owner should be able to rescue these unaccounted tokens: stakingToken.balanceOf(address(this) - _totalSupply).  I assigned this issue a severity of low because I assume we can trust the owner not to exploit this :?  You should forbid recoverERC20 of rewardsToken, and may also allow transferring the surplus from _totalSupply of stakingToken. Usually, it is a good practice in such contracts to have an emergency withdrawal function, where users can get back their stake tokens but forfeit the rewards.  * Function setRewardsDistribution has a misleading revert message:  "... changing the duration ..."  * A small loss in precision due to multiplication and division: ```solidity   IERC20(reward.token).transfer(treasury, d_reward / 5);   d_reward = (d_reward * 4) / 5; ``` A more accurate approach would be something like this: ```solidity   uint toTreasury = d_reward / 5;   IERC20(reward.token).transfer(treasury, toTreasury);   d_reward -= toTreasury; ```  * Consider introducing a reasonable upper limit for the rewards[_pid] array in ConvexStakingWrapper, otherwise if it grows too large it may exceed the gas limit when performing the _checkpoint and there is no way to remove it once added.  * ConvexStakingWrapper function addRewards fetches extraRewards and adds them to the list of rewards, but please note that extra rewards can change: https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L109-L119 Currently, ConvexStakingWrapper has no function to (sync) delete extra rewards. Consider implementing it.  * You should use safe casts here: ```solidity   deposits[_pid][msg.sender].amount += uint192(_amount);   deposits[_pid][msg.sender].amount -= uint192(_amount);   amount : uint192(_amount) ``` Otherwise, if token amounts are exceeding these limits (e.g. rebasing tokens) the accounted and transferred amounts will differ. For instance, in function deposit it will add less to the user's balance but charge the full amount: ```solidity   deposits[_pid][msg.sender].amount += uint192(_amount);   ...   lpToken.safeTransferFrom(msg.sender, address(this), _amount); ```  * I don't think this check in function provide of contract USDMPegRecovery is correct: ```solidity   require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, "<liquidity"); ``` After you provide the liquidity (usdm3crv.add_liquidity), the balance of usdm will decrease, but totalLiquidity.usdm, will not, so the next time it will need to increase even more to reach this condition again. But not sure what was the exact intention here, so submitting this as of low severity FYI.  * Consider introducing a withdrawal deadline to indicate when it is too late and the user has to requestWithdraw again.  * I think the comment and the actual code is misleading here: ```solidity    if (extraToken == cvx) {         //no-op for cvx, crv rewards         rewards[_pid][CVX_INDEX].pool = extraPool;     }  ```
1. LOW: Solidity version pragma uses caret.  [Example](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L3) Note that this issue is present in pretty much every other contract in the project.  This is a bad practice because `^0.8.11` means that the contracts can be compiled with solidity versions greater than or equal to 0.8.11 but less than 0.9.0. Because any number of solidity versions can be used, it is possible that the contracts are tested with one version of solidity and deployed to production using another version of solidity, which can lead to issues if there are bugs in the solidity compiler. Instead, the lines should be replaced with `pragma solidity 0.8.11;`  so that 0.8.11 is used in production and testing.  3. informational: `safeTransfer` to `msg.sender` in `StakingRewards.withdraw` should come after all effects. [location](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L111) This follows the check-effects-interactions pattern, and is good defense-in-depth (since there function uses `nonReentrant` modifier).  4. Informational: Code layout in StakingRewards doesn't obey conventions, events are on the bottom. [Example](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L213) They should come before functions. Putting events at the end is inconsistent with the other contracts in this repo. [It is also inconsistent with solidity's standard conventions](https://docs.soliditylang.org/en/v0.8.11/style-guide.html#order-of-layout) 
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L34 https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L54   # Vulnerability details  ## Impact Function donate in Shelter shouldn't allow new deposits after the grace period ends, when the claim period begins.  Otherwise, it will be possible to increase savedTokens[_token], and thus new user claim amounts will increase after some users might already have withdrawn their shares.  ## Recommended Mitigation Steps Based on my understanding, it should contain this check: ```solidity   require(activated[_token] + GRACE_PERIOD > block.timestamp, "too late"); ```  
###GAS OPTIMIZATION --1 -unnecessary `i` value set https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L35 unnecessary value set. the default value of uint is zero. just use: ``` uint i; ``` --2 -better increment https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L35 change i++ to ++i --3 -Best way to use `SafeERC20.function` for gas opt https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L10 by not declare: ``` using SafeERC20 for IERC20; ``` and use: ``` SafeERC20.safeTransfer(IERC20(_tokens[i]), msg.sender, getting); ``` can safe gas usage. --4 -unnecessary variable declaration -Unnecessary (uint) `getting` variable declaration https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L36 instead of caching `reward[msg.sender][_tokens[i]]` in `getting`, better just pass it directly into `safeTransfer()` function. `getting` was declared and called once per loop. It cost more gas.  recommended mitigation: ``` IERC20(_tokens[i]).safeTransfer(msg.sender, reward[msg.sender][_tokens[i]]); // L 36 ``` ##ConvexStakingWrapper.sol --5 -Using `storage` to declare Struct variable inside function https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L171 instead of caching `rewardType` to memory. read it directly from storage. ``` RewardType storage reward = rewards[_pid][_index]; ``` --6 -Using `uint` instead `struct` https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L24 The `Reward` struct merely contain 1 property. Instead of declaring it as struct, better as a uint example: uint128 integralReward(example name); https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L44 then modify the `userReward` mapping output from `Reward` to `uint`. ##MasterChef.sol --7 -unnecessary `totalAllocPoint` & `_pid` value set  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L51 https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L129 unnecessary value set. the default value of uint is zero. just use: ``` uint public totalAllocPoint; ``` --8 -use constant for gas saving https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L57 use `constant` to declare `_perMille` & ` _concurShareMultiplier` uint --9 -Unused library https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L15 unused SafeERC20 lib ##Shelter.sol --10 -`&&` is more expensive gas https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L45 using multiple `require()` is cheaper than use && ``` require(activated[_token] != 0 , "too late"); require(activated[_token] + GRACE_PERIOD > block.timestamp, "too late"); ``` --11 -unnecessary value set https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L21-L22 unnecessary value set. the default value of uint is zero for `rewardRate` & `periodFinish`. uint default value is 0 --12 -`step` declaration https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L22 setting the `step` value directly and use `constant` can save gas. then remove the line: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L56 --13 -using storage to declare struct inside function https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L91 instead of caching `Liquidity` in memory. just read it directly to storage ``` Liquidity storage total = totalLiquidity; ``` it can save gas. And same for `user` variable right below it. --14 -unnecessary math operation https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L116-L117 the value of `registeredRewards[_pid][crv]` and `registeredRewards[_pid][cvx]` is fixed, Set the value(1 and 2) directly then add additional info which explain the math operation behind it: ```             registeredRewards[_pid][crv] = 1; //mark registered CRV_INDEX + 1             registeredRewards[_pid][cvx] = 2; //mark registered CVX_INDEX + 1 ``` --15 -use calldata to store `signature` https://github.com/code-423n4/2022-02-concur/blob/main/contracts/EasySign.sol#L51 replace memory with calldata to save gas --16 -Using `immutable` to declare variable which set once at constructor https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L52-L54 `startBlock`, `endBlock` & `concur` are set once in constructor. Use `immutable` --17 -use `require()` to validate instead `if()` https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L137 by using: ```  require(block.number > pool.lastRewardBlock); ``` to replace: ```         if (block.number <= pool.lastRewardBlock) {             return;         } ``` can save gas with the same output 18-- -Unncessary `multiplier` (uint) declaration https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L150-L151 `multiplier` is called once in `updatePool()`. Its gas consuming to cache `getMultiplier` return in `multiplier`. Remove line 150, and change line it to: ``` uint concurReward = getMultiplier(pool.lastRewardBlock, block.number).mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint); ```     
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L52-L57   # Vulnerability details  ## Impact tl;dr Anyone who can call `withdraw` to withdraw their own funds can call it repeatedly to withdraw the funds of others. `withdraw` should only succeed if the user hasn't withdrawn the token already.  The shelter can be used for users to withdraw funds in the event of an emergency. The `withdraw` function allows callers to withdraw tokens based on the tokens they have deposited into the shelter client: ConvexStakingWrapper. However, `withdraw` does not check if a user has already withdrawn their tokens. Thus a user that can `withdraw` tokens, can call withdraw repeatedly to steal the tokens of others.  ## Proof of Concept  tl;dr an attacker that can successfully call `withdraw` once on a shelter, can call it repeatedly to steal the funds of others. Below is a detailed scenario where this situation can be exploited.  1. Mallory deposits 1 `wETH` into `ConvexStakingWrapper` using [`deposit`](https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L280). Let's also assume that other users have deposited 2 `wETH` into the same contract. 2. An emergency happens and the owner of `ConvexStakingWrapper` calls `setShelter(shelter)` and `enterShelter([pidOfWETHToken, ...])`. Now `shelter` has 3 `wETH` and is activated for `wETH`. 3. Mallory calls `shelter.withdraw(wETHAddr, MalloryAddr)`, mallory will rightfully receive 1 wETH because her share of wETH in the shelter is 1/3. 4. Mallory calls `shelter.withdraw(wETHAddr, MalloryAddr)` again, receiving 1/3*2 = 2/3 wETH. `withdraw` does not check that she has already withdrawn. This time, the wETH does not belong to her, she has stolen the wETH of the other users. She can continue calling `withdraw` to steal the rest of the funds   ## Tools Used  Manual inspection.  ## Recommended Mitigation Steps  To mitigate this, `withdraw` must first check that `msg.sender` has not withdrawn this token before and `withdraw` must also record that `msg.sender` has withdrawn the token. The exact steps for this are below: 1. Add the following line to the beginning of `withdraw` (line 53): ``` require(!claimed[_token][msg.sender], "already claimed") ``` 2.  Replace [line 55](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L55) with the following: ``` claimed[_token][msg.sender] = true; ``` This replacement is necessary because we want to record who is withdrawing, not where they are sending the token which isn't really useful info.  
 1. considered using != instead of > can save gas https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L236 // gas cost 45422  Change to: ```  if (_amount != 0) { ``` // gas cost 45419  ========================================================================  2. using calldata can save gas https://github.com/code-423n4/2022-02-concur/blob/main/contracts/EasySign.sol#L51 // gas cost 23523  Change to: ``` function tryRecover(bytes32 hash, bytes calldata signature) ``` // gas cost 23056  ========================================================================  3. considered using require instead of `if` can save gas https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L118 // gas cost 24404  Change to: ```         require (block.number > pool.lastRewardBlock);         require (lpSupply != 0);  ``` // gas cost 24392  ========================================================================  4. considered using require instead of && can save gas  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L45 // gas cost 24475  Change to: ```         require(activated[_token] != 0);         require (activated[_token] + GRACE_PERIOD > block.timestamp, "too late"); ``` // gas cost 24162
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86-L101   # Vulnerability details  ## Impact  Token fee in `MasterChef` can be set to more than 100%, (for example by accident) causing all `deposit` calls to fail due to underflow on subtraction when reward is lowered by the fee, thus breaking essential mechanics. Note that after the fee has been set to any value, it cannot be undone. A token cannot be removed, added, or added the second time. Thus, mistakenly (or deliberately, maliciously) added fee that is larger than 100% will make the contract impossible to recover from not being able to use the token.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  On setting fee ensure that it is below a set maximum, which is set to no more than 100%.   
1. Tittle Changing memory to storage can safe gas.  ## Impact Bye changing memory pointer to storage pointer and delete line ``https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L206.`` ``https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L105.``, can safe gas.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L206. https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L105.
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L182   # Vulnerability details  ## Impact  If deposits and withdraws are done frequently enough, the reward update operation they invoke will deal mostly with the case when there is nothing to add yet, i.e. `reward.remaining` match the reward token balance.  If reward token doesn't allow for zero value transfers, the reward update function will fail on an empty incremental reward transfer, which is now done unconditionally, reverting the caller deposit/withdrawal functionality  ## Proof of Concept  When ConvexStakingWrapper isn't paused, every deposit and withdraw update current rewards via `_checkpoint` function before proceeding:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L233  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L260  `_checkpoint` calls `_calcRewardIntegral` for each of the reward tokens of the pid:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L220  `_calcRewardIntegral` updates the incremental reward for the token, running the logic even if reward is zero, which is frequently the case:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L182  If the reward token doesn't allow zero value transfers, this transfer will fail, reverting the corresponding deposit or withdraw  ## Recommended Mitigation Steps  Consider checking the reward before doing transfer (and the related computations as an efficiency measure):  Now: ``` IERC20(reward.token).transfer(address(claimContract), d_reward); ```  To be: ``` if (d_reward > 0)  IERC20(reward.token).transfer(address(claimContract), d_reward); ```   
1. Tittle execute() should revert, instead of returning false on failing low level call   # Vulnerability details  ## Impact When an owner want to execute something, make sure to revert the transaction when the low level call is failing, this execute() will still returning a success transaction, eventhough the actual execution is failing when doing the low level call  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/VoteProxy.sol#L33 --------------------------------------------------------------------------------------------------------------------------- 2. Tittle claimRewards() didnt follow the safe check effect pattern  ## Impact a user can claim a reward by calling the claimRewards(), however this function didnt follow the correct check effect pattern, where the zero address is set after making an external call, lets say the reward token is erc777 which will make an external during transfer, the user can reenter this function since this function didnt follow the check effect pattern and didnt have a noreentrant modifier, the user can claim token with reentrancy.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L37 --------------------------------------------------------------------------------------------------------------------------- 3. Tittle Unsafe cast from uint256 to uint192  ## Impact  the max value of uint192 is 6277101735386680763835789423207666416102355444464034512895, however when you input the _amount to 6277101735386680763835789423207666416102355444464034512896 value, since it doing an unsafe cast from uint256 to uint192, the _amount value would be 0.  ##Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L235 --------------------------------------------------------------------------------------------------------------------------- 4. Tittle this check can be bypassed  ## Impact this check is useless, since the usdm is allowed a user to flashmint the token, in the usdm contract, the usdm is allowed the user to flashmint the token instead of the usual flashloan, in flashmint you are minting a token instead of borrowing an existing token, therefore the flashmint is allowed the user to borrow up to 115792089237316195423570985008687907853269984665640517394379403123841238667621 usdm token, then deposit the pool3 token.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L100 1. unlockable state is true and totalliquidity usdm is bellow 4m 2. a user/whale is flashmint 4m usdm 3. user deposit 4m usdm token 4. user deposit pool3 token 5. withdraw the 4m usdm that was already deposited 6. pay the fee 7. now the user/whale has deposited the pool3 token eventhough the totalliqudity of usdm still below 4m ------------------------------------------------------------------------------------------------------------------------- 5. Tittle mismatch between description and actual code  ## Impact the actual value in the https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L100 is 4m usdm, but the description said that it is 40m usdm.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L100 
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L178-185   # Vulnerability details  ## Impact  notifyRewardAmount will be inoperable if rewardsDuration bet set to zero. If will cease to produce meaningful results if rewardsDuration be too small or too big  ## Proof of Concept  The setter do not control the value, allowing zero/near zero/enormous duration:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L178-185  Division by the duration is used in notifyRewardAmount:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L143-156  ## Recommended Mitigation Steps  Check for min and max range in the rewardsDuration setter, as too small or too big rewardsDuration breaks the logic  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol   # Vulnerability details  ## Impact There is no functionality for removing pools/setting pool's allocPoints. Therefore `totalAllocPoint` only increases and rewards for pool decreases.  ## Proof of Concept Scenario: 1. Owner adds new pool (first pool) for staking with points = 900 (totalAllocPoint=900). 2. 1 week passes 3. First pool staking period ends (or for other reasons that pool is not meaningfully anymore). 4. Owner adds new pool (second pool) for staking with points = 100 (totalAllocPoint=1000) 5. 1 block later Alice stake 10 tokens there (at the same time). 6. 1 week passes 7. After some time Alice claims rewards. But she is eligible only for 10% of the rewards. 90% goes to unused pool.  ## Tools Used Manual review  ## Recommended Mitigation Steps Add functionality for removing pool or functionality for setting pool's `totalAllocPoint` param.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86   # Vulnerability details  ## Impact When adding new token pool for staking in MasterChef contract ```javascript function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) ``` All other, already added, pools should be updated but currently they are not. Instead, only totalPoints is updated. Therefore, old (and not updated) pools will lose it's share during the next update. Therefore, user rewards are not computed correctly (will be always smaller).  ## Proof of Concept Scenario 1: 1. Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100)    and 1 block later Alice stakes 10 tokens in the first pool. 2. 1 week passes 3. Alice withdraws her 10 tokens and claims X amount of reward tokens.    and 1 block later Bob stakes 10 tokens in the first pool. 4. 1 week passes 5. Owner adds new pool (second pool) for staking with points = 100 (totalPoints=200)    and 1 block later Bob withdraws his 10 tokens and claims X/2 amount of reward tokens.    But he should get X amount  Scenario 2: 1. Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100). 2. 1 block later Alice, Bob and Charlie stake 10 tokens there (at the same time). 3. 1 week passes 4. Owner adds new pool (second pool) for staking with points = 400 (totalPoints=500) 5. Right after that, when Alice, Bob or Charlie wants to withdraw tokens and claim rewards they will only be able to claim 20% of what they should be eligible for, because their pool is updated with 20% (100/500) rewards instead of 100% (100/100) rewards for the past week.  ## Tools Used Manual review  ## Recommended Mitigation Steps Update all existing pools before adding new pool. Use the massUdpate() function which is already present ... but unused.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110-L128   # Vulnerability details  Per the doc:  > USDM deposits are locked based on the KPI’s from carrot.eth.  > 3Crv deposits are not locked.  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110-L128  ```solidity function withdraw(Liquidity calldata _withdrawal) external {         Liquidity memory total = totalLiquidity;         Liquidity memory user = userLiquidity[msg.sender];         if(_withdrawal.usdm > 0) {             require(unlockable, "!unlock usdm");             usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));             total.usdm -= _withdrawal.usdm;             user.usdm -= _withdrawal.usdm;         }          if(_withdrawal.pool3 > 0) {             pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));             total.pool3 -= _withdrawal.pool3;             user.pool3 -= _withdrawal.pool3;         }         totalLiquidity = total;         userLiquidity[msg.sender] = user;         emit Withdraw(msg.sender, _withdrawal);     } ```  However, because the `withdraw()` function takes funds from the balance of the contract, once the majority of the funds are added to the curve pool via `provide()`. The `withdraw()` may often fail due to insufficient funds in the balance.  ### PoC  1. Alice deposits `4M` USDM and `4M` pool3 tokens; 2. Guardian calls `provide()` and all the `usdm` and `pool3` to `usdm3crv`; 3. Alice calls `withdraw()`, the tx will fail, due to insufficient balance.  ### Recommendation  Consider calling `usdm3crv.remove_liquidity_one_coin()`  when the balance is insufficient for the user's withdrawal.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L166-L176   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L166-L176  ```solidity     function recoverERC20(address tokenAddress, uint256 tokenAmount)         external         onlyOwner     {         require(             tokenAddress != address(stakingToken),             "Cannot withdraw the staking token"         );         IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);         emit Recovered(tokenAddress, tokenAmount);     } ```  ### Impact  Users can lose all the rewards to the malicious/compromised `owner`.  ### Recommendation  Change to:  ```solidity  function recoverERC20(     address tokenAddress,     address to,     uint256 amount ) external onlyOwner {     require(tokenAddress != address(stakingToken) && tokenAddress != address(rewardsToken), "20");      IERC20(tokenAddress).safeTransfer(to, amount);     emit Recovered(tokenAddress, to, amount); } ```  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L154-L158   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L154-L158  ```solidity     uint256 balance = rewardsToken.balanceOf(address(this));     require(         rewardRate <= balance / rewardsDuration,         "Provided reward too high"     ); ```  In the current implementation, the contract only checks if balanceOf `rewardsToken` is greater than or equal to the future rewards.  However, under normal circumstances, since users can not withdraw all their rewards in time, the balance in the contract contains rewards that belong to the users but have not been withdrawn yet. This means the current checks can not be sufficient enough to make sure the contract has enough amount of rewardsToken.  As a result, if the `rewardsDistribution` mistakenly `notifyRewardAmount` with a larger amount, the contract may end up in a wrong state that makes some users unable to claim their rewards.  ### PoC  Given:  - rewardsDuration = 7 days;  1. Alice stakes `1,000` stakingToken; 2. `rewardsDistribution` sends `100` rewardsToken to the contract; 3. `rewardsDistribution` calls `notifyRewardAmount()` with `amount` = `100`; 4. 7 days later, Alice calls `earned()` and it returns `100` rewardsToken, but Alice choose not to `getReward()` for now; 5. `rewardsDistribution` calls `notifyRewardAmount()` with `amount` = `100` without send any fund to contract, the tx will succees; 6. 7 days later, Alice calls `earned()` `200` rewardsToken, when Alice tries to call `getReward()`, the transaction will fail due to insufficient balance of rewardsToken.  Expected Results:  The tx in step 5 should revert.  ### Recommendation  Consider changing the function `notifyRewardAmount` to `addRward` and use `transferFrom` to transfer rewardsToken into the contract:  ```solidity function addRward(uint256 reward)     external     updateReward(address(0)) {     require(         msg.sender == rewardsDistribution,         "Caller is not RewardsDistribution contract"     );      if (block.timestamp >= periodFinish) {         rewardRate = reward / rewardsDuration;     } else {         uint256 remaining = periodFinish - block.timestamp;         uint256 leftover = remaining * rewardRate;         rewardRate = (reward + leftover) / rewardsDuration;     }      rewardsToken.safeTransferFrom(msg.sender, address(this), reward);      lastUpdateTime = block.timestamp;     periodFinish = block.timestamp + rewardsDuration;     emit RewardAdded(reward); } ```  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L135-L154   # Vulnerability details  According to:  -   README https://github.com/code-423n4/2022-02-concur#-masterchef -   Implementation of `deposit()`: [/contracts/MasterChef.sol#L157-L180](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L157-L180)  MasterChef is only recording the deposited amount in the states, it's not actually holding the `depositToken`.  `depositToken` won't be transferred from `_msgSender()` to the MasterChef contract.  Therefore, in `updatePool()` L140 `lpSupply = pool.depositToken.balanceOf(address(this))` will always be `0`. And the `updatePool()` will be returned at L147.  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L135-L154  ```solidity function updatePool(uint _pid) public {     PoolInfo storage pool = poolInfo[_pid];     if (block.number <= pool.lastRewardBlock) {         return;     }     uint lpSupply = pool.depositToken.balanceOf(address(this));     if (lpSupply == 0 || pool.allocPoint == 0) {         pool.lastRewardBlock = block.number;         return;     }     if(block.number >= endBlock) {         pool.lastRewardBlock = block.number;         return;     }              uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);     uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);     pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));     pool.lastRewardBlock = block.number; } ```   ### Impact  - The MasterChef contract fail to implement the most essential function; - Users won't be able to receive any `Concur` rewards from MasterChef;  ### Recommendation  Consider creating a receipt token to represent the invested token and use the receipt tokens in MasterChef.  See: https://github.com/convex-eth/platform/blob/883ffd4ebcaee12e64d18f75bdfe404bcd900616/contracts/contracts/Booster.sol#L272-L277  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L175-L204   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L175-L204  ```solidity     uint256 bal = IERC20(reward.token).balanceOf(address(this));     uint256 d_reward = bal - reward.remaining;     // send 20 % of cvx / crv reward to treasury     if (reward.token == cvx || reward.token == crv) {         IERC20(reward.token).transfer(treasury, d_reward / 5);         d_reward = (d_reward * 4) / 5;     }     IERC20(reward.token).transfer(address(claimContract), d_reward);      if (_supply > 0 && d_reward > 0) {         reward.integral =             reward.integral +             uint128((d_reward * 1e20) / _supply);     }      //update user integrals     uint256 userI = userReward[_pid][_index][_account].integral;     if (userI < reward.integral) {         userReward[_pid][_index][_account].integral = reward.integral;         claimContract.pushReward(             _account,             reward.token,             (_balance * (reward.integral - userI)) / 1e20         );     }      //update remaining reward here since balance could have changed if claiming     if (bal != reward.remaining) {         reward.remaining = uint128(bal);     } ```  The problems in the current implementation:  - `reward.remaining` is not a global state; the `reward.remaining` of other `reward`s with the same rewardToken are not updated; - `bal` should be refreshed before `reward.remaining = uint128(bal);`; - L175 should not use `balanceOf` but take the diff before and after `getReward()`.  ### PoC  - convexPool[1] is incentivized with CRV as the reward token, `1000 lpToken` can get `10 CRV` per day; - convexPool[2] is incentivized with CRV as the reward token, `1000 lpToken` can get `20 CRV` per day.  1. Alice deposits `1,000` lpToken to `_pid` = `1` 2. 1 day later, Alice deposits `500` lpToken to `_pid` = `1`   - convexPool `getReward()` sends `10 CRV` as reward to contract - `d_reward` = 10, `2 CRV` sends to `treasury`, `8 CRV` send to `claimContract` - `rewards[1][0].remaining` = 10  3. 0.5 day later, Alice deposits `500` lpToken to `_pid` = `1`, and the tx will fail:  - convexPool `getReward()` sends `7.5 CRV` as reward to contract - `reward.remaining` = 10 - `bal` = 7.5 - `bal - reward.remaining` will fail due to underflow  4. 0.5 day later, Alice deposits `500` lpToken to `_pid` = `1`, most of the reward tokens will be left in the contract:  - convexPool `getReward()` sends `15 CRV` as reward to the contract; - `d_reward = bal - reward.remaining` = 5 - `1 CRV` got sent to `treasury`, `4 CRV` sent to `claimContract`, `10 CRV` left in the contract; - `rewards[1][0].remaining` = 15  Expected Results:  All the `15 CRV` get distributed: `3 CRV` to the `treasury`, and `12 CRV` to `claimContract`.  Actual Results:  Only `5 CRV` got distributed. The other `10 CRV` got left in the contract which can be frozen in the contract, see below for the details:  5. Bob deposits `1,000` lpToken to `_pid` = `2`  - convexPool `getReward()` sends `0 CRV` as reward to the contract - `d_reward = bal - reward.remaining` = 10 - `2 CRV` sent to `treasury`, `8 CRV` sent to `claimContract` without calling `pushReward()`, so the `8 CRV` are now frozen in `claimContract`; - `rewards[2][0].remaining` = 10  ### Impact  - The two most important methods: `deposit()` and `withdraw()` will frequently fail as the tx will revert at `_calcRewardIntegral()`; - Rewards distributed to users can often be fewer than expected; - If there are different pools that use the same token as rewards, part of the rewards can be frozen at `claimContract` and no one can claim them.  ### Recommendation  Consider comparing the `balanceOf` reward token before and after `getReward()` to get the actual rewarded amount, and `reward.remaining` should be removed.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/ConvexStakingWrapper.sol#L184-L188   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/ConvexStakingWrapper.sol#L184-L188  ```solidity if (_supply > 0 && d_reward > 0) {     reward.integral =         reward.integral +         uint128((d_reward * 1e20) / _supply); } ```  `reward.integral` is `uint128`, if an early user deposits with just `1` Wei of `lpToken`, and make `_supply == 1`, and then transferring `5e18` of `reward_token` to the contract.  As a result, `reward.integral` can exceed `type(uint128).max` and overflow, causing the rewards distribution to be disrupted.  ### Recommendation  Consider `wrap` a certain amount of initial totalSupply at deployment, e.g. `1e8`, and never burn it. And consider using uint256 instead of uint128 for `reward.integral`. Also, consdier lower `1e20` down to `1e12`.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/USDMPegRecovery.sol#L73-L82   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/USDMPegRecovery.sol#L73-L82  ```solidity function provide(uint256 _minimumLP) external onlyGuardian {     require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, "<liquidity");     // truncate amounts under step     uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;     // match usdm : pool3 = 1 : 1     uint256[2] memory amounts = [addingLiquidity, addingLiquidity];     usdm.approve(address(usdm3crv), addingLiquidity);     pool3.approve(address(usdm3crv), addingLiquidity);     usdm3crv.add_liquidity(amounts, _minimumLP); } ```  In the current implementation of `USDMPegRecovery.sol#provide()`, `addingLiquidity` is calculated solely based on `usdm` balance (truncate at a step of 250k), and it always uses the same amount of 3pool tokens to add_liquidity with.  Based on other functions of the contract, the balance of `usdm` can usually be more than the `pool3` balance, in that case, `usdm3crv.add_liquidity()` will fail.  ### Impact  When the balance of `pool3` is less than `usdm` (which is can be a common scenario), funds cannot be added to the curve pool.  For example:  When the contract got 5M of USDM and 4.2M of `pool3` tokens, it won't be possible to call `provide()` and add liquidity to the `usdm3crv` pool, as there are not enough pool3 tokens to match the 5M of USDM yet.  We expect it to add liquidity with 4M of USDM and 4M of pool3 tokens in that case.  ### Recommendation  Change to:  ```solidity function provide(uint256 _minimumLP) external onlyGuardian {     require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, "<liquidity");     uint256 tokenBalance = Math.min(usdm.balanceOf(address(this), pool3.balanceOf(address(this));     // truncate amounts under step     uint256 addingLiquidity = (tokenBalance / step) * step;     // match usdm : pool3 = 1 : 1     uint256[2] memory amounts = [addingLiquidity, addingLiquidity];     usdm.approve(address(usdm3crv), addingLiquidity);     pool3.approve(address(usdm3crv), addingLiquidity);     usdm3crv.add_liquidity(amounts, _minimumLP); } ```  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90   # Vulnerability details  ## Impact In README.me: > USDM deposits are locked based on the KPI’s from carrot.eth  However, USDM deposits are also locked until guardian remove liquidity because there are no mechanism to remove deposited USDM in `withdraw`  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L216-L259   # Vulnerability details  ## Impact  The `ConvexStakingWrapper.sol` implementation makes several modifications to the original design. One of the key changes is the ability to add multiple pools into the wrapper contract, where each pool is represented by a unique `_pid`. By doing this, we are able to aggregate pools and their LP tokens to simplify the token distribution process.   However, the interdependence between pools introduces new problems. Because the original implementation uses the contract's reward token balance to track newly claimed tokens, it is possible for a malicious user to abuse the unguarded `getReward` function to maximise the profit they are able to generate. By calling `getReward` on multiple pools with the same reward token (i.e. `cvx`), users are able to siphon rewards from other pools. This inevitably leads to certain loss of rewards for users who have deposited LP tokens into these victim pools. As `crv` and `cvx` are reward tokens by default, it is very likely that someone will want to exploit this issue.  ## Proof of Concept  Let's consider the following scenario: - There are two convex pools with `_pid` 0 and 1. - Both pools currently only distribute `cvx` tokens. - Alice deposits LP tokens into the pool with `_pid` 0. - Both pools earn 100 `cvx` tokens which are to be distributed to the holders of the two pools. - While Alice is a sole staker of the pool with `_pid` 0, the pool with `_pid` 1 has several stakers. -  Alice decides she wants to maximise her potential rewards, so she directly calls the unguarded `IRewardStaking(convexPool[_pid]).getReward` function on both pools, resulting in 200 `cvx` tokens being sent to the contract. - She then decides to deposit the 0 amount to execute the `_calcRewardIntegral` function on the pool with `_pid` 0. However, this function will calculate `d_reward` as `bal - reward.remaining` which is effectively the change in contract balance. As we have directly claimed `cvx` tokens over the two pools, this `d_reward` will be equal to 200. - Alice is then entitled to the entire 200 tokens as she is the sole staker of her pool. So instead of receiving 100 tokens, she is able to siphon rewards from other pools.  Altogether, this will lead to the loss of rewards for other stakers as they are unable to then claim their rewards.  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L216-L259 ``` function _calcRewardIntegral(     uint256 _pid,     uint256 _index,     address _account,     uint256 _balance,     uint256 _supply ) internal {     RewardType memory reward = rewards[_pid][_index];      //get difference in balance and remaining rewards     //getReward is unguarded so we use remaining to keep track of how much was actually claimed     uint256 bal = IERC20(reward.token).balanceOf(address(this));     uint256 d_reward = bal - reward.remaining;     // send 20 % of cvx / crv reward to treasury     if (reward.token == cvx || reward.token == crv) {         IERC20(reward.token).transfer(treasury, d_reward / 5);         d_reward = (d_reward * 4) / 5;     }     IERC20(reward.token).transfer(address(claimContract), d_reward);      if (_supply > 0 && d_reward > 0) {         reward.integral =             reward.integral +             uint128((d_reward * 1e20) / _supply);     }      //update user integrals     uint256 userI = userReward[_pid][_index][_account].integral;     if (userI < reward.integral) {         userReward[_pid][_index][_account].integral = reward.integral;         claimContract.pushReward(             _account,             reward.token,             (_balance * (reward.integral - userI)) / 1e20         );     }      //update remaining reward here since balance could have changed if claiming     if (bal != reward.remaining) {         reward.remaining = uint128(bal);     }      rewards[_pid][_index] = reward; } ```  ## Tools Used  Manual code review. Confirmation from Taek.  ## Recommended Mitigation Steps  Consider redesigning this mechanism such that all pools have their `getReward` function called in `_checkpoint`. The `_calcRewardIntegral` function can then ensure that each pool is allocated only a fraction of the total rewards instead of the change in contract balance. Other implementations might be more ideal, so it is important that careful consideration is taken when making these changes.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L121-L130 https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L309-L331   # Vulnerability details  ## Impact  The shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. Conversely, the `exitShelter` function will deactivate the shelter and transfer all LP tokens back to the `ConvexStakingWrapper.sol` contract.  Unfortunately, LP tokens aren't restaked in the pool, causing LP tokens to be stuck within the contract. Users will be unable to withdraw their LP tokens as the `withdraw` function attempts to `withdrawAndUnwrap` LP tokens from the staking pool. As a result, this function will always revert due to insufficient staked balance. If other users decide to deposit their LP tokens, then these tokens can be swiped by users who have had their LP tokens locked in the contract.  This guarantees poor UX for the protocol and will most definitely lead to LP token loss.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L121-L130 ``` function exitShelter(uint256[] calldata _pids) external onlyOwner {     for(uint256 i = 0; i<_pids.length; i++){         IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);         IERC20 lpToken = IERC20(             pool.poolInfo(_pids[i]).lptoken         );         amountInShelter[lpToken] = 0;         shelter.deactivate(lpToken);     } } ```  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L309-L331 ``` function withdraw(uint256 _pid, uint256 _amount)     external     nonReentrant     whenNotInShelter(_pid) {     WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];     require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), "wait");     require(request.amount >= _amount, "too much");     _checkpoint(_pid, msg.sender);     deposits[_pid][msg.sender].amount -= uint192(_amount);     if (_amount > 0) {         IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);         IERC20 lpToken = IERC20(             IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken         );         lpToken.safeTransfer(msg.sender, _amount);         uint256 pid = masterChef.pid(address(lpToken));         masterChef.withdraw(msg.sender, pid, _amount);     }     delete withdrawRequest[_pid][msg.sender];     //events     emit Withdrawn(msg.sender, _amount); } ```  ## Tools Used  Manual code review. Confirmation from Taek.  ## Recommended Mitigation Steps  Consider re-depositing LP tokens upon calling `exitShelter`. This should ensure the same tokens can be reclaimed by users wishing to exit the `ConvexStakingWrapper.sol` contract.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L170-L172   # Vulnerability details  ## Impact  If a pool’s deposit fee is non-zero, it is subtracted from the amount to be credited to the user.  ```jsx if (pool.depositFeeBP > 0) {   uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);   user.amount = SafeCast.toUint128(user.amount + _amount - depositFee); } ```  However, the deposit fee is not credited to anyone, leading to permanent lockups of deposit fees in the relevant depositor contracts (StakingRewards and ConvexStakingWrapper for now).  ## Proof of Concept  ### Example 1: ConvexStakingWrapper  Assume the following  - The [curve cDai / cUSDC / cUSDT LP token](https://etherscan.io/address/0x9fC689CCaDa600B6DF723D9E47D84d76664a1F23) corresponds to `pid = 1` in the convex booster contract. - Pool is added in Masterchef with `depositFeeBP = 100 (10%)`. 1. Alice deposits 1000 LP tokens via the ConvexStakingWrapper contract. A deposit fee of 100 LP tokens is charged. Note that the `deposits` mapping of the ConvexStakingWrapper contract credits 1000 LP tokens to her. 2. However, Alice will only be able to withdraw 900 LP tokens. The 100 LP tokens is not credited to any party, and is therefore locked up permanently (essentially becomes protocol-owned liquidity). While she is able to do `requestWithdraw()` for 1000 LP tokens, attempts to execute `withdraw()` with amount = 1000 will revert because she is only credited 900 LP tokens in the Masterchef contract.  ### Example 2: StakingRewards  - CRV pool is added in Masterchef with `depositFeeBP = 100 (10%)`. 1. Alice deposits 1000 CRV into the StakingRewards contract. A deposit fee of 100 CRV is charged. 2. Alice is only able to withdraw 900 CRV tokens, while the 100 CRV is not credited to any party, and is therefore locked up permanently.  These examples are non-exhaustive as more depositors can be added / removed from the Masterchef contract.  ## Recommended Mitigation Steps  I recommend shifting the deposit fee logic out of the masterchef contract into the depositor contracts themselves, as additional logic would have to be added in the masterchef to update the fee recipient’s state (rewardDebt, send pending concur rewards, update amount), which further complicates matters. As the fee recipient is likely to be the treasury, it is also not desirable for it to accrue concur rewards.  ```jsx if (pool.depositFeeBP > 0) {   uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);   user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);   UserInfo storage feeRecipient = userInfo[_pid][feeRecipient];   // TODO: update and send feeRecipient pending concur rewards   feeRecipient.amount = SafeCast.toUint128(feeRecipient.amount + depositFee);   // TODO: update fee recipient's rewardDebt } ```  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L256   # Vulnerability details  ``` ConcurRewardPool.constructor(address)._notifier (contracts/ConcurRewardPool.sol#15) lacks a zero-check on :   - rewardNotifier = _notifier (contracts/ConcurRewardPool.sol#16) ConvexStakingWrapper.constructor(address,MasterChef)._treasury (contracts/ConvexStakingWrapper.sol#69) lacks a zero-check on :   - treasury = _treasury (contracts/ConvexStakingWrapper.sol#70) ConvexStakingWrapper.changeTreasury(address)._treasury (contracts/ConvexStakingWrapper.sol#82) lacks a zero-check on :   - treasury = _treasury (contracts/ConvexStakingWrapper.sol#83) StakingRewards.constructor(address,address,address,MasterChef)._rewardsDistribution (contracts/StakingRewards.sol#38) lacks a zero-check on :   - rewardsDistribution = _rewardsDistribution (contracts/StakingRewards.sol#45) StakingRewards.setRewardsDistribution(address)._rewardsDistribution (contracts/StakingRewards.sol#187) lacks a zero-check on :   - rewardsDistribution = _rewardsDistribution (contracts/StakingRewards.sol#195) USDMPegRecovery.constructor(uint256,address)._kpiOracle (contracts/USDMPegRecovery.sol#50) lacks a zero-check on :   - kpiOracle = _kpiOracle (contracts/USDMPegRecovery.sol#57) VoteProxy.execute(address,uint256,bytes)._to (contracts/VoteProxy.sol#29) lacks a zero-check on :   - (success,result) = _to.call{value: _value}(_data) (contracts/VoteProxy.sol#33) ```  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/StakingRewards.sol   # Vulnerability details  ## Impact  Staking tokens are used to deposit into the `StakingRewards.sol` and `ConvexStakingWrapper.sol` contracts. Once deposited, the user is entitled to Concur rewards in proportion to their staked balance and the underlying pool's `allocPoint` in the `MasterChef.sol` contract.  The `Shelter.sol` mechanism allows the owner of the `ConvexStakingWrapper.sol` to react to emergency events and protect depositor's assets. The staking tokens can be withdrawn after the grace period has passed. However, these staking tokens can be deposited into the `StakingRewards.sol` contract to continue receiving Concur rewards not only for `StakingRewards.sol` but also for their `ConvexStakingWrapper.sol` deposited balance which has not been wiped. As a result, users are able to effectively claim double the amount of Concur rewards they should be receiving.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/StakingRewards.sol  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Ensure that staking tokens cannot be deposited in both the `StakingRewards.sol` and `ConvexStakingWrapper.sol` contracts. If this is intended behaviour, it may be worthwhile to ensure that the sheltered users have their deposited balance wiped from the `MasterChef.sol` contract upon being sheltered.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol   # Vulnerability details  ## Impact  The shelter mechanism aims to protect the protocol's users by draining funds into a separate contract in the event of an emergency. However, while users are able to reclaim their funds through the `Shelter.sol` contract, they will still have a deposited balance from the perspective of `ConvexStakingWrapper.sol`.  However, if the shelter mechanism is enacted before users are able to claim their Concur rewards, any accrued tokens will be lost and the `MasterChef.sol` contract will continue to allocate tokens to the sheltered pool which will be forever locked within this contract.  There is currently no way to remove sheltered pools from the `MasterChef.sol` contract, hence any balance lost in the contract cannot be recovered due to a lack of a sweep mechanism which can be called by the contract owner.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing sheltered pools from the `MasterChef.sol` Concur token distribution. It is important to ensure `massUpdatePools` is called before making any changes to the list of pools. Additionally, removing pools from this list may also create issues with how `_pid` is produced on each new pool. Therefore, it may be worthwhile to rethink this mechanism such that `_pid` tracks some counter variable and not `poolInfo.length - 1`.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol   # Vulnerability details  ## Impact  The shelter mechanism aims to protect the protocol's users by draining funds into a separate contract in the event of an emergency. However, while users are able to reclaim their funds through the `Shelter.sol` contract, they will still have a deposited balance from the perspective of `ConvexStakingWrapper.sol`.  Because users will only receive their rewards upon depositing/withdrawing their funds due to how the checkpointing mechanism works, it is likely that by draining funds to the `Shelter.sol` contract, users will lose out on any rewards they had accrued up and until that point. These rewards are unrecoverable and can potentially be locked within the contract if the reward token is unique and only belongs to the sheltered `_pid`.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider allowing users to call a public facing `_checkpoint` function once their funds have been drained to the `Shelter.sol` contract. This should ensure they receive their fair share of rewards. Careful consideration needs to be made when designing this mechanism, as by giving users full control of the `_checkpoint` function may allow them to continue receiving rewards after they have withdrawn their LP tokens.  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L107-L119 https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L132-L135   # Vulnerability details  ## Impact  The shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. If this function is called again on the same LP token, the `amountInShelter` value is overwritten, potentially by the zero amount. As a result  its possible that the shelter is put in a state where no users can withdraw from it or only a select few users with a finite number of shares are able to. Once the shelter has passed its grace period, these tokens may forever be locked in the shelter contract.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L107-L119 ``` function enterShelter(uint256[] calldata _pids) external onlyOwner {     for(uint256 i = 0; i<_pids.length; i++){         IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);         uint256 amount = pool.balanceOf(address(this));         pool.withdrawAndUnwrap(amount, false);         IERC20 lpToken = IERC20(             pool.poolInfo(_pids[i]).lptoken         );         amountInShelter[lpToken] = amount;         lpToken.safeTransfer(address(shelter), amount);         shelter.activate(lpToken);     } } ```  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L132-L135 ``` function totalShare(IERC20 _token) external view override returns(uint256) {     // this will be zero if shelter is not activated     return amountInShelter[_token]; } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding to the `amountInShelter[lpToken]` mapping instead of overwriting it altogether. This will allow `enterShelter` to be called multiple times with no loss of funds for the protocol's users.  
# Lines of code   https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L55   # Vulnerability details  # Impact  Any user can withdraw all the funds from the shelter. This is done by calling withdraw repeatedly until all funds are drained. You only need to have a small share.  Even if the `claimed` mapping was checked, there would still be a vulnerability. This is because the `claimed` mapping is updated with the `_to` address, not the `msg.sender` address.  Remediation is to change the `_to` to `msg.sender`. https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L55   
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L73-L82   # Vulnerability details  ## Impact  The `provide` function does not take a `_steps` argument and will instead calculate `addingLiquidity` by truncating amounts under `step`. As a result, if there is an excess of `usdm` such that the truncated amount exceeds the contract's `pool3` truncated balance, then the function will revert due to insufficient `pool3` collateral.  This will prevent guardians from effectively providing liquidity whenever tokens are available. Consider the following example: - The contract has `500000e18` `usdm` tokens and `250000e18` `pool3` tokens. - `addingLiquidity` will be calculated as `500000e18 / 250000e18 * 250000e18`. - The function will attempt to add `500000e18` `usdm` and `pool3` tokens in which there are insufficient `pool3` tokens in the contract. As a result, it will revert even though there is an abundance of tokens that satisfy the `step` amount.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L73-L82 ``` function provide(uint256 _minimumLP) external onlyGuardian {     require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, "<liquidity");     // truncate amounts under step     uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;     // match usdm : pool3 = 1 : 1     uint256[2] memory amounts = [addingLiquidity, addingLiquidity];     usdm.approve(address(usdm3crv), addingLiquidity);     pool3.approve(address(usdm3crv), addingLiquidity);     usdm3crv.add_liquidity(amounts, _minimumLP); } ```  ## Tools Used  Manual code review. Discussions with Taek.  ## Recommended Mitigation Steps  Consider modifying the `provide` function such that a `_steps` argument can be supplied. This will allow guardians to maximise the amount of liquidity provided to the Curve pool.  
# Non critical  ## Lack of events  The method [ConcurRewardPool.pushReward](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L23) should emit an event in order to be detectable by the `_recipient`.  ## Non exploitable reentrancy  The method [ConcurRewardPool.claimRewards](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L34-L37) allow the reentrancy, it seems that it's not vulnerable but it should be protected in order to be resilient.  # Low  ## Contract management risks  The following contracts are `Ownable` and `Pausable`, so the owner could resign while the contract is paused, causing a Denial of Service. Owner resignation while paused should be avoided: - [ConvexStakingWrapper](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L14) - [StakingRewards](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L12)  ## contracts\ConvexStakingWrapper.sol  1. It was found some `transfer`, `approve` or `transferFrom` without checking the boolean result, ERC20 standard specify that the token can return false if this call was not made, so it's mandatory to check the result of these methods.  As following you can see the affected locations: - [ConvexStakingWrapper.sol#L179](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L179) - [ConvexStakingWrapper.sol#L182](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L182)  2. There are a lack of checks in the method [requestWithdraw](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L287) that allow to create a request for `_amount=0` it should be denied in order to avoid possible errors. 
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L73 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L84   # Vulnerability details  ## Impact In `USDMPegRecovery` `deposit` and `withdraw` allow for direct deposits of a specific token (3crv or usdm)  The balances are directly changed and tracked in storage.  `provide` seems to be using the real balances (not the ones store) to provide liquidity. Because of how curve works, you'll be able (first deposit) to provide exactly matching liquidity.  But after (even just 1 or) multiple swaps, the pool will be slightly imbalanced, adding or removing liquidity at that point will drastically change the balances in the contract from the ones tracked in storage.  Eventually users won't be able to withdraw the exact amounts they deposited.  This will culminate with real balances not matching user deposits, sometimes to user advantage and other times to user disadvantage, ultimately to the protocol dismay.    ## Proof of Concept Deposit equal usdm and 3crv LP Do one trade on CRV Withdraw the LP  The real balances are not matching the balances in storage  User tries to withdraw all their balances, inevitable revert  ## Recommended Mitigation Steps Either find a way to price the user contribution based on the LP tokens (use virtual_price) Or simply have people deposit the LP token directly (avoiding the IL math which is a massive headache)  
# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L166   # Vulnerability details  ## Impact `StakingRewards.recoverERC20` rightfully checks against the `stakingToken` being sweeped away. However there's no check against the `rewardsToken` which over time will sit in this contract.  This is the case of an admin privilege, which allows the owner to sweep the rewards tokens, perhaps as a way to rug depositors  ## Proof of Concept calling `StakingRewards.recoverERC20(rewardsToken, rewardsToken.balanceOf(this))` enables the `owner` to sweep the token  ## Recommended Mitigation Steps Add an additional check ```         require(             tokenAddress != address(rewardsToken),             "Cannot withdraw the rewards token"         ); ```  
# Report  * [cache values from external function calls](#cache-values-from-external-function-calls) * [remove unnecessary `safeApprove()`](#remove-unnecessary-safeapprove) * [use constant state variables wherever you can](#use-constant-state-variables-wherever-you-can) * [use immutable state variables wherever you can](#use-immutable-state-variables-wherever-you-can)  ## cache values from external function calls  Instead of calling the same function twice, cache the return value and use that.  Example:   - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L131  Replace the call with `extraToken` which was cached here: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L123  ## remove unnecessary `safeApprove()`  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L242-L244  The second `safeApprove()` call can be removed. After the `deposit()` the `convexBooster`'s allowance should be `0` already.  ## use constant state variables wherever you can  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L56-L57 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L50  ## use immutable state variables wherever you can  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L19-L20 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L22-L24
# Report    * [Non-Critical](#non-critical)     * [emit events for address or important state changes](#emit-events-for-address-or-important-state-changes)     * [don't convert to a smaller bit uint without verifying its value](#dont-convert-to-a-smaller-bit-uint-without-verifying-its-value)   * [Low](#low)     * [use SafeERC20 or check return value of ERC20 functions](#use-safeerc20-or-check-return-value-of-erc20-functions)     * [Shelter donations result in wrong internal balance if fee-on-transfer token is used](#shelter-donations-result-in-wrong-internal-balance-if-fee-on-transfer-token-is-used)     * [Shelter can delay the user's ability to withdraw their funds indefinitely](#shelter-can-delay-the-users-ability-to-withdraw-their-funds-indefinitely)      ## Non-Critical  ### emit events for address or important state changes  Stuff like a guardian being added to the contract or the treasury address being changed. All of that should be accompanied by an event.  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L60-L66 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L83  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L87 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L70  ### don't convert to a smaller bit uint without verifying its value  When converting to a smaller bit uint it might result in a smaller number if the value is higher than the maximum value of that uint type. Before converting it check whether the passed value is small enough.  ```sol require(x <= type(uint192).max); uint192 y = uint192(x); ```  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L235  It shouldn't really be an issue here tho and since I don't expect anybody to have more than `2 ** 196 - 1` tokens to abuse this.  ## Low  ### use SafeERC20 or check return value of ERC20 functions  Some tokens don't revert if a transfer fails. Instead they just return `false`. Since the `ConvexStakingWrapper` contract [potentially works with arbitrary ERC20 tokens](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L129-L136) it's recommended to use SafeERC20 when working with it. Or at least check the return values:  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L179 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L182   ### Shelter donations result in wrong internal balance if fee-on-transfer token is used  In case of a fee-on-transfer ERC20 token the `savedTokens` balance will not represent the actual balance of the contract:  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L34-L35  You can either disable the use of fee-on-transfer tokens for donations or use the actual balance:  ```sol // disable uint oldBalance = _token.balanceOf(address(this)); _token.safeTransferFrom(msg.sender, address(this), _amount); uint newBalance = _token.balanceOf(address(this)); require(_amount == (newBalance - oldBalance)); savedTokens[_token] += _amount; ```  ```sol // use actual balance _token.safeTransferFrom(msg.sender, address(this), _amount); savedTokens[_token] = _token.balanceOf(address(this)); ```  ### Shelter can delay the user's ability to withdraw their funds indefinitely  By repedeatly calling the `activate()` function for a specific token they can extend the timestamp at which withdrawal by users is enabled.  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L39 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L53  With each call `activated[_token]` is reset to `block.timestamp`. Thus the require statement in `withdraw()` will fail for another week. There's nothing stopping the client from calling the function multiple times to keep delaying the withdrawal.  Fix it by not allowing already activated tokens to be reactivated. But with the current implementation of the contract, the client could deactivate and reactivate it.  ```sol function activate(IERC20 _token) external override onlyClient {     require(!activated[_token]);     activated[_token] = block.timestamp;     savedTokens[_token] = _token.balanceOf(address(this));     emit ShelterActivated(_token); } ``` 
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description In the codebase for the protocol **concur**, There was many places where code do suffer from non-critical findings. Following security best practices can help in mitigating these issues.  # Impact code quality.  ## Proof of Concept  ### Unchecked ERC20 operations https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L179 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L182 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L79 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L80  ### floating pragma compiler version on contracts https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/EasySign.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L4 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/VoteProxy.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/interfaces/Iauction.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/interfaces/IShelterClient.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/interfaces/IShelter.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/interfaces/IConcurRewardClaim.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/external/ConvexInterfaces.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/external/CurveInterfaces.sol#L3  ### Unused event or missed emit https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L19  ### Hardcoded addresses for external protocols https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L29 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L31 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L33 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L53-L55 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/library/CvxMining.sol#L8  ### Public visibility functions https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L93 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L127  ### Missing parameter validation https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L82 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L86  ## Tools Used c4udit and manual review.  ## Recommended Mitigation Steps - check for ERC20 operation functions return value or wrap it inside require(). - restrict pragma for compiler version unless it's a library. - each declared event should have a corresponding emit statement or remove it from the codebase.  - consider passing value of external protocol addresses instead for hardcoding them since blockchains differ.  - set functions visibility to external if not used inside the same contract file. - missing input validations can lead to contract redeployment or wasted gas.   
# Handle  kenta   # Vulnerability details  ## Impact The default value of uint256 is 0 and we do not initialize it and save a little bit of gas.   ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L121  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L219  ## Tools Used  ## Recommended Mitigation Steps for (unit256 i; i < length; i++) {}  
# Handle  robee   # Vulnerability details  Title: Unnecessary equals boolean Severity: GAS   Boolean variables can be checked within conditionals directly without the use of equality operators to true/false.          VoteProxy.sol, 21: if (auctioneer.isWinningSignature(_hash, _signature) == true) {    Title: State variables that could be set immutable Severity: GAS  In the following files there are state variables that could be set immutable to save gas.           startBlock in MasterChef.sol         client in Shelter.sol         masterChef in ConvexStakingWrapper.sol         endBlock in MasterChef.sol         rewardNotifier in ConcurRewardPool.sol         concur in MasterChef.sol    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           ConcurRewardPool.sol, _tokens, 35    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           just change to unchecked: MasterChef.sol, _pid, 129         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 219         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 121         change to prefix increment and unchecked: ConcurRewardPool.sol, i, 35    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          ConcurRewardPool.sol, 35         ConvexStakingWrapper.sol, 219         MasterChef.sol, 129         ConvexStakingWrapper.sol, 121    Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          EasySign.sol, tryRecover         ConvexStakingWrapper.sol, _calcRewardIntegral         ConvexStakingWrapper.sol, _checkpoint         ConvexStakingWrapper.sol, _getDepositedBalance         ConvexStakingWrapper.sol, _getTotalSupply         EasySign.sol, recover    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           MasterChef.sol, massUpdatePools         MasterChef.sol, add         ConvexStakingWrapper.sol, addRewards    Title: Unnecessary default assignment Severity: GAS   Unnecessary default assignments, you can just declare and it will save gas and have the same meaning.               StakingRewards.sol (L#22) : uint256 public rewardRate = 0;         ConvexStakingWrapper.sol (L#36) : uint256 public constant CRV_INDEX = 0;         MasterChef.sol (L#51) : uint public totalAllocPoint = 0;         StakingRewards.sol (L#21) : uint256 public periodFinish = 0;    Title: Rearrange state variables Severity: GAS  You can change the order of the storage variables to decrease memory uses.  In USDMPegRecovery.sol,rearranging the storage fields can optimize to: 7 slots from: 8 slots. The new order of types (you choose the actual variables):         1. IERC20         2. IERC20         3. ICurveMetaPool         4. uint256         5. uint256         6. Liquidity         7. address         8. bool     Title: Short the following require messages Severity: GAS  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: StakingRewards.sol, In line 170, Require message length to shorten: 33, The message: Cannot withdraw the staking token         Solidity file: MasterChef.sol, In line 210, Require message length to shorten: 35, The message: safeConcurTransfer: transfer failed    Title: Unused imports Severity: GAS   In the following files there are contract imports that aren't used Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore)          ConvexStakingWrapper.sol, line 9, import "./external/ConvexInterfaces.sol";         USDMPegRecovery.sol, line 7, import { ICurveMetaPool } from "./external/CurveInterfaces.sol";    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           MasterChef.sol, 169: change '_amount > 0' to '_amount != 0'         ConvexStakingWrapper.sol, 262: change '_amount > 0' to '_amount != 0'         MasterChef.sol, 194: change '_amount > 0' to '_amount != 0'         USDMPegRecovery.sol, 74: change 'balance > 0' to 'balance != 0'         ConvexStakingWrapper.sol, 236: change '_amount > 0' to '_amount != 0'         StakingRewards.sol, 94: change 'amount > 0' to 'amount != 0'         StakingRewards.sol, 108: change 'amount > 0' to 'amount != 0'         ConvexStakingWrapper.sol, 184: change '_supply > 0' to '_supply != 0'    Title: Use unchecked to save gas for certain additive calculations that cannot overflow Severity: GAS   You can use unchecked in the following calculations since there is no risk to overflow:          StakingRewards.sol (L#161) - periodFinish = block.timestamp + rewardsDuration;         Shelter.sol (L#53) - require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, "shelter not activated");         ConvexStakingWrapper.sol (L#279) - return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;         Shelter.sol (L#45) - require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, "too late");    Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               EasySign.isWinningSignature (_signature)    Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               ConvexStakingWrapper.sol, _getDepositedBalance, { return deposits[_pid][_account].amount; }         ConvexStakingWrapper.sol, _getTotalSupply, { return IRewardStaking(convexPool[_pid]).balanceOf(address(this)); }    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               ConvexStakingWrapper.sol, _calcRewardIntegral         ConvexStakingWrapper.sol, _getDepositedBalance         ConvexStakingWrapper.sol, _getTotalSupply    Title: Check if amount is not zero to save gas Severity: GAS  The following functions could skip other steps if the amount is 0. (A similar issue: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82)           StakingRewards.sol, recoverERC20    
# Handle  0x510c   # Vulnerability details  ## Impact The function definition of "add" is marked "public". However, it is never directly called by another function in the same contract or in any of its descendants. Consider to mark it as "external" instead.  ## Proof of Concept  MasterChef.sol  function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {         require(_token != address(0), "zero address");         uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;         totalAllocPoint = totalAllocPoint.add(_allocationPoints);         require(pid[_token] == 0, "already registered"); // pid starts from 0         poolInfo.push(             PoolInfo({                 depositToken: IERC20(_token),                 allocPoint: _allocationPoints,                 lastRewardBlock: lastRewardBlock,                 accConcurPerShare: 0,                 depositFeeBP: _depositFee             })         );         pid[_token] = poolInfo.length - 1;     }  ## Tools Used Manual Review  ## Recommended Mitigation Steps It recommended to change the visibility of the function to External to optimize the usage of gas.  
# Handle  wuwe1   # Vulnerability details  # Cache array length in for loops can save gas  ## POC > Caching the array length in the stack saves around 3 gas per iteration.  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L35  ```solidity function claimRewards(address[] calldata _tokens) external override {     for (uint256 i = 0; i < _tokens.length; i++) {         uint256 getting = reward[msg.sender][_tokens[i]];         IERC20(_tokens[i]).safeTransfer(msg.sender, getting);         reward[msg.sender][_tokens[i]] = 0;     } } ```  # Dead code  Remove dead code in  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L19  # public to external  These function can be external.  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L93  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L127  # state can be constant  These state variables can be constant  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L50  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L56  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L57  
# Handle  wuwe1   # Vulnerability details  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L94-L99  ```solidity         address mainPool = IRewardStaking(convexBooster)             .poolInfo(_pid)             .crvRewards;         if (rewards[_pid].length == 0) {             pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;             convexPool[_pid] = mainPool; ```  `convexPool[_pid]` is set to `IRewardStaking(convexBooster).poolInfo(_pid).crvRewards;`  `crvRewards` is a `BaseRewardPool` like this one https://etherscan.io/address/0x8B55351ea358e5Eda371575B031ee24F462d503e#code.  `BaseRewardPool` does not implement `poolInfo`   https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L238  ```solidity IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken ```  Above line calls `poolInfo` of  `crvRewards` which causes revert.  ## Recommended Mitigation Steps  According to Booster's code   https://etherscan.io/address/0xF403C135812408BFbE8713b5A23a04b3D48AAE31#code  ```solidity     //deposit lp tokens and stake     function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){         require(!isShutdown,"shutdown");         PoolInfo storage pool = poolInfo[_pid];         require(pool.shutdown == false, "pool is closed");          //send to proxy to stake         address lptoken = pool.lptoken;         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount); ```  `convexBooster` requires `poolInfo[_pid].lptoken`.  change L238 to   ```solidity IRewardStaking(convexBooster).poolInfo(_pid).lptoken ```  
# Handle  csanuragjain   # Vulnerability details  ## Impact onlyClient can deactivate a token even after deadline is passed and transfer all token balance to itself  ## Proof of Concept 1. Navigate to contract at https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol  2. Observe that token can only be deactivated if activated[_token] + GRACE_PERIOD > block.timestamp. We will bypass this  3. onlyClient activates a token X using the activate function  4. Assume Grace period is crossed such that activated[_token] + GRACE_PERIOD < block.timestamp  5. Now if onlyClient calls deactivate function, it fails with "too late"  6. But onlyClient can bypass this by calling activate function again on token X which will reset the timestamp to latest in activated[_token] and hence onlyClient can now call deactivate function to disable the token and retrieve all funds present in the contract to his own address  ## Recommended Mitigation Steps Add below condition to activate function  ``` function activate(IERC20 _token) external override onlyClient { require(activated[_token]==0, "Already activated");         activated[_token] = block.timestamp;         savedTokens[_token] = _token.balanceOf(address(this));         emit ShelterActivated(_token);     } ```  
# Handle  csanuragjain   # Vulnerability details  ## Low findings  ****  1.  Incorrect Condition Finding:   Contract - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol  In deactivate function, deactivation is rejected even if activated[_token] + GRACE_PERIOD = block.timestamp even when it should be allowed till Grace period.   Remediation: This should be corrected by changing require condition to below:  ``` require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD >= block.timestamp, "too late"); ```  2. Zero Address check missing   Contract - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol  In withdraw function, Zero address checks can be added for **to** address which can prevent losses  Remediation:  ``` require(to!=address(0), "Incorrect address"); ```  3. User fund stuck  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol  In withdraw function, Funds will stuck if user deposited a amount and then isDepositor[_depositor] is set to false by Admin. Now user cannot withdraw the amount since onlyDepositor will fail  Remediation: Withdraw should be independent of onlyDepositor  4. Incorrect PID updation  Contract : https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol  In massUpdatePools function, pid 0 should not be updated as poolInfo[_pid] is filled by dummy zero address token in constructor  ``` constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {         startBlock = _startBlock;         endBlock = _endBlock;         concur = _concur;         poolInfo.push(             PoolInfo({             depositToken: IERC20(address(0)),             allocPoint : 0,             lastRewardBlock : _startBlock,             accConcurPerShare : 0,             depositFeeBP : 0         }));     } ```  Remediation: The loop in massUpdatePools function should start with value 1 instead of 0  5. Insecure transfer method used  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol  In safeConcurTransfer function, transfer function is used  Remediation: use safeTransfer instead of transfer which is more secure  6. User funds can be added to 0 or non-existent pid with 0 rewards  Contract : https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol  a. In deposit & withdraw function, both accepts 0 pid which is zero address pool added by constructor, which means user funds would get added to incorrect pool.   b. Similarly non existent pid will also be accepted by both of these functions.   c. Offcourse these incorrect pid will not incur any reward since pool.accConcurPerShare will always be 0 which means user amount is added to a pool without any reward  Remediation: Add a check to see if pid>0 and pid<poolInfo.length  7. Extra reward will be given to users  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol  In notifyRewardAmount function, Since block.timestamp value will change slightly while calculating periodFinish (when compared to lastUpdateTime) so periodFinish will actually become lastUpdateTime+rewardsDuration+x which is incorrect and would impact rewardPerToken by making it slightly higher  ``` lastUpdateTime = block.timestamp;         periodFinish = block.timestamp + rewardsDuration; ```  Remediation: Store block.timestamp locally and then use local variable to update periodFinish and lastUpdateTime  8. Missing condition:  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol  In addRewards function, it is not checked if extraToken is crv. Only cvx check is present  Remediation: Add below check  ``` if (extraToken == crv) {rewards[_pid][CRV_INDEX].pool = extraPool;} ```  9. rewards entries are made even for incorrect/non-existent pid  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol  Non existent pid will create crv and cvx entries for rewards[_pid] since rewards[_pid].length == 0  Remediation: Revert if mainPool is zero address, require (mainPool!=address(0));  ## Non critical findings  10. Missing events  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol  In claimRewards function observe that No emit event is fired after successful reward claim by user. Ideally a new event should be triggered showing that reward was claimed successfully by user  11. Reward lost  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol  In notifyRewardAmount function, if Admin added a reward 100 once block.timestamp >= periodFinish. Now if Admin decides to add 200 rewards calling this function at block.timestamp >= periodFinish then contract considers total reward as 200 and discards the reward 100 added initially  ``` if (block.timestamp >= periodFinish) {             rewardRate = reward / rewardsDuration; // old reward is not considered         } ```  
# Handle  wuwe1   # Vulnerability details  ## Impact `execute` will revert when `msg.value > 0`  ## Proof of Concept Lacking `payable` mutability specifier.  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/VoteProxy.sol#L28-L35  ```solidity     function execute(         address _to,         uint256 _value,         bytes calldata _data     ) external onlyOwner returns (bool, bytes memory) {         (bool success, bytes memory result) = _to.call{value: _value}(_data);         return (success, result);     } ```   ## Recommended Mitigation Steps  Add `payable` mutability specifier.  
# Handle  Heartless   # Vulnerability details  ## Impact external visibility uses less gas than public visibility. addRewards is never called internally in this project so does not need public visibility. addRewards was public in the original source from convex because they called addRewards() internally in the initialize() function, which ConvexStakingWrapper does not have.  ## Proof of Concept Line 93 in ConvexStakingWrapper.sol  ## Tools Used  ## Recommended Mitigation Steps Change addRewards visibility to external.  
