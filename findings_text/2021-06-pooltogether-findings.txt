# Handle  shw   # Vulnerability details  ## Impact  At line 213 of `ATokenYieldSource`, `depositToken()` can be replaced by `_tokenAddress()` to save gas since the former is a public function, while the latter is an internal function.  ## Proof of Concept  Referenced code: [ATokenYieldSource.sol#L213](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/ATokenYieldSource.sol#L213)  ## Recommended Mitigation Steps  Change `depositToken()` to `_tokenAddress()`.  
# Handle  shw   # Vulnerability details  ## Impact  The function `_depositToAave` of `ATokenYieldSource` calls `_lendingPool` and `_tokenAddress` twice, both of which include function calls to external contracts. Thus, storing the first results into local variables and reuse them for the second time could help save gas.  ## Proof of Concept  Referenced code: [ATokenYieldSource.sol#L175-L182](https://github.com/pooltogether/aave-yield-source/blob/main/contracts/yield-source/ATokenYieldSource.sol#L175-L182)  ## Recommended Mitigation Steps  Store the result of `_tokenAddress()` and `_lendingPool()` to local variables and resue them.  
# Handle  shw   # Vulnerability details  ## Impact  The `redeemToken` function in `IdleYieldSource` uses `redeemedShare` instead of `redeemAmount` as the input parameter when calling `redeemIdleToken` of the Idle yield source. As a result, users could get fewer underlying tokens than they should.  ## Proof of Concept  When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the `tokenPriceWithFee()` is greater than `ONE_IDLE_TOKEN`, and thus `redeemedShare` is less than `redeemAmount`, causing users to get fewer underlying tokens than expected.  Referenced code: [IdleYieldSource.sol#L129-L131](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L129-L131)  ## Recommended Mitigation Steps  Change `redeemedShare` to `redeemAmount` at line 131.  
# Handle  shw   # Vulnerability details  ## Impact  The `YearnV2YieldSource` contract prevents the `supplyTokenTo`, `redeemToken`, and `sponsor` functions from being reentered by applying a `nonReentrant` modifier. Since these contracts share a similar logic, adding a `nonReentrant` modifier to these functions in all of the yield source contracts is reasonable. However, the same protection is not seen in other yield source contracts.  ## Proof of Concept  A `nonReentrant` modifier in the following functions is missing: 1. The `sponsor` function of `ATokenYieldSource` 2. The `supplyTokenTo` and `redeemToken` function of `BadgerYieldSource` 3. The `sponsor` function of `IdleYieldSource` 4. The `supplyTokenTo` and `redeemToken` function of `SushiYieldSource`  Referenced code: [ATokenYieldSource.sol#L233](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/ATokenYieldSource.sol#L233) [BadgerYieldSource.sol#L43](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L43) [BadgerYieldSource.sol#L57](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L57) [IdleYieldSource.sol#L150](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L150) [SushiYieldSource.sol#L47](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L47) [SushiYieldSource.sol#L66](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L66)  ## Recommended Mitigation Steps  Add a `nonReentrant` modifier to these functions. For `BadgerYieldSource` and `SushiYieldSource` contracts, make them inherit from Openzeppelin's `ReentrancyGuardUpgradeable` to use the `nonReentrant` modifier.  
# Handle  shw   # Vulnerability details  ## Impact  The `PrizePool` contract does not implement the `onERC721Received` function, which is considered a best practice to transfer ERC721 tokens from contracts to contracts. The absence of this function could prevent `PrizePool` from receiving ERC721 tokens from other contracts via `safeTransferFrom`.  ## Proof of Concept  Referenced code: [PrizePool.sol](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol)  ## Recommended Mitigation Steps  Consider adding an implementation of the `onERC721Received` function in `PrizePool`.  
# Handle  shw   # Vulnerability details  ## Impact  In the function `awardExternalERC721` of contract `PrizePool`, when awarding external ERC721 tokens to the winners, the `transferFrom` keyword is used instead of `safeTransferFrom`. If any winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be locked.  ## Proof of Concept  Referenced code: [PrizePool.sol#L602](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol#L602)  ## Recommended Mitigation Steps  Consider changing `transferFrom` to `safeTransferFrom` at line 602. However, it could introduce a DoS attack vector if any winner maliciously rejects the received ERC721 tokens to make the others unable to get their awards. Possible mitigations are to use a `try/catch` statement to handle error cases separately or provide a function for the pool owner to remove malicious winners manually if this happens.  
# Handle  shw   # Vulnerability details  ## Impact  SafeMath is not completely used at the following lines of yield source contracts, which could potentially cause arithmetic underflow and overflow: 1. line 78 in `SushiYieldSource` 2. line 67 in `BadgerYieldSource` 3. line 91 and 98 in `IdleYieldSource`  ## Proof of Concept  Referenced code: [SushiYieldSource.sol#L78](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L78) [BadgerYieldSource.sol#L67](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L67) [IdleYieldSource.sol#L91](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L91) [IdleYieldSource.sol#L98](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L98)  ## Recommended Mitigation Steps  Use the SafeMath library functions in the above lines.  
# Handle  shw   # Vulnerability details  ## Impact  In the contracts `BadgerYieldSource` and `SushiYieldSource`, the return values of ERC20 `transfer` and `transferFrom` are not checked to be `true`, which could be `false` if the transferred tokens are not ERC20-compliant (e.g., `BADGER`). In that case, the transfer fails without being noticed by the calling contract.  ## Proof of Concept  If warden's understanding of the `BadgerYieldSource` is correct, the `badger` variable should be the `BADGER` token at address `0x3472a5a71965499acd81997a54bba8d852c6e53d`. However, this implementation of `BADGER` is not ERC20-compliant, which returns `false` when the sender does not have enough token to transfer (both for `transfer` and `transferFrom`). See the [source code on Etherscan](https://etherscan.io/address/0x3472a5a71965499acd81997a54bba8d852c6e53d#code) (at line 226) for more details.  Referenced code: [BadgerYieldSource.sol#L44](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L44) [BadgerYieldSource.sol#L79](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L79) [SushiYieldSource.sol#L48](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L48) [SushiYieldSource.sol#L89](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L89)  ## Recommended Mitigation Steps  Use the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from Openzeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.  
# Handle  shw   # Vulnerability details  ## Impact  Some contracts (e.g., `PrizePool`) use an unlocked pragma (e.g., `pragma solidity >=0.6.0 <0.7.0;`) which is not fixed to a specific Solidity version. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler version with which they have been tested the most.  ## Proof of Concept  Referenced code: Please use `grep -R pragma .` to find the unlocked pragma statements.  ## Recommended Mitigation Steps  Lock pragmas to a specific Solidity version. Consider the compiler bugs in the following lists and ensure the contracts are not affected by them. It is also recommended to use the latest version of Solidity when deploying contracts (see [Solidity docs](https://docs.soliditylang.org/en/v0.8.4/#solidity)).  Solidity compiler bugs: [Solidity repo - known bugs](https://github.com/ethereum/solidity/blob/develop/docs/bugs.json) [Solidity repo - bugs by version](https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json)  
# Handle  shw   # Vulnerability details  ## Impact  Functions (e.g., `supplyTokenTo`, `redeemToken`) in the `BadgerYieldSource` and `SushiYieldSource` can be declared `external` instead of `public` to save gas.  ## Proof of Concept  Referenced code: [BadgerYieldSource.sol#L26](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L26) [BadgerYieldSource.sol#L32](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L32) [BadgerYieldSource.sol#L43](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L43) [BadgerYieldSource.sol#L57](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L57) [SushiYieldSource.sol#L29](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L29) [SushiYieldSource.sol#L35](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L35) [SushiYieldSource.sol#L47](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L47) [SushiYieldSource.sol#L66](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L66)  ## Recommended Mitigation Steps  Change the keyword `public` to `external`.  
# Handle  tensors   # Vulnerability details  ## Impact Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given.  For example, say I deposit 1 token, expecting 1 share in return. On L95, if the totalunderlying assets is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares.    ## Proof of Concept https://github.com/sunnyRK/IdleYieldSource-PoolTogether/blob/6dcc419e881a4f0f205c07c58f4db87520b6046d/contracts/IdleYieldSource.sol#L95  https://github.com/sunnyRK/IdleYieldSource-PoolTogether/blob/6dcc419e881a4f0f205c07c58f4db87520b6046d/contracts/IdleYieldSource.sol#L106  ## Recommended Mitigation Steps Implement mantissa calculations like in the contract for the AAVE  yield.  
# Handle  tensors   # Vulnerability details  ##Impact Uninitialized variables initialize to 0 automatically. No need to explicitly initialize it.   ##Proof of concept https://github.com/pooltogether/aave-yield-source/blob/bc65c875f62235b7af55ede92231a495ba091a47/contracts/yield-source/ATokenYieldSource.sol#L141  ##Recommended mitigation steps Replace with: `uint256 shares;`  
# Handle  cmichel   # Vulnerability details  In `PrizePool._updateCreditBalance` the `CreditBurned` event is emitted even if nothing was burned. Not emitting this event when nothing happened can save gas and also seems better semantically.  
# Handle  cmichel   # Vulnerability details  The credit is accrued twice in `award`. The first accrual happens implicitly when calling `_mint` through the `ControlledToken(controlledToken).controllerMint` call which then performs the `PrizePool.beforeTokenTransfer` hook which accrues credit. Then the explicit accrual is done again. It should be enough to only add the `extraCredit` without doing another accrual (calling `_updateCreditBalance(..., newBalance= _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra)))` instead).  
# Handle  cmichel   # Vulnerability details  `SushiYieldSource` should approve the SushiBar once during initialization with the max value. This saves gas on every `supplyTokenTo` call as the approval can be removed from there.  
# Handle  cmichel   # Vulnerability details  `ATokenYieldSource` should approve the lending contract once during initialization with the max value. This saves gas on every `supplyTokenTo/_depositToAave` call as the approval can be removed from there.  
# Handle  cmichel   # Vulnerability details  One can withdraw the entire `PrizePool` deposit by circumventing the timelock. Assume the user has no credits for ease of computation: - user calls `withdrawWithTimelockFrom(user, amount=userBalance)` with their entire balance. This "mints" an equivalent `amount` of `timelock` and resets `_unlockTimestamps[user] = timestamp = blockTime + lockDuration`. - user calls `withdrawWithTimelockFrom(user, amount=0)` again but this time withdrawing `0` amount. This will return a `lockDuration` of `0` and thus `unlockTimestamp = blockTime`. The inner `_mintTimelock` now resets `_unlockTimestamps[user] = unlockTimestamp` - As `if (timestamp <= _currentTime()) ` is true, the full users amount is now transferred out to the user in the `_sweepTimelockBalances` call.  ## Impact  Users don't need to wait for their deposit to contribute their fair share to the prize pool. They can join before the awards and leave right after without a penalty which leads to significant issues for the protocol. It's the superior strategy but it leads to no investments in the strategy to earn the actual interest.  ## Recommended Mitigation Steps  The unlock timestamp should be increased by duration each time, instead of being reset to the duration.  
# Handle  cmichel   # Vulnerability details  `YearnV2YieldSource._withdrawFromVault` uses a wrong subtraction. When withdrawing from the `vault` one redeems `yTokens` for `token`s, thus the `token` balance of the contract should increase after withdrawal. But the contract subtracts the `currentBalance` from the `previousBalance`:  ```solidity uint256 yShares = _tokenToYShares(amount); uint256 previousBalance = token.balanceOf(address(this)); // we accept losses to avoid being locked in the Vault (if losses happened for some reason) if(maxLosses != 0) {     vault.withdraw(yShares, address(this), maxLosses); } else {     vault.withdraw(yShares); } uint256 currentBalance = token.balanceOf(address(this)); // @audit-issue this seems wrong return previousBalance.sub(currentBalance); ```  ## Impact  All vault withdrawals fail due to the integer underflow as the `previousBalance` is less than `currentBalance`. Users won't be able to get back their investment.  ## Recommended Mitigation Steps  It should return `currentBalance > previousBalance ? currentBalance - previousBalance : 0`  
# Handle  cmichel   # Vulnerability details  The `ATokenYieldSource.redeemToken` function burns `aTokens` and sends out underlying, however, it's used in a reverse way in the code: The `balanceDiff` is used as the `depositToken` that is transferred out but it's computed on the **aTokens** that were burned instead of on the `depositToken` received.  ## Impact  It should not directly lead to issues as aTokens are 1-to-1 with their underlying but we still recommend doing it correctly to make the code more robust against any possible rounding issues.  ## Recommended Mitigation Steps  Compute `balanceDiff` on the underyling balance (depositToken), not on the aToken. Subtract the actual burned aTokens from the user shares.  
# Handle  cmichel   # Vulnerability details   When suppling to the `BadgerYieldSource`, some `amount` of `badger` is deposited to `badgerSett` and one receives `badgerSett` share tokens in return which are stored in the `balances` mapping of the user. So far this is correct.  The `balanceOfToken` function should then return the redeemable balance in `badger` for the user's `badgerSett` balance. It computes it as the pro-rata share of the user balance (compared to the total-supply of `badgerSett`) on the `badger` in the vault:  ```solidity balances[addr].mul(   badger.balanceOf(address(badgerSett)) ).div(   badgerSett.totalSupply() ) ```  However, `badger.balanceOf(address(badgerSett))` is only a small amount of badger that is deployed in the vault ("Sett") due to most of the capital being deployed to the _strategies_. Therefore, it under-reports the actual balance:  > Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply. [Badger Docs](https://badger-finance.gitbook.io/badger-finance/technical/setts/sett-contract)  ## Impact  Any contract or user calling the `balanceOf` function will receive a value that is far lower than the actual balance. Using this value as a basis for computations will lead to further errors in the integrations.  ## Recommended Mitigation Steps  It should use [`badgerSett.balance()`](https://github.com/Badger-Finance/badger-system/blob/2b0ee9bd77a2cc6f875b9b984ae4dfe713bbc55c/contracts/badger-sett/Sett.sol#L126) instead of `badger.balanceOf(address(badgerSett))` to also account for "the balance in the Sett, the Controller, and the Strategy".  
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `StakePrizePool.initialize`: `address _stakeToken` not checked for non-zero or contract - `ControlledToken.initialize`: `address controller` not checked for non-zero or contract - `PrizePool.withdrawReserve`: `address to` not checked for non-zero, funds will be lost when sending to zero address - `ATokenYieldSource.initialize`: `address _aToken, _lendingPoolAddressesProviderRegistry` not checked for non-zero or contract - `BadgerYieldSource.initialize`: `address badgerSettAddr, badgerAddr` not checked for non-zero or contract - `SushiYieldSource.constructor`: `address _sushiBar, _sushiAddr` not checked for non-zero or contract  ## Impact  Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps  Validate the parameters.  
# Handle  pauliax   # Vulnerability details  ## Impact contract ATokenYieldSource function _depositToAave returns 0 if successful. However, this value is not checked nor used anywhere. As this function is internal it would probably be better to remove this unnecessary return to save some gas and eliminate confusion.  ## Recommended Mitigation Steps refactor function _depositToAave to return void.  
# Handle  JMukesh   # Vulnerability details  ## Impact To track off-chain data it is necessary to use events  ## Proof of Concept  In  ATokenYieldSource.sol, IdleYieldSource.sol, yearnV2yieldsource  : events are emmitted in supplyTokenTo(), redeemToken() sponsor(), but not in  BadgerYieldsource.sol and shushiyieldsource.sol     ## Tools Used  Manual analysis  ## Recommended Mitigation Steps use events   
# Handle  hrkrshnn   # Vulnerability details  # General Gas optimization  ## Upgrade to at least 0.8.4 (even better is 0.8.5)  The following should lead to better gas savings:    - The inliner should decrease runtime gas.   - Inbuilt safemath instead of openzeppelin safemath should save some gas.   - Various improvement in the expression simplifier in the compiler throughout (0.7.0 - 0.8.5)     which should decrease both runtime and deploy time costs. (I'm assuming that the project     currently uses 0.6.12, since the compiler version was not explicitly specified.)  Of course, these improvements comes when optimizer is enabled, preferably with a high `--optimize-runs` value.  Note that the `inliner` in particular can be quite useful for the contract, since the contracts sometimes generously chains small functions.  ## Use custom errors instead of large revert strings  Saves both deploy time and runtime gas (runtime gas is only relevant when the revert condition is met.)  Need at least solidity 0.8.4 for this feature.  ### Use shorter revert strings  If you decide to not use custom errors, then try to use revert strings of size at most 32 characters.  For one, shorter strings would save deploy cost (one time saving of 200 gas per byte / character decreased). Also strings more than 32 bytes requires an additional `mstore`, two additional `push`, and an `add`. Roughly, 18 more gas during runtime (when revert condition is met).  Example string (33 bytes), from ControlledToken.sol  ``` solidity uint256 decreasedAllowance = allowance(_user, _operator).sub(_amount, "ControlledToken/exceeds-allowance"); ```  # Specific Gas optimizations  ## Use `immutable`  For state variables that are only assigned in constructors, change it to `immutable`.  This saves an `sload` each time the variable is accessed. Can save around 2100 gas (or 100 depending on warm / cold.)  Examples:  ### StakePrizePool.sol  ``` diff modified   contracts/StakePrizePool.sol @@ -8,7 +8,7 @@ import "../PrizePool.sol";   contract StakePrizePool is PrizePool {  -  IERC20Upgradeable private stakeToken; +  IERC20Upgradeable immutable private stakeToken;     event StakePrizePoolInitialized(address indexed stakeToken); ```  ### ControlledToken.sol  ``` diff contract ControlledToken is ERC20PermitUpgradeable, ControlledTokenInterface {     /// @notice Interface to the contract responsible for controlling mint/burn -  TokenControllerInterface public override controller; +  TokenControllerInterface public immutable override controller; ```  ### yield-source/YearnV2YieldSource.sol  ``` diff @@ -24,7 +24,7 @@ contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeabl      /// @notice Yearn Vault which manages `token` to generate yield      IYVaultV2 public vault;      /// @dev Deposit Token contract address -    IERC20Upgradeable internal token; +    IERC20Upgradeable immutable internal token;      /// @dev Max % of losses that the Yield Source will accept from the Vault in BPS      uint256 public maxLosses = 0; // 100% would be 10_000 ```  This change would likely require changing the initialization pattern. See the section below for details.  Similarly, several such variables can be changed. Not listing everything here.  ## Avoiding the `initialize` pattern  If elements can be initialized in the constructor, or via calls to internal functions in constructor, instead of the public `initialize` function, it should be possible to save deployment costs. On top of that, since the `initialize` function won't be part of the function dispatch in the contract, one could save some gas at run time for some calls (saves approximately two `push`, an `eq` and a `jumpi`.)  Another benefit for this is that several state variables can be converted to immutables. Again, saves `sload` costs during runtime.  Also, it might also be possible to change `initialize` from `public` to `internal`.  ## `_msgSender()` (Possible micro optimization)  Use `msg.sender` instead of `_msgSender()`. The latter might not be inlined by the compiler. (This is for cases where `_msgSender()` function simply returns `msg.sender`.) Can save around 30 gas (2 `JUMP`, plus some `PUSH` and some stack operations.)  Also, the contracts seem to mix `_msgSender()` and `msg.sender`, for example in `PrizePool.sol`. This could be avoided.  ## Use `decreaseAllowance` in ControllerToken.sol  ``` diff @@ -58,8 +58,7 @@ contract ControlledToken is ERC20PermitUpgradeable, ControlledTokenInterface {    /// @param _amount Amount of tokens to burn    function controllerBurnFrom(address _operator, address _user, uint256 _amount) external virtual override onlyController {      if (_operator != _user) { -      uint256 decreasedAllowance = allowance(_user, _operator).sub(_amount, "ControlledToken/exceeds-allowance"); -      _approve(_user, _operator, decreasedAllowance); +      decreaseAllowance(_user, _operator, _amount);      }      _burn(_user, _amount);    } ```  Will be slightly more gas efficient than the first once.  # General comments  ## Try to avoid `super` if possible  For example, in Ticket.sol:  ``` solidity   public   virtual   override   initializer {   super.initialize(_name, _symbol, _decimals, _controller); ```  The above usage of `super` is unnecessary. Unless you are dealing with multiple inheritance, where `super` is absolutely required, there is no need to use super, instead of statically specifying the name of the parent contract. There is however no performance penalty in using `super` instead of a static call to the parent.  ## Several `balance` related function can be made `view`?  In PrizePool, the function `function balance() external returns (uint256)` can perhaps be made `view`. This would also mean that a few other internal functions should be made `view`, such as `_balance`.   
# Handle  JMukesh   # Vulnerability details  ## Impact Using memory array parameters (e.g. uint[] memory) as function parameters can be tricky in Solidity, because an attack is possible with a very large array which will overlap with other parts of the memory.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L219  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L639   This an example to show the exploit:  // based on https://github.com/paradigm-operations/paradigm-ctf-2021/blob/master/swap/private/Exploit.sol  pragma solidity ^0.4.24; // only works with low solidity version  contract test{     struct Overlap {         uint field0;     }     event log(uint);    function mint(uint[] memory amounts) public  returns (uint) {   // this can be in any solidity version        Overlap memory v;        v.field0 = 1234;        emit log(amounts[0]); // would expect to be 0 however is 1234        return 1;      }    function go() public { // this part requires the low solidity version       uint x=0x800000000000000000000000000000000000000000000000000000000000000; // 2^251       bytes memory payload = abi.encodeWithSelector(this.mint.selector, 0x20, x);       bool success=address(this).call(payload);   } }     ## Tools Used  manual analysis  ## Recommended Mitigation Steps check the array length before using it  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The _depositInVault() function for Yearn yield source uses ERC20 safeApprove() from OpenZeppelin's SafeERC20 library to give maximum allowance to the Yearn Vault address if the current allowance is less than contract’s token balance.  However, the safeApprove function prevents changing an allowance between non-zero values to mitigate a possible front-running attack. It reverts if that is the case. Instead, the safeIncreaseAllowance and safeDecreaseAllowance functions should be used. Comment from the OZ library for this function: “// safeApprove should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and ‘safeDecreaseAllowance'"  Impact: If the existing allowance is non-zero (say, for e.g., previously the entire balance was not deposited due to vault balance limit resulting in the allowance being reduced but not made 0), then safeApprove() will revert causing the user’s token deposits to fail leading to denial-of-service. The condition predicate indicates that this scenario is possible.  ## Proof of Concept  Reference: See similar Medium-severity finding M03 here: https://blog.openzeppelin.com/1inch-exchange-audit/  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L171-L173  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6842518b1b71fac9a21c7d94ec521992cff266b5/contracts/token/ERC20/utils/SafeERC20.sol#L44-L57   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use safeIncreaseAllowance() function instead of safeApprove().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Most contracts use initialize() functions instead of constructor given the delegatecall proxy pattern. While most of them emit an event in the critical initialize() functions to record the init parameters for off-chain monitoring and transparency reasons, Ticket.sol nor its base class ControlledToken.sol emit such an event in their initialize() functions.  Impact: These contracts are initialized but their critical init parameters (name, symbol, decimals and controller address) are not logged for any off-chain monitoring.  ## Proof of Concept  See similar Medium-severity Finding M01 in OpenZeppelin’s audit of UMA protocol: https://blog.openzeppelin.com/uma-audit-phase-4/  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/Ticket.sol#L24-L37  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/ControlledToken.sol#L22-L36  Examples of event emission: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L239-L243  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/YieldSourcePrizePool.sol#L47   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit an initialised event in Ticket.sol and ControlledToken.sol logging their init parameters.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Most contracts use the delegateCall proxy pattern and hence their implementations require the use of initialize() functions instead of constructors. This requires derived contracts to call the corresponding init functions of their inherited base contracts. This is done in most places except a few.  Impact: The inherited base classes do not get initialized which may lead to undefined behavior.   ## Proof of Concept  Missing call to __ReentrancyGuard_init: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/ATokenYieldSource.sol#L99-L102  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L59-L61  Missing call to__ERC20_init: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L59-L61  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L83-L86   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add missing calls to init functions of inherited contracts.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level calls call/delegatecall/staticcall return true even if the account called is non-existent (per EVM design). Solidity documentation warns: "The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.”  The staticcall here will return True even if the _yieldSource contract doesn't exist at any incorrect-but-not-zero address, e.g. EOA address, used during initialization by accident. Impact: The hack, as commented, to check if it’s an actual yield source contract will fail if the address is indeed a contract account which doesn’t implement the depositToken function. However, if the address is that of an EOA account, the check will pass here but will revert in all future calls to the yield source forcing contract redeployment after the pool is active. Users will not be able to interact with the pool and abandon it.  ## Proof of Concept  https://docs.soliditylang.org/en/v0.8.6/control-structures.html#error-handling-assert-require-revert-and-exceptions  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/YieldSourcePrizePool.sol#L41-L45  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  A contract existence check should be performed on _yieldSource prior to the depositToken function existence hack for determining yield source contract.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The modifier onlyControlledToken is used for functions that allow the controlledToken address as a parameter to ensure that only whitelisted tokens (ticket and sponsorship) are provided. This is used in all functions except calculateEarlyExitFee().  Impact: The use of a non-whitelisted controlledToken will result in calls to potentially malicious token contract and cause undefined behavior for the `from` user address specified in the call.  ## Proof of Concept  Missing modifier: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L729-L747  Modifier: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1105-L1110  All other functions which accept controlledToken parameter have modifier onlyControlledToken: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L275  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L299  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L327  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L378  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L418  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L498  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L888  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L903  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add missing modifier onlyControlledToken to calculateEarlyExitFee().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Named return values in multiple functions are never used in favor of explicit returns.   Impact: This affects readability/auditability at the least and could potentially result in unexpected values being returned along paths with no explicit returns.  ## Proof of Concept  Unused in favor of explicit return:   https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L717-L726  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L741-L744  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L770  Used without explicit return:  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L923-L930  Used with explicit return:  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L944-L947   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unused named returns where unnecessary. Be consistent in using named vs explicit returns.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  If a function has multiple modifiers they are executed in the order specified. If checks or logic of modifiers depend on other modifiers this has to be considered in their ordering. PrizePool has functions with multiple modifiers with one of them being nonreentrant which prevents reentrancy on the functions. This should ideally be the first one to prevent even the execution of other modifiers in case of reentrancies.  While there is no obvious vulnerability currently with nonreentrant being the last modifier in the list, it is safer to place it in the first. This is of slight concern with the deposit functions which have the canAddLiquidity() modifier (before nonreentrant) that makes external calls to get totalSupply of controlled tokens.  ## Proof of Concept  For reference, see similar finding in Consensys’s audit of Balancer : https://consensys.net/diligence/audits/2020/05/balancer-finance/#switch-modifier-order-in-bpool  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L275-L277  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L299-L301   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Switch modifier order to consistently place the nonreentrant modifier as the first one to run so that all other modifiers are executed only if the call is nonreentrant.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Caching sushiAddr and sushiBar in local variables right at the beginning of supplyTokenTo() (similar to what's done in redeemToken) can save 100 gas from repeat SLOADs for each of them for a total savings of 200.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/SushiYieldSource.sol#L48-L51  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Caching sushiAddr and sushiBar in local variables at the beginning of supplyTokenTo() and use those instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  maxLosses state variable is used in two places in _withdrawFromVault(). It can be cached in a local variable  at the beginning of the function to save 100 gas from one repeated SLOAD.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L187-L188  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache maxLosses in a local variable at the beginning of the function and use that instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  token state variable is used in two places in _withdrawFromVault(). It can be cached in a local variable  at the beginning of the function to save 100 gas from one repeated SLOAD.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L185  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L192   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache token in a local variable  at the beginning of the function and use that instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  token state variable is used in three places in _depositInVault(). It can be cached in a local variable  at the beginning of the function to save 200 gas from two repeated SLOADs.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L171-L172  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache token in a local variable  at the beginning of the function and use that instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Using parameter _vault instead of SLOAD of state variable vault in the call to safeApprove() leads to gas savings of 100.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L87  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L67  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L25   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Using parameter _vault instead of state variable vault in the call to safeApprove()  
# Handle  0xRajeev   # Vulnerability details  ## Impact  YearnV2YieldSource initialize does a zero-address check for value address to detect if it has already been initialized. This is an unnecessary check because vault address default value is zero, it is not initialized/set anywhere else and the initializer modifier will prevent the calling of initialize() a second time. So vault is guaranteed to be zero in initialize().  The impact is gas wastage from an additional SLOAD of vault state variable and the require() check.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L25  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L73  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the zero-address check for vault.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  State variables badger and badgerSett addresses are read two and four times respectively in supplyTokenTo(). Caching them in local variables at the beginning of the function and using those local variables can save 400 gas from avoiding 3 repeated SLOADs for badgerSett and 1 repeated SLOAD for badger.  Impact: Gas savings of 400  ## Proof of Concept  Two badger reads: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L44-L45  Four badgerSett reads:   https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L45  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L47  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L48  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L49  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache badger and badgerSett state variables in local variables at the beginning of the function and use those local variables instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The loop iteration in _tokenTotalSupply() ends when currentToken matches _tokens.end() where _tokens is a state variable.  Impact: Checking against the state variable for every iteration costs 100 gas per iteration. Even with only two controlled tokens (tickets & sponsorship), this costs 100 more than caching this in a local memory variable and using that within the while predicate.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1059  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L177   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _tokens.end() in a local memory variable before the loop and using that within the while predicate.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  When _tokenTotalSupply() adds up the supplies of all controlled tokens, it checks and skips zero-address tokens. Instead of checking for zero-address every time for every call to _tokenTotalSupply() from captureAwardBalance() and every deposit via canAddLiquidity modifier, preventing zero-address controlled-token addresses from being added in _addControlledToken() during initialization will avoid these checks.  Impact: All deposit calls which cost 0.5M gas currently will be impacted by these unnecessary checks if we instead perform it one time during the addition of tokens in initialization.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1059  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L228-L230  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move zero-address check from time of use to time of adding the tokens into the list in initialize().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  State variable maxTimelockDuration is read twice on consecutive lines 723 and 724 of function _calculateTimelockDuration(). Caching it in a local variable will save 100 gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L723-L724   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache maxTimelockDuration in a local variable in the beginning of the function.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Mapping state variable value _timelockBalances[user] is read on consecutive lines 655 and 656 resulting in 2 SLOADS (2100 + 100 gas).   Impact: Caching this in a local variable would save ~= 100 gas savings per user iteration (by converting the use of the second 100-gas costing SLOAD to 1 MSTORE and 1 MLOAD both of which only cost 3 gas). If there are 1000 users in a call to sweepTimelockBalances(), this could be significant savings of 100,000 gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L655-L656   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _timelockBalances[user] in a local variable before using on lines 655 and 656.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Cache _currentAwardBalance state variable in a local variable for computation to save gas. 4 SLOADs + 1 SSTORE can be reduced to 1 SLOAD and 1 STORE.   Impact: Saves 300 gas from avoid 3 SLOADs because each SLOAD to already accessed storage slot costs 100.  ## Proof of Concept  2 SLOADs: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L456  1 SSTORE + 1 SLOAD: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L465  1 SLOAD: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L470   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _currentAwardBalance in a local variable in the beginning, use that for computation/return and one updation to state variable at the end.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The canAddLiquidity modifier, which is used on all deposits (each deposit costs 0.5M gas), appears to be an expensive modifier because it calculates the sum of all the supplies across controlled tokens (by making external CALLs) and adding that up with reserve and timelock supplies. While this is an extensible implementation that supports arbitrary number of controlled tokens via mapped singly linked list, the prize pools typically have only two controlled tokens: tickets and sponsorship.   Impact: deposits currently cost 0.5M gas.  ## Proof of Concept  https://docs.pooltogether.com/protocol/overview#gas-usage  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L276  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L300  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1119-L1122  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1069-L1072  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1054-L1064  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider gas profiling a fast-path calculation by keeping a separate state variable that tracks the sum of timelock+reserve along with all deposits made towards controlled token supplies and comparing new deposits with that state variable instead of reevaluating totals during each deposit. The extra SLOADs, CALLs and other expensive operations (in linked list and other logic) during reevaluation may add up to more than updating this proposed new state variable across different operations.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Where possible, use equivalent function parameters or local variables in event emits instead of state variables to prevent expensive SLOADs. Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase.  ## Proof of Concept  The Initialized event in PrizePool uses state variables maxExitFeeMantissa and maxTimelockDuration instead of using the equivalent function parameters _maxExitFeeMantissa and _maxTimelockDuration which were just used to set these state variables. Using them instead will save 2 extra SLOADs, leading to gas savings of 200.  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L239-L243  The StakePrizePoolInitialized event uses state variable stakeToken instead of the function parameter _stakeToken used to set it. Using that instead will save 100 gas.  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/StakePrizePool.sol#L36-L38  The IdleYieldSourceInitialized similarly uses idleToken instead of _idleToken.  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L62-L66  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use equivalent function parameters or local variables in event emits instead of state variables.  
# Handle  jvaqa   # Vulnerability details  ## Impact PrizePool._calculateCreditBalance.creditBalance is incorrectly declared as storage rather than as memory, causing unnecessary SLOADs instead of MLOADs. [1]  PrizePool._calculateCreditBalance() is declared as a view function, so we know definitively that PrizePool._calculateCreditBalance.creditBalance is not modified within the function. [2]  Since PrizePool._calculateCreditBalance.creditBalance is not modified within the function, then when we fetch it, we want to pass it by value and not by reference by declaring it as 'CreditBalance memory creditBalance' rather than 'CreditBalance storage creditBalance'.   This way, each of the subsequent reads of the creditBalance are read from memory (MLOAD) rather than read from storage (SLOAD), where MLOAD is cheaper than SLOAD.  ## Recommended Mitigation Steps  Change this:  CreditBalance storage creditBalance  To this:  CreditBalance memory creditBalance   [1] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L825  [2] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L823  
# Handle  jvaqa   # Vulnerability details  ## Impact PrizePool.beforeTokenTransfer() incorrectly uses msg.sender in seven places instead of _msgSender(). [1]  Nearly all of PrizePool.sol opts to use _msgSender() to provide for more optionality.   It appears that PrizePool.beforeTokenTransfer() may have been copy/pasted into PrizePool.sol without adjusting msg.sender to use _msgSender().  ## Recommended Mitigation Steps  Replace the seven instances of msg.sender in PrizePool.beforeTokenTransfer() with _msgSender()  [1] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L418  
# Handle  pauliax   # Vulnerability details  ## Impact function _getRefferalCode() in ATokenYieldSource just returns a constant of uint16(188). To save some gas and improve the readability this can be extracted to a constant variable and used where necessary.  ## Recommended Mitigation Steps  uint16 internal constant REFFERAL_CODE = uint16(188);  
# Handle  pauliax   # Vulnerability details  ## Impact modifier canAddLiquidity calls internal function _canAddLiquidity. This function is not called anywhere else so I do not see a reason why all the logic can't be moved to the modifier to save some gas by reducing the extra call.  ## Recommended Mitigation Steps Remove function _canAddLiquidity, place its logic directly in the canAddLiquidity modifier.  
# Handle  gpersoon   # Vulnerability details  ## Impact Most of the contracts set variables in the initialize function that are never changed. See for examples in the "proof of concept" section. Here the solidity keyword "immutable" could be added to the variables as an extra security measure.  ## Proof of Concept ControlledToken.sol:         TokenControllerInterface public override controller; StakePricePools.sol:           IERC20Upgradeable private stakeToken; YieldSourcePrizePool.sol:   IYieldSource public yieldSource; PrizePool.sol:                     RegistryInterface public reserveRegistry; PrizePool.sol:                     uint256 public maxExitFeeMantissa; PrizePool.sol:                     uint256 public maxTimelockDuration; BadgerYieldSource.sol       IBadgerSett private immutable badgerSett; BadgerYieldSource.sol       IBadger private immutable badger; YearnV2YieldSource.sol      IYVaultV2 public vault; YearnV2YieldSource.sol      IERC20Upgradeable internal token;  IdleYieldSource.sol            address public idleToken; IdleYieldSource.sol            address public underlyingAsset; ATokenYieldSource.sol       ATokenInterface public aToken; ATokenYieldSource.sol       ILendingPoolAddressesProviderRegistry public lendingPoolAddressesProviderRegistry;     SushiYieldSource.sol          ISushiBar public immutable sushiBar; SushiYieldSource.sol          ISushi public immutable sushiAddr;     ## Tools Used  ## Recommended Mitigation Steps Add immutable where possible  
# Handle  gpersoon   # Vulnerability details  ## Impact uint256(-1) is used in the function initialize of PrizePool.sol to indicate the max uint256 value. Solidity also allows type(uint256).max), which is easier to read.  ## Proof of Concept // https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol#L233 function initialize ( ...     _setLiquidityCap(uint256(-1));  ## Tools Used  ## Recommended Mitigation Steps Replace uint256(-1) with: type(uint256).max)  
# Handle  shw   # Vulnerability details  ## Impact  At line 213 of `ATokenYieldSource`, `depositToken()` can be replaced by `_tokenAddress()` to save gas since the former is a public function, while the latter is an internal function.  ## Proof of Concept  Referenced code: [ATokenYieldSource.sol#L213](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/ATokenYieldSource.sol#L213)  ## Recommended Mitigation Steps  Change `depositToken()` to `_tokenAddress()`.  
# Handle  shw   # Vulnerability details  ## Impact  The function `_depositToAave` of `ATokenYieldSource` calls `_lendingPool` and `_tokenAddress` twice, both of which include function calls to external contracts. Thus, storing the first results into local variables and reuse them for the second time could help save gas.  ## Proof of Concept  Referenced code: [ATokenYieldSource.sol#L175-L182](https://github.com/pooltogether/aave-yield-source/blob/main/contracts/yield-source/ATokenYieldSource.sol#L175-L182)  ## Recommended Mitigation Steps  Store the result of `_tokenAddress()` and `_lendingPool()` to local variables and resue them.  
# Handle  shw   # Vulnerability details  ## Impact  The `redeemToken` function in `IdleYieldSource` uses `redeemedShare` instead of `redeemAmount` as the input parameter when calling `redeemIdleToken` of the Idle yield source. As a result, users could get fewer underlying tokens than they should.  ## Proof of Concept  When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the `tokenPriceWithFee()` is greater than `ONE_IDLE_TOKEN`, and thus `redeemedShare` is less than `redeemAmount`, causing users to get fewer underlying tokens than expected.  Referenced code: [IdleYieldSource.sol#L129-L131](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L129-L131)  ## Recommended Mitigation Steps  Change `redeemedShare` to `redeemAmount` at line 131.  
# Handle  shw   # Vulnerability details  ## Impact  The `YearnV2YieldSource` contract prevents the `supplyTokenTo`, `redeemToken`, and `sponsor` functions from being reentered by applying a `nonReentrant` modifier. Since these contracts share a similar logic, adding a `nonReentrant` modifier to these functions in all of the yield source contracts is reasonable. However, the same protection is not seen in other yield source contracts.  ## Proof of Concept  A `nonReentrant` modifier in the following functions is missing: 1. The `sponsor` function of `ATokenYieldSource` 2. The `supplyTokenTo` and `redeemToken` function of `BadgerYieldSource` 3. The `sponsor` function of `IdleYieldSource` 4. The `supplyTokenTo` and `redeemToken` function of `SushiYieldSource`  Referenced code: [ATokenYieldSource.sol#L233](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/ATokenYieldSource.sol#L233) [BadgerYieldSource.sol#L43](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L43) [BadgerYieldSource.sol#L57](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L57) [IdleYieldSource.sol#L150](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L150) [SushiYieldSource.sol#L47](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L47) [SushiYieldSource.sol#L66](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L66)  ## Recommended Mitigation Steps  Add a `nonReentrant` modifier to these functions. For `BadgerYieldSource` and `SushiYieldSource` contracts, make them inherit from Openzeppelin's `ReentrancyGuardUpgradeable` to use the `nonReentrant` modifier.  
# Handle  shw   # Vulnerability details  ## Impact  The `PrizePool` contract does not implement the `onERC721Received` function, which is considered a best practice to transfer ERC721 tokens from contracts to contracts. The absence of this function could prevent `PrizePool` from receiving ERC721 tokens from other contracts via `safeTransferFrom`.  ## Proof of Concept  Referenced code: [PrizePool.sol](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol)  ## Recommended Mitigation Steps  Consider adding an implementation of the `onERC721Received` function in `PrizePool`.  
# Handle  shw   # Vulnerability details  ## Impact  In the function `awardExternalERC721` of contract `PrizePool`, when awarding external ERC721 tokens to the winners, the `transferFrom` keyword is used instead of `safeTransferFrom`. If any winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be locked.  ## Proof of Concept  Referenced code: [PrizePool.sol#L602](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol#L602)  ## Recommended Mitigation Steps  Consider changing `transferFrom` to `safeTransferFrom` at line 602. However, it could introduce a DoS attack vector if any winner maliciously rejects the received ERC721 tokens to make the others unable to get their awards. Possible mitigations are to use a `try/catch` statement to handle error cases separately or provide a function for the pool owner to remove malicious winners manually if this happens.  
# Handle  shw   # Vulnerability details  ## Impact  SafeMath is not completely used at the following lines of yield source contracts, which could potentially cause arithmetic underflow and overflow: 1. line 78 in `SushiYieldSource` 2. line 67 in `BadgerYieldSource` 3. line 91 and 98 in `IdleYieldSource`  ## Proof of Concept  Referenced code: [SushiYieldSource.sol#L78](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L78) [BadgerYieldSource.sol#L67](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L67) [IdleYieldSource.sol#L91](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L91) [IdleYieldSource.sol#L98](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L98)  ## Recommended Mitigation Steps  Use the SafeMath library functions in the above lines.  
# Handle  shw   # Vulnerability details  ## Impact  In the contracts `BadgerYieldSource` and `SushiYieldSource`, the return values of ERC20 `transfer` and `transferFrom` are not checked to be `true`, which could be `false` if the transferred tokens are not ERC20-compliant (e.g., `BADGER`). In that case, the transfer fails without being noticed by the calling contract.  ## Proof of Concept  If warden's understanding of the `BadgerYieldSource` is correct, the `badger` variable should be the `BADGER` token at address `0x3472a5a71965499acd81997a54bba8d852c6e53d`. However, this implementation of `BADGER` is not ERC20-compliant, which returns `false` when the sender does not have enough token to transfer (both for `transfer` and `transferFrom`). See the [source code on Etherscan](https://etherscan.io/address/0x3472a5a71965499acd81997a54bba8d852c6e53d#code) (at line 226) for more details.  Referenced code: [BadgerYieldSource.sol#L44](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L44) [BadgerYieldSource.sol#L79](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L79) [SushiYieldSource.sol#L48](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L48) [SushiYieldSource.sol#L89](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L89)  ## Recommended Mitigation Steps  Use the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from Openzeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.  
# Handle  shw   # Vulnerability details  ## Impact  Some contracts (e.g., `PrizePool`) use an unlocked pragma (e.g., `pragma solidity >=0.6.0 <0.7.0;`) which is not fixed to a specific Solidity version. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler version with which they have been tested the most.  ## Proof of Concept  Referenced code: Please use `grep -R pragma .` to find the unlocked pragma statements.  ## Recommended Mitigation Steps  Lock pragmas to a specific Solidity version. Consider the compiler bugs in the following lists and ensure the contracts are not affected by them. It is also recommended to use the latest version of Solidity when deploying contracts (see [Solidity docs](https://docs.soliditylang.org/en/v0.8.4/#solidity)).  Solidity compiler bugs: [Solidity repo - known bugs](https://github.com/ethereum/solidity/blob/develop/docs/bugs.json) [Solidity repo - bugs by version](https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json)  
# Handle  shw   # Vulnerability details  ## Impact  Functions (e.g., `supplyTokenTo`, `redeemToken`) in the `BadgerYieldSource` and `SushiYieldSource` can be declared `external` instead of `public` to save gas.  ## Proof of Concept  Referenced code: [BadgerYieldSource.sol#L26](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L26) [BadgerYieldSource.sol#L32](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L32) [BadgerYieldSource.sol#L43](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L43) [BadgerYieldSource.sol#L57](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L57) [SushiYieldSource.sol#L29](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L29) [SushiYieldSource.sol#L35](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L35) [SushiYieldSource.sol#L47](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L47) [SushiYieldSource.sol#L66](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L66)  ## Recommended Mitigation Steps  Change the keyword `public` to `external`.  
# Handle  tensors   # Vulnerability details  ## Impact Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given.  For example, say I deposit 1 token, expecting 1 share in return. On L95, if the totalunderlying assets is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares.    ## Proof of Concept https://github.com/sunnyRK/IdleYieldSource-PoolTogether/blob/6dcc419e881a4f0f205c07c58f4db87520b6046d/contracts/IdleYieldSource.sol#L95  https://github.com/sunnyRK/IdleYieldSource-PoolTogether/blob/6dcc419e881a4f0f205c07c58f4db87520b6046d/contracts/IdleYieldSource.sol#L106  ## Recommended Mitigation Steps Implement mantissa calculations like in the contract for the AAVE  yield.  
# Handle  tensors   # Vulnerability details  ##Impact Uninitialized variables initialize to 0 automatically. No need to explicitly initialize it.   ##Proof of concept https://github.com/pooltogether/aave-yield-source/blob/bc65c875f62235b7af55ede92231a495ba091a47/contracts/yield-source/ATokenYieldSource.sol#L141  ##Recommended mitigation steps Replace with: `uint256 shares;`  
# Handle  cmichel   # Vulnerability details  In `PrizePool._updateCreditBalance` the `CreditBurned` event is emitted even if nothing was burned. Not emitting this event when nothing happened can save gas and also seems better semantically.  
# Handle  cmichel   # Vulnerability details  The credit is accrued twice in `award`. The first accrual happens implicitly when calling `_mint` through the `ControlledToken(controlledToken).controllerMint` call which then performs the `PrizePool.beforeTokenTransfer` hook which accrues credit. Then the explicit accrual is done again. It should be enough to only add the `extraCredit` without doing another accrual (calling `_updateCreditBalance(..., newBalance= _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra)))` instead).  
# Handle  cmichel   # Vulnerability details  `SushiYieldSource` should approve the SushiBar once during initialization with the max value. This saves gas on every `supplyTokenTo` call as the approval can be removed from there.  
# Handle  cmichel   # Vulnerability details  `ATokenYieldSource` should approve the lending contract once during initialization with the max value. This saves gas on every `supplyTokenTo/_depositToAave` call as the approval can be removed from there.  
# Handle  cmichel   # Vulnerability details  One can withdraw the entire `PrizePool` deposit by circumventing the timelock. Assume the user has no credits for ease of computation: - user calls `withdrawWithTimelockFrom(user, amount=userBalance)` with their entire balance. This "mints" an equivalent `amount` of `timelock` and resets `_unlockTimestamps[user] = timestamp = blockTime + lockDuration`. - user calls `withdrawWithTimelockFrom(user, amount=0)` again but this time withdrawing `0` amount. This will return a `lockDuration` of `0` and thus `unlockTimestamp = blockTime`. The inner `_mintTimelock` now resets `_unlockTimestamps[user] = unlockTimestamp` - As `if (timestamp <= _currentTime()) ` is true, the full users amount is now transferred out to the user in the `_sweepTimelockBalances` call.  ## Impact  Users don't need to wait for their deposit to contribute their fair share to the prize pool. They can join before the awards and leave right after without a penalty which leads to significant issues for the protocol. It's the superior strategy but it leads to no investments in the strategy to earn the actual interest.  ## Recommended Mitigation Steps  The unlock timestamp should be increased by duration each time, instead of being reset to the duration.  
# Handle  cmichel   # Vulnerability details  `YearnV2YieldSource._withdrawFromVault` uses a wrong subtraction. When withdrawing from the `vault` one redeems `yTokens` for `token`s, thus the `token` balance of the contract should increase after withdrawal. But the contract subtracts the `currentBalance` from the `previousBalance`:  ```solidity uint256 yShares = _tokenToYShares(amount); uint256 previousBalance = token.balanceOf(address(this)); // we accept losses to avoid being locked in the Vault (if losses happened for some reason) if(maxLosses != 0) {     vault.withdraw(yShares, address(this), maxLosses); } else {     vault.withdraw(yShares); } uint256 currentBalance = token.balanceOf(address(this)); // @audit-issue this seems wrong return previousBalance.sub(currentBalance); ```  ## Impact  All vault withdrawals fail due to the integer underflow as the `previousBalance` is less than `currentBalance`. Users won't be able to get back their investment.  ## Recommended Mitigation Steps  It should return `currentBalance > previousBalance ? currentBalance - previousBalance : 0`  
# Handle  cmichel   # Vulnerability details  The `ATokenYieldSource.redeemToken` function burns `aTokens` and sends out underlying, however, it's used in a reverse way in the code: The `balanceDiff` is used as the `depositToken` that is transferred out but it's computed on the **aTokens** that were burned instead of on the `depositToken` received.  ## Impact  It should not directly lead to issues as aTokens are 1-to-1 with their underlying but we still recommend doing it correctly to make the code more robust against any possible rounding issues.  ## Recommended Mitigation Steps  Compute `balanceDiff` on the underyling balance (depositToken), not on the aToken. Subtract the actual burned aTokens from the user shares.  
# Handle  cmichel   # Vulnerability details   When suppling to the `BadgerYieldSource`, some `amount` of `badger` is deposited to `badgerSett` and one receives `badgerSett` share tokens in return which are stored in the `balances` mapping of the user. So far this is correct.  The `balanceOfToken` function should then return the redeemable balance in `badger` for the user's `badgerSett` balance. It computes it as the pro-rata share of the user balance (compared to the total-supply of `badgerSett`) on the `badger` in the vault:  ```solidity balances[addr].mul(   badger.balanceOf(address(badgerSett)) ).div(   badgerSett.totalSupply() ) ```  However, `badger.balanceOf(address(badgerSett))` is only a small amount of badger that is deployed in the vault ("Sett") due to most of the capital being deployed to the _strategies_. Therefore, it under-reports the actual balance:  > Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply. [Badger Docs](https://badger-finance.gitbook.io/badger-finance/technical/setts/sett-contract)  ## Impact  Any contract or user calling the `balanceOf` function will receive a value that is far lower than the actual balance. Using this value as a basis for computations will lead to further errors in the integrations.  ## Recommended Mitigation Steps  It should use [`badgerSett.balance()`](https://github.com/Badger-Finance/badger-system/blob/2b0ee9bd77a2cc6f875b9b984ae4dfe713bbc55c/contracts/badger-sett/Sett.sol#L126) instead of `badger.balanceOf(address(badgerSett))` to also account for "the balance in the Sett, the Controller, and the Strategy".  
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `StakePrizePool.initialize`: `address _stakeToken` not checked for non-zero or contract - `ControlledToken.initialize`: `address controller` not checked for non-zero or contract - `PrizePool.withdrawReserve`: `address to` not checked for non-zero, funds will be lost when sending to zero address - `ATokenYieldSource.initialize`: `address _aToken, _lendingPoolAddressesProviderRegistry` not checked for non-zero or contract - `BadgerYieldSource.initialize`: `address badgerSettAddr, badgerAddr` not checked for non-zero or contract - `SushiYieldSource.constructor`: `address _sushiBar, _sushiAddr` not checked for non-zero or contract  ## Impact  Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps  Validate the parameters.  
# Handle  pauliax   # Vulnerability details  ## Impact contract ATokenYieldSource function _depositToAave returns 0 if successful. However, this value is not checked nor used anywhere. As this function is internal it would probably be better to remove this unnecessary return to save some gas and eliminate confusion.  ## Recommended Mitigation Steps refactor function _depositToAave to return void.  
# Handle  JMukesh   # Vulnerability details  ## Impact To track off-chain data it is necessary to use events  ## Proof of Concept  In  ATokenYieldSource.sol, IdleYieldSource.sol, yearnV2yieldsource  : events are emmitted in supplyTokenTo(), redeemToken() sponsor(), but not in  BadgerYieldsource.sol and shushiyieldsource.sol     ## Tools Used  Manual analysis  ## Recommended Mitigation Steps use events   
# Handle  hrkrshnn   # Vulnerability details  # General Gas optimization  ## Upgrade to at least 0.8.4 (even better is 0.8.5)  The following should lead to better gas savings:    - The inliner should decrease runtime gas.   - Inbuilt safemath instead of openzeppelin safemath should save some gas.   - Various improvement in the expression simplifier in the compiler throughout (0.7.0 - 0.8.5)     which should decrease both runtime and deploy time costs. (I'm assuming that the project     currently uses 0.6.12, since the compiler version was not explicitly specified.)  Of course, these improvements comes when optimizer is enabled, preferably with a high `--optimize-runs` value.  Note that the `inliner` in particular can be quite useful for the contract, since the contracts sometimes generously chains small functions.  ## Use custom errors instead of large revert strings  Saves both deploy time and runtime gas (runtime gas is only relevant when the revert condition is met.)  Need at least solidity 0.8.4 for this feature.  ### Use shorter revert strings  If you decide to not use custom errors, then try to use revert strings of size at most 32 characters.  For one, shorter strings would save deploy cost (one time saving of 200 gas per byte / character decreased). Also strings more than 32 bytes requires an additional `mstore`, two additional `push`, and an `add`. Roughly, 18 more gas during runtime (when revert condition is met).  Example string (33 bytes), from ControlledToken.sol  ``` solidity uint256 decreasedAllowance = allowance(_user, _operator).sub(_amount, "ControlledToken/exceeds-allowance"); ```  # Specific Gas optimizations  ## Use `immutable`  For state variables that are only assigned in constructors, change it to `immutable`.  This saves an `sload` each time the variable is accessed. Can save around 2100 gas (or 100 depending on warm / cold.)  Examples:  ### StakePrizePool.sol  ``` diff modified   contracts/StakePrizePool.sol @@ -8,7 +8,7 @@ import "../PrizePool.sol";   contract StakePrizePool is PrizePool {  -  IERC20Upgradeable private stakeToken; +  IERC20Upgradeable immutable private stakeToken;     event StakePrizePoolInitialized(address indexed stakeToken); ```  ### ControlledToken.sol  ``` diff contract ControlledToken is ERC20PermitUpgradeable, ControlledTokenInterface {     /// @notice Interface to the contract responsible for controlling mint/burn -  TokenControllerInterface public override controller; +  TokenControllerInterface public immutable override controller; ```  ### yield-source/YearnV2YieldSource.sol  ``` diff @@ -24,7 +24,7 @@ contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeabl      /// @notice Yearn Vault which manages `token` to generate yield      IYVaultV2 public vault;      /// @dev Deposit Token contract address -    IERC20Upgradeable internal token; +    IERC20Upgradeable immutable internal token;      /// @dev Max % of losses that the Yield Source will accept from the Vault in BPS      uint256 public maxLosses = 0; // 100% would be 10_000 ```  This change would likely require changing the initialization pattern. See the section below for details.  Similarly, several such variables can be changed. Not listing everything here.  ## Avoiding the `initialize` pattern  If elements can be initialized in the constructor, or via calls to internal functions in constructor, instead of the public `initialize` function, it should be possible to save deployment costs. On top of that, since the `initialize` function won't be part of the function dispatch in the contract, one could save some gas at run time for some calls (saves approximately two `push`, an `eq` and a `jumpi`.)  Another benefit for this is that several state variables can be converted to immutables. Again, saves `sload` costs during runtime.  Also, it might also be possible to change `initialize` from `public` to `internal`.  ## `_msgSender()` (Possible micro optimization)  Use `msg.sender` instead of `_msgSender()`. The latter might not be inlined by the compiler. (This is for cases where `_msgSender()` function simply returns `msg.sender`.) Can save around 30 gas (2 `JUMP`, plus some `PUSH` and some stack operations.)  Also, the contracts seem to mix `_msgSender()` and `msg.sender`, for example in `PrizePool.sol`. This could be avoided.  ## Use `decreaseAllowance` in ControllerToken.sol  ``` diff @@ -58,8 +58,7 @@ contract ControlledToken is ERC20PermitUpgradeable, ControlledTokenInterface {    /// @param _amount Amount of tokens to burn    function controllerBurnFrom(address _operator, address _user, uint256 _amount) external virtual override onlyController {      if (_operator != _user) { -      uint256 decreasedAllowance = allowance(_user, _operator).sub(_amount, "ControlledToken/exceeds-allowance"); -      _approve(_user, _operator, decreasedAllowance); +      decreaseAllowance(_user, _operator, _amount);      }      _burn(_user, _amount);    } ```  Will be slightly more gas efficient than the first once.  # General comments  ## Try to avoid `super` if possible  For example, in Ticket.sol:  ``` solidity   public   virtual   override   initializer {   super.initialize(_name, _symbol, _decimals, _controller); ```  The above usage of `super` is unnecessary. Unless you are dealing with multiple inheritance, where `super` is absolutely required, there is no need to use super, instead of statically specifying the name of the parent contract. There is however no performance penalty in using `super` instead of a static call to the parent.  ## Several `balance` related function can be made `view`?  In PrizePool, the function `function balance() external returns (uint256)` can perhaps be made `view`. This would also mean that a few other internal functions should be made `view`, such as `_balance`.   
# Handle  JMukesh   # Vulnerability details  ## Impact Using memory array parameters (e.g. uint[] memory) as function parameters can be tricky in Solidity, because an attack is possible with a very large array which will overlap with other parts of the memory.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L219  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L639   This an example to show the exploit:  // based on https://github.com/paradigm-operations/paradigm-ctf-2021/blob/master/swap/private/Exploit.sol  pragma solidity ^0.4.24; // only works with low solidity version  contract test{     struct Overlap {         uint field0;     }     event log(uint);    function mint(uint[] memory amounts) public  returns (uint) {   // this can be in any solidity version        Overlap memory v;        v.field0 = 1234;        emit log(amounts[0]); // would expect to be 0 however is 1234        return 1;      }    function go() public { // this part requires the low solidity version       uint x=0x800000000000000000000000000000000000000000000000000000000000000; // 2^251       bytes memory payload = abi.encodeWithSelector(this.mint.selector, 0x20, x);       bool success=address(this).call(payload);   } }     ## Tools Used  manual analysis  ## Recommended Mitigation Steps check the array length before using it  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The _depositInVault() function for Yearn yield source uses ERC20 safeApprove() from OpenZeppelin's SafeERC20 library to give maximum allowance to the Yearn Vault address if the current allowance is less than contract’s token balance.  However, the safeApprove function prevents changing an allowance between non-zero values to mitigate a possible front-running attack. It reverts if that is the case. Instead, the safeIncreaseAllowance and safeDecreaseAllowance functions should be used. Comment from the OZ library for this function: “// safeApprove should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and ‘safeDecreaseAllowance'"  Impact: If the existing allowance is non-zero (say, for e.g., previously the entire balance was not deposited due to vault balance limit resulting in the allowance being reduced but not made 0), then safeApprove() will revert causing the user’s token deposits to fail leading to denial-of-service. The condition predicate indicates that this scenario is possible.  ## Proof of Concept  Reference: See similar Medium-severity finding M03 here: https://blog.openzeppelin.com/1inch-exchange-audit/  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L171-L173  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6842518b1b71fac9a21c7d94ec521992cff266b5/contracts/token/ERC20/utils/SafeERC20.sol#L44-L57   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use safeIncreaseAllowance() function instead of safeApprove().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Most contracts use initialize() functions instead of constructor given the delegatecall proxy pattern. While most of them emit an event in the critical initialize() functions to record the init parameters for off-chain monitoring and transparency reasons, Ticket.sol nor its base class ControlledToken.sol emit such an event in their initialize() functions.  Impact: These contracts are initialized but their critical init parameters (name, symbol, decimals and controller address) are not logged for any off-chain monitoring.  ## Proof of Concept  See similar Medium-severity Finding M01 in OpenZeppelin’s audit of UMA protocol: https://blog.openzeppelin.com/uma-audit-phase-4/  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/Ticket.sol#L24-L37  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/ControlledToken.sol#L22-L36  Examples of event emission: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L239-L243  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/YieldSourcePrizePool.sol#L47   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit an initialised event in Ticket.sol and ControlledToken.sol logging their init parameters.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Most contracts use the delegateCall proxy pattern and hence their implementations require the use of initialize() functions instead of constructors. This requires derived contracts to call the corresponding init functions of their inherited base contracts. This is done in most places except a few.  Impact: The inherited base classes do not get initialized which may lead to undefined behavior.   ## Proof of Concept  Missing call to __ReentrancyGuard_init: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/ATokenYieldSource.sol#L99-L102  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L59-L61  Missing call to__ERC20_init: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L59-L61  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L83-L86   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add missing calls to init functions of inherited contracts.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level calls call/delegatecall/staticcall return true even if the account called is non-existent (per EVM design). Solidity documentation warns: "The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.”  The staticcall here will return True even if the _yieldSource contract doesn't exist at any incorrect-but-not-zero address, e.g. EOA address, used during initialization by accident. Impact: The hack, as commented, to check if it’s an actual yield source contract will fail if the address is indeed a contract account which doesn’t implement the depositToken function. However, if the address is that of an EOA account, the check will pass here but will revert in all future calls to the yield source forcing contract redeployment after the pool is active. Users will not be able to interact with the pool and abandon it.  ## Proof of Concept  https://docs.soliditylang.org/en/v0.8.6/control-structures.html#error-handling-assert-require-revert-and-exceptions  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/YieldSourcePrizePool.sol#L41-L45  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  A contract existence check should be performed on _yieldSource prior to the depositToken function existence hack for determining yield source contract.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The modifier onlyControlledToken is used for functions that allow the controlledToken address as a parameter to ensure that only whitelisted tokens (ticket and sponsorship) are provided. This is used in all functions except calculateEarlyExitFee().  Impact: The use of a non-whitelisted controlledToken will result in calls to potentially malicious token contract and cause undefined behavior for the `from` user address specified in the call.  ## Proof of Concept  Missing modifier: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L729-L747  Modifier: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1105-L1110  All other functions which accept controlledToken parameter have modifier onlyControlledToken: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L275  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L299  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L327  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L378  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L418  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L498  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L888  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L903  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add missing modifier onlyControlledToken to calculateEarlyExitFee().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Named return values in multiple functions are never used in favor of explicit returns.   Impact: This affects readability/auditability at the least and could potentially result in unexpected values being returned along paths with no explicit returns.  ## Proof of Concept  Unused in favor of explicit return:   https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L717-L726  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L741-L744  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L770  Used without explicit return:  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L923-L930  Used with explicit return:  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L944-L947   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unused named returns where unnecessary. Be consistent in using named vs explicit returns.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  If a function has multiple modifiers they are executed in the order specified. If checks or logic of modifiers depend on other modifiers this has to be considered in their ordering. PrizePool has functions with multiple modifiers with one of them being nonreentrant which prevents reentrancy on the functions. This should ideally be the first one to prevent even the execution of other modifiers in case of reentrancies.  While there is no obvious vulnerability currently with nonreentrant being the last modifier in the list, it is safer to place it in the first. This is of slight concern with the deposit functions which have the canAddLiquidity() modifier (before nonreentrant) that makes external calls to get totalSupply of controlled tokens.  ## Proof of Concept  For reference, see similar finding in Consensys’s audit of Balancer : https://consensys.net/diligence/audits/2020/05/balancer-finance/#switch-modifier-order-in-bpool  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L275-L277  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L299-L301   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Switch modifier order to consistently place the nonreentrant modifier as the first one to run so that all other modifiers are executed only if the call is nonreentrant.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Caching sushiAddr and sushiBar in local variables right at the beginning of supplyTokenTo() (similar to what's done in redeemToken) can save 100 gas from repeat SLOADs for each of them for a total savings of 200.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/SushiYieldSource.sol#L48-L51  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Caching sushiAddr and sushiBar in local variables at the beginning of supplyTokenTo() and use those instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  maxLosses state variable is used in two places in _withdrawFromVault(). It can be cached in a local variable  at the beginning of the function to save 100 gas from one repeated SLOAD.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L187-L188  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache maxLosses in a local variable at the beginning of the function and use that instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  token state variable is used in two places in _withdrawFromVault(). It can be cached in a local variable  at the beginning of the function to save 100 gas from one repeated SLOAD.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L185  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L192   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache token in a local variable  at the beginning of the function and use that instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  token state variable is used in three places in _depositInVault(). It can be cached in a local variable  at the beginning of the function to save 200 gas from two repeated SLOADs.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L171-L172  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache token in a local variable  at the beginning of the function and use that instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Using parameter _vault instead of SLOAD of state variable vault in the call to safeApprove() leads to gas savings of 100.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L87  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L67  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L25   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Using parameter _vault instead of state variable vault in the call to safeApprove()  
# Handle  0xRajeev   # Vulnerability details  ## Impact  YearnV2YieldSource initialize does a zero-address check for value address to detect if it has already been initialized. This is an unnecessary check because vault address default value is zero, it is not initialized/set anywhere else and the initializer modifier will prevent the calling of initialize() a second time. So vault is guaranteed to be zero in initialize().  The impact is gas wastage from an additional SLOAD of vault state variable and the require() check.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L25  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L73  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the zero-address check for vault.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  State variables badger and badgerSett addresses are read two and four times respectively in supplyTokenTo(). Caching them in local variables at the beginning of the function and using those local variables can save 400 gas from avoiding 3 repeated SLOADs for badgerSett and 1 repeated SLOAD for badger.  Impact: Gas savings of 400  ## Proof of Concept  Two badger reads: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L44-L45  Four badgerSett reads:   https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L45  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L47  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L48  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L49  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache badger and badgerSett state variables in local variables at the beginning of the function and use those local variables instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The loop iteration in _tokenTotalSupply() ends when currentToken matches _tokens.end() where _tokens is a state variable.  Impact: Checking against the state variable for every iteration costs 100 gas per iteration. Even with only two controlled tokens (tickets & sponsorship), this costs 100 more than caching this in a local memory variable and using that within the while predicate.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1059  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L177   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _tokens.end() in a local memory variable before the loop and using that within the while predicate.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  When _tokenTotalSupply() adds up the supplies of all controlled tokens, it checks and skips zero-address tokens. Instead of checking for zero-address every time for every call to _tokenTotalSupply() from captureAwardBalance() and every deposit via canAddLiquidity modifier, preventing zero-address controlled-token addresses from being added in _addControlledToken() during initialization will avoid these checks.  Impact: All deposit calls which cost 0.5M gas currently will be impacted by these unnecessary checks if we instead perform it one time during the addition of tokens in initialization.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1059  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L228-L230  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move zero-address check from time of use to time of adding the tokens into the list in initialize().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  State variable maxTimelockDuration is read twice on consecutive lines 723 and 724 of function _calculateTimelockDuration(). Caching it in a local variable will save 100 gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L723-L724   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache maxTimelockDuration in a local variable in the beginning of the function.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Mapping state variable value _timelockBalances[user] is read on consecutive lines 655 and 656 resulting in 2 SLOADS (2100 + 100 gas).   Impact: Caching this in a local variable would save ~= 100 gas savings per user iteration (by converting the use of the second 100-gas costing SLOAD to 1 MSTORE and 1 MLOAD both of which only cost 3 gas). If there are 1000 users in a call to sweepTimelockBalances(), this could be significant savings of 100,000 gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L655-L656   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _timelockBalances[user] in a local variable before using on lines 655 and 656.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Cache _currentAwardBalance state variable in a local variable for computation to save gas. 4 SLOADs + 1 SSTORE can be reduced to 1 SLOAD and 1 STORE.   Impact: Saves 300 gas from avoid 3 SLOADs because each SLOAD to already accessed storage slot costs 100.  ## Proof of Concept  2 SLOADs: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L456  1 SSTORE + 1 SLOAD: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L465  1 SLOAD: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L470   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _currentAwardBalance in a local variable in the beginning, use that for computation/return and one updation to state variable at the end.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The canAddLiquidity modifier, which is used on all deposits (each deposit costs 0.5M gas), appears to be an expensive modifier because it calculates the sum of all the supplies across controlled tokens (by making external CALLs) and adding that up with reserve and timelock supplies. While this is an extensible implementation that supports arbitrary number of controlled tokens via mapped singly linked list, the prize pools typically have only two controlled tokens: tickets and sponsorship.   Impact: deposits currently cost 0.5M gas.  ## Proof of Concept  https://docs.pooltogether.com/protocol/overview#gas-usage  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L276  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L300  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1119-L1122  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1069-L1072  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1054-L1064  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider gas profiling a fast-path calculation by keeping a separate state variable that tracks the sum of timelock+reserve along with all deposits made towards controlled token supplies and comparing new deposits with that state variable instead of reevaluating totals during each deposit. The extra SLOADs, CALLs and other expensive operations (in linked list and other logic) during reevaluation may add up to more than updating this proposed new state variable across different operations.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Where possible, use equivalent function parameters or local variables in event emits instead of state variables to prevent expensive SLOADs. Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase.  ## Proof of Concept  The Initialized event in PrizePool uses state variables maxExitFeeMantissa and maxTimelockDuration instead of using the equivalent function parameters _maxExitFeeMantissa and _maxTimelockDuration which were just used to set these state variables. Using them instead will save 2 extra SLOADs, leading to gas savings of 200.  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L239-L243  The StakePrizePoolInitialized event uses state variable stakeToken instead of the function parameter _stakeToken used to set it. Using that instead will save 100 gas.    https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/StakePrizePool.sol#L36-L38   The IdleYieldSourceInitialized similarly uses idleToken instead of _idleToken.    https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L62-L66  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use equivalent function parameters or local variables in event emits instead of state variables.  
# Handle  jvaqa   # Vulnerability details  ## Impact PrizePool._calculateCreditBalance.creditBalance is incorrectly declared as storage rather than as memory, causing unnecessary SLOADs instead of MLOADs. [1]  PrizePool._calculateCreditBalance() is declared as a view function, so we know definitively that PrizePool._calculateCreditBalance.creditBalance is not modified within the function. [2]  Since PrizePool._calculateCreditBalance.creditBalance is not modified within the function, then when we fetch it, we want to pass it by value and not by reference by declaring it as 'CreditBalance memory creditBalance' rather than 'CreditBalance storage creditBalance'.   This way, each of the subsequent reads of the creditBalance are read from memory (MLOAD) rather than read from storage (SLOAD), where MLOAD is cheaper than SLOAD.  ## Recommended Mitigation Steps  Change this:  CreditBalance storage creditBalance  To this:  CreditBalance memory creditBalance   [1] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L825  [2] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L823  
# Handle  jvaqa   # Vulnerability details  ## Impact PrizePool.beforeTokenTransfer() incorrectly uses msg.sender in seven places instead of _msgSender(). [1]  Nearly all of PrizePool.sol opts to use _msgSender() to provide for more optionality.   It appears that PrizePool.beforeTokenTransfer() may have been copy/pasted into PrizePool.sol without adjusting msg.sender to use _msgSender().  ## Recommended Mitigation Steps  Replace the seven instances of msg.sender in PrizePool.beforeTokenTransfer() with _msgSender()  [1] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L418  
# Handle  pauliax   # Vulnerability details  ## Impact function _getRefferalCode() in ATokenYieldSource just returns a constant of uint16(188). To save some gas and improve the readability this can be extracted to a constant variable and used where necessary.  ## Recommended Mitigation Steps  uint16 internal constant REFFERAL_CODE = uint16(188);  
# Handle  pauliax   # Vulnerability details  ## Impact modifier canAddLiquidity calls internal function _canAddLiquidity. This function is not called anywhere else so I do not see a reason why all the logic can't be moved to the modifier to save some gas by reducing the extra call.  ## Recommended Mitigation Steps Remove function _canAddLiquidity, place its logic directly in the canAddLiquidity modifier.  
# Handle  gpersoon   # Vulnerability details  ## Impact Most of the contracts set variables in the initialize function that are never changed. See for examples in the "proof of concept" section. Here the solidity keyword "immutable" could be added to the variables as an extra security measure.  ## Proof of Concept ControlledToken.sol:         TokenControllerInterface public override controller; StakePricePools.sol:           IERC20Upgradeable private stakeToken; YieldSourcePrizePool.sol:   IYieldSource public yieldSource; PrizePool.sol:                     RegistryInterface public reserveRegistry; PrizePool.sol:                     uint256 public maxExitFeeMantissa; PrizePool.sol:                     uint256 public maxTimelockDuration; BadgerYieldSource.sol       IBadgerSett private immutable badgerSett; BadgerYieldSource.sol       IBadger private immutable badger; YearnV2YieldSource.sol      IYVaultV2 public vault; YearnV2YieldSource.sol      IERC20Upgradeable internal token;  IdleYieldSource.sol            address public idleToken; IdleYieldSource.sol            address public underlyingAsset; ATokenYieldSource.sol       ATokenInterface public aToken; ATokenYieldSource.sol       ILendingPoolAddressesProviderRegistry public lendingPoolAddressesProviderRegistry;     SushiYieldSource.sol          ISushiBar public immutable sushiBar; SushiYieldSource.sol          ISushi public immutable sushiAddr;     ## Tools Used  ## Recommended Mitigation Steps Add immutable where possible  
# Handle  gpersoon   # Vulnerability details  ## Impact uint256(-1) is used in the function initialize of PrizePool.sol to indicate the max uint256 value. Solidity also allows type(uint256).max), which is easier to read.  ## Proof of Concept // https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol#L233 function initialize ( ...     _setLiquidityCap(uint256(-1));  ## Tools Used  ## Recommended Mitigation Steps Replace uint256(-1) with: type(uint256).max)  
# Handle  shw   # Vulnerability details  ## Impact  At line 213 of `ATokenYieldSource`, `depositToken()` can be replaced by `_tokenAddress()` to save gas since the former is a public function, while the latter is an internal function.  ## Proof of Concept  Referenced code: [ATokenYieldSource.sol#L213](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/ATokenYieldSource.sol#L213)  ## Recommended Mitigation Steps  Change `depositToken()` to `_tokenAddress()`.  
# Handle  shw   # Vulnerability details  ## Impact  The function `_depositToAave` of `ATokenYieldSource` calls `_lendingPool` and `_tokenAddress` twice, both of which include function calls to external contracts. Thus, storing the first results into local variables and reuse them for the second time could help save gas.  ## Proof of Concept  Referenced code: [ATokenYieldSource.sol#L175-L182](https://github.com/pooltogether/aave-yield-source/blob/main/contracts/yield-source/ATokenYieldSource.sol#L175-L182)  ## Recommended Mitigation Steps  Store the result of `_tokenAddress()` and `_lendingPool()` to local variables and resue them.  
# Handle  shw   # Vulnerability details  ## Impact  The `redeemToken` function in `IdleYieldSource` uses `redeemedShare` instead of `redeemAmount` as the input parameter when calling `redeemIdleToken` of the Idle yield source. As a result, users could get fewer underlying tokens than they should.  ## Proof of Concept  When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the `tokenPriceWithFee()` is greater than `ONE_IDLE_TOKEN`, and thus `redeemedShare` is less than `redeemAmount`, causing users to get fewer underlying tokens than expected.  Referenced code: [IdleYieldSource.sol#L129-L131](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L129-L131)  ## Recommended Mitigation Steps  Change `redeemedShare` to `redeemAmount` at line 131.  
# Handle  shw   # Vulnerability details  ## Impact  The `YearnV2YieldSource` contract prevents the `supplyTokenTo`, `redeemToken`, and `sponsor` functions from being reentered by applying a `nonReentrant` modifier. Since these contracts share a similar logic, adding a `nonReentrant` modifier to these functions in all of the yield source contracts is reasonable. However, the same protection is not seen in other yield source contracts.  ## Proof of Concept  A `nonReentrant` modifier in the following functions is missing: 1. The `sponsor` function of `ATokenYieldSource` 2. The `supplyTokenTo` and `redeemToken` function of `BadgerYieldSource` 3. The `sponsor` function of `IdleYieldSource` 4. The `supplyTokenTo` and `redeemToken` function of `SushiYieldSource`  Referenced code: [ATokenYieldSource.sol#L233](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/ATokenYieldSource.sol#L233) [BadgerYieldSource.sol#L43](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L43) [BadgerYieldSource.sol#L57](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L57) [IdleYieldSource.sol#L150](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L150) [SushiYieldSource.sol#L47](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L47) [SushiYieldSource.sol#L66](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L66)  ## Recommended Mitigation Steps  Add a `nonReentrant` modifier to these functions. For `BadgerYieldSource` and `SushiYieldSource` contracts, make them inherit from Openzeppelin's `ReentrancyGuardUpgradeable` to use the `nonReentrant` modifier.  
# Handle  shw   # Vulnerability details  ## Impact  The `PrizePool` contract does not implement the `onERC721Received` function, which is considered a best practice to transfer ERC721 tokens from contracts to contracts. The absence of this function could prevent `PrizePool` from receiving ERC721 tokens from other contracts via `safeTransferFrom`.  ## Proof of Concept  Referenced code: [PrizePool.sol](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol)  ## Recommended Mitigation Steps  Consider adding an implementation of the `onERC721Received` function in `PrizePool`.  
# Handle  shw   # Vulnerability details  ## Impact  In the function `awardExternalERC721` of contract `PrizePool`, when awarding external ERC721 tokens to the winners, the `transferFrom` keyword is used instead of `safeTransferFrom`. If any winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be locked.  ## Proof of Concept  Referenced code: [PrizePool.sol#L602](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol#L602)  ## Recommended Mitigation Steps  Consider changing `transferFrom` to `safeTransferFrom` at line 602. However, it could introduce a DoS attack vector if any winner maliciously rejects the received ERC721 tokens to make the others unable to get their awards. Possible mitigations are to use a `try/catch` statement to handle error cases separately or provide a function for the pool owner to remove malicious winners manually if this happens.  
# Handle  shw   # Vulnerability details  ## Impact  SafeMath is not completely used at the following lines of yield source contracts, which could potentially cause arithmetic underflow and overflow: 1. line 78 in `SushiYieldSource` 2. line 67 in `BadgerYieldSource` 3. line 91 and 98 in `IdleYieldSource`  ## Proof of Concept  Referenced code: [SushiYieldSource.sol#L78](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L78) [BadgerYieldSource.sol#L67](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L67) [IdleYieldSource.sol#L91](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L91) [IdleYieldSource.sol#L98](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L98)  ## Recommended Mitigation Steps  Use the SafeMath library functions in the above lines.  
# Handle  shw   # Vulnerability details  ## Impact  In the contracts `BadgerYieldSource` and `SushiYieldSource`, the return values of ERC20 `transfer` and `transferFrom` are not checked to be `true`, which could be `false` if the transferred tokens are not ERC20-compliant (e.g., `BADGER`). In that case, the transfer fails without being noticed by the calling contract.  ## Proof of Concept  If warden's understanding of the `BadgerYieldSource` is correct, the `badger` variable should be the `BADGER` token at address `0x3472a5a71965499acd81997a54bba8d852c6e53d`. However, this implementation of `BADGER` is not ERC20-compliant, which returns `false` when the sender does not have enough token to transfer (both for `transfer` and `transferFrom`). See the [source code on Etherscan](https://etherscan.io/address/0x3472a5a71965499acd81997a54bba8d852c6e53d#code) (at line 226) for more details.  Referenced code: [BadgerYieldSource.sol#L44](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L44) [BadgerYieldSource.sol#L79](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L79) [SushiYieldSource.sol#L48](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L48) [SushiYieldSource.sol#L89](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L89)  ## Recommended Mitigation Steps  Use the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from Openzeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.  
# Handle  shw   # Vulnerability details  ## Impact  Some contracts (e.g., `PrizePool`) use an unlocked pragma (e.g., `pragma solidity >=0.6.0 <0.7.0;`) which is not fixed to a specific Solidity version. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler version with which they have been tested the most.  ## Proof of Concept  Referenced code: Please use `grep -R pragma .` to find the unlocked pragma statements.  ## Recommended Mitigation Steps  Lock pragmas to a specific Solidity version. Consider the compiler bugs in the following lists and ensure the contracts are not affected by them. It is also recommended to use the latest version of Solidity when deploying contracts (see [Solidity docs](https://docs.soliditylang.org/en/v0.8.4/#solidity)).  Solidity compiler bugs: [Solidity repo - known bugs](https://github.com/ethereum/solidity/blob/develop/docs/bugs.json) [Solidity repo - bugs by version](https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json)  
# Handle  shw   # Vulnerability details  ## Impact  Functions (e.g., `supplyTokenTo`, `redeemToken`) in the `BadgerYieldSource` and `SushiYieldSource` can be declared `external` instead of `public` to save gas.  ## Proof of Concept  Referenced code: [BadgerYieldSource.sol#L26](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L26) [BadgerYieldSource.sol#L32](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L32) [BadgerYieldSource.sol#L43](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L43) [BadgerYieldSource.sol#L57](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L57) [SushiYieldSource.sol#L29](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L29) [SushiYieldSource.sol#L35](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L35) [SushiYieldSource.sol#L47](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L47) [SushiYieldSource.sol#L66](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L66)  ## Recommended Mitigation Steps  Change the keyword `public` to `external`.  
# Handle  tensors   # Vulnerability details  ## Impact Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given.  For example, say I deposit 1 token, expecting 1 share in return. On L95, if the totalunderlying assets is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares.    ## Proof of Concept https://github.com/sunnyRK/IdleYieldSource-PoolTogether/blob/6dcc419e881a4f0f205c07c58f4db87520b6046d/contracts/IdleYieldSource.sol#L95  https://github.com/sunnyRK/IdleYieldSource-PoolTogether/blob/6dcc419e881a4f0f205c07c58f4db87520b6046d/contracts/IdleYieldSource.sol#L106  ## Recommended Mitigation Steps Implement mantissa calculations like in the contract for the AAVE  yield.  
# Handle  tensors   # Vulnerability details  ##Impact Uninitialized variables initialize to 0 automatically. No need to explicitly initialize it.   ##Proof of concept https://github.com/pooltogether/aave-yield-source/blob/bc65c875f62235b7af55ede92231a495ba091a47/contracts/yield-source/ATokenYieldSource.sol#L141  ##Recommended mitigation steps Replace with: `uint256 shares;`  
# Handle  cmichel   # Vulnerability details  In `PrizePool._updateCreditBalance` the `CreditBurned` event is emitted even if nothing was burned. Not emitting this event when nothing happened can save gas and also seems better semantically.  
# Handle  cmichel   # Vulnerability details  The credit is accrued twice in `award`. The first accrual happens implicitly when calling `_mint` through the `ControlledToken(controlledToken).controllerMint` call which then performs the `PrizePool.beforeTokenTransfer` hook which accrues credit. Then the explicit accrual is done again. It should be enough to only add the `extraCredit` without doing another accrual (calling `_updateCreditBalance(..., newBalance= _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra)))` instead).  
# Handle  cmichel   # Vulnerability details  `SushiYieldSource` should approve the SushiBar once during initialization with the max value. This saves gas on every `supplyTokenTo` call as the approval can be removed from there.  
# Handle  cmichel   # Vulnerability details  `ATokenYieldSource` should approve the lending contract once during initialization with the max value. This saves gas on every `supplyTokenTo/_depositToAave` call as the approval can be removed from there.  
# Handle  cmichel   # Vulnerability details  One can withdraw the entire `PrizePool` deposit by circumventing the timelock. Assume the user has no credits for ease of computation: - user calls `withdrawWithTimelockFrom(user, amount=userBalance)` with their entire balance. This "mints" an equivalent `amount` of `timelock` and resets `_unlockTimestamps[user] = timestamp = blockTime + lockDuration`. - user calls `withdrawWithTimelockFrom(user, amount=0)` again but this time withdrawing `0` amount. This will return a `lockDuration` of `0` and thus `unlockTimestamp = blockTime`. The inner `_mintTimelock` now resets `_unlockTimestamps[user] = unlockTimestamp` - As `if (timestamp <= _currentTime()) ` is true, the full users amount is now transferred out to the user in the `_sweepTimelockBalances` call.  ## Impact  Users don't need to wait for their deposit to contribute their fair share to the prize pool. They can join before the awards and leave right after without a penalty which leads to significant issues for the protocol. It's the superior strategy but it leads to no investments in the strategy to earn the actual interest.  ## Recommended Mitigation Steps  The unlock timestamp should be increased by duration each time, instead of being reset to the duration.  
# Handle  cmichel   # Vulnerability details  `YearnV2YieldSource._withdrawFromVault` uses a wrong subtraction. When withdrawing from the `vault` one redeems `yTokens` for `token`s, thus the `token` balance of the contract should increase after withdrawal. But the contract subtracts the `currentBalance` from the `previousBalance`:  ```solidity uint256 yShares = _tokenToYShares(amount); uint256 previousBalance = token.balanceOf(address(this)); // we accept losses to avoid being locked in the Vault (if losses happened for some reason) if(maxLosses != 0) {     vault.withdraw(yShares, address(this), maxLosses); } else {     vault.withdraw(yShares); } uint256 currentBalance = token.balanceOf(address(this)); // @audit-issue this seems wrong return previousBalance.sub(currentBalance); ```  ## Impact  All vault withdrawals fail due to the integer underflow as the `previousBalance` is less than `currentBalance`. Users won't be able to get back their investment.  ## Recommended Mitigation Steps  It should return `currentBalance > previousBalance ? currentBalance - previousBalance : 0`  
# Handle  cmichel   # Vulnerability details  The `ATokenYieldSource.redeemToken` function burns `aTokens` and sends out underlying, however, it's used in a reverse way in the code: The `balanceDiff` is used as the `depositToken` that is transferred out but it's computed on the **aTokens** that were burned instead of on the `depositToken` received.  ## Impact  It should not directly lead to issues as aTokens are 1-to-1 with their underlying but we still recommend doing it correctly to make the code more robust against any possible rounding issues.  ## Recommended Mitigation Steps  Compute `balanceDiff` on the underyling balance (depositToken), not on the aToken. Subtract the actual burned aTokens from the user shares.  
# Handle  cmichel   # Vulnerability details   When suppling to the `BadgerYieldSource`, some `amount` of `badger` is deposited to `badgerSett` and one receives `badgerSett` share tokens in return which are stored in the `balances` mapping of the user. So far this is correct.  The `balanceOfToken` function should then return the redeemable balance in `badger` for the user's `badgerSett` balance. It computes it as the pro-rata share of the user balance (compared to the total-supply of `badgerSett`) on the `badger` in the vault:  ```solidity balances[addr].mul(   badger.balanceOf(address(badgerSett)) ).div(   badgerSett.totalSupply() ) ```  However, `badger.balanceOf(address(badgerSett))` is only a small amount of badger that is deployed in the vault ("Sett") due to most of the capital being deployed to the _strategies_. Therefore, it under-reports the actual balance:  > Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply. [Badger Docs](https://badger-finance.gitbook.io/badger-finance/technical/setts/sett-contract)  ## Impact  Any contract or user calling the `balanceOf` function will receive a value that is far lower than the actual balance. Using this value as a basis for computations will lead to further errors in the integrations.  ## Recommended Mitigation Steps  It should use [`badgerSett.balance()`](https://github.com/Badger-Finance/badger-system/blob/2b0ee9bd77a2cc6f875b9b984ae4dfe713bbc55c/contracts/badger-sett/Sett.sol#L126) instead of `badger.balanceOf(address(badgerSett))` to also account for "the balance in the Sett, the Controller, and the Strategy".  
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `StakePrizePool.initialize`: `address _stakeToken` not checked for non-zero or contract - `ControlledToken.initialize`: `address controller` not checked for non-zero or contract - `PrizePool.withdrawReserve`: `address to` not checked for non-zero, funds will be lost when sending to zero address - `ATokenYieldSource.initialize`: `address _aToken, _lendingPoolAddressesProviderRegistry` not checked for non-zero or contract - `BadgerYieldSource.initialize`: `address badgerSettAddr, badgerAddr` not checked for non-zero or contract - `SushiYieldSource.constructor`: `address _sushiBar, _sushiAddr` not checked for non-zero or contract  ## Impact  Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps  Validate the parameters.  
# Handle  pauliax   # Vulnerability details  ## Impact contract ATokenYieldSource function _depositToAave returns 0 if successful. However, this value is not checked nor used anywhere. As this function is internal it would probably be better to remove this unnecessary return to save some gas and eliminate confusion.  ## Recommended Mitigation Steps refactor function _depositToAave to return void.  
# Handle  JMukesh   # Vulnerability details  ## Impact To track off-chain data it is necessary to use events  ## Proof of Concept  In  ATokenYieldSource.sol, IdleYieldSource.sol, yearnV2yieldsource  : events are emmitted in supplyTokenTo(), redeemToken() sponsor(), but not in  BadgerYieldsource.sol and shushiyieldsource.sol     ## Tools Used  Manual analysis  ## Recommended Mitigation Steps use events   
# Handle  hrkrshnn   # Vulnerability details  # General Gas optimization  ## Upgrade to at least 0.8.4 (even better is 0.8.5)  The following should lead to better gas savings:    - The inliner should decrease runtime gas.   - Inbuilt safemath instead of openzeppelin safemath should save some gas.   - Various improvement in the expression simplifier in the compiler throughout (0.7.0 - 0.8.5)     which should decrease both runtime and deploy time costs. (I'm assuming that the project     currently uses 0.6.12, since the compiler version was not explicitly specified.)  Of course, these improvements comes when optimizer is enabled, preferably with a high `--optimize-runs` value.  Note that the `inliner` in particular can be quite useful for the contract, since the contracts sometimes generously chains small functions.  ## Use custom errors instead of large revert strings  Saves both deploy time and runtime gas (runtime gas is only relevant when the revert condition is met.)  Need at least solidity 0.8.4 for this feature.  ### Use shorter revert strings  If you decide to not use custom errors, then try to use revert strings of size at most 32 characters.  For one, shorter strings would save deploy cost (one time saving of 200 gas per byte / character decreased). Also strings more than 32 bytes requires an additional `mstore`, two additional `push`, and an `add`. Roughly, 18 more gas during runtime (when revert condition is met).  Example string (33 bytes), from ControlledToken.sol  ``` solidity uint256 decreasedAllowance = allowance(_user, _operator).sub(_amount, "ControlledToken/exceeds-allowance"); ```  # Specific Gas optimizations  ## Use `immutable`  For state variables that are only assigned in constructors, change it to `immutable`.  This saves an `sload` each time the variable is accessed. Can save around 2100 gas (or 100 depending on warm / cold.)  Examples:  ### StakePrizePool.sol  ``` diff modified   contracts/StakePrizePool.sol @@ -8,7 +8,7 @@ import "../PrizePool.sol";   contract StakePrizePool is PrizePool {  -  IERC20Upgradeable private stakeToken; +  IERC20Upgradeable immutable private stakeToken;     event StakePrizePoolInitialized(address indexed stakeToken); ```  ### ControlledToken.sol  ``` diff contract ControlledToken is ERC20PermitUpgradeable, ControlledTokenInterface {     /// @notice Interface to the contract responsible for controlling mint/burn -  TokenControllerInterface public override controller; +  TokenControllerInterface public immutable override controller; ```  ### yield-source/YearnV2YieldSource.sol  ``` diff @@ -24,7 +24,7 @@ contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeabl      /// @notice Yearn Vault which manages `token` to generate yield      IYVaultV2 public vault;      /// @dev Deposit Token contract address -    IERC20Upgradeable internal token; +    IERC20Upgradeable immutable internal token;      /// @dev Max % of losses that the Yield Source will accept from the Vault in BPS      uint256 public maxLosses = 0; // 100% would be 10_000 ```  This change would likely require changing the initialization pattern. See the section below for details.  Similarly, several such variables can be changed. Not listing everything here.  ## Avoiding the `initialize` pattern  If elements can be initialized in the constructor, or via calls to internal functions in constructor, instead of the public `initialize` function, it should be possible to save deployment costs. On top of that, since the `initialize` function won't be part of the function dispatch in the contract, one could save some gas at run time for some calls (saves approximately two `push`, an `eq` and a `jumpi`.)  Another benefit for this is that several state variables can be converted to immutables. Again, saves `sload` costs during runtime.  Also, it might also be possible to change `initialize` from `public` to `internal`.  ## `_msgSender()` (Possible micro optimization)  Use `msg.sender` instead of `_msgSender()`. The latter might not be inlined by the compiler. (This is for cases where `_msgSender()` function simply returns `msg.sender`.) Can save around 30 gas (2 `JUMP`, plus some `PUSH` and some stack operations.)  Also, the contracts seem to mix `_msgSender()` and `msg.sender`, for example in `PrizePool.sol`. This could be avoided.  ## Use `decreaseAllowance` in ControllerToken.sol  ``` diff @@ -58,8 +58,7 @@ contract ControlledToken is ERC20PermitUpgradeable, ControlledTokenInterface {    /// @param _amount Amount of tokens to burn    function controllerBurnFrom(address _operator, address _user, uint256 _amount) external virtual override onlyController {      if (_operator != _user) { -      uint256 decreasedAllowance = allowance(_user, _operator).sub(_amount, "ControlledToken/exceeds-allowance"); -      _approve(_user, _operator, decreasedAllowance); +      decreaseAllowance(_user, _operator, _amount);      }      _burn(_user, _amount);    } ```  Will be slightly more gas efficient than the first once.  # General comments  ## Try to avoid `super` if possible  For example, in Ticket.sol:  ``` solidity   public   virtual   override   initializer {   super.initialize(_name, _symbol, _decimals, _controller); ```  The above usage of `super` is unnecessary. Unless you are dealing with multiple inheritance, where `super` is absolutely required, there is no need to use super, instead of statically specifying the name of the parent contract. There is however no performance penalty in using `super` instead of a static call to the parent.  ## Several `balance` related function can be made `view`?  In PrizePool, the function `function balance() external returns (uint256)` can perhaps be made `view`. This would also mean that a few other internal functions should be made `view`, such as `_balance`.   
# Handle  JMukesh   # Vulnerability details  ## Impact Using memory array parameters (e.g. uint[] memory) as function parameters can be tricky in Solidity, because an attack is possible with a very large array which will overlap with other parts of the memory.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L219  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L639   This an example to show the exploit:  // based on https://github.com/paradigm-operations/paradigm-ctf-2021/blob/master/swap/private/Exploit.sol  pragma solidity ^0.4.24; // only works with low solidity version  contract test{     struct Overlap {         uint field0;     }     event log(uint);    function mint(uint[] memory amounts) public  returns (uint) {   // this can be in any solidity version        Overlap memory v;        v.field0 = 1234;        emit log(amounts[0]); // would expect to be 0 however is 1234        return 1;      }    function go() public { // this part requires the low solidity version       uint x=0x800000000000000000000000000000000000000000000000000000000000000; // 2^251       bytes memory payload = abi.encodeWithSelector(this.mint.selector, 0x20, x);       bool success=address(this).call(payload);   } }     ## Tools Used  manual analysis  ## Recommended Mitigation Steps check the array length before using it  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The _depositInVault() function for Yearn yield source uses ERC20 safeApprove() from OpenZeppelin's SafeERC20 library to give maximum allowance to the Yearn Vault address if the current allowance is less than contract’s token balance.  However, the safeApprove function prevents changing an allowance between non-zero values to mitigate a possible front-running attack. It reverts if that is the case. Instead, the safeIncreaseAllowance and safeDecreaseAllowance functions should be used. Comment from the OZ library for this function: “// safeApprove should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and ‘safeDecreaseAllowance'"  Impact: If the existing allowance is non-zero (say, for e.g., previously the entire balance was not deposited due to vault balance limit resulting in the allowance being reduced but not made 0), then safeApprove() will revert causing the user’s token deposits to fail leading to denial-of-service. The condition predicate indicates that this scenario is possible.  ## Proof of Concept  Reference: See similar Medium-severity finding M03 here: https://blog.openzeppelin.com/1inch-exchange-audit/  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L171-L173  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6842518b1b71fac9a21c7d94ec521992cff266b5/contracts/token/ERC20/utils/SafeERC20.sol#L44-L57   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use safeIncreaseAllowance() function instead of safeApprove().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Most contracts use initialize() functions instead of constructor given the delegatecall proxy pattern. While most of them emit an event in the critical initialize() functions to record the init parameters for off-chain monitoring and transparency reasons, Ticket.sol nor its base class ControlledToken.sol emit such an event in their initialize() functions.  Impact: These contracts are initialized but their critical init parameters (name, symbol, decimals and controller address) are not logged for any off-chain monitoring.  ## Proof of Concept  See similar Medium-severity Finding M01 in OpenZeppelin’s audit of UMA protocol: https://blog.openzeppelin.com/uma-audit-phase-4/  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/Ticket.sol#L24-L37  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/ControlledToken.sol#L22-L36  Examples of event emission: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L239-L243  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/YieldSourcePrizePool.sol#L47   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit an initialised event in Ticket.sol and ControlledToken.sol logging their init parameters.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Most contracts use the delegateCall proxy pattern and hence their implementations require the use of initialize() functions instead of constructors. This requires derived contracts to call the corresponding init functions of their inherited base contracts. This is done in most places except a few.  Impact: The inherited base classes do not get initialized which may lead to undefined behavior.   ## Proof of Concept  Missing call to __ReentrancyGuard_init: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/ATokenYieldSource.sol#L99-L102  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L59-L61  Missing call to__ERC20_init: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L59-L61  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L83-L86   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add missing calls to init functions of inherited contracts.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level calls call/delegatecall/staticcall return true even if the account called is non-existent (per EVM design). Solidity documentation warns: "The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.”  The staticcall here will return True even if the _yieldSource contract doesn't exist at any incorrect-but-not-zero address, e.g. EOA address, used during initialization by accident. Impact: The hack, as commented, to check if it’s an actual yield source contract will fail if the address is indeed a contract account which doesn’t implement the depositToken function. However, if the address is that of an EOA account, the check will pass here but will revert in all future calls to the yield source forcing contract redeployment after the pool is active. Users will not be able to interact with the pool and abandon it.  ## Proof of Concept  https://docs.soliditylang.org/en/v0.8.6/control-structures.html#error-handling-assert-require-revert-and-exceptions  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/YieldSourcePrizePool.sol#L41-L45  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  A contract existence check should be performed on _yieldSource prior to the depositToken function existence hack for determining yield source contract.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The modifier onlyControlledToken is used for functions that allow the controlledToken address as a parameter to ensure that only whitelisted tokens (ticket and sponsorship) are provided. This is used in all functions except calculateEarlyExitFee().  Impact: The use of a non-whitelisted controlledToken will result in calls to potentially malicious token contract and cause undefined behavior for the `from` user address specified in the call.  ## Proof of Concept  Missing modifier: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L729-L747  Modifier: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1105-L1110  All other functions which accept controlledToken parameter have modifier onlyControlledToken: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L275  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L299  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L327  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L378  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L418  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L498  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L888  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L903  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add missing modifier onlyControlledToken to calculateEarlyExitFee().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Named return values in multiple functions are never used in favor of explicit returns.   Impact: This affects readability/auditability at the least and could potentially result in unexpected values being returned along paths with no explicit returns.  ## Proof of Concept  Unused in favor of explicit return:   https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L717-L726  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L741-L744  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L770  Used without explicit return:  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L923-L930  Used with explicit return:  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L944-L947   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unused named returns where unnecessary. Be consistent in using named vs explicit returns.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  If a function has multiple modifiers they are executed in the order specified. If checks or logic of modifiers depend on other modifiers this has to be considered in their ordering. PrizePool has functions with multiple modifiers with one of them being nonreentrant which prevents reentrancy on the functions. This should ideally be the first one to prevent even the execution of other modifiers in case of reentrancies.  While there is no obvious vulnerability currently with nonreentrant being the last modifier in the list, it is safer to place it in the first. This is of slight concern with the deposit functions which have the canAddLiquidity() modifier (before nonreentrant) that makes external calls to get totalSupply of controlled tokens.  ## Proof of Concept  For reference, see similar finding in Consensys’s audit of Balancer : https://consensys.net/diligence/audits/2020/05/balancer-finance/#switch-modifier-order-in-bpool  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L275-L277  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L299-L301   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Switch modifier order to consistently place the nonreentrant modifier as the first one to run so that all other modifiers are executed only if the call is nonreentrant.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Caching sushiAddr and sushiBar in local variables right at the beginning of supplyTokenTo() (similar to what's done in redeemToken) can save 100 gas from repeat SLOADs for each of them for a total savings of 200.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/SushiYieldSource.sol#L48-L51  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Caching sushiAddr and sushiBar in local variables at the beginning of supplyTokenTo() and use those instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  maxLosses state variable is used in two places in _withdrawFromVault(). It can be cached in a local variable  at the beginning of the function to save 100 gas from one repeated SLOAD.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L187-L188  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache maxLosses in a local variable at the beginning of the function and use that instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  token state variable is used in two places in _withdrawFromVault(). It can be cached in a local variable  at the beginning of the function to save 100 gas from one repeated SLOAD.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L185  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L192   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache token in a local variable  at the beginning of the function and use that instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  token state variable is used in three places in _depositInVault(). It can be cached in a local variable  at the beginning of the function to save 200 gas from two repeated SLOADs.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L171-L172  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache token in a local variable  at the beginning of the function and use that instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Using parameter _vault instead of SLOAD of state variable vault in the call to safeApprove() leads to gas savings of 100.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L87  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L67  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L25   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Using parameter _vault instead of state variable vault in the call to safeApprove()  
# Handle  0xRajeev   # Vulnerability details  ## Impact  YearnV2YieldSource initialize does a zero-address check for value address to detect if it has already been initialized. This is an unnecessary check because vault address default value is zero, it is not initialized/set anywhere else and the initializer modifier will prevent the calling of initialize() a second time. So vault is guaranteed to be zero in initialize().  The impact is gas wastage from an additional SLOAD of vault state variable and the require() check.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L25  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L73  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the zero-address check for vault.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  State variables badger and badgerSett addresses are read two and four times respectively in supplyTokenTo(). Caching them in local variables at the beginning of the function and using those local variables can save 400 gas from avoiding 3 repeated SLOADs for badgerSett and 1 repeated SLOAD for badger.  Impact: Gas savings of 400  ## Proof of Concept  Two badger reads: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L44-L45  Four badgerSett reads:   https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L45  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L47  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L48  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L49  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache badger and badgerSett state variables in local variables at the beginning of the function and use those local variables instead.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The loop iteration in _tokenTotalSupply() ends when currentToken matches _tokens.end() where _tokens is a state variable.  Impact: Checking against the state variable for every iteration costs 100 gas per iteration. Even with only two controlled tokens (tickets & sponsorship), this costs 100 more than caching this in a local memory variable and using that within the while predicate.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1059  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L177   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _tokens.end() in a local memory variable before the loop and using that within the while predicate.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  When _tokenTotalSupply() adds up the supplies of all controlled tokens, it checks and skips zero-address tokens. Instead of checking for zero-address every time for every call to _tokenTotalSupply() from captureAwardBalance() and every deposit via canAddLiquidity modifier, preventing zero-address controlled-token addresses from being added in _addControlledToken() during initialization will avoid these checks.  Impact: All deposit calls which cost 0.5M gas currently will be impacted by these unnecessary checks if we instead perform it one time during the addition of tokens in initialization.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1059  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L228-L230  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move zero-address check from time of use to time of adding the tokens into the list in initialize().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  State variable maxTimelockDuration is read twice on consecutive lines 723 and 724 of function _calculateTimelockDuration(). Caching it in a local variable will save 100 gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L723-L724   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache maxTimelockDuration in a local variable in the beginning of the function.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Mapping state variable value _timelockBalances[user] is read on consecutive lines 655 and 656 resulting in 2 SLOADS (2100 + 100 gas).   Impact: Caching this in a local variable would save ~= 100 gas savings per user iteration (by converting the use of the second 100-gas costing SLOAD to 1 MSTORE and 1 MLOAD both of which only cost 3 gas). If there are 1000 users in a call to sweepTimelockBalances(), this could be significant savings of 100,000 gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L655-L656   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _timelockBalances[user] in a local variable before using on lines 655 and 656.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Cache _currentAwardBalance state variable in a local variable for computation to save gas. 4 SLOADs + 1 SSTORE can be reduced to 1 SLOAD and 1 STORE.   Impact: Saves 300 gas from avoid 3 SLOADs because each SLOAD to already accessed storage slot costs 100.  ## Proof of Concept  2 SLOADs: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L456  1 SSTORE + 1 SLOAD: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L465  1 SLOAD: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L470   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _currentAwardBalance in a local variable in the beginning, use that for computation/return and one updation to state variable at the end.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The canAddLiquidity modifier, which is used on all deposits (each deposit costs 0.5M gas), appears to be an expensive modifier because it calculates the sum of all the supplies across controlled tokens (by making external CALLs) and adding that up with reserve and timelock supplies. While this is an extensible implementation that supports arbitrary number of controlled tokens via mapped singly linked list, the prize pools typically have only two controlled tokens: tickets and sponsorship.   Impact: deposits currently cost 0.5M gas.  ## Proof of Concept  https://docs.pooltogether.com/protocol/overview#gas-usage  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L276  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L300  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1119-L1122  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1069-L1072  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1054-L1064  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider gas profiling a fast-path calculation by keeping a separate state variable that tracks the sum of timelock+reserve along with all deposits made towards controlled token supplies and comparing new deposits with that state variable instead of reevaluating totals during each deposit. The extra SLOADs, CALLs and other expensive operations (in linked list and other logic) during reevaluation may add up to more than updating this proposed new state variable across different operations.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Where possible, use equivalent function parameters or local variables in event emits instead of state variables to prevent expensive SLOADs. Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase.  ## Proof of Concept  The Initialized event in PrizePool uses state variables maxExitFeeMantissa and maxTimelockDuration instead of using the equivalent function parameters _maxExitFeeMantissa and _maxTimelockDuration which were just used to set these state variables. Using them instead will save 2 extra SLOADs, leading to gas savings of 200.  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L239-L243  The StakePrizePoolInitialized event uses state variable stakeToken instead of the function parameter _stakeToken used to set it. Using that instead will save 100 gas.    https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/StakePrizePool.sol#L36-L38   The IdleYieldSourceInitialized similarly uses idleToken instead of _idleToken.    https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L62-L66  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use equivalent function parameters or local variables in event emits instead of state variables.  
# Handle  jvaqa   # Vulnerability details  ## Impact PrizePool._calculateCreditBalance.creditBalance is incorrectly declared as storage rather than as memory, causing unnecessary SLOADs instead of MLOADs. [1]  PrizePool._calculateCreditBalance() is declared as a view function, so we know definitively that PrizePool._calculateCreditBalance.creditBalance is not modified within the function. [2]  Since PrizePool._calculateCreditBalance.creditBalance is not modified within the function, then when we fetch it, we want to pass it by value and not by reference by declaring it as 'CreditBalance memory creditBalance' rather than 'CreditBalance storage creditBalance'.   This way, each of the subsequent reads of the creditBalance are read from memory (MLOAD) rather than read from storage (SLOAD), where MLOAD is cheaper than SLOAD.  ## Recommended Mitigation Steps  Change this:  CreditBalance storage creditBalance  To this:  CreditBalance memory creditBalance   [1] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L825  [2] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L823  
# Handle  jvaqa   # Vulnerability details  ## Impact PrizePool.beforeTokenTransfer() incorrectly uses msg.sender in seven places instead of _msgSender(). [1]  Nearly all of PrizePool.sol opts to use _msgSender() to provide for more optionality.   It appears that PrizePool.beforeTokenTransfer() may have been copy/pasted into PrizePool.sol without adjusting msg.sender to use _msgSender().  ## Recommended Mitigation Steps  Replace the seven instances of msg.sender in PrizePool.beforeTokenTransfer() with _msgSender()  [1] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L418  
# Handle  pauliax   # Vulnerability details  ## Impact function _getRefferalCode() in ATokenYieldSource just returns a constant of uint16(188). To save some gas and improve the readability this can be extracted to a constant variable and used where necessary.  ## Recommended Mitigation Steps  uint16 internal constant REFFERAL_CODE = uint16(188);  
# Handle  pauliax   # Vulnerability details  ## Impact modifier canAddLiquidity calls internal function _canAddLiquidity. This function is not called anywhere else so I do not see a reason why all the logic can't be moved to the modifier to save some gas by reducing the extra call.  ## Recommended Mitigation Steps Remove function _canAddLiquidity, place its logic directly in the canAddLiquidity modifier.  
# Handle  gpersoon   # Vulnerability details  ## Impact Most of the contracts set variables in the initialize function that are never changed. See for examples in the "proof of concept" section. Here the solidity keyword "immutable" could be added to the variables as an extra security measure.  ## Proof of Concept ControlledToken.sol:         TokenControllerInterface public override controller; StakePricePools.sol:           IERC20Upgradeable private stakeToken; YieldSourcePrizePool.sol:   IYieldSource public yieldSource; PrizePool.sol:                     RegistryInterface public reserveRegistry; PrizePool.sol:                     uint256 public maxExitFeeMantissa; PrizePool.sol:                     uint256 public maxTimelockDuration; BadgerYieldSource.sol       IBadgerSett private immutable badgerSett; BadgerYieldSource.sol       IBadger private immutable badger; YearnV2YieldSource.sol      IYVaultV2 public vault; YearnV2YieldSource.sol      IERC20Upgradeable internal token;  IdleYieldSource.sol            address public idleToken; IdleYieldSource.sol            address public underlyingAsset; ATokenYieldSource.sol       ATokenInterface public aToken; ATokenYieldSource.sol       ILendingPoolAddressesProviderRegistry public lendingPoolAddressesProviderRegistry;     SushiYieldSource.sol          ISushiBar public immutable sushiBar; SushiYieldSource.sol          ISushi public immutable sushiAddr;     ## Tools Used  ## Recommended Mitigation Steps Add immutable where possible  
# Handle  gpersoon   # Vulnerability details  ## Impact uint256(-1) is used in the function initialize of PrizePool.sol to indicate the max uint256 value. Solidity also allows type(uint256).max), which is easier to read.  ## Proof of Concept // https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol#L233 function initialize ( ...     _setLiquidityCap(uint256(-1));  ## Tools Used  ## Recommended Mitigation Steps Replace uint256(-1) with: type(uint256).max)  
