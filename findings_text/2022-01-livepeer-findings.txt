# Handle  Dravee   # Vulnerability details  ## Impact `msg.sender` costs 2 gas (CALLER opcode). `_msgSender()` represents the following: ``` function _msgSender() internal view virtual returns (address payable) {     return msg.sender; } ``` When no GSN capabilities are used: `msg.sender` is enough.  See https://docs.openzeppelin.com/contracts/2.x/gsn for more information about GSN capabilities.  ## Proof of Concept Instances include: ``` arbitrum-lpt-bridge\contracts\L1\escrow\L1Escrow.sol:18:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:133:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:83:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\contracts\L2\token\LivepeerToken.sol:13:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\contracts\ControlledGateway.sol:19:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Replace `_msgSender()` with `msg.sender`  
# Handle  gzeon   # Vulnerability details  ## Impact Fund can be lost if the L1 call value provided is insufficient to cover `_maxSubmissionCost`, or stuck if insufficient to cover `_maxSubmissionCost + (_maxGas * _gasPriceBid)`.  ## Proof of Concept `outboundTransfer` in `L1LPTGateway` does not check if the call value is sufficient, if it is `< _maxSubmissionCost` the retryable ticket creation will fail and fund is lost; if it is `<_maxSubmissionCost + (_maxGas * _gasPriceBid)` the ticket would require manual execution.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1LPTGateway.sol#L80 ```     function outboundTransfer(         address _l1Token,         address _to,         uint256 _amount,         uint256 _maxGas,         uint256 _gasPriceBid,         bytes calldata _data     ) external payable override whenNotPaused returns (bytes memory) {         require(_l1Token == l1Lpt, "TOKEN_NOT_LPT");          // nested scope to avoid stack too deep errors         address from;         uint256 seqNum;         bytes memory extraData;         {             uint256 maxSubmissionCost;             (from, maxSubmissionCost, extraData) = parseOutboundData(_data);             require(extraData.length == 0, "CALL_HOOK_DATA_NOT_ALLOWED");              // transfer tokens to escrow             TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount);              bytes memory outboundCalldata = getOutboundCalldata(                 _l1Token,                 from,                 _to,                 _amount,                 extraData             );              seqNum = sendTxToL2(                 l2Counterpart,                 from,                 maxSubmissionCost,                 _maxGas,                 _gasPriceBid,                 outboundCalldata             );         }          emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);          return abi.encode(seqNum);     } ```  ## Recommended Mitigation Steps Add check similar to the one used in `L1GatewayRouter` provided by Arbitrum team  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L236 ```         uint256 expectedEth = _maxSubmissionCost + (_maxGas * _gasPriceBid);         require(_maxSubmissionCost > 0, "NO_SUBMISSION_COST");         require(msg.value == expectedEth, "WRONG_ETH_VALUE"); ```  
# Handle  pauliax   # Vulnerability details  ## Impact In contract BridgeMinter function setToken, it just sets the new tokenAddr, but it does not process the old token balance leaving it stuck in the contract. I think that setToken could also migrate the old balance somewhere before updating the token address. I can even suggest adding token rescue functions to the contracts that may come in handy in such cases or if someone accidentally sends the tokens directly to the contract. An owner can rescue the tokens if the token is not protected (e.g. intended to be held in the contract).  ## Recommended Mitigation Steps An example implementation that could help to rescue old token balance: ```solidity   function withdrawLPTToL1Migrator(address _tokenAddr, address _recipient) external onlyControllerOwner returns (uint256) {       require(_tokenAddr != tokenAddr, "protected");        IERC20 token = IERC20(_tokenAddr);        uint256 balance = token.balanceOf(address(this));        token.transfer(_recipient, balance);        return balance;   } ```  
# Handle  0x0x0x   # Vulnerability details  ## Concept  When a variable is declared solidity assigns the default value. In case the contract assigns the value again, it costs extra gas.   Example:`uint x = 0` costs more gas than `uint x` without having any different functionality.  Scope  ``` ./protocol/bonding/libraries/EarningsPool.sol:84:        uint256 delegatorFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:85:        uint256 transcoderFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:115:        uint256 delegatorRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:116:        uint256 transcoderRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:189:        uint256 transcoderFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:190:        uint256 delegatorFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:217:        uint256 transcoderRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:218:        uint256 delegatorRewards = 0; ./protocol/pm/mixins/MixinTicketBrokerCore.sol:121:        uint256 amountToTransfer = 0; ./protocol/token/Minter.sol:223:        uint256 currentBondingRate = 0; ./arbitrum-lpt-bridge/L1/gateway/L1Migrator.sol:471:        uint256 total = 0; ./protocol/zeppelin/MintableToken.sol:17:    bool public mintingFinished = false; ./protocol/zeppelin/Pausable.sol:13:    bool public paused = false;  ```  
# Handle  byterocket   # Vulnerability details  ## Impact  The `_setupRole` function in OpenZeppelin's `AccessControl` contract is marked as deprecated in favor of `_grantRole`. See [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L183).  Following contracts use the deprecated `_setupRole` in their constructor: ``` arbitrum-lpt-bridge:   - ControlledGateway.sol   - L1/escrow/L1Escrow.sol   - L2/gateway/L2Migrator.sol   - token/LivepeerToken.sol   - L1/gateway/L1Migrator.sol ```  ## Recommended Mitigation Steps  Refactor the contracts constructor's to use `_grantRole` instead of `_setupRole`.  
# Handle  WatchPug   # Vulnerability details  Per the `arb-bridge-eth` code:  > all msg.value will deposited to callValueRefundAddress on L2  https://github.com/OffchainLabs/arbitrum/blob/78118ba205854374ed280a27415cb62c37847f72/packages/arb-bridge-eth/contracts/bridge/Inbox.sol#L313  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1ArbitrumMessenger.sol#L65-L74  ```solidity uint256 seqNum = inbox.createRetryableTicket{value: _l1CallValue}(     target,     _l2CallValue,     maxSubmissionCost,     from,     from,     maxGas,     gasPriceBid,     data ); ```  At L308-L309, ETH held by `BridgeMinter` is withdrawn to L1Migrator:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L309  ```solidity         uint256 amount = IBridgeMinter(bridgeMinterAddr)             .withdrawETHToL1Migrator(); ```  However, when calling `sendTxToL2()` the parameter `_l1CallValue` is only the `msg.value`, therefore, the ETH transferred to L2 does not include any funds from `bridgeMinter`.   https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L318-L327  ```solidity     sendTxToL2(         l2MigratorAddr,         address(this), // L2 alias of this contract will receive refunds         msg.value,         amount,         _maxSubmissionCost,         _maxGas,         _gasPriceBid,         ""     ) ```  As a result, due to lack of funds, `call` with value = amount to `l2MigratorAddr` will always fail on L2.  Since there is no other way to send ETH to L2, all the ETH from `bridgeMinter` is now frozen in the contract.  ### Recommendation  Change to:  ```solidity     sendTxToL2(         l2MigratorAddr,         address(this), // L2 alias of this contract will receive refunds         msg.value + amount, // the `amount` withdrawn from BridgeMinter should be added         amount,         _maxSubmissionCost,         _maxGas,         _gasPriceBid,         ""     ) ```  
# Handle  WatchPug   # Vulnerability details  Per the document: https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-73.md#upgrade-process  > *Phase 1* > > - The L1 RoundsManager will be upgraded to disable round initialization at `LIP_73_ROUND` > - During this phase, protocol transactions will be executed normally > - During this phase, the following contracts will be deployed: >     - Protocol contracts on L2 >     - Migrator contracts on L1 and L2 >     - LPT bridge contracts on L1 and L2 >     - ***All of these contracts will start off paused***  However, the current implementation of `L1LPTGateway`, `L2LPTGateway` are not automatically paused on deployment.  We recommend adding `_pause()` to the end of the `constructor()` in `L1LPTGateway`, `L2LPTGateway`, like the constructor of [L1Migrator.sol#L143](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L143-L143), and `unpause()` when Phase 2 starts.   This will help avoid tx to happen in an intermediate state between Phase1 and Phase 2, which may cause certain txs to fail, for instance:  When in Phase 1, `L1LPTGateway` cant calls `bridgeMint()` on the `BridgeMinter` to mint LPT to the user, as L1 Minter have not `migrateToNewMinter()` to `BridgeMinter` yet. If a user in L2 tries to move `LPT` from L2 to L1, their tx may fail.  
# Handle  WatchPug   # Vulnerability details  Per the document: https://github.com/code-423n4/2022-01-livepeer#l2---l1-lpt-withdrawal  > The following occurs when LPT is withdrawn from L2 to L1:  > The user initiates a withdrawal for X LPT. This can be done in two ways: a. Call outboundTransfer() on L2GatewayRouter which will call outboundTransfer() on L2LPTGateway b. Call outboundTransfer() directly on L2LPTGateway  The method (a) described above won't work in the current implementation due to the missing interface on `L2LPTGateway`.  When initiate a withdraw from the Arbitrum Gateway Router, `L2GatewayRouter` will call `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` on `ITokenGateway(gateway)`:  ```solidity function outboundTransfer(     address _token,     address _to,     uint256 _amount,     uint256 _maxGas,     uint256 _gasPriceBid,     bytes calldata _data ) external payable returns (bytes memory); ```  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/arbitrum/gateway/L2GatewayRouter.sol#L57-L64  ```solidity function outboundTransfer(     address _l1Token,     address _to,     uint256 _amount,     bytes calldata _data ) public payable returns (bytes memory) {     return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data); } ```  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/GatewayRouter.sol#L78-L102  ```solidity function outboundTransfer(     address _token,     address _to,     uint256 _amount,     uint256 _maxGas,     uint256 _gasPriceBid,     bytes calldata _data ) public payable virtual override returns (bytes memory) {     address gateway = getGateway(_token);     bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(         msg.sender,         _data     );      emit TransferRouted(_token, msg.sender, _to, gateway);     return         ITokenGateway(gateway).outboundTransfer{ value: msg.value }(             _token,             _to,             _amount,             _maxGas,             _gasPriceBid,             gatewayData         ); } ```  However, `L2LPTGateway` dose not implement `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` but only `outboundTransfer(address,address,uint256,bytes)`:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTGateway.sol#L65-L89  ```solidity function outboundTransfer(     address _l1Token,     address _to,     uint256 _amount,     bytes calldata _data ) public override whenNotPaused returns (bytes memory res) {     // ... } ```  Therefore, the desired feature to withdraw LPT from L2 to L1 via Arbitrum Router will not be working properly.  ## Recommendation  Consider implementing the method used by  Arbitrum Router.  See also the implementation of L2DaiGateway by arbitrum-dai-bridge: https://github.com/makerdao/arbitrum-dai-bridge/blob/master/contracts/l2/L2DaiGateway.sol#L88-L95  
# Handle  Jujic   # Vulnerability details  ## Impact The    initialize    function   does   not   check   if   the   `_bondingManager`   are   all   non-zero   addresses.   If   all  the   initialized   `_bondingManager`   happen   to   be   0,   the   contract   will   have   to   be redeployed.  The  contract are initialized, but their critical init parameters are not logged for any off-chain monitoring.  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L47-L51  ``` function initialize(address _bondingManager) public initializer {         bondingManager = _bondingManager;         migrator = msg.sender;         initialStake = pendingStake();     } ``` Most contracts use initialize() functions instead of constructor given the delegatecall proxy pattern. While most of them emit an event in the critical initialize() functions to record the init parameters for off-chain monitoring and transparency reasons, DelegatorPool.sol not emit such an event in their initialize() function.    ## Tools Used https://github.com/code-423n4/2021-06-pooltogether-findings/issues/68 ## Recommended Mitigation Steps Add check for zero address and emit event.  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L310  ```solidity uint256 amount = IBridgeMinter(bridgeMinterAddr)             .withdrawETHToL1Migrator(); ```  `L1Migrator.sol#migrateETH()` will call `IBridgeMinter(bridgeMinterAddr).withdrawETHToL1Migrator()` to withdraw ETH from `BridgeMinter`.  However, the current implementation of `L1Migrator` is unable to receive ETH.  https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L94-L94  ```solidity (bool ok, ) = l1MigratorAddr.call.value(address(this).balance)(""); ```  A contract receiving Ether must have at least one of the functions below:  - `receive() external payable` - `fallback() external payable`  `receive()` is called if `msg.data` is empty, otherwise `fallback()` is called.  Because `L1Migrator` implement neither `receive()` or `fallback()`, the `call` at L94 will always revert.  ## Impact  All the ETH held by the `BridgeMinter` can get stuck in the contract.  ## Recommandation  Add `receive() external payable {}` in `L1Migrator`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L12-L16  ```solidity constructor() ERC20("Livepeer Token", "LPT") ERC20Permit("Livepeer Token") {     _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);     _setRoleAdmin(BURNER_ROLE, DEFAULT_ADMIN_ROLE); } ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L18-L24  ```solidity constructor(address _l1Lpt, address _l2Lpt) {     _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     _setRoleAdmin(GOVERNOR_ROLE, DEFAULT_ADMIN_ROLE);      l1Lpt = _l1Lpt;     l2Lpt = _l2Lpt; } ```  `constant DEFAULT_ADMIN_ROLE = 0x00`  By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`.  Therefore, `_setRoleAdmin(***_ROLE, DEFAULT_ADMIN_ROLE);` is redundant.  Removing it will make the code simpler and save some gas.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/783ac759a902a7b4a218c2d026a77e6a26b6c42d/contracts/access/AccessControl.sol#L40-L43  ```solidity  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means  * that only accounts with this role will be able to grant or revoke other  * roles. More complex role relationships can be created by using  * {_setRoleAdmin}. ```  https://docs.openzeppelin.com/contracts/3.x/access-control#granting-and-revoking  > AccessControl includes a special role, called DEFAULT_ADMIN_ROLE, which acts as the ***default admin role for all roles***. An account with this role will be able to manage any other role, unless _setRoleAdmin is used to select a new admin role.  ### Recommendation  Remove the redundant code.  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L36-L43  ```solidity function burn(address _from, uint256 _amount)     external     override     onlyRole(BURNER_ROLE) {     _burn(_from, _amount);     emit Burn(_from, _amount); } ```  Using the `burn()` function of `L2LivepeerToken`, an address with `BURNER_ROLE` can burn an arbitrary amount of tokens from any address.  We believe this is unnecessary and poses a serious centralization risk.  A malicious or compromised `BURNER_ROLE` address can take advantage of this, burn the balance of a Uniswap pool and effectively steal almost all the funds from the liquidity pool (eg, Uniswap LPT-WETH Pool).  ### Recommendation  Consider removing the `BURNER_ROLE` and change `burn()` function to:  ```solidity function burn(uint256 _amount)     external     override {     _burn(msg.sender, _amount);     emit Burn(msg.sender, _amount); } ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/49cf5401b0514511675d781a1e29d6b0325cfe88/contracts/L2/gateway/L2LPTGateway.sol#L34-L45  `Mintable(l2Lpt).burn(from, _amount);` in `L2LPTGateway.sol#outboundTransfer()` should also be replaced with:  ```solidity Mintable(l2Lpt).transferFrom(from, _amount); Mintable(l2Lpt).burn(_amount); ```  
# Handle  WatchPug   # Vulnerability details  In the current implementation of `DelegatorPool.sol#claim()`, it first requires `claimedInitialStake < initialStake`, or it throws an error of `DelegatorPool#claim: FULLY_CLAIMED`.  However, since it's an `onlyMigrator` function, the felicity of `_delegator` and `_stake` should be assured by the `Migrator` contract, otherwise, this `require` statement itself also can not prevent bad results caused by the wrong inputs.  Furthermore, even if the purpose of this `require` statement is to make sure that `claimedInitialStake` can never surpass the `initialStake`, the expression should be `claimedInitialStake + _stake <= initialStake` instead of `claimedInitialStake < initialStake`.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L58-L93  ```solidity function claim(address _delegator, uint256 _stake) external onlyMigrator {     require(         claimedInitialStake < initialStake,         "DelegatorPool#claim: FULLY_CLAIMED"     );      // Calculate stake owed to delegator     uint256 currTotalStake = pendingStake();     uint256 owedStake = (currTotalStake * _stake) /         (initialStake - claimedInitialStake);      // Calculate fees owed to delegator     uint256 currTotalFees = pendingFees();     uint256 owedFees = (currTotalFees * _stake) /         (initialStake - claimedInitialStake);      // update claimed balance     claimedInitialStake += _stake;      // Transfer owed stake to the delegator     transferBond(_delegator, owedStake);      // Transfer owed fees to the delegator     IBondingManager(bondingManager).withdrawFees(         payable(_delegator),         owedFees     );      emit Claimed(_delegator, owedStake, owedFees); } ```  ## Recommandation  Consider removing it or changing to:  ```solidity require(     claimedInitialStake + _stake <= initialStake,     "DelegatorPool#claim: FULLY_CLAIMED" ); ```  
# Handle  ye0lde   # Vulnerability details  ## Impact Save Gas With The Unchecked Keyword (L2LPTDataCache.sol)  Redundant arithmetic underflow/overflow checks can be avoided when an underflow/overflow cannot happen.  ## Proof of Concept The "unchecked" keyword can be applied here since there is an `if` statement before to ensure the arithmetic operations would not cause an integer underflow or overflow.: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L57-L69  Change the code to:  ```     function decreaseL2SupplyFromL1(uint256 _amount) external onlyL2LPTGateway {         // If there is a mass withdrawal from L2, _amount could exceed l2SupplyFromL1.         // In this case, we just set l2SupplyFromL1 = 0 because there will be no more supply on L2         // that is from L1 and the excess (_amount - l2SupplyFromL1) is inflationary LPT that was         // never from L1 in the first place.         unchecked {             if (_amount > l2SupplyFromL1) {                 l2SupplyFromL1 = 0;             } else {                 l2SupplyFromL1 -= _amount;  // @audit unchecked             }         }          // No event because the L2LPTGateway events are sufficient     }   ```  A similar change can be made here: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L91-L94  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Add the "unchecked" keyword as shown above.  
# Handle  ye0lde   # Vulnerability details  ## Impact Changing the variables from constant to immutable will reduce keccak operations and save gas.  A previous finding with additional explanation and a pointer to the ethereum/solidity issue is here: https://github.com/code-423n4/2021-10-slingshot-findings/issues/3  ## Proof of Concept These variables can simply be changed from `constant` to `immutable`: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L114 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L116 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L121  Additional changes are needed for these variables since they are used in the constructor: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L111 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L59 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L9-L10 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13   Here's an example of the changes needed in the constructor for: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13  ``` contract ControlledGateway is AccessControl, Pausable {     bytes32 public immutable GOVERNOR_ROLE;        address public immutable l1Lpt;     address public immutable l2Lpt;      constructor(address _l1Lpt, address _l2Lpt) {         _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());         _setRoleAdmin(GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE"), DEFAULT_ADMIN_ROLE);          l1Lpt = _l1Lpt;         l2Lpt = _l2Lpt;     }      function pause() external onlyRole(GOVERNOR_ROLE) {         _pause();     }      function unpause() external onlyRole(GOVERNOR_ROLE) {         _unpause();     } } ```  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the constant variables to immutable as described in the POC.    
# Handle  defsec   # Vulnerability details  ## Impact  Based on the context, l2MigratorAddr should be able to be updated after deployment. However, there is no function to update it. On the L2Migrator.sol, l1MigratorAddr can be updated. (https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L101)   ## Proof of Concept  1. Navigate to the following contract variable.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L141  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to define function for setting l2MigratorAddr.  
# Handle  hyh   # Vulnerability details  ## Proof of Concept  In L2LPTGateway contract description the @title is L1LPTGateway  In L2LPTGateway.outboundTransfer function's description there is '@param _data Contains sender and additional data to send to L1' line, while actually function allows no additional data  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on calculations and checks  ## Proof of Concept  (initialStake - claimedInitialStake) figure is calculated after require check, so the subtraction itself can be unchecked. Also, it is done twice now, can save the result to memory and use it.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L2/pool/DelegatorPool.sol#L73  ## Recommended Mitigation Steps  Consider calculating (initialStake - claimedInitialStake) one time and in unchecked scope.  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `L2LPTDataCache.sol:l1CirculatingSupply()`, the code is as follows: ``` File: L2LPTDataCache.sol 88:     function l1CirculatingSupply() public view returns (uint256) { 89:         // After the first update from L1, l1TotalSupply should always be >= l2SupplyFromL1 90:         // The below check is defensive to avoid reverting if this invariant for some reason violated 91:         return 92:             l1TotalSupply >= l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; 95:     } ```  I suspect that statistically, the arithmetic operation `l1TotalSupply - l2SupplyFromL1` should often be triggered. Therefore, caching the 2 variables `l1TotalSupply` and `l2SupplyFromL1` in memory variables would save the 2 SLOADs (~200 gas) in the substraction and cost 4 MLOADs (~12 gas) and 2 MSTOREs (6 gas).  It can be done this way, as an example: `(uint256 _l1TotalSupply, uint256 _l2SupplyFromL1) = (l1TotalSupply, l2SupplyFromL1);`  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `l1TotalSupply` and `l2SupplyFromL1` in local variables  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (2 SLOADs and 1 SUB are avoided with the suggested solution)  ## Proof of Concept In `L2LPTDataCache.sol:l1CirculatingSupply()`, the code is as such: ``` File: L2LPTDataCache.sol 88:     function l1CirculatingSupply() public view returns (uint256) { 89:         // After the first update from L1, l1TotalSupply should always be >= l2SupplyFromL1 90:         // The below check is defensive to avoid reverting if this invariant for some reason violated 91:         return 92:             l1TotalSupply >= l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; 95:     }  ```  Here, in the case of `l1TotalSupply == l2SupplyFromL1`, the substraction is equal to 0, but the computation is still done instead of return the already present 0 value. This could be avoided by making a strict comparison: ``` File: L2LPTDataCache.sol 91:         return 92:             l1TotalSupply > l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use `>` instead of `>=`  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (2 SLOADs and 1 SUB vs 1 MSTORE and 2 MLOADs)  ## Proof of Concept In `DelegatorPool.sol:claim()`, the following calculation is done twice :  ``` (X * _stake) / (initialStake - claimedInitialStake);  where X is either currTotalStake or currTotalFees ```  While I understand a loss of precision could occur by caching the whole calculation, it's possible to save some gas (here, 2 SLOADs and 1 SUB) by caching the result of the denominator's substraction in a variable (`initialStake - claimedInitialStake`) and using this instead of computing the substraction twice.  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  
# Handle  kemmio   # Vulnerability details  ## Impact Vulnerability in requireValidMigration() function gives opportunity to authenticate on behalf of ZERO address (l1addr == ZERO) and migrate locked up bonds, delegators, sender  ## Proof of Concept  L1Migrator contract's functions migrateDelegator(), migrateUnbondingLocks(), migrateSender() use requireValidMigration() to authenticate the migration request, as can be seen in: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L164-L173 https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L214-L228 https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L267-L274  requireValidMigration() checks if l2addr=ZERO and reverts in that's the case: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L506-L509  Next it checks wether msg.sender==l1addr or tries to authenticate with signature otherwise: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L510-L514  It calls recoverSigner() for that purpose which calls ECDS.recover to recover signing address, but before that it checks if signature is empty and returns address(0): https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L522-L524  This functionality can be abused to bypass authentication for ZERO address  Proof of Concept: (add this tests to ./test/unit/L1/l1Migrator.test.ts and run "yarn test test/unit/L1/l1Migrator.test.ts" ) ```       it('migrates delegator for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateDelegator('0x0000000000000000000000000000000000000000', l1EOA.address, '0x', 0, 0, 0, {               value: ethers.utils.parseEther('1'),             });         await expect(tx).to.emit(l1Migrator,'MigrateDelegatorInitiated');       });       it('migrates unbonding locks for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateUnbondingLocks(                 '0x0000000000000000000000000000000000000000',                 l1EOA.address,                 [],                 '0x',                 0,                 0,                 0,                 {                   value: ethers.utils.parseEther('1'),                 },             );         await expect(tx).to.emit(l1Migrator,'MigrateUnbondingLocksInitiated');       });       it('migrates sender for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateSender('0x0000000000000000000000000000000000000000', l1EOA.address, '0x', 0, 0, 0, {               value: ethers.utils.parseEther('1'),             });         await expect(tx).to.emit(l1Migrator,'MigrateSenderInitiated');       }); ```  ## Tools Used  ## Recommended Mitigation Steps Remove these lines: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L522-L524  
# Handle  Dravee   # Vulnerability details  ## Impact Checking non-zero transfer values can avoid an external call to save gas.  ## Proof of Concept Instances missing a non-zero check: ``` arbitrum-lpt-bridge\contracts\L1\gateway\L1LPTGateway.sol:100:            TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount); arbitrum-lpt-bridge\contracts\L1\gateway\L1LPTGateway.sol:150:            TokenLike(l1Token).transferFrom(l1LPTEscrow, to, amount); protocol\contracts\token\BridgeMinter.sol:79:        token.transfer(_newMinterAddr, token.balanceOf(address(this))); protocol\contracts\token\BridgeMinter.sol:109:        token.transfer(l1MigratorAddr, balance);  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check if transfer amount > 0 before executing the transfer  
# Handle  Dravee   # Vulnerability details  ## Impact The `_from` parameter comment is missing on `LivepeerToken.sol:burn()`. The impact is minimal, but as it's commented elsewhere (https://github.com/livepeer/arbitrum-lpt-bridge/blob/af952a58eff5ff84559e25f62e29f2a3d9e176f9/contracts/L2/gateway/L2LPTGateway.sol#L96), I figured I'd mention it.  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/e89be1431024d976b8c97bbe64ec4bdfeb28ec64/contracts/L2/token/LivepeerToken.sol#L32-L36 ``` File: LivepeerToken.sol 32:     /** 33:      * @dev Burns a specific amount of the sender's tokens 34:      * @param _amount The amount of tokens to be burned 35:      */ 36:     function burn(address _from, uint256 _amount) 37:         external 38:         override 39:         onlyRole(BURNER_ROLE) 40:     { 41:         _burn(_from, _amount); 42:         emit Burn(_from, _amount); 43:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Add the missing comment  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `L2LPTDataCache.sol:decreaseL2SupplyFromL1()`, the code is as follows:  ``` File: L2LPTDataCache.sol 57:     function decreaseL2SupplyFromL1(uint256 _amount) external onlyL2LPTGateway { 58:         // If there is a mass withdrawal from L2, _amount could exceed l2SupplyFromL1. 59:         // In this case, we just set l2SupplyFromL1 = 0 because there will be no more supply on L2 60:         // that is from L1 and the excess (_amount - l2SupplyFromL1) is inflationary LPT that was 61:         // never from L1 in the first place. 62:         if (_amount > l2SupplyFromL1) {  63:             l2SupplyFromL1 = 0; 64:         } else { 65:             l2SupplyFromL1 -= _amount; 66:         } 67:  68:         // No event because the L2LPTGateway events are sufficient 69:     } ```  However, this can be optimized : - Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO) - In this case here, if `_amount == l2SupplyFromL1`, `0` should be returned - Avoiding the else clause would avoid some opcodes (1 SUB,  1 SLOAD, 1 MLOAD)  The code would become:  ```         if (_amount >= l2SupplyFromL1) {             l2SupplyFromL1 = 0;         } else {             l2SupplyFromL1 -= _amount;         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use the non-strict greater-than operator in this particular case  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L90-L98  ```solidity function withdrawETHToL1Migrator() external onlyL1Migrator returns (uint256) {     uint256 balance = address(this).balance;      // call() should be safe from re-entrancy here because the L1Migrator and l1MigratorAddr are trusted     (bool ok, ) = l1MigratorAddr.call.value(address(this).balance)("");     require(ok, "BridgeMinter#withdrawETHToL1Migrator: FAIL_CALL");      return balance; } ```  At L94, `address(this).balance` can be replaced with `balance` to avoid unnecessarily repeated read of account balance state to save some gas.   
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L70-L78  ```solidity         // Calculate stake owed to delegator         uint256 currTotalStake = pendingStake();         uint256 owedStake = (currTotalStake * _stake) /             (initialStake - claimedInitialStake);          // Calculate fees owed to delegator         uint256 currTotalFees = pendingFees();         uint256 owedFees = (currTotalFees * _stake) /             (initialStake - claimedInitialStake); ```  The local variable `currTotalStake`, `currTotalFees` is used only once. Making the expression inline can save gas.  Similar issue exists in `L2Migrator.sol#claimStake()`, `L1Migrator.sol#migrateETH()`, `L1Migrator.sol#migrateLPT()`, `L1ArbitrumMessenger.sol#onlyL2Counterpart()`.  ### Recommendation  Change to:  ```solidity         // Calculate stake owed to delegator         uint256 owedStake = (pendingStake() * _stake) /             (initialStake - claimedInitialStake);          // Calculate fees owed to delegator         uint256 owedFees = (pendingFees() * _stake) /             (initialStake - claimedInitialStake); ```   
# Handle  WatchPug   # Vulnerability details  When there are multiple checks, adjusting the sequence to allow the tx to fail earlier can save some gas.  Checks using less gas should be executed earlier than those with higher gas costs, to avoid unnecessary storage read, arithmetic operations, etc when it reverts.  For example:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L255-L275  ```solidity         require(             claimStakeEnabled,             "L2Migrator#claimStake: CLAIM_STAKE_DISABLED"         );          IMerkleSnapshot merkleSnapshot = IMerkleSnapshot(merkleSnapshotAddr);          address delegator = msg.sender;         bytes32 leaf = keccak256(             abi.encodePacked(delegator, _delegate, _stake, _fees)         );          require(             merkleSnapshot.verify(keccak256("LIP-73"), _proof, leaf),             "L2Migrator#claimStake: INVALID_PROOF"         );          require(             !migratedDelegators[delegator],             "L2Migrator#claimStake: ALREADY_MIGRATED"         ); ```  The check of `!migratedDelegators[delegator]` can be done earlier to avoid reading from storage when `migratedDelegators[delegator] == true`.  ## Recommendation  Change to:  ```solidity         require(             claimStakeEnabled,             "L2Migrator#claimStake: CLAIM_STAKE_DISABLED"         );          address delegator = msg.sender;         require(             !migratedDelegators[delegator],             "L2Migrator#claimStake: ALREADY_MIGRATED"         );          IMerkleSnapshot merkleSnapshot = IMerkleSnapshot(merkleSnapshotAddr);         require(             merkleSnapshot.verify(keccak256("LIP-73"), _proof, leaf),             "L2Migrator#claimStake: INVALID_PROOF"         );          bytes32 leaf = keccak256(             abi.encodePacked(delegator, _delegate, _stake, _fees)         ); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L471-L471  ```solidity uint256 total = 0; ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L472-L472  ```solidity for (uint256 i = 0; i < _unbondingLockIds.length; i++) ```  Setting `uint256` variables to `0` is redundant as they default to `0`.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The ControlledGateway.sol contract specifies a custom "GOVERNOR_ROLE" value that is assigned to the _msgsender when the contract is deployed. There is no need to create a custom role when only one role is used in the contract. This custom "GOVERNOR_ROLE" could be replaced with the built-in "DEFAULT_ADMIN_ROLE" value, which is the approach in the contract L1/escrow/L1Escrow.sol.  ## Proof of Concept  The custom role is created [on line 13 of ControlledGateway.sol](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13)  ## Recommended Mitigation Steps  Remove the GOVERNOR_ROLE role in ControlledGateway.sol and use the built-in DEFAULT_ADMIN_ROLE role to save gas  
# Handle  sirhashalot   # Vulnerability details  ## Impact  Strings are broken into 32 byte chunks for operations. Revert error strings over 32 bytes therefore consume extra gas than shorter strings, as [documented publicly](https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#c17b).  ## Proof of Concept  There are dozens of examples of this gas optimization opportunity in the project, but some examples of this issue include: - [L2/gateway/L2Migrator.sol:184](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L184) - [L2/gateway/L2Migrator.sol:201](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L201) - [L2/gateway/L2Migrator.sol:221](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L221) - [L2/gateway/L2Migrator.sol:257](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L257) - [bonding/BondingManager.sol:553](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/bonding/BondingManager.sol#L553) - [bonding/BondingManager.sol:463](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/bonding/BondingManager.sol#L463) - [bonding/BondingManager.sol:651](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/bonding/BondingManager.sol#L651) - [token/Minter.sol:78](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/Minter.sol#L78) - [token/Minter.sol:80](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/Minter.sol#L80) - [token/Minter.sol:93](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/Minter.sol#L93)  ## Recommended Mitigation Steps  Reducing revert error strings to under 32 bytes decreases deployment time gas and runtime gas when the revert condition is met. Alternatively, use custom errors, introduced in Solidity 0.8.4: https://blog.soliditylang.org/2021/04/21/custom-errors/  
# Handle  Ruhum   # Vulnerability details  # Vulnerability details  ## Impact Same thing as the ETH issue I reported earlier. I wasn't sure if those are supposed to be a single issue or not. The concept is the same. But, now you lose LPT tokens.  The `L1Migrator.migrateLPT()` function can be called by **anyone**. It pulls all the LPT from the `BridgeMinter` contract and starts the process of moving the funds to L2. First of all, this function is only executable once. The RetryableTicket created with the first call is the only chance of moving the funds to L2.  The attacker can call the function with [parameters](https://developer.offchainlabs.com/docs/l1_l2_messages#parameters) that make the creation of the RetryableTicket on L2 fail. Thus, the LPT sits in the L1Migrator contract with no way of moving it to L2 or anywhere else. Effectively, the funds are lost.  ## Proof of Concept The function is only executable once because it uses the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` to specify the amount of LPT to be sent to L2: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L342  After the first call to `migrateLPT()` that function will always return 0 since the `BridgeMinter` won't have any more LPT: https://github.com/livepeer/protocol/blob/streamflow/contracts/token/BridgeMinter.sol#L107  So after the attacker called `migrateLPT()` with insufficient funds to create a RetryableTicket on L2 we have the following state: - BridgeMinter has 0 LPT - L1Migrator has X amount of LPT that is not accessible. There are no functions to get the LPT out of there. - 1 failed RetryTicket  The same thing can also be triggered by a non-malicious caller by simply providing insufficient funds. The whole design of only being able to try once is the issue here.  ## Tools Used none  ## Recommended Mitigation Steps Instead of using the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` you should use the balance of the `L1Migrator` contract.  It might also make sense to **not** allow anybody to call the function. I don't see the benefit of that.  `EDIT` Actually, the funds aren't lost. The funds are sent to the Escrow contract which can be used to transfer the funds back to the BridgeMinter contract. Thus, you could reset the whole thing to its initial state and call `L1Migrator.migrateLPT()` again. But, a really persistent attacker has the ability to DoS the function by frontrunning any call to it which results in the RetryableTicket failing again. Thus, you'd have to transfer the funds from the Escrow contract to the BrigeMinter again and so on.  So the same scenario I've outlined earlier is still viable. It's just a bit more difficult now since it has a higher cost for the attacker now. Because of that I think it's an medium issue instead of high.  Also, the mitigation steps I've given aren't valid. You can't use the `L1Migrator` contract's balance since it will always be 0 (the funds are sent to the Escrow contract). Thus the best solution would be to just limit the access to the function.
# Handle  0x1f8b   # Vulnerability details  ## Impact Users and dapps are not notified when someting important is changed.  ## Proof of Concept  Functions that are only executable by privileged users (e.g. onlyOwner) and have an impact (e.g. financial, trust) on other users should emit events.  - contracts\L1\gateway\L1LPTGateway.sol : [setCounterpart,setMinter]. - contracts\L2\gateway\L2Migrator.sol : [setL1Migrator,setDelegatorPoolImpl,setClaimStakeEnabled]. - contracts\L2\gateway\L2LPTGateway.sol : [setCounterpart]. - contracts\L2\gateway\L2LPTDataCache.sol : [setL1LPTDataCache,setL2LPTGateway].  ## Tools Used Manual review.  ## Recommended Mitigation Steps Emit event during important changes.  
# Handle  defsec   # Vulnerability details  ## Impact  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  ## Proof of Concept  1. Navigate to the following smart contract line.  ``` https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L197  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L472 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to cache array length.  
# Handle  Dravee   # Vulnerability details  ## Impact   Reducing from public to private will save gas    ## Proof of Concept   ``` arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:111:    bytes32 public constant GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE"); arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:59:    bytes32 public constant GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE"); arbitrum-lpt-bridge\contracts\L2\token\LivepeerToken.sol:9:    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE"); arbitrum-lpt-bridge\contracts\L2\token\LivepeerToken.sol:10:    bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE"); arbitrum-lpt-bridge\contracts\ControlledGateway.sol:13:    bytes32 public constant GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE"); ```  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Theses constants can simply be read from the verified contract, i.e., it is unnecessary to expose them with a public function.  
# Handle  Dravee   # Vulnerability details  ## Impact   `private` functions are cheaper than `internal` functions.      ## Proof of Concept   Several `internal` functions are in contracts that are never inherited.      Their `internal` keywords are there:      ``` arbitrum-lpt-bridge\contracts\L1\gateway\L1LPTGateway.sol:170:        internal arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:505:    ) internal view { arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:518:        internal arbitrum-lpt-bridge\contracts\L2\gateway\L2LPTGateway.sol:123:        internal arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:307:    ) internal { arbitrum-lpt-bridge\contracts\L2\pool\DelegatorPool.sol:95:    function transferBond(address _delegator, uint256 _stake) internal { arbitrum-lpt-bridge\contracts\L2\pool\DelegatorPool.sol:106:    function pendingStake() internal view returns (uint256) { arbitrum-lpt-bridge\contracts\L2\pool\DelegatorPool.sol:110:    function pendingFees() internal view returns (uint256) { protocol\contracts\Manager.sol:48:    function _onlyController() internal view { protocol\contracts\Manager.sol:52:    function _onlyControllerOwner() internal view { protocol\contracts\Manager.sol:56:    function _whenSystemNotPaused() internal view { protocol\contracts\Manager.sol:60:    function _whenSystemPaused() internal view {   ```     Therefore, their visibility should be reduced to `private`.      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Define these functions as `private`.   
# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ``` arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:159:        bytes memory _sig, arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:209:        bytes memory _sig, arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:262:        bytes memory _sig, arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:130:    function finalizeMigrateDelegator(MigrateDelegatorParams memory _params) arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:195:        MigrateUnbondingLocksParams memory _params arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:215:    function finalizeMigrateSender(MigrateSenderParams memory _params) ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.   
# Handle  Tomio   # Vulnerability details  ## Impact save in memory can save more gas instead of double storage call  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L57  ## Tools Used Remix  ## Recommended Mitigation Steps add `l2SupplyFromL1` to memory example: ```         uint256 savel2SupplyFromL1 = l2SupplyFromL1;         if (_amount > savel2SupplyFromL1) {             savel2SupplyFromL1 = 0;         } else {             savel2SupplyFromL1 -= _amount;         } ```  
# Handle  jayjonah8   # Vulnerability details  ## Impact In files like L1LPTDataCache.sol,  floating pragmas are used.  Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept https://swcregistry.io/docs/SWC-103  ## Tools Used Manual code review   ## Recommended Mitigation Steps Lock the pragma version:  delete pragma solidity 0.8.0 in favor of pragma solidity 0.8.0  
# Handle  Tomio   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1LPTGateway.sol#L227  ## Tools Used Remix  ## Recommended Mitigation Steps change to `bytes memory emptyBytes;`  
# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           L2LPTDataCache.sol, l1CirculatingSupply         L2LPTGateway.sol, outboundTransfer         DelegatorPool.sol, initialize         IController.sol, getContract         Manager.sol, constructor         BridgeMinter.sol, constructor         BridgeMinter.sol, getController   
# Handle  robee   # Vulnerability details           Using newer compiler versions and the optimizer gives gas optimizations         and additional safety checks are available for free.                  The advantages of versions 0.8.* over <0.8.0 are:                  1. Safemath by default from 0.8.0 (can be more gas efficient than library based safemath.)         2. Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls.         3. Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.         4. Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.              IController.sol         IManager.sol         Manager.sol         BridgeMinter.sol   
# Handle  robee   # Vulnerability details  The project is compiled with different versions of solidity, which is not recommended due ti  undefined behaviors as a result of it.           
# Handle  robee   # Vulnerability details  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           L1LPTGateway.sol, getOutboundCalldata         L2LPTGateway.sol, outboundTransfer         L2LPTGateway.sol, getOutboundCalldata  
# Handle  Dravee   # Vulnerability details  ## Impact `msg.sender` costs 2 gas (CALLER opcode). `_msgSender()` represents the following: ``` function _msgSender() internal view virtual returns (address payable) {     return msg.sender; } ``` When no GSN capabilities are used: `msg.sender` is enough.  See https://docs.openzeppelin.com/contracts/2.x/gsn for more information about GSN capabilities.  ## Proof of Concept Instances include: ``` arbitrum-lpt-bridge\contracts\L1\escrow\L1Escrow.sol:18:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:133:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:83:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\contracts\L2\token\LivepeerToken.sol:13:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\contracts\ControlledGateway.sol:19:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Replace `_msgSender()` with `msg.sender`  
# Handle  gzeon   # Vulnerability details  ## Impact Fund can be lost if the L1 call value provided is insufficient to cover `_maxSubmissionCost`, or stuck if insufficient to cover `_maxSubmissionCost + (_maxGas * _gasPriceBid)`.  ## Proof of Concept `outboundTransfer` in `L1LPTGateway` does not check if the call value is sufficient, if it is `< _maxSubmissionCost` the retryable ticket creation will fail and fund is lost; if it is `<_maxSubmissionCost + (_maxGas * _gasPriceBid)` the ticket would require manual execution.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1LPTGateway.sol#L80 ```     function outboundTransfer(         address _l1Token,         address _to,         uint256 _amount,         uint256 _maxGas,         uint256 _gasPriceBid,         bytes calldata _data     ) external payable override whenNotPaused returns (bytes memory) {         require(_l1Token == l1Lpt, "TOKEN_NOT_LPT");          // nested scope to avoid stack too deep errors         address from;         uint256 seqNum;         bytes memory extraData;         {             uint256 maxSubmissionCost;             (from, maxSubmissionCost, extraData) = parseOutboundData(_data);             require(extraData.length == 0, "CALL_HOOK_DATA_NOT_ALLOWED");              // transfer tokens to escrow             TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount);              bytes memory outboundCalldata = getOutboundCalldata(                 _l1Token,                 from,                 _to,                 _amount,                 extraData             );              seqNum = sendTxToL2(                 l2Counterpart,                 from,                 maxSubmissionCost,                 _maxGas,                 _gasPriceBid,                 outboundCalldata             );         }          emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);          return abi.encode(seqNum);     } ```  ## Recommended Mitigation Steps Add check similar to the one used in `L1GatewayRouter` provided by Arbitrum team  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L236 ```         uint256 expectedEth = _maxSubmissionCost + (_maxGas * _gasPriceBid);         require(_maxSubmissionCost > 0, "NO_SUBMISSION_COST");         require(msg.value == expectedEth, "WRONG_ETH_VALUE"); ```  
# Handle  pauliax   # Vulnerability details  ## Impact In contract BridgeMinter function setToken, it just sets the new tokenAddr, but it does not process the old token balance leaving it stuck in the contract. I think that setToken could also migrate the old balance somewhere before updating the token address. I can even suggest adding token rescue functions to the contracts that may come in handy in such cases or if someone accidentally sends the tokens directly to the contract. An owner can rescue the tokens if the token is not protected (e.g. intended to be held in the contract).  ## Recommended Mitigation Steps An example implementation that could help to rescue old token balance: ```solidity   function withdrawLPTToL1Migrator(address _tokenAddr, address _recipient) external onlyControllerOwner returns (uint256) {       require(_tokenAddr != tokenAddr, "protected");        IERC20 token = IERC20(_tokenAddr);        uint256 balance = token.balanceOf(address(this));        token.transfer(_recipient, balance);        return balance;   } ```  
# Handle  0x0x0x   # Vulnerability details  ## Concept  When a variable is declared solidity assigns the default value. In case the contract assigns the value again, it costs extra gas.   Example:`uint x = 0` costs more gas than `uint x` without having any different functionality.  Scope  ``` ./protocol/bonding/libraries/EarningsPool.sol:84:        uint256 delegatorFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:85:        uint256 transcoderFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:115:        uint256 delegatorRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:116:        uint256 transcoderRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:189:        uint256 transcoderFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:190:        uint256 delegatorFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:217:        uint256 transcoderRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:218:        uint256 delegatorRewards = 0; ./protocol/pm/mixins/MixinTicketBrokerCore.sol:121:        uint256 amountToTransfer = 0; ./protocol/token/Minter.sol:223:        uint256 currentBondingRate = 0; ./arbitrum-lpt-bridge/L1/gateway/L1Migrator.sol:471:        uint256 total = 0; ./protocol/zeppelin/MintableToken.sol:17:    bool public mintingFinished = false; ./protocol/zeppelin/Pausable.sol:13:    bool public paused = false;  ```  
# Handle  byterocket   # Vulnerability details  ## Impact  The `_setupRole` function in OpenZeppelin's `AccessControl` contract is marked as deprecated in favor of `_grantRole`. See [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L183).  Following contracts use the deprecated `_setupRole` in their constructor: ``` arbitrum-lpt-bridge:   - ControlledGateway.sol   - L1/escrow/L1Escrow.sol   - L2/gateway/L2Migrator.sol   - token/LivepeerToken.sol   - L1/gateway/L1Migrator.sol ```  ## Recommended Mitigation Steps  Refactor the contracts constructor's to use `_grantRole` instead of `_setupRole`.  
# Handle  WatchPug   # Vulnerability details  Per the `arb-bridge-eth` code:  > all msg.value will deposited to callValueRefundAddress on L2  https://github.com/OffchainLabs/arbitrum/blob/78118ba205854374ed280a27415cb62c37847f72/packages/arb-bridge-eth/contracts/bridge/Inbox.sol#L313  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1ArbitrumMessenger.sol#L65-L74  ```solidity uint256 seqNum = inbox.createRetryableTicket{value: _l1CallValue}(     target,     _l2CallValue,     maxSubmissionCost,     from,     from,     maxGas,     gasPriceBid,     data ); ```  At L308-L309, ETH held by `BridgeMinter` is withdrawn to L1Migrator:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L309  ```solidity         uint256 amount = IBridgeMinter(bridgeMinterAddr)             .withdrawETHToL1Migrator(); ```  However, when calling `sendTxToL2()` the parameter `_l1CallValue` is only the `msg.value`, therefore, the ETH transferred to L2 does not include any funds from `bridgeMinter`.   https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L318-L327  ```solidity     sendTxToL2(         l2MigratorAddr,         address(this), // L2 alias of this contract will receive refunds         msg.value,         amount,         _maxSubmissionCost,         _maxGas,         _gasPriceBid,         ""     ) ```  As a result, due to lack of funds, `call` with value = amount to `l2MigratorAddr` will always fail on L2.  Since there is no other way to send ETH to L2, all the ETH from `bridgeMinter` is now frozen in the contract.  ### Recommendation  Change to:  ```solidity     sendTxToL2(         l2MigratorAddr,         address(this), // L2 alias of this contract will receive refunds         msg.value + amount, // the `amount` withdrawn from BridgeMinter should be added         amount,         _maxSubmissionCost,         _maxGas,         _gasPriceBid,         ""     ) ```  
# Handle  WatchPug   # Vulnerability details  Per the document: https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-73.md#upgrade-process  > *Phase 1* > > - The L1 RoundsManager will be upgraded to disable round initialization at `LIP_73_ROUND` > - During this phase, protocol transactions will be executed normally > - During this phase, the following contracts will be deployed: >     - Protocol contracts on L2 >     - Migrator contracts on L1 and L2 >     - LPT bridge contracts on L1 and L2 >     - ***All of these contracts will start off paused***  However, the current implementation of `L1LPTGateway`, `L2LPTGateway` are not automatically paused on deployment.  We recommend adding `_pause()` to the end of the `constructor()` in `L1LPTGateway`, `L2LPTGateway`, like the constructor of [L1Migrator.sol#L143](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L143-L143), and `unpause()` when Phase 2 starts.   This will help avoid tx to happen in an intermediate state between Phase1 and Phase 2, which may cause certain txs to fail, for instance:  When in Phase 1, `L1LPTGateway` cant calls `bridgeMint()` on the `BridgeMinter` to mint LPT to the user, as L1 Minter have not `migrateToNewMinter()` to `BridgeMinter` yet. If a user in L2 tries to move `LPT` from L2 to L1, their tx may fail.  
# Handle  WatchPug   # Vulnerability details  Per the document: https://github.com/code-423n4/2022-01-livepeer#l2---l1-lpt-withdrawal  > The following occurs when LPT is withdrawn from L2 to L1:  > The user initiates a withdrawal for X LPT. This can be done in two ways: a. Call outboundTransfer() on L2GatewayRouter which will call outboundTransfer() on L2LPTGateway b. Call outboundTransfer() directly on L2LPTGateway  The method (a) described above won't work in the current implementation due to the missing interface on `L2LPTGateway`.  When initiate a withdraw from the Arbitrum Gateway Router, `L2GatewayRouter` will call `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` on `ITokenGateway(gateway)`:  ```solidity function outboundTransfer(     address _token,     address _to,     uint256 _amount,     uint256 _maxGas,     uint256 _gasPriceBid,     bytes calldata _data ) external payable returns (bytes memory); ```  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/arbitrum/gateway/L2GatewayRouter.sol#L57-L64  ```solidity function outboundTransfer(     address _l1Token,     address _to,     uint256 _amount,     bytes calldata _data ) public payable returns (bytes memory) {     return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data); } ```  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/GatewayRouter.sol#L78-L102  ```solidity function outboundTransfer(     address _token,     address _to,     uint256 _amount,     uint256 _maxGas,     uint256 _gasPriceBid,     bytes calldata _data ) public payable virtual override returns (bytes memory) {     address gateway = getGateway(_token);     bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(         msg.sender,         _data     );      emit TransferRouted(_token, msg.sender, _to, gateway);     return         ITokenGateway(gateway).outboundTransfer{ value: msg.value }(             _token,             _to,             _amount,             _maxGas,             _gasPriceBid,             gatewayData         ); } ```  However, `L2LPTGateway` dose not implement `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` but only `outboundTransfer(address,address,uint256,bytes)`:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTGateway.sol#L65-L89  ```solidity function outboundTransfer(     address _l1Token,     address _to,     uint256 _amount,     bytes calldata _data ) public override whenNotPaused returns (bytes memory res) {     // ... } ```  Therefore, the desired feature to withdraw LPT from L2 to L1 via Arbitrum Router will not be working properly.  ## Recommendation  Consider implementing the method used by  Arbitrum Router.  See also the implementation of L2DaiGateway by arbitrum-dai-bridge: https://github.com/makerdao/arbitrum-dai-bridge/blob/master/contracts/l2/L2DaiGateway.sol#L88-L95  
# Handle  Jujic   # Vulnerability details  ## Impact The    initialize    function   does   not   check   if   the   `_bondingManager`   are   all   non-zero   addresses.   If   all  the   initialized   `_bondingManager`   happen   to   be   0,   the   contract   will   have   to   be redeployed.  The  contract are initialized, but their critical init parameters are not logged for any off-chain monitoring.  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L47-L51  ``` function initialize(address _bondingManager) public initializer {         bondingManager = _bondingManager;         migrator = msg.sender;         initialStake = pendingStake();     } ``` Most contracts use initialize() functions instead of constructor given the delegatecall proxy pattern. While most of them emit an event in the critical initialize() functions to record the init parameters for off-chain monitoring and transparency reasons, DelegatorPool.sol not emit such an event in their initialize() function.    ## Tools Used https://github.com/code-423n4/2021-06-pooltogether-findings/issues/68 ## Recommended Mitigation Steps Add check for zero address and emit event.  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L310  ```solidity uint256 amount = IBridgeMinter(bridgeMinterAddr)             .withdrawETHToL1Migrator(); ```  `L1Migrator.sol#migrateETH()` will call `IBridgeMinter(bridgeMinterAddr).withdrawETHToL1Migrator()` to withdraw ETH from `BridgeMinter`.  However, the current implementation of `L1Migrator` is unable to receive ETH.  https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L94-L94  ```solidity (bool ok, ) = l1MigratorAddr.call.value(address(this).balance)(""); ```  A contract receiving Ether must have at least one of the functions below:  - `receive() external payable` - `fallback() external payable`  `receive()` is called if `msg.data` is empty, otherwise `fallback()` is called.  Because `L1Migrator` implement neither `receive()` or `fallback()`, the `call` at L94 will always revert.  ## Impact  All the ETH held by the `BridgeMinter` can get stuck in the contract.  ## Recommandation  Add `receive() external payable {}` in `L1Migrator`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L12-L16  ```solidity constructor() ERC20("Livepeer Token", "LPT") ERC20Permit("Livepeer Token") {     _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);     _setRoleAdmin(BURNER_ROLE, DEFAULT_ADMIN_ROLE); } ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L18-L24  ```solidity constructor(address _l1Lpt, address _l2Lpt) {     _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     _setRoleAdmin(GOVERNOR_ROLE, DEFAULT_ADMIN_ROLE);      l1Lpt = _l1Lpt;     l2Lpt = _l2Lpt; } ```  `constant DEFAULT_ADMIN_ROLE = 0x00`  By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`.  Therefore, `_setRoleAdmin(***_ROLE, DEFAULT_ADMIN_ROLE);` is redundant.  Removing it will make the code simpler and save some gas.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/783ac759a902a7b4a218c2d026a77e6a26b6c42d/contracts/access/AccessControl.sol#L40-L43  ```solidity  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means  * that only accounts with this role will be able to grant or revoke other  * roles. More complex role relationships can be created by using  * {_setRoleAdmin}. ```  https://docs.openzeppelin.com/contracts/3.x/access-control#granting-and-revoking  > AccessControl includes a special role, called DEFAULT_ADMIN_ROLE, which acts as the ***default admin role for all roles***. An account with this role will be able to manage any other role, unless _setRoleAdmin is used to select a new admin role.  ### Recommendation  Remove the redundant code.  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L36-L43  ```solidity function burn(address _from, uint256 _amount)     external     override     onlyRole(BURNER_ROLE) {     _burn(_from, _amount);     emit Burn(_from, _amount); } ```  Using the `burn()` function of `L2LivepeerToken`, an address with `BURNER_ROLE` can burn an arbitrary amount of tokens from any address.  We believe this is unnecessary and poses a serious centralization risk.  A malicious or compromised `BURNER_ROLE` address can take advantage of this, burn the balance of a Uniswap pool and effectively steal almost all the funds from the liquidity pool (eg, Uniswap LPT-WETH Pool).  ### Recommendation  Consider removing the `BURNER_ROLE` and change `burn()` function to:  ```solidity function burn(uint256 _amount)     external     override {     _burn(msg.sender, _amount);     emit Burn(msg.sender, _amount); } ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/49cf5401b0514511675d781a1e29d6b0325cfe88/contracts/L2/gateway/L2LPTGateway.sol#L34-L45  `Mintable(l2Lpt).burn(from, _amount);` in `L2LPTGateway.sol#outboundTransfer()` should also be replaced with:  ```solidity Mintable(l2Lpt).transferFrom(from, _amount); Mintable(l2Lpt).burn(_amount); ```  
# Handle  WatchPug   # Vulnerability details  In the current implementation of `DelegatorPool.sol#claim()`, it first requires `claimedInitialStake < initialStake`, or it throws an error of `DelegatorPool#claim: FULLY_CLAIMED`.  However, since it's an `onlyMigrator` function, the felicity of `_delegator` and `_stake` should be assured by the `Migrator` contract, otherwise, this `require` statement itself also can not prevent bad results caused by the wrong inputs.  Furthermore, even if the purpose of this `require` statement is to make sure that `claimedInitialStake` can never surpass the `initialStake`, the expression should be `claimedInitialStake + _stake <= initialStake` instead of `claimedInitialStake < initialStake`.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L58-L93  ```solidity function claim(address _delegator, uint256 _stake) external onlyMigrator {     require(         claimedInitialStake < initialStake,         "DelegatorPool#claim: FULLY_CLAIMED"     );      // Calculate stake owed to delegator     uint256 currTotalStake = pendingStake();     uint256 owedStake = (currTotalStake * _stake) /         (initialStake - claimedInitialStake);      // Calculate fees owed to delegator     uint256 currTotalFees = pendingFees();     uint256 owedFees = (currTotalFees * _stake) /         (initialStake - claimedInitialStake);      // update claimed balance     claimedInitialStake += _stake;      // Transfer owed stake to the delegator     transferBond(_delegator, owedStake);      // Transfer owed fees to the delegator     IBondingManager(bondingManager).withdrawFees(         payable(_delegator),         owedFees     );      emit Claimed(_delegator, owedStake, owedFees); } ```  ## Recommandation  Consider removing it or changing to:  ```solidity require(     claimedInitialStake + _stake <= initialStake,     "DelegatorPool#claim: FULLY_CLAIMED" ); ```  
# Handle  ye0lde   # Vulnerability details  ## Impact Save Gas With The Unchecked Keyword (L2LPTDataCache.sol)  Redundant arithmetic underflow/overflow checks can be avoided when an underflow/overflow cannot happen.  ## Proof of Concept The "unchecked" keyword can be applied here since there is an `if` statement before to ensure the arithmetic operations would not cause an integer underflow or overflow.: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L57-L69  Change the code to:  ```     function decreaseL2SupplyFromL1(uint256 _amount) external onlyL2LPTGateway {         // If there is a mass withdrawal from L2, _amount could exceed l2SupplyFromL1.         // In this case, we just set l2SupplyFromL1 = 0 because there will be no more supply on L2         // that is from L1 and the excess (_amount - l2SupplyFromL1) is inflationary LPT that was         // never from L1 in the first place.         unchecked {             if (_amount > l2SupplyFromL1) {                 l2SupplyFromL1 = 0;             } else {                 l2SupplyFromL1 -= _amount;  // @audit unchecked             }         }          // No event because the L2LPTGateway events are sufficient     }   ```  A similar change can be made here: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L91-L94  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Add the "unchecked" keyword as shown above.  
# Handle  ye0lde   # Vulnerability details  ## Impact Changing the variables from constant to immutable will reduce keccak operations and save gas.  A previous finding with additional explanation and a pointer to the ethereum/solidity issue is here: https://github.com/code-423n4/2021-10-slingshot-findings/issues/3  ## Proof of Concept These variables can simply be changed from `constant` to `immutable`: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L114 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L116 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L121  Additional changes are needed for these variables since they are used in the constructor: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L111 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L59 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L9-L10 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13   Here's an example of the changes needed in the constructor for: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13  ``` contract ControlledGateway is AccessControl, Pausable {     bytes32 public immutable GOVERNOR_ROLE;        address public immutable l1Lpt;     address public immutable l2Lpt;      constructor(address _l1Lpt, address _l2Lpt) {         _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());         _setRoleAdmin(GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE"), DEFAULT_ADMIN_ROLE);          l1Lpt = _l1Lpt;         l2Lpt = _l2Lpt;     }      function pause() external onlyRole(GOVERNOR_ROLE) {         _pause();     }      function unpause() external onlyRole(GOVERNOR_ROLE) {         _unpause();     } } ```  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the constant variables to immutable as described in the POC.    
# Handle  defsec   # Vulnerability details  ## Impact  Based on the context, l2MigratorAddr should be able to be updated after deployment. However, there is no function to update it. On the L2Migrator.sol, l1MigratorAddr can be updated. (https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L101)   ## Proof of Concept  1. Navigate to the following contract variable.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L141  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to define function for setting l2MigratorAddr.  
# Handle  hyh   # Vulnerability details  ## Proof of Concept  In L2LPTGateway contract description the @title is L1LPTGateway  In L2LPTGateway.outboundTransfer function's description there is '@param _data Contains sender and additional data to send to L1' line, while actually function allows no additional data  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on calculations and checks  ## Proof of Concept  (initialStake - claimedInitialStake) figure is calculated after require check, so the subtraction itself can be unchecked. Also, it is done twice now, can save the result to memory and use it.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L2/pool/DelegatorPool.sol#L73  ## Recommended Mitigation Steps  Consider calculating (initialStake - claimedInitialStake) one time and in unchecked scope.  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `L2LPTDataCache.sol:l1CirculatingSupply()`, the code is as follows: ``` File: L2LPTDataCache.sol 88:     function l1CirculatingSupply() public view returns (uint256) { 89:         // After the first update from L1, l1TotalSupply should always be >= l2SupplyFromL1 90:         // The below check is defensive to avoid reverting if this invariant for some reason violated 91:         return 92:             l1TotalSupply >= l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; 95:     } ```  I suspect that statistically, the arithmetic operation `l1TotalSupply - l2SupplyFromL1` should often be triggered. Therefore, caching the 2 variables `l1TotalSupply` and `l2SupplyFromL1` in memory variables would save the 2 SLOADs (~200 gas) in the substraction and cost 4 MLOADs (~12 gas) and 2 MSTOREs (6 gas).  It can be done this way, as an example: `(uint256 _l1TotalSupply, uint256 _l2SupplyFromL1) = (l1TotalSupply, l2SupplyFromL1);`  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `l1TotalSupply` and `l2SupplyFromL1` in local variables  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (2 SLOADs and 1 SUB are avoided with the suggested solution)  ## Proof of Concept In `L2LPTDataCache.sol:l1CirculatingSupply()`, the code is as such: ``` File: L2LPTDataCache.sol 88:     function l1CirculatingSupply() public view returns (uint256) { 89:         // After the first update from L1, l1TotalSupply should always be >= l2SupplyFromL1 90:         // The below check is defensive to avoid reverting if this invariant for some reason violated 91:         return 92:             l1TotalSupply >= l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; 95:     }  ```  Here, in the case of `l1TotalSupply == l2SupplyFromL1`, the substraction is equal to 0, but the computation is still done instead of return the already present 0 value. This could be avoided by making a strict comparison: ``` File: L2LPTDataCache.sol 91:         return 92:             l1TotalSupply > l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use `>` instead of `>=`  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (2 SLOADs and 1 SUB vs 1 MSTORE and 2 MLOADs)  ## Proof of Concept In `DelegatorPool.sol:claim()`, the following calculation is done twice :  ``` (X * _stake) / (initialStake - claimedInitialStake);  where X is either currTotalStake or currTotalFees ```  While I understand a loss of precision could occur by caching the whole calculation, it's possible to save some gas (here, 2 SLOADs and 1 SUB) by caching the result of the denominator's substraction in a variable (`initialStake - claimedInitialStake`) and using this instead of computing the substraction twice.  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  
# Handle  kemmio   # Vulnerability details  ## Impact Vulnerability in requireValidMigration() function gives opportunity to authenticate on behalf of ZERO address (l1addr == ZERO) and migrate locked up bonds, delegators, sender  ## Proof of Concept  L1Migrator contract's functions migrateDelegator(), migrateUnbondingLocks(), migrateSender() use requireValidMigration() to authenticate the migration request, as can be seen in: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L164-L173 https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L214-L228 https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L267-L274  requireValidMigration() checks if l2addr=ZERO and reverts in that's the case: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L506-L509  Next it checks wether msg.sender==l1addr or tries to authenticate with signature otherwise: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L510-L514  It calls recoverSigner() for that purpose which calls ECDS.recover to recover signing address, but before that it checks if signature is empty and returns address(0): https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L522-L524  This functionality can be abused to bypass authentication for ZERO address  Proof of Concept: (add this tests to ./test/unit/L1/l1Migrator.test.ts and run "yarn test test/unit/L1/l1Migrator.test.ts" ) ```       it('migrates delegator for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateDelegator('0x0000000000000000000000000000000000000000', l1EOA.address, '0x', 0, 0, 0, {               value: ethers.utils.parseEther('1'),             });         await expect(tx).to.emit(l1Migrator,'MigrateDelegatorInitiated');       });       it('migrates unbonding locks for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateUnbondingLocks(                 '0x0000000000000000000000000000000000000000',                 l1EOA.address,                 [],                 '0x',                 0,                 0,                 0,                 {                   value: ethers.utils.parseEther('1'),                 },             );         await expect(tx).to.emit(l1Migrator,'MigrateUnbondingLocksInitiated');       });       it('migrates sender for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateSender('0x0000000000000000000000000000000000000000', l1EOA.address, '0x', 0, 0, 0, {               value: ethers.utils.parseEther('1'),             });         await expect(tx).to.emit(l1Migrator,'MigrateSenderInitiated');       }); ```  ## Tools Used  ## Recommended Mitigation Steps Remove these lines: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L522-L524  
# Handle  Dravee   # Vulnerability details  ## Impact Checking non-zero transfer values can avoid an external call to save gas.  ## Proof of Concept Instances missing a non-zero check: ``` arbitrum-lpt-bridge\contracts\L1\gateway\L1LPTGateway.sol:100:            TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount); arbitrum-lpt-bridge\contracts\L1\gateway\L1LPTGateway.sol:150:            TokenLike(l1Token).transferFrom(l1LPTEscrow, to, amount); protocol\contracts\token\BridgeMinter.sol:79:        token.transfer(_newMinterAddr, token.balanceOf(address(this))); protocol\contracts\token\BridgeMinter.sol:109:        token.transfer(l1MigratorAddr, balance);  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check if transfer amount > 0 before executing the transfer  
# Handle  Dravee   # Vulnerability details  ## Impact The `_from` parameter comment is missing on `LivepeerToken.sol:burn()`. The impact is minimal, but as it's commented elsewhere (https://github.com/livepeer/arbitrum-lpt-bridge/blob/af952a58eff5ff84559e25f62e29f2a3d9e176f9/contracts/L2/gateway/L2LPTGateway.sol#L96), I figured I'd mention it.  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/e89be1431024d976b8c97bbe64ec4bdfeb28ec64/contracts/L2/token/LivepeerToken.sol#L32-L36 ``` File: LivepeerToken.sol 32:     /** 33:      * @dev Burns a specific amount of the sender's tokens 34:      * @param _amount The amount of tokens to be burned 35:      */ 36:     function burn(address _from, uint256 _amount) 37:         external 38:         override 39:         onlyRole(BURNER_ROLE) 40:     { 41:         _burn(_from, _amount); 42:         emit Burn(_from, _amount); 43:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Add the missing comment  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `L2LPTDataCache.sol:decreaseL2SupplyFromL1()`, the code is as follows:  ``` File: L2LPTDataCache.sol 57:     function decreaseL2SupplyFromL1(uint256 _amount) external onlyL2LPTGateway { 58:         // If there is a mass withdrawal from L2, _amount could exceed l2SupplyFromL1. 59:         // In this case, we just set l2SupplyFromL1 = 0 because there will be no more supply on L2 60:         // that is from L1 and the excess (_amount - l2SupplyFromL1) is inflationary LPT that was 61:         // never from L1 in the first place. 62:         if (_amount > l2SupplyFromL1) {  63:             l2SupplyFromL1 = 0; 64:         } else { 65:             l2SupplyFromL1 -= _amount; 66:         } 67:  68:         // No event because the L2LPTGateway events are sufficient 69:     } ```  However, this can be optimized : - Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO) - In this case here, if `_amount == l2SupplyFromL1`, `0` should be returned - Avoiding the else clause would avoid some opcodes (1 SUB,  1 SLOAD, 1 MLOAD)  The code would become:  ```         if (_amount >= l2SupplyFromL1) {             l2SupplyFromL1 = 0;         } else {             l2SupplyFromL1 -= _amount;         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use the non-strict greater-than operator in this particular case  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L90-L98  ```solidity function withdrawETHToL1Migrator() external onlyL1Migrator returns (uint256) {     uint256 balance = address(this).balance;      // call() should be safe from re-entrancy here because the L1Migrator and l1MigratorAddr are trusted     (bool ok, ) = l1MigratorAddr.call.value(address(this).balance)("");     require(ok, "BridgeMinter#withdrawETHToL1Migrator: FAIL_CALL");      return balance; } ```  At L94, `address(this).balance` can be replaced with `balance` to avoid unnecessarily repeated read of account balance state to save some gas.   
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L70-L78  ```solidity         // Calculate stake owed to delegator         uint256 currTotalStake = pendingStake();         uint256 owedStake = (currTotalStake * _stake) /             (initialStake - claimedInitialStake);          // Calculate fees owed to delegator         uint256 currTotalFees = pendingFees();         uint256 owedFees = (currTotalFees * _stake) /             (initialStake - claimedInitialStake); ```  The local variable `currTotalStake`, `currTotalFees` is used only once. Making the expression inline can save gas.  Similar issue exists in `L2Migrator.sol#claimStake()`, `L1Migrator.sol#migrateETH()`, `L1Migrator.sol#migrateLPT()`, `L1ArbitrumMessenger.sol#onlyL2Counterpart()`.  ### Recommendation  Change to:  ```solidity         // Calculate stake owed to delegator         uint256 owedStake = (pendingStake() * _stake) /             (initialStake - claimedInitialStake);          // Calculate fees owed to delegator         uint256 owedFees = (pendingFees() * _stake) /             (initialStake - claimedInitialStake); ```   
# Handle  WatchPug   # Vulnerability details  When there are multiple checks, adjusting the sequence to allow the tx to fail earlier can save some gas.  Checks using less gas should be executed earlier than those with higher gas costs, to avoid unnecessary storage read, arithmetic operations, etc when it reverts.  For example:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L255-L275  ```solidity         require(             claimStakeEnabled,             "L2Migrator#claimStake: CLAIM_STAKE_DISABLED"         );          IMerkleSnapshot merkleSnapshot = IMerkleSnapshot(merkleSnapshotAddr);          address delegator = msg.sender;         bytes32 leaf = keccak256(             abi.encodePacked(delegator, _delegate, _stake, _fees)         );          require(             merkleSnapshot.verify(keccak256("LIP-73"), _proof, leaf),             "L2Migrator#claimStake: INVALID_PROOF"         );          require(             !migratedDelegators[delegator],             "L2Migrator#claimStake: ALREADY_MIGRATED"         ); ```  The check of `!migratedDelegators[delegator]` can be done earlier to avoid reading from storage when `migratedDelegators[delegator] == true`.  ## Recommendation  Change to:  ```solidity         require(             claimStakeEnabled,             "L2Migrator#claimStake: CLAIM_STAKE_DISABLED"         );          address delegator = msg.sender;         require(             !migratedDelegators[delegator],             "L2Migrator#claimStake: ALREADY_MIGRATED"         );          IMerkleSnapshot merkleSnapshot = IMerkleSnapshot(merkleSnapshotAddr);         require(             merkleSnapshot.verify(keccak256("LIP-73"), _proof, leaf),             "L2Migrator#claimStake: INVALID_PROOF"         );          bytes32 leaf = keccak256(             abi.encodePacked(delegator, _delegate, _stake, _fees)         ); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L471-L471  ```solidity uint256 total = 0; ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L472-L472  ```solidity for (uint256 i = 0; i < _unbondingLockIds.length; i++) ```  Setting `uint256` variables to `0` is redundant as they default to `0`.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The ControlledGateway.sol contract specifies a custom "GOVERNOR_ROLE" value that is assigned to the _msgsender when the contract is deployed. There is no need to create a custom role when only one role is used in the contract. This custom "GOVERNOR_ROLE" could be replaced with the built-in "DEFAULT_ADMIN_ROLE" value, which is the approach in the contract L1/escrow/L1Escrow.sol.  ## Proof of Concept  The custom role is created [on line 13 of ControlledGateway.sol](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13)  ## Recommended Mitigation Steps  Remove the GOVERNOR_ROLE role in ControlledGateway.sol and use the built-in DEFAULT_ADMIN_ROLE role to save gas  
# Handle  sirhashalot   # Vulnerability details  ## Impact  Strings are broken into 32 byte chunks for operations. Revert error strings over 32 bytes therefore consume extra gas than shorter strings, as [documented publicly](https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#c17b).  ## Proof of Concept  There are dozens of examples of this gas optimization opportunity in the project, but some examples of this issue include: - [L2/gateway/L2Migrator.sol:184](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L184) - [L2/gateway/L2Migrator.sol:201](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L201) - [L2/gateway/L2Migrator.sol:221](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L221) - [L2/gateway/L2Migrator.sol:257](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L257) - [bonding/BondingManager.sol:553](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/bonding/BondingManager.sol#L553) - [bonding/BondingManager.sol:463](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/bonding/BondingManager.sol#L463) - [bonding/BondingManager.sol:651](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/bonding/BondingManager.sol#L651) - [token/Minter.sol:78](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/Minter.sol#L78) - [token/Minter.sol:80](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/Minter.sol#L80) - [token/Minter.sol:93](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/Minter.sol#L93)  ## Recommended Mitigation Steps  Reducing revert error strings to under 32 bytes decreases deployment time gas and runtime gas when the revert condition is met. Alternatively, use custom errors, introduced in Solidity 0.8.4: https://blog.soliditylang.org/2021/04/21/custom-errors/  
# Handle  Ruhum   # Vulnerability details  # Vulnerability details  ## Impact Same thing as the ETH issue I reported earlier. I wasn't sure if those are supposed to be a single issue or not. The concept is the same. But, now you lose LPT tokens.  The `L1Migrator.migrateLPT()` function can be called by **anyone**. It pulls all the LPT from the `BridgeMinter` contract and starts the process of moving the funds to L2. First of all, this function is only executable once. The RetryableTicket created with the first call is the only chance of moving the funds to L2.  The attacker can call the function with [parameters](https://developer.offchainlabs.com/docs/l1_l2_messages#parameters) that make the creation of the RetryableTicket on L2 fail. Thus, the LPT sits in the L1Migrator contract with no way of moving it to L2 or anywhere else. Effectively, the funds are lost.  ## Proof of Concept The function is only executable once because it uses the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` to specify the amount of LPT to be sent to L2: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L342  After the first call to `migrateLPT()` that function will always return 0 since the `BridgeMinter` won't have any more LPT: https://github.com/livepeer/protocol/blob/streamflow/contracts/token/BridgeMinter.sol#L107  So after the attacker called `migrateLPT()` with insufficient funds to create a RetryableTicket on L2 we have the following state: - BridgeMinter has 0 LPT - L1Migrator has X amount of LPT that is not accessible. There are no functions to get the LPT out of there. - 1 failed RetryTicket  The same thing can also be triggered by a non-malicious caller by simply providing insufficient funds. The whole design of only being able to try once is the issue here.  ## Tools Used none  ## Recommended Mitigation Steps Instead of using the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` you should use the balance of the `L1Migrator` contract.  It might also make sense to **not** allow anybody to call the function. I don't see the benefit of that.  `EDIT` Actually, the funds aren't lost. The funds are sent to the Escrow contract which can be used to transfer the funds back to the BridgeMinter contract. Thus, you could reset the whole thing to its initial state and call `L1Migrator.migrateLPT()` again. But, a really persistent attacker has the ability to DoS the function by frontrunning any call to it which results in the RetryableTicket failing again. Thus, you'd have to transfer the funds from the Escrow contract to the BrigeMinter again and so on.  So the same scenario I've outlined earlier is still viable. It's just a bit more difficult now since it has a higher cost for the attacker now. Because of that I think it's an medium issue instead of high.  Also, the mitigation steps I've given aren't valid. You can't use the `L1Migrator` contract's balance since it will always be 0 (the funds are sent to the Escrow contract). Thus the best solution would be to just limit the access to the function.
# Handle  0x1f8b   # Vulnerability details  ## Impact Users and dapps are not notified when someting important is changed.  ## Proof of Concept  Functions that are only executable by privileged users (e.g. onlyOwner) and have an impact (e.g. financial, trust) on other users should emit events.  - contracts\L1\gateway\L1LPTGateway.sol : [setCounterpart,setMinter]. - contracts\L2\gateway\L2Migrator.sol : [setL1Migrator,setDelegatorPoolImpl,setClaimStakeEnabled]. - contracts\L2\gateway\L2LPTGateway.sol : [setCounterpart]. - contracts\L2\gateway\L2LPTDataCache.sol : [setL1LPTDataCache,setL2LPTGateway].  ## Tools Used Manual review.  ## Recommended Mitigation Steps Emit event during important changes.  
# Handle  defsec   # Vulnerability details  ## Impact  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  ## Proof of Concept  1. Navigate to the following smart contract line.  ``` https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L197  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L472 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to cache array length.  
# Handle  Dravee   # Vulnerability details  ## Impact   Reducing from public to private will save gas    ## Proof of Concept   ``` arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:111:    bytes32 public constant GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE"); arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:59:    bytes32 public constant GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE"); arbitrum-lpt-bridge\contracts\L2\token\LivepeerToken.sol:9:    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE"); arbitrum-lpt-bridge\contracts\L2\token\LivepeerToken.sol:10:    bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE"); arbitrum-lpt-bridge\contracts\ControlledGateway.sol:13:    bytes32 public constant GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE"); ```  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Theses constants can simply be read from the verified contract, i.e., it is unnecessary to expose them with a public function.  
# Handle  Dravee   # Vulnerability details  ## Impact   `private` functions are cheaper than `internal` functions.      ## Proof of Concept   Several `internal` functions are in contracts that are never inherited.      Their `internal` keywords are there:      ``` arbitrum-lpt-bridge\contracts\L1\gateway\L1LPTGateway.sol:170:        internal arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:505:    ) internal view { arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:518:        internal arbitrum-lpt-bridge\contracts\L2\gateway\L2LPTGateway.sol:123:        internal arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:307:    ) internal { arbitrum-lpt-bridge\contracts\L2\pool\DelegatorPool.sol:95:    function transferBond(address _delegator, uint256 _stake) internal { arbitrum-lpt-bridge\contracts\L2\pool\DelegatorPool.sol:106:    function pendingStake() internal view returns (uint256) { arbitrum-lpt-bridge\contracts\L2\pool\DelegatorPool.sol:110:    function pendingFees() internal view returns (uint256) { protocol\contracts\Manager.sol:48:    function _onlyController() internal view { protocol\contracts\Manager.sol:52:    function _onlyControllerOwner() internal view { protocol\contracts\Manager.sol:56:    function _whenSystemNotPaused() internal view { protocol\contracts\Manager.sol:60:    function _whenSystemPaused() internal view {   ```     Therefore, their visibility should be reduced to `private`.      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Define these functions as `private`.   
# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ``` arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:159:        bytes memory _sig, arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:209:        bytes memory _sig, arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:262:        bytes memory _sig, arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:130:    function finalizeMigrateDelegator(MigrateDelegatorParams memory _params) arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:195:        MigrateUnbondingLocksParams memory _params arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:215:    function finalizeMigrateSender(MigrateSenderParams memory _params) ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.   
# Handle  Tomio   # Vulnerability details  ## Impact save in memory can save more gas instead of double storage call  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L57  ## Tools Used Remix  ## Recommended Mitigation Steps add `l2SupplyFromL1` to memory example: ```         uint256 savel2SupplyFromL1 = l2SupplyFromL1;         if (_amount > savel2SupplyFromL1) {             savel2SupplyFromL1 = 0;         } else {             savel2SupplyFromL1 -= _amount;         } ```  
# Handle  jayjonah8   # Vulnerability details  ## Impact In files like L1LPTDataCache.sol,  floating pragmas are used.  Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept https://swcregistry.io/docs/SWC-103  ## Tools Used Manual code review   ## Recommended Mitigation Steps Lock the pragma version:  delete pragma solidity 0.8.0 in favor of pragma solidity 0.8.0  
# Handle  Tomio   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1LPTGateway.sol#L227  ## Tools Used Remix  ## Recommended Mitigation Steps change to `bytes memory emptyBytes;`  
# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           L2LPTDataCache.sol, l1CirculatingSupply         L2LPTGateway.sol, outboundTransfer         DelegatorPool.sol, initialize         IController.sol, getContract         Manager.sol, constructor         BridgeMinter.sol, constructor         BridgeMinter.sol, getController   
# Handle  robee   # Vulnerability details           Using newer compiler versions and the optimizer gives gas optimizations         and additional safety checks are available for free.                  The advantages of versions 0.8.* over <0.8.0 are:                  1. Safemath by default from 0.8.0 (can be more gas efficient than library based safemath.)         2. Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls.         3. Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.         4. Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.              IController.sol         IManager.sol         Manager.sol         BridgeMinter.sol   
# Handle  robee   # Vulnerability details  The project is compiled with different versions of solidity, which is not recommended due ti  undefined behaviors as a result of it.           
# Handle  robee   # Vulnerability details  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           L1LPTGateway.sol, getOutboundCalldata         L2LPTGateway.sol, outboundTransfer         L2LPTGateway.sol, getOutboundCalldata  
# Handle  Dravee   # Vulnerability details  ## Impact `msg.sender` costs 2 gas (CALLER opcode). `_msgSender()` represents the following: ``` function _msgSender() internal view virtual returns (address payable) {     return msg.sender; } ``` When no GSN capabilities are used: `msg.sender` is enough.  See https://docs.openzeppelin.com/contracts/2.x/gsn for more information about GSN capabilities.  ## Proof of Concept Instances include: ``` arbitrum-lpt-bridge\contracts\L1\escrow\L1Escrow.sol:18:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:133:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:83:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\contracts\L2\token\LivepeerToken.sol:13:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\contracts\ControlledGateway.sol:19:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Replace `_msgSender()` with `msg.sender`  
# Handle  gzeon   # Vulnerability details  ## Impact Fund can be lost if the L1 call value provided is insufficient to cover `_maxSubmissionCost`, or stuck if insufficient to cover `_maxSubmissionCost + (_maxGas * _gasPriceBid)`.  ## Proof of Concept `outboundTransfer` in `L1LPTGateway` does not check if the call value is sufficient, if it is `< _maxSubmissionCost` the retryable ticket creation will fail and fund is lost; if it is `<_maxSubmissionCost + (_maxGas * _gasPriceBid)` the ticket would require manual execution.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1LPTGateway.sol#L80 ```     function outboundTransfer(         address _l1Token,         address _to,         uint256 _amount,         uint256 _maxGas,         uint256 _gasPriceBid,         bytes calldata _data     ) external payable override whenNotPaused returns (bytes memory) {         require(_l1Token == l1Lpt, "TOKEN_NOT_LPT");          // nested scope to avoid stack too deep errors         address from;         uint256 seqNum;         bytes memory extraData;         {             uint256 maxSubmissionCost;             (from, maxSubmissionCost, extraData) = parseOutboundData(_data);             require(extraData.length == 0, "CALL_HOOK_DATA_NOT_ALLOWED");              // transfer tokens to escrow             TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount);              bytes memory outboundCalldata = getOutboundCalldata(                 _l1Token,                 from,                 _to,                 _amount,                 extraData             );              seqNum = sendTxToL2(                 l2Counterpart,                 from,                 maxSubmissionCost,                 _maxGas,                 _gasPriceBid,                 outboundCalldata             );         }          emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);          return abi.encode(seqNum);     } ```  ## Recommended Mitigation Steps Add check similar to the one used in `L1GatewayRouter` provided by Arbitrum team  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L236 ```         uint256 expectedEth = _maxSubmissionCost + (_maxGas * _gasPriceBid);         require(_maxSubmissionCost > 0, "NO_SUBMISSION_COST");         require(msg.value == expectedEth, "WRONG_ETH_VALUE"); ```  
# Handle  pauliax   # Vulnerability details  ## Impact In contract BridgeMinter function setToken, it just sets the new tokenAddr, but it does not process the old token balance leaving it stuck in the contract. I think that setToken could also migrate the old balance somewhere before updating the token address. I can even suggest adding token rescue functions to the contracts that may come in handy in such cases or if someone accidentally sends the tokens directly to the contract. An owner can rescue the tokens if the token is not protected (e.g. intended to be held in the contract).  ## Recommended Mitigation Steps An example implementation that could help to rescue old token balance: ```solidity   function withdrawLPTToL1Migrator(address _tokenAddr, address _recipient) external onlyControllerOwner returns (uint256) {       require(_tokenAddr != tokenAddr, "protected");        IERC20 token = IERC20(_tokenAddr);        uint256 balance = token.balanceOf(address(this));        token.transfer(_recipient, balance);        return balance;   } ```  
# Handle  0x0x0x   # Vulnerability details  ## Concept  When a variable is declared solidity assigns the default value. In case the contract assigns the value again, it costs extra gas.   Example:`uint x = 0` costs more gas than `uint x` without having any different functionality.  Scope  ``` ./protocol/bonding/libraries/EarningsPool.sol:84:        uint256 delegatorFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:85:        uint256 transcoderFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:115:        uint256 delegatorRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:116:        uint256 transcoderRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:189:        uint256 transcoderFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:190:        uint256 delegatorFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:217:        uint256 transcoderRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:218:        uint256 delegatorRewards = 0; ./protocol/pm/mixins/MixinTicketBrokerCore.sol:121:        uint256 amountToTransfer = 0; ./protocol/token/Minter.sol:223:        uint256 currentBondingRate = 0; ./arbitrum-lpt-bridge/L1/gateway/L1Migrator.sol:471:        uint256 total = 0; ./protocol/zeppelin/MintableToken.sol:17:    bool public mintingFinished = false; ./protocol/zeppelin/Pausable.sol:13:    bool public paused = false;  ```  
# Handle  byterocket   # Vulnerability details  ## Impact  The `_setupRole` function in OpenZeppelin's `AccessControl` contract is marked as deprecated in favor of `_grantRole`. See [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L183).  Following contracts use the deprecated `_setupRole` in their constructor: ``` arbitrum-lpt-bridge:   - ControlledGateway.sol   - L1/escrow/L1Escrow.sol   - L2/gateway/L2Migrator.sol   - token/LivepeerToken.sol   - L1/gateway/L1Migrator.sol ```  ## Recommended Mitigation Steps  Refactor the contracts constructor's to use `_grantRole` instead of `_setupRole`.  
# Handle  WatchPug   # Vulnerability details  Per the `arb-bridge-eth` code:  > all msg.value will deposited to callValueRefundAddress on L2  https://github.com/OffchainLabs/arbitrum/blob/78118ba205854374ed280a27415cb62c37847f72/packages/arb-bridge-eth/contracts/bridge/Inbox.sol#L313  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1ArbitrumMessenger.sol#L65-L74  ```solidity uint256 seqNum = inbox.createRetryableTicket{value: _l1CallValue}(     target,     _l2CallValue,     maxSubmissionCost,     from,     from,     maxGas,     gasPriceBid,     data ); ```  At L308-L309, ETH held by `BridgeMinter` is withdrawn to L1Migrator:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L309  ```solidity         uint256 amount = IBridgeMinter(bridgeMinterAddr)             .withdrawETHToL1Migrator(); ```  However, when calling `sendTxToL2()` the parameter `_l1CallValue` is only the `msg.value`, therefore, the ETH transferred to L2 does not include any funds from `bridgeMinter`.   https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L318-L327  ```solidity     sendTxToL2(         l2MigratorAddr,         address(this), // L2 alias of this contract will receive refunds         msg.value,         amount,         _maxSubmissionCost,         _maxGas,         _gasPriceBid,         ""     ) ```  As a result, due to lack of funds, `call` with value = amount to `l2MigratorAddr` will always fail on L2.  Since there is no other way to send ETH to L2, all the ETH from `bridgeMinter` is now frozen in the contract.  ### Recommendation  Change to:  ```solidity     sendTxToL2(         l2MigratorAddr,         address(this), // L2 alias of this contract will receive refunds         msg.value + amount, // the `amount` withdrawn from BridgeMinter should be added         amount,         _maxSubmissionCost,         _maxGas,         _gasPriceBid,         ""     ) ```  
# Handle  WatchPug   # Vulnerability details  Per the document: https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-73.md#upgrade-process  > *Phase 1* > > - The L1 RoundsManager will be upgraded to disable round initialization at `LIP_73_ROUND` > - During this phase, protocol transactions will be executed normally > - During this phase, the following contracts will be deployed: >     - Protocol contracts on L2 >     - Migrator contracts on L1 and L2 >     - LPT bridge contracts on L1 and L2 >     - ***All of these contracts will start off paused***  However, the current implementation of `L1LPTGateway`, `L2LPTGateway` are not automatically paused on deployment.  We recommend adding `_pause()` to the end of the `constructor()` in `L1LPTGateway`, `L2LPTGateway`, like the constructor of [L1Migrator.sol#L143](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L143-L143), and `unpause()` when Phase 2 starts.   This will help avoid tx to happen in an intermediate state between Phase1 and Phase 2, which may cause certain txs to fail, for instance:  When in Phase 1, `L1LPTGateway` cant calls `bridgeMint()` on the `BridgeMinter` to mint LPT to the user, as L1 Minter have not `migrateToNewMinter()` to `BridgeMinter` yet. If a user in L2 tries to move `LPT` from L2 to L1, their tx may fail.  
# Handle  WatchPug   # Vulnerability details  Per the document: https://github.com/code-423n4/2022-01-livepeer#l2---l1-lpt-withdrawal  > The following occurs when LPT is withdrawn from L2 to L1:  > The user initiates a withdrawal for X LPT. This can be done in two ways: a. Call outboundTransfer() on L2GatewayRouter which will call outboundTransfer() on L2LPTGateway b. Call outboundTransfer() directly on L2LPTGateway  The method (a) described above won't work in the current implementation due to the missing interface on `L2LPTGateway`.  When initiate a withdraw from the Arbitrum Gateway Router, `L2GatewayRouter` will call `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` on `ITokenGateway(gateway)`:  ```solidity function outboundTransfer(     address _token,     address _to,     uint256 _amount,     uint256 _maxGas,     uint256 _gasPriceBid,     bytes calldata _data ) external payable returns (bytes memory); ```  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/arbitrum/gateway/L2GatewayRouter.sol#L57-L64  ```solidity function outboundTransfer(     address _l1Token,     address _to,     uint256 _amount,     bytes calldata _data ) public payable returns (bytes memory) {     return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data); } ```  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/GatewayRouter.sol#L78-L102  ```solidity function outboundTransfer(     address _token,     address _to,     uint256 _amount,     uint256 _maxGas,     uint256 _gasPriceBid,     bytes calldata _data ) public payable virtual override returns (bytes memory) {     address gateway = getGateway(_token);     bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(         msg.sender,         _data     );      emit TransferRouted(_token, msg.sender, _to, gateway);     return         ITokenGateway(gateway).outboundTransfer{ value: msg.value }(             _token,             _to,             _amount,             _maxGas,             _gasPriceBid,             gatewayData         ); } ```  However, `L2LPTGateway` dose not implement `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` but only `outboundTransfer(address,address,uint256,bytes)`:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTGateway.sol#L65-L89  ```solidity function outboundTransfer(     address _l1Token,     address _to,     uint256 _amount,     bytes calldata _data ) public override whenNotPaused returns (bytes memory res) {     // ... } ```  Therefore, the desired feature to withdraw LPT from L2 to L1 via Arbitrum Router will not be working properly.  ## Recommendation  Consider implementing the method used by  Arbitrum Router.  See also the implementation of L2DaiGateway by arbitrum-dai-bridge: https://github.com/makerdao/arbitrum-dai-bridge/blob/master/contracts/l2/L2DaiGateway.sol#L88-L95  
# Handle  Jujic   # Vulnerability details  ## Impact The    initialize    function   does   not   check   if   the   `_bondingManager`   are   all   non-zero   addresses.   If   all  the   initialized   `_bondingManager`   happen   to   be   0,   the   contract   will   have   to   be redeployed.  The  contract are initialized, but their critical init parameters are not logged for any off-chain monitoring.  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L47-L51  ``` function initialize(address _bondingManager) public initializer {         bondingManager = _bondingManager;         migrator = msg.sender;         initialStake = pendingStake();     } ``` Most contracts use initialize() functions instead of constructor given the delegatecall proxy pattern. While most of them emit an event in the critical initialize() functions to record the init parameters for off-chain monitoring and transparency reasons, DelegatorPool.sol not emit such an event in their initialize() function.    ## Tools Used https://github.com/code-423n4/2021-06-pooltogether-findings/issues/68 ## Recommended Mitigation Steps Add check for zero address and emit event.  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L310  ```solidity uint256 amount = IBridgeMinter(bridgeMinterAddr)             .withdrawETHToL1Migrator(); ```  `L1Migrator.sol#migrateETH()` will call `IBridgeMinter(bridgeMinterAddr).withdrawETHToL1Migrator()` to withdraw ETH from `BridgeMinter`.  However, the current implementation of `L1Migrator` is unable to receive ETH.  https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L94-L94  ```solidity (bool ok, ) = l1MigratorAddr.call.value(address(this).balance)(""); ```  A contract receiving Ether must have at least one of the functions below:  - `receive() external payable` - `fallback() external payable`  `receive()` is called if `msg.data` is empty, otherwise `fallback()` is called.  Because `L1Migrator` implement neither `receive()` or `fallback()`, the `call` at L94 will always revert.  ## Impact  All the ETH held by the `BridgeMinter` can get stuck in the contract.  ## Recommandation  Add `receive() external payable {}` in `L1Migrator`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L12-L16  ```solidity constructor() ERC20("Livepeer Token", "LPT") ERC20Permit("Livepeer Token") {     _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);     _setRoleAdmin(BURNER_ROLE, DEFAULT_ADMIN_ROLE); } ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L18-L24  ```solidity constructor(address _l1Lpt, address _l2Lpt) {     _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     _setRoleAdmin(GOVERNOR_ROLE, DEFAULT_ADMIN_ROLE);      l1Lpt = _l1Lpt;     l2Lpt = _l2Lpt; } ```  `constant DEFAULT_ADMIN_ROLE = 0x00`  By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`.  Therefore, `_setRoleAdmin(***_ROLE, DEFAULT_ADMIN_ROLE);` is redundant.  Removing it will make the code simpler and save some gas.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/783ac759a902a7b4a218c2d026a77e6a26b6c42d/contracts/access/AccessControl.sol#L40-L43  ```solidity  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means  * that only accounts with this role will be able to grant or revoke other  * roles. More complex role relationships can be created by using  * {_setRoleAdmin}. ```  https://docs.openzeppelin.com/contracts/3.x/access-control#granting-and-revoking  > AccessControl includes a special role, called DEFAULT_ADMIN_ROLE, which acts as the ***default admin role for all roles***. An account with this role will be able to manage any other role, unless _setRoleAdmin is used to select a new admin role.  ### Recommendation  Remove the redundant code.  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L36-L43  ```solidity function burn(address _from, uint256 _amount)     external     override     onlyRole(BURNER_ROLE) {     _burn(_from, _amount);     emit Burn(_from, _amount); } ```  Using the `burn()` function of `L2LivepeerToken`, an address with `BURNER_ROLE` can burn an arbitrary amount of tokens from any address.  We believe this is unnecessary and poses a serious centralization risk.  A malicious or compromised `BURNER_ROLE` address can take advantage of this, burn the balance of a Uniswap pool and effectively steal almost all the funds from the liquidity pool (eg, Uniswap LPT-WETH Pool).  ### Recommendation  Consider removing the `BURNER_ROLE` and change `burn()` function to:  ```solidity function burn(uint256 _amount)     external     override {     _burn(msg.sender, _amount);     emit Burn(msg.sender, _amount); } ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/49cf5401b0514511675d781a1e29d6b0325cfe88/contracts/L2/gateway/L2LPTGateway.sol#L34-L45  `Mintable(l2Lpt).burn(from, _amount);` in `L2LPTGateway.sol#outboundTransfer()` should also be replaced with:  ```solidity Mintable(l2Lpt).transferFrom(from, _amount); Mintable(l2Lpt).burn(_amount); ```  
# Handle  WatchPug   # Vulnerability details  In the current implementation of `DelegatorPool.sol#claim()`, it first requires `claimedInitialStake < initialStake`, or it throws an error of `DelegatorPool#claim: FULLY_CLAIMED`.  However, since it's an `onlyMigrator` function, the felicity of `_delegator` and `_stake` should be assured by the `Migrator` contract, otherwise, this `require` statement itself also can not prevent bad results caused by the wrong inputs.  Furthermore, even if the purpose of this `require` statement is to make sure that `claimedInitialStake` can never surpass the `initialStake`, the expression should be `claimedInitialStake + _stake <= initialStake` instead of `claimedInitialStake < initialStake`.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L58-L93  ```solidity function claim(address _delegator, uint256 _stake) external onlyMigrator {     require(         claimedInitialStake < initialStake,         "DelegatorPool#claim: FULLY_CLAIMED"     );      // Calculate stake owed to delegator     uint256 currTotalStake = pendingStake();     uint256 owedStake = (currTotalStake * _stake) /         (initialStake - claimedInitialStake);      // Calculate fees owed to delegator     uint256 currTotalFees = pendingFees();     uint256 owedFees = (currTotalFees * _stake) /         (initialStake - claimedInitialStake);      // update claimed balance     claimedInitialStake += _stake;      // Transfer owed stake to the delegator     transferBond(_delegator, owedStake);      // Transfer owed fees to the delegator     IBondingManager(bondingManager).withdrawFees(         payable(_delegator),         owedFees     );      emit Claimed(_delegator, owedStake, owedFees); } ```  ## Recommandation  Consider removing it or changing to:  ```solidity require(     claimedInitialStake + _stake <= initialStake,     "DelegatorPool#claim: FULLY_CLAIMED" ); ```  
# Handle  ye0lde   # Vulnerability details  ## Impact Save Gas With The Unchecked Keyword (L2LPTDataCache.sol)  Redundant arithmetic underflow/overflow checks can be avoided when an underflow/overflow cannot happen.  ## Proof of Concept The "unchecked" keyword can be applied here since there is an `if` statement before to ensure the arithmetic operations would not cause an integer underflow or overflow.: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L57-L69  Change the code to:  ```     function decreaseL2SupplyFromL1(uint256 _amount) external onlyL2LPTGateway {         // If there is a mass withdrawal from L2, _amount could exceed l2SupplyFromL1.         // In this case, we just set l2SupplyFromL1 = 0 because there will be no more supply on L2         // that is from L1 and the excess (_amount - l2SupplyFromL1) is inflationary LPT that was         // never from L1 in the first place.         unchecked {             if (_amount > l2SupplyFromL1) {                 l2SupplyFromL1 = 0;             } else {                 l2SupplyFromL1 -= _amount;  // @audit unchecked             }         }          // No event because the L2LPTGateway events are sufficient     }   ```  A similar change can be made here: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L91-L94  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Add the "unchecked" keyword as shown above.  
# Handle  ye0lde   # Vulnerability details  ## Impact Changing the variables from constant to immutable will reduce keccak operations and save gas.  A previous finding with additional explanation and a pointer to the ethereum/solidity issue is here: https://github.com/code-423n4/2021-10-slingshot-findings/issues/3  ## Proof of Concept These variables can simply be changed from `constant` to `immutable`: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L114 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L116 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L121  Additional changes are needed for these variables since they are used in the constructor: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L111 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L59 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L9-L10 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13   Here's an example of the changes needed in the constructor for: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13  ``` contract ControlledGateway is AccessControl, Pausable {     bytes32 public immutable GOVERNOR_ROLE;        address public immutable l1Lpt;     address public immutable l2Lpt;      constructor(address _l1Lpt, address _l2Lpt) {         _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());         _setRoleAdmin(GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE"), DEFAULT_ADMIN_ROLE);          l1Lpt = _l1Lpt;         l2Lpt = _l2Lpt;     }      function pause() external onlyRole(GOVERNOR_ROLE) {         _pause();     }      function unpause() external onlyRole(GOVERNOR_ROLE) {         _unpause();     } } ```  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the constant variables to immutable as described in the POC.    
# Handle  defsec   # Vulnerability details  ## Impact  Based on the context, l2MigratorAddr should be able to be updated after deployment. However, there is no function to update it. On the L2Migrator.sol, l1MigratorAddr can be updated. (https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L101)   ## Proof of Concept  1. Navigate to the following contract variable.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L141  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to define function for setting l2MigratorAddr.  
# Handle  hyh   # Vulnerability details  ## Proof of Concept  In L2LPTGateway contract description the @title is L1LPTGateway  In L2LPTGateway.outboundTransfer function's description there is '@param _data Contains sender and additional data to send to L1' line, while actually function allows no additional data  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on calculations and checks  ## Proof of Concept  (initialStake - claimedInitialStake) figure is calculated after require check, so the subtraction itself can be unchecked. Also, it is done twice now, can save the result to memory and use it.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L2/pool/DelegatorPool.sol#L73  ## Recommended Mitigation Steps  Consider calculating (initialStake - claimedInitialStake) one time and in unchecked scope.  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `L2LPTDataCache.sol:l1CirculatingSupply()`, the code is as follows: ``` File: L2LPTDataCache.sol 88:     function l1CirculatingSupply() public view returns (uint256) { 89:         // After the first update from L1, l1TotalSupply should always be >= l2SupplyFromL1 90:         // The below check is defensive to avoid reverting if this invariant for some reason violated 91:         return 92:             l1TotalSupply >= l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; 95:     } ```  I suspect that statistically, the arithmetic operation `l1TotalSupply - l2SupplyFromL1` should often be triggered. Therefore, caching the 2 variables `l1TotalSupply` and `l2SupplyFromL1` in memory variables would save the 2 SLOADs (~200 gas) in the substraction and cost 4 MLOADs (~12 gas) and 2 MSTOREs (6 gas).  It can be done this way, as an example: `(uint256 _l1TotalSupply, uint256 _l2SupplyFromL1) = (l1TotalSupply, l2SupplyFromL1);`  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `l1TotalSupply` and `l2SupplyFromL1` in local variables  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (2 SLOADs and 1 SUB are avoided with the suggested solution)  ## Proof of Concept In `L2LPTDataCache.sol:l1CirculatingSupply()`, the code is as such: ``` File: L2LPTDataCache.sol 88:     function l1CirculatingSupply() public view returns (uint256) { 89:         // After the first update from L1, l1TotalSupply should always be >= l2SupplyFromL1 90:         // The below check is defensive to avoid reverting if this invariant for some reason violated 91:         return 92:             l1TotalSupply >= l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; 95:     }  ```  Here, in the case of `l1TotalSupply == l2SupplyFromL1`, the substraction is equal to 0, but the computation is still done instead of return the already present 0 value. This could be avoided by making a strict comparison: ``` File: L2LPTDataCache.sol 91:         return 92:             l1TotalSupply > l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use `>` instead of `>=`  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (2 SLOADs and 1 SUB vs 1 MSTORE and 2 MLOADs)  ## Proof of Concept In `DelegatorPool.sol:claim()`, the following calculation is done twice :  ``` (X * _stake) / (initialStake - claimedInitialStake);  where X is either currTotalStake or currTotalFees ```  While I understand a loss of precision could occur by caching the whole calculation, it's possible to save some gas (here, 2 SLOADs and 1 SUB) by caching the result of the denominator's substraction in a variable (`initialStake - claimedInitialStake`) and using this instead of computing the substraction twice.  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  
# Handle  kemmio   # Vulnerability details  ## Impact Vulnerability in requireValidMigration() function gives opportunity to authenticate on behalf of ZERO address (l1addr == ZERO) and migrate locked up bonds, delegators, sender  ## Proof of Concept  L1Migrator contract's functions migrateDelegator(), migrateUnbondingLocks(), migrateSender() use requireValidMigration() to authenticate the migration request, as can be seen in: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L164-L173 https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L214-L228 https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L267-L274  requireValidMigration() checks if l2addr=ZERO and reverts in that's the case: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L506-L509  Next it checks wether msg.sender==l1addr or tries to authenticate with signature otherwise: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L510-L514  It calls recoverSigner() for that purpose which calls ECDS.recover to recover signing address, but before that it checks if signature is empty and returns address(0): https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L522-L524  This functionality can be abused to bypass authentication for ZERO address  Proof of Concept: (add this tests to ./test/unit/L1/l1Migrator.test.ts and run "yarn test test/unit/L1/l1Migrator.test.ts" ) ```       it('migrates delegator for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateDelegator('0x0000000000000000000000000000000000000000', l1EOA.address, '0x', 0, 0, 0, {               value: ethers.utils.parseEther('1'),             });         await expect(tx).to.emit(l1Migrator,'MigrateDelegatorInitiated');       });       it('migrates unbonding locks for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateUnbondingLocks(                 '0x0000000000000000000000000000000000000000',                 l1EOA.address,                 [],                 '0x',                 0,                 0,                 0,                 {                   value: ethers.utils.parseEther('1'),                 },             );         await expect(tx).to.emit(l1Migrator,'MigrateUnbondingLocksInitiated');       });       it('migrates sender for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateSender('0x0000000000000000000000000000000000000000', l1EOA.address, '0x', 0, 0, 0, {               value: ethers.utils.parseEther('1'),             });         await expect(tx).to.emit(l1Migrator,'MigrateSenderInitiated');       }); ```  ## Tools Used  ## Recommended Mitigation Steps Remove these lines: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L522-L524  
# Handle  Dravee   # Vulnerability details  ## Impact Checking non-zero transfer values can avoid an external call to save gas.  ## Proof of Concept Instances missing a non-zero check: ``` arbitrum-lpt-bridge\contracts\L1\gateway\L1LPTGateway.sol:100:            TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount); arbitrum-lpt-bridge\contracts\L1\gateway\L1LPTGateway.sol:150:            TokenLike(l1Token).transferFrom(l1LPTEscrow, to, amount); protocol\contracts\token\BridgeMinter.sol:79:        token.transfer(_newMinterAddr, token.balanceOf(address(this))); protocol\contracts\token\BridgeMinter.sol:109:        token.transfer(l1MigratorAddr, balance);  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check if transfer amount > 0 before executing the transfer  
# Handle  Dravee   # Vulnerability details  ## Impact The `_from` parameter comment is missing on `LivepeerToken.sol:burn()`. The impact is minimal, but as it's commented elsewhere (https://github.com/livepeer/arbitrum-lpt-bridge/blob/af952a58eff5ff84559e25f62e29f2a3d9e176f9/contracts/L2/gateway/L2LPTGateway.sol#L96), I figured I'd mention it.  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/e89be1431024d976b8c97bbe64ec4bdfeb28ec64/contracts/L2/token/LivepeerToken.sol#L32-L36 ``` File: LivepeerToken.sol 32:     /** 33:      * @dev Burns a specific amount of the sender's tokens 34:      * @param _amount The amount of tokens to be burned 35:      */ 36:     function burn(address _from, uint256 _amount) 37:         external 38:         override 39:         onlyRole(BURNER_ROLE) 40:     { 41:         _burn(_from, _amount); 42:         emit Burn(_from, _amount); 43:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Add the missing comment  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `L2LPTDataCache.sol:decreaseL2SupplyFromL1()`, the code is as follows:  ``` File: L2LPTDataCache.sol 57:     function decreaseL2SupplyFromL1(uint256 _amount) external onlyL2LPTGateway { 58:         // If there is a mass withdrawal from L2, _amount could exceed l2SupplyFromL1. 59:         // In this case, we just set l2SupplyFromL1 = 0 because there will be no more supply on L2 60:         // that is from L1 and the excess (_amount - l2SupplyFromL1) is inflationary LPT that was 61:         // never from L1 in the first place. 62:         if (_amount > l2SupplyFromL1) {  63:             l2SupplyFromL1 = 0; 64:         } else { 65:             l2SupplyFromL1 -= _amount; 66:         } 67:  68:         // No event because the L2LPTGateway events are sufficient 69:     } ```  However, this can be optimized : - Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO) - In this case here, if `_amount == l2SupplyFromL1`, `0` should be returned - Avoiding the else clause would avoid some opcodes (1 SUB,  1 SLOAD, 1 MLOAD)  The code would become:  ```         if (_amount >= l2SupplyFromL1) {             l2SupplyFromL1 = 0;         } else {             l2SupplyFromL1 -= _amount;         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use the non-strict greater-than operator in this particular case  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L90-L98  ```solidity function withdrawETHToL1Migrator() external onlyL1Migrator returns (uint256) {     uint256 balance = address(this).balance;      // call() should be safe from re-entrancy here because the L1Migrator and l1MigratorAddr are trusted     (bool ok, ) = l1MigratorAddr.call.value(address(this).balance)("");     require(ok, "BridgeMinter#withdrawETHToL1Migrator: FAIL_CALL");      return balance; } ```  At L94, `address(this).balance` can be replaced with `balance` to avoid unnecessarily repeated read of account balance state to save some gas.   
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L70-L78  ```solidity         // Calculate stake owed to delegator         uint256 currTotalStake = pendingStake();         uint256 owedStake = (currTotalStake * _stake) /             (initialStake - claimedInitialStake);          // Calculate fees owed to delegator         uint256 currTotalFees = pendingFees();         uint256 owedFees = (currTotalFees * _stake) /             (initialStake - claimedInitialStake); ```  The local variable `currTotalStake`, `currTotalFees` is used only once. Making the expression inline can save gas.  Similar issue exists in `L2Migrator.sol#claimStake()`, `L1Migrator.sol#migrateETH()`, `L1Migrator.sol#migrateLPT()`, `L1ArbitrumMessenger.sol#onlyL2Counterpart()`.  ### Recommendation  Change to:  ```solidity         // Calculate stake owed to delegator         uint256 owedStake = (pendingStake() * _stake) /             (initialStake - claimedInitialStake);          // Calculate fees owed to delegator         uint256 owedFees = (pendingFees() * _stake) /             (initialStake - claimedInitialStake); ```   
# Handle  WatchPug   # Vulnerability details  When there are multiple checks, adjusting the sequence to allow the tx to fail earlier can save some gas.  Checks using less gas should be executed earlier than those with higher gas costs, to avoid unnecessary storage read, arithmetic operations, etc when it reverts.  For example:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L255-L275  ```solidity         require(             claimStakeEnabled,             "L2Migrator#claimStake: CLAIM_STAKE_DISABLED"         );          IMerkleSnapshot merkleSnapshot = IMerkleSnapshot(merkleSnapshotAddr);          address delegator = msg.sender;         bytes32 leaf = keccak256(             abi.encodePacked(delegator, _delegate, _stake, _fees)         );          require(             merkleSnapshot.verify(keccak256("LIP-73"), _proof, leaf),             "L2Migrator#claimStake: INVALID_PROOF"         );          require(             !migratedDelegators[delegator],             "L2Migrator#claimStake: ALREADY_MIGRATED"         ); ```  The check of `!migratedDelegators[delegator]` can be done earlier to avoid reading from storage when `migratedDelegators[delegator] == true`.  ## Recommendation  Change to:  ```solidity         require(             claimStakeEnabled,             "L2Migrator#claimStake: CLAIM_STAKE_DISABLED"         );          address delegator = msg.sender;         require(             !migratedDelegators[delegator],             "L2Migrator#claimStake: ALREADY_MIGRATED"         );          IMerkleSnapshot merkleSnapshot = IMerkleSnapshot(merkleSnapshotAddr);         require(             merkleSnapshot.verify(keccak256("LIP-73"), _proof, leaf),             "L2Migrator#claimStake: INVALID_PROOF"         );          bytes32 leaf = keccak256(             abi.encodePacked(delegator, _delegate, _stake, _fees)         ); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L471-L471  ```solidity uint256 total = 0; ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L472-L472  ```solidity for (uint256 i = 0; i < _unbondingLockIds.length; i++) ```  Setting `uint256` variables to `0` is redundant as they default to `0`.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The ControlledGateway.sol contract specifies a custom "GOVERNOR_ROLE" value that is assigned to the _msgsender when the contract is deployed. There is no need to create a custom role when only one role is used in the contract. This custom "GOVERNOR_ROLE" could be replaced with the built-in "DEFAULT_ADMIN_ROLE" value, which is the approach in the contract L1/escrow/L1Escrow.sol.  ## Proof of Concept  The custom role is created [on line 13 of ControlledGateway.sol](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13)  ## Recommended Mitigation Steps  Remove the GOVERNOR_ROLE role in ControlledGateway.sol and use the built-in DEFAULT_ADMIN_ROLE role to save gas  
# Handle  sirhashalot   # Vulnerability details  ## Impact  Strings are broken into 32 byte chunks for operations. Revert error strings over 32 bytes therefore consume extra gas than shorter strings, as [documented publicly](https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#c17b).  ## Proof of Concept  There are dozens of examples of this gas optimization opportunity in the project, but some examples of this issue include: - [L2/gateway/L2Migrator.sol:184](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L184) - [L2/gateway/L2Migrator.sol:201](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L201) - [L2/gateway/L2Migrator.sol:221](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L221) - [L2/gateway/L2Migrator.sol:257](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L257) - [bonding/BondingManager.sol:553](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/bonding/BondingManager.sol#L553) - [bonding/BondingManager.sol:463](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/bonding/BondingManager.sol#L463) - [bonding/BondingManager.sol:651](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/bonding/BondingManager.sol#L651) - [token/Minter.sol:78](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/Minter.sol#L78) - [token/Minter.sol:80](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/Minter.sol#L80) - [token/Minter.sol:93](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/Minter.sol#L93)  ## Recommended Mitigation Steps  Reducing revert error strings to under 32 bytes decreases deployment time gas and runtime gas when the revert condition is met. Alternatively, use custom errors, introduced in Solidity 0.8.4: https://blog.soliditylang.org/2021/04/21/custom-errors/  
# Handle  Ruhum   # Vulnerability details  # Vulnerability details  ## Impact Same thing as the ETH issue I reported earlier. I wasn't sure if those are supposed to be a single issue or not. The concept is the same. But, now you lose LPT tokens.  The `L1Migrator.migrateLPT()` function can be called by **anyone**. It pulls all the LPT from the `BridgeMinter` contract and starts the process of moving the funds to L2. First of all, this function is only executable once. The RetryableTicket created with the first call is the only chance of moving the funds to L2.  The attacker can call the function with [parameters](https://developer.offchainlabs.com/docs/l1_l2_messages#parameters) that make the creation of the RetryableTicket on L2 fail. Thus, the LPT sits in the L1Migrator contract with no way of moving it to L2 or anywhere else. Effectively, the funds are lost.  ## Proof of Concept The function is only executable once because it uses the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` to specify the amount of LPT to be sent to L2: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L342  After the first call to `migrateLPT()` that function will always return 0 since the `BridgeMinter` won't have any more LPT: https://github.com/livepeer/protocol/blob/streamflow/contracts/token/BridgeMinter.sol#L107  So after the attacker called `migrateLPT()` with insufficient funds to create a RetryableTicket on L2 we have the following state: - BridgeMinter has 0 LPT - L1Migrator has X amount of LPT that is not accessible. There are no functions to get the LPT out of there. - 1 failed RetryTicket  The same thing can also be triggered by a non-malicious caller by simply providing insufficient funds. The whole design of only being able to try once is the issue here.  ## Tools Used none  ## Recommended Mitigation Steps Instead of using the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` you should use the balance of the `L1Migrator` contract.  It might also make sense to **not** allow anybody to call the function. I don't see the benefit of that.  `EDIT` Actually, the funds aren't lost. The funds are sent to the Escrow contract which can be used to transfer the funds back to the BridgeMinter contract. Thus, you could reset the whole thing to its initial state and call `L1Migrator.migrateLPT()` again. But, a really persistent attacker has the ability to DoS the function by frontrunning any call to it which results in the RetryableTicket failing again. Thus, you'd have to transfer the funds from the Escrow contract to the BrigeMinter again and so on.  So the same scenario I've outlined earlier is still viable. It's just a bit more difficult now since it has a higher cost for the attacker now. Because of that I think it's an medium issue instead of high.  Also, the mitigation steps I've given aren't valid. You can't use the `L1Migrator` contract's balance since it will always be 0 (the funds are sent to the Escrow contract). Thus the best solution would be to just limit the access to the function.
# Handle  0x1f8b   # Vulnerability details  ## Impact Users and dapps are not notified when someting important is changed.  ## Proof of Concept  Functions that are only executable by privileged users (e.g. onlyOwner) and have an impact (e.g. financial, trust) on other users should emit events.  - contracts\L1\gateway\L1LPTGateway.sol : [setCounterpart,setMinter]. - contracts\L2\gateway\L2Migrator.sol : [setL1Migrator,setDelegatorPoolImpl,setClaimStakeEnabled]. - contracts\L2\gateway\L2LPTGateway.sol : [setCounterpart]. - contracts\L2\gateway\L2LPTDataCache.sol : [setL1LPTDataCache,setL2LPTGateway].  ## Tools Used Manual review.  ## Recommended Mitigation Steps Emit event during important changes.  
# Handle  defsec   # Vulnerability details  ## Impact  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  ## Proof of Concept  1. Navigate to the following smart contract line.  ``` https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L197  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L472 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to cache array length.  
# Handle  Dravee   # Vulnerability details  ## Impact   Reducing from public to private will save gas    ## Proof of Concept   ``` arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:111:    bytes32 public constant GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE"); arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:59:    bytes32 public constant GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE"); arbitrum-lpt-bridge\contracts\L2\token\LivepeerToken.sol:9:    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE"); arbitrum-lpt-bridge\contracts\L2\token\LivepeerToken.sol:10:    bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE"); arbitrum-lpt-bridge\contracts\ControlledGateway.sol:13:    bytes32 public constant GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE"); ```  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Theses constants can simply be read from the verified contract, i.e., it is unnecessary to expose them with a public function.  
# Handle  Dravee   # Vulnerability details  ## Impact   `private` functions are cheaper than `internal` functions.      ## Proof of Concept   Several `internal` functions are in contracts that are never inherited.      Their `internal` keywords are there:      ``` arbitrum-lpt-bridge\contracts\L1\gateway\L1LPTGateway.sol:170:        internal arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:505:    ) internal view { arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:518:        internal arbitrum-lpt-bridge\contracts\L2\gateway\L2LPTGateway.sol:123:        internal arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:307:    ) internal { arbitrum-lpt-bridge\contracts\L2\pool\DelegatorPool.sol:95:    function transferBond(address _delegator, uint256 _stake) internal { arbitrum-lpt-bridge\contracts\L2\pool\DelegatorPool.sol:106:    function pendingStake() internal view returns (uint256) { arbitrum-lpt-bridge\contracts\L2\pool\DelegatorPool.sol:110:    function pendingFees() internal view returns (uint256) { protocol\contracts\Manager.sol:48:    function _onlyController() internal view { protocol\contracts\Manager.sol:52:    function _onlyControllerOwner() internal view { protocol\contracts\Manager.sol:56:    function _whenSystemNotPaused() internal view { protocol\contracts\Manager.sol:60:    function _whenSystemPaused() internal view {   ```     Therefore, their visibility should be reduced to `private`.      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Define these functions as `private`.   
# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ``` arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:159:        bytes memory _sig, arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:209:        bytes memory _sig, arbitrum-lpt-bridge\contracts\L1\gateway\L1Migrator.sol:262:        bytes memory _sig, arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:130:    function finalizeMigrateDelegator(MigrateDelegatorParams memory _params) arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:195:        MigrateUnbondingLocksParams memory _params arbitrum-lpt-bridge\contracts\L2\gateway\L2Migrator.sol:215:    function finalizeMigrateSender(MigrateSenderParams memory _params) ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.   
# Handle  Tomio   # Vulnerability details  ## Impact save in memory can save more gas instead of double storage call  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L57  ## Tools Used Remix  ## Recommended Mitigation Steps add `l2SupplyFromL1` to memory example: ```         uint256 savel2SupplyFromL1 = l2SupplyFromL1;         if (_amount > savel2SupplyFromL1) {             savel2SupplyFromL1 = 0;         } else {             savel2SupplyFromL1 -= _amount;         } ```  
# Handle  jayjonah8   # Vulnerability details  ## Impact In files like L1LPTDataCache.sol,  floating pragmas are used.  Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept https://swcregistry.io/docs/SWC-103  ## Tools Used Manual code review   ## Recommended Mitigation Steps Lock the pragma version:  delete pragma solidity 0.8.0 in favor of pragma solidity 0.8.0  
# Handle  Tomio   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1LPTGateway.sol#L227  ## Tools Used Remix  ## Recommended Mitigation Steps change to `bytes memory emptyBytes;`  
# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           L2LPTDataCache.sol, l1CirculatingSupply         L2LPTGateway.sol, outboundTransfer         DelegatorPool.sol, initialize         IController.sol, getContract         Manager.sol, constructor         BridgeMinter.sol, constructor         BridgeMinter.sol, getController   
# Handle  robee   # Vulnerability details           Using newer compiler versions and the optimizer gives gas optimizations         and additional safety checks are available for free.                  The advantages of versions 0.8.* over <0.8.0 are:                  1. Safemath by default from 0.8.0 (can be more gas efficient than library based safemath.)         2. Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls.         3. Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.         4. Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.              IController.sol         IManager.sol         Manager.sol         BridgeMinter.sol   
# Handle  robee   # Vulnerability details  The project is compiled with different versions of solidity, which is not recommended due ti  undefined behaviors as a result of it.           
# Handle  robee   # Vulnerability details  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           L1LPTGateway.sol, getOutboundCalldata         L2LPTGateway.sol, outboundTransfer         L2LPTGateway.sol, getOutboundCalldata  
