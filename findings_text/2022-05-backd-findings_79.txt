  ## Using != 0 is cheaper than > 0 when used on a uint in a require() statement with the optimizer enabled  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L91-L92 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L137 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L84     ## Unnecessary variable definition in BkdLocker.sol, executeUnlocks() function  "length" is assigned to "i" and "i" is used for further operations, however "length" is never accessed again. Therefore, "length" can be directly used. Can be changed from this: ~~~         uint256 i = length;     //@audit gas no need to assign to i, directly use length         while (i > 0) {             i = i - 1;             if (stashedWithdraws[i].releaseTime <= block.timestamp) {                 totalAvailableToWithdraw += stashedWithdraws[i].amount;                  stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1];                  stashedWithdraws.pop();             }         } ~~~ To this: ~~~         while (length > 0) {             length--;             if (stashedWithdraws[length].releaseTime <= block.timestamp) {                 totalAvailableToWithdraw += stashedWithdraws[length].amount;                  stashedWithdraws[length] = stashedWithdraws[stashedWithdraws.length - 1];                  stashedWithdraws.pop();             }         } ~~~     ## for index can be made unchecked  All the for indexes are made unchecked except this one.  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L22     ## Redundant initialisation to default value  keeperGaugeExists initialised with default value.   ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L412      ## Public state variables and immutables can be made private  Most of the public state variables, immutables and constants do not need to be public. Hence, they can be private to save gas.  ### Lines of code There are many instances, for example; https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L25-L53 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L25-L32     ## Execution of strict inequalities are cheaper than non-strict inequalities  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/CvxMintAmount.sol#L24 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L190     ## Prefix increment/decrements are cheaper than postfix  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L59 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L98   
