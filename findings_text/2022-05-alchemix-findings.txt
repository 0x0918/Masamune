# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L111-L124 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L189-L191   # Vulnerability details  ## Impact An alchemist / user can mint more than their alloted amount of AlTokens by calling `lowerHasMinted()` before they reach their minting cap.  ## Proof of Concept Function `mint()` in `AlchemicTokenV2Base.sol`  ```solidity   function mint(address recipient, uint256 amount) external onlyWhitelisted {     if (paused[msg.sender]) {       revert IllegalState();     }      uint256 total = amount + totalMinted[msg.sender];     if (total > mintCeiling[msg.sender]) {       revert IllegalState();     }      totalMinted[msg.sender] = total;      _mint(recipient, amount);   } ``` Note the require conditional check that `total > mintCeiling[msg.sender]`.  In the same contract, there is the function `lowerHasMinted()` with the same permission level as mint and is thus callable by the same user as well. ```solidity   function lowerHasMinted(uint256 amount) external onlyWhitelisted {     totalMinted[msg.sender] = totalMinted[msg.sender] - amount;   } ```  It is clear that a user can accumulate an infinite (within supply) amount of AlTokens by calling `lowerHasMinted()` before any action that would make them exceed their minting cap.  ## Tools Used Manual review, VScode  ## Recommended Mitigation Steps Change the permissioning on `lowerHasMinted()` to be restricted to a higher permissioned role like `onlySentinel()` , or deprecate this function as I could not find any uses of it throughout the codebase or in tests.  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/fuse/FuseTokenAdapterV1.sol#L76 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/fuse/FuseTokenAdapterV1.sol#L98   # Vulnerability details  ## Impact the code is doing wrong check, so when things will work it will revert.   ## Proof of Concept In the function `wrap()` there is this lines: ```    if ((error = ICERC20(token).mint(amount)) != NO_ERROR) {             revert FuseError(error);         } ``` but `mint` returns the amount that minted, so when `error = amount` the check will fail even though it worked good.  Same in `unwrap`: ``` if ((error = ICERC20(token).redeem(amount)) != NO_ERROR) {             revert FuseError(error);         } ``` the redeem returns the amount.   ## Recommended Mitigation Steps  I recommend to change the lines like this:     in wrap:     ```      if ((error = ICERC20(token).mint(amount)) != amount) {             revert FuseError(error);         }     ```     and in unwrap:     ```     if ((error = ICERC20(token).redeem(amount)) != amount) {             revert FuseError(error);         }     ```   
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L61-L63   # Vulnerability details  ## Impact Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved. ## Proof of Concept https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L61-L63 https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L147-L147 https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L178-L179 ## Tools Used None ## Recommended Mitigation Steps ```     function approve(address token, address spender) internal {     +  IERC20(token).approve(spender, 0);         IERC20(token).approve(spender, type(uint256).max);     } ```  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterBuffer.sol#L230-L248   # Vulnerability details  Currently setAlchemist doesn't check whether there are any open positions left with the old Alchemist before switching to the new one.  As this require a number of checks the probability of operational mistake isn't low and it's prudent to introduce the main controls directly to the code to minimize it. In the case if the system go on with new Alchemist before realizing that there are some funds left in the old one, tedious and error prone manual recovery will be needed. There is also going to be a corresponding reputational damage.  Setting the severity to medium as while the function is admin only, the impact is up to massive user fund freeze, i.e. this is system breaking with external assumptions.  ## Proof of Concept  Alchemist implementation change can happen while there are open deposits remaining with the current contract. As there looks to be no process to transfer them in the code, such TransmuterBuffer's funds will be frozen with old alchemist:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-hardhat/TransmuterBuffer.sol#L230-L232  ```solidity     function setAlchemist(address _alchemist) external override onlyAdmin {         sources[alchemist] = false;         sources[_alchemist] = true; ```  ## Recommended Mitigation Steps  Consider requiring that all exposure to the old Alchemist is closed, for example both `getAvailableFlow` and `getTotalCredit` is zero.  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterBuffer.sol#L230-L231  ```solidity     function setAlchemist(address _alchemist) external override onlyAdmin { +    require(getTotalCredit() == 0, "Credit exists with old Alchemist"); +       for (uint256 j = 0; j < registeredUnderlyings.length; j++) { +           require(getTotalUnderlyingBuffered[registeredUnderlyings[j]] == 0, "Buffer exists with old Alchemist"); +       }         sources[alchemist] = false; ```  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1290-L1300 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1268 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1532 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L899 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1625   # Vulnerability details  ## Impact  It is possible for the contract to become stuck and unable to perform any actions if the `totalShares` of a yield token fall to zero while there is some `pendingCredit` still to be paid.  It will then be impossible to call deposit or withdraw functions, mints, burns, repay, liquidate, donate or harvest due to division by zero reverts in:  - `_distributeCredit()` - `_distributeUnlockedCredit()` - `_calculateUnrealizedDebt()` - `_convertSharesToYieldTokens()` - `donate()`  Furthermore, any `pendingCredit` amount of tokens are still in the contract will become permanently stuck.  ## Proof of Concept  This case may arise under the follow steps a) `deposit()` is called by a user then time passes to earn some yield b) `harvest()` is called by the keeper which calls `_distributeCredit()` and increases `pendingCredit` c) `withdraw()` is called by the user to withdraw all funds  Since there is `pendingCredit` the following will have a non-zero balance for `unlockedCredit` however `yieldTokenParams.totalShares` is zero and thus we get a division by zero which reverts the entire transaction.  ```solidity     function _distributeUnlockedCredit(address yieldToken) internal {         YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];           uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);         if (unlockedCredit == 0) {             return;         }           yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;         yieldTokenParams.distributedCredit += unlockedCredit;     } ```  Each of the other listed functions will reach the same issue by attempting to divide some numerator by the `totalShares` which is zero.  ## Recommended Mitigation Steps  Consider preventing `totalShares` from over becoming zero once it is set. That is enforce a user to leave at least 1 unit if they are the last user to withdraw.  Another option is to transfer the first 1000 shares to a "burn" account (e.g. 0x000...01), when the first user deposits.  Alternatively, when the last user withdraws, transfer all pending credit to this user and set the required variables to zero to replicate the state before any users have deposited.  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L30-L32   # Vulnerability details  Some tokens do not allow for approval of positive amount when allowance is positive already (to handle approval race condition, most known example is USDT).  This can cause the function to stuck whenever a combination of such a token and leftover approval be met. The latter can be possible if, for example, yearn vault is becoming full on a particular wrap() call and accepts only a part of amount, not utilizing the approval fully.  Then each next safeApprove will revert and wrap becomes permanently unavailable. Setting the severity to medium as depositing (wrapping) is core functionality for the contract and its availability is affected.  ## Proof of Concept  wrap use one step approve:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L30-L32  ```solidity     function wrap(uint256 amount, address recipient) external override returns (uint256) {         TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);         TokenUtils.safeApprove(underlyingToken, token, amount); ```  Some ERC20 forbid the approval of positive amount when the allowance is positive:  https://github.com/d-xo/weird-erc20#approval-race-protections  For example, USDT is supported by Yearn and can be the underlying asset:  https://yearn.finance/#/vault/0x7Da96a3891Add058AdA2E826306D812C638D87a7  ## Recommended Mitigation Steps  As the most general approach consider approving zero before doing so for the amount:  ```solidity     function wrap(uint256 amount, address recipient) external override returns (uint256) {         TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount); +      TokenUtils.safeApprove(underlyingToken, token, 0);         TokenUtils.safeApprove(underlyingToken, token, amount); ```  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L896-L905 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L566-L573   # Vulnerability details  Both contracts treat meta assets as if they have fixed decimals of 18. Minting logic breaks when it's not the case. However, meta tokens decimals aren't controlled.  If actual meta assets have any other decimals, minting slippage control logic of both contracts will break up as `total` is calculated as a plain sum of token amounts.  In the higher token decimals case `minTotalAmount` will be magnitudes higher than actual amount Curve can provide and minting becomes unavailable.  In the lower token decimals case `minTotalAmount` will lack value and slippage control will be rendered void, which opens up a possibility of a fund loss from the excess slippage.  Setting severity to medium as the contract can be used with various meta tokens (`_metaPoolAssetCache`  can be filled with any assets) and, whenever decimals differ from 18 `add_liquidity` uses, its logic be broken: the inability to mint violates the contract purpose, the lack of slippage control can lead to fund losses.  I.e. this is system breaking impact conditional on a low probability assumption of different meta token decimals.  ## Proof of Concept  Meta tokens decimals are de facto hard coded into the contract as plain amounts are used (L. 905):  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L896-L905  ```solidity     function _mintMetaPoolTokens(         uint256[NUM_META_COINS] calldata amounts     ) internal returns (uint256 minted) {         IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;          uint256 total = 0;         for (uint256 i = 0; i < NUM_META_COINS; i++) {             if (amounts[i] == 0) continue;              total += amounts[i]; ```  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L915-L919  ```solidity         uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();         uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;          // Add the liquidity to the pool.         minted = metaPool.add_liquidity(amounts, minimumMintAmount); ```  The same plain sum approach is used in EthAssetManager._mintMetaPoolTokens:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L566-L573  ```solidity         uint256 total = 0;         for (uint256 i = 0; i < NUM_META_COINS; i++) {             // Skip over approving WETH since we are directly swapping ETH.             if (i == uint256(MetaPoolAsset.ETH)) continue;              if (amounts[i] == 0) continue;              total += amounts[i]; ```  When this decimals assumption doesn't hold, the slippage logic will not hold too: either the mint be blocked or slippage control disabled.  Notice, that ThreePoolAssetManager.calculateRebalance do query alUSD decimals (which is inconsistent with the above as it’s either fix and control on inception or do not fix and accommodate the logic):  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L338-L338  ```solidity decimals     = SafeERC20.expectDecimals(address(alUSD)); ```  ## Recommended Mitigation Steps  If meta assets are always supposed to have fixed decimals of 18, consider controlling it at the construction time.  I.e. the decimals can be controlled in constructors:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L214-L219  ```solidity         for (uint256 i = 0; i < NUM_META_COINS; i++) {             _metaPoolAssetCache[i] = params.metaPool.coins(i);             if (_metaPoolAssetCache[i] == IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {                 _metaPoolAssetCache[i] = weth; +           } else { +            // check the decimals     }         } ```  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L254-L256  ```solidity         for (uint256 i = 0; i < NUM_META_COINS; i++) {             _metaPoolAssetCache[i] = params.metaPool.coins(i); +           // check the decimals                     } ```  In this case further decimals reading as it's done in calculateRebalance() is redundant.  Otherwise (which is less recommended as fixed decimals assumption is viable and simplify the logic) the meta token decimals can be added to calculations similarly to stables:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L779-L779  ```solidity normalizedTotal += amounts[i] * 10**missingDecimals; ```  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L20 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/CrossChainCanonicalBase.sol#L12 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterV2.sol#L26 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/CrossChainCanonicalAlchemicTokenV2.sol#L7   # Vulnerability details  ## Impact  For upgradeable contracts, there must be storage gap to "allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments" (quote OpenZeppelin). Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts, potentially causing loss of user fund or cause the contract to malfunction completely.  Refer to the bottom part of this article: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable   ## Proof of Concept  Several contracts are intended to be upgradeable contracts in the code base, including  - AlchemicTokenV2Base - CrossChainCanonicalBase - CrossChainCanonicalAlchemicTokenV2 - TransmuterV2  However, none of these contracts contain storage gap. The storage gap is essential for upgradeable contract because "It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments". Refer to the bottom part of this article:  https://docs.openzeppelin.com/contracts/3.x/upgradeable  As an example, both the `AlchemicTokenV2Base` and the `CrossChainCanonicalBase` are intended to act as the base contracts in the project. If the contract inheriting the base contract contains additional variable, then the base contract cannot be upgraded to include any additional variable, because it would overwrite the variable declared in its child contract. This greatly limits contract upgradeability.    ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.  ```solidity uint256[50] private __gap; ```  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L111-L124 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L189-L191   # Vulnerability details  ## Impact An alchemist / user can mint more than their alloted amount of AlTokens by calling `lowerHasMinted()` before they reach their minting cap.  ## Proof of Concept Function `mint()` in `AlchemicTokenV2Base.sol`  ```solidity   function mint(address recipient, uint256 amount) external onlyWhitelisted {     if (paused[msg.sender]) {       revert IllegalState();     }      uint256 total = amount + totalMinted[msg.sender];     if (total > mintCeiling[msg.sender]) {       revert IllegalState();     }      totalMinted[msg.sender] = total;      _mint(recipient, amount);   } ``` Note the require conditional check that `total > mintCeiling[msg.sender]`.  In the same contract, there is the function `lowerHasMinted()` with the same permission level as mint and is thus callable by the same user as well. ```solidity   function lowerHasMinted(uint256 amount) external onlyWhitelisted {     totalMinted[msg.sender] = totalMinted[msg.sender] - amount;   } ```  It is clear that a user can accumulate an infinite (within supply) amount of AlTokens by calling `lowerHasMinted()` before any action that would make them exceed their minting cap.  ## Tools Used Manual review, VScode  ## Recommended Mitigation Steps Change the permissioning on `lowerHasMinted()` to be restricted to a higher permissioned role like `onlySentinel()` , or deprecate this function as I could not find any uses of it throughout the codebase or in tests.  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/fuse/FuseTokenAdapterV1.sol#L76 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/fuse/FuseTokenAdapterV1.sol#L98   # Vulnerability details  ## Impact the code is doing wrong check, so when things will work it will revert.   ## Proof of Concept In the function `wrap()` there is this lines: ```    if ((error = ICERC20(token).mint(amount)) != NO_ERROR) {             revert FuseError(error);         } ``` but `mint` returns the amount that minted, so when `error = amount` the check will fail even though it worked good.  Same in `unwrap`: ``` if ((error = ICERC20(token).redeem(amount)) != NO_ERROR) {             revert FuseError(error);         } ``` the redeem returns the amount.   ## Recommended Mitigation Steps  I recommend to change the lines like this:     in wrap:     ```      if ((error = ICERC20(token).mint(amount)) != amount) {             revert FuseError(error);         }     ```     and in unwrap:     ```     if ((error = ICERC20(token).redeem(amount)) != amount) {             revert FuseError(error);         }     ```   
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L61-L63   # Vulnerability details  ## Impact Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved. ## Proof of Concept https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L61-L63 https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L147-L147 https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L178-L179 ## Tools Used None ## Recommended Mitigation Steps ```     function approve(address token, address spender) internal {     +  IERC20(token).approve(spender, 0);         IERC20(token).approve(spender, type(uint256).max);     } ```  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterBuffer.sol#L230-L248   # Vulnerability details  Currently setAlchemist doesn't check whether there are any open positions left with the old Alchemist before switching to the new one.  As this require a number of checks the probability of operational mistake isn't low and it's prudent to introduce the main controls directly to the code to minimize it. In the case if the system go on with new Alchemist before realizing that there are some funds left in the old one, tedious and error prone manual recovery will be needed. There is also going to be a corresponding reputational damage.  Setting the severity to medium as while the function is admin only, the impact is up to massive user fund freeze, i.e. this is system breaking with external assumptions.  ## Proof of Concept  Alchemist implementation change can happen while there are open deposits remaining with the current contract. As there looks to be no process to transfer them in the code, such TransmuterBuffer's funds will be frozen with old alchemist:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-hardhat/TransmuterBuffer.sol#L230-L232  ```solidity     function setAlchemist(address _alchemist) external override onlyAdmin {         sources[alchemist] = false;         sources[_alchemist] = true; ```  ## Recommended Mitigation Steps  Consider requiring that all exposure to the old Alchemist is closed, for example both `getAvailableFlow` and `getTotalCredit` is zero.  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterBuffer.sol#L230-L231  ```solidity     function setAlchemist(address _alchemist) external override onlyAdmin { +    require(getTotalCredit() == 0, "Credit exists with old Alchemist"); +       for (uint256 j = 0; j < registeredUnderlyings.length; j++) { +           require(getTotalUnderlyingBuffered[registeredUnderlyings[j]] == 0, "Buffer exists with old Alchemist"); +       }         sources[alchemist] = false; ```  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1290-L1300 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1268 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1532 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L899 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1625   # Vulnerability details  ## Impact  It is possible for the contract to become stuck and unable to perform any actions if the `totalShares` of a yield token fall to zero while there is some `pendingCredit` still to be paid.  It will then be impossible to call deposit or withdraw functions, mints, burns, repay, liquidate, donate or harvest due to division by zero reverts in:  - `_distributeCredit()` - `_distributeUnlockedCredit()` - `_calculateUnrealizedDebt()` - `_convertSharesToYieldTokens()` - `donate()`  Furthermore, any `pendingCredit` amount of tokens are still in the contract will become permanently stuck.  ## Proof of Concept  This case may arise under the follow steps a) `deposit()` is called by a user then time passes to earn some yield b) `harvest()` is called by the keeper which calls `_distributeCredit()` and increases `pendingCredit` c) `withdraw()` is called by the user to withdraw all funds  Since there is `pendingCredit` the following will have a non-zero balance for `unlockedCredit` however `yieldTokenParams.totalShares` is zero and thus we get a division by zero which reverts the entire transaction.  ```solidity     function _distributeUnlockedCredit(address yieldToken) internal {         YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];           uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);         if (unlockedCredit == 0) {             return;         }           yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;         yieldTokenParams.distributedCredit += unlockedCredit;     } ```  Each of the other listed functions will reach the same issue by attempting to divide some numerator by the `totalShares` which is zero.  ## Recommended Mitigation Steps  Consider preventing `totalShares` from over becoming zero once it is set. That is enforce a user to leave at least 1 unit if they are the last user to withdraw.  Another option is to transfer the first 1000 shares to a "burn" account (e.g. 0x000...01), when the first user deposits.  Alternatively, when the last user withdraws, transfer all pending credit to this user and set the required variables to zero to replicate the state before any users have deposited.  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L30-L32   # Vulnerability details  Some tokens do not allow for approval of positive amount when allowance is positive already (to handle approval race condition, most known example is USDT).  This can cause the function to stuck whenever a combination of such a token and leftover approval be met. The latter can be possible if, for example, yearn vault is becoming full on a particular wrap() call and accepts only a part of amount, not utilizing the approval fully.  Then each next safeApprove will revert and wrap becomes permanently unavailable. Setting the severity to medium as depositing (wrapping) is core functionality for the contract and its availability is affected.  ## Proof of Concept  wrap use one step approve:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L30-L32  ```solidity     function wrap(uint256 amount, address recipient) external override returns (uint256) {         TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);         TokenUtils.safeApprove(underlyingToken, token, amount); ```  Some ERC20 forbid the approval of positive amount when the allowance is positive:  https://github.com/d-xo/weird-erc20#approval-race-protections  For example, USDT is supported by Yearn and can be the underlying asset:  https://yearn.finance/#/vault/0x7Da96a3891Add058AdA2E826306D812C638D87a7  ## Recommended Mitigation Steps  As the most general approach consider approving zero before doing so for the amount:  ```solidity     function wrap(uint256 amount, address recipient) external override returns (uint256) {         TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount); +      TokenUtils.safeApprove(underlyingToken, token, 0);         TokenUtils.safeApprove(underlyingToken, token, amount); ```  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L896-L905 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L566-L573   # Vulnerability details  Both contracts treat meta assets as if they have fixed decimals of 18. Minting logic breaks when it's not the case. However, meta tokens decimals aren't controlled.  If actual meta assets have any other decimals, minting slippage control logic of both contracts will break up as `total` is calculated as a plain sum of token amounts.  In the higher token decimals case `minTotalAmount` will be magnitudes higher than actual amount Curve can provide and minting becomes unavailable.  In the lower token decimals case `minTotalAmount` will lack value and slippage control will be rendered void, which opens up a possibility of a fund loss from the excess slippage.  Setting severity to medium as the contract can be used with various meta tokens (`_metaPoolAssetCache`  can be filled with any assets) and, whenever decimals differ from 18 `add_liquidity` uses, its logic be broken: the inability to mint violates the contract purpose, the lack of slippage control can lead to fund losses.  I.e. this is system breaking impact conditional on a low probability assumption of different meta token decimals.  ## Proof of Concept  Meta tokens decimals are de facto hard coded into the contract as plain amounts are used (L. 905):  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L896-L905  ```solidity     function _mintMetaPoolTokens(         uint256[NUM_META_COINS] calldata amounts     ) internal returns (uint256 minted) {         IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;          uint256 total = 0;         for (uint256 i = 0; i < NUM_META_COINS; i++) {             if (amounts[i] == 0) continue;              total += amounts[i]; ```  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L915-L919  ```solidity         uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();         uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;          // Add the liquidity to the pool.         minted = metaPool.add_liquidity(amounts, minimumMintAmount); ```  The same plain sum approach is used in EthAssetManager._mintMetaPoolTokens:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L566-L573  ```solidity         uint256 total = 0;         for (uint256 i = 0; i < NUM_META_COINS; i++) {             // Skip over approving WETH since we are directly swapping ETH.             if (i == uint256(MetaPoolAsset.ETH)) continue;              if (amounts[i] == 0) continue;              total += amounts[i]; ```  When this decimals assumption doesn't hold, the slippage logic will not hold too: either the mint be blocked or slippage control disabled.  Notice, that ThreePoolAssetManager.calculateRebalance do query alUSD decimals (which is inconsistent with the above as it’s either fix and control on inception or do not fix and accommodate the logic):  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L338-L338  ```solidity decimals     = SafeERC20.expectDecimals(address(alUSD)); ```  ## Recommended Mitigation Steps  If meta assets are always supposed to have fixed decimals of 18, consider controlling it at the construction time.  I.e. the decimals can be controlled in constructors:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L214-L219  ```solidity         for (uint256 i = 0; i < NUM_META_COINS; i++) {             _metaPoolAssetCache[i] = params.metaPool.coins(i);             if (_metaPoolAssetCache[i] == IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {                 _metaPoolAssetCache[i] = weth; +           } else { +            // check the decimals     }         } ```  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L254-L256  ```solidity         for (uint256 i = 0; i < NUM_META_COINS; i++) {             _metaPoolAssetCache[i] = params.metaPool.coins(i); +           // check the decimals                     } ```  In this case further decimals reading as it's done in calculateRebalance() is redundant.  Otherwise (which is less recommended as fixed decimals assumption is viable and simplify the logic) the meta token decimals can be added to calculations similarly to stables:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L779-L779  ```solidity normalizedTotal += amounts[i] * 10**missingDecimals; ```  
# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L20 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/CrossChainCanonicalBase.sol#L12 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterV2.sol#L26 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/CrossChainCanonicalAlchemicTokenV2.sol#L7   # Vulnerability details  ## Impact  For upgradeable contracts, there must be storage gap to "allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments" (quote OpenZeppelin). Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts, potentially causing loss of user fund or cause the contract to malfunction completely.  Refer to the bottom part of this article: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable   ## Proof of Concept  Several contracts are intended to be upgradeable contracts in the code base, including  - AlchemicTokenV2Base - CrossChainCanonicalBase - CrossChainCanonicalAlchemicTokenV2 - TransmuterV2  However, none of these contracts contain storage gap. The storage gap is essential for upgradeable contract because "It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments". Refer to the bottom part of this article:  https://docs.openzeppelin.com/contracts/3.x/upgradeable  As an example, both the `AlchemicTokenV2Base` and the `CrossChainCanonicalBase` are intended to act as the base contracts in the project. If the contract inheriting the base contract contains additional variable, then the base contract cannot be upgraded to include any additional variable, because it would overwrite the variable declared in its child contract. This greatly limits contract upgradeability.    ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.  ```solidity uint256[50] private __gap; ```  
