# Gas Report  **Table of Contents:**  - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [Summary](#summary)   - [File: AMM.sol](#file-ammsol)     - [function initialize()](#function-initialize)       - [Use `calldata` instead of `memory` for `string _name`](#use-calldata-instead-of-memory-for-string-_name)     - [function openPosition()](#function-openposition)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory)     - [function liquidatePosition()](#function-liquidateposition)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-1)     - [function removeLiquidity()](#function-removeliquidity)       - [Do not cache `positions[maker]` in memory](#do-not-cache-positionsmaker-in-memory)       - [Do not cache `makers[maker]` in memory](#do-not-cache-makersmaker-in-memory)     - [function getNotionalPositionAndUnrealizedPnl()](#function-getnotionalpositionandunrealizedpnl)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-2)       - [Do not cache `makers[trader]` in memory](#do-not-cache-makerstrader-in-memory)     - [function getPendingFundingPayment()](#function-getpendingfundingpayment)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-3)       - [Do not cache `makers[trader]` in memory](#do-not-cache-makerstrader-in-memory-1)     - [function getTakerNotionalPositionAndUnrealizedPnl()](#function-gettakernotionalpositionandunrealizedpnl)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-4)     - [function _emitPositionChanged()](#function-_emitpositionchanged)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-5)     - [function _openReversePosition()](#function-_openreverseposition)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-6)       - [Unchecked block L597](#unchecked-block-l597)     - [function _calcTwap()](#function-_calctwap)       - [Do not cache `reserveSnapshots[snapshotIndex]` in memory](#do-not-cache-reservesnapshotssnapshotindex-in-memory)       - [Cache `reserveSnapshots.length` in memory](#cache-reservesnapshotslength-in-memory)       - [Unchecked block L684](#unchecked-block-l684)       - [Use the cache for calculation](#use-the-cache-for-calculation)   - [File: ClearingHouse.sol](#file-clearinghousesol)     - [function _disperseLiquidationFee()](#function-_disperseliquidationfee)       - [Unchecked block L214](#unchecked-block-l214)   - [File: InsuranceFund.sol](#file-insurancefundsol)     - [function pricePerShare()](#function-pricepershare)       - [Unchecked block L97](#unchecked-block-l97)   - [File: Oracle.sol](#file-oraclesol)     - [function getUnderlyingTwapPrice()](#function-getunderlyingtwapprice)       - [Unchecked block L81](#unchecked-block-l81)   - [File: Interfaces.sol](#file-interfacessol)     - [struct Collateral](#struct-collateral)       - [Tight packing structs to save slots](#tight-packing-structs-to-save-slots)   - [File: MarginAccount.sol](#file-marginaccountsol)     - [function _getLiquidationInfo()](#function-_getliquidationinfo)       - [Do not cache `supportedCollateral[idx]` in memory](#do-not-cache-supportedcollateralidx-in-memory)     - [function _transferOutVusd()](#function-_transferoutvusd)       - [Unchecked block L588](#unchecked-block-l588)   - [File: VUSD.sol](#file-vusdsol)     - [function processWithdrawals()](#function-processwithdrawals)       - [Unchecked block L57-L65](#unchecked-block-l57-l65)       - [Cache `start` in memory](#cache-start-in-memory)   - [General recommendations](#general-recommendations)     - [Variables](#variables)       - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values)       - [Pre-increments cost less gas compared to post-increments](#pre-increments-cost-less-gas-compared-to-post-increments)     - [Comparisons](#comparisons)       - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof)     - [For-Loops](#for-loops)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)       - [`++i` costs less gas compared to `i++`](#i-costs-less-gas-compared-to-i)       - [Increments can be unchecked](#increments-can-be-unchecked)     - [Arithmetics](#arithmetics)       - [Shift Right instead of Dividing by 2](#shift-right-instead-of-dividing-by-2)     - [Errors](#errors)       - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword  - **Storage-reading optimizations**  > The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). In the paragraphs below, please see the `@audit-issue` tags in the pieces of code's comments for more information about SLOADs that could be saved by caching the mentioned **storage** variables in **memory** variables.  - **Unchecking arithmetics operations that can't underflow/overflow**  > Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Summary  - One pattern that was often seen is caching structs in memory when it's not needed. A copy in memory of a storage struct will trigger as many SLOADs as there are slots. If the struct's fields are only read once, or if the number of storage reading would be inferior to the number of slots: don't cache the struct in memory.  ## File: AMM.sol  ### function initialize()  ``` 093:     function initialize( 094:         address _registry, 095:         address _underlyingAsset, 096:         string memory _name,//@audit readonly: calldata 097:         address _vamm, 098:         address _governance 099:     ) external initializer { 100:         _setGovernace(_governance); 101:  102:         vamm = IVAMM(_vamm); 103:         underlyingAsset = _underlyingAsset; 104:         name = _name; 105:         fundingBufferPeriod = 15 minutes; 106:  107:         syncDeps(_registry); 108:     } ```  #### Use `calldata` instead of `memory` for `string _name`  An external function passing a readonly variable should mark it as `calldata` and not `memory`  ### function openPosition()  ``` 113:     function openPosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit) 114:         override 115:         external 116:         onlyClearingHouse 117:         returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased) 118:     { 119:         require(ammState == AMMState.Active, "AMM.openPosition.not_active"); 120:         Position memory position = positions[trader]; //@audit 3 SLOADs vs 1 enough 121:         bool isNewPosition = position.size == 0 ? true : false; 122:         Side side = baseAssetQuantity > 0 ? Side.LONG : Side.SHORT; 123:         if (isNewPosition || (position.size > 0 ? Side.LONG : Side.SHORT) == side) { 124:             // realizedPnl = 0; 125:             quoteAsset = _increasePosition(trader, baseAssetQuantity, quoteAssetLimit); 126:             isPositionIncreased = true; 127:         } else { 128:             (realizedPnl, quoteAsset, isPositionIncreased) = _openReversePosition(trader, baseAssetQuantity, quoteAssetLimit); 129:         } 130:         _emitPositionChanged(trader, realizedPnl); 131:     } ```  #### Do not cache `positions[trader]` in memory  As a copy in memory of a struct makes as many SLOADs as there are slots, here a copy costs 3 SLOADs:  ``` 41:     struct Position { 42:         int256 size; 43:         uint256 openNotional; 44:         int256 lastPremiumFraction; 45:     } ```  However, only the `size` field is read twice. Therefore, only this field should get cached: `int256 _size = positions[trader].size;`  ### function liquidatePosition()  ``` 133:     function liquidatePosition(address trader) 134:         override 135:         external 136:         onlyClearingHouse 137:         returns (int realizedPnl, uint quoteAsset) 138:     { 139:         // don't need an ammState check because there should be no active positions 140:         Position memory position = positions[trader]; //@audit 3 SLOADs vs 1 enough 141:         bool isLongPosition = position.size > 0 ? true : false; 142:         // sending market orders can fk the trader. @todo put some safe guards around price of liquidations 143:         if (isLongPosition) { 144:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, 0); 145:         } else { 146:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, type(uint).max); 147:         } 148:         _emitPositionChanged(trader, realizedPnl); 149:     } ```  #### Do not cache `positions[trader]` in memory  Similar to [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory).  However, only the `size` field is read 3 times. Therefore, only this field should get cached: `int256 _size = positions[trader].size;`  ### function removeLiquidity()  ``` 133:     function liquidatePosition(address trader) 134:         override 135:         external 136:         onlyClearingHouse 137:         returns (int realizedPnl, uint quoteAsset) 138:     { 139:         // don't need an ammState check because there should be no active positions 140:         Position memory position = positions[trader]; //@audit 3 SLOADs vs 1 enough 141:         bool isLongPosition = position.size > 0 ? true : false; 142:         // sending market orders can fk the trader. @todo put some safe guards around price of liquidations 143:         if (isLongPosition) { 144:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, 0); 145:         } else { 146:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, type(uint).max); 147:         } 148:         _emitPositionChanged(trader, realizedPnl); 149:     } ```  #### Do not cache `positions[maker]` in memory  Similar to [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory). However, here, even the fields shouldn't get cached, as they are read only once:  ``` 220:         Position memory _taker = positions[maker];//@audit 3 SLOADs vs 2 enough ... 233:             _taker.size, 234:             _taker.openNotional ```  Therefore, use `220:         Position storage _taker = positions[maker];`  #### Do not cache `makers[maker]` in memory  Similarly, a copy in memory for `Maker` costs 7 SLOADs:  ``` 48:     struct Maker { 49:         uint vUSD; 50:         uint vAsset; 51:         uint dToken; 52:         int pos; // position 53:         int posAccumulator; // value of global.posAccumulator until which pos has been updated 54:         int lastPremiumFraction; 55:         int lastPremiumPerDtoken; 56:     } ```  Here, caching the first 5 fields in memory is enough.  ### function getNotionalPositionAndUnrealizedPnl()  ``` 395:     function getNotionalPositionAndUnrealizedPnl(address trader) 396:         override 397:         external 398:         view 399:         returns(uint256 notionalPosition, int256 unrealizedPnl, int256 size, uint256 openNotional) 400:     { 401:         Position memory _taker = positions[trader];//@audit 3 SLOADs vs 2 enough 402:         Maker memory _maker = makers[trader];//@audit 7 SLOADs vs 3 enough 403:  404:         (notionalPosition, size, unrealizedPnl, openNotional) = vamm.get_notional( 405:             _maker.dToken, 406:             _maker.vUSD, 407:             _maker.vAsset, 408:             _taker.size, 409:             _taker.openNotional 410:         ); 411:     } ```  #### Do not cache `positions[trader]` in memory  Here, we need `Position storage _taker = positions[trader];`  #### Do not cache `makers[trader]` in memory  Here, we need `Maker storage _maker = makers[trader];`  ### function getPendingFundingPayment()  ``` 425:         Position memory taker = positions[trader];//@audit 3 SLOADs vs 2 enough ... 434:         Maker memory maker = makers[trader];//@audit 7 SLOADs vs 5 enough ```  #### Do not cache `positions[trader]` in memory  Here, we need `Position storage _taker = positions[trader];`  #### Do not cache `makers[trader]` in memory  Here, we need `Maker storage _maker = makers[trader];`  ### function getTakerNotionalPositionAndUnrealizedPnl()  ``` 458:     function getTakerNotionalPositionAndUnrealizedPnl(address trader) override public view returns(uint takerNotionalPosition, int256 unrealizedPnl) { 459:         Position memory position = positions[trader];//@audit 3 SLOADs vs 2 enough 460:         if (position.size > 0) { 461:             takerNotionalPosition = vamm.get_dy(1, 0, position.size.toUint256()); 462:             unrealizedPnl = takerNotionalPosition.toInt256() - position.openNotional.toInt256(); 463:         } else if (position.size < 0) { 464:             takerNotionalPosition = vamm.get_dx(0, 1, (-position.size).toUint256()); 465:             unrealizedPnl = position.openNotional.toInt256() - takerNotionalPosition.toInt256(); 466:         } 467:     } ```  #### Do not cache `positions[trader]` in memory  Here, we need to cache these fields: `size` and `openNotional`  ### function _emitPositionChanged()  ``` 527:     function _emitPositionChanged(address trader, int256 realizedPnl) internal { 528:         Position memory position = positions[trader];//@audit 3 SLOADs vs 2 enough 529:         emit PositionChanged(trader, position.size, position.openNotional, realizedPnl); 530:     } ```  #### Do not cache `positions[trader]` in memory  Here, we need `Position storage _taker = positions[trader];`  ### function _openReversePosition()  ``` 584:     function _openReversePosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit) 585:         internal 586:         returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased) 587:     { 588:         Position memory position = positions[trader];//@audit 3 SLOADs vs 1 enough 589:         if (abs(position.size) >= abs(baseAssetQuantity)) { 590:             (realizedPnl, quoteAsset) = _reducePosition(trader, baseAssetQuantity, quoteAssetLimit); 591:         } else { 592:             uint closedRatio = (quoteAssetLimit * abs(position.size).toUint256()) / abs(baseAssetQuantity).toUint256(); 593:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, closedRatio); 594:  595:             // this is required because the user might pass a very less value (slippage-prone) while shorting 596:             if (quoteAssetLimit >= quoteAsset) { 597:                 quoteAssetLimit -= quoteAsset; //@audit uncheck (see L596) 598:             } 599:             quoteAsset += _increasePosition(trader, baseAssetQuantity + position.size, quoteAssetLimit); 600:             isPositionIncreased = true; 601:         } 602:     } ```  #### Do not cache `positions[trader]` in memory  Here, we need to cache the `size` field  #### Unchecked block L597  This line can't underflow due to the condition L596. Therefore, it should be wrapped in an `unchecked` block  ### function _calcTwap()  ``` 656:     function _calcTwap(uint256 _intervalInSeconds) 657:         internal 658:         view 659:         returns (uint256) 660:     { 661:         uint256 snapshotIndex = reserveSnapshots.length - 1; //@audit reserveSnapshots.length  SLOAD 1 662:         uint256 currentPrice = reserveSnapshots[snapshotIndex].lastPrice; 663:         if (_intervalInSeconds == 0) { 664:             return currentPrice; 665:         } 666:  667:         uint256 baseTimestamp = _blockTimestamp() - _intervalInSeconds; 668:         ReserveSnapshot memory currentSnapshot = reserveSnapshots[snapshotIndex];//@audit 3 SLOADs vs 1 enough 669:         // return the latest snapshot price directly 670:         // if only one snapshot or the timestamp of latest snapshot is earlier than asking for 671:         if (reserveSnapshots.length == 1 || currentSnapshot.timestamp <= baseTimestamp) {//@audit reserveSnapshots.length  SLOAD 2 ... 675:         uint256 previousTimestamp = currentSnapshot.timestamp; 676:         uint256 period = _blockTimestamp() - previousTimestamp; 677:         uint256 weightedPrice = currentPrice * period; 678:         while (true) { ... 680:             if (snapshotIndex == 0) { 681:                 return weightedPrice / period; 682:             } ... 684:             snapshotIndex = snapshotIndex - 1; //@audit uncheck (see L680-L682) 685:             currentSnapshot = reserveSnapshots[snapshotIndex]; 686:             currentPrice = reserveSnapshots[snapshotIndex].lastPrice; //@audit use currentSnapshot.lastPrice ... 689:             if (currentSnapshot.timestamp <= baseTimestamp) { ... 698:             uint256 timeFraction = previousTimestamp - currentSnapshot.timestamp; ... 701:             previousTimestamp = currentSnapshot.timestamp; ```  #### Do not cache `reserveSnapshots[snapshotIndex]` in memory  Here, we need to cache the `timestamp` field. Copying the struct in memory costs 3 SLOADs.  #### Cache `reserveSnapshots.length` in memory  This would save 1 SLOAD  #### Unchecked block L684  This line can't underflow due to the condition L680-L682. Therefore, it should be wrapped in an `unchecked` block  #### Use the cache for calculation  As we already have `currentSnapshot = reserveSnapshots[snapshotIndex];`: use it here: `currentPrice = currentSnapshot.lastPrice;`  ## File: ClearingHouse.sol  ### function _disperseLiquidationFee()  ``` 210:     function _disperseLiquidationFee(uint liquidationFee) internal { 211:         if (liquidationFee > 0) { 212:             uint toInsurance = liquidationFee / 2; 213:             marginAccount.transferOutVusd(address(insuranceFund), toInsurance); 214:             marginAccount.transferOutVusd(_msgSender(), liquidationFee - toInsurance); //@audit uncheck (see L212) 215:         } 216:     } ```  #### Unchecked block L214  This line can't underflow due to the condition L212. Therefore, it should be wrapped in an `unchecked` block  ## File: InsuranceFund.sol  ### function pricePerShare()  ``` File: InsuranceFund.sol 094:     function pricePerShare() external view returns (uint) { 095:         uint _totalSupply = totalSupply(); 096:         uint _balance = balance(); 097:         _balance -= Math.min(_balance, pendingObligation); //@audit uncheck 098:         if (_totalSupply == 0 || _balance == 0)  099:             return PRECISION; 100:         } 101:         return _balance * PRECISION /  _totalSupply; 102:     } ```  #### Unchecked block L97  This line can't underflow for obvious mathematical reasons (`_balance` substracting at most itself). Therefore, it should be wrapped in an `unchecked` block  ## File: Oracle.sol  ### function getUnderlyingTwapPrice()  #### Unchecked block L81  This line can't underflow due to L76-L79. Therefore, it should be wrapped in an `unchecked` block  ## File: Interfaces.sol  ### struct Collateral  #### Tight packing structs to save slots  While this file is out of scope, it deeply impacts MarginAccount.sol. I suggest going from:  ``` 94:     struct Collateral { 95:         IERC20 token; //@audit 20 bytes 96:         uint weight; //@audit 32 bytes 97:         uint8 decimals; //@audit 1 byte 98:     } ```  to  ``` 94:     struct Collateral { 95:         IERC20 token; //@audit 20 bytes 96:         uint8 decimals; //@audit 1 byte 97:         uint weight; //@audit 32 bytes 98:     } ```  To save 1 slot per array element in MarginAccount.sol's storage  ## File: MarginAccount.sol  ### function _getLiquidationInfo()  ``` 460:     function _getLiquidationInfo(address trader, uint idx) internal view returns (LiquidationBuffer memory buffer) { 461:         require(idx > VUSD_IDX && idx < supportedCollateral.length, "collateral not seizable"); 462:         (buffer.status, buffer.repayAble, buffer.incentivePerDollar) = isLiquidatable(trader, false); 463:         if (buffer.status == IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) { 464:             Collateral memory coll = supportedCollateral[idx];//@audit 3 SLOADs vs 2 enough 465:             buffer.priceCollateral = oracle.getUnderlyingPrice(address(coll.token)).toUint256(); 466:             buffer.decimals = coll.decimals; 467:         } 468:     } ```  #### Do not cache `supportedCollateral[idx]` in memory  Here, we need `Collateral storage coll = supportedCollateral[idx];`. Copying the struct in memory costs 3 SLOADs.  ### function _transferOutVusd()  #### Unchecked block L588  This line can't underflow due to L583. Therefore, it should be wrapped in an `unchecked` block  ## File: VUSD.sol  ### function processWithdrawals()  ``` 53:     function processWithdrawals() external { 54:         uint reserve = reserveToken.balanceOf(address(this)); 55:         require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance'); //@audit start SLOAD 1 56:         uint i = start;//@audit start SLOAD 2 57:         while (i < withdrawals.length && (i - start) <= maxWithdrawalProcesses) { //@audit uncheck whole //@audit start SLOAD 3 58:             Withdrawal memory withdrawal = withdrawals[i]; //@audit-ok 59:             if (reserve < withdrawal.amount) { 60:                 break; 61:             } 62:             reserveToken.safeTransfer(withdrawal.usr, withdrawal.amount); 63:             reserve -= withdrawal.amount;  //@audit uncheck (see L59-L61) 64:             i += 1; 65:         } 66:         start = i; 67:     } ```  #### Unchecked block L57-L65  The whole while-loop can't underflow. Therefore, it should be wrapped in an `unchecked` block  #### Cache `start` in memory  Cache `start` in memory as `initialStart` and use it L55 + L57 (compare `i` to it in the while-loop)  ## General recommendations  ### Variables  #### No need to explicitly initialize variables with default values  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Instances include:    ``` ClearingHouse.sol:122:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:130:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:170:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:194:        for (uint i = 0; i < amms.length; i++) { // liquidate all positions ClearingHouse.sol:251:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:263:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:277:        for (uint i = 0; i < amms.length; i++) { InsuranceFund.sol:52:        uint shares = 0; MarginAccount.sol:31:    uint constant VUSD_IDX = 0; MarginAccount.sol:331:        for (uint i = 0; i < idxs.length; i++) { MarginAccount.sol:521:        for (uint i = 0; i < assets.length; i++) { MarginAccount.sol:552:        for (uint i = 0; i < _collaterals.length; i++) { MarginAccountHelper.sol:13:    uint constant VUSD_IDX = 0; ```  I suggest removing explicit initializations for default values.  #### Pre-increments cost less gas compared to post-increments  ### Comparisons  #### `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  `> 0` in require statements are used in the following location(s):  ``` AMM.sol:487:        require(baseAssetQuantity > 0, "VAMM._long: baseAssetQuantity is <= 0"); AMM.sol:511:        require(baseAssetQuantity < 0, "VAMM._short: baseAssetQuantity is >= 0"); ClearingHouse.sol:51:        require(_maintenanceMargin > 0, "_maintenanceMargin < 0"); MarginAccount.sol:150:        require(amount > 0, "Add non-zero margin"); Oracle.sol:153:        require(_round > 0, "Not enough history"); ```  I suggest you change `> 0` with `!= 0` in require statements. Also, enable the Optimizer.  ### For-Loops  #### An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead:  ``` ClearingHouse.sol:122:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:130:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:170:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:194:        for (uint i = 0; i < amms.length; i++) { // liquidate all positions ClearingHouse.sol:251:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:263:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:277:        for (uint i = 0; i < amms.length; i++) { MarginAccount.sol:331:        for (uint i = 0; i < idxs.length; i++) { MarginAccount.sol:373:        for (uint i = 1 /* skip vusd */; i < assets.length; i++) { MarginAccount.sol:521:        for (uint i = 0; i < assets.length; i++) { MarginAccount.sol:552:        for (uint i = 0; i < _collaterals.length; i++) { ```  #### `++i` costs less gas compared to `i++`  `++i` costs less gas compared to `i++` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration)    `i++` increments `i` and returns the initial value of `i`. Which means:      ``` uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ``` uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:    ``` ClearingHouse.sol:122:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:130:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:170:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:194:        for (uint i = 0; i < amms.length; i++) { // liquidate all positions ClearingHouse.sol:251:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:263:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:277:        for (uint i = 0; i < amms.length; i++) { MarginAccount.sol:331:        for (uint i = 0; i < idxs.length; i++) { MarginAccount.sol:373:        for (uint i = 1 /* skip vusd */; i < assets.length; i++) { MarginAccount.sol:521:        for (uint i = 0; i < assets.length; i++) { MarginAccount.sol:552:        for (uint i = 0; i < _collaterals.length; i++) { ```  I suggest using `++i` instead of `i++` to increment the value of an uint variable.  #### Increments can be unchecked  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Instances include:    ``` ClearingHouse.sol:122:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:130:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:170:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:194:        for (uint i = 0; i < amms.length; i++) { // liquidate all positions ClearingHouse.sol:251:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:263:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:277:        for (uint i = 0; i < amms.length; i++) { MarginAccount.sol:331:        for (uint i = 0; i < idxs.length; i++) { MarginAccount.sol:373:        for (uint i = 1 /* skip vusd */; i < assets.length; i++) { MarginAccount.sol:521:        for (uint i = 0; i < assets.length; i++) { MarginAccount.sol:552:        for (uint i = 0; i < _collaterals.length; i++) { ```  The code would go from:      ``` for (uint256 i; i < numIterations; i++) {    // ...   }   ```  to:    ``` for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ```  The risk of overflow is inexistant for a `uint256` here.  ### Arithmetics    #### Shift Right instead of Dividing by 2  A division by 2 can be calculated by shifting one to the right.      While the `DIV` opcode uses 5 gas, the `SHR` opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.    I suggest replacing `/ 2` with `>> 1` here:    ```   ClearingHouse.sol:212:            uint toInsurance = liquidationFee / 2; ```    ### Errors  #### Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes are here:  ``` AMM.sol:487:        require(baseAssetQuantity > 0, "VAMM._long: baseAssetQuantity is <= 0"); AMM.sol:511:        require(baseAssetQuantity < 0, "VAMM._short: baseAssetQuantity is >= 0"); ClearingHouse.sol:84:            require(isAboveMinAllowableMargin(trader), "CH: Below Minimum Allowable Margin"); ClearingHouse.sol:101:        require(isAboveMinAllowableMargin(maker), "CH: Below Minimum Allowable Margin"); MarginAccount.sol:174:        require(margin[VUSD_IDX][trader] >= 0, "Cannot remove margin when vusd balance is negative"); MarginAccount.sol:354:        require(notionalPosition == 0, "Liquidate positions before settling bad debt"); MarginAccount.sol:453:        require(repay <= maxRepay, "Need to repay more to seize that much");  ```  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next.  #### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  ``` legos/Governable.sol:11:        require(msg.sender == governance, "ONLY_GOVERNANCE"); AMM.sol:84:        require(msg.sender == clearingHouse, "Only clearingHouse"); AMM.sol:89:        require(msg.sender == address(vamm), "Only VAMM"); AMM.sol:119:        require(ammState == AMMState.Active, "AMM.openPosition.not_active"); AMM.sol:186:        require(ammState != AMMState.Inactive, "AMM.addLiquidity.amm_inactive"); AMM.sol:296:        require(abs(positionSize) >= abs(baseAssetQuantity), "AMM.ONLY_REDUCE_POS"); AMM.sol:348:        require(_blockTimestamp() >= nextFundingTime, "settle funding too early"); AMM.sol:487:        require(baseAssetQuantity > 0, "VAMM._long: baseAssetQuantity is <= 0"); AMM.sol:511:        require(baseAssetQuantity < 0, "VAMM._short: baseAssetQuantity is >= 0"); AMM.sol:723:        require(ammState != _state, "AMM.setAmmState.sameState"); ClearingHouse.sol:51:        require(_maintenanceMargin > 0, "_maintenanceMargin < 0"); ClearingHouse.sol:75:        require(baseAssetQuantity != 0, "CH: baseAssetQuantity == 0"); ClearingHouse.sol:84:            require(isAboveMinAllowableMargin(trader), "CH: Below Minimum Allowable Margin"); ClearingHouse.sol:101:        require(isAboveMinAllowableMargin(maker), "CH: Below Minimum Allowable Margin"); ClearingHouse.sol:120:        require(address(trader) != address(0), 'CH: 0x0 trader Address'); ClearingHouse.sol:154:        require(!isMaker(trader), 'CH: Remove Liquidity First'); ClearingHouse.sol:164:        require( ClearingHouse.sol:189:        require(_calcMarginFraction(trader, false /* check funding payments again */) < maintenanceMargin, "Above Maintenance Margin"); InsuranceFund.sol:30:        require(msg.sender == address(marginAccount), "IF.only_margin_account"); InsuranceFund.sol:42:        require(pendingObligation == 0, "IF.deposit.pending_obligations"); InsuranceFund.sol:64:        require(pendingObligation == 0, "IF.withdraw.pending_obligations"); MarginAccount.sol:115:        require(_msgSender() == address(clearingHouse), "Only clearingHouse"); MarginAccount.sol:150:        require(amount > 0, "Add non-zero margin"); MarginAccount.sol:174:        require(margin[VUSD_IDX][trader] >= 0, "Cannot remove margin when vusd balance is negative"); MarginAccount.sol:175:        require(margin[idx][trader] >= amount.toInt256(), "Insufficient balance"); MarginAccount.sol:180:        require(clearingHouse.isAboveMinAllowableMargin(trader), "MA.removeMargin.Below_MM"); MarginAccount.sol:354:        require(notionalPosition == 0, "Liquidate positions before settling bad debt"); MarginAccount.sol:357:        require(getSpotCollateralValue(trader) < 0, "Above bad debt threshold"); MarginAccount.sol:362:        require(vusdBal < 0, "Nothing to repay"); MarginAccount.sol:438:        require(seized >= minSeizeAmount, "Not seizing enough"); MarginAccount.sol:453:        require(repay <= maxRepay, "Need to repay more to seize that much"); MarginAccount.sol:461:        require(idx > VUSD_IDX && idx < supportedCollateral.length, "collateral not seizable"); MarginAccount.sol:549:        require(_weight <= PRECISION, "weight > 1e6"); MarginAccount.sol:553:            require(address(_collaterals[i].token) != _coin, "collateral exists"); MarginAccount.sol:601:        require(_liquidationIncentive <= PRECISION / 10, "MA.syncDeps.LI_GT_10_percent"); MarginAccount.sol:603:        require(registry.marginAccount() == address(this), "Incorrect setup"); MarginAccount.sol:617:        require(_weight <= PRECISION, "weight > 1e6"); MarginAccount.sol:618:        require(idx < supportedCollateral.length, "Collateral not supported"); MinimalForwarder.sol:15:        require(success, string(abi.encodePacked("META_EXEC_FAILED: ", returnData))); Oracle.sol:48:        require(intervalInSeconds != 0, "interval can't be 0"); Oracle.sol:153:        require(_round > 0, "Not enough history"); Oracle.sol:157:        require(_addr != address(0), "empty address"); VUSD.sol:33:        require(_reserveToken != address(0), "vUSD: null _reserveToken"); VUSD.sol:55:        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance'); ```  I suggest replacing revert strings with custom errors. 
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L348   # Vulnerability details  # Impact  settleFunding calls will revert until all AMMs are ready to be updated.  # Proof of Concept  1. AMM 1 has a nextFundingTime of now. AMM 2 has a nextFundingTime in 30 minutes. AMM 1 won't be able to be updated until after AMM 2's nextFundingTime elapses.  # Mitigation You shouldn't revert at the place mentioned in the links to affected code. Just return so that the other AMMs can still get updated.  
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L377   # Vulnerability details  # Impact Assets sent from MarginAccount to InsuranceFund will be locked forever  # Proof of Concept The insurance fund doesn't have a way to transfer non-vusd out of the contract.  Assets transferred to the InsuranceFund will be locked forever.  # Mitigation Have a way for governance to sweep tokens to swap them.  
#1  ## Impact Light DoS of USDC withdrawal system  ## Proof of Concept Currently, withdrawals are queued in an array and processed sequentially in a for loop. However, a malicious user can post unlimited number of tiny (1 wei) withdrawals. Or, not-malicious user can post multiple withdrawals. User will receive funds from multiple transfers but it's possible to make only 1 transfer.  USDC transfers are actually expensive due to additional, non-standard SLOADs.  There is more...  Unused array's storage is not freed. I propose usage of mappings, so one can free the memory and get a refund.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67  ## Tools Used Manual review  ## Recommended Mitigation Steps There are 3 ways it can be rewritten:  1st, preserve FIFO order + remove unused storage - multiple calls to the same recipient  2nd, don't preserve FIFO order + remove unused storage - most efficient although unfair property  3nd (BEST), preserve FIFO order + remove unused storage + single call to the same recipient (Aggregate)  ### 1st approach ```javascript function withdraw__gas_efficient_1st(uint amount) external {     burn(amount);     pendingWithdrawals[end_index] += Withdrawal(msg.sender, aount);     end_index += 1; } function processWithdrawals__gas_efficient_1st() external {     uint reserve = reserveToken.balanceOf(address(this));     require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');     uint count = (end_index - start_index);     uint end = start_index + min(count, maxWithdrawalProcesses);     uint i;     for (i = startIndex; i < end; ++i) {         Withdrawal memory withdrawal = pendingWithdrawals[i];         if (reserve < withdrawal.amount) {             break;         }         reserveToken.safeTransfer(withdrawal.user, withdrawal.amount);         reserve -= withdrawal.amount;         delete pendingWithdrawals[i]; // save gas         delete pendingWithdrawalsIdx[withdrawal.user]; // save gas     }     start_index = i; } ```  ### 2nd approach ```javascript function withdraw__gas_efficient_2nd(uint amount) external {     burn(amount);     uint user_index = pendingWithdrawalsIndicies[msg.sender];     if (user_index == 0) {         user_index = end_index++;         pendingWithdrawalsIndicies[msg.sender] = user_index;     }     pendingWithdrawals[user_index] += Withdrawal(msg.sender, aount); } function processWithdrawals__gas_efficient_2nd() external {     uint reserve = reserveToken.balanceOf(address(this));     require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');     uint count = (end_index - start_index);     uint end = start_index + min(count, maxWithdrawalProcesses);     uint i;     for (i = startIndex; i < end; ++i) {         Withdrawal memory withdrawal = pendingWithdrawals[i];         if (reserve < withdrawal.amount) {             break;         }         reserveToken.safeTransfer(withdrawal.user, withdrawal.amount);         reserve -= withdrawal.amount;         delete pendingWithdrawals[i]; // save gas         delete pendingWithdrawalsIdx[withdrawal.user]; // save gas     }     start_index = i; } ```  ### 3rd approach ```javascript function withdraw__gas_efficient_3rd(uint amount) external {     burn(amount);     pendingWithdrawals[end_index] += Withdrawal(msg.sender, aount);     end_index += 1; } function processWithdrawals__gas_efficient_3rd() external {     uint reserve = reserveToken.balanceOf(address(this));     require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');     uint count = (end_index - start_index);     uint end = start_index + min(count, maxWithdrawalProcesses);     uint i;     // compute     mapping(address => uint) memory temp_idx;     Withdrawal[] memory temp_withdrawals     for (i = startIndex; i < end; ++i) {         Withdrawal memory withdrawal = pendingWithdrawals[i];         if (reserve < withdrawal.amount) {             break;         }         uint user_index = temp_idx[withdrawal.user];         if (user_index == 0) {             user_index = ++idx;             temp_withdrawals.push(withdrawal);         } else {             temp_withdrawals[user_index - 1].amount += withdrawal.amount;         }         reserve -= withdrawal.amount;         delete pendingWithdrawals[i]; // save gas         delete pendingWithdrawalsIdx[withdrawal.user]; // save gas     }     startIndex = i;      for (uint j = 0; j < temp_withdrawals.length; ++j) {         Withdrawal memory withdrawal = temp_withdrawals[j];         reserveToken.safeTransfer(withdrawal.user, withdrawal.amount); // save gas     } } ```  # 2  ## Impact Excessive SLOAD in a for loop.  ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L57  ## Tools Used Manual review  ## Recommended Mitigation Steps Cache array's length in memory
##GAS OPTIMAZATION  #1 Better increment for saving more gas   Using ++i for all the loops in the variable. it is known and common case that implementation by using ++i can cost less gas per iteration than i++  ##POC  it can bee seen from here : https://github.com/ethereum/solidity/issues/10695  ##Occurance  ``` main/contracts/ClearingHouse.sol#L122; main/contracts/ClearingHouse.sol#L170;  main/contracts/ClearingHouse.sol#L194; main/contracts/ClearingHouse.sol#L251; main/contracts/ClearingHouse.sol#L263; main/contracts/ClearingHouse.sol#L278; main/contracts/MarginAccount.sol#L331; main/contracts/MarginAccount.sol#L373; main/contracts/MarginAccount.sol#L521; main/contracts/MarginAccount.sol#L552; ```  ##Mitigation  `i++` change to `++i`  #2 Using `storage` instead `memory` for saving more gas  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L588 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/VUSD.sol#L58  instead of caching with `memory` it can be used by caching with `storage`, just read it directly for saving more gas  change to  `Position storage position = positions[trader];` `Withdrawal storage withdrawal = withdrawals[i];`  #3 using `&&` is more expensive gas   https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L461 using mutiple `require()` is cheaper than use `&&` if this was used many times. Because it can save gas execution cost   ##Mitigation  ``` require(idx > VUSD_IDX && idx < supportedCollateral.length, "collateral not seizable"); ```  change to   ``` require idx > VUSD_IDX; require supportedCollateral.length, "collateral not seizable"; ```  #4 Using `constructor()` instead `initialize()` or vice versa https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L35-L56 better to execute all the codes in the `initialize()` using `constructor()`. The idea is of using initialize is to run all the code inside it once in a lifetime. The current implementation of some of the contract is using both `constructor()` & `initialize()`  #5 Directly call `msg.sender` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L69 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L65 by using `msg.sender` instead of `_msgSender()` can save gas  6# The vars can set to immutable https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L22-L24 `vusd`, `insuranceFund`, & `marginAccount` set once at `initialize()`. Use immutable  7# There is no int which using `Safecast` lib https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L13 In the `ClearingHouse.sol` there is no int which is using the lib. Remove the line 13  8# Better way to call `SafeCast`lib function https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L12-L13 By removing lines which declaring that this contract is using `SafeCast` lib  and directly call it on each function, it can save execution gas cost ``` int256 marginCharge = realizedPnl - SafeCast.toInt256(fee); ``` The `SafeCast.function` is only called 3 times at `ClearingHouse.sol` so i recommend to change it thes way https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L332  9# Calling `block.timestamp` directly can save gas https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L86 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L201 instead of using `_blockTimestamp()` func to get `block.timestamp` value, using `block.timestamp`  can save gas  10# Caching `position.size` in `isLongPosition` bool is not gas efficient https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L614 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L141 By putting `position.size` inside the `if()` condition, and removing `L141` and `L614`, can save a lot of gas  11# Using != instead > https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L211 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L253 since uint cant be < 0, by using != operator to check condition can save gas  12# Custom error can save gas Using string to throw an error to user is more gas consuming. From solidity 0.8.4 we can use custom error to save gas. Custom errors are defined using the `error` statement https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L51 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L75 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L84 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L101 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L120 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L154 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L164 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L189  
https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L540  the comment: ```             makerNotional = newNotional * makerPos / totalPos //<-------- This line             if (side remains same)             reducedOpenNotional = takerOpenNotional * makerPos / takerPos             pnl = makerNotional - reducedOpenNotional  ```  and the actual code was   ```  uint totalPosition = abs(makerPosition + takerPosition).toUint256();         if (abs(takerPosition) > abs(makerPosition)) {  // taker position side remains same             uint reducedOpenNotional = takerOpenNotional * abs(makerPosition).toUint256() /              abs(takerPosition).toUint256();              uint makerNotional = newNotional * abs(makerPosition).toUint256() / totalPosition; //<------- this line             pnlToBeRealized = _getPnlToBeRealized(takerPosition, makerNotional, reducedOpenNotional); ```  the line ```  uint makerNotional = newNotional * abs(makerPosition).toUint256() / totalPosition; ``` was intended to executed outside of `if()` body(Not sure which one is the correct, the comment or the code)
already checked twice: https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/curve-v2/Swap.vy#L669 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/curve-v2/Swap.vy#L671   the check can be removed, as it's an external view function: https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/curve-v2/Swap.vy#L929
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53   # Vulnerability details  processWithdrawals can process limited amount in each call. an attacker can push to withdrawals enormous amount of withdrawals with amount = 0. in order to stop the dos attack and process the withdrawal, the governance needs to spend as much gas as the attacker. if the governance doesn't have enough money to pay for the gas, the withdrawals can't be processed.  ## Proof of Concept Alice wants to attack vusd, she spend 1millions dollars for gas to push as many withdrawals of amount = 0 as she can. if the governance wants to process the deposits after alices empty deposits, they also need to spend at least 1 million dollars for gas in order to process alice's withdrawals first. but the governance doesn't have 1 million dollar so the funds will be locked.  ## Recommended Mitigation Steps set  a minimum amount of withdrawal. e.g. 1 dollar  ```     function withdraw(uint amount) external {         require(amount >= 10 ** 6);         burn(amount);         withdrawals.push(Withdrawal(msg.sender, amount));     } ```  
GAS :  1. Title : Its cheaper using delete  Impact :  In the removeLiquidity function if the diff value is 0, its cheaper to use delete instead setting the pos, vAsset, vUSD, dToken to zero, this can save +- 3 gas  POC :  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L243-L246  Mitigation :  ```  delete __maker.pos;  delete __maker.vAsset;  delete __maker.vUSD;  delete __maker.dToken; ```  2. Title : its cheaper to save length value to a local variable  Impact : when using a loop, its cheaper to save the length value of an array to a variable, so the loop didn't have to read the storage length in each loop, but comparing with the length that was already save in the local variable. For an array that has a length 10 it can save +- 1800 gas.  POC :  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  3.  Title : its cheaper to use block.timestamp directly   Impact :  Its cheaper to use block.timestamp directly instead calling it through a _blocktimestamp() function.  POC :  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L65 
## Hubble QA Report  Unless otherwise noted, manual auditing and testing were done using Visual Studio Code and Remix. The audit was done from February 17-23, 2022 by ye0lde through code4rena.  Overall, I found the code to be clear to follow and read. I'd recommend the team improve the supporting documentation to give a better overall understanding of the protocol.  - [Findings](#findings)   - [L-1 - No validation of parameter `price` in `setStablePrice` (Oracle.sol)](#l-1---no-validation-of-parameter-price-in-setstableprice-oraclesol)   - [L-2 - Unsafe type cast in `getTwapPrice` (AMM.sol)](#l-2---unsafe-type-cast-in-gettwapprice-ammsol)   - [NC-1 - Typo in `getUnderlyingTwapPrice` (Oracle.sol)](#nc-1---typo-in-getunderlyingtwapprice-oraclesol)  ## Findings    ### L-1 - No validation of parameter `price` in `setStablePrice` (Oracle.sol)  #### Impact The `setStablePrice` function does not do any validation of the `price` parameter before setting `stablePrice[underlying] = price`. While this is a governance function, once `stablePrice[underlying]` is set to any non-zero value this overrides any aggregator calls made to access the current price by function `getUnderlyingPrice` and `getUnderlyingTwapPrice`.  `underlying` is checked but not the `price` itself.  #### Proof of Concept `setStablePrice` is here: https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L169-L172  ``` function setStablePrice(address underlying, int256 price) external onlyGovernance {     requireNonEmptyAddress(underlying);     stablePrice[underlying] = price; } ```  #### Recommended Mitigation Steps Consider adding a check for `price > 0`  ---  ### L-2 - Unsafe type cast in `getTwapPrice` (AMM.sol)  #### Impact `getTwapPrice` performs an unsafe type cast to uint128 without checking if the value actually fits into 128 bits. This typecast doesn't seem to directly lead to an exploit but safe typecasts should still be implemented for additional security.  #### Proof of Concept The type cast is here: https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L392  #### Recommended Mitigation Steps I suggest the following change:  ``` function getTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {     return (_calcTwap(_intervalInSeconds).toInt256());  } ``` ---  ### NC-1 - Typo in `getUnderlyingTwapPrice` (Oracle.sol)  #### Impact Code clarity  #### Proof of Concept The typo is here: https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L53  #### Recommended Mitigation Steps Change `form` to `from`.  --- 
### G-01: use uint256 for best gas saving  ClearingHouse.sol L#17,18,19,20 MarginAccount.sol L#47  ### G-02: uint256 instead of bool ClearingHouse.sol L#79,250  ### G-04: Prefix increments are cheaper than postfix increments. Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change ClearingHouse.sol L#122,130,170,194,251,263,278 MarginAccount.sol L#331,373,521  ### G-05: immutable instead of constant MarginAccount.sol L#34,15,  ### G-06: use calldata instead of memory  ### G-07: use memory instead of storage  ### G-03: bytes32 instead of string
# C4-001 : Adding unchecked directive can save gas  ## Impact -  Gas Optimization  Using the unchecked keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen. E.g. 'unchecked' can be applied in the following lines of code since there are require statements before to ensure the arithmetic operations would not cause an integer underflow or overflow. For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  ## Proof of Concept  1. Navigate to the following contract function and lines.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L676 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider applying unchecked arithmetic where overflow/underflow is not possible.  # C4-002 : `> 0 can be replaced with != 0 for gas optimization`  ## Impact -  Gas Optimization  `!= 0` is a cheaper operation compared to `> 0`, when dealing with uint.  ## Proof of Concept  1. Navigate to the following contract function and lines.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L141  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L123  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L199  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L271  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L78 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Use "!=0" instead of ">0" for the gas optimization.  # C4-003 : `++i is more gas efficient than i++ in loops forwarding`  ## Impact -  Gas Optimization  ++i is more gas efficient than i++ in loops forwarding.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L331  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L373  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L521  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L552  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L52  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L65  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L78  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L95  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L120  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L137  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L367 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  It is  recommend to use unchecked{++i} and change i declaration to uint256.   # C4-004 : `Cache array length in for loops can save gas`  ## Impact -  Gas Optimization  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L331  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L373  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L521  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L552 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to cache array length.  # C4-005 : Less than 256 uints are not gas efficient  ## Impact -  Gas Optimization  Lower than uint256 size storage instance variables are actually less gas efficient. E.g. using uint16 does not give any efficiency, actually, it is the opposite as EVM operates on default of 256-bit values so uint16 is more expensive in this case as it needs a conversion. It only gives improvements in cases where you can pack variables together, e.g. structs.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L302 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to review all uint types. Change them with uint256 If the integer is not necessary to present with uint16.`   # C4-006 : State variables could be declared constant  ## Impact -  Gas Optimization  State variables that never change can be declared constant. This can greatly reduce gas costs.  ## Proof of Concept  1. Navigate to the following contract variables.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L20  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L23  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L19 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add the constant keyword for state variables whose value never change.   # C4-007 : Immutable Variables  ## Impact -  Gas Optimization  'immutable' greatly reduces gas costs. There are variables that do not change so they can be marked as immutable to greatly improve the gas costs.  ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/ClearingHouse.sol#L23  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/ClearingHouse.sol#L24   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Mark variables as immutable.   # C4-008 : There is no need to assign default values to variables  ## Impact -  Gas Optimization  When a variable is declared solidity assigns the default value. In case the contract assigns the value again, it costs extra gas.  Example: uint x = 0 costs more gas than uint x without having any different functionality.  ## Proof of Concept  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L331  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L373  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L521  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L552  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L52  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L65  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L78  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L95  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L120  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L137  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L367 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  uint x = 0 costs more gas than uint x without having any different functionality.   # C4-009 : Cache external call results can save gas  ## Impact  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.   ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L25 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Cache external call for the gas optimization.    # C4-010 : Redundant Import  ## Impact - Gas Optimization  Safemath is an unnecessary import in all contracts since it is used solely for development. It can therefore be removed.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L9 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to delete redundant import.  # C4-011 : Gas Optimization on the Public Functions  ## Impact  This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract. Calling each function, we can see that the public function uses 496 gas, while the external function uses only 261.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.  Slither Detector:  external-function:  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L69  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L104  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L108  ## Tools Used  Slither  ## Recommended Mitigation Steps  1. Get Smart Contracts from the Repository. 2. Create a python virtual environment with a stable python version. 3. Install Slither Analyzer on the python VEM. 4. Run Slither against all contracts. 5. Define public functions as an external for the gas optimization.   # C4-012 : Avoid unnecessary SafeCast.toInt256() can save gas  ## Impact  Gas Improvement  ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/ClearingHouse.sol#L332  ## Tools Used  None  ## Recommended Mitigation Steps   Avoid unnecessary SafeCast.toInt256() can save gas   # C4-013 : Use of _msgSender()  ## Impact  The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.  ## Proof of Concept  _msgSender() is utilized three times where msg.sender could have been used in the following function.  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L115  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L140  ## Tools Used  None  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.
## [L1] Add check against parameters `_amount` and `_shares`:  Assessed risk: 1/10  Urgency: N/A  Codebase frequency: 2  ### [L1 - Impact]:  The `amount` that the user deposits is not checked against being `!=0`. It’s a good practice to check arbitrary inputs against being null. Although the transaction would revert anyhow(due to arithmetic error of division `/0`) you should consider adding a check against it. The same goes with parameter `_shares` in the `withdraw()` function.  ### [L1 - References]:   InsuranceFund.sol lines [62](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L62) and [39](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L39)   ### [L1 - Mitigation]:  Adding `require` statements would prevent such operations.  ```bash function deposit(uint _amount) external {      require(_amount !=0, "IF.deposit.amount_zero");  ... }  function withdraw(uint _shares) external {     require(_shares !=0, "IF.withdraw.shares_not_zero");  ... } ```
# C4-001 :  PREVENT DIV BY 0  ## Impact -  LOW  On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn’t done.  Oracle price is not checked. That will cause to revert on the several functions.   ## Proof of Concept  1. Navigate to the following contract.  ```  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L34  ```   ## Tools Used  None  ## Recommended Mitigation Steps  Recommend making sure division by 0 won’t occur by checking the variables beforehand and handling this edge case.  # C4-002 : Single-step change of governance address is extremely risky  ## Impact -  LOW   Single-step change of critical governance address and lack of zero address check is extremely risky. If a zero address or incorrect address (private key not available) is used accidentally, or maliciously changed by a compromised governance account then the entire governance of the protocol is locked forever or lost to an attacker. No governance changes can be made by authorized governance account and protocol will have to be redeployed. The reputation of the protocol will take a huge hit. There may be significant fund lock/loss as well.  Interestingly, this 2-step process is applied to the changing of Strategist address but not Governance address. Governance has more authority in the protocol because it can change the Strategist among other things. So this 2-step should definitely be applied to Governance as well.  Given the magnitude of the impact, i.e. permanent lock of all governance actions, potential lock/loss of funds, and the known/documented failures of wallet opsec, this risk is classified as medium severity.  ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L20  ## Tool  Code Review  ## Recommended Mitigation Steps  Change of the most critical protocol address i.e. governance should be timelocked and be a 2-step process: approve+claim in two different transactions, instead of a single-step change.   # C4-003 : Use of Block.timestamp  ## Impact -  Non-Critical  Block timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the Entropy Illusion for further details), locking funds for periods of time, and various state-changing conditional statements that are time-dependent. Miners have the ability to adjust timestamps slightly, which can prove to be dangerous if block timestamps are used incorrectly in smart contracts.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/HubbleBase.sol#L49 ```   ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  Block timestamps should not be used for entropy or generating random numbers—i.e., they should not be the deciding factor (either directly or through some derivation) for winning a game or changing an important state.  Time-sensitive logic is sometimes required; e.g., for unlocking contracts (time-locking), completing an ICO after a few weeks, or enforcing expiry dates. It is sometimes recommended to use block.number and an average block time to estimate times; with a 10 second block time, 1 week equates to approximately, 60480 blocks. Thus, specifying a block number at which to change a contract state can be more secure, as miners are unable to easily manipulate the block number.   # C4-004 : Front-runnable Initializers  ## Impact -  LOW  All contract **initializers** were missing access controls, allowing any user to initialize the contract. By front-running the contract deployers to initialize the contract, the incorrect parameters may be supplied, leaving the contract needing to be redeployed.   ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L93  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L20  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L38  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L121 ```  2. initialize functions does not have access control. They are vulnerable to front-running.   ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  While the code that can be run in contract constructors is limited, setting the owner in the contract's constructor to the `msg.sender` and adding the `onlyOwner` modifier to all **initializers** would be a sufficient level of access control.  # C4-005 : Incompatibility With Rebasing/Deflationary/Inflationary tokens  ## Impact -  LOW  The protocol do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L155  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L29 ```   ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  - Ensure that to check previous balance/after balance  equals to amount for any rebasing/inflation/deflation - Add support in contracts for such tokens before accepting user-supplied tokens - Consider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they don't want to lose them.  # C4-006 : Missing zero-address check in constructors and the setter functions  ## Impact -  LOW  Missing checks for zero-addresses may lead to infunctional protocol, if the variable addresses are updated incorrectly.  ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L19  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L39  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L16  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L35  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L121 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider adding zero-address checks in the discussed constructors: require(newAddr != address(0));.   # C4-007 : Missing events for governor only functions that change critical parameters  ## Impact - Non critical  The governor only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in the contracts.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L616  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L19  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L162  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L74  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L722  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L737 ```  See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)  ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all admin/privileged functions that change critical parameters.  # C4-008 : Deprecated safeApprove() function  ## Impact -  LOW  Detailed description of the impact of this finding.  Using this deprecated function can lead to unintended reverts and potentially the locking of funds. A deeper discussion on the deprecation of this function is in OZ issue #2219 (https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219). The OpenZeppelin ERC20 safeApprove() function has been deprecated, as seen in the comments of the OpenZeppelin code.  ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L24 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  As suggested by the OpenZeppelin comment, replace safeApprove() with safeIncreaseAllowance() or safeDecreaseAllowance() instead.   # C4-009 : The Contract Should Approve(0) first  ## Impact -  LOW  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).approve(address(operator), 0); IERC20(token).approve(address(operator), amount); ```  ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L24 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount.   # C4-0010 : The Contract Should Approve(0) first  ## Impact -  LOW  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).approve(address(operator), 0); IERC20(token).approve(address(operator), amount); ```   ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L24 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount.  # C4-0011 : Missing Pause Modifier On the InsuranceFunds contract  ## Impact -  Low  In case a hack occurs or an exploit is discovered, the team should be able to pause functionality until the necessary changes are made to the system.  The deposits should be paused with Pause modifier.   ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L39 ```  There is no pause mechanism has been defined.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Pause functionality on the contract would have helped secure the funds quickly.   # C4-0012 : Missing Re-entrancy Guard  ## Impact -  Non-critical  The re-entrancy guard is missing on the Eth anchor interaction. The external router interaction can cause to the re-entrancy vulnerability.   ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L39 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Follow the check effect interaction pattern or put re-entrancy guard.
# Unused import https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AdminProxy.sol#L6-7  # Unresolved todos ``` $ egrep -Rn "todo" contracts contracts/AMM.sol:142:        // sending market orders can fk the trader. @todo put some safe guards around price of liquidations contracts/AMM.sol:555:            // @todo handle case when totalPosition = 0 contracts/ClearingHouse.sol:172:            // @todo put checks on slippage contracts/MarginAccount.sol:277:            @todo consider providing some incentive from insurance fund to execute a liquidation in this scenario. ```  # Lack checks to make sure minAllowableMargin >= maintenanceMargin User might get liquidated immediated if maintenanceMargin > minAllowableMargin https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L344 ```     function setParams(         int _maintenanceMargin,         int _minAllowableMargin,         uint _tradeFee,         uint _liquidationPenality     ) external onlyGovernance {         tradeFee = _tradeFee;         liquidationPenalty = _liquidationPenality;         maintenanceMargin = _maintenanceMargin;         minAllowableMargin = _minAllowableMargin;     } ```  # Lack events on critical parameters change https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L344 ```     function setParams(         int _maintenanceMargin,         int _minAllowableMargin,         uint _tradeFee,         uint _liquidationPenality     ) external onlyGovernance {         tradeFee = _tradeFee;         liquidationPenalty = _liquidationPenality;         maintenanceMargin = _maintenanceMargin;         minAllowableMargin = _minAllowableMargin;     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L722 ```     function setAmmState(AMMState _state) external onlyGovernance {         require(ammState != _state, "AMM.setAmmState.sameState");         ammState = _state;         if (_state == AMMState.Active) {             nextFundingTime = ((_blockTimestamp() + fundingPeriod) / 1 hours) * 1 hours;         }     }      function syncDeps(address _registry) public onlyGovernance {         IRegistry registry = IRegistry(_registry);         clearingHouse = registry.clearingHouse();         oracle = IOracle(registry.oracle());     }      function setFundingBufferPeriod(uint _fundingBufferPeriod) external onlyGovernance {         fundingBufferPeriod = _fundingBufferPeriod;     } ```  # Lack liquidation events in _liquidateMaker https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L163  # Governance can set the orcale price to arbitary number `price` can be set to any number including negative numbers, which will have serious impact  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L169 ```     function setStablePrice(address underlying, int256 price) external onlyGovernance {         requireNonEmptyAddress(underlying);         stablePrice[underlying] = price;     } ```  # Lack chainlink oracle sanity check Recommened to uncoment the sanity check https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L166  # Fund frozen on Oracle malfunction If Oracle malfunction, most fund in the protocol would be frozen 
  # 1. Loops can be more efficient  ## Impact  The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas. ## Proof of Concept ``` function settleFunding() override external whenNotPaused {         for (uint i = 0; i < amms.length; i++) {             amms[i].settleFunding();         }     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L130  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L170  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L251  The same situation are in other scope contracts where loops use.  Remix ## Recommended Mitigation Steps  Remove explicit 0 initialization of for loop index variable.                    # 2. Cache array length in for loops can save gas # Vulnerability details ## Impact Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack. Caching the array length in the stack saves around 3 gas per iteration. ## Proof of Concept ``` function settleFunding() override external whenNotPaused {         for (uint i = 0; i < amms.length; i++) {             amms[i].settleFunding();         }     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L130  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L170  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L251  The same situation are in other scope contracts where loops use. ## Tools  Manual ## Recommended Mitigation Steps Caching len = amms.length and using the len instead will save gas.                    ## 3. Prefix increments are cheaper than postfix increments (i++)  ## Impact There is no risk of overflow caused by increamenting the iteration index in for loops. Increments perform overflow checks that are not necessary in this case.  ## Proof of Concept ``` function settleFunding() override external whenNotPaused {         for (uint i = 0; i < amms.length; i++) {             amms[i].settleFunding();         }     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L130  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L170  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L251  The same situation are in other scope contracts where loops use.  ## Tools  Remix  ## Recommended Mitigation Steps Surround the increment expressions with an unchecked { ... } block to avoid the default overflow checks                     # 4. Long Revert Strings   ## Impact Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met. ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L101  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L354  There are several other places throughout the codebase where the same optimization can be used.   ## Tools  https://planetcalc.com/9029/ ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.       # 5. > 0 can be replaced with != 0 for gas optimisation # Vulnerability details ## Impact != 0 is a cheaper operation compared to > 0, when dealing with uint. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L574 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L211  There are several other places throughout the codebase where the same optimization can be used.   Remix ## Recommended Mitigation Steps   # 6. Change string to byteX if possible # Vulnerability details  ## Impact In the `AMM.sol`, declaring the type bytes32 can save gas. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L28  https://medium.com/layerx/how-to-reduce-gas-cost-in-solidity-f2e5321e0395#2a78 ## Recommended Mitigation Steps  # 7. Struct layout in AMM.sol ## Impact `ReserveSnapshot` struct in `AMM.sol` can be optimized to reduce 2 storage slot ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L61-L62 ``` struct ReserveSnapshot {         uint256 lastPrice;         uint256 timestamp;         uint256 blockNumber;     } ``` `timestamp`  and `blockNumber` store block numbers, and 2^128 is be enough for a very long time. ## Tools  https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html?highlight=Structs#layout-of-state-variables-in-storage ## Recommended Mitigation Steps Change the struct as suggested above ``` struct ReserveSnapshot {         uint256 lastPrice;         uint128 timestamp;         uint128 blockNumber;     } ``` # 8. Adding unchecked directive can save gas  ## Impact For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L726 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L212 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L175-L177 ``` require(margin[idx][trader] >= amount.toInt256(), "Insufficient balance"); margin[idx][trader] -= amount.toInt256(); ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L73 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L81  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L370 ``` uint256 minNextValidFundingTime = _blockTimestamp() + fundingBufferPeriod; ```  ## Recommended Mitigation Steps Consider using 'unchecked' where it is safe to do so.  # 9. Caching variables  ## Impact Some of the variable can be cached to slightly reduce gas usage. ## Proof of Concept   `vamm`  can be cached. https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L188-L195  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L486-L501  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L510-L525  `_blockTimestamp()` can be cahed   https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L656-L704  `vusd` can be cashed  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L572-L579  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L581-L593   ## Tools  Remix ## Recommended Mitigation Steps Consider caching those variable for read and make sure write back to storage      # 10. Placement of require statements ## Impact The require statement in the  `function initialize()` can be placed earlier to reduce gas usage on revert. ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L51  ``` function initialize(         address _governance,         address _insuranceFund,         address _marginAccount,         address _vusd,         int256 _maintenanceMargin,         int256 _minAllowableMargin,         uint _tradeFee,         uint _liquidationPenalty     ) external initializer {         _setGovernace(_governance);          insuranceFund = IInsuranceFund(_insuranceFund);         marginAccount = IMarginAccount(_marginAccount);         vusd = VUSD(_vusd);          require(_maintenanceMargin > 0, "_maintenanceMargin < 0");         maintenanceMargin = _maintenanceMargin;         minAllowableMargin = _minAllowableMargin;         tradeFee = _tradeFee;         liquidationPenalty = _liquidationPenalty;     } ```  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L48  ```  function getUnderlyingTwapPrice(address underlying, uint256 intervalInSeconds)         virtual         public         view         returns (int256)     {         if (stablePrice[underlying] != 0) {             return stablePrice[underlying];         }         AggregatorV3Interface aggregator = AggregatorV3Interface(chainLinkAggregatorMap[underlying]);         requireNonEmptyAddress(address(aggregator));         require(intervalInSeconds != 0, "interval can't be 0");  ```  ## Tools  Remix ## Recommended Mitigation Steps Relocate the said require statement   # 11. Constant is being assigned its default value.  ## Impact The constant variable is being assigned its default value which is unnecessary. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L31 ``` uint constant VUSD_IDX = 0; ``` ## Recommended Mitigation Steps Remove the assignment.  # 12. Checking non-zero value can avoid an external call to save gas Checking if `_amount > 0 `before making the external call to `vusd.safeTransferFrom()` can save 2600 gas by avoiding the external call in such situations. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L51 ## Recommended Mitigation Steps Add check   # 13. function decimals() can be refactored to a constant variable ## Impact function `decimals()` just returns a constant of uint8(6). To save some gas and improve the readability this can be extracted to a constant variable and used where necessary. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/VUSD.sol#L69 ``` function decimals() public pure override returns (uint8) {         return 6;     } ``` ## Recommended Mitigation Steps  # 14. Avoid use of state variables in event emissions to save gas ## Impact Where possible, use equivalent function parameters or local variables in event emits instead of state variables to prevent expensive SLOADs. Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L205 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L381  ``` function realizePnL(address trader, int256 realizedPnl)         override    external       onlyClearingHouse    {            if (realizedPnl != 0) {             margin[VUSD_IDX][trader] += realizedPnl;             emit PnLRealized(trader, realizedPnl, _blockTimestamp());         }   ```  ## Recommended Mitigation Steps Use equivalent function parameters or local variables in event emits instead of state variables.  # 15. Unnecessary indirection to access block.timestamp value ## Impact `_blockTimestamp()` returns the block.timestamp value in `AMM` contract. This internal call only to get value of block.timestamp seems unnecessary because there isn’t any other way of getting current time on the blockchain which justifies moving this to a separate function for modularity. Adds an additional jump and other supporting bytecode of making the internal call which increase gas usage unnecessarily. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L652 ``` function _blockTimestamp() internal view virtual returns (uint256) {         return block.timestamp;     } ``` Recommended Mitigation Steps Use block.timestamp directly to save a little gas by avoiding this unnecessary indirection.  # 16. Consider making some constants as non-public to save gas ## Impact Each function part of contract's external interface is part of the function dispatch, i.e., every time a contract is called, it goes through a switch statement (a set of eq ... JUMPI blocks in EVM) matching the selector of each externally available functions with the chosen function selector (the first 4 bytes of calldata). This means that any unnecessary function that is part of contract's external interface will lead to more gas for (almost) every single function calls to the contract. There are several cases where constants were made public. This is unnecessary; the constants can simply be readfrom the verified contract, i.e., it is unnecessary to expose it with a public function. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L15-L17    # 17. Gas Optimization on the Public Function ## Impact This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract.  ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/VUSD.sol#L69  ## Recommended Mitigation Steps The function  `decimals() public` could be set external instead of public.   # 18. Use Custom Errors to save Gas ## Impact Custom errors from Solidity 0.8.4 are cheaper than revert strings. ## Proof of Concept Source: https://blog.soliditylang.org/2021/04/21/custom-errors/: Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them. Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  ## Recommended Mitigation Steps Replace revert strings with custom errors. # 19. && operator can use more gas ## Impact More expensive gas usage ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L461 ``` require(idx > VUSD_IDX && idx < supportedCollateral.length, "collateral not seizable"); ```  ## Tools Used ## Recommended Mitigation Steps Instead of using operator && on single require check  using double require check can save more gas  # 20. Use  `10 ** DECIMALS` for constant ## Impact More expensive gas usage ## Proof of Concept ``` uint8 constant DECIMALS = 6; uint constant PRECISION = 10 ** DECIMALS; ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L17  ## Recommended Mitigation Steps Change to: ``` uint constant PRECISION = 1e6; ```
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/package.json#L17 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L5 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L24   # Vulnerability details  ## Impact  While Governable.sol is out of scope, I figured this issue would still be fair game.  The solution uses: `"@openzeppelin/contracts": "4.2.0"`. This dependency has a known high severity vulnerability: https://security.snyk.io/vuln/SNYK-JS-OPENZEPPELINCONTRACTS-2320176 Which makes this contract vulnerable: ``` File: Governable.sol 05: import { Initializable } from "@openzeppelin/contracts/proxy/utils/Initializable.sol"; ... 24: contract Governable is VanillaGovernable, Initializable {} ```  This contract is inherited at multiple places: ``` contracts/AMM.sol:   11: contract AMM is IAMM, Governable {  contracts/InsuranceFund.sol:   13: contract InsuranceFund is VanillaGovernable, ERC20Upgradeable {  contracts/Oracle.sol:   11: contract Oracle is Governable {  contracts/legos/HubbleBase.sol:   15: contract HubbleBase is Governable, Pausable, ERC2771Context {  contracts/ClearingHouse.sol:   11: contract ClearingHouse is IClearingHouse, HubbleBase {  contracts/MarginAccount.sol:   25: contract MarginAccount is IMarginAccount, HubbleBase { ```   ìnitializer()` is used here: ``` contracts/AMM.sol:   99:     ) external initializer {  contracts/ClearingHouse.sol:   44:     ) external initializer {  contracts/MarginAccount.sol:   124:     ) external initializer {  contracts/Oracle.sol:   20:     function initialize(address _governance) external initializer {  ```  ## Recommended Mitigation Steps Upgrade `@openzeppelin/contracts` to version 4.4.1 or higher.  
Hubble contest Gas Optimization   1 use initial value to save gas for uint.      https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L52  uint shares;   2 use cache for array length to save gas.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277      3 Delete unused variable. It seems that the following variable will be not used in this construct and other contracts. If it is not used, you can delete it to save gas.   https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L22      4 Avoid extra mstore.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L121 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L141 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L614   isNewPosition and isLongPosition are used only one time in   https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L123 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L143   https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L616 You can use position.size == 0 and position.size > 0 directly there to save gas.  if (position.size == 0 || (position.size > 0 ? Side.LONG : Side.SHORT) == side) { if (position.size > 0) {  5 Use msg.sender instead of _msgSender() to save gas.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L65 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L69 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L98 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L113 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L214     6 Delete unused import statements in AMM.sol  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L5  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L9 
Hubble contest  1 Change order of the modifier of functions.  According to solidity doc order of the modifier must be             1 Visibility 2 Mutability 3Virtual 4 Override 5 Custom modifiers In functions, the order is a little different. For example,  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L64 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L242  and so on.    2 missing input validation.  Input _governance is not checked in initialize whether it is empty or not. Nobody can have control as governance if it will be set with an empty address.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L34-L37     3 Use naming convention for constant variables  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L15-L16  uint256 public constant SPOT_PRICE_TWAP_INTERVAL = 1 hours; Uint256 public constant FUNDING_PERIOD = 1 hours;     4 Delete unused return value variable name in getCloseQuote.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L449     5 Input validation must be checked.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L148-L151  add   require(isMaker(trader), 'describe something');     6 Delete unnecessary variables.  In getTotalNotionalPositionAndUnrealizedPnl return values are defined, so following variables must be unnecessary.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L275-L276 
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67   # Vulnerability details  ## Impact DoS of USDC withdrawal system  ## Proof of Concept Currently, withdrawals are queued in an array and processed sequentially in a for loop. However, a `safeTransfer()` to USDC blacklisted user will fail. It will also brick the withdrawal system because the blacklisted user is never cleared.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67  ## Tools Used Manual review  ## Recommended Mitigation Steps Possible solutions: 1st solution: Implement 2-step withdrawals:     - In a for loop, increase the user's amount that can be safely withdrawn.     - A user himself withdraws his balance  2st solution: Skip blacklisted users in a processWithdrawals loop  
# QA Report  # Low Findings  ## L01: Add modifiers to ensure that dependencies are synced  ### Description  The `syncDeps` function exists in the AMM, InsuranceFund and MarginAccount contracts as a helper function to sync the shared contract addresses between the Registry contract. It does not however ensure that all contracts are actually in synced i.e. if the Registry contract changes, there are no checks to ensure that the addresses are still in sync.  ## L02: Adhere to the Check Effect Interactions pattern best practice  ### Line References  [https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L62-L64](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L62-L64)  ### Description  Update internal state before transferring tokens out.  # Non-Critical Findings  ## NC01: Avoid rebase tokens  ### Line References  [https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L548](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L548)  ### Description  Be mindful when adding collateral as some token implementations e.g. rebase tokens are not handled by the smart contract.  ## NC02: Incorrect comment for `_getLiquidationInfo`  ### Line References  [https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L458](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L458)  ### Description  `_getLiquidationInfo` doesn’t actually revert. It is the parent liquidation function that reverts if it receives a `LiquidationStatus` that is not `IS_LIQUIDATABLE`.  ## NC03: Add a rescue token / ETH function  ### Description  In the event ETH / tokens are mistakenly sent to the contracts, it is possible to withdraw them through a `rescueToken` or `rescueETH` function. This function can only be called by governance.
### Using memory copies of storage variables when repeated access is required uses less gas `credit` should be copied ```solidity         if (credit > 0) {             uint toBurn = Math.min(vusd.balanceOf(address(this)), credit);             credit -= toBurn; ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L574-L576   ### Functions not called by the contract itself should be `external` rather than `public` ```solidity function getUnderlyingTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {         ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L387  ```solidity function liquidateMaker(address maker) override public whenNotPaused {          ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L148  ```solidity function liquidateTaker(address trader) override public whenNotPaused {          ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L153  ```solidity function syncDeps(IRegistry _registry) public onlyGovernance {           ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L116  ```solidity function getNormalizedMargin(address trader) override public view returns(int256 weighted) {        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L509  ```solidity function syncDeps(address _registry, uint _liquidationIncentive) public onlyGovernance {         ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L599   ### `require()` strings longer than 32 bytes cost extra gas ```solidity require(baseAssetQuantity > 0, "VAMM._longbaseAssetQuantity is <= 0");                  ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L487  ```solidity require(baseAssetQuantity < 0, "VAMM._shortbaseAssetQuantity is >= 0");                  ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L511  ```solidity require(margin[VUSD_IDX][trader] >= 0, "Cannot remove margin when vusd balance is negative");              ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L174  ```solidity require(notionalPosition == 0, "Liquidate positions before settling bad debt");                ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L354  ```solidity require(repay <= maxRepay, "Need to repay more to seize that much");              ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L453  ```solidity require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this timeNot enough balance');              ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L55  ```solidity require(isAboveMinAllowableMargin(trader), "CHBelow Minimum Allowable Margin");                    ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L84  ```solidity require(isAboveMinAllowableMargin(maker), "CHBelow Minimum Allowable Margin");                    ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L101  ```solidity require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "HubbleErc20.allowTransfers.noAuth");                      ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/ERC20Mintable.sol#L32  ```solidity require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "HubbleErc20.allowTransfers.noAuth");                      ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/ERC20Mintable.sol#L60  ```solidity require(prices[underlying] != 0, "underlying price has not been set as yet");              ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/TestOracle.sol#L20  ```solidity require(twapPrices[underlying] != 0, "underlying twap price has not been set as yet");             ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/TestOracle.sol#L33   ### Using `> 0` costs more gas than `!= 0` when used in on uints in a `require()` statement ```solidity require(amount > 0, "Add non-zero margin");           ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L150  ```solidity require(_round > 0, "Not enough history");           ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L153   ### Splitting `require()` statements that use `&&` saves gas See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) for an example ```solidity require(idx > VUSD_IDX && idx < supportedCollateral.length, "collateral not seizable");       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol   ### It costs more gas to initialize variables to zero than to let the default of zero be applied ```solidity uint constant VUSD_IDX = 0;            ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L31  ```solidity for (uint i = 0; i < idxs.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L331  ```solidity for (uint i = 0; i < assets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L521  ```solidity for (uint i = 0; i < _collaterals.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L552  ```solidity uint constant VUSD_IDX = 0;            ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccountHelper.sol#L13  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170  ```solidity for (uint i = 0; i < amms.length; i++) { // liquidate all positions   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L251  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277  ```solidity uint shares = 0;             ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L52  ```solidity uint constant VUSD_IDX = 0;            ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L15  ```solidity for (uint i = 0; i < len; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L52  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L65  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L78  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L95  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L120  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L137  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L9  ```solidity uint256 total = 0;             ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L17  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L18  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L21  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L27  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L32  ```solidity for (uint i = 0; i < numTraders; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L43  ```solidity for (uint j = 0; j < l; j++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L45  ```solidity for (uint i = 0; i < targets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Executor.sol#L19  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L25  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L31  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L37   ### `<array>.length` should not be looked up in every loop of a for-loop Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length ```solidity for (uint i = 0; i < idxs.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L331  ```solidity for (uint i = 1 /* skip vusd */; i < assets.length; i++) {   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L373  ```solidity for (uint i = 0; i < assets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L521  ```solidity for (uint i = 0; i < _collaterals.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L552  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170  ```solidity for (uint i = 0; i < amms.length; i++) { // liquidate all positions   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L251  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L65  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L78  ```solidity for (uint i = 1; i < length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L367  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L9  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L18  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L21  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L27  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L32  ```solidity for (uint i = 0; i < targets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Executor.sol#L19  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L25  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L31  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L37   ### `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in for- and while-loops ```solidity for (uint i = 0; i < idxs.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L331  ```solidity for (uint i = 1 /* skip vusd */; i < assets.length; i++) {   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L373  ```solidity for (uint i = 0; i < assets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L521  ```solidity for (uint i = 0; i < _collaterals.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L552  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170  ```solidity for (uint i = 0; i < amms.length; i++) { // liquidate all positions   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L251  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277  ```solidity for (uint i = 0; i < len; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L52  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L65  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L78  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L95  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L120  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L137  ```solidity for (uint i = 1; i < length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L367  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L9  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L18  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L21  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L27  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L32  ```solidity for (uint i = 0; i < numTraders; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L43  ```solidity for (uint j = 0; j < l; j++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L45  ```solidity for (uint i = 0; i < targets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Executor.sol#L19  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L25  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L31  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L37   ### `++i` costs less gas than `++i`, especially when it's used in for-loops (`--i`/`i--` too) ```solidity for (uint i = 0; i < idxs.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L331  ```solidity for (uint i = 1 /* skip vusd */; i < assets.length; i++) {   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L373  ```solidity for (uint i = 0; i < assets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L521  ```solidity for (uint i = 0; i < _collaterals.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L552  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170  ```solidity for (uint i = 0; i < amms.length; i++) { // liquidate all positions   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L251  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277  ```solidity for (uint i = 0; i < len; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L52  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L65  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L78  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L95  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L120  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L137  ```solidity for (uint i = 1; i < length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L367  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L9  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L18  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L21  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L27  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L32  ```solidity for (uint i = 0; i < numTraders; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L43  ```solidity for (uint j = 0; j < l; j++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L45  ```solidity for (uint i = 0; i < targets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Executor.sol#L19  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L25  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L31  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L37 
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L71-L75 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L62-L69   # Vulnerability details  ## Impact  A user is able to front-run the call to `seizeBadDebt()` in `InsuranceFund.sol` to avoid paying the insurance costs.  `seizeBadDebt()` is called by `MarginAccount.settleBadDebt()` which is a public function. When this functions is called the transaction will appear in the mem pool.  A user may then call `InsuranceFund.withdraw()` to withdraw all of their shares. If they do this with a higher gas fee it will likely be processed before the `settleBadDebt()` transaction. In this way they will avoid incurring any cost from the assets being seized.  The impact is that users may gain their share of the insurance funding payments with minimal risk (minimal as there is a change the front-run will not succeed) of having to repay these costs.  ## Proof of Concept  ```     function withdraw(uint _shares) external {         settlePendingObligation();         require(pendingObligation == 0, "IF.withdraw.pending_obligations");         uint amount = balance() * _shares / totalSupply();         _burn(msg.sender, _shares);         vusd.safeTransfer(msg.sender, amount);         emit FundsWithdrawn(msg.sender, amount, block.timestamp);     } ```  ```     function seizeBadDebt(uint amount) external onlyMarginAccount {         pendingObligation += amount;         emit BadDebtAccumulated(amount, block.timestamp);         settlePendingObligation();     } ```  ## Recommended Mitigation Steps  Consider making the withdrawals a two step process. The first step requests a withdrawal and marks the time. The second request processes the withdrawal but requires a period of time to elapse since the first step.  To avoid having users constantly having pending withdrawal, each withdrawal should have an expiry time and also a recharge time. The if the second step is not called within expiry amount of time it should be considered invalid. The first step must not be able to be called until recharge time has passed.  Another solution involves a design change where the insurance fund is slowly filled up over time without external deposits. However, this has the disadvantage that bad debts received early in the protocols life time may not have sufficient insurance capital to cover them.  
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L93-L108 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L730-L734 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L10-L13   # Vulnerability details  ## Impact  The contact `AMM.sol` cannot be initialize unless it is called from the `_governance` address.  This prevents the use of a deployer account and requires the governance to be able to deploy proxy contracts and encode the required arguements. If this is not feasible then the contract cannot be deployed.  ## Proof of Concept  `initialize()` calls `_setGovernace(_governance);` which will store the governance address.   Following this it will call `syncDeps(_registry);` which has `onlyGovernance` modifier.  Thus, if the `msg.sender` of `initialize()` is not the same as the parameter `_governance` then the initialisation will revert.   ```solidity     function initialize(         address _registry,         address _underlyingAsset,         string memory _name,         address _vamm,         address _governance     ) external initializer {         _setGovernace(_governance);          vamm = IVAMM(_vamm);         underlyingAsset = _underlyingAsset;         name = _name;         fundingBufferPeriod = 15 minutes;          syncDeps(_registry);     } ```  ## Recommended Mitigation Steps  Consider adding the steps manually to `initialize()`. i.e.  ```solidity     function initialize(         address _registry,         address _underlyingAsset,         string memory _name,         address _vamm,         address _governance     ) external initializer {         _setGovernace(_governance);          vamm = IVAMM(_vamm);         underlyingAsset = _underlyingAsset;         name = _name;         fundingBufferPeriod = 15 minutes;          IRegistry registry = IRegistry(_registry);         clearingHouse = registry.clearingHouse();         oracle = IOracle(registry.oracle()); } ```  
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L339-L342 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L269-L282   # Vulnerability details  ## Impact  `ClearingHouse.sol` allows the Governance protocol to whitelist `AMM.sol` contracts. These contracts allow users to earn profits based on the price of a base asset against a quote asset.  It is possible to add the same `AMM` twice in the function `whitelistAmm()`. The impact is that unrealized profits will be counted multiple times. As a result the liquidation calculations will be incorrect, potentially allowing users to trade while insolvent or incorrectly liquidating solvent users.  Note `whitelistAmm()` may only be called by Governance.  ## Proof of Concept  The function `getTotalNotionalPositionAndUnrealizedPnl()` will iterate over all `amms` summing the `unrealizedPnl`  and `notinoalPosition`, thus if an `amm` is repeated the `unrealizedPnl` and `notionalPosition` of that asset will be counted multiple times.  This is used in `_calcMarginFraction()` which calculates a users margin as a fraction of the total position. The margin fraction is used to determine if a user is liquitable or is allowed to open new positions.   ## Recommended Mitigation Steps  Consider ensuring the `AMM` does not already exist in the list when adding a new `AMM`.  ```     function whitelistAmm(address _amm) external onlyGovernance {         for (uint256 i; i < amm.length; i++) {             require(amm[i] != IAMM(_amm), "AMM already whitelisted");         }         emit MarketAdded(amms.length, _amm);         amms.push(IAMM(_amm));     } ```  
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L24-L35   # Vulnerability details  ## Impact  If the price feed is manipulated in any way or there is any malfunction based volatility on the market, a malicious user can use this to liquidate a healthy position.  An attacker can setup a monitoring of the used Oracle feed and act on observing a price outbreak (for example, zero price, which is usually a subject to filtration), liquidating the trader position which is perfectly healthy otherwise, obtaining the collateral with a substantial discount at the expense of the trader.  The same is for a flash crash kind of scenario, i.e. a price outbreak of any nature will allow for non-market liquidation by an attacker, who has the incentives to setup such a monitoring and act on such an outbreak, knowing that it will not be smoothed or filtered out, allowing a liquidation at a non-market price that happen to be printed in the Oracle feed  ## Proof of Concept  Oracle.getUnderlyingPrice just passes on the latest Oracle answer, not checking it anyhow:  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L24-L35  It is then used in liquidation triggers providing isLiquidatable and _getLiquidationInfo functions:  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L249  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L465  ## Recommended Mitigation Steps  Add a non-zero Oracle price check, possibly add an additional Oracle feed information usage to control that the price is fresh. Please consult the Chainlink for that as OCR introduction might have changed the state of the art approach (i.e. whether and how to use latestRoundData returned data):  https://docs.chain.link/docs/off-chain-reporting/  Regarding any price spikes it is straightforward to construct a mitigation mechanics for such cases, so the system will be affected by sustainable price movements only.  As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.  One of the approaches is to track both current and TWAP prices, and condition all state changing actions, including liquidations, on the current price being within a threshold of the TWAP one. If the liquidation margin level is conservative enough and TWAP window is small enough this is safe for the overall stability of the system, while providing substantial mitigation mechanics by allowing state changes on the locally calm market only.  Another approach is to introduce time delay between liquidation request and actual liquidation. Again, conservative enough margin level plus small enough delay keeps the system safe, while requiring that market conditions allow for liquidation both at request time and at execution time provides ample filtration against price feed outbreaks   
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L34   # Vulnerability details  ## Impact The `Oracle.getUnderlyingPrice` function divides the chainlink price by `100`. It probably assumes that the answer for the underlying is in 8 decimals but then wants to reduce it for 6 decimals to match USDC.  However, arbitrary `underlying` tokens are used and the chainlink oracles can have different decimals.  ## Recommended Mitigation Steps While most USD price feeds use 8 decimals, it's better to take the on-chain reported decimals into account by doing `AggregatorV3Interface(chainLinkAggregatorMap[underlying]).decimals()`, see [Chainlink docs](https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination). The price should then be scaled down to 6 decimals.   
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L344-L354 https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L15-L21   # Vulnerability details  When fees/margin or governance are involved it's important to emit events for off-chain monitors/tools to be able to react if necessary.  ## Impact Automated tools especially need all relevant ancillary data to be emitted in order to efficiently react to it. An automated bot trading with the hubble exchange will not be able to see changes to fee/margin changes in real time, and may submit orders which cause it to miscalculate P&L, causing it to lose capital. This is especially true because the contracts do not use timelocks for changes. See [these](https://github.com/code-423n4/2021-06-tracer-findings/issues/64) [examples](https://github.com/code-423n4/2021-09-swivel-findings/issues/101) [where](https://blog.openzeppelin.com/uma-audit-phase-4/) [similar](https://blog.openzeppelin.com/audius-contracts-audit/#high) findings have been flagged as medium/high-severity issues.  ## Proof of Concept ```solidity     function setParams(         int _maintenanceMargin,         int _minAllowableMargin,         uint _tradeFee,         uint _liquidationPenality     ) external onlyGovernance {         tradeFee = _tradeFee;         liquidationPenalty = _liquidationPenality;         maintenanceMargin = _maintenanceMargin;         minAllowableMargin = _minAllowableMargin;     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L344-L354  ```solidity     function setGovernace(address _governance) external onlyGovernance {         _setGovernace(_governance);     }      function _setGovernace(address _governance) internal {         governance = _governance;     } ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L15-L21  The `onlyGovernance` modifier does not emit events ```solidity     address public governance;      modifier onlyGovernance() {         require(msg.sender == governance, "ONLY_GOVERNANCE");         _;     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/legos/Governable.sol#L8-L13  The provided deployment script [only uses a signer](https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/scripts/deploy.js#L18) rather than a contract as the governance address. Furthermore, the live environment deployed on testnet has a [deployed](https://testnet.snowtrace.io/address/0x089f4f3b4aedc41d6ffd4908f4ff32e6a915996b) `InsuranceFund` which uses the `onlyGovernance` modifier... ```solidity     function syncDeps(IRegistry _registry) public onlyGovernance {         vusd = IERC20(_registry.vusd());         marginAccount = _registry.marginAccount();     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L116-L119  ...and the only transaction interacting with this function appears [here](https://testnet.snowtrace.io/tx/0x31d395e69753469c86a7ed9ab817f15c6a6362ebe31397373daabc83f24d567c) and is called by an [address](https://testnet.snowtrace.io/address/0x835ce0760387bc894e91039a88a00b6a69e65d94), not a contract. There are no other transactions to the insurance fund to change the governance address, so it's clear that the testnet does not use an emitting governor either.  ## Tools Used Code inspection Hardhat snowtrace.io  ## Recommended Mitigation Steps Emit events for these changes   
## Withdrawals can stuck  1. Consider processWithdrawals function at VUSD.sol#L53 2. Assume contract has balance of 100 3. Withdrawal request are 101,10,20,30 4. processWithdrawals function is called 5. Function fail since contract does not have 101 balance 6. But due to this the remaining transaction also get blocked 10,20,30 for which contract had sufficient balance  Recommendation: If contract does not have balance for particular withdrawal instance, keep that in pending object and try to complete the remaining ones  ## Withdraw timelock missing  1. The withdraw function at VUSD.sol#L48 is not placing any timelock which means user can call withdraw function frequently and push them into withdrawals object. This can delay other user withdrawal which are placed in long queue back and since processWithdrawals can only process maxWithdrawalProcesses at one run, other user withdrawal may delay  Recommendation: There should be a timelock after which withdraw can be called again otherwise this can be called repeatedly for small amounts If user has requested withdraw then he should only be able to call this function again after x timestamp  ## Shares can give lower value  1. Consider withdraw function at InsuranceFund.sol#L62  2. if some big bad debt comes (seizeBadDebt at MarginAccount.sol#L368) then settlePendingObligation function which is called at withdraw function will consume most contract balance. This will reduce amount in balance()  3. Since withdraw amount is directly proportional to balance (uint amount = balance() * _shares / totalSupply();) so same shares will give less amount  ## Missing Oracle price checks  1. In getLatestRoundData function at Oracle.sol#L115, there is no check to see if returned price of _aggregator.latestRoundData() is not stale. More details at https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  Recommendation: Modify the function as below:  ``` (uint80 round, int256 latestPrice, , uint256 latestTimestamp, uint80 answeredInRound) = _aggregator.latestRoundData(); require(feedPrice > 0, "Chainlink price <= 0");  require(answeredInRound >= round, "Stale price"); require(latestTimestamp != 0, "Round not complete"); ```  ## Input validation missing  1. It was observed that price can be set to 0 in setStablePrice function at Oracle.sol#L169. This is incorrect since the contract checks stablePrice[underlying] != 0 in other functions like getUnderlyingPrice.   Recommendation: Add below check  ``` function setStablePrice(address underlying, int256 price) external onlyGovernance { require(price!=0,"Invalid price")         requireNonEmptyAddress(underlying);         stablePrice[underlying] = price;     } ```  ## Incorrect condition can give incorrect price  1. The getUnderlyingTwapPrice function at Oracle.sol#L67 is returning latestPrice when latestTimestamp < baseTimestamp.   2. Else it would goto previous rounds  3. This is incorrect. This function should return latestPrice when latestTimestamp = baseTimestamp  Recommendation: Modify the check like below  ``` if (latestTimestamp <= baseTimestamp || round == 0) {             return formatPrice(latestPrice);         } ```  ## Zero address checks are missing   1. For all address arguments at constructor of Registry.sol#L12. Add below require  ``` require(_oracle!=address(0), "Invalid address"); require(_clearingHouse!=address(0), "Invalid address"); require(_insuranceFund!=address(0), "Invalid address"); require(_marginAccount!=address(0), "Invalid address"); require(_vusd!=address(0), "Invalid address"); ```  2. Initialize function at AMM.sol#L93, add below require  ``` require(_registry!=address(0), "Invalid address"); require(_underlyingAsset!=address(0), "Invalid address"); require(_vamm!=address(0), "Invalid address"); ```  3.  Initialize function at ClearingHouse.sol#L35, add below require  ``` require(_insuranceFund!=address(0), "Invalid address"); require(_marginAccount!=address(0), "Invalid address"); require(_vusd!=address(0), "Invalid address"); ```  4. In getUnderlyingPrice function, check aggregator is non empty address  ``` function getUnderlyingPrice(address underlying)         virtual         external         view         returns(int256 answer)     { AggregatorV3Interface aggregator = AggregatorV3Interface(chainLinkAggregatorMap[underlying]); requireNonEmptyAddress(address(aggregator));         ...     } ```
1. In processWithdrawals function at VUSD.sol#L64, modify i+=1 to ++i  2. In processWithdrawals function at VUSD.sol#L63, use unchecked at reserve -= withdrawal.amount; since we already know that reserve > withdrawal.amount  3. In withdraw function at VUSD.sol#L48, add a check require(amount!=0, "Invalid amount");  4. In mintWithReserve function at VUSD.sol#L43, add below require  ``` require(amount!=0, "Invalid amount"); require(to!=address(0), "Invalid address"); ```  5. getRoundData function at Oracle.sol#L124 is not required. Simply change the if(latestPrice < 0) to while(latestPrice < 0) at Oracle.sol#L117 which will eliminate the need of getRoundData function  ``` function getLatestRoundData(AggregatorV3Interface _aggregator)         internal         view         returns (             uint80,             uint256 finalPrice,             uint256         )     {         (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.latestRoundData();         finalPrice = uint256(latestPrice);         while (latestPrice < 0) {             requireEnoughHistory(round);             (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);         }         return (round, finalPrice, latestTimestamp);     } ```  6. In deposit function at InsuranceFund.sol#L39, add a condition require(amount!=0, "Invalid amount")  7. In withdraw function at InsuranceFund.sol#L62, add a check require( _shares!=0,"Invalid shares");  8. In liquidate function at ClearingHouse.sol#L140, updatePositions function is not required since this is already called in _liquidateMaker and _liquidateTaker function  9. In addMarginFor function at MarginAccount.sol#L149, add new check   ``` require(idx >= supportedCollateral.length,"Invalid index"); ```  10. In removeMargin function at MarginAccount.sol#L177, margin[idx][trader] -= amount.toInt256(); can be unchecked since contract has already checked margin[idx][trader] >= amount.toInt256()  11. In removeMargin function at MarginAccount.sol#L168, add a check require(amount!=0,"Invalid amount");  12. In settleBadDebt function at MarginAccount.sol#L362, modify require(vusdBal < 0, "Nothing to repay"); to require(vusdBal <= 0, "Nothing to repay"); since if vusdBal is 0 then also there is nothing to repay  13. In weightedAndSpotCollateral function at MarginAccount.sol#L524 add a check to see margin[i][trader]==0 as shown below  ``` function weightedAndSpotCollateral(address trader)         public         view         returns (int256 weighted, int256 spot)     {         ...          for (uint i = 0; i < assets.length; i++) {             _collateral = assets[i];   if(margin[i][trader]==0){continue}             int numerator = margin[i][trader] * oracle.getUnderlyingPrice(address(assets[i].token));             ...         }     } ```  14. In liquidateFlexible function at MarginAccount.sol#L328, before entering loop check if trader can be liquidated  ``` function liquidateFlexible(address trader, uint maxRepay, uint[] calldata idxs) external whenNotPaused {         clearingHouse.updatePositions(trader); // credits/debits funding (buffer.status, buffer.repayAble, buffer.incentivePerDollar) = isLiquidatable(trader, false); if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {return}  for (uint i = 0; i < idxs.length; i++){         ...     } ```
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L11   # Vulnerability details  ## Impact The contract use two governance model, one looks hidden.  ## Proof of Concept The VUSD contract uses `VanillaGovernable` but inherits from `ERC20PresetMinterPauserUpgradeable` and this contract uses roles to use some administrative methods like `pause` or `mint`.  This two-governance model does not seem necessary and can hide or raise suspicion about a rogue pool, thus damaging the user's trust.  ## Recommended Mitigation Steps Unify governance in only one, VanillaGovernable or role based.  
 Title: Not verified input Severity: Low Risk       external / public functions parameters should be validated to make sure the address is not 0.     Otherwise if not given the right input it can mistakenly lead to loss of user funds.                       AMM.sol.getPendingFundingPayment trader         Oracle.sol.requireNonEmptyAddress _addr         ClearingHouse.sol.whitelistAmm _amm     Title: Named return issue Severity: Low Risk  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           Oracle.sol, getUnderlyingPrice         AMM.sol, updatePosition         MarginAccount.sol, isLiquidatable         Oracle.sol, getLatestRoundData         AMM.sol, getCloseQuote    Title: Mult instead div in compares Severity: Low Risk       To improve algorithm precision instead using division in comparison use multiplication in the following scenario:                          Instead a < b / c use a * c < b.               In all of the big and trusted contracts this rule is maintained.              MarginAccount.sol, 601, require(_liquidationIncentive <= PRECISION / 10, "MA.syncDeps.LI_GT_10_percent");    Title: In the following public update functions no value is returned Severity: Low Risk  In the following functions no value is returned, due to which by default value of return will be 0.  We assumed that after the update you return the latest new value.  (similar issue here: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/85).           ClearingHouse.sol, updatePositions    Title: Anyone can withdraw others Severity: Low Risk   Anyone can withdraw users shares. Although we think that they are sent to the right address, it is still     1) not the desired behavior     2) can be dangerous if the receiver is a smart contract     3) the receiver may not know someone withdraw him               InsuranceFund.withdraw         VUSD.setMaxWithdrawalProcesses         VUSD.withdraw         VUSD.processWithdrawals    Title: Does not validate the input fee parameter Severity: Low Risk   Some fee parameters of functions are not checked for invalid values. Validate the parameters:                           ClearingHouse._disperseLiquidationFee (liquidationFee)         ClearingHouse.setParams (_tradeFee)         ClearingHouse.initialize (_tradeFee)    Title: Duplicates in array Severity: Low Risk           You allow in some arrays to have duplicates. Sometimes you assumes there are no duplicates in the array.          ClearingHouse.whitelistAmm pushed (_amm)   {         emit MarketAdded(amms.length, _amm);         amms.push(IAMM(_amm));     } VUSD.withdraw pushed (amount)   {         burn(amount);         withdrawals.push(Withdrawal(msg.sender, amount));     }    Title: Init frontrun Severity: Low Risk  Most contracts use an init pattern (instead of a constructor) to initialize contract parameters. Unless these are enforced to be atomic with contact deployment via deployment script or factory contracts, they are susceptible to front-running race conditions where an attacker/griefer can front-run (cannot access control because admin roles are not initialized) to initially with their own (malicious) parameters upon detecting (if an event is emitted) which the contract deployer has to redeploy wasting gas and risking other transactions from interacting with the attacker-initialized contract.  Many init functions do not have an explicit event emission which makes monitoring such scenarios harder. All of them have re-init checks; while many are explicit some (those in auction contracts) have implicit reinit checks in initAccessControls() which is better if converted to an explicit check in the main init function itself. (details credit to: https://github.com/code-423n4/2021-09-sushimiso-findings/issues/64) The vulnerable initialization functions in the codebase are:           Oracle.sol, initialize, 20         ClearingHouse.sol, initialize, 35         MarginAccount.sol, initialize, 121         AMM.sol, initialize, 93    Title: Open TODOs Severity: Low Risk  Open TODOs can hint at programming or architectural errors that still need to be fixed.  These files has open TODOs:  Open TODO in AMM.sol line 554 :             // @todo handle case when totalPosition = 0  Open TODO in ClearingHouse.sol line 171 :             // @todo put checks on slippage  Open TODO in MarginAccount.sol line 276 :             @todo consider providing some incentive from insurance fund to execute a liquidation in this scenario.  Open TODO in AMM.sol line 141 :         // sending market orders can fk the trader. @todo put some safe guards around price of liquidations     Title: Unbounded loop on array that can only grow can lead to DoS Severity: Low/Med Risk  A malicious attacker that is also a protocol owner can push unlimitedly to an array, that some function loop over this array. If increasing the array size enough, calling the function that does a loop over the array will always revert since there is a gas limit. This is a Med Risk issue since it can lead to DoS with a reasonable chance of having untrusted owner or even an owner that did a mistake in good faith.          ClearingHouse.sol (L250): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L169): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L276): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L129): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L193): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L262): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L121): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled    Title: Div by 0 Severity: Medium Risk   Division by 0 can lead to accidentally revert, (An example of a similar issue - https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/84)          MarginAccount.sol (L432) buffer might be 0)         AMM.sol (L251) _maker might be 0)         AMM.sol (L551) takerPosition might be 0)         MarginAccount.sol (L497) buffer might be 0)         AMM.sol (L681) period might be 0)         ClearingHouse.sol (L332) notionalPosition might be 0)         MarginAccount.sol (L495) buffer might be 0)         AMM.sol (L556) totalPosition might be 0)         AMM.sol (L552) totalPosition might be 0)         AMM.sol (L710) _underlyingPrice might be 0)         AMM.sol (L251) maker might be 0)         AMM.sol (L250) maker might be 0)         AMM.sol (L703) _intervalInSeconds might be 0)         AMM.sol (L250) _maker might be 0)         AMM.sol (L592) baseAssetQuantity might be 0)    Title: Usage of an incorrect version of Ownbale library can potentially malfunction all onlyOwner functions Severity: High Risk       The current implementaion is using an non-upgradeable version of the Ownbale library.  instead of the upgradeable version: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol.     A regular, non-upgradeable Ownbale library will make the deployer the default owner in the constructor. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. Therefore, there will be no owner when the contract is deployed as a proxy contract     Use @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol and @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol instead.     And add     __Ownable_init(); at the beginning of the initializer.                   Oracle.sol         AMM.sol    Title: Unbounded loop on array can lead to DoS Severity: High Risk  The attacker can push unlimitedly to an array, that some function loop over this array. If increasing the array size enough, calling the function that does a loop over the array will always revert since there is a gas limit. This is an High Risk issue since those arrays are publicly allows to push items into them.          ClearingHouse.sol (L193): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L262): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L169): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L129): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L250): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L121): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L276): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']  
# Gas Report  **Table of Contents:**  - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [Summary](#summary)   - [File: AMM.sol](#file-ammsol)     - [function initialize()](#function-initialize)       - [Use `calldata` instead of `memory` for `string _name`](#use-calldata-instead-of-memory-for-string-_name)     - [function openPosition()](#function-openposition)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory)     - [function liquidatePosition()](#function-liquidateposition)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-1)     - [function removeLiquidity()](#function-removeliquidity)       - [Do not cache `positions[maker]` in memory](#do-not-cache-positionsmaker-in-memory)       - [Do not cache `makers[maker]` in memory](#do-not-cache-makersmaker-in-memory)     - [function getNotionalPositionAndUnrealizedPnl()](#function-getnotionalpositionandunrealizedpnl)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-2)       - [Do not cache `makers[trader]` in memory](#do-not-cache-makerstrader-in-memory)     - [function getPendingFundingPayment()](#function-getpendingfundingpayment)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-3)       - [Do not cache `makers[trader]` in memory](#do-not-cache-makerstrader-in-memory-1)     - [function getTakerNotionalPositionAndUnrealizedPnl()](#function-gettakernotionalpositionandunrealizedpnl)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-4)     - [function _emitPositionChanged()](#function-_emitpositionchanged)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-5)     - [function _openReversePosition()](#function-_openreverseposition)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-6)       - [Unchecked block L597](#unchecked-block-l597)     - [function _calcTwap()](#function-_calctwap)       - [Do not cache `reserveSnapshots[snapshotIndex]` in memory](#do-not-cache-reservesnapshotssnapshotindex-in-memory)       - [Cache `reserveSnapshots.length` in memory](#cache-reservesnapshotslength-in-memory)       - [Unchecked block L684](#unchecked-block-l684)       - [Use the cache for calculation](#use-the-cache-for-calculation)   - [File: ClearingHouse.sol](#file-clearinghousesol)     - [function _disperseLiquidationFee()](#function-_disperseliquidationfee)       - [Unchecked block L214](#unchecked-block-l214)   - [File: InsuranceFund.sol](#file-insurancefundsol)     - [function pricePerShare()](#function-pricepershare)       - [Unchecked block L97](#unchecked-block-l97)   - [File: Oracle.sol](#file-oraclesol)     - [function getUnderlyingTwapPrice()](#function-getunderlyingtwapprice)       - [Unchecked block L81](#unchecked-block-l81)   - [File: Interfaces.sol](#file-interfacessol)     - [struct Collateral](#struct-collateral)       - [Tight packing structs to save slots](#tight-packing-structs-to-save-slots)   - [File: MarginAccount.sol](#file-marginaccountsol)     - [function _getLiquidationInfo()](#function-_getliquidationinfo)       - [Do not cache `supportedCollateral[idx]` in memory](#do-not-cache-supportedcollateralidx-in-memory)     - [function _transferOutVusd()](#function-_transferoutvusd)       - [Unchecked block L588](#unchecked-block-l588)   - [File: VUSD.sol](#file-vusdsol)     - [function processWithdrawals()](#function-processwithdrawals)       - [Unchecked block L57-L65](#unchecked-block-l57-l65)       - [Cache `start` in memory](#cache-start-in-memory)   - [General recommendations](#general-recommendations)     - [Variables](#variables)       - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values)       - [Pre-increments cost less gas compared to post-increments](#pre-increments-cost-less-gas-compared-to-post-increments)     - [Comparisons](#comparisons)       - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof)     - [For-Loops](#for-loops)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)       - [`++i` costs less gas compared to `i++`](#i-costs-less-gas-compared-to-i)       - [Increments can be unchecked](#increments-can-be-unchecked)     - [Arithmetics](#arithmetics)       - [Shift Right instead of Dividing by 2](#shift-right-instead-of-dividing-by-2)     - [Errors](#errors)       - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword  - **Storage-reading optimizations**  > The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). In the paragraphs below, please see the `@audit-issue` tags in the pieces of code's comments for more information about SLOADs that could be saved by caching the mentioned **storage** variables in **memory** variables.  - **Unchecking arithmetics operations that can't underflow/overflow**  > Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Summary  - One pattern that was often seen is caching structs in memory when it's not needed. A copy in memory of a storage struct will trigger as many SLOADs as there are slots. If the struct's fields are only read once, or if the number of storage reading would be inferior to the number of slots: don't cache the struct in memory.  ## File: AMM.sol  ### function initialize()  ``` 093:     function initialize( 094:         address _registry, 095:         address _underlyingAsset, 096:         string memory _name,//@audit readonly: calldata 097:         address _vamm, 098:         address _governance 099:     ) external initializer { 100:         _setGovernace(_governance); 101:  102:         vamm = IVAMM(_vamm); 103:         underlyingAsset = _underlyingAsset; 104:         name = _name; 105:         fundingBufferPeriod = 15 minutes; 106:  107:         syncDeps(_registry); 108:     } ```  #### Use `calldata` instead of `memory` for `string _name`  An external function passing a readonly variable should mark it as `calldata` and not `memory`  ### function openPosition()  ``` 113:     function openPosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit) 114:         override 115:         external 116:         onlyClearingHouse 117:         returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased) 118:     { 119:         require(ammState == AMMState.Active, "AMM.openPosition.not_active"); 120:         Position memory position = positions[trader]; //@audit 3 SLOADs vs 1 enough 121:         bool isNewPosition = position.size == 0 ? true : false; 122:         Side side = baseAssetQuantity > 0 ? Side.LONG : Side.SHORT; 123:         if (isNewPosition || (position.size > 0 ? Side.LONG : Side.SHORT) == side) { 124:             // realizedPnl = 0; 125:             quoteAsset = _increasePosition(trader, baseAssetQuantity, quoteAssetLimit); 126:             isPositionIncreased = true; 127:         } else { 128:             (realizedPnl, quoteAsset, isPositionIncreased) = _openReversePosition(trader, baseAssetQuantity, quoteAssetLimit); 129:         } 130:         _emitPositionChanged(trader, realizedPnl); 131:     } ```  #### Do not cache `positions[trader]` in memory  As a copy in memory of a struct makes as many SLOADs as there are slots, here a copy costs 3 SLOADs:  ``` 41:     struct Position { 42:         int256 size; 43:         uint256 openNotional; 44:         int256 lastPremiumFraction; 45:     } ```  However, only the `size` field is read twice. Therefore, only this field should get cached: `int256 _size = positions[trader].size;`  ### function liquidatePosition()  ``` 133:     function liquidatePosition(address trader) 134:         override 135:         external 136:         onlyClearingHouse 137:         returns (int realizedPnl, uint quoteAsset) 138:     { 139:         // don't need an ammState check because there should be no active positions 140:         Position memory position = positions[trader]; //@audit 3 SLOADs vs 1 enough 141:         bool isLongPosition = position.size > 0 ? true : false; 142:         // sending market orders can fk the trader. @todo put some safe guards around price of liquidations 143:         if (isLongPosition) { 144:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, 0); 145:         } else { 146:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, type(uint).max); 147:         } 148:         _emitPositionChanged(trader, realizedPnl); 149:     } ```  #### Do not cache `positions[trader]` in memory  Similar to [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory).  However, only the `size` field is read 3 times. Therefore, only this field should get cached: `int256 _size = positions[trader].size;`  ### function removeLiquidity()  ``` 133:     function liquidatePosition(address trader) 134:         override 135:         external 136:         onlyClearingHouse 137:         returns (int realizedPnl, uint quoteAsset) 138:     { 139:         // don't need an ammState check because there should be no active positions 140:         Position memory position = positions[trader]; //@audit 3 SLOADs vs 1 enough 141:         bool isLongPosition = position.size > 0 ? true : false; 142:         // sending market orders can fk the trader. @todo put some safe guards around price of liquidations 143:         if (isLongPosition) { 144:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, 0); 145:         } else { 146:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, type(uint).max); 147:         } 148:         _emitPositionChanged(trader, realizedPnl); 149:     } ```  #### Do not cache `positions[maker]` in memory  Similar to [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory). However, here, even the fields shouldn't get cached, as they are read only once:  ``` 220:         Position memory _taker = positions[maker];//@audit 3 SLOADs vs 2 enough ... 233:             _taker.size, 234:             _taker.openNotional ```  Therefore, use `220:         Position storage _taker = positions[maker];`  #### Do not cache `makers[maker]` in memory  Similarly, a copy in memory for `Maker` costs 7 SLOADs:  ``` 48:     struct Maker { 49:         uint vUSD; 50:         uint vAsset; 51:         uint dToken; 52:         int pos; // position 53:         int posAccumulator; // value of global.posAccumulator until which pos has been updated 54:         int lastPremiumFraction; 55:         int lastPremiumPerDtoken; 56:     } ```  Here, caching the first 5 fields in memory is enough.  ### function getNotionalPositionAndUnrealizedPnl()  ``` 395:     function getNotionalPositionAndUnrealizedPnl(address trader) 396:         override 397:         external 398:         view 399:         returns(uint256 notionalPosition, int256 unrealizedPnl, int256 size, uint256 openNotional) 400:     { 401:         Position memory _taker = positions[trader];//@audit 3 SLOADs vs 2 enough 402:         Maker memory _maker = makers[trader];//@audit 7 SLOADs vs 3 enough 403:  404:         (notionalPosition, size, unrealizedPnl, openNotional) = vamm.get_notional( 405:             _maker.dToken, 406:             _maker.vUSD, 407:             _maker.vAsset, 408:             _taker.size, 409:             _taker.openNotional 410:         ); 411:     } ```  #### Do not cache `positions[trader]` in memory  Here, we need `Position storage _taker = positions[trader];`  #### Do not cache `makers[trader]` in memory  Here, we need `Maker storage _maker = makers[trader];`  ### function getPendingFundingPayment()  ``` 425:         Position memory taker = positions[trader];//@audit 3 SLOADs vs 2 enough ... 434:         Maker memory maker = makers[trader];//@audit 7 SLOADs vs 5 enough ```  #### Do not cache `positions[trader]` in memory  Here, we need `Position storage _taker = positions[trader];`  #### Do not cache `makers[trader]` in memory  Here, we need `Maker storage _maker = makers[trader];`  ### function getTakerNotionalPositionAndUnrealizedPnl()  ``` 458:     function getTakerNotionalPositionAndUnrealizedPnl(address trader) override public view returns(uint takerNotionalPosition, int256 unrealizedPnl) { 459:         Position memory position = positions[trader];//@audit 3 SLOADs vs 2 enough 460:         if (position.size > 0) { 461:             takerNotionalPosition = vamm.get_dy(1, 0, position.size.toUint256()); 462:             unrealizedPnl = takerNotionalPosition.toInt256() - position.openNotional.toInt256(); 463:         } else if (position.size < 0) { 464:             takerNotionalPosition = vamm.get_dx(0, 1, (-position.size).toUint256()); 465:             unrealizedPnl = position.openNotional.toInt256() - takerNotionalPosition.toInt256(); 466:         } 467:     } ```  #### Do not cache `positions[trader]` in memory  Here, we need to cache these fields: `size` and `openNotional`  ### function _emitPositionChanged()  ``` 527:     function _emitPositionChanged(address trader, int256 realizedPnl) internal { 528:         Position memory position = positions[trader];//@audit 3 SLOADs vs 2 enough 529:         emit PositionChanged(trader, position.size, position.openNotional, realizedPnl); 530:     } ```  #### Do not cache `positions[trader]` in memory  Here, we need `Position storage _taker = positions[trader];`  ### function _openReversePosition()  ``` 584:     function _openReversePosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit) 585:         internal 586:         returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased) 587:     { 588:         Position memory position = positions[trader];//@audit 3 SLOADs vs 1 enough 589:         if (abs(position.size) >= abs(baseAssetQuantity)) { 590:             (realizedPnl, quoteAsset) = _reducePosition(trader, baseAssetQuantity, quoteAssetLimit); 591:         } else { 592:             uint closedRatio = (quoteAssetLimit * abs(position.size).toUint256()) / abs(baseAssetQuantity).toUint256(); 593:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, closedRatio); 594:  595:             // this is required because the user might pass a very less value (slippage-prone) while shorting 596:             if (quoteAssetLimit >= quoteAsset) { 597:                 quoteAssetLimit -= quoteAsset; //@audit uncheck (see L596) 598:             } 599:             quoteAsset += _increasePosition(trader, baseAssetQuantity + position.size, quoteAssetLimit); 600:             isPositionIncreased = true; 601:         } 602:     } ```  #### Do not cache `positions[trader]` in memory  Here, we need to cache the `size` field  #### Unchecked block L597  This line can't underflow due to the condition L596. Therefore, it should be wrapped in an `unchecked` block  ### function _calcTwap()  ``` 656:     function _calcTwap(uint256 _intervalInSeconds) 657:         internal 658:         view 659:         returns (uint256) 660:     { 661:         uint256 snapshotIndex = reserveSnapshots.length - 1; //@audit reserveSnapshots.length  SLOAD 1 662:         uint256 currentPrice = reserveSnapshots[snapshotIndex].lastPrice; 663:         if (_intervalInSeconds == 0) { 664:             return currentPrice; 665:         } 666:  667:         uint256 baseTimestamp = _blockTimestamp() - _intervalInSeconds; 668:         ReserveSnapshot memory currentSnapshot = reserveSnapshots[snapshotIndex];//@audit 3 SLOADs vs 1 enough 669:         // return the latest snapshot price directly 670:         // if only one snapshot or the timestamp of latest snapshot is earlier than asking for 671:         if (reserveSnapshots.length == 1 || currentSnapshot.timestamp <= baseTimestamp) {//@audit reserveSnapshots.length  SLOAD 2 ... 675:         uint256 previousTimestamp = currentSnapshot.timestamp; 676:         uint256 period = _blockTimestamp() - previousTimestamp; 677:         uint256 weightedPrice = currentPrice * period; 678:         while (true) { ... 680:             if (snapshotIndex == 0) { 681:                 return weightedPrice / period; 682:             } ... 684:             snapshotIndex = snapshotIndex - 1; //@audit uncheck (see L680-L682) 685:             currentSnapshot = reserveSnapshots[snapshotIndex]; 686:             currentPrice = reserveSnapshots[snapshotIndex].lastPrice; //@audit use currentSnapshot.lastPrice ... 689:             if (currentSnapshot.timestamp <= baseTimestamp) { ... 698:             uint256 timeFraction = previousTimestamp - currentSnapshot.timestamp; ... 701:             previousTimestamp = currentSnapshot.timestamp; ```  #### Do not cache `reserveSnapshots[snapshotIndex]` in memory  Here, we need to cache the `timestamp` field. Copying the struct in memory costs 3 SLOADs.  #### Cache `reserveSnapshots.length` in memory  This would save 1 SLOAD  #### Unchecked block L684  This line can't underflow due to the condition L680-L682. Therefore, it should be wrapped in an `unchecked` block  #### Use the cache for calculation  As we already have `currentSnapshot = reserveSnapshots[snapshotIndex];`: use it here: `currentPrice = currentSnapshot.lastPrice;`  ## File: ClearingHouse.sol  ### function _disperseLiquidationFee()  ``` 210:     function _disperseLiquidationFee(uint liquidationFee) internal { 211:         if (liquidationFee > 0) { 212:             uint toInsurance = liquidationFee / 2; 213:             marginAccount.transferOutVusd(address(insuranceFund), toInsurance); 214:             marginAccount.transferOutVusd(_msgSender(), liquidationFee - toInsurance); //@audit uncheck (see L212) 215:         } 216:     } ```  #### Unchecked block L214  This line can't underflow due to the condition L212. Therefore, it should be wrapped in an `unchecked` block  ## File: InsuranceFund.sol  ### function pricePerShare()  ``` File: InsuranceFund.sol 094:     function pricePerShare() external view returns (uint) { 095:         uint _totalSupply = totalSupply(); 096:         uint _balance = balance(); 097:         _balance -= Math.min(_balance, pendingObligation); //@audit uncheck 098:         if (_totalSupply == 0 || _balance == 0)  099:             return PRECISION; 100:         } 101:         return _balance * PRECISION /  _totalSupply; 102:     } ```  #### Unchecked block L97  This line can't underflow for obvious mathematical reasons (`_balance` substracting at most itself). Therefore, it should be wrapped in an `unchecked` block  ## File: Oracle.sol  ### function getUnderlyingTwapPrice()  #### Unchecked block L81  This line can't underflow due to L76-L79. Therefore, it should be wrapped in an `unchecked` block  ## File: Interfaces.sol  ### struct Collateral  #### Tight packing structs to save slots  While this file is out of scope, it deeply impacts MarginAccount.sol. I suggest going from:  ``` 94:     struct Collateral { 95:         IERC20 token; //@audit 20 bytes 96:         uint weight; //@audit 32 bytes 97:         uint8 decimals; //@audit 1 byte 98:     } ```  to  ``` 94:     struct Collateral { 95:         IERC20 token; //@audit 20 bytes 96:         uint8 decimals; //@audit 1 byte 97:         uint weight; //@audit 32 bytes 98:     } ```  To save 1 slot per array element in MarginAccount.sol's storage  ## File: MarginAccount.sol  ### function _getLiquidationInfo()  ``` 460:     function _getLiquidationInfo(address trader, uint idx) internal view returns (LiquidationBuffer memory buffer) { 461:         require(idx > VUSD_IDX && idx < supportedCollateral.length, "collateral not seizable"); 462:         (buffer.status, buffer.repayAble, buffer.incentivePerDollar) = isLiquidatable(trader, false); 463:         if (buffer.status == IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) { 464:             Collateral memory coll = supportedCollateral[idx];//@audit 3 SLOADs vs 2 enough 465:             buffer.priceCollateral = oracle.getUnderlyingPrice(address(coll.token)).toUint256(); 466:             buffer.decimals = coll.decimals; 467:         } 468:     } ```  #### Do not cache `supportedCollateral[idx]` in memory  Here, we need `Collateral storage coll = supportedCollateral[idx];`. Copying the struct in memory costs 3 SLOADs.  ### function _transferOutVusd()  #### Unchecked block L588  This line can't underflow due to L583. Therefore, it should be wrapped in an `unchecked` block  ## File: VUSD.sol  ### function processWithdrawals()  ``` 53:     function processWithdrawals() external { 54:         uint reserve = reserveToken.balanceOf(address(this)); 55:         require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance'); //@audit start SLOAD 1 56:         uint i = start;//@audit start SLOAD 2 57:         while (i < withdrawals.length && (i - start) <= maxWithdrawalProcesses) { //@audit uncheck whole //@audit start SLOAD 3 58:             Withdrawal memory withdrawal = withdrawals[i]; //@audit-ok 59:             if (reserve < withdrawal.amount) { 60:                 break; 61:             } 62:             reserveToken.safeTransfer(withdrawal.usr, withdrawal.amount); 63:             reserve -= withdrawal.amount;  //@audit uncheck (see L59-L61) 64:             i += 1; 65:         } 66:         start = i; 67:     } ```  #### Unchecked block L57-L65  The whole while-loop can't underflow. Therefore, it should be wrapped in an `unchecked` block  #### Cache `start` in memory  Cache `start` in memory as `initialStart` and use it L55 + L57 (compare `i` to it in the while-loop)  ## General recommendations  ### Variables  #### No need to explicitly initialize variables with default values  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Instances include:    ``` ClearingHouse.sol:122:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:130:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:170:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:194:        for (uint i = 0; i < amms.length; i++) { // liquidate all positions ClearingHouse.sol:251:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:263:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:277:        for (uint i = 0; i < amms.length; i++) { InsuranceFund.sol:52:        uint shares = 0; MarginAccount.sol:31:    uint constant VUSD_IDX = 0; MarginAccount.sol:331:        for (uint i = 0; i < idxs.length; i++) { MarginAccount.sol:521:        for (uint i = 0; i < assets.length; i++) { MarginAccount.sol:552:        for (uint i = 0; i < _collaterals.length; i++) { MarginAccountHelper.sol:13:    uint constant VUSD_IDX = 0; ```  I suggest removing explicit initializations for default values.  #### Pre-increments cost less gas compared to post-increments  ### Comparisons  #### `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  `> 0` in require statements are used in the following location(s):  ``` AMM.sol:487:        require(baseAssetQuantity > 0, "VAMM._long: baseAssetQuantity is <= 0"); AMM.sol:511:        require(baseAssetQuantity < 0, "VAMM._short: baseAssetQuantity is >= 0"); ClearingHouse.sol:51:        require(_maintenanceMargin > 0, "_maintenanceMargin < 0"); MarginAccount.sol:150:        require(amount > 0, "Add non-zero margin"); Oracle.sol:153:        require(_round > 0, "Not enough history"); ```  I suggest you change `> 0` with `!= 0` in require statements. Also, enable the Optimizer.  ### For-Loops  #### An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead:  ``` ClearingHouse.sol:122:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:130:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:170:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:194:        for (uint i = 0; i < amms.length; i++) { // liquidate all positions ClearingHouse.sol:251:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:263:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:277:        for (uint i = 0; i < amms.length; i++) { MarginAccount.sol:331:        for (uint i = 0; i < idxs.length; i++) { MarginAccount.sol:373:        for (uint i = 1 /* skip vusd */; i < assets.length; i++) { MarginAccount.sol:521:        for (uint i = 0; i < assets.length; i++) { MarginAccount.sol:552:        for (uint i = 0; i < _collaterals.length; i++) { ```  #### `++i` costs less gas compared to `i++`  `++i` costs less gas compared to `i++` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration)    `i++` increments `i` and returns the initial value of `i`. Which means:      ``` uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ``` uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:    ``` ClearingHouse.sol:122:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:130:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:170:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:194:        for (uint i = 0; i < amms.length; i++) { // liquidate all positions ClearingHouse.sol:251:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:263:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:277:        for (uint i = 0; i < amms.length; i++) { MarginAccount.sol:331:        for (uint i = 0; i < idxs.length; i++) { MarginAccount.sol:373:        for (uint i = 1 /* skip vusd */; i < assets.length; i++) { MarginAccount.sol:521:        for (uint i = 0; i < assets.length; i++) { MarginAccount.sol:552:        for (uint i = 0; i < _collaterals.length; i++) { ```  I suggest using `++i` instead of `i++` to increment the value of an uint variable.  #### Increments can be unchecked  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Instances include:    ``` ClearingHouse.sol:122:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:130:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:170:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:194:        for (uint i = 0; i < amms.length; i++) { // liquidate all positions ClearingHouse.sol:251:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:263:        for (uint i = 0; i < amms.length; i++) { ClearingHouse.sol:277:        for (uint i = 0; i < amms.length; i++) { MarginAccount.sol:331:        for (uint i = 0; i < idxs.length; i++) { MarginAccount.sol:373:        for (uint i = 1 /* skip vusd */; i < assets.length; i++) { MarginAccount.sol:521:        for (uint i = 0; i < assets.length; i++) { MarginAccount.sol:552:        for (uint i = 0; i < _collaterals.length; i++) { ```  The code would go from:      ``` for (uint256 i; i < numIterations; i++) {    // ...   }   ```  to:    ``` for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ```  The risk of overflow is inexistant for a `uint256` here.  ### Arithmetics    #### Shift Right instead of Dividing by 2  A division by 2 can be calculated by shifting one to the right.      While the `DIV` opcode uses 5 gas, the `SHR` opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.    I suggest replacing `/ 2` with `>> 1` here:    ```   ClearingHouse.sol:212:            uint toInsurance = liquidationFee / 2; ```    ### Errors  #### Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes are here:  ``` AMM.sol:487:        require(baseAssetQuantity > 0, "VAMM._long: baseAssetQuantity is <= 0"); AMM.sol:511:        require(baseAssetQuantity < 0, "VAMM._short: baseAssetQuantity is >= 0"); ClearingHouse.sol:84:            require(isAboveMinAllowableMargin(trader), "CH: Below Minimum Allowable Margin"); ClearingHouse.sol:101:        require(isAboveMinAllowableMargin(maker), "CH: Below Minimum Allowable Margin"); MarginAccount.sol:174:        require(margin[VUSD_IDX][trader] >= 0, "Cannot remove margin when vusd balance is negative"); MarginAccount.sol:354:        require(notionalPosition == 0, "Liquidate positions before settling bad debt"); MarginAccount.sol:453:        require(repay <= maxRepay, "Need to repay more to seize that much");  ```  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next.  #### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  ``` legos/Governable.sol:11:        require(msg.sender == governance, "ONLY_GOVERNANCE"); AMM.sol:84:        require(msg.sender == clearingHouse, "Only clearingHouse"); AMM.sol:89:        require(msg.sender == address(vamm), "Only VAMM"); AMM.sol:119:        require(ammState == AMMState.Active, "AMM.openPosition.not_active"); AMM.sol:186:        require(ammState != AMMState.Inactive, "AMM.addLiquidity.amm_inactive"); AMM.sol:296:        require(abs(positionSize) >= abs(baseAssetQuantity), "AMM.ONLY_REDUCE_POS"); AMM.sol:348:        require(_blockTimestamp() >= nextFundingTime, "settle funding too early"); AMM.sol:487:        require(baseAssetQuantity > 0, "VAMM._long: baseAssetQuantity is <= 0"); AMM.sol:511:        require(baseAssetQuantity < 0, "VAMM._short: baseAssetQuantity is >= 0"); AMM.sol:723:        require(ammState != _state, "AMM.setAmmState.sameState"); ClearingHouse.sol:51:        require(_maintenanceMargin > 0, "_maintenanceMargin < 0"); ClearingHouse.sol:75:        require(baseAssetQuantity != 0, "CH: baseAssetQuantity == 0"); ClearingHouse.sol:84:            require(isAboveMinAllowableMargin(trader), "CH: Below Minimum Allowable Margin"); ClearingHouse.sol:101:        require(isAboveMinAllowableMargin(maker), "CH: Below Minimum Allowable Margin"); ClearingHouse.sol:120:        require(address(trader) != address(0), 'CH: 0x0 trader Address'); ClearingHouse.sol:154:        require(!isMaker(trader), 'CH: Remove Liquidity First'); ClearingHouse.sol:164:        require( ClearingHouse.sol:189:        require(_calcMarginFraction(trader, false /* check funding payments again */) < maintenanceMargin, "Above Maintenance Margin"); InsuranceFund.sol:30:        require(msg.sender == address(marginAccount), "IF.only_margin_account"); InsuranceFund.sol:42:        require(pendingObligation == 0, "IF.deposit.pending_obligations"); InsuranceFund.sol:64:        require(pendingObligation == 0, "IF.withdraw.pending_obligations"); MarginAccount.sol:115:        require(_msgSender() == address(clearingHouse), "Only clearingHouse"); MarginAccount.sol:150:        require(amount > 0, "Add non-zero margin"); MarginAccount.sol:174:        require(margin[VUSD_IDX][trader] >= 0, "Cannot remove margin when vusd balance is negative"); MarginAccount.sol:175:        require(margin[idx][trader] >= amount.toInt256(), "Insufficient balance"); MarginAccount.sol:180:        require(clearingHouse.isAboveMinAllowableMargin(trader), "MA.removeMargin.Below_MM"); MarginAccount.sol:354:        require(notionalPosition == 0, "Liquidate positions before settling bad debt"); MarginAccount.sol:357:        require(getSpotCollateralValue(trader) < 0, "Above bad debt threshold"); MarginAccount.sol:362:        require(vusdBal < 0, "Nothing to repay"); MarginAccount.sol:438:        require(seized >= minSeizeAmount, "Not seizing enough"); MarginAccount.sol:453:        require(repay <= maxRepay, "Need to repay more to seize that much"); MarginAccount.sol:461:        require(idx > VUSD_IDX && idx < supportedCollateral.length, "collateral not seizable"); MarginAccount.sol:549:        require(_weight <= PRECISION, "weight > 1e6"); MarginAccount.sol:553:            require(address(_collaterals[i].token) != _coin, "collateral exists"); MarginAccount.sol:601:        require(_liquidationIncentive <= PRECISION / 10, "MA.syncDeps.LI_GT_10_percent"); MarginAccount.sol:603:        require(registry.marginAccount() == address(this), "Incorrect setup"); MarginAccount.sol:617:        require(_weight <= PRECISION, "weight > 1e6"); MarginAccount.sol:618:        require(idx < supportedCollateral.length, "Collateral not supported"); MinimalForwarder.sol:15:        require(success, string(abi.encodePacked("META_EXEC_FAILED: ", returnData))); Oracle.sol:48:        require(intervalInSeconds != 0, "interval can't be 0"); Oracle.sol:153:        require(_round > 0, "Not enough history"); Oracle.sol:157:        require(_addr != address(0), "empty address"); VUSD.sol:33:        require(_reserveToken != address(0), "vUSD: null _reserveToken"); VUSD.sol:55:        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance'); ```  I suggest replacing revert strings with custom errors. 
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L348   # Vulnerability details  # Impact  settleFunding calls will revert until all AMMs are ready to be updated.  # Proof of Concept  1. AMM 1 has a nextFundingTime of now. AMM 2 has a nextFundingTime in 30 minutes. AMM 1 won't be able to be updated until after AMM 2's nextFundingTime elapses.  # Mitigation You shouldn't revert at the place mentioned in the links to affected code. Just return so that the other AMMs can still get updated.  
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L377   # Vulnerability details  # Impact Assets sent from MarginAccount to InsuranceFund will be locked forever  # Proof of Concept The insurance fund doesn't have a way to transfer non-vusd out of the contract.  Assets transferred to the InsuranceFund will be locked forever.  # Mitigation Have a way for governance to sweep tokens to swap them.  
#1  ## Impact Light DoS of USDC withdrawal system  ## Proof of Concept Currently, withdrawals are queued in an array and processed sequentially in a for loop. However, a malicious user can post unlimited number of tiny (1 wei) withdrawals. Or, not-malicious user can post multiple withdrawals. User will receive funds from multiple transfers but it's possible to make only 1 transfer.  USDC transfers are actually expensive due to additional, non-standard SLOADs.  There is more...  Unused array's storage is not freed. I propose usage of mappings, so one can free the memory and get a refund.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67  ## Tools Used Manual review  ## Recommended Mitigation Steps There are 3 ways it can be rewritten:  1st, preserve FIFO order + remove unused storage - multiple calls to the same recipient  2nd, don't preserve FIFO order + remove unused storage - most efficient although unfair property  3nd (BEST), preserve FIFO order + remove unused storage + single call to the same recipient (Aggregate)  ### 1st approach ```javascript function withdraw__gas_efficient_1st(uint amount) external {     burn(amount);     pendingWithdrawals[end_index] += Withdrawal(msg.sender, aount);     end_index += 1; } function processWithdrawals__gas_efficient_1st() external {     uint reserve = reserveToken.balanceOf(address(this));     require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');     uint count = (end_index - start_index);     uint end = start_index + min(count, maxWithdrawalProcesses);     uint i;     for (i = startIndex; i < end; ++i) {         Withdrawal memory withdrawal = pendingWithdrawals[i];         if (reserve < withdrawal.amount) {             break;         }         reserveToken.safeTransfer(withdrawal.user, withdrawal.amount);         reserve -= withdrawal.amount;         delete pendingWithdrawals[i]; // save gas         delete pendingWithdrawalsIdx[withdrawal.user]; // save gas     }     start_index = i; } ```  ### 2nd approach ```javascript function withdraw__gas_efficient_2nd(uint amount) external {     burn(amount);     uint user_index = pendingWithdrawalsIndicies[msg.sender];     if (user_index == 0) {         user_index = end_index++;         pendingWithdrawalsIndicies[msg.sender] = user_index;     }     pendingWithdrawals[user_index] += Withdrawal(msg.sender, aount); } function processWithdrawals__gas_efficient_2nd() external {     uint reserve = reserveToken.balanceOf(address(this));     require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');     uint count = (end_index - start_index);     uint end = start_index + min(count, maxWithdrawalProcesses);     uint i;     for (i = startIndex; i < end; ++i) {         Withdrawal memory withdrawal = pendingWithdrawals[i];         if (reserve < withdrawal.amount) {             break;         }         reserveToken.safeTransfer(withdrawal.user, withdrawal.amount);         reserve -= withdrawal.amount;         delete pendingWithdrawals[i]; // save gas         delete pendingWithdrawalsIdx[withdrawal.user]; // save gas     }     start_index = i; } ```  ### 3rd approach ```javascript function withdraw__gas_efficient_3rd(uint amount) external {     burn(amount);     pendingWithdrawals[end_index] += Withdrawal(msg.sender, aount);     end_index += 1; } function processWithdrawals__gas_efficient_3rd() external {     uint reserve = reserveToken.balanceOf(address(this));     require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');     uint count = (end_index - start_index);     uint end = start_index + min(count, maxWithdrawalProcesses);     uint i;     // compute     mapping(address => uint) memory temp_idx;     Withdrawal[] memory temp_withdrawals     for (i = startIndex; i < end; ++i) {         Withdrawal memory withdrawal = pendingWithdrawals[i];         if (reserve < withdrawal.amount) {             break;         }         uint user_index = temp_idx[withdrawal.user];         if (user_index == 0) {             user_index = ++idx;             temp_withdrawals.push(withdrawal);         } else {             temp_withdrawals[user_index - 1].amount += withdrawal.amount;         }         reserve -= withdrawal.amount;         delete pendingWithdrawals[i]; // save gas         delete pendingWithdrawalsIdx[withdrawal.user]; // save gas     }     startIndex = i;      for (uint j = 0; j < temp_withdrawals.length; ++j) {         Withdrawal memory withdrawal = temp_withdrawals[j];         reserveToken.safeTransfer(withdrawal.user, withdrawal.amount); // save gas     } } ```  # 2  ## Impact Excessive SLOAD in a for loop.  ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L57  ## Tools Used Manual review  ## Recommended Mitigation Steps Cache array's length in memory
##GAS OPTIMAZATION  #1 Better increment for saving more gas   Using ++i for all the loops in the variable. it is known and common case that implementation by using ++i can cost less gas per iteration than i++  ##POC  it can bee seen from here : https://github.com/ethereum/solidity/issues/10695  ##Occurance  ``` main/contracts/ClearingHouse.sol#L122; main/contracts/ClearingHouse.sol#L170;  main/contracts/ClearingHouse.sol#L194; main/contracts/ClearingHouse.sol#L251; main/contracts/ClearingHouse.sol#L263; main/contracts/ClearingHouse.sol#L278; main/contracts/MarginAccount.sol#L331; main/contracts/MarginAccount.sol#L373; main/contracts/MarginAccount.sol#L521; main/contracts/MarginAccount.sol#L552; ```  ##Mitigation  `i++` change to `++i`  #2 Using `storage` instead `memory` for saving more gas  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L588 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/VUSD.sol#L58  instead of caching with `memory` it can be used by caching with `storage`, just read it directly for saving more gas  change to  `Position storage position = positions[trader];` `Withdrawal storage withdrawal = withdrawals[i];`  #3 using `&&` is more expensive gas   https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L461 using mutiple `require()` is cheaper than use `&&` if this was used many times. Because it can save gas execution cost   ##Mitigation  ``` require(idx > VUSD_IDX && idx < supportedCollateral.length, "collateral not seizable"); ```  change to   ``` require idx > VUSD_IDX; require supportedCollateral.length, "collateral not seizable"; ```  #4 Using `constructor()` instead `initialize()` or vice versa https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L35-L56 better to execute all the codes in the `initialize()` using `constructor()`. The idea is of using initialize is to run all the code inside it once in a lifetime. The current implementation of some of the contract is using both `constructor()` & `initialize()`  #5 Directly call `msg.sender` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L69 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L65 by using `msg.sender` instead of `_msgSender()` can save gas  6# The vars can set to immutable https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L22-L24 `vusd`, `insuranceFund`, & `marginAccount` set once at `initialize()`. Use immutable  7# There is no int which using `Safecast` lib https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L13 In the `ClearingHouse.sol` there is no int which is using the lib. Remove the line 13  8# Better way to call `SafeCast`lib function https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L12-L13 By removing lines which declaring that this contract is using `SafeCast` lib  and directly call it on each function, it can save execution gas cost ``` int256 marginCharge = realizedPnl - SafeCast.toInt256(fee); ``` The `SafeCast.function` is only called 3 times at `ClearingHouse.sol` so i recommend to change it thes way https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L332  9# Calling `block.timestamp` directly can save gas https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L86 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L201 instead of using `_blockTimestamp()` func to get `block.timestamp` value, using `block.timestamp`  can save gas  10# Caching `position.size` in `isLongPosition` bool is not gas efficient https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L614 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L141 By putting `position.size` inside the `if()` condition, and removing `L141` and `L614`, can save a lot of gas  11# Using != instead > https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L211 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L253 since uint cant be < 0, by using != operator to check condition can save gas  12# Custom error can save gas Using string to throw an error to user is more gas consuming. From solidity 0.8.4 we can use custom error to save gas. Custom errors are defined using the `error` statement https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L51 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L75 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L84 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L101 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L120 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L154 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L164 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L189  
https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L540  the comment: ```             makerNotional = newNotional * makerPos / totalPos //<-------- This line             if (side remains same)             reducedOpenNotional = takerOpenNotional * makerPos / takerPos             pnl = makerNotional - reducedOpenNotional  ```  and the actual code was   ```  uint totalPosition = abs(makerPosition + takerPosition).toUint256();         if (abs(takerPosition) > abs(makerPosition)) {  // taker position side remains same             uint reducedOpenNotional = takerOpenNotional * abs(makerPosition).toUint256() /              abs(takerPosition).toUint256();              uint makerNotional = newNotional * abs(makerPosition).toUint256() / totalPosition; //<------- this line             pnlToBeRealized = _getPnlToBeRealized(takerPosition, makerNotional, reducedOpenNotional); ```  the line ```  uint makerNotional = newNotional * abs(makerPosition).toUint256() / totalPosition; ``` was intended to executed outside of `if()` body(Not sure which one is the correct, the comment or the code)
already checked twice: https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/curve-v2/Swap.vy#L669 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/curve-v2/Swap.vy#L671   the check can be removed, as it's an external view function: https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/curve-v2/Swap.vy#L929
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53   # Vulnerability details  processWithdrawals can process limited amount in each call. an attacker can push to withdrawals enormous amount of withdrawals with amount = 0. in order to stop the dos attack and process the withdrawal, the governance needs to spend as much gas as the attacker. if the governance doesn't have enough money to pay for the gas, the withdrawals can't be processed.  ## Proof of Concept Alice wants to attack vusd, she spend 1millions dollars for gas to push as many withdrawals of amount = 0 as she can. if the governance wants to process the deposits after alices empty deposits, they also need to spend at least 1 million dollars for gas in order to process alice's withdrawals first. but the governance doesn't have 1 million dollar so the funds will be locked.  ## Recommended Mitigation Steps set  a minimum amount of withdrawal. e.g. 1 dollar  ```     function withdraw(uint amount) external {         require(amount >= 10 ** 6);         burn(amount);         withdrawals.push(Withdrawal(msg.sender, amount));     } ```  
GAS :  1. Title : Its cheaper using delete  Impact :  In the removeLiquidity function if the diff value is 0, its cheaper to use delete instead setting the pos, vAsset, vUSD, dToken to zero, this can save +- 3 gas  POC :  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L243-L246  Mitigation :  ```  delete __maker.pos;  delete __maker.vAsset;  delete __maker.vUSD;  delete __maker.dToken; ```  2. Title : its cheaper to save length value to a local variable  Impact : when using a loop, its cheaper to save the length value of an array to a variable, so the loop didn't have to read the storage length in each loop, but comparing with the length that was already save in the local variable. For an array that has a length 10 it can save +- 1800 gas.  POC :  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  3.  Title : its cheaper to use block.timestamp directly   Impact :  Its cheaper to use block.timestamp directly instead calling it through a _blocktimestamp() function.  POC :  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L65 
## Hubble QA Report  Unless otherwise noted, manual auditing and testing were done using Visual Studio Code and Remix. The audit was done from February 17-23, 2022 by ye0lde through code4rena.  Overall, I found the code to be clear to follow and read. I'd recommend the team improve the supporting documentation to give a better overall understanding of the protocol.  - [Findings](#findings)   - [L-1 - No validation of parameter `price` in `setStablePrice` (Oracle.sol)](#l-1---no-validation-of-parameter-price-in-setstableprice-oraclesol)   - [L-2 - Unsafe type cast in `getTwapPrice` (AMM.sol)](#l-2---unsafe-type-cast-in-gettwapprice-ammsol)   - [NC-1 - Typo in `getUnderlyingTwapPrice` (Oracle.sol)](#nc-1---typo-in-getunderlyingtwapprice-oraclesol)  ## Findings    ### L-1 - No validation of parameter `price` in `setStablePrice` (Oracle.sol)  #### Impact The `setStablePrice` function does not do any validation of the `price` parameter before setting `stablePrice[underlying] = price`. While this is a governance function, once `stablePrice[underlying]` is set to any non-zero value this overrides any aggregator calls made to access the current price by function `getUnderlyingPrice` and `getUnderlyingTwapPrice`.  `underlying` is checked but not the `price` itself.  #### Proof of Concept `setStablePrice` is here: https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L169-L172  ``` function setStablePrice(address underlying, int256 price) external onlyGovernance {     requireNonEmptyAddress(underlying);     stablePrice[underlying] = price; } ```  #### Recommended Mitigation Steps Consider adding a check for `price > 0`  ---  ### L-2 - Unsafe type cast in `getTwapPrice` (AMM.sol)  #### Impact `getTwapPrice` performs an unsafe type cast to uint128 without checking if the value actually fits into 128 bits. This typecast doesn't seem to directly lead to an exploit but safe typecasts should still be implemented for additional security.  #### Proof of Concept The type cast is here: https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L392  #### Recommended Mitigation Steps I suggest the following change:  ``` function getTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {     return (_calcTwap(_intervalInSeconds).toInt256());  } ``` ---  ### NC-1 - Typo in `getUnderlyingTwapPrice` (Oracle.sol)  #### Impact Code clarity  #### Proof of Concept The typo is here: https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L53  #### Recommended Mitigation Steps Change `form` to `from`.  --- 
### G-01: use uint256 for best gas saving  ClearingHouse.sol L#17,18,19,20 MarginAccount.sol L#47  ### G-02: uint256 instead of bool ClearingHouse.sol L#79,250  ### G-04: Prefix increments are cheaper than postfix increments. Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change ClearingHouse.sol L#122,130,170,194,251,263,278 MarginAccount.sol L#331,373,521  ### G-05: immutable instead of constant MarginAccount.sol L#34,15,  ### G-06: use calldata instead of memory  ### G-07: use memory instead of storage  ### G-03: bytes32 instead of string
# C4-001 : Adding unchecked directive can save gas  ## Impact -  Gas Optimization  Using the unchecked keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen. E.g. 'unchecked' can be applied in the following lines of code since there are require statements before to ensure the arithmetic operations would not cause an integer underflow or overflow. For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  ## Proof of Concept  1. Navigate to the following contract function and lines.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L676 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider applying unchecked arithmetic where overflow/underflow is not possible.  # C4-002 : `> 0 can be replaced with != 0 for gas optimization`  ## Impact -  Gas Optimization  `!= 0` is a cheaper operation compared to `> 0`, when dealing with uint.  ## Proof of Concept  1. Navigate to the following contract function and lines.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L141  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L123  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L199  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L271  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L78 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Use "!=0" instead of ">0" for the gas optimization.  # C4-003 : `++i is more gas efficient than i++ in loops forwarding`  ## Impact -  Gas Optimization  ++i is more gas efficient than i++ in loops forwarding.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L331  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L373  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L521  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L552  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L52  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L65  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L78  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L95  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L120  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L137  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L367 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  It is  recommend to use unchecked{++i} and change i declaration to uint256.   # C4-004 : `Cache array length in for loops can save gas`  ## Impact -  Gas Optimization  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L331  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L373  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L521  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L552 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to cache array length.  # C4-005 : Less than 256 uints are not gas efficient  ## Impact -  Gas Optimization  Lower than uint256 size storage instance variables are actually less gas efficient. E.g. using uint16 does not give any efficiency, actually, it is the opposite as EVM operates on default of 256-bit values so uint16 is more expensive in this case as it needs a conversion. It only gives improvements in cases where you can pack variables together, e.g. structs.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L302 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to review all uint types. Change them with uint256 If the integer is not necessary to present with uint16.`   # C4-006 : State variables could be declared constant  ## Impact -  Gas Optimization  State variables that never change can be declared constant. This can greatly reduce gas costs.  ## Proof of Concept  1. Navigate to the following contract variables.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L20  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L23  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L19 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add the constant keyword for state variables whose value never change.   # C4-007 : Immutable Variables  ## Impact -  Gas Optimization  'immutable' greatly reduces gas costs. There are variables that do not change so they can be marked as immutable to greatly improve the gas costs.  ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/ClearingHouse.sol#L23  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/ClearingHouse.sol#L24   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Mark variables as immutable.   # C4-008 : There is no need to assign default values to variables  ## Impact -  Gas Optimization  When a variable is declared solidity assigns the default value. In case the contract assigns the value again, it costs extra gas.  Example: uint x = 0 costs more gas than uint x without having any different functionality.  ## Proof of Concept  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L331  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L373  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L521  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L552  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L52  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L65  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L78  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L95  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L120  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L137  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L367 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  uint x = 0 costs more gas than uint x without having any different functionality.   # C4-009 : Cache external call results can save gas  ## Impact  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.   ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L25 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Cache external call for the gas optimization.    # C4-010 : Redundant Import  ## Impact - Gas Optimization  Safemath is an unnecessary import in all contracts since it is used solely for development. It can therefore be removed.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L9 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to delete redundant import.  # C4-011 : Gas Optimization on the Public Functions  ## Impact  This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract. Calling each function, we can see that the public function uses 496 gas, while the external function uses only 261.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.  Slither Detector:  external-function:  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L69  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L104  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L108  ## Tools Used  Slither  ## Recommended Mitigation Steps  1. Get Smart Contracts from the Repository. 2. Create a python virtual environment with a stable python version. 3. Install Slither Analyzer on the python VEM. 4. Run Slither against all contracts. 5. Define public functions as an external for the gas optimization.   # C4-012 : Avoid unnecessary SafeCast.toInt256() can save gas  ## Impact  Gas Improvement  ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/ClearingHouse.sol#L332  ## Tools Used  None  ## Recommended Mitigation Steps   Avoid unnecessary SafeCast.toInt256() can save gas   # C4-013 : Use of _msgSender()  ## Impact  The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.  ## Proof of Concept  _msgSender() is utilized three times where msg.sender could have been used in the following function.  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L115  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L140  ## Tools Used  None  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.
## [L1] Add check against parameters `_amount` and `_shares`:  Assessed risk: 1/10  Urgency: N/A  Codebase frequency: 2  ### [L1 - Impact]:  The `amount` that the user deposits is not checked against being `!=0`. It’s a good practice to check arbitrary inputs against being null. Although the transaction would revert anyhow(due to arithmetic error of division `/0`) you should consider adding a check against it. The same goes with parameter `_shares` in the `withdraw()` function.  ### [L1 - References]:   InsuranceFund.sol lines [62](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L62) and [39](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L39)   ### [L1 - Mitigation]:  Adding `require` statements would prevent such operations.  ```bash function deposit(uint _amount) external {      require(_amount !=0, "IF.deposit.amount_zero");  ... }  function withdraw(uint _shares) external {     require(_shares !=0, "IF.withdraw.shares_not_zero");  ... } ```
# C4-001 :  PREVENT DIV BY 0  ## Impact -  LOW  On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn’t done.  Oracle price is not checked. That will cause to revert on the several functions.   ## Proof of Concept  1. Navigate to the following contract.  ```  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L34  ```   ## Tools Used  None  ## Recommended Mitigation Steps  Recommend making sure division by 0 won’t occur by checking the variables beforehand and handling this edge case.  # C4-002 : Single-step change of governance address is extremely risky  ## Impact -  LOW   Single-step change of critical governance address and lack of zero address check is extremely risky. If a zero address or incorrect address (private key not available) is used accidentally, or maliciously changed by a compromised governance account then the entire governance of the protocol is locked forever or lost to an attacker. No governance changes can be made by authorized governance account and protocol will have to be redeployed. The reputation of the protocol will take a huge hit. There may be significant fund lock/loss as well.  Interestingly, this 2-step process is applied to the changing of Strategist address but not Governance address. Governance has more authority in the protocol because it can change the Strategist among other things. So this 2-step should definitely be applied to Governance as well.  Given the magnitude of the impact, i.e. permanent lock of all governance actions, potential lock/loss of funds, and the known/documented failures of wallet opsec, this risk is classified as medium severity.  ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L20  ## Tool  Code Review  ## Recommended Mitigation Steps  Change of the most critical protocol address i.e. governance should be timelocked and be a 2-step process: approve+claim in two different transactions, instead of a single-step change.   # C4-003 : Use of Block.timestamp  ## Impact -  Non-Critical  Block timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the Entropy Illusion for further details), locking funds for periods of time, and various state-changing conditional statements that are time-dependent. Miners have the ability to adjust timestamps slightly, which can prove to be dangerous if block timestamps are used incorrectly in smart contracts.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/HubbleBase.sol#L49 ```   ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  Block timestamps should not be used for entropy or generating random numbers—i.e., they should not be the deciding factor (either directly or through some derivation) for winning a game or changing an important state.  Time-sensitive logic is sometimes required; e.g., for unlocking contracts (time-locking), completing an ICO after a few weeks, or enforcing expiry dates. It is sometimes recommended to use block.number and an average block time to estimate times; with a 10 second block time, 1 week equates to approximately, 60480 blocks. Thus, specifying a block number at which to change a contract state can be more secure, as miners are unable to easily manipulate the block number.   # C4-004 : Front-runnable Initializers  ## Impact -  LOW  All contract **initializers** were missing access controls, allowing any user to initialize the contract. By front-running the contract deployers to initialize the contract, the incorrect parameters may be supplied, leaving the contract needing to be redeployed.   ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L93  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L20  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L38  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L121 ```  2. initialize functions does not have access control. They are vulnerable to front-running.   ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  While the code that can be run in contract constructors is limited, setting the owner in the contract's constructor to the `msg.sender` and adding the `onlyOwner` modifier to all **initializers** would be a sufficient level of access control.  # C4-005 : Incompatibility With Rebasing/Deflationary/Inflationary tokens  ## Impact -  LOW  The protocol do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L155  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L29 ```   ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  - Ensure that to check previous balance/after balance  equals to amount for any rebasing/inflation/deflation - Add support in contracts for such tokens before accepting user-supplied tokens - Consider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they don't want to lose them.  # C4-006 : Missing zero-address check in constructors and the setter functions  ## Impact -  LOW  Missing checks for zero-addresses may lead to infunctional protocol, if the variable addresses are updated incorrectly.  ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L19  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L39  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L16  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L35  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L121 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider adding zero-address checks in the discussed constructors: require(newAddr != address(0));.   # C4-007 : Missing events for governor only functions that change critical parameters  ## Impact - Non critical  The governor only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in the contracts.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L616  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L19  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L162  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L74  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L722  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L737 ```  See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)  ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all admin/privileged functions that change critical parameters.  # C4-008 : Deprecated safeApprove() function  ## Impact -  LOW  Detailed description of the impact of this finding.  Using this deprecated function can lead to unintended reverts and potentially the locking of funds. A deeper discussion on the deprecation of this function is in OZ issue #2219 (https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219). The OpenZeppelin ERC20 safeApprove() function has been deprecated, as seen in the comments of the OpenZeppelin code.  ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L24 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  As suggested by the OpenZeppelin comment, replace safeApprove() with safeIncreaseAllowance() or safeDecreaseAllowance() instead.   # C4-009 : The Contract Should Approve(0) first  ## Impact -  LOW  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).approve(address(operator), 0); IERC20(token).approve(address(operator), amount); ```  ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L24 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount.   # C4-0010 : The Contract Should Approve(0) first  ## Impact -  LOW  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).approve(address(operator), 0); IERC20(token).approve(address(operator), amount); ```   ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L24 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount.  # C4-0011 : Missing Pause Modifier On the InsuranceFunds contract  ## Impact -  Low  In case a hack occurs or an exploit is discovered, the team should be able to pause functionality until the necessary changes are made to the system.  The deposits should be paused with Pause modifier.   ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L39 ```  There is no pause mechanism has been defined.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Pause functionality on the contract would have helped secure the funds quickly.   # C4-0012 : Missing Re-entrancy Guard  ## Impact -  Non-critical  The re-entrancy guard is missing on the Eth anchor interaction. The external router interaction can cause to the re-entrancy vulnerability.   ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L39 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Follow the check effect interaction pattern or put re-entrancy guard.
# Unused import https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AdminProxy.sol#L6-7  # Unresolved todos ``` $ egrep -Rn "todo" contracts contracts/AMM.sol:142:        // sending market orders can fk the trader. @todo put some safe guards around price of liquidations contracts/AMM.sol:555:            // @todo handle case when totalPosition = 0 contracts/ClearingHouse.sol:172:            // @todo put checks on slippage contracts/MarginAccount.sol:277:            @todo consider providing some incentive from insurance fund to execute a liquidation in this scenario. ```  # Lack checks to make sure minAllowableMargin >= maintenanceMargin User might get liquidated immediated if maintenanceMargin > minAllowableMargin https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L344 ```     function setParams(         int _maintenanceMargin,         int _minAllowableMargin,         uint _tradeFee,         uint _liquidationPenality     ) external onlyGovernance {         tradeFee = _tradeFee;         liquidationPenalty = _liquidationPenality;         maintenanceMargin = _maintenanceMargin;         minAllowableMargin = _minAllowableMargin;     } ```  # Lack events on critical parameters change https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L344 ```     function setParams(         int _maintenanceMargin,         int _minAllowableMargin,         uint _tradeFee,         uint _liquidationPenality     ) external onlyGovernance {         tradeFee = _tradeFee;         liquidationPenalty = _liquidationPenality;         maintenanceMargin = _maintenanceMargin;         minAllowableMargin = _minAllowableMargin;     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L722 ```     function setAmmState(AMMState _state) external onlyGovernance {         require(ammState != _state, "AMM.setAmmState.sameState");         ammState = _state;         if (_state == AMMState.Active) {             nextFundingTime = ((_blockTimestamp() + fundingPeriod) / 1 hours) * 1 hours;         }     }      function syncDeps(address _registry) public onlyGovernance {         IRegistry registry = IRegistry(_registry);         clearingHouse = registry.clearingHouse();         oracle = IOracle(registry.oracle());     }      function setFundingBufferPeriod(uint _fundingBufferPeriod) external onlyGovernance {         fundingBufferPeriod = _fundingBufferPeriod;     } ```  # Lack liquidation events in _liquidateMaker https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L163  # Governance can set the orcale price to arbitary number `price` can be set to any number including negative numbers, which will have serious impact  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L169 ```     function setStablePrice(address underlying, int256 price) external onlyGovernance {         requireNonEmptyAddress(underlying);         stablePrice[underlying] = price;     } ```  # Lack chainlink oracle sanity check Recommened to uncoment the sanity check https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L166  # Fund frozen on Oracle malfunction If Oracle malfunction, most fund in the protocol would be frozen 
  # 1. Loops can be more efficient  ## Impact  The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas. ## Proof of Concept ``` function settleFunding() override external whenNotPaused {         for (uint i = 0; i < amms.length; i++) {             amms[i].settleFunding();         }     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L130  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L170  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L251  The same situation are in other scope contracts where loops use.  Remix ## Recommended Mitigation Steps  Remove explicit 0 initialization of for loop index variable.                    # 2. Cache array length in for loops can save gas # Vulnerability details ## Impact Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack. Caching the array length in the stack saves around 3 gas per iteration. ## Proof of Concept ``` function settleFunding() override external whenNotPaused {         for (uint i = 0; i < amms.length; i++) {             amms[i].settleFunding();         }     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L130  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L170  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L251  The same situation are in other scope contracts where loops use. ## Tools  Manual ## Recommended Mitigation Steps Caching len = amms.length and using the len instead will save gas.                    ## 3. Prefix increments are cheaper than postfix increments (i++)  ## Impact There is no risk of overflow caused by increamenting the iteration index in for loops. Increments perform overflow checks that are not necessary in this case.  ## Proof of Concept ``` function settleFunding() override external whenNotPaused {         for (uint i = 0; i < amms.length; i++) {             amms[i].settleFunding();         }     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L130  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L170  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L251  The same situation are in other scope contracts where loops use.  ## Tools  Remix  ## Recommended Mitigation Steps Surround the increment expressions with an unchecked { ... } block to avoid the default overflow checks                     # 4. Long Revert Strings   ## Impact Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met. ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L101  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L354  There are several other places throughout the codebase where the same optimization can be used.   ## Tools  https://planetcalc.com/9029/ ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.       # 5. > 0 can be replaced with != 0 for gas optimisation # Vulnerability details ## Impact != 0 is a cheaper operation compared to > 0, when dealing with uint. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L574 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L211  There are several other places throughout the codebase where the same optimization can be used.   Remix ## Recommended Mitigation Steps   # 6. Change string to byteX if possible # Vulnerability details  ## Impact In the `AMM.sol`, declaring the type bytes32 can save gas. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L28  https://medium.com/layerx/how-to-reduce-gas-cost-in-solidity-f2e5321e0395#2a78 ## Recommended Mitigation Steps  # 7. Struct layout in AMM.sol ## Impact `ReserveSnapshot` struct in `AMM.sol` can be optimized to reduce 2 storage slot ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L61-L62 ``` struct ReserveSnapshot {         uint256 lastPrice;         uint256 timestamp;         uint256 blockNumber;     } ``` `timestamp`  and `blockNumber` store block numbers, and 2^128 is be enough for a very long time. ## Tools  https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html?highlight=Structs#layout-of-state-variables-in-storage ## Recommended Mitigation Steps Change the struct as suggested above ``` struct ReserveSnapshot {         uint256 lastPrice;         uint128 timestamp;         uint128 blockNumber;     } ``` # 8. Adding unchecked directive can save gas  ## Impact For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L726 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L212 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L175-L177 ``` require(margin[idx][trader] >= amount.toInt256(), "Insufficient balance"); margin[idx][trader] -= amount.toInt256(); ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L73 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L81  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L370 ``` uint256 minNextValidFundingTime = _blockTimestamp() + fundingBufferPeriod; ```  ## Recommended Mitigation Steps Consider using 'unchecked' where it is safe to do so.  # 9. Caching variables  ## Impact Some of the variable can be cached to slightly reduce gas usage. ## Proof of Concept   `vamm`  can be cached. https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L188-L195  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L486-L501  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L510-L525  `_blockTimestamp()` can be cahed   https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L656-L704  `vusd` can be cashed  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L572-L579  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L581-L593   ## Tools  Remix ## Recommended Mitigation Steps Consider caching those variable for read and make sure write back to storage      # 10. Placement of require statements ## Impact The require statement in the  `function initialize()` can be placed earlier to reduce gas usage on revert. ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L51  ``` function initialize(         address _governance,         address _insuranceFund,         address _marginAccount,         address _vusd,         int256 _maintenanceMargin,         int256 _minAllowableMargin,         uint _tradeFee,         uint _liquidationPenalty     ) external initializer {         _setGovernace(_governance);          insuranceFund = IInsuranceFund(_insuranceFund);         marginAccount = IMarginAccount(_marginAccount);         vusd = VUSD(_vusd);          require(_maintenanceMargin > 0, "_maintenanceMargin < 0");         maintenanceMargin = _maintenanceMargin;         minAllowableMargin = _minAllowableMargin;         tradeFee = _tradeFee;         liquidationPenalty = _liquidationPenalty;     } ```  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L48  ```  function getUnderlyingTwapPrice(address underlying, uint256 intervalInSeconds)         virtual         public         view         returns (int256)     {         if (stablePrice[underlying] != 0) {             return stablePrice[underlying];         }         AggregatorV3Interface aggregator = AggregatorV3Interface(chainLinkAggregatorMap[underlying]);         requireNonEmptyAddress(address(aggregator));         require(intervalInSeconds != 0, "interval can't be 0");  ```  ## Tools  Remix ## Recommended Mitigation Steps Relocate the said require statement   # 11. Constant is being assigned its default value.  ## Impact The constant variable is being assigned its default value which is unnecessary. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L31 ``` uint constant VUSD_IDX = 0; ``` ## Recommended Mitigation Steps Remove the assignment.  # 12. Checking non-zero value can avoid an external call to save gas Checking if `_amount > 0 `before making the external call to `vusd.safeTransferFrom()` can save 2600 gas by avoiding the external call in such situations. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L51 ## Recommended Mitigation Steps Add check   # 13. function decimals() can be refactored to a constant variable ## Impact function `decimals()` just returns a constant of uint8(6). To save some gas and improve the readability this can be extracted to a constant variable and used where necessary. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/VUSD.sol#L69 ``` function decimals() public pure override returns (uint8) {         return 6;     } ``` ## Recommended Mitigation Steps  # 14. Avoid use of state variables in event emissions to save gas ## Impact Where possible, use equivalent function parameters or local variables in event emits instead of state variables to prevent expensive SLOADs. Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L205 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L381  ``` function realizePnL(address trader, int256 realizedPnl)         override    external       onlyClearingHouse    {            if (realizedPnl != 0) {             margin[VUSD_IDX][trader] += realizedPnl;             emit PnLRealized(trader, realizedPnl, _blockTimestamp());         }   ```  ## Recommended Mitigation Steps Use equivalent function parameters or local variables in event emits instead of state variables.  # 15. Unnecessary indirection to access block.timestamp value ## Impact `_blockTimestamp()` returns the block.timestamp value in `AMM` contract. This internal call only to get value of block.timestamp seems unnecessary because there isn’t any other way of getting current time on the blockchain which justifies moving this to a separate function for modularity. Adds an additional jump and other supporting bytecode of making the internal call which increase gas usage unnecessarily. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L652 ``` function _blockTimestamp() internal view virtual returns (uint256) {         return block.timestamp;     } ``` Recommended Mitigation Steps Use block.timestamp directly to save a little gas by avoiding this unnecessary indirection.  # 16. Consider making some constants as non-public to save gas ## Impact Each function part of contract's external interface is part of the function dispatch, i.e., every time a contract is called, it goes through a switch statement (a set of eq ... JUMPI blocks in EVM) matching the selector of each externally available functions with the chosen function selector (the first 4 bytes of calldata). This means that any unnecessary function that is part of contract's external interface will lead to more gas for (almost) every single function calls to the contract. There are several cases where constants were made public. This is unnecessary; the constants can simply be readfrom the verified contract, i.e., it is unnecessary to expose it with a public function. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L15-L17    # 17. Gas Optimization on the Public Function ## Impact This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract.  ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/VUSD.sol#L69  ## Recommended Mitigation Steps The function  `decimals() public` could be set external instead of public.   # 18. Use Custom Errors to save Gas ## Impact Custom errors from Solidity 0.8.4 are cheaper than revert strings. ## Proof of Concept Source: https://blog.soliditylang.org/2021/04/21/custom-errors/: Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them. Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  ## Recommended Mitigation Steps Replace revert strings with custom errors. # 19. && operator can use more gas ## Impact More expensive gas usage ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L461 ``` require(idx > VUSD_IDX && idx < supportedCollateral.length, "collateral not seizable"); ```  ## Tools Used ## Recommended Mitigation Steps Instead of using operator && on single require check  using double require check can save more gas  # 20. Use  `10 ** DECIMALS` for constant ## Impact More expensive gas usage ## Proof of Concept ``` uint8 constant DECIMALS = 6; uint constant PRECISION = 10 ** DECIMALS; ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L17  ## Recommended Mitigation Steps Change to: ``` uint constant PRECISION = 1e6; ```
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/package.json#L17 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L5 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L24   # Vulnerability details  ## Impact  While Governable.sol is out of scope, I figured this issue would still be fair game.  The solution uses: `"@openzeppelin/contracts": "4.2.0"`. This dependency has a known high severity vulnerability: https://security.snyk.io/vuln/SNYK-JS-OPENZEPPELINCONTRACTS-2320176 Which makes this contract vulnerable: ``` File: Governable.sol 05: import { Initializable } from "@openzeppelin/contracts/proxy/utils/Initializable.sol"; ... 24: contract Governable is VanillaGovernable, Initializable {} ```  This contract is inherited at multiple places: ``` contracts/AMM.sol:   11: contract AMM is IAMM, Governable {  contracts/InsuranceFund.sol:   13: contract InsuranceFund is VanillaGovernable, ERC20Upgradeable {  contracts/Oracle.sol:   11: contract Oracle is Governable {  contracts/legos/HubbleBase.sol:   15: contract HubbleBase is Governable, Pausable, ERC2771Context {  contracts/ClearingHouse.sol:   11: contract ClearingHouse is IClearingHouse, HubbleBase {  contracts/MarginAccount.sol:   25: contract MarginAccount is IMarginAccount, HubbleBase { ```   ìnitializer()` is used here: ``` contracts/AMM.sol:   99:     ) external initializer {  contracts/ClearingHouse.sol:   44:     ) external initializer {  contracts/MarginAccount.sol:   124:     ) external initializer {  contracts/Oracle.sol:   20:     function initialize(address _governance) external initializer {  ```  ## Recommended Mitigation Steps Upgrade `@openzeppelin/contracts` to version 4.4.1 or higher.  
Hubble contest Gas Optimization   1 use initial value to save gas for uint.      https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L52  uint shares;   2 use cache for array length to save gas.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277      3 Delete unused variable. It seems that the following variable will be not used in this construct and other contracts. If it is not used, you can delete it to save gas.   https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L22      4 Avoid extra mstore.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L121 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L141 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L614   isNewPosition and isLongPosition are used only one time in   https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L123 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L143   https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L616 You can use position.size == 0 and position.size > 0 directly there to save gas.  if (position.size == 0 || (position.size > 0 ? Side.LONG : Side.SHORT) == side) { if (position.size > 0) {  5 Use msg.sender instead of _msgSender() to save gas.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L65 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L69 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L98 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L113 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L214     6 Delete unused import statements in AMM.sol  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L5  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L9 
Hubble contest  1 Change order of the modifier of functions.  According to solidity doc order of the modifier must be             1 Visibility 2 Mutability 3Virtual 4 Override 5 Custom modifiers In functions, the order is a little different. For example,  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L64 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L242  and so on.    2 missing input validation.  Input _governance is not checked in initialize whether it is empty or not. Nobody can have control as governance if it will be set with an empty address.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L34-L37     3 Use naming convention for constant variables  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L15-L16  uint256 public constant SPOT_PRICE_TWAP_INTERVAL = 1 hours; Uint256 public constant FUNDING_PERIOD = 1 hours;     4 Delete unused return value variable name in getCloseQuote.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L449     5 Input validation must be checked.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L148-L151  add   require(isMaker(trader), 'describe something');     6 Delete unnecessary variables.  In getTotalNotionalPositionAndUnrealizedPnl return values are defined, so following variables must be unnecessary.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L275-L276 
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67   # Vulnerability details  ## Impact DoS of USDC withdrawal system  ## Proof of Concept Currently, withdrawals are queued in an array and processed sequentially in a for loop. However, a `safeTransfer()` to USDC blacklisted user will fail. It will also brick the withdrawal system because the blacklisted user is never cleared.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67  ## Tools Used Manual review  ## Recommended Mitigation Steps Possible solutions: 1st solution: Implement 2-step withdrawals:     - In a for loop, increase the user's amount that can be safely withdrawn.     - A user himself withdraws his balance  2st solution: Skip blacklisted users in a processWithdrawals loop  
# QA Report  # Low Findings  ## L01: Add modifiers to ensure that dependencies are synced  ### Description  The `syncDeps` function exists in the AMM, InsuranceFund and MarginAccount contracts as a helper function to sync the shared contract addresses between the Registry contract. It does not however ensure that all contracts are actually in synced i.e. if the Registry contract changes, there are no checks to ensure that the addresses are still in sync.  ## L02: Adhere to the Check Effect Interactions pattern best practice  ### Line References  [https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L62-L64](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L62-L64)  ### Description  Update internal state before transferring tokens out.  # Non-Critical Findings  ## NC01: Avoid rebase tokens  ### Line References  [https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L548](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L548)  ### Description  Be mindful when adding collateral as some token implementations e.g. rebase tokens are not handled by the smart contract.  ## NC02: Incorrect comment for `_getLiquidationInfo`  ### Line References  [https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L458](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L458)  ### Description  `_getLiquidationInfo` doesn’t actually revert. It is the parent liquidation function that reverts if it receives a `LiquidationStatus` that is not `IS_LIQUIDATABLE`.  ## NC03: Add a rescue token / ETH function  ### Description  In the event ETH / tokens are mistakenly sent to the contracts, it is possible to withdraw them through a `rescueToken` or `rescueETH` function. This function can only be called by governance.
### Using memory copies of storage variables when repeated access is required uses less gas `credit` should be copied ```solidity         if (credit > 0) {             uint toBurn = Math.min(vusd.balanceOf(address(this)), credit);             credit -= toBurn; ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L574-L576   ### Functions not called by the contract itself should be `external` rather than `public` ```solidity function getUnderlyingTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {         ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L387  ```solidity function liquidateMaker(address maker) override public whenNotPaused {          ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L148  ```solidity function liquidateTaker(address trader) override public whenNotPaused {          ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L153  ```solidity function syncDeps(IRegistry _registry) public onlyGovernance {           ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L116  ```solidity function getNormalizedMargin(address trader) override public view returns(int256 weighted) {        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L509  ```solidity function syncDeps(address _registry, uint _liquidationIncentive) public onlyGovernance {         ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L599   ### `require()` strings longer than 32 bytes cost extra gas ```solidity require(baseAssetQuantity > 0, "VAMM._longbaseAssetQuantity is <= 0");                  ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L487  ```solidity require(baseAssetQuantity < 0, "VAMM._shortbaseAssetQuantity is >= 0");                  ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L511  ```solidity require(margin[VUSD_IDX][trader] >= 0, "Cannot remove margin when vusd balance is negative");              ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L174  ```solidity require(notionalPosition == 0, "Liquidate positions before settling bad debt");                ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L354  ```solidity require(repay <= maxRepay, "Need to repay more to seize that much");              ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L453  ```solidity require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this timeNot enough balance');              ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L55  ```solidity require(isAboveMinAllowableMargin(trader), "CHBelow Minimum Allowable Margin");                    ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L84  ```solidity require(isAboveMinAllowableMargin(maker), "CHBelow Minimum Allowable Margin");                    ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L101  ```solidity require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "HubbleErc20.allowTransfers.noAuth");                      ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/ERC20Mintable.sol#L32  ```solidity require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "HubbleErc20.allowTransfers.noAuth");                      ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/ERC20Mintable.sol#L60  ```solidity require(prices[underlying] != 0, "underlying price has not been set as yet");              ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/TestOracle.sol#L20  ```solidity require(twapPrices[underlying] != 0, "underlying twap price has not been set as yet");             ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/TestOracle.sol#L33   ### Using `> 0` costs more gas than `!= 0` when used in on uints in a `require()` statement ```solidity require(amount > 0, "Add non-zero margin");           ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L150  ```solidity require(_round > 0, "Not enough history");           ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L153   ### Splitting `require()` statements that use `&&` saves gas See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) for an example ```solidity require(idx > VUSD_IDX && idx < supportedCollateral.length, "collateral not seizable");       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol   ### It costs more gas to initialize variables to zero than to let the default of zero be applied ```solidity uint constant VUSD_IDX = 0;            ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L31  ```solidity for (uint i = 0; i < idxs.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L331  ```solidity for (uint i = 0; i < assets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L521  ```solidity for (uint i = 0; i < _collaterals.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L552  ```solidity uint constant VUSD_IDX = 0;            ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccountHelper.sol#L13  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170  ```solidity for (uint i = 0; i < amms.length; i++) { // liquidate all positions   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L251  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277  ```solidity uint shares = 0;             ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L52  ```solidity uint constant VUSD_IDX = 0;            ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L15  ```solidity for (uint i = 0; i < len; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L52  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L65  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L78  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L95  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L120  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L137  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L9  ```solidity uint256 total = 0;             ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L17  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L18  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L21  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L27  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L32  ```solidity for (uint i = 0; i < numTraders; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L43  ```solidity for (uint j = 0; j < l; j++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L45  ```solidity for (uint i = 0; i < targets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Executor.sol#L19  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L25  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L31  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L37   ### `<array>.length` should not be looked up in every loop of a for-loop Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length ```solidity for (uint i = 0; i < idxs.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L331  ```solidity for (uint i = 1 /* skip vusd */; i < assets.length; i++) {   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L373  ```solidity for (uint i = 0; i < assets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L521  ```solidity for (uint i = 0; i < _collaterals.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L552  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170  ```solidity for (uint i = 0; i < amms.length; i++) { // liquidate all positions   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L251  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L65  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L78  ```solidity for (uint i = 1; i < length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L367  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L9  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L18  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L21  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L27  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L32  ```solidity for (uint i = 0; i < targets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Executor.sol#L19  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L25  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L31  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L37   ### `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in for- and while-loops ```solidity for (uint i = 0; i < idxs.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L331  ```solidity for (uint i = 1 /* skip vusd */; i < assets.length; i++) {   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L373  ```solidity for (uint i = 0; i < assets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L521  ```solidity for (uint i = 0; i < _collaterals.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L552  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170  ```solidity for (uint i = 0; i < amms.length; i++) { // liquidate all positions   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L251  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277  ```solidity for (uint i = 0; i < len; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L52  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L65  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L78  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L95  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L120  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L137  ```solidity for (uint i = 1; i < length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L367  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L9  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L18  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L21  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L27  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L32  ```solidity for (uint i = 0; i < numTraders; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L43  ```solidity for (uint j = 0; j < l; j++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L45  ```solidity for (uint i = 0; i < targets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Executor.sol#L19  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L25  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L31  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L37   ### `++i` costs less gas than `++i`, especially when it's used in for-loops (`--i`/`i--` too) ```solidity for (uint i = 0; i < idxs.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L331  ```solidity for (uint i = 1 /* skip vusd */; i < assets.length; i++) {   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L373  ```solidity for (uint i = 0; i < assets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L521  ```solidity for (uint i = 0; i < _collaterals.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L552  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170  ```solidity for (uint i = 0; i < amms.length; i++) { // liquidate all positions   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L251  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277  ```solidity for (uint i = 0; i < len; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L52  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L65  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L78  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L95  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L120  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L137  ```solidity for (uint i = 1; i < length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L367  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L9  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L18  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L21  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L27  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L32  ```solidity for (uint i = 0; i < numTraders; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L43  ```solidity for (uint j = 0; j < l; j++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L45  ```solidity for (uint i = 0; i < targets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Executor.sol#L19  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L25  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L31  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L37 
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L71-L75 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L62-L69   # Vulnerability details  ## Impact  A user is able to front-run the call to `seizeBadDebt()` in `InsuranceFund.sol` to avoid paying the insurance costs.  `seizeBadDebt()` is called by `MarginAccount.settleBadDebt()` which is a public function. When this functions is called the transaction will appear in the mem pool.  A user may then call `InsuranceFund.withdraw()` to withdraw all of their shares. If they do this with a higher gas fee it will likely be processed before the `settleBadDebt()` transaction. In this way they will avoid incurring any cost from the assets being seized.  The impact is that users may gain their share of the insurance funding payments with minimal risk (minimal as there is a change the front-run will not succeed) of having to repay these costs.  ## Proof of Concept  ```     function withdraw(uint _shares) external {         settlePendingObligation();         require(pendingObligation == 0, "IF.withdraw.pending_obligations");         uint amount = balance() * _shares / totalSupply();         _burn(msg.sender, _shares);         vusd.safeTransfer(msg.sender, amount);         emit FundsWithdrawn(msg.sender, amount, block.timestamp);     } ```  ```     function seizeBadDebt(uint amount) external onlyMarginAccount {         pendingObligation += amount;         emit BadDebtAccumulated(amount, block.timestamp);         settlePendingObligation();     } ```  ## Recommended Mitigation Steps  Consider making the withdrawals a two step process. The first step requests a withdrawal and marks the time. The second request processes the withdrawal but requires a period of time to elapse since the first step.  To avoid having users constantly having pending withdrawal, each withdrawal should have an expiry time and also a recharge time. The if the second step is not called within expiry amount of time it should be considered invalid. The first step must not be able to be called until recharge time has passed.  Another solution involves a design change where the insurance fund is slowly filled up over time without external deposits. However, this has the disadvantage that bad debts received early in the protocols life time may not have sufficient insurance capital to cover them.  
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L93-L108 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L730-L734 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L10-L13   # Vulnerability details  ## Impact  The contact `AMM.sol` cannot be initialize unless it is called from the `_governance` address.  This prevents the use of a deployer account and requires the governance to be able to deploy proxy contracts and encode the required arguements. If this is not feasible then the contract cannot be deployed.  ## Proof of Concept  `initialize()` calls `_setGovernace(_governance);` which will store the governance address.   Following this it will call `syncDeps(_registry);` which has `onlyGovernance` modifier.  Thus, if the `msg.sender` of `initialize()` is not the same as the parameter `_governance` then the initialisation will revert.   ```solidity     function initialize(         address _registry,         address _underlyingAsset,         string memory _name,         address _vamm,         address _governance     ) external initializer {         _setGovernace(_governance);          vamm = IVAMM(_vamm);         underlyingAsset = _underlyingAsset;         name = _name;         fundingBufferPeriod = 15 minutes;          syncDeps(_registry);     } ```  ## Recommended Mitigation Steps  Consider adding the steps manually to `initialize()`. i.e.  ```solidity     function initialize(         address _registry,         address _underlyingAsset,         string memory _name,         address _vamm,         address _governance     ) external initializer {         _setGovernace(_governance);          vamm = IVAMM(_vamm);         underlyingAsset = _underlyingAsset;         name = _name;         fundingBufferPeriod = 15 minutes;          IRegistry registry = IRegistry(_registry);         clearingHouse = registry.clearingHouse();         oracle = IOracle(registry.oracle()); } ```  
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L339-L342 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L269-L282   # Vulnerability details  ## Impact  `ClearingHouse.sol` allows the Governance protocol to whitelist `AMM.sol` contracts. These contracts allow users to earn profits based on the price of a base asset against a quote asset.  It is possible to add the same `AMM` twice in the function `whitelistAmm()`. The impact is that unrealized profits will be counted multiple times. As a result the liquidation calculations will be incorrect, potentially allowing users to trade while insolvent or incorrectly liquidating solvent users.  Note `whitelistAmm()` may only be called by Governance.  ## Proof of Concept  The function `getTotalNotionalPositionAndUnrealizedPnl()` will iterate over all `amms` summing the `unrealizedPnl`  and `notinoalPosition`, thus if an `amm` is repeated the `unrealizedPnl` and `notionalPosition` of that asset will be counted multiple times.  This is used in `_calcMarginFraction()` which calculates a users margin as a fraction of the total position. The margin fraction is used to determine if a user is liquitable or is allowed to open new positions.   ## Recommended Mitigation Steps  Consider ensuring the `AMM` does not already exist in the list when adding a new `AMM`.  ```     function whitelistAmm(address _amm) external onlyGovernance {         for (uint256 i; i < amm.length; i++) {             require(amm[i] != IAMM(_amm), "AMM already whitelisted");         }         emit MarketAdded(amms.length, _amm);         amms.push(IAMM(_amm));     } ```  
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L24-L35   # Vulnerability details  ## Impact  If the price feed is manipulated in any way or there is any malfunction based volatility on the market, a malicious user can use this to liquidate a healthy position.  An attacker can setup a monitoring of the used Oracle feed and act on observing a price outbreak (for example, zero price, which is usually a subject to filtration), liquidating the trader position which is perfectly healthy otherwise, obtaining the collateral with a substantial discount at the expense of the trader.  The same is for a flash crash kind of scenario, i.e. a price outbreak of any nature will allow for non-market liquidation by an attacker, who has the incentives to setup such a monitoring and act on such an outbreak, knowing that it will not be smoothed or filtered out, allowing a liquidation at a non-market price that happen to be printed in the Oracle feed  ## Proof of Concept  Oracle.getUnderlyingPrice just passes on the latest Oracle answer, not checking it anyhow:  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L24-L35  It is then used in liquidation triggers providing isLiquidatable and _getLiquidationInfo functions:  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L249  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L465  ## Recommended Mitigation Steps  Add a non-zero Oracle price check, possibly add an additional Oracle feed information usage to control that the price is fresh. Please consult the Chainlink for that as OCR introduction might have changed the state of the art approach (i.e. whether and how to use latestRoundData returned data):  https://docs.chain.link/docs/off-chain-reporting/  Regarding any price spikes it is straightforward to construct a mitigation mechanics for such cases, so the system will be affected by sustainable price movements only.  As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.  One of the approaches is to track both current and TWAP prices, and condition all state changing actions, including liquidations, on the current price being within a threshold of the TWAP one. If the liquidation margin level is conservative enough and TWAP window is small enough this is safe for the overall stability of the system, while providing substantial mitigation mechanics by allowing state changes on the locally calm market only.  Another approach is to introduce time delay between liquidation request and actual liquidation. Again, conservative enough margin level plus small enough delay keeps the system safe, while requiring that market conditions allow for liquidation both at request time and at execution time provides ample filtration against price feed outbreaks   
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L34   # Vulnerability details  ## Impact The `Oracle.getUnderlyingPrice` function divides the chainlink price by `100`. It probably assumes that the answer for the underlying is in 8 decimals but then wants to reduce it for 6 decimals to match USDC.  However, arbitrary `underlying` tokens are used and the chainlink oracles can have different decimals.  ## Recommended Mitigation Steps While most USD price feeds use 8 decimals, it's better to take the on-chain reported decimals into account by doing `AggregatorV3Interface(chainLinkAggregatorMap[underlying]).decimals()`, see [Chainlink docs](https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination). The price should then be scaled down to 6 decimals.   
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L344-L354 https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L15-L21   # Vulnerability details  When fees/margin or governance are involved it's important to emit events for off-chain monitors/tools to be able to react if necessary.  ## Impact Automated tools especially need all relevant ancillary data to be emitted in order to efficiently react to it. An automated bot trading with the hubble exchange will not be able to see changes to fee/margin changes in real time, and may submit orders which cause it to miscalculate P&L, causing it to lose capital. This is especially true because the contracts do not use timelocks for changes. See [these](https://github.com/code-423n4/2021-06-tracer-findings/issues/64) [examples](https://github.com/code-423n4/2021-09-swivel-findings/issues/101) [where](https://blog.openzeppelin.com/uma-audit-phase-4/) [similar](https://blog.openzeppelin.com/audius-contracts-audit/#high) findings have been flagged as medium/high-severity issues.  ## Proof of Concept ```solidity     function setParams(         int _maintenanceMargin,         int _minAllowableMargin,         uint _tradeFee,         uint _liquidationPenality     ) external onlyGovernance {         tradeFee = _tradeFee;         liquidationPenalty = _liquidationPenality;         maintenanceMargin = _maintenanceMargin;         minAllowableMargin = _minAllowableMargin;     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L344-L354  ```solidity     function setGovernace(address _governance) external onlyGovernance {         _setGovernace(_governance);     }      function _setGovernace(address _governance) internal {         governance = _governance;     } ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L15-L21  The `onlyGovernance` modifier does not emit events ```solidity     address public governance;      modifier onlyGovernance() {         require(msg.sender == governance, "ONLY_GOVERNANCE");         _;     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/legos/Governable.sol#L8-L13  The provided deployment script [only uses a signer](https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/scripts/deploy.js#L18) rather than a contract as the governance address. Furthermore, the live environment deployed on testnet has a [deployed](https://testnet.snowtrace.io/address/0x089f4f3b4aedc41d6ffd4908f4ff32e6a915996b) `InsuranceFund` which uses the `onlyGovernance` modifier... ```solidity     function syncDeps(IRegistry _registry) public onlyGovernance {         vusd = IERC20(_registry.vusd());         marginAccount = _registry.marginAccount();     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L116-L119  ...and the only transaction interacting with this function appears [here](https://testnet.snowtrace.io/tx/0x31d395e69753469c86a7ed9ab817f15c6a6362ebe31397373daabc83f24d567c) and is called by an [address](https://testnet.snowtrace.io/address/0x835ce0760387bc894e91039a88a00b6a69e65d94), not a contract. There are no other transactions to the insurance fund to change the governance address, so it's clear that the testnet does not use an emitting governor either.  ## Tools Used Code inspection Hardhat snowtrace.io  ## Recommended Mitigation Steps Emit events for these changes   
## Withdrawals can stuck  1. Consider processWithdrawals function at VUSD.sol#L53 2. Assume contract has balance of 100 3. Withdrawal request are 101,10,20,30 4. processWithdrawals function is called 5. Function fail since contract does not have 101 balance 6. But due to this the remaining transaction also get blocked 10,20,30 for which contract had sufficient balance  Recommendation: If contract does not have balance for particular withdrawal instance, keep that in pending object and try to complete the remaining ones  ## Withdraw timelock missing  1. The withdraw function at VUSD.sol#L48 is not placing any timelock which means user can call withdraw function frequently and push them into withdrawals object. This can delay other user withdrawal which are placed in long queue back and since processWithdrawals can only process maxWithdrawalProcesses at one run, other user withdrawal may delay  Recommendation: There should be a timelock after which withdraw can be called again otherwise this can be called repeatedly for small amounts If user has requested withdraw then he should only be able to call this function again after x timestamp  ## Shares can give lower value  1. Consider withdraw function at InsuranceFund.sol#L62  2. if some big bad debt comes (seizeBadDebt at MarginAccount.sol#L368) then settlePendingObligation function which is called at withdraw function will consume most contract balance. This will reduce amount in balance()  3. Since withdraw amount is directly proportional to balance (uint amount = balance() * _shares / totalSupply();) so same shares will give less amount  ## Missing Oracle price checks  1. In getLatestRoundData function at Oracle.sol#L115, there is no check to see if returned price of _aggregator.latestRoundData() is not stale. More details at https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  Recommendation: Modify the function as below:  ``` (uint80 round, int256 latestPrice, , uint256 latestTimestamp, uint80 answeredInRound) = _aggregator.latestRoundData(); require(feedPrice > 0, "Chainlink price <= 0");  require(answeredInRound >= round, "Stale price"); require(latestTimestamp != 0, "Round not complete"); ```  ## Input validation missing  1. It was observed that price can be set to 0 in setStablePrice function at Oracle.sol#L169. This is incorrect since the contract checks stablePrice[underlying] != 0 in other functions like getUnderlyingPrice.   Recommendation: Add below check  ``` function setStablePrice(address underlying, int256 price) external onlyGovernance { require(price!=0,"Invalid price")         requireNonEmptyAddress(underlying);         stablePrice[underlying] = price;     } ```  ## Incorrect condition can give incorrect price  1. The getUnderlyingTwapPrice function at Oracle.sol#L67 is returning latestPrice when latestTimestamp < baseTimestamp.   2. Else it would goto previous rounds  3. This is incorrect. This function should return latestPrice when latestTimestamp = baseTimestamp  Recommendation: Modify the check like below  ``` if (latestTimestamp <= baseTimestamp || round == 0) {             return formatPrice(latestPrice);         } ```  ## Zero address checks are missing   1. For all address arguments at constructor of Registry.sol#L12. Add below require  ``` require(_oracle!=address(0), "Invalid address"); require(_clearingHouse!=address(0), "Invalid address"); require(_insuranceFund!=address(0), "Invalid address"); require(_marginAccount!=address(0), "Invalid address"); require(_vusd!=address(0), "Invalid address"); ```  2. Initialize function at AMM.sol#L93, add below require  ``` require(_registry!=address(0), "Invalid address"); require(_underlyingAsset!=address(0), "Invalid address"); require(_vamm!=address(0), "Invalid address"); ```  3.  Initialize function at ClearingHouse.sol#L35, add below require  ``` require(_insuranceFund!=address(0), "Invalid address"); require(_marginAccount!=address(0), "Invalid address"); require(_vusd!=address(0), "Invalid address"); ```  4. In getUnderlyingPrice function, check aggregator is non empty address  ``` function getUnderlyingPrice(address underlying)         virtual         external         view         returns(int256 answer)     { AggregatorV3Interface aggregator = AggregatorV3Interface(chainLinkAggregatorMap[underlying]); requireNonEmptyAddress(address(aggregator));         ...     } ```
1. In processWithdrawals function at VUSD.sol#L64, modify i+=1 to ++i  2. In processWithdrawals function at VUSD.sol#L63, use unchecked at reserve -= withdrawal.amount; since we already know that reserve > withdrawal.amount  3. In withdraw function at VUSD.sol#L48, add a check require(amount!=0, "Invalid amount");  4. In mintWithReserve function at VUSD.sol#L43, add below require  ``` require(amount!=0, "Invalid amount"); require(to!=address(0), "Invalid address"); ```  5. getRoundData function at Oracle.sol#L124 is not required. Simply change the if(latestPrice < 0) to while(latestPrice < 0) at Oracle.sol#L117 which will eliminate the need of getRoundData function  ``` function getLatestRoundData(AggregatorV3Interface _aggregator)         internal         view         returns (             uint80,             uint256 finalPrice,             uint256         )     {         (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.latestRoundData();         finalPrice = uint256(latestPrice);         while (latestPrice < 0) {             requireEnoughHistory(round);             (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);         }         return (round, finalPrice, latestTimestamp);     } ```  6. In deposit function at InsuranceFund.sol#L39, add a condition require(amount!=0, "Invalid amount")  7. In withdraw function at InsuranceFund.sol#L62, add a check require( _shares!=0,"Invalid shares");  8. In liquidate function at ClearingHouse.sol#L140, updatePositions function is not required since this is already called in _liquidateMaker and _liquidateTaker function  9. In addMarginFor function at MarginAccount.sol#L149, add new check   ``` require(idx >= supportedCollateral.length,"Invalid index"); ```  10. In removeMargin function at MarginAccount.sol#L177, margin[idx][trader] -= amount.toInt256(); can be unchecked since contract has already checked margin[idx][trader] >= amount.toInt256()  11. In removeMargin function at MarginAccount.sol#L168, add a check require(amount!=0,"Invalid amount");  12. In settleBadDebt function at MarginAccount.sol#L362, modify require(vusdBal < 0, "Nothing to repay"); to require(vusdBal <= 0, "Nothing to repay"); since if vusdBal is 0 then also there is nothing to repay  13. In weightedAndSpotCollateral function at MarginAccount.sol#L524 add a check to see margin[i][trader]==0 as shown below  ``` function weightedAndSpotCollateral(address trader)         public         view         returns (int256 weighted, int256 spot)     {         ...          for (uint i = 0; i < assets.length; i++) {             _collateral = assets[i];   if(margin[i][trader]==0){continue}             int numerator = margin[i][trader] * oracle.getUnderlyingPrice(address(assets[i].token));             ...         }     } ```  14. In liquidateFlexible function at MarginAccount.sol#L328, before entering loop check if trader can be liquidated  ``` function liquidateFlexible(address trader, uint maxRepay, uint[] calldata idxs) external whenNotPaused {         clearingHouse.updatePositions(trader); // credits/debits funding (buffer.status, buffer.repayAble, buffer.incentivePerDollar) = isLiquidatable(trader, false); if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {return}  for (uint i = 0; i < idxs.length; i++){         ...     } ```
# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L11   # Vulnerability details  ## Impact The contract use two governance model, one looks hidden.  ## Proof of Concept The VUSD contract uses `VanillaGovernable` but inherits from `ERC20PresetMinterPauserUpgradeable` and this contract uses roles to use some administrative methods like `pause` or `mint`.  This two-governance model does not seem necessary and can hide or raise suspicion about a rogue pool, thus damaging the user's trust.  ## Recommended Mitigation Steps Unify governance in only one, VanillaGovernable or role based.  
 Title: Not verified input Severity: Low Risk       external / public functions parameters should be validated to make sure the address is not 0.     Otherwise if not given the right input it can mistakenly lead to loss of user funds.                       AMM.sol.getPendingFundingPayment trader         Oracle.sol.requireNonEmptyAddress _addr         ClearingHouse.sol.whitelistAmm _amm     Title: Named return issue Severity: Low Risk  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           Oracle.sol, getUnderlyingPrice         AMM.sol, updatePosition         MarginAccount.sol, isLiquidatable         Oracle.sol, getLatestRoundData         AMM.sol, getCloseQuote    Title: Mult instead div in compares Severity: Low Risk       To improve algorithm precision instead using division in comparison use multiplication in the following scenario:                          Instead a < b / c use a * c < b.               In all of the big and trusted contracts this rule is maintained.              MarginAccount.sol, 601, require(_liquidationIncentive <= PRECISION / 10, "MA.syncDeps.LI_GT_10_percent");    Title: In the following public update functions no value is returned Severity: Low Risk  In the following functions no value is returned, due to which by default value of return will be 0.  We assumed that after the update you return the latest new value.  (similar issue here: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/85).           ClearingHouse.sol, updatePositions    Title: Anyone can withdraw others Severity: Low Risk   Anyone can withdraw users shares. Although we think that they are sent to the right address, it is still     1) not the desired behavior     2) can be dangerous if the receiver is a smart contract     3) the receiver may not know someone withdraw him               InsuranceFund.withdraw         VUSD.setMaxWithdrawalProcesses         VUSD.withdraw         VUSD.processWithdrawals    Title: Does not validate the input fee parameter Severity: Low Risk   Some fee parameters of functions are not checked for invalid values. Validate the parameters:                           ClearingHouse._disperseLiquidationFee (liquidationFee)         ClearingHouse.setParams (_tradeFee)         ClearingHouse.initialize (_tradeFee)    Title: Duplicates in array Severity: Low Risk           You allow in some arrays to have duplicates. Sometimes you assumes there are no duplicates in the array.          ClearingHouse.whitelistAmm pushed (_amm)   {         emit MarketAdded(amms.length, _amm);         amms.push(IAMM(_amm));     } VUSD.withdraw pushed (amount)   {         burn(amount);         withdrawals.push(Withdrawal(msg.sender, amount));     }    Title: Init frontrun Severity: Low Risk  Most contracts use an init pattern (instead of a constructor) to initialize contract parameters. Unless these are enforced to be atomic with contact deployment via deployment script or factory contracts, they are susceptible to front-running race conditions where an attacker/griefer can front-run (cannot access control because admin roles are not initialized) to initially with their own (malicious) parameters upon detecting (if an event is emitted) which the contract deployer has to redeploy wasting gas and risking other transactions from interacting with the attacker-initialized contract.  Many init functions do not have an explicit event emission which makes monitoring such scenarios harder. All of them have re-init checks; while many are explicit some (those in auction contracts) have implicit reinit checks in initAccessControls() which is better if converted to an explicit check in the main init function itself. (details credit to: https://github.com/code-423n4/2021-09-sushimiso-findings/issues/64) The vulnerable initialization functions in the codebase are:           Oracle.sol, initialize, 20         ClearingHouse.sol, initialize, 35         MarginAccount.sol, initialize, 121         AMM.sol, initialize, 93    Title: Open TODOs Severity: Low Risk  Open TODOs can hint at programming or architectural errors that still need to be fixed.  These files has open TODOs:  Open TODO in AMM.sol line 554 :             // @todo handle case when totalPosition = 0  Open TODO in ClearingHouse.sol line 171 :             // @todo put checks on slippage  Open TODO in MarginAccount.sol line 276 :             @todo consider providing some incentive from insurance fund to execute a liquidation in this scenario.  Open TODO in AMM.sol line 141 :         // sending market orders can fk the trader. @todo put some safe guards around price of liquidations     Title: Unbounded loop on array that can only grow can lead to DoS Severity: Low/Med Risk  A malicious attacker that is also a protocol owner can push unlimitedly to an array, that some function loop over this array. If increasing the array size enough, calling the function that does a loop over the array will always revert since there is a gas limit. This is a Med Risk issue since it can lead to DoS with a reasonable chance of having untrusted owner or even an owner that did a mistake in good faith.          ClearingHouse.sol (L250): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L169): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L276): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L129): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L193): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L262): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L121): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled    Title: Div by 0 Severity: Medium Risk   Division by 0 can lead to accidentally revert, (An example of a similar issue - https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/84)          MarginAccount.sol (L432) buffer might be 0)         AMM.sol (L251) _maker might be 0)         AMM.sol (L551) takerPosition might be 0)         MarginAccount.sol (L497) buffer might be 0)         AMM.sol (L681) period might be 0)         ClearingHouse.sol (L332) notionalPosition might be 0)         MarginAccount.sol (L495) buffer might be 0)         AMM.sol (L556) totalPosition might be 0)         AMM.sol (L552) totalPosition might be 0)         AMM.sol (L710) _underlyingPrice might be 0)         AMM.sol (L251) maker might be 0)         AMM.sol (L250) maker might be 0)         AMM.sol (L703) _intervalInSeconds might be 0)         AMM.sol (L250) _maker might be 0)         AMM.sol (L592) baseAssetQuantity might be 0)    Title: Usage of an incorrect version of Ownbale library can potentially malfunction all onlyOwner functions Severity: High Risk       The current implementaion is using an non-upgradeable version of the Ownbale library.  instead of the upgradeable version: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol.     A regular, non-upgradeable Ownbale library will make the deployer the default owner in the constructor. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. Therefore, there will be no owner when the contract is deployed as a proxy contract     Use @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol and @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol instead.     And add     __Ownable_init(); at the beginning of the initializer.                   Oracle.sol         AMM.sol    Title: Unbounded loop on array can lead to DoS Severity: High Risk  The attacker can push unlimitedly to an array, that some function loop over this array. If increasing the array size enough, calling the function that does a loop over the array will always revert since there is a gas limit. This is an High Risk issue since those arrays are publicly allows to push items into them.          ClearingHouse.sol (L193): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L262): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L169): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L129): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L250): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L121): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L276): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']  
