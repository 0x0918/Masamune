# Handle  ye0lde   # Vulnerability details  ## Impact  The variable v is declared after the first use of its contents.  Moving the declaration before the first use will save gas.  ## Proof of Concept  "v" is declared here: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L180  But "v"s contents (validators[validatorId]) is used here first: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L178  Move line 180 above line 178 and change line 178 to use "v".  I've run out of contest time to continue testing but I'd recommend looking through the following functions for how "validators[validatorId]" may be used more efficiently. https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L272 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L346   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See Proof of Concept  
# Handle  pants   # Vulnerability details  Change lines 178 to 173. We know it's minor but it's still optimizing gas and more elegant :)  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The function `getDelegatorDetails()` declares three arrays of type `uint`  (alias for `uint256`).  The variables saved in the arrays are of type `uint128`.  See lines [451-453](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L451).  The suggestion is to be consistent with the integer sizes.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The mapping `validators` is defined with `uint` (alias for `uint256`) as key  type.  In the functions receiving the `validatorId` as parameter however, the  `validatorId` is defined as `uint128`.  See lines [166](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L166), [214](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L214).  The suggestion is to be consistent with the integer size.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The variable `CQT` is used as constant but not declared as such.  Declaring it as constant saves gas.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L423-L433  ```solidity function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 stakingId) public {     Unstaking storage us = validators[validatorId].unstakings[msg.sender][stakingId];     require( uint128(block.number) > us.coolDownEnd, "Cooldown period has not ended" );     require(us.amount >= amount, "Amount is too high");     transferFromContract(msg.sender, amount);     us.amount -= amount;     // set cool down end to 0 to release gas if new unstaking amount is 0     if (us.amount == 0)         us.coolDownEnd = 0;     emit UnstakeRedeemed(validatorId, msg.sender, amount); } ```  The last parameter of `transferUnstakedOut()` is named `stakingId`, while other functions is using `unstakingId`. This is inconsistent and can be misleading.  ### Recommendation  Change from `stakingId` to `unstakingId`.  
# Handle  cmichel   # Vulnerability details  The `unstake` function does not immediately update the exchange rates. It first computes the `validatorSharesRemove = tokensToShares(amount, v.exchangeRate)` **with the old exchange rate**.  Only afterwards, it updates the exchange rates (if the validator is not disabled):  ```solidity // @audit shares are computed here with old rate uint128 validatorSharesRemove = tokensToShares(amount, v.exchangeRate); require(validatorSharesRemove > 0, "Unstake amount is too small");  if (v.disabledEpoch == 0) {     // @audit rates are updated here     updateGlobalExchangeRate();     updateValidator(v);     // ... } ```  ## Impact More shares for the amount are burned than required and users will lose rewards in the end.  ## POC Demonstrating that users will lose rewards:  1. Assume someone staked `1000 amount` and received `1000 shares`, and `v.exchangeRate = 1.0`. (This user is the single staker) 2. Several epochs pass, interest accrues, and `1000 tokens` accrue for the validator, `tokensGivenToValidator = 1000`. User should be entitled to 1000 in principal + 1000 in rewards = 2000 tokens. 3. But user calls `unstake(1000)`, which sets `validatorSharesRemove = tokensToShares(amount, v.exchangeRate) = 1000 / 1.0 = 1000`. **Afterwards**, the exchange rate is updated: `v.exchangeRate += tokensGivenToValidator / totalShares = 1.0 + 1.0 = 2.0`. The staker is updated with `s.shares -= validatorSharesRemove = 0` and `s.staked -= amount = 0`. And the user receives their 1000 tokens but notice how the user's shares are now at zero as well. 4. User tries to claim rewards calling `redeemAllRewards` which fails as the `rewards` are 0.  If the user had first called `redeemAllRewards` and `unstake` afterwards they'd have received their 2000 tokens.  ## Recommended Mitigation Steps The exchange rates always need to be updated first before doing anything. Move the `updateGlobalExchangeRate()` and `updateValidator(v)` calls to the beginning of the function.   
# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style of function names does not follow the best practices:  - transferToContract() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L74  - transferToContract() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L82  - updateGlobalExchangeRate() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L118  - updateValidator() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L134  - sharesToTokens() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L157-L164  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L183-L188  ```solidity if (msg.sender == v._address){     require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, "Amount is less than minimum staked required"); } else {     // otherwise need to check for max cap     uint128 validatorStaked = v.stakings[v._address].staked; ```  `v._address` is read twice.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L345-L351  ```solidity function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {         validators[validatorsN]._address = validator;         validators[validatorsN].operator = operator;         validators[validatorsN].commissionRate = commissionRate;         emit ValidatorAdded(validatorsN, validator, operator);         validatorsN +=1;     } ```  `validatorsN` is read 4 times.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L437-L446  ```solidity function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {         commissionRates = new uint128[](validatorsN);         delegated = new uint128[](validatorsN);         for (uint128 i = 0; i < validatorsN; i++){             Validator storage v = validators[i];             commissionRates[i] = v.commissionRate;             delegated[i] = v.delegated - v.stakings[v._address].staked;         }         return (commissionRates, delegated);     } ```  `validatorsN` is read 3 times.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L450-L459  ```solidity function getDelegatorDetails(address delegator) public view returns( uint[] memory delegated,  uint[] memory rewardsAvailable, uint[] memory commissionRewards) {        delegated = new uint[](validatorsN);        rewardsAvailable = new uint[](validatorsN);        commissionRewards = new uint[](validatorsN);        uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;        uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;          for (uint128 i = 0; i < validatorsN; i++){             Validator storage v = validators[i];  ```  `validatorsN` is read 4 times.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L313-L322  ```solidity if(msg.sender == v._address){     require(rewards + v.commissionAvailableToRedeem >= amount, "Cannot redeem more than available");     // first redeem rewards from commission     uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;     // if there is more, redeem  it from regular rewards     if (commissionLeftOver == 0){         uint128 validatorSharesRemove = tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);         s.shares -= validatorSharesRemove;         v.totalShares -= validatorSharesRemove;     } ```  `v.commissionAvailableToRedeem` is read 4 times.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L111-L111  ```solidity rewardsLocked -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L201-L202  ```solidity totalGlobalShares += globalSharesToAdd; v.globalShares += globalSharesToAdd; ```   https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L261-L261  ```solidity us.amount -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L350-L350  ```solidity validatorsN +=1; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L415-L415  ```solidity us.amount -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L428-L428  ```solidity us.amount -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L316-L319  ```solidity uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0; // if there is more, redeem  it from regular rewards if (commissionLeftOver == 0){     uint128 validatorSharesRemove = tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L101-L115  ```solidity function takeOutRewardTokens(uint128 amount) public onlyOwner {     require(amount > 0, "Amount is 0");     uint128 currentEpoch = uint128(block.number);     uint128 epochs = amount / allocatedTokensPerEpoch;     if (endEpoch != 0){         require(endEpoch - epochs > currentEpoch, "Cannot takeout rewards from past");         endEpoch = endEpoch - epochs;     }     else{         require(rewardsLocked >= amount, "Amount is greater than available");         rewardsLocked -= amount;     }     transferFromContract(owner(), amount);     emit AllocatedTokensTaken(amount); } ```  Since the `takeOutRewardTokens()` function is `onlyOwner`, `transferFromContract(owner(), amount);` can be changed to `transferFromContract(msg.sender, amount);` to avoid unnecessary internal call and storage read to save some gas.  
# Handle  WatchPug   # Vulnerability details  Duplicated or logically equivalent code can be hard to maintain. Avoiding code duplication is recommended when feasible.  For example, most of the business logic in `redeemAllRewards()` and `redeemRewards()` is the same.  Consider calculating the amount of the total rewards in `redeemAllRewards()` and call `redeemRewards()` with the amount to reduce code duplication.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L62-L63  ```solidity // this is used to have the contract upgradeable function initialize(uint128 minStakedRequired) public initializer { ```  Based on the context and comments in the code, the `DelegatedStaking.sol` contract is designed to be deployed as an upgradeable proxy contract.  However, the current implementaion is using an non-upgradeable version of the `Ownbale` library: `@openzeppelin/contracts/access/Ownable.sol` instead of the upgradeable version: `@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol`.  A regular, non-upgradeable `Ownbale` library will make the deployer the default owner in the constructor. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. Therefore, there will be no owner when the contract is deployed as a proxy contract.  As a result, all the `onlyOwner` functions will be inaccessible.  ### Recommendation  Use `@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol` and `@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol` instead.  And change the `initialize()` function to:  ```solidity function initialize(uint128 minStakedRequired) public initializer {     __Ownable_init();     ... } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L57  ```solidity=57 event TransferedUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId); ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L419  ```solidity=419 emit TransferedUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId); ```  `Transfered` should be `Transferred`.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L303-L304  ```solidity // if validator calls redeem rewards, first tokens paid from comissions will be redeemed and then regular rewards     function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) public { ```  `comissions` should be `commissions`.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L392-L393  ```solidity // only owner can change comission rate     function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner { ```  `comission` should be `commission`.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L374-L375  ```solidity // calclate how much rewards would be distribited with the old emission rate uint128 futureRewards = allocatedTokensPerEpoch * epochs; ```  `calculate` should be `calculate`. `distribited` should be `distributed`.  
# Handle  pants   # Vulnerability details  Declaration inside a loop is less gas efficient than before it. See line 462 for example.  
# Handle  pants   # Vulnerability details  ++i is more gas efficient than i++ in loops forwarding. At line 440 for example. We would also recommend to use unchecked{++i} and change i declaration to uint256  
# Handle  pants   # Vulnerability details  The following calculation can be more numeric precise: uint128 perEpochRateIncrease =uint128(uint256(allocatedTokensPerEpoch)*divider/uint256(totalGlobalShares));  globalExchangeRate += perEpochRateIncrease * (currentEpoch - lastUpdateEpoch);   Change it to: uint128 perEpochRateIncrease =uint256(allocatedTokensPerEpoch)*divider; globalExchangeRate += perEpochRateIncrease * (currentEpoch - lastUpdateEpoch) / uint256(totalGlobalShares);  
# Handle  pants   # Vulnerability details  You forgot emit event at the end of initialize function.  
# Handle  pants   # Vulnerability details  state variable divider could be set immutable. At line 9.  
# Handle  hickuphh3   # Vulnerability details  ## Impact  The following lines in `takeOutRewardTokens()` are only needed in the case where `endEpoch != 0`.  ```jsx uint128 currentEpoch = uint128(block.number); uint128 epochs = amount / allocatedTokensPerEpoch; ```  Hence, they can be shifted inside the "if" block.  Furthermore, a double calculation of `endEpoch - epochs` can be avoided by saving the result into a new variable `newEpoch`.  ## Recommended Mitigation Steps  ```jsx if (endEpoch != 0) {   uint128 newEpoch = endEpoch - (amount / allocatedTokensPerEpoch);   require(newEpoch  > uint128(block.number), "Cannot takeout rewards from past");   endEpoch = newEpoch; } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The check `require(amount < divider, "Rate must be less than 100%");` exists in `setValidatorComissionRate()` but not in `addValidator()`.  ### Recommended Mitigation Steps  Add the check in `addValidator()` as well.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L75 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L83 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L91 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L184 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L218 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L233 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L314 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L326 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L358 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L410 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L411  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.  Or in contracts using solc version 0.8.4 or greater use the Custom Errors feature.    
# Handle  xYrYuYx   # Vulnerability details  ## Impact UpdateGlobalExchangeRate has incorrect implementation when `totalGlobalShares` is zero.  If any user didn't start stake, `totalGlobalShares` is 0, and every stake it will increase. but there is possibility that `totalGlobalShares` can be 0 amount later by unstake or disable validator.  ## Proof of Concept https://github.com/xYrYuYx/C4-2021-10-covalent/blob/main/test/c4-tests/C4_issues.js#L76 This is my test case to proof this issue.  In my test case, I disabled validator to make `totalGlobalShares` to zero. And in this case, some reward amount will be forever locked in the contract. After disable validator, I mined 10 blocks, and 4 more blocks mined due to other function calls, So total 14 CQT is forever locked in the contract.   ## Tools Used Hardhat test  ## Recommended Mitigation Steps Please think again when `totalGlobalShares` is zero.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _stake() initializes endEpoch using the value of rewardsLocked. Afterwards rewardsLocked is no longer used (because now endEpoch !=0)  So you can set rewardsLocked to 0 save a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L171-L176  ## Tools Used  ## Recommended Mitigation Steps Update to code of  _stake() to: if (endEpoch == 0) {            endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch;            rewardsLocked = 0; // no longer used and saves a bit of gas }  
# Handle  gpersoon   # Vulnerability details  ## Impact The function depositRewardTokens divides the "amount" of tokens by allocatedTokensPerEpoch to calculate the endEpoch. When "amount" isn't a multiple of allocatedTokensPerEpoch the result of the division will be rounded down, effectively losing a number of tokens for the rewards.  For example if allocatedTokensPerEpoch is set to 3e18 and "amount" is 100e18 then endEpoch will be increased with 33e18 and the last 1e18 tokens are lost.  A similar problem occurs here: - in setAllocatedTokensPerEpoch(), with the recalculation of endEpoch  - in takeOutRewardTokens(), with the retrieval of tokens  - in _stake(), when initializing endEpoch (e.g. when endEpoch==0)   ## Proof of Concept https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L90-L98  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L368-L383  ## Tools Used  ## Recommended Mitigation Steps In depositRewardTokens() add, in the beginning of function, before the if statement: require(amount % allocatedTokensPerEpoch == 0,"Not multiple");  In takeOutRewardTokens() add: require(amount % allocatedTokensPerEpoch == 0,"Not multiple");  Update setAllocatedTokensPerEpoch() to something like:  if (endEpoch != 0) {       ...    uint128 futureRewards = ...    require(futureRewards % amount ==0,"Not multiple");    ...    } else { // to prevent issues with _stake()     require(rewardsLocked % allocatedTokensPerEpoch==0,"Not multiple"); }    
# Handle  xYrYuYx   # Vulnerability details  ## Impact In `disableValidator` function, validatorId checker is not required, or it is good to change require order for better contract.  ## Proof of Concept If `validatorId` is higher than `validatorsN`, it means, that validator is not initialized, so `validator._address` is always `address(0)`. so it will revert in Line 358. It means that Line 359 cannot be executed at all.  ## Tools Used  ## Recommended Mitigation Steps Move Line 359 (https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L359) at the top of function body, before get validator storage variable. This is good to track correct issue.  Or   You can remove that line. So if validatorId is invalid, the error message will be `Caller is not the owner or the validator`, because validator._address = address(0) which cannot be caller.  
# Handle  xYrYuYx   # Vulnerability details  ## Impact This is too complicated steps to transfer ERC20 token which could use more gas. You don't need to check balance before transfer. If there is no enough balance, it SafeERC20 will revert. Also you don't need to check balance after transfer, because CQT does not have transaction fee.  ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol  ## Tools Used  ## Recommended Mitigation Steps Since there is no transaction fee in CQT token, you can use OZ SafeERC20 library to send or receive.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L20 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L28   
# Handle  ye0lde   # Vulnerability details  ## Impact  The variable v is declared after the first use of its contents.  Moving the declaration before the first use will save gas.  ## Proof of Concept  "v" is declared here: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L180  But "v"s contents (validators[validatorId]) is used here first: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L178  Move line 180 above line 178 and change line 178 to use "v".  I've run out of contest time to continue testing but I'd recommend looking through the following functions for how "validators[validatorId]" may be used more efficiently. https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L272 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L346   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See Proof of Concept  
# Handle  pants   # Vulnerability details  Change lines 178 to 173. We know it's minor but it's still optimizing gas and more elegant :)  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The function `getDelegatorDetails()` declares three arrays of type `uint`  (alias for `uint256`).  The variables saved in the arrays are of type `uint128`.  See lines [451-453](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L451).  The suggestion is to be consistent with the integer sizes.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The mapping `validators` is defined with `uint` (alias for `uint256`) as key  type.  In the functions receiving the `validatorId` as parameter however, the  `validatorId` is defined as `uint128`.  See lines [166](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L166), [214](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L214).  The suggestion is to be consistent with the integer size.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The variable `CQT` is used as constant but not declared as such.  Declaring it as constant saves gas.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L423-L433  ```solidity function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 stakingId) public {     Unstaking storage us = validators[validatorId].unstakings[msg.sender][stakingId];     require( uint128(block.number) > us.coolDownEnd, "Cooldown period has not ended" );     require(us.amount >= amount, "Amount is too high");     transferFromContract(msg.sender, amount);     us.amount -= amount;     // set cool down end to 0 to release gas if new unstaking amount is 0     if (us.amount == 0)         us.coolDownEnd = 0;     emit UnstakeRedeemed(validatorId, msg.sender, amount); } ```  The last parameter of `transferUnstakedOut()` is named `stakingId`, while other functions is using `unstakingId`. This is inconsistent and can be misleading.  ### Recommendation  Change from `stakingId` to `unstakingId`.  
# Handle  cmichel   # Vulnerability details  The `unstake` function does not immediately update the exchange rates. It first computes the `validatorSharesRemove = tokensToShares(amount, v.exchangeRate)` **with the old exchange rate**.  Only afterwards, it updates the exchange rates (if the validator is not disabled):  ```solidity // @audit shares are computed here with old rate uint128 validatorSharesRemove = tokensToShares(amount, v.exchangeRate); require(validatorSharesRemove > 0, "Unstake amount is too small");  if (v.disabledEpoch == 0) {     // @audit rates are updated here     updateGlobalExchangeRate();     updateValidator(v);     // ... } ```  ## Impact More shares for the amount are burned than required and users will lose rewards in the end.  ## POC Demonstrating that users will lose rewards:  1. Assume someone staked `1000 amount` and received `1000 shares`, and `v.exchangeRate = 1.0`. (This user is the single staker) 2. Several epochs pass, interest accrues, and `1000 tokens` accrue for the validator, `tokensGivenToValidator = 1000`. User should be entitled to 1000 in principal + 1000 in rewards = 2000 tokens. 3. But user calls `unstake(1000)`, which sets `validatorSharesRemove = tokensToShares(amount, v.exchangeRate) = 1000 / 1.0 = 1000`. **Afterwards**, the exchange rate is updated: `v.exchangeRate += tokensGivenToValidator / totalShares = 1.0 + 1.0 = 2.0`. The staker is updated with `s.shares -= validatorSharesRemove = 0` and `s.staked -= amount = 0`. And the user receives their 1000 tokens but notice how the user's shares are now at zero as well. 4. User tries to claim rewards calling `redeemAllRewards` which fails as the `rewards` are 0.  If the user had first called `redeemAllRewards` and `unstake` afterwards they'd have received their 2000 tokens.  ## Recommended Mitigation Steps The exchange rates always need to be updated first before doing anything. Move the `updateGlobalExchangeRate()` and `updateValidator(v)` calls to the beginning of the function.   
# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style of function names does not follow the best practices:  - transferToContract() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L74  - transferToContract() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L82  - updateGlobalExchangeRate() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L118  - updateValidator() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L134  - sharesToTokens() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L157-L164  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L183-L188  ```solidity if (msg.sender == v._address){     require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, "Amount is less than minimum staked required"); } else {     // otherwise need to check for max cap     uint128 validatorStaked = v.stakings[v._address].staked; ```  `v._address` is read twice.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L345-L351  ```solidity function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {         validators[validatorsN]._address = validator;         validators[validatorsN].operator = operator;         validators[validatorsN].commissionRate = commissionRate;         emit ValidatorAdded(validatorsN, validator, operator);         validatorsN +=1;     } ```  `validatorsN` is read 4 times.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L437-L446  ```solidity function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {         commissionRates = new uint128[](validatorsN);         delegated = new uint128[](validatorsN);         for (uint128 i = 0; i < validatorsN; i++){             Validator storage v = validators[i];             commissionRates[i] = v.commissionRate;             delegated[i] = v.delegated - v.stakings[v._address].staked;         }         return (commissionRates, delegated);     } ```  `validatorsN` is read 3 times.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L450-L459  ```solidity function getDelegatorDetails(address delegator) public view returns( uint[] memory delegated,  uint[] memory rewardsAvailable, uint[] memory commissionRewards) {        delegated = new uint[](validatorsN);        rewardsAvailable = new uint[](validatorsN);        commissionRewards = new uint[](validatorsN);        uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;        uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;          for (uint128 i = 0; i < validatorsN; i++){             Validator storage v = validators[i];  ```  `validatorsN` is read 4 times.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L313-L322  ```solidity if(msg.sender == v._address){     require(rewards + v.commissionAvailableToRedeem >= amount, "Cannot redeem more than available");     // first redeem rewards from commission     uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;     // if there is more, redeem  it from regular rewards     if (commissionLeftOver == 0){         uint128 validatorSharesRemove = tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);         s.shares -= validatorSharesRemove;         v.totalShares -= validatorSharesRemove;     } ```  `v.commissionAvailableToRedeem` is read 4 times.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L111-L111  ```solidity rewardsLocked -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L201-L202  ```solidity totalGlobalShares += globalSharesToAdd; v.globalShares += globalSharesToAdd; ```   https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L261-L261  ```solidity us.amount -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L350-L350  ```solidity validatorsN +=1; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L415-L415  ```solidity us.amount -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L428-L428  ```solidity us.amount -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L316-L319  ```solidity uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0; // if there is more, redeem  it from regular rewards if (commissionLeftOver == 0){     uint128 validatorSharesRemove = tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L101-L115  ```solidity function takeOutRewardTokens(uint128 amount) public onlyOwner {     require(amount > 0, "Amount is 0");     uint128 currentEpoch = uint128(block.number);     uint128 epochs = amount / allocatedTokensPerEpoch;     if (endEpoch != 0){         require(endEpoch - epochs > currentEpoch, "Cannot takeout rewards from past");         endEpoch = endEpoch - epochs;     }     else{         require(rewardsLocked >= amount, "Amount is greater than available");         rewardsLocked -= amount;     }     transferFromContract(owner(), amount);     emit AllocatedTokensTaken(amount); } ```  Since the `takeOutRewardTokens()` function is `onlyOwner`, `transferFromContract(owner(), amount);` can be changed to `transferFromContract(msg.sender, amount);` to avoid unnecessary internal call and storage read to save some gas.  
# Handle  WatchPug   # Vulnerability details  Duplicated or logically equivalent code can be hard to maintain. Avoiding code duplication is recommended when feasible.  For example, most of the business logic in `redeemAllRewards()` and `redeemRewards()` is the same.  Consider calculating the amount of the total rewards in `redeemAllRewards()` and call `redeemRewards()` with the amount to reduce code duplication.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L62-L63  ```solidity // this is used to have the contract upgradeable function initialize(uint128 minStakedRequired) public initializer { ```  Based on the context and comments in the code, the `DelegatedStaking.sol` contract is designed to be deployed as an upgradeable proxy contract.  However, the current implementaion is using an non-upgradeable version of the `Ownbale` library: `@openzeppelin/contracts/access/Ownable.sol` instead of the upgradeable version: `@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol`.  A regular, non-upgradeable `Ownbale` library will make the deployer the default owner in the constructor. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. Therefore, there will be no owner when the contract is deployed as a proxy contract.  As a result, all the `onlyOwner` functions will be inaccessible.  ### Recommendation  Use `@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol` and `@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol` instead.  And change the `initialize()` function to:  ```solidity function initialize(uint128 minStakedRequired) public initializer {     __Ownable_init();     ... } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L57  ```solidity=57 event TransferedUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId); ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L419  ```solidity=419 emit TransferedUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId); ```  `Transfered` should be `Transferred`.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L303-L304  ```solidity // if validator calls redeem rewards, first tokens paid from comissions will be redeemed and then regular rewards     function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) public { ```  `comissions` should be `commissions`.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L392-L393  ```solidity // only owner can change comission rate     function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner { ```  `comission` should be `commission`.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L374-L375  ```solidity // calclate how much rewards would be distribited with the old emission rate uint128 futureRewards = allocatedTokensPerEpoch * epochs; ```  `calculate` should be `calculate`. `distribited` should be `distributed`.  
# Handle  pants   # Vulnerability details  Declaration inside a loop is less gas efficient than before it. See line 462 for example.  
# Handle  pants   # Vulnerability details  ++i is more gas efficient than i++ in loops forwarding. At line 440 for example. We would also recommend to use unchecked{++i} and change i declaration to uint256  
# Handle  pants   # Vulnerability details  The following calculation can be more numeric precise: uint128 perEpochRateIncrease =uint128(uint256(allocatedTokensPerEpoch)*divider/uint256(totalGlobalShares));  globalExchangeRate += perEpochRateIncrease * (currentEpoch - lastUpdateEpoch);   Change it to: uint128 perEpochRateIncrease =uint256(allocatedTokensPerEpoch)*divider; globalExchangeRate += perEpochRateIncrease * (currentEpoch - lastUpdateEpoch) / uint256(totalGlobalShares);  
# Handle  pants   # Vulnerability details  You forgot emit event at the end of initialize function.  
# Handle  pants   # Vulnerability details  state variable divider could be set immutable. At line 9.  
# Handle  hickuphh3   # Vulnerability details  ## Impact  The following lines in `takeOutRewardTokens()` are only needed in the case where `endEpoch != 0`.  ```jsx uint128 currentEpoch = uint128(block.number); uint128 epochs = amount / allocatedTokensPerEpoch; ```  Hence, they can be shifted inside the "if" block.  Furthermore, a double calculation of `endEpoch - epochs` can be avoided by saving the result into a new variable `newEpoch`.  ## Recommended Mitigation Steps  ```jsx if (endEpoch != 0) {   uint128 newEpoch = endEpoch - (amount / allocatedTokensPerEpoch);   require(newEpoch  > uint128(block.number), "Cannot takeout rewards from past");   endEpoch = newEpoch; } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The check `require(amount < divider, "Rate must be less than 100%");` exists in `setValidatorComissionRate()` but not in `addValidator()`.  ### Recommended Mitigation Steps  Add the check in `addValidator()` as well.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L75 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L83 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L91 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L184 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L218 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L233 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L314 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L326 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L358 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L410 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L411  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.  Or in contracts using solc version 0.8.4 or greater use the Custom Errors feature.    
# Handle  xYrYuYx   # Vulnerability details  ## Impact UpdateGlobalExchangeRate has incorrect implementation when `totalGlobalShares` is zero.  If any user didn't start stake, `totalGlobalShares` is 0, and every stake it will increase. but there is possibility that `totalGlobalShares` can be 0 amount later by unstake or disable validator.  ## Proof of Concept https://github.com/xYrYuYx/C4-2021-10-covalent/blob/main/test/c4-tests/C4_issues.js#L76 This is my test case to proof this issue.  In my test case, I disabled validator to make `totalGlobalShares` to zero. And in this case, some reward amount will be forever locked in the contract. After disable validator, I mined 10 blocks, and 4 more blocks mined due to other function calls, So total 14 CQT is forever locked in the contract.   ## Tools Used Hardhat test  ## Recommended Mitigation Steps Please think again when `totalGlobalShares` is zero.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _stake() initializes endEpoch using the value of rewardsLocked. Afterwards rewardsLocked is no longer used (because now endEpoch !=0)  So you can set rewardsLocked to 0 save a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L171-L176  ## Tools Used  ## Recommended Mitigation Steps Update to code of  _stake() to: if (endEpoch == 0) {            endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch;            rewardsLocked = 0; // no longer used and saves a bit of gas }  
# Handle  gpersoon   # Vulnerability details  ## Impact The function depositRewardTokens divides the "amount" of tokens by allocatedTokensPerEpoch to calculate the endEpoch. When "amount" isn't a multiple of allocatedTokensPerEpoch the result of the division will be rounded down, effectively losing a number of tokens for the rewards.  For example if allocatedTokensPerEpoch is set to 3e18 and "amount" is 100e18 then endEpoch will be increased with 33e18 and the last 1e18 tokens are lost.  A similar problem occurs here: - in setAllocatedTokensPerEpoch(), with the recalculation of endEpoch  - in takeOutRewardTokens(), with the retrieval of tokens  - in _stake(), when initializing endEpoch (e.g. when endEpoch==0)   ## Proof of Concept https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L90-L98  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L368-L383  ## Tools Used  ## Recommended Mitigation Steps In depositRewardTokens() add, in the beginning of function, before the if statement: require(amount % allocatedTokensPerEpoch == 0,"Not multiple");  In takeOutRewardTokens() add: require(amount % allocatedTokensPerEpoch == 0,"Not multiple");  Update setAllocatedTokensPerEpoch() to something like:  if (endEpoch != 0) {       ...    uint128 futureRewards = ...    require(futureRewards % amount ==0,"Not multiple");    ...    } else { // to prevent issues with _stake()     require(rewardsLocked % allocatedTokensPerEpoch==0,"Not multiple"); }    
# Handle  xYrYuYx   # Vulnerability details  ## Impact In `disableValidator` function, validatorId checker is not required, or it is good to change require order for better contract.  ## Proof of Concept If `validatorId` is higher than `validatorsN`, it means, that validator is not initialized, so `validator._address` is always `address(0)`. so it will revert in Line 358. It means that Line 359 cannot be executed at all.  ## Tools Used  ## Recommended Mitigation Steps Move Line 359 (https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L359) at the top of function body, before get validator storage variable. This is good to track correct issue.  Or   You can remove that line. So if validatorId is invalid, the error message will be `Caller is not the owner or the validator`, because validator._address = address(0) which cannot be caller.  
# Handle  xYrYuYx   # Vulnerability details  ## Impact This is too complicated steps to transfer ERC20 token which could use more gas. You don't need to check balance before transfer. If there is no enough balance, it SafeERC20 will revert. Also you don't need to check balance after transfer, because CQT does not have transaction fee.  ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol  ## Tools Used  ## Recommended Mitigation Steps Since there is no transaction fee in CQT token, you can use OZ SafeERC20 library to send or receive.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L20 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L28   
# Handle  ye0lde   # Vulnerability details  ## Impact  The variable v is declared after the first use of its contents.  Moving the declaration before the first use will save gas.  ## Proof of Concept  "v" is declared here: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L180  But "v"s contents (validators[validatorId]) is used here first: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L178  Move line 180 above line 178 and change line 178 to use "v".  I've run out of contest time to continue testing but I'd recommend looking through the following functions for how "validators[validatorId]" may be used more efficiently. https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L272 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L346   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See Proof of Concept  
# Handle  pants   # Vulnerability details  Change lines 178 to 173. We know it's minor but it's still optimizing gas and more elegant :)  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The function `getDelegatorDetails()` declares three arrays of type `uint`  (alias for `uint256`).  The variables saved in the arrays are of type `uint128`.  See lines [451-453](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L451).  The suggestion is to be consistent with the integer sizes.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The mapping `validators` is defined with `uint` (alias for `uint256`) as key  type.  In the functions receiving the `validatorId` as parameter however, the  `validatorId` is defined as `uint128`.  See lines [166](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L166), [214](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L214).  The suggestion is to be consistent with the integer size.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The variable `CQT` is used as constant but not declared as such.  Declaring it as constant saves gas.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L423-L433  ```solidity function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 stakingId) public {     Unstaking storage us = validators[validatorId].unstakings[msg.sender][stakingId];     require( uint128(block.number) > us.coolDownEnd, "Cooldown period has not ended" );     require(us.amount >= amount, "Amount is too high");     transferFromContract(msg.sender, amount);     us.amount -= amount;     // set cool down end to 0 to release gas if new unstaking amount is 0     if (us.amount == 0)         us.coolDownEnd = 0;     emit UnstakeRedeemed(validatorId, msg.sender, amount); } ```  The last parameter of `transferUnstakedOut()` is named `stakingId`, while other functions is using `unstakingId`. This is inconsistent and can be misleading.  ### Recommendation  Change from `stakingId` to `unstakingId`.  
# Handle  cmichel   # Vulnerability details  The `unstake` function does not immediately update the exchange rates. It first computes the `validatorSharesRemove = tokensToShares(amount, v.exchangeRate)` **with the old exchange rate**.  Only afterwards, it updates the exchange rates (if the validator is not disabled):  ```solidity // @audit shares are computed here with old rate uint128 validatorSharesRemove = tokensToShares(amount, v.exchangeRate); require(validatorSharesRemove > 0, "Unstake amount is too small");  if (v.disabledEpoch == 0) {     // @audit rates are updated here     updateGlobalExchangeRate();     updateValidator(v);     // ... } ```  ## Impact More shares for the amount are burned than required and users will lose rewards in the end.  ## POC Demonstrating that users will lose rewards:  1. Assume someone staked `1000 amount` and received `1000 shares`, and `v.exchangeRate = 1.0`. (This user is the single staker) 2. Several epochs pass, interest accrues, and `1000 tokens` accrue for the validator, `tokensGivenToValidator = 1000`. User should be entitled to 1000 in principal + 1000 in rewards = 2000 tokens. 3. But user calls `unstake(1000)`, which sets `validatorSharesRemove = tokensToShares(amount, v.exchangeRate) = 1000 / 1.0 = 1000`. **Afterwards**, the exchange rate is updated: `v.exchangeRate += tokensGivenToValidator / totalShares = 1.0 + 1.0 = 2.0`. The staker is updated with `s.shares -= validatorSharesRemove = 0` and `s.staked -= amount = 0`. And the user receives their 1000 tokens but notice how the user's shares are now at zero as well. 4. User tries to claim rewards calling `redeemAllRewards` which fails as the `rewards` are 0.  If the user had first called `redeemAllRewards` and `unstake` afterwards they'd have received their 2000 tokens.  ## Recommended Mitigation Steps The exchange rates always need to be updated first before doing anything. Move the `updateGlobalExchangeRate()` and `updateValidator(v)` calls to the beginning of the function.   
# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style of function names does not follow the best practices:  - transferToContract() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L74  - transferToContract() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L82  - updateGlobalExchangeRate() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L118  - updateValidator() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L134  - sharesToTokens() https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L157-L164  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L183-L188  ```solidity if (msg.sender == v._address){     require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, "Amount is less than minimum staked required"); } else {     // otherwise need to check for max cap     uint128 validatorStaked = v.stakings[v._address].staked; ```  `v._address` is read twice.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L345-L351  ```solidity function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {         validators[validatorsN]._address = validator;         validators[validatorsN].operator = operator;         validators[validatorsN].commissionRate = commissionRate;         emit ValidatorAdded(validatorsN, validator, operator);         validatorsN +=1;     } ```  `validatorsN` is read 4 times.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L437-L446  ```solidity function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {         commissionRates = new uint128[](validatorsN);         delegated = new uint128[](validatorsN);         for (uint128 i = 0; i < validatorsN; i++){             Validator storage v = validators[i];             commissionRates[i] = v.commissionRate;             delegated[i] = v.delegated - v.stakings[v._address].staked;         }         return (commissionRates, delegated);     } ```  `validatorsN` is read 3 times.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L450-L459  ```solidity function getDelegatorDetails(address delegator) public view returns( uint[] memory delegated,  uint[] memory rewardsAvailable, uint[] memory commissionRewards) {        delegated = new uint[](validatorsN);        rewardsAvailable = new uint[](validatorsN);        commissionRewards = new uint[](validatorsN);        uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;        uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;          for (uint128 i = 0; i < validatorsN; i++){             Validator storage v = validators[i];  ```  `validatorsN` is read 4 times.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L313-L322  ```solidity if(msg.sender == v._address){     require(rewards + v.commissionAvailableToRedeem >= amount, "Cannot redeem more than available");     // first redeem rewards from commission     uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;     // if there is more, redeem  it from regular rewards     if (commissionLeftOver == 0){         uint128 validatorSharesRemove = tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);         s.shares -= validatorSharesRemove;         v.totalShares -= validatorSharesRemove;     } ```  `v.commissionAvailableToRedeem` is read 4 times.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L111-L111  ```solidity rewardsLocked -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L201-L202  ```solidity totalGlobalShares += globalSharesToAdd; v.globalShares += globalSharesToAdd; ```   https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L261-L261  ```solidity us.amount -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L350-L350  ```solidity validatorsN +=1; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L415-L415  ```solidity us.amount -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L428-L428  ```solidity us.amount -= amount; ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L316-L319  ```solidity uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0; // if there is more, redeem  it from regular rewards if (commissionLeftOver == 0){     uint128 validatorSharesRemove = tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L101-L115  ```solidity function takeOutRewardTokens(uint128 amount) public onlyOwner {     require(amount > 0, "Amount is 0");     uint128 currentEpoch = uint128(block.number);     uint128 epochs = amount / allocatedTokensPerEpoch;     if (endEpoch != 0){         require(endEpoch - epochs > currentEpoch, "Cannot takeout rewards from past");         endEpoch = endEpoch - epochs;     }     else{         require(rewardsLocked >= amount, "Amount is greater than available");         rewardsLocked -= amount;     }     transferFromContract(owner(), amount);     emit AllocatedTokensTaken(amount); } ```  Since the `takeOutRewardTokens()` function is `onlyOwner`, `transferFromContract(owner(), amount);` can be changed to `transferFromContract(msg.sender, amount);` to avoid unnecessary internal call and storage read to save some gas.  
# Handle  WatchPug   # Vulnerability details  Duplicated or logically equivalent code can be hard to maintain. Avoiding code duplication is recommended when feasible.  For example, most of the business logic in `redeemAllRewards()` and `redeemRewards()` is the same.  Consider calculating the amount of the total rewards in `redeemAllRewards()` and call `redeemRewards()` with the amount to reduce code duplication.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L62-L63  ```solidity // this is used to have the contract upgradeable function initialize(uint128 minStakedRequired) public initializer { ```  Based on the context and comments in the code, the `DelegatedStaking.sol` contract is designed to be deployed as an upgradeable proxy contract.  However, the current implementaion is using an non-upgradeable version of the `Ownbale` library: `@openzeppelin/contracts/access/Ownable.sol` instead of the upgradeable version: `@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol`.  A regular, non-upgradeable `Ownbale` library will make the deployer the default owner in the constructor. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. Therefore, there will be no owner when the contract is deployed as a proxy contract.  As a result, all the `onlyOwner` functions will be inaccessible.  ### Recommendation  Use `@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol` and `@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol` instead.  And change the `initialize()` function to:  ```solidity function initialize(uint128 minStakedRequired) public initializer {     __Ownable_init();     ... } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L57  ```solidity=57 event TransferedUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId); ```  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L419  ```solidity=419 emit TransferedUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId); ```  `Transfered` should be `Transferred`.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L303-L304  ```solidity // if validator calls redeem rewards, first tokens paid from comissions will be redeemed and then regular rewards     function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) public { ```  `comissions` should be `commissions`.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L392-L393  ```solidity // only owner can change comission rate     function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner { ```  `comission` should be `commission`.  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L374-L375  ```solidity // calclate how much rewards would be distribited with the old emission rate uint128 futureRewards = allocatedTokensPerEpoch * epochs; ```  `calculate` should be `calculate`. `distribited` should be `distributed`.  
# Handle  pants   # Vulnerability details  Declaration inside a loop is less gas efficient than before it. See line 462 for example.  
# Handle  pants   # Vulnerability details  ++i is more gas efficient than i++ in loops forwarding. At line 440 for example. We would also recommend to use unchecked{++i} and change i declaration to uint256  
# Handle  pants   # Vulnerability details  The following calculation can be more numeric precise: uint128 perEpochRateIncrease =uint128(uint256(allocatedTokensPerEpoch)*divider/uint256(totalGlobalShares));  globalExchangeRate += perEpochRateIncrease * (currentEpoch - lastUpdateEpoch);   Change it to: uint128 perEpochRateIncrease =uint256(allocatedTokensPerEpoch)*divider; globalExchangeRate += perEpochRateIncrease * (currentEpoch - lastUpdateEpoch) / uint256(totalGlobalShares);  
# Handle  pants   # Vulnerability details  You forgot emit event at the end of initialize function.  
# Handle  pants   # Vulnerability details  state variable divider could be set immutable. At line 9.  
# Handle  hickuphh3   # Vulnerability details  ## Impact  The following lines in `takeOutRewardTokens()` are only needed in the case where `endEpoch != 0`.  ```jsx uint128 currentEpoch = uint128(block.number); uint128 epochs = amount / allocatedTokensPerEpoch; ```  Hence, they can be shifted inside the "if" block.  Furthermore, a double calculation of `endEpoch - epochs` can be avoided by saving the result into a new variable `newEpoch`.  ## Recommended Mitigation Steps  ```jsx if (endEpoch != 0) {   uint128 newEpoch = endEpoch - (amount / allocatedTokensPerEpoch);   require(newEpoch  > uint128(block.number), "Cannot takeout rewards from past");   endEpoch = newEpoch; } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The check `require(amount < divider, "Rate must be less than 100%");` exists in `setValidatorComissionRate()` but not in `addValidator()`.  ### Recommended Mitigation Steps  Add the check in `addValidator()` as well.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L75 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L83 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L91 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L184 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L218 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L233 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L314 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L326 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L358 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L410 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L411  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.  Or in contracts using solc version 0.8.4 or greater use the Custom Errors feature.    
# Handle  xYrYuYx   # Vulnerability details  ## Impact UpdateGlobalExchangeRate has incorrect implementation when `totalGlobalShares` is zero.  If any user didn't start stake, `totalGlobalShares` is 0, and every stake it will increase. but there is possibility that `totalGlobalShares` can be 0 amount later by unstake or disable validator.  ## Proof of Concept https://github.com/xYrYuYx/C4-2021-10-covalent/blob/main/test/c4-tests/C4_issues.js#L76 This is my test case to proof this issue.  In my test case, I disabled validator to make `totalGlobalShares` to zero. And in this case, some reward amount will be forever locked in the contract. After disable validator, I mined 10 blocks, and 4 more blocks mined due to other function calls, So total 14 CQT is forever locked in the contract.   ## Tools Used Hardhat test  ## Recommended Mitigation Steps Please think again when `totalGlobalShares` is zero.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _stake() initializes endEpoch using the value of rewardsLocked. Afterwards rewardsLocked is no longer used (because now endEpoch !=0)  So you can set rewardsLocked to 0 save a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L171-L176  ## Tools Used  ## Recommended Mitigation Steps Update to code of  _stake() to: if (endEpoch == 0) {            endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch;            rewardsLocked = 0; // no longer used and saves a bit of gas }  
# Handle  gpersoon   # Vulnerability details  ## Impact The function depositRewardTokens divides the "amount" of tokens by allocatedTokensPerEpoch to calculate the endEpoch. When "amount" isn't a multiple of allocatedTokensPerEpoch the result of the division will be rounded down, effectively losing a number of tokens for the rewards.  For example if allocatedTokensPerEpoch is set to 3e18 and "amount" is 100e18 then endEpoch will be increased with 33e18 and the last 1e18 tokens are lost.  A similar problem occurs here: - in setAllocatedTokensPerEpoch(), with the recalculation of endEpoch  - in takeOutRewardTokens(), with the retrieval of tokens  - in _stake(), when initializing endEpoch (e.g. when endEpoch==0)   ## Proof of Concept https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L90-L98  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L368-L383  ## Tools Used  ## Recommended Mitigation Steps In depositRewardTokens() add, in the beginning of function, before the if statement: require(amount % allocatedTokensPerEpoch == 0,"Not multiple");  In takeOutRewardTokens() add: require(amount % allocatedTokensPerEpoch == 0,"Not multiple");  Update setAllocatedTokensPerEpoch() to something like:  if (endEpoch != 0) {       ...    uint128 futureRewards = ...    require(futureRewards % amount ==0,"Not multiple");    ...    } else { // to prevent issues with _stake()     require(rewardsLocked % allocatedTokensPerEpoch==0,"Not multiple"); }    
# Handle  xYrYuYx   # Vulnerability details  ## Impact In `disableValidator` function, validatorId checker is not required, or it is good to change require order for better contract.  ## Proof of Concept If `validatorId` is higher than `validatorsN`, it means, that validator is not initialized, so `validator._address` is always `address(0)`. so it will revert in Line 358. It means that Line 359 cannot be executed at all.  ## Tools Used  ## Recommended Mitigation Steps Move Line 359 (https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L359) at the top of function body, before get validator storage variable. This is good to track correct issue.  Or   You can remove that line. So if validatorId is invalid, the error message will be `Caller is not the owner or the validator`, because validator._address = address(0) which cannot be caller.  
# Handle  xYrYuYx   # Vulnerability details  ## Impact This is too complicated steps to transfer ERC20 token which could use more gas. You don't need to check balance before transfer. If there is no enough balance, it SafeERC20 will revert. Also you don't need to check balance after transfer, because CQT does not have transaction fee.  ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol  ## Tools Used  ## Recommended Mitigation Steps Since there is no transaction fee in CQT token, you can use OZ SafeERC20 library to send or receive.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L20 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L28   
