# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/package.json#L18-L19   # Vulnerability details  ## Impact  The solution uses: ```jsx     "@openzeppelin/contracts": "^4.0.0",     "@openzeppelin/contracts-upgradeable": "^4.3.2", ``` These dependencies have a known high severity vulnerability:  - https://security.snyk.io/vuln/SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177 - https://snyk.io/test/npm/@openzeppelin/contracts-upgradeable/4.3.2#SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177 - https://snyk.io/test/npm/@openzeppelin/contracts/4.0.0#SNYK-JS-OPENZEPPELINCONTRACTS-2320176  Which makes these contracts vulnerable: ```jsx contracts/helpers/CryptoPunksHelper.sol:   19:     function initialize(address punksAddress) external initializer {  contracts/helpers/EtherRocksHelper.sol:   19:     function initialize(address rocksAddress) external initializer {  contracts/staking/JPEGStaking.sol:   21:     function initialize(IERC20Upgradeable _jpeg) external initializer {  contracts/vaults/FungibleAssetVaultForDAO.sol:   71:     ) external initializer {  contracts/vaults/NFTVault.sol:   149:     ) external initializer { ```  ## Recommended Mitigation Steps Upgrade `@openzeppelin/contracts` and `@openzeppelin/contracts-upgradeable` to version 4.4.1 or higher.  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234   # Vulnerability details  ## Impact  As specified in Convex [BaseRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L149) and [VirtualRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/VirtualBalanceRewardPool.sol#L127), the function signature of `earned` is `earned(address)`. However, `balanceOfJPEG` did not pass any arguments to `earned`, which would cause `balanceOfJPEG` to always revert.  This bug will propagate through `Controller` and `YVault` until finally reaching the source of the call in `YVaultLPFarming ._computeUpdate`, and render the entire farming contract unuseable.  ## Proof of Concept  Both `BaseRewardPool.earned` and `VirtualBalanceRewardPool.earned` takes an address as argument  ```     function earned(address account) public view returns (uint256) {         return             balanceOf(account)                 .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))                 .div(1e18)                 .add(rewards[account]);     }      function earned(address account) public view returns (uint256) {         return             balanceOf(account)                 .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))                 .div(1e18)                 .add(rewards[account]);     } ```  But `balanceOfJPEG` does not pass any address to `extraReward.earned`, causing the entire function to revert when called ```     function balanceOfJPEG() external view returns (uint256) {         uint256 availableBalance = jpeg.balanceOf(address(this));          IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;         uint256 length = baseRewardPool.extraRewardsLength();         for (uint256 i = 0; i < length; i++) {             IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));             if (address(jpeg) == extraReward.rewardToken()) {                 availableBalance += extraReward.earned();                 //we found jpeg, no need to continue the loop                 break;             }         }          return availableBalance;     } ```  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Pass `address(this)` as argument of `earned`.  Notice how we modify the fetching of reward. This is reported in a separate bug report, but for completeness, the entire fix is shown in both report entries.  ```     function balanceOfJPEG() external view returns (uint256) {         uint256 availableBalance = jpeg.balanceOf(address(this));          IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;         availableBalance += baseRewardPool.earned(address(this));         uint256 length = baseRewardPool.extraRewardsLength();         for (uint256 i = 0; i < length; i++) {             IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));             if (address(jpeg) == extraReward.rewardToken()) {                 availableBalance += extraReward.earned(address(this));             }         }          return availableBalance;     } ```   
**Table of Contents:**  - [`NFTEscrow._executeTransfer()`: Cheap Contract Deployment Through Clones](#nftescrow_executetransfer-cheap-contract-deployment-through-clones) - [`LPFarming.newEpoch()`: L128 and L133 should be unchecked due to parent if/else condition](#lpfarmingnewepoch-l128-and-l133-should-be-unchecked-due-to-parent-ifelse-condition) - [`LPFarming.withdraw()`: L248 should be unchecked due to L243](#lpfarmingwithdraw-l248-should-be-unchecked-due-to-l243) - [`LPFarming._withdrawReward()`: `poolInfo[_pid].accRewardPerShare` should get cached](#lpfarming_withdrawreward-poolinfo_pidaccrewardpershare-should-get-cached) - [`yVaultLPFarming.withdraw()`: L124 should be unchecked due to L119](#yvaultlpfarmingwithdraw-l124-should-be-unchecked-due-to-l119) - [`yVaultLPFarming._withdrawReward()`: `accRewardPerShare` should get cached](#yvaultlpfarming_withdrawreward-accrewardpershare-should-get-cached) - [`JPEGLock.unlock()`: use `storage` instead of copying struct in memory L69](#jpeglockunlock-use-storage-instead-of-copying-struct-in-memory-l69) - [`FungibleAssetVaultForDAO._collateralPriceUsd()`: `oracle` should get cached](#fungibleassetvaultfordao_collateralpriceusd-oracle-should-get-cached) - [`FungibleAssetVaultForDAO._collateralPriceUsd()`: return statement should be unchecked](#fungibleassetvaultfordao_collateralpriceusd-return-statement-should-be-unchecked) - [`FungibleAssetVaultForDAO.deposit()`: `collateralAsset` should get cached](#fungibleassetvaultfordaodeposit-collateralasset-should-get-cached) - [`FungibleAssetVaultForDAO.repay)`: L184 should be unchecked due to L182](#fungibleassetvaultfordaorepay-l184-should-be-unchecked-due-to-l182) - [`FungibleAssetVaultForDAO.withdraw()`: L196 should be unchecked due to L194](#fungibleassetvaultfordaowithdraw-l196-should-be-unchecked-due-to-l194) - [`FungibleAssetVaultForDAO.withdraw()`: `collateralAmount` should get cached](#fungibleassetvaultfordaowithdraw-collateralamount-should-get-cached) - [`NFTVault._normalizeAggregatorAnswer()`: return statement should be unchecked](#nftvault_normalizeaggregatoranswer-return-statement-should-be-unchecked) - [`NFTVault._calculateAdditionalInterest()`: `totalDebtAmount` should get cached](#nftvault_calculateadditionalinterest-totaldebtamount-should-get-cached) - [`NFTVault.sol`: `struct PositionPreview` can be tightly packed to save 1 storage slot](#nftvaultsol-struct-positionpreview-can-be-tightly-packed-to-save-1-storage-slot) - [`NFTVault.showPosition()`: L659 should be unchecked due to L649](#nftvaultshowposition-l659-should-be-unchecked-due-to-l649) - [`NFTVault.showPosition()`: `positions[_nftIndex].liquidatedAt` should get cached](#nftvaultshowposition-positions_nftindexliquidatedat-should-get-cached) - [`NFTVault.showPosition()`: Help the optimizer by saving a storage variable's reference instead of repeatedly fetching it (`positions[_nftIndex]`)](#nftvaultshowposition-help-the-optimizer-by-saving-a-storage-variables-reference-instead-of-repeatedly-fetching-it-positions_nftindex) - [`NFTVault.borrow()`: `totalDebtPortion` should get cached](#nftvaultborrow-totaldebtportion-should-get-cached) - [`NFTVault.repay()`: L781 should be unchecked due to ternary operator](#nftvaultrepay-l781-should-be-unchecked-due-to-ternary-operator) - [`NFTVault.repay()`: `totalDebtPortion` and `totalDebtAmount` should get cached](#nftvaultrepay-totaldebtportion-and-totaldebtamount-should-get-cached) - [`Controller.setStrategy()`: boolean comparison L87](#controllersetstrategy-boolean-comparison-l87) - [`StrategyPUSDConvex.balanceOfJPEG()`: `jpeg` should get cached](#strategypusdconvexbalanceofjpeg-jpeg-should-get-cached) - [`StrategyPUSDConvex.balanceOfJPEG()`: use a `return` statement instead of `break`](#strategypusdconvexbalanceofjpeg-use-a-return-statement-instead-of-break) - [`StrategyPUSDConvex.withdraw()`: L281 should be unchecked due to L279](#strategypusdconvexwithdraw-l281-should-be-unchecked-due-to-l279) - [`StrategyPUSDConvex.harvest()`: L362 should be unchecked due to L359-L360 and how performanceFee is set L183](#strategypusdconvexharvest-l362-should-be-unchecked-due-to-l359-l360-and-how-performancefee-is-set-l183) - [`yVault.earn()`: `token` and `controller` should get cached](#yvaultearn-token-and-controller-should-get-cached) - [`yVault.withdraw()`: L178 should be unchecked due to L177](#yvaultwithdraw-l178-should-be-unchecked-due-to-l177) - [`yVault.withdraw()`: `token` should get cached](#yvaultwithdraw-token-should-get-cached) - [`yVault.withdrawJPEG()`: `farm` should get cached](#yvaultwithdrawjpeg-farm-should-get-cached) - [Upgrade pragma to at least 0.8.4](#upgrade-pragma-to-at-least-084) - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values) - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof) - [`>=` is cheaper than `>`](#-is-cheaper-than-) - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops) - [`++i` costs less gas compared to `i++` or `i += 1`](#i-costs-less-gas-compared-to-i-or-i--1) - [Increments can be unchecked](#increments-can-be-unchecked) - [Use `calldata` instead of `memory`](#use-calldata-instead-of-memory) - [Consider making some constants as non-public to save gas](#consider-making-some-constants-as-non-public-to-save-gas) - [Public functions to external](#public-functions-to-external) - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings) - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## `NFTEscrow._executeTransfer()`: Cheap Contract Deployment Through Clones  See `@audit` tag:  ```solidity 67:     function _executeTransfer(address _owner, uint256 _idx) internal { 68:         (bytes32 salt, ) = precompute(_owner, _idx); 69:         new FlashEscrow{salt: salt}( //@audit gas: deployment can cost less through clones  70:             nftAddress, 71:             _encodeFlashEscrowPayload(_idx) 72:         ); 73:     } ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  I suggest applying a similar pattern.  ## `LPFarming.newEpoch()`: L128 and L133 should be unchecked due to parent if/else condition  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  I suggest wrapping with an `unchecked` block here (see `@audit` tag):  ```solidity 107:     function newEpoch( ... 111:     ) external onlyOwner { 127:         if (remainingRewards > newRewards) { 128:             jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);  //@audit gas: should be unchecked (can't underflow due to L127) 129:         } else if (remainingRewards < newRewards) { 130:             jpeg.safeTransferFrom( 131:                 msg.sender, 132:                 address(this), 133:                 newRewards - remainingRewards  //@audit gas: should be unchecked (can't underflow due to L129) 134:             ); 135:         } 136:     } ```  ## `LPFarming.withdraw()`: L248 should be unchecked due to L243  See `@audit` tag:  ```solidity 235:     function withdraw(uint256 _pid, uint256 _amount) 236:         external 237:         noContract(msg.sender) 238:     { 239:         require(_amount > 0, "invalid_amount"); 240:  241:         PoolInfo storage pool = poolInfo[_pid]; 242:         UserInfo storage user = userInfo[_pid][msg.sender]; 243:         require(user.amount >= _amount, "insufficient_amount"); 244:  245:         _updatePool(_pid); 246:         _withdrawReward(_pid); 247:  248:         user.amount -= _amount;  //@audit gas: should be unchecked (can't underflow due to L243) ```  ## `LPFarming._withdrawReward()`: `poolInfo[_pid].accRewardPerShare` should get cached  The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, the storage value should get cached in memory (see the `@audit` tags for further details):  ```solidity 315:     function _withdrawReward(uint256 _pid) internal returns (uint256) { 316:         UserInfo storage user = userInfo[_pid][msg.sender]; 317:         uint256 pending = (user.amount * 318:             (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) / //@audit gas: SLOAD 1 poolInfo[_pid].accRewardPerShare 319:             1e36; 320:         if (pending > 0) { 321:             userRewards[msg.sender] += pending; 322:         } 323:  324:         user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare; //@audit gas: SLOAD 2 poolInfo[_pid].accRewardPerShare 325:  326:         return pending; 327:     } ```  ## `yVaultLPFarming.withdraw()`: L124 should be unchecked due to L119  See `@audit` tag:  ```solidity 117:     function withdraw(uint256 _amount) external noContract(msg.sender) { 118:         require(_amount > 0, "invalid_amount"); 119:         require(balanceOf[msg.sender] >= _amount, "insufficient_amount"); 120:  121:         _update(); 122:         _withdrawReward(msg.sender); 123:  124:         balanceOf[msg.sender] -= _amount;  //@audit gas: should be unchecked (can't underflow due to L119) ```  ## `yVaultLPFarming._withdrawReward()`: `accRewardPerShare` should get cached  See `@audit` tags:  ```solidity 177:     function _withdrawReward(address account) internal returns (uint256) { 178:         uint256 pending = (balanceOf[account] * 179:             (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36; //@audit gas: SLOAD 1 accRewardPerShare 180:  181:         if (pending > 0) userPendingRewards[account] += pending; 182:  183:         userLastAccRewardPerShare[account] = accRewardPerShare; //@audit gas: SLOAD 2 accRewardPerShare 184:  185:         return pending; 186:     } ```  ## `JPEGLock.unlock()`: use `storage` instead of copying struct in memory L69  See `@audit` tag:  ```solidity 68:     function unlock(uint256 _nftIndex) external nonReentrant { 69:         LockPosition memory position = positions[_nftIndex]; //@audit gas: costing 3 SLOADs while only lockAmount is needed twice. Replace "memory" with "storage" and cache only position.lockAmount  70:         require(position.owner == msg.sender, "unauthorized"); 71:         require(position.unlockAt <= block.timestamp, "locked"); 72:  73:         delete positions[_nftIndex]; 74:  75:         jpeg.safeTransfer(msg.sender, position.lockAmount); 76:  77:         emit Unlock(msg.sender, _nftIndex, position.lockAmount); 78:     } ```  Here, a copy in memory is costing 3 SLOADs and 3 MSTORES. The, 2 variables are only read once through MLOAD (`position.owner` and `position.unlockAt`) and one is read twice (`position.lockAmount`). I suggest replacing the `memory` keyword with `storage` at L69 and only copying `position.lockAmount` in memory.  ## `FungibleAssetVaultForDAO._collateralPriceUsd()`: `oracle` should get cached  See `@audit` tags:  ```solidity 104:     function _collateralPriceUsd() internal view returns (uint256) { 105:         int256 answer = oracle.latestAnswer();  //@audit gas: SLOAD 1 oracle 106:         uint8 decimals = oracle.decimals();  //@audit gas: SLOAD 2 oracle 107:  ```  ## `FungibleAssetVaultForDAO._collateralPriceUsd()`: return statement should be unchecked  See `@audit` tag:  ```solidity 104:     function _collateralPriceUsd() internal view returns (uint256) { ... 111:         return //@audit gas: whole return statement should be unchecked (obviously can't underflow/overflow here) 112:             decimals > 18 113:                 ? uint256(answer) / 10**(decimals - 18)   114:                 : uint256(answer) * 10**(18 - decimals);   115:     } ```  Due to the ternary condition and the fact that `int256 answer = oracle.latestAnswer();`, the return statement can't underflow and should be unchecked.  ## `FungibleAssetVaultForDAO.deposit()`: `collateralAsset` should get cached  See `@audit` tags:  ```solidity 141:     function deposit(uint256 amount) external payable onlyRole(WHITELISTED_ROLE) { 142:         require(amount > 0, "invalid_amount"); 143:  144:         if (collateralAsset == ETH) {  //@audit gas: SLOAD 1 collateralAsset 145:             require(msg.value == amount, "invalid_msg_value"); 146:         } else { 147:             require(msg.value == 0, "non_zero_eth_value"); 148:             IERC20Upgradeable(collateralAsset).safeTransferFrom(  //@audit gas: SLOAD 2 collateralAsset 149:                 msg.sender, 150:                 address(this), 151:                 amount 152:             ); 153:         } ```  ## `FungibleAssetVaultForDAO.repay)`: L184 should be unchecked due to L182  See `@audit` tag:  ```solidity 179:     function repay(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant { 180:         require(amount > 0, "invalid_amount"); 181:  182:         amount = amount > debtAmount ? debtAmount : amount; 183:  184:         debtAmount -= amount; //@audit gas: should be unchecked (can't underflow due to L182) ```  ## `FungibleAssetVaultForDAO.withdraw()`: L196 should be unchecked due to L194  See `@audit` tag:  ```solidity 193:     function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant { 194:         require(amount > 0 && amount <= collateralAmount, "invalid_amount"); 195:  196:         uint256 creditLimit = getCreditLimit(collateralAmount - amount); //@audit gas: should be unchecked (can't underflow due to L194) ```  ## `FungibleAssetVaultForDAO.withdraw()`: `collateralAmount` should get cached  See `@audit` tags:  ```solidity 193:     function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant { 194:         require(amount > 0 && amount <= collateralAmount, "invalid_amount");  //@audit gas: SLOAD 1 collateralAmount 195:  196:         uint256 creditLimit = getCreditLimit(collateralAmount - amount); //@audit gas: SLOAD 2 collateralAmount 197:         require(creditLimit >= debtAmount, "insufficient_credit"); 198:  199:         collateralAmount -= amount; //@audit gas: SLOAD 3 collateralAmount (could've used the a cached value for calculation) ```  ## `NFTVault._normalizeAggregatorAnswer()`: return statement should be unchecked  See `@audit` tag:  ```solidity 454:     function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator) 455:         internal 456:         view 457:         returns (uint256) 458:     { ... 464:         return //@audit gas: whole return statement should be unchecked (obviously can't underflow/overflow) 465:             decimals > 18 466:                 ? uint256(answer) / 10**(decimals - 18) 467:                 : uint256(answer) * 10**(18 - decimals); 468:     } ```  ## `NFTVault._calculateAdditionalInterest()`: `totalDebtAmount` should get cached  See `@audit` tags:  ```solidity 578:     function _calculateAdditionalInterest() internal view returns (uint256) { ... 585:         if (totalDebtAmount == 0) {  //@audit gas: SLOAD 1 totalDebtAmount 586:             return 0; 587:         } 588:  589:         // Accrue interest 590:         uint256 interestPerYear = (totalDebtAmount *  //@audit gas: SLOAD 2 totalDebtAmount ```  ## `NFTVault.sol`: `struct PositionPreview` can be tightly packed to save 1 storage slot  From (see `@audit` tags):  ```solidity 610:     struct PositionPreview { // @audit gas: can be tightly packed by moving borrowType and liquidatable at the end 611:         address owner; 612:         uint256 nftIndex; 613:         bytes32 nftType; 614:         uint256 nftValueUSD; 615:         VaultSettings vaultSettings; 616:         uint256 creditLimit; 617:         uint256 debtPrincipal; 618:         uint256 debtInterest; // @audit gas: 32 bytes 619:         BorrowType borrowType; // @audit gas: 1 byte (this enum is equivalent to uint8 as it has less than 256 options) 620:         bool liquidatable; // @audit gas: 1 byte 621:         uint256 liquidatedAt; // @audit gas: 32 bytes 622:         address liquidator; // @audit gas: 20 bytes 623:     } ```  To:  ```solidity     struct PositionPreview {         address owner;         uint256 nftIndex;         bytes32 nftType;         uint256 nftValueUSD;         VaultSettings vaultSettings;         uint256 creditLimit;         uint256 debtPrincipal;         uint256 debtInterest; // @audit gas: 32 bytes         uint256 liquidatedAt; // @audit gas: 32 bytes         BorrowType borrowType; // @audit gas: 1 byte (this enum is equivalent to uint8 as it has less than 256 options)         bool liquidatable; // @audit gas: 1 byte         address liquidator; // @audit gas: 20 bytes     } ```  ## `NFTVault.showPosition()`: L659 should be unchecked due to L649  See `@audit` tag:  ```solidity File: NFTVault.sol 628:     function showPosition(uint256 _nftIndex) ... 649:         if (debtPrincipal > debtAmount) debtAmount = debtPrincipal; ... 659:             debtInterest: debtAmount - debtPrincipal, //@audit gas: should be unchecked (can't underflow due to L649) ```  ## `NFTVault.showPosition()`: `positions[_nftIndex].liquidatedAt` should get cached  See `@audit` tags:  ```solidity File: NFTVault.sol 628:     function showPosition(uint256 _nftIndex) ... 661:             liquidatable: positions[_nftIndex].liquidatedAt == 0 &&  //@audit gas: SLOAD 1 positions[_nftIndex].liquidatedAt 662:                 debtAmount >= _getLiquidationLimit(_nftIndex), 663:             liquidatedAt: positions[_nftIndex].liquidatedAt,  //@audit gas: SLOAD 2 positions[_nftIndex].liquidatedAt ```  ## `NFTVault.showPosition()`: Help the optimizer by saving a storage variable's reference instead of repeatedly fetching it (`positions[_nftIndex]`)  To help the optimizer, declare a `storage` type variable and use it instead of repeatedly fetching the reference in a map or an array.  The effect can be quite significant.  Here, instead of repeatedly calling `positions[_nftIndex]`, save its reference like this: `Position storage _position = positions[_nftIndex]` and use it.  Impacted lines (see `@audit` tags):  ```solidity   636:         uint256 debtPrincipal = positions[_nftIndex].debtPrincipal; //@audit gas: use the suggested storage variable "Position storage _position"   637:         uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0 //@audit gas: use the suggested storage variable "Position storage _position"   638:             ? positions[_nftIndex].debtAmountForRepurchase //@audit gas: use the suggested storage variable "Position storage _position"   641:                 positions[_nftIndex].debtPortion, //@audit gas: use the suggested storage variable "Position storage _position"   660:             borrowType: positions[_nftIndex].borrowType, //@audit gas: use the suggested storage variable "Position storage _position"   661:             liquidatable: positions[_nftIndex].liquidatedAt == 0 && //@audit gas: use the suggested storage variable "Position storage _position"   663:             liquidatedAt: positions[_nftIndex].liquidatedAt, //@audit gas: use the suggested storage variable "Position storage _position"   664:             liquidator: positions[_nftIndex].liquidator //@audit gas: use the suggested storage variable "Position storage _position" ```  This practice already exists in the solution, as seen in `NFTVault.borrow()`:  ```solidity 675:     function borrow( ... 697:         Position storage position = positions[_nftIndex]; ```  ## `NFTVault.borrow()`: `totalDebtPortion` should get cached  See `@audit` tags:  ```solidity 675:     function borrow( ... 735:         if (totalDebtPortion == 0) {  //@audit gas: SLOAD 1 totalDebtPortion ... 738:         } else { 739:             uint256 plusPortion = (totalDebtPortion * _amount) / //@audit gas: SLOAD 2 totalDebtPortion 740:                 totalDebtAmount; 741:             totalDebtPortion += plusPortion; //@audit gas: SLOAD 3 totalDebtPortion (could've used cached value for calculation) ```  ## `NFTVault.repay()`: L781 should be unchecked due to ternary operator  See `@audit` tag:  ```solidity 756:     function repay(uint256 _nftIndex, uint256 _amount) ... 780:         uint256 paidPrincipal = _amount > debtInterest 781:             ? _amount - debtInterest //@audit gas: should be unchecked (obviously) 782:             : 0; ```  ## `NFTVault.repay()`: `totalDebtPortion` and `totalDebtAmount` should get cached  See `@audit` tags:  ```solidity 756:     function repay(uint256 _nftIndex, uint256 _amount) ... 784:         uint256 minusPortion = paidPrincipal == debtPrincipal 785:             ? position.debtPortion 786:             : (totalDebtPortion * _amount) / totalDebtAmount; //@audit gas: SLOADs 1 totalDebtPortion & totalDebtAmount 787:  788:         totalDebtPortion -= minusPortion; //@audit gas: SLOAD 2 totalDebtPortion (could've used cached value for calculation) ... 791:         totalDebtAmount -= _amount; //@audit gas: SLOAD 2 totalDebtAmount (could've used cached value for calculation) ```  ## `Controller.setStrategy()`: boolean comparison L87  Comparing to a constant (`true` or `false`) is a bit more expensive than directly checking the returned boolean value. I suggest using `if(directValue)` instead of `if(directValue == true)` and `if(!directValue)` instead of `if(directValue == false)` here (see `@audit` tag):  ```solidity 82:     function setStrategy(IERC20 _token, IStrategy _strategy) 83:         external 84:         onlyRole(STRATEGIST_ROLE) 85:     { 86:         require( 87:             approvedStrategies[_token][_strategy] == true, //@audit gas: instead of comparing to a constant, just use "approvedStrategies[_token][_strategy]" ```  ## `StrategyPUSDConvex.balanceOfJPEG()`: `jpeg` should get cached  See `@audit` tags:  ```solidity 226:     function balanceOfJPEG() external view returns (uint256) { 227:         uint256 availableBalance = jpeg.balanceOf(address(this)); //@audit gas: SLOAD 1 jpeg ... 231:         for (uint256 i = 0; i < length; i++) { ... 233:             if (address(jpeg) == extraReward.rewardToken()) { //@audit gas: SLOADs in Loop for jpeg. Cache it at L227 ```  ## `StrategyPUSDConvex.balanceOfJPEG()`: use a `return` statement instead of `break`  See `@audit` tag:  ```solidity 226:     function balanceOfJPEG() external view returns (uint256) { ... 231:         for (uint256 i = 0; i < length; i++) { ... 233:             if (address(jpeg) == extraReward.rewardToken()) { 234:                 availableBalance += extraReward.earned(); 235:                 //we found jpeg, no need to continue the loop 236:                 break; //@audit gas: instead of adding to availableBalance & breaking, just return here "availableBalance + extraReward.earned()" 237:             } 238:         } 239:  240:         return availableBalance; 241:     } ```  Here, instead of making a memory operation with `availableBalance += extraReward.earned();` and then using `break;` before returning the memory variable `availableBalance`, it would've been more optimized to just return `availableBalance + extraReward.earned()`:  ```solidity     function balanceOfJPEG() external view returns (uint256) { ...         for (uint256 i = 0; i < length; i++) { ...             if (address(jpeg) == extraReward.rewardToken()) {               return availableBalance + extraReward.earned();             }         }     } ```  ## `StrategyPUSDConvex.withdraw()`: L281 should be unchecked due to L279  See `@audit` tag:  ```solidity 273:     function withdraw(uint256 _amount) external onlyController { ... 279:         if (balance < _amount) 280:             convexConfig.baseRewardPool.withdrawAndUnwrap( 281:                 _amount - balance, //@audit gas: should be unchecked (can't underflow due to L279) 282:                 false 283:             ); ```  ## `StrategyPUSDConvex.harvest()`: L362 should be unchecked due to L359-L360 and how performanceFee is set L183  See `@audit` tags:  ```solidity 177:     function setPerformanceFee(Rate memory _performanceFee) ... 181:         require( 182:             _performanceFee.denominator > 0 && 183:                 _performanceFee.denominator >= _performanceFee.numerator, //@audit gas: can uncheck L362 thanks to this 184:             "INVALID_RATE" 185:         ); ... 311:     function harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) { ... 359:         uint256 fee = (usdcBalance * performanceFee.numerator) / 360:             performanceFee.denominator; 361:         usdc.safeTransfer(strategy.controller.feeAddress(), fee); 362:         usdcBalance -= fee; //@audit gas: should be unchecked (can't underflow due to L359-L360 & how performanceFee is set L183) ```  ## `yVault.earn()`: `token` and `controller` should get cached  See `@audit` tags:  ```solidity 129:     function earn() external { 130:         uint256 _bal = available(); 131:         token.safeTransfer(address(controller), _bal); //@audit gas: SLOADs 1 token & controller 132:         controller.earn(address(token), _bal); //@audit gas: SLOADs 2 token & controller 133:     } ```  ## `yVault.withdraw()`: L178 should be unchecked due to L177  See `@audit` tag:  ```solidity 166:     function withdraw(uint256 _shares) public noContract(msg.sender) { ... 177:         if (vaultBalance < backingTokens) { 178:             uint256 toWithdraw = backingTokens - vaultBalance; //@audit gas: should be unchecked (can't underflow due to L177) ```  ## `yVault.withdraw()`: `token` should get cached  See `@audit` tags:  ```solidity 166:     function withdraw(uint256 _shares) public noContract(msg.sender) { ... 176:         uint256 vaultBalance = token.balanceOf(address(this)); //@audit gas: SLOAD 1 token 177:         if (vaultBalance < backingTokens) { 178:             uint256 toWithdraw = backingTokens - vaultBalance; 179:             controller.withdraw(address(token), toWithdraw);  //@audit gas: SLOAD 2 token 180:         } 181:  182:         token.safeTransfer(msg.sender, backingTokens);  //@audit gas: SLOAD 3 token ```  ## `yVault.withdrawJPEG()`: `farm` should get cached  See `@audit` tags:  ```solidity 187:     function withdrawJPEG() external { 188:         require(farm != address(0), "NO_FARM");  //@audit gas: SLOAD 1 farm 189:         controller.withdrawJPEG(address(token), farm);  //@audit gas: SLOAD 2 farm 190:     } ```  ## Upgrade pragma to at least 0.8.4  Across the whole solution, the declared pragma is `^0.8.0`.  Using newer compiler versions and the optimizer give gas optimizations. Also, additional safety checks are available for free.  The advantages here are:  - **Low level inliner** (>= 0.8.2): Cheaper runtime gas (especially relevant when the contract has small functions). - **Optimizer improvements in packed structs** (>= 0.8.3) - **Custom errors** (>= 0.8.4): cheaper deployment cost and runtime cost. *Note*: the runtime cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.  Consider upgrading pragma to at least 0.8.4:  ## No need to explicitly initialize variables with default values  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Instances include:    ```solidity farming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) { farming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) { vaults/FungibleAssetVaultForDAO.sol:45:    address internal constant ETH = address(0); vaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) { vaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) { ```  I suggest removing explicit initializations for default values.  ## `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  I suggest changing `> 0` with `!= 0` here:  ```solidity farming/LPFarming.sol:114:        require(_rewardPerBlock > 0, "Invalid reward per block"); farming/LPFarming.sol:218:        require(_amount > 0, "invalid_amount"); farming/LPFarming.sol:239:        require(_amount > 0, "invalid_amount"); farming/LPFarming.sol:337:        require(rewards > 0, "no_reward"); farming/LPFarming.sol:354:        require(rewards > 0, "no_reward"); farming/yVaultLPFarming.sol:101:        require(_amount > 0, "invalid_amount"); farming/yVaultLPFarming.sol:118:        require(_amount > 0, "invalid_amount"); farming/yVaultLPFarming.sol:139:        require(rewards > 0, "no_reward"); lock/JPEGLock.sol:40:        require(_newTime > 0, "Invalid lock time"); staking/JPEGStaking.sol:32:        require(_amount > 0, "invalid_amount"); vaults/yVault/strategies/StrategyPUSDConvex.sol:182:            _performanceFee.denominator > 0 && vaults/yVault/strategies/StrategyPUSDConvex.sol:334:            require(wethBalance > 0, "NOOP"); vaults/yVault/yVault.sol:100:            _rate.numerator > 0 && _rate.denominator >= _rate.numerator, vaults/yVault/yVault.sol:143:        require(_amount > 0, "INVALID_AMOUNT"); vaults/yVault/yVault.sol:167:        require(_shares > 0, "INVALID_AMOUNT"); vaults/yVault/yVault.sol:170:        require(supply > 0, "NO_TOKENS_DEPOSITED"); vaults/FungibleAssetVaultForDAO.sol:94:            _creditLimitRate.denominator > 0 && vaults/FungibleAssetVaultForDAO.sol:108:        require(answer > 0, "invalid_oracle_answer"); vaults/FungibleAssetVaultForDAO.sol:142:        require(amount > 0, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:164:        require(amount > 0, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:180:        require(amount > 0, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:194:        require(amount > 0 && amount <= collateralAmount, "invalid_amount"); vaults/NFTVault.sol:278:        require(_newFloor > 0, "Invalid floor"); vaults/NFTVault.sol:327:            _type == bytes32(0) || nftTypeValueETH[_type] > 0, vaults/NFTVault.sol:365:        require(pendingValue > 0, "no_pending_value"); vaults/NFTVault.sol:402:            rate.denominator > 0 && rate.denominator >= rate.numerator, vaults/NFTVault.sol:462:        require(answer > 0, "invalid_oracle_answer"); vaults/NFTVault.sol:687:        require(_amount > 0, "invalid_amount"); vaults/NFTVault.sol:764:        require(_amount > 0, "invalid_amount"); vaults/NFTVault.sol:770:        require(debtAmount > 0, "position_not_borrowed"); vaults/NFTVault.sol:882:        require(position.liquidatedAt > 0, "not_liquidated"); vaults/NFTVault.sol:926:        require(position.liquidatedAt > 0, "not_liquidated"); ```  Also, please enable the Optimizer.  ## `>=` is cheaper than `>`  Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)    I suggest using  `>=`  instead of `>` to avoid some opcodes here:  ```solidity vaults/NFTVault.sol:539:        return principal > calculatedDebt ? principal : calculatedDebt; vaults/NFTVault.sol:775:        _amount = _amount > debtAmount ? debtAmount : _amount; ```  ## An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead:  ```solidity farming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) { vaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) { vaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) { ```  This is already done here:  ```solidity farming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) { vaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) { ```  ## `++i` costs less gas compared to `i++` or `i += 1`  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:      ```solidity uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ```solidity uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:    ```solidity farming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) { vaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) { vaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) { ```  I suggest using `++i` instead of `i++` to increment the value of an uint variable.  This is already done here:  ```solidity farming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) { ```  ## Increments can be unchecked  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Instances include:    ```solidity farming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) { farming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) { vaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) { vaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) { ```  The code would go from:      ```solidity for (uint256 i; i < numIterations; i++) {    // ...   }   ```  to:    ```solidity for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ```  The risk of overflow is inexistant for a `uint256` here.  ## Use `calldata` instead of `memory`  When arguments are read-only on external functions, the data location should be `calldata`:  ```solidity contracts/vaults/NFTVault.sol:   212:     function setDebtInterestApr(Rate memory _debtInterestApr) //@audit gas: should be calldata   222:     function setValueIncreaseLockRate(Rate memory _valueIncreaseLockRate)  //@audit gas: should be calldata   232:     function setCreditLimitRate(Rate memory _creditLimitRate)  //@audit gas: should be calldata   247:     function setLiquidationLimitRate(Rate memory _liquidationLimitRate)  //@audit gas: should be calldata   290:     function setOrganizationFeeRate(Rate memory _organizationFeeRate)  //@audit gas: should be calldata   300:     function setInsurancePurchaseRate(Rate memory _insurancePurchaseRate)  //@audit gas: should be calldata   311:         Rate memory _insuranceLiquidationPenaltyRate  //@audit gas: should be calldata ```  ## Consider making some constants as non-public to save gas  Reducing from `public` to `private` or `internal` can save gas when a constant isn't used outside of its contract. I suggest changing the visibility from `public` to `internal` or `private` here:  ```solidity tokens/JPEG.sol:10:    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE"); tokens/StableCoin.sol:22:    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE"); tokens/StableCoin.sol:23:    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE"); vaults/yVault/strategies/StrategyPUSDConvex.sol:66:    bytes32 public constant STRATEGIST_ROLE = keccak256("STRATEGIST_ROLE"); vaults/yVault/Controller.sol:15:    bytes32 public constant STRATEGIST_ROLE = keccak256("STRATEGIST_ROLE"); vaults/FungibleAssetVaultForDAO.sol:41:    bytes32 public constant WHITELISTED_ROLE = keccak256("WHITELISTED_ROLE"); vaults/NFTVault.sol:71:    bytes32 public constant DAO_ROLE = keccak256("DAO_ROLE"); vaults/NFTVault.sol:72:    bytes32 public constant LIQUIDATOR_ROLE = keccak256("LIQUIDATOR_ROLE"); vaults/NFTVault.sol:74:    bytes32 public constant CUSTOM_NFT_HASH = keccak256("CUSTOM"); ```  ## Public functions to external  The following functions could be set external to save gas and improve code quality. External call cost is less expensive than of public functions.  ```solidity withdraw(IERC20,uint256) should be declared external:  - Controller.withdraw(IERC20,uint256) (contracts/vaults/yVault/Controller.sol#151-154) setFarmingPool(address) should be declared external:  - YVault.setFarmingPool(address) (contracts/vaults/yVault/yVault.sol#115-118) ```  ## Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity tokens/JPEG.sol:23:            "JPEG: must have minter role to mint" tokens/StableCoin.sol:41:            "StableCoin: must have minter role to mint" tokens/StableCoin.sol:55:            "StableCoin: must have pauser role to pause" tokens/StableCoin.sol:69:            "StableCoin: must have pauser role to unpause" vaults/NFTVault.sol:394:            "credit_rate_exceeds_or_equals_liquidation_rate"  ```  I suggest shortening the revert strings to fit in 32 bytes, or using custom errors as described next.  ## Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  ```solidity escrow/NFTEscrow.sol:18:        require(success, "FlashEscrow: call_failed"); escrow/NFTEscrow.sol:86:        require( farming/LPFarming.sol:86:        require( farming/LPFarming.sol:112:        require(_startBlock >= block.number, "Invalid start block"); farming/LPFarming.sol:113:        require(_endBlock > _startBlock, "Invalid end block"); farming/LPFarming.sol:114:        require(_rewardPerBlock > 0, "Invalid reward per block"); farming/LPFarming.sol:218:        require(_amount > 0, "invalid_amount"); farming/LPFarming.sol:239:        require(_amount > 0, "invalid_amount"); farming/LPFarming.sol:243:        require(user.amount >= _amount, "insufficient_amount"); farming/LPFarming.sol:337:        require(rewards > 0, "no_reward"); farming/LPFarming.sol:354:        require(rewards > 0, "no_reward"); farming/yVaultLPFarming.sol:42:        require(_vault != address(0), "INVALID_VAULT"); farming/yVaultLPFarming.sol:43:        require(_jpeg != address(0), "INVALID_JPEG"); farming/yVaultLPFarming.sol:55:        require( farming/yVaultLPFarming.sol:101:        require(_amount > 0, "invalid_amount"); farming/yVaultLPFarming.sol:118:        require(_amount > 0, "invalid_amount"); farming/yVaultLPFarming.sol:119:        require(balanceOf[msg.sender] >= _amount, "insufficient_amount"); farming/yVaultLPFarming.sol:139:        require(rewards > 0, "no_reward"); helpers/CryptoPunksHelper.sol:79:        require( helpers/EtherRocksHelper.sol:81:        require( lock/JPEGLock.sol:40:        require(_newTime > 0, "Invalid lock time"); lock/JPEGLock.sol:70:        require(position.owner == msg.sender, "unauthorized"); lock/JPEGLock.sol:71:        require(position.unlockAt <= block.timestamp, "locked"); staking/JPEGStaking.sol:32:        require(_amount > 0, "invalid_amount"); staking/JPEGStaking.sol:45:        require( tokens/JPEG.sol:21:        require( tokens/StableCoin.sol:39:        require( tokens/StableCoin.sol:53:        require( tokens/StableCoin.sol:67:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:108:        require(_want != address(0), "INVALID_WANT"); vaults/yVault/strategies/StrategyPUSDConvex.sol:109:        require(_jpeg != address(0), "INVALID_JPEG"); vaults/yVault/strategies/StrategyPUSDConvex.sol:110:        require(_pusd != address(0), "INVALID_PUSD"); vaults/yVault/strategies/StrategyPUSDConvex.sol:111:        require(_weth != address(0), "INVALID_WETH"); vaults/yVault/strategies/StrategyPUSDConvex.sol:112:        require(_usdc != address(0), "INVALID_USDC"); vaults/yVault/strategies/StrategyPUSDConvex.sol:113:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:117:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:121:        require(address(_curveConfig.curve) != address(0), "INVALID_CURVE"); vaults/yVault/strategies/StrategyPUSDConvex.sol:122:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:126:        require(_curveConfig.pusdIndex < 4, "INVALID_PUSD_CURVE_INDEX"); vaults/yVault/strategies/StrategyPUSDConvex.sol:127:        require(_curveConfig.usdcIndex < 4, "INVALID_USDC_CURVE_INDEX"); vaults/yVault/strategies/StrategyPUSDConvex.sol:128:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:132:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:136:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:140:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:146:            require( vaults/yVault/strategies/StrategyPUSDConvex.sol:168:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:181:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:195:        require(_controller != address(0), "INVALID_CONTROLLER"); vaults/yVault/strategies/StrategyPUSDConvex.sol:205:        require(_vault != address(0), "INVALID_USDC_VAULT"); vaults/yVault/strategies/StrategyPUSDConvex.sol:262:        require(want != _asset, "want"); vaults/yVault/strategies/StrategyPUSDConvex.sol:263:        require(pusd != _asset, "pusd"); vaults/yVault/strategies/StrategyPUSDConvex.sol:264:        require(usdc != _asset, "usdc"); vaults/yVault/strategies/StrategyPUSDConvex.sol:265:        require(weth != _asset, "weth"); vaults/yVault/strategies/StrategyPUSDConvex.sol:266:        require(jpeg != _asset, "jpeg"); vaults/yVault/strategies/StrategyPUSDConvex.sol:275:        require(vault != address(0), "ZERO_VAULT"); // additional protection so we don't burn the funds vaults/yVault/strategies/StrategyPUSDConvex.sol:292:        require(vault != address(0), "ZERO_VAULT"); // additional protection so we don't burn the funds vaults/yVault/strategies/StrategyPUSDConvex.sol:334:            require(wethBalance > 0, "NOOP"); vaults/yVault/Controller.sol:37:        require(_feeAddress != address(0), "INVALID_FEE_ADDRESS"); vaults/yVault/Controller.sol:48:        require(vaults[_token] == address(0), "ALREADY_HAS_VAULT"); vaults/yVault/Controller.sol:49:        require(_vault != address(0), "INVALID_VAULT"); vaults/yVault/Controller.sol:60:        require(address(_token) != address(0), "INVALID_TOKEN"); vaults/yVault/Controller.sol:61:        require(address(_strategy) != address(0), "INVALID_STRATEGY"); vaults/yVault/Controller.sol:73:        require(address(_token) != address(0), "INVALID_TOKEN"); vaults/yVault/Controller.sol:74:        require(address(_strategy) != address(0), "INVALID_STRATEGY"); vaults/yVault/Controller.sol:86:        require( vaults/yVault/Controller.sol:152:        require(msg.sender == vaults[_token], "NOT_VAULT"); vaults/yVault/Controller.sol:164:        require(msg.sender == vaults[_token], "NOT_VAULT"); vaults/yVault/yVault.sol:62:        require( vaults/yVault/yVault.sol:99:        require( vaults/yVault/yVault.sol:109:        require(_controller != address(0), "INVALID_CONTROLLER"); vaults/yVault/yVault.sol:116:        require(_farm != address(0), "INVALID_FARMING_POOL"); vaults/yVault/yVault.sol:143:        require(_amount > 0, "INVALID_AMOUNT"); vaults/yVault/yVault.sol:167:        require(_shares > 0, "INVALID_AMOUNT"); vaults/yVault/yVault.sol:170:        require(supply > 0, "NO_TOKENS_DEPOSITED"); vaults/yVault/yVault.sol:188:        require(farm != address(0), "NO_FARM"); vaults/FungibleAssetVaultForDAO.sol:93:        require( vaults/FungibleAssetVaultForDAO.sol:108:        require(answer > 0, "invalid_oracle_answer"); vaults/FungibleAssetVaultForDAO.sol:142:        require(amount > 0, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:145:            require(msg.value == amount, "invalid_msg_value"); vaults/FungibleAssetVaultForDAO.sol:147:            require(msg.value == 0, "non_zero_eth_value"); vaults/FungibleAssetVaultForDAO.sol:164:        require(amount > 0, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:168:        require(newDebtAmount <= creditLimit, "insufficient_credit"); vaults/FungibleAssetVaultForDAO.sol:180:        require(amount > 0, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:194:        require(amount > 0 && amount <= collateralAmount, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:197:        require(creditLimit >= debtAmount, "insufficient_credit"); vaults/NFTVault.sol:118:        require(nftContract.ownerOf(nftIndex) != address(0), "invalid_nft"); vaults/NFTVault.sol:278:        require(_newFloor > 0, "Invalid floor"); vaults/NFTVault.sol:326:        require( vaults/NFTVault.sol:365:        require(pendingValue > 0, "no_pending_value"); vaults/NFTVault.sol:391:        require( vaults/NFTVault.sol:401:        require( vaults/NFTVault.sol:462:        require(answer > 0, "invalid_oracle_answer"); vaults/NFTVault.sol:682:        require( vaults/NFTVault.sol:687:        require(_amount > 0, "invalid_amount"); vaults/NFTVault.sol:688:        require( vaults/NFTVault.sol:698:        require(position.liquidatedAt == 0, "liquidated"); vaults/NFTVault.sol:699:        require( vaults/NFTVault.sol:710:        require(debtAmount + _amount <= creditLimit, "insufficient_credit"); vaults/NFTVault.sol:763:        require(msg.sender == positionOwner[_nftIndex], "unauthorized"); vaults/NFTVault.sol:764:        require(_amount > 0, "invalid_amount"); vaults/NFTVault.sol:767:        require(position.liquidatedAt == 0, "liquidated"); vaults/NFTVault.sol:770:        require(debtAmount > 0, "position_not_borrowed"); vaults/NFTVault.sol:805:        require(msg.sender == positionOwner[_nftIndex], "unauthorized"); vaults/NFTVault.sol:806:        require(_getDebtAmount(_nftIndex) == 0, "position_not_repaid"); vaults/NFTVault.sol:839:        require(posOwner != address(0), "position_not_exist"); vaults/NFTVault.sol:842:        require(position.liquidatedAt == 0, "liquidated"); vaults/NFTVault.sol:845:        require( vaults/NFTVault.sol:881:        require(msg.sender == positionOwner[_nftIndex], "unauthorized"); vaults/NFTVault.sol:882:        require(position.liquidatedAt > 0, "not_liquidated"); vaults/NFTVault.sol:883:        require( vaults/NFTVault.sol:887:        require( vaults/NFTVault.sol:925:        require(address(0) != owner, "no_position"); vaults/NFTVault.sol:926:        require(position.liquidatedAt > 0, "not_liquidated"); vaults/NFTVault.sol:927:        require( vaults/NFTVault.sol:932:        require(position.liquidator == msg.sender, "unauthorized"); ```  I suggest replacing revert strings with custom errors. 
1. It was found some `transfer` or `transferFrom` without checking the boolean result, ERC20 standard specify that the token can return false if this call was not made, so it's mandatory to check the result of approve methods. - [NFTVault.sol#L899](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L899) - [JPEGStaking.sol#L34](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/staking/JPEGStaking.sol#L34) - [JPEGStaking.sol#L52](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/staking/JPEGStaking.sol#L52)  2. Lack of input checks. - [LPFarming.sol#L77](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L77) 
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L144-L145   # Vulnerability details  ## Impact In `deposit`, the balance is cached and then a `token.transferFrom` is triggered which can lead to exploits if the `token` is a token that gives control to the sender, like ERC777 tokens.  #### POC Initial state: `balance() = 1000`, shares `supply = 1000`. Depositing 1000 amount should mint 1000 supply, but one can split the 1000 amounts into two 500 deposits and use re-entrancy to profit.  - Outer `deposit(500)`: `balanceBefore = 1000`. Control is given to attacker ... - Inner `deposit(500)`: `balanceBefore = 1000`. `shares = (_amount * supply) / balanceBefore = 500 * 1000 / 1000 = 500` shares are minted ... - Outer `deposit(500)` continues with the mint: `shares = (_amount * supply) / balanceBefore = 500 * 1500 / 1000 = 750` are minted. - Withdrawing the `500 + 750 = 1250` shares via `withdraw(1250)`, the attacker receives `backingTokens = (balance() * _shares) / supply = 2000 * 1250 / 2250 = 1111.111111111`. The attacker makes a profit of `1111 - 1000 = 111` tokens. - They repeat the attack until the vault is drained.  ## Recommended Mitigation Steps The `safeTransferFrom` should be the last call in `deposit`.   
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L799   # Vulnerability details  ## Impact The owner of an **insured** position that has been liquidated can claim back their NFT without paying back the debt by calling `closePosition` instead of `repurchase`.  ```solidity function closePosition(uint256 _nftIndex)     external     // @audit NFT is still valid (ownerOf(nft) == this)     validNFTIndex(_nftIndex) {     accrue();     // @audit owner is still original owner (depositor)     require(msg.sender == positionOwner[_nftIndex], "unauthorized");     // @audit debt is zero as it's been repaid by liquidator     require(_getDebtAmount(_nftIndex) == 0, "position_not_repaid");      positionOwner[_nftIndex] = address(0);     delete positions[_nftIndex];     positionIndexes.remove(_nftIndex);      // transfer nft back to owner if nft was deposited     if (nftContract.ownerOf(_nftIndex) == address(this)) {         nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);     }      emit PositionClosed(msg.sender, _nftIndex); } ```  The `liquidate` function sets `position.debtPortion = 0;` and does not clear the `owner` which means all `closePosition` checks pass. This means that PUSD can be minted for free by:  - Attacker deposits NFT collateral in insured state and borrow PUSD against it - Let it be liquidated (the liquidator unexpectedly loses as they cannot get the NFT through `claimExpiredInsuranceNFT` anymore) - Attacker claims it back through `closePosition` - Repeat  ## Recommended Mitigation Steps Consider checking in `closePosition` that the position has not been liquidated.   
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L212   # Vulnerability details  ## Impact The `setDebtInterestApr` changes the debt interest rate without first accruing the debt. This means that the new debt interest rate is applied retroactively to the unaccrued period on next `accrue()` call.  It should never be applied retroactively to a previous time window as this is unfair & wrong. Borrowers can incur more debt than they should.  ## Recommended Mitigation Steps Call `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`.  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/Controller.sol#L95 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L266   # Vulnerability details  ## Details  The controller calls the `withdraw()` method to withdraw JPEGs from the contract, but the strategy might blacklist the JPEG asset, which is what the PUSDConvex strategy has done.  The migration would therefore revert.  ## Proof of Concept  Insert this test into [`StrategyPUSDConvex.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/StrategyPUSDConvex.ts).  ```jsx it.only("will revert when attempting to migrate strategy", async () => {   await controller.setVault(want.address, yVault.address);   await expect(controller.setStrategy(want.address, strategy.address)).to.be.revertedWith("jpeg"); }); ```  ## Recommended Mitigation Steps  Replace `_current.withdraw(address(jpeg));` with `_current.withdrawJPEG(vaults[_token])`.  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/yVaultLPFarming.sol#L169-L170   # Vulnerability details  ## Details & Impact  yVault users participating in the farm have to trust that:  - `vault.balanceOfJPEG()`  returns the correct claimable JPEG amount by its strategy / strategies - the strategy / strategies will send all claimable JPEG to the farm  Should either of these assumptions break, then it could be possibly be the case that `currentBalance` is less than `previousBalance`, causing deposits and crucially, withdrawals to fail due to subtraction overflow.  ## Proof of Concept  For instance,   - Farm migration occurs. A new farm is set in `yVault`, then `withdrawJPEG()` is called, which sends funds to the new farm. Users of the old farm would be unable to withdraw their deposits.  ```jsx it.only("will revert old farms' deposits and withdrawals if yVault migrates farm", async () => {   // 0. setup   await token.mint(owner.address, units(1000));   await token.approve(yVault.address, units(1000));   await yVault.depositAll();   await yVault.approve(lpFarming.address, units(1000));   // send some JPEG to strategy prior to deposit   await jpeg.mint(strategy.address, units(100));   // deposit twice, so that the second deposit will invoke _update()   await lpFarming.deposit(units(250));   await lpFarming.deposit(units(250));     // 1. change farm and call withdrawJPEG()   await yVault.setFarmingPool(user1.address);   await yVault.withdrawJPEG();     // deposit and withdrawal will fail   await expect(lpFarming.deposit(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');   await expect(lpFarming.withdraw(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)'); }); ```  - Strategy migration occurs, but JPEG funds held by the old strategy were not claimed, causing `vault.balanceOfJPEG()` to report a smaller amount than previously recorded - `jpeg` could be accidentally included in the StrategyConfig, resulting in JPEG being converted to other assets - A future implementation takes a fee on the `jpeg` to be claimed  ## Recommended Mitigation Steps  A simple fix would be to `return` if `currentBalance ≤ previousBalance`. A full fix would properly handle potential shortfall.  ```jsx if (currentBalance <= previousBalance) return; ```  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L105   # Vulnerability details  ## Impact Price can be stale and can lead to wrong `answer` return value.  ## Proof of Concept Oracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong  `answer`  return value.  ``` function _collateralPriceUsd() internal view returns (uint256) {         int256 answer = oracle.latestAnswer();         uint8 decimals = oracle.decimals();          require(answer > 0, "invalid_oracle_answer");          ...  ```  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L105  ## Tools Used Manual review ## Recommended Mitigation Steps Validate data feed  ``` function _collateralPriceUsd() internal view returns (uint256) {  (uint80 roundID, int256 answer, , uint256 timestamp, uint80 answeredInRound) = oracle.latestRoundData();         require(answer > 0, "invalid_oracle_answer");     require(answeredInRound >= roundID, "ChainLink: Stale price");     require(timestamp > 0, "ChainLink: Round not complete");           ...  ```  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L201   # Vulnerability details  ## Impact  Function `FungibleAssetVaultForDAO.withdraw` in line 201 uses native `transfer` function to send ETH to `msg.sender`.  This is unsafe as transfer has hard coded gas budget (2300 gas) and can fail when the user is a smart contract. Especially when this contract is for DAO and ecosystem contracts as documentation.   ## Proof-of-concept https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L201   ## Tools Used Manual code review  ## Recommended Mitigation Steps  All functions have a `nonReentrant` modifier already, so reentrancy is not an issue and `transfer()` can be replaced.  Using low-level call.value(amount) with the corresponding result check or using the OpenZeppelin Address.sendValue is advised https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60   
https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/JPEG.sol#L20 Consider added valid check for the to address. The to address can be of a contract or another token or user. See below test code to replicate the behavior it("should return the correct JPEG balance", async () => {     await controller.approveStrategy(token.address, strategy.address);     await controller.setStrategy(token.address, strategy.address);     await jpeg.mint(token.address, units(500)); --- the to address can be any address.     expect(await controller.balanceOfJPEG(token.address)).to.equal(units(500)); });  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L115 setFarmingPool is declared public but not called from within the contract. Consider makin it external. Public visiility will persist the parameters which can incurr as fees.  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L35 The whitelistedContractMap is not necessary. It can be an address array. If contract is whitelisted, then add to array, if not, remove it. Removing the extra flag will save some space in the contract.  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L187 Function withdrawJPEG() seems duplicate of Controller.withdrawJPEG() and is not necessay. Remove the function or make it a utility.  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L61 Modifier noContract() is duplicated, can be abstracted out  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L89 setContractWhitelisted is duplicated, can be abstracted out
Use ```assert``` instead of ```require``` https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/helpers/CryptoPunksHelper.sol#L79 https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/helpers/EtherRocksHelper.sol#L81   ## proof of concept  https://ethereum.stackexchange.com/questions/15166/difference-between-require-and-assert-and-the-difference-between-revert-and-thro 
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L190   # Vulnerability details  ## Impact ###### LpFarming.sol reward will be locked in the farming, when user execute a direct transfer with lpToken to farm without using deposit    ## Proof of Concept "pls add this test to LpFarming.ts to check"   ``` it("a part of rewards can't be distributed if user execute a direct transfer to farm", async() => {       // manual mine new block         await network.provider.send("evm_setAutomine", [false]);        // prepare        const attacker = bob;       await lpTokens[0].transfer(alice.address, units(1000));       await lpTokens[0].transfer(attacker.address, units(1000));       await lpTokens[0].connect(alice).approve(farming.address, units(1000));       await mineBlocks(1);        // attacker direct deposit lp token to the pool        await lpTokens[0].connect(attacker).transfer(farming.address, units(100));        // create new pool       await farming.add(10, lpTokens[0].address);       await mineBlocks(1);       expect(await farming.poolLength()).to.equal(1);        let pool = await farming.poolInfo(0);       expect(pool.lpToken).to.equal(lpTokens[0].address);       expect(pool.allocPoint).to.equal(10);        // create new epoch ==> balance of pool will be 1000        let blockNumber = await ethers.provider.getBlockNumber();       await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);        // alice deposit        await farming.connect(alice).deposit(0, units(100));       await mineBlocks(1);        expect(await jpeg.balanceOf(farming.address)).to.equal(1000);        // when pool end, alice can just take 500 jpeg, and 500 jpeg will be locked in the contract forever !!!       await mineBlocks(13);       console.log("reward of alice: ", (await   farming.pendingReward(0, alice.address)).toString());       expect(await farming.pendingReward(0, alice.address)).to.equal(BigNumber.from('500'));     }); ``` In the test above, the attacker transfers 100 lpToken to the farm without using deposit function, and alice deposit 100 lpToken. Because the contract uses ```pool.lpToken.balanceOf(address(this))``` to get the total supply of lpToken in the pool, it will sum up 100 lpToken of attacker and 100 lpToken of alice. This will lead to the situation where Alice will only be able to claim 500 token (at epoch.endBlock), the rest will be locked in the pool forever. Not only with this pool, it also affects the following, a part of the reward will be locked in the pool when the farm end.  ## Tools Used typescript   ## Recommended Mitigation Steps Declare a new variable ```totalLPSupply``` to the struct ```PoolInfo```, and use it instead of ```pool.lpToken.balanceOf(address(this))```   
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L148-L153   # Vulnerability details  ## Details  The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.  ## Proof of Concept  - Attacker deposits 1 wei to mint 1 share - Attacker transfers exorbitant amount to the `StrategyPUSDConvex` contract to greatly inflate the share’s price. Note that the strategy deposits its entire balance into Convex when its `deposit()` function is called. - Subsequent depositors instead have to deposit an equivalent sum to avoid minting 0 shares. Otherwise, their deposits accrue to the attacker who holds the only share.  Insert this test into [`yVault.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/yVault.ts).  ```jsx it.only("will cause 0 share issuance", async () => {   // mint 10k + 1 wei tokens to user1   // mint 10k tokens to owner   let depositAmount = units(10_000);   await token.mint(user1.address, depositAmount.add(1));   await token.mint(owner.address, depositAmount);   // token approval to yVault   await token.connect(user1).approve(yVault.address, 1);   await token.connect(owner).approve(yVault.address, depositAmount);      // 1. user1 mints 1 wei = 1 share   await yVault.connect(user1).deposit(1);      // 2. do huge transfer of 10k to strategy   // to greatly inflate share price (1 share = 10k + 1 wei)   await token.connect(user1).transfer(strategy.address, depositAmount);      // 3. owner deposits 10k   await yVault.connect(owner).deposit(depositAmount);   // receives 0 shares in return   expect(await yVault.balanceOf(owner.address)).to.equal(0);    // user1 withdraws both his and owner's deposits   // total amt: 20k + 1 wei   await expect(() => yVault.connect(user1).withdrawAll())     .to.changeTokenBalance(token, user1, depositAmount.mul(2).add(1)); }); ```  ## Recommended Mitigation Steps  - [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. - Ensure the number of shares to be minted is non-zero: `require(_shares != 0, "zero shares minted");`  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/vaults/yVault/yVault.sol#L61 https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/farming/yVaultLPFarming.sol#L54 https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/vaults/yVault/yVault.sol#L61   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  The expectation of the noContract modifier is to allow access only to accounts inside EOA or Whitelist, if access is controlled using ! access control with _account.isContract(), then because isContract() gets the size of the code length of the account in question by relying on extcodesize/address.code.length, this means that the restriction can be bypassed when deploying a smart contract through the smart contract's constructor call.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps  Modify the code to `require(msg.sender == tx.origin);`  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L375 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/lock/JPEGLock.sol#L54-L62   # Vulnerability details  ## Details & Impact  A user’s JPEG lock schedule can be overwritten by another user’s if he (the other user) submits and finalizes a proposal to change the same NFT index’s value.  The existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.  ## Proof of Concept  1. `user` successfully proposes and finalizes a proposal to change his NFT’s collateral value 2. Another user (`owner`) does the same for the same NFT index 3. `user` will be unable to withdraw his locked JPEG because schedule has been overwritten  Insert this test case into [`NFTVault.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/NFTVault.ts).  ```jsx it.only("will overwrite existing user's JPEG lock schedule", async () => {   // 0. setup   const index = 7000;   await erc721.mint(user.address, index);   await nftVault     .connect(dao)     .setPendingNFTValueETH(index, units(50));   await jpeg.transfer(user.address, units(150000));   await jpeg.connect(user).approve(locker.address, units(500000));   await jpeg.connect(owner).approve(locker.address, units(500000));    // 1. user has JPEG locked for finalization   await nftVault.connect(user).finalizePendingNFTValueETH(index);    // 2. owner submit proposal to further increase NFT value   await nftVault     .connect(dao)     .setPendingNFTValueETH(index, units(100));      // 3. owner finalizes, has JPEG locked   await nftVault.connect(owner).finalizePendingNFTValueETH(index);    // user schedule has been overwritten   let schedule = await locker.positions(index);   expect(schedule.owner).to.equal(owner.address);    // user tries to unstake   // wont be able to because schedule was overwritten   await timeTravel(days(366));   await expect(locker.connect(user).unlock(index)).to.be.revertedWith("unauthorized"); }); ```  ## Recommended Mitigation Steps  1. Release the tokens of the existing schedule. Simple and elegant.  ```jsx // in JPEGLock#lockFor() LockPosition memory existingPosition = positions[_nftIndex]; if (existingPosition.owner != address(0)) {   // release jpegs to existing owner   jpeg.safeTransfer(existingPosition.owner, existingPosition.lockAmount); } ```  2. Revert in `finalizePendingNFTValueETH()` there is an existing lock schedule. This is less desirable IMO, as there is a use-case for increasing / decreasing the NFT value.  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L675 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L560   # Vulnerability details  ## Impact In `NFTVault.sol` the `borrow()` function does not follow the Checks Effects Interactions pattern. There are important state updates that occur after an external call which happens in `_openPosition()`.  Assuming that the `nonReentrant` modifier makes this ok is false due to the threat of cross function reentrancy. `require` checks should be done followed by state updates and then any external calls in accord with the Checks Effects Interactions pattern  ## Proof of Concept  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L675  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L560  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  ## Tools Used Manual code review   ## Recommended Mitigation Steps The `borrow()` function should fully implement the Checks Effects Interactions pattern performing all external calls last and not making important state updates after external calls.   
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/FungibleAssetVaultForDAO.sol#L105   # Vulnerability details  ## Impact According to Chainlink's documentation, the latestAnswer function is deprecated. This function might suddenly stop working if Chainlink stop supporting deprecated APIs. And the old API can return stale data.  ## Proof of Concept https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/FungibleAssetVaultForDAO.sol#L105 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L459 ## Tools Used None ## Recommended Mitigation Steps Use the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete https://docs.chain.link/docs/price-feeds-api-reference/  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L141-L154   # Vulnerability details  ## Impact In the LPFarming contract, a new staking pool can be added using the add() function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the _lpToken is the same as the reward token (jpeg) or not. ```     function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {         _massUpdatePools();          uint256 lastRewardBlock = _blockNumber();         totalAllocPoint = totalAllocPoint + _allocPoint;         poolInfo.push(             PoolInfo({                 lpToken: _lpToken,                 allocPoint: _allocPoint,                 lastRewardBlock: lastRewardBlock,                 accRewardPerShare: 0             })         );     } ```  When the _lpToken is the same token as jpeg, reward calculation for that pool in the updatePool() function can be incorrect. This is because the current balance of the _lpToken in the contract is used in the calculation of the reward. Since the _lpToken is the same token as the reward, the reward minted to the contract will inflate the value of lpSupply, causing the reward of that pool to be less than what it should be. ```     function _updatePool(uint256 _pid) internal {         PoolInfo storage pool = poolInfo[_pid];         if (pool.allocPoint == 0) {             return;         }          uint256 blockNumber = _blockNumber();         //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch         uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);         if (blockNumber <= lastRewardBlock) {             return;         }         uint256 lpSupply = pool.lpToken.balanceOf(address(this));         if (lpSupply == 0) {             pool.lastRewardBlock = blockNumber;             return;         }         uint256 reward = ((blockNumber - lastRewardBlock) *             epoch.rewardPerBlock *             1e36 *             pool.allocPoint) / totalAllocPoint;         pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;         pool.lastRewardBlock = blockNumber;     } ```  ## Proof of Concept https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L141-L154 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L288-L311 ## Tools Used None  ## Recommended Mitigation Steps  Add a check that _lpToken is not jpeg in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token.   
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/package.json#L18-L19   # Vulnerability details  ## Impact  The solution uses: ```jsx     "@openzeppelin/contracts": "^4.0.0",     "@openzeppelin/contracts-upgradeable": "^4.3.2", ``` These dependencies have a known high severity vulnerability:  - https://security.snyk.io/vuln/SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177 - https://snyk.io/test/npm/@openzeppelin/contracts-upgradeable/4.3.2#SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177 - https://snyk.io/test/npm/@openzeppelin/contracts/4.0.0#SNYK-JS-OPENZEPPELINCONTRACTS-2320176  Which makes these contracts vulnerable: ```jsx contracts/helpers/CryptoPunksHelper.sol:   19:     function initialize(address punksAddress) external initializer {  contracts/helpers/EtherRocksHelper.sol:   19:     function initialize(address rocksAddress) external initializer {  contracts/staking/JPEGStaking.sol:   21:     function initialize(IERC20Upgradeable _jpeg) external initializer {  contracts/vaults/FungibleAssetVaultForDAO.sol:   71:     ) external initializer {  contracts/vaults/NFTVault.sol:   149:     ) external initializer { ```  ## Recommended Mitigation Steps Upgrade `@openzeppelin/contracts` and `@openzeppelin/contracts-upgradeable` to version 4.4.1 or higher.  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234   # Vulnerability details  ## Impact  As specified in Convex [BaseRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L149) and [VirtualRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/VirtualBalanceRewardPool.sol#L127), the function signature of `earned` is `earned(address)`. However, `balanceOfJPEG` did not pass any arguments to `earned`, which would cause `balanceOfJPEG` to always revert.  This bug will propagate through `Controller` and `YVault` until finally reaching the source of the call in `YVaultLPFarming ._computeUpdate`, and render the entire farming contract unuseable.  ## Proof of Concept  Both `BaseRewardPool.earned` and `VirtualBalanceRewardPool.earned` takes an address as argument  ```     function earned(address account) public view returns (uint256) {         return             balanceOf(account)                 .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))                 .div(1e18)                 .add(rewards[account]);     }      function earned(address account) public view returns (uint256) {         return             balanceOf(account)                 .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))                 .div(1e18)                 .add(rewards[account]);     } ```  But `balanceOfJPEG` does not pass any address to `extraReward.earned`, causing the entire function to revert when called ```     function balanceOfJPEG() external view returns (uint256) {         uint256 availableBalance = jpeg.balanceOf(address(this));          IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;         uint256 length = baseRewardPool.extraRewardsLength();         for (uint256 i = 0; i < length; i++) {             IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));             if (address(jpeg) == extraReward.rewardToken()) {                 availableBalance += extraReward.earned();                 //we found jpeg, no need to continue the loop                 break;             }         }          return availableBalance;     } ```  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Pass `address(this)` as argument of `earned`.  Notice how we modify the fetching of reward. This is reported in a separate bug report, but for completeness, the entire fix is shown in both report entries.  ```     function balanceOfJPEG() external view returns (uint256) {         uint256 availableBalance = jpeg.balanceOf(address(this));          IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;         availableBalance += baseRewardPool.earned(address(this));         uint256 length = baseRewardPool.extraRewardsLength();         for (uint256 i = 0; i < length; i++) {             IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));             if (address(jpeg) == extraReward.rewardToken()) {                 availableBalance += extraReward.earned(address(this));             }         }          return availableBalance;     } ```   
**Table of Contents:**  - [`NFTEscrow._executeTransfer()`: Cheap Contract Deployment Through Clones](#nftescrow_executetransfer-cheap-contract-deployment-through-clones) - [`LPFarming.newEpoch()`: L128 and L133 should be unchecked due to parent if/else condition](#lpfarmingnewepoch-l128-and-l133-should-be-unchecked-due-to-parent-ifelse-condition) - [`LPFarming.withdraw()`: L248 should be unchecked due to L243](#lpfarmingwithdraw-l248-should-be-unchecked-due-to-l243) - [`LPFarming._withdrawReward()`: `poolInfo[_pid].accRewardPerShare` should get cached](#lpfarming_withdrawreward-poolinfo_pidaccrewardpershare-should-get-cached) - [`yVaultLPFarming.withdraw()`: L124 should be unchecked due to L119](#yvaultlpfarmingwithdraw-l124-should-be-unchecked-due-to-l119) - [`yVaultLPFarming._withdrawReward()`: `accRewardPerShare` should get cached](#yvaultlpfarming_withdrawreward-accrewardpershare-should-get-cached) - [`JPEGLock.unlock()`: use `storage` instead of copying struct in memory L69](#jpeglockunlock-use-storage-instead-of-copying-struct-in-memory-l69) - [`FungibleAssetVaultForDAO._collateralPriceUsd()`: `oracle` should get cached](#fungibleassetvaultfordao_collateralpriceusd-oracle-should-get-cached) - [`FungibleAssetVaultForDAO._collateralPriceUsd()`: return statement should be unchecked](#fungibleassetvaultfordao_collateralpriceusd-return-statement-should-be-unchecked) - [`FungibleAssetVaultForDAO.deposit()`: `collateralAsset` should get cached](#fungibleassetvaultfordaodeposit-collateralasset-should-get-cached) - [`FungibleAssetVaultForDAO.repay)`: L184 should be unchecked due to L182](#fungibleassetvaultfordaorepay-l184-should-be-unchecked-due-to-l182) - [`FungibleAssetVaultForDAO.withdraw()`: L196 should be unchecked due to L194](#fungibleassetvaultfordaowithdraw-l196-should-be-unchecked-due-to-l194) - [`FungibleAssetVaultForDAO.withdraw()`: `collateralAmount` should get cached](#fungibleassetvaultfordaowithdraw-collateralamount-should-get-cached) - [`NFTVault._normalizeAggregatorAnswer()`: return statement should be unchecked](#nftvault_normalizeaggregatoranswer-return-statement-should-be-unchecked) - [`NFTVault._calculateAdditionalInterest()`: `totalDebtAmount` should get cached](#nftvault_calculateadditionalinterest-totaldebtamount-should-get-cached) - [`NFTVault.sol`: `struct PositionPreview` can be tightly packed to save 1 storage slot](#nftvaultsol-struct-positionpreview-can-be-tightly-packed-to-save-1-storage-slot) - [`NFTVault.showPosition()`: L659 should be unchecked due to L649](#nftvaultshowposition-l659-should-be-unchecked-due-to-l649) - [`NFTVault.showPosition()`: `positions[_nftIndex].liquidatedAt` should get cached](#nftvaultshowposition-positions_nftindexliquidatedat-should-get-cached) - [`NFTVault.showPosition()`: Help the optimizer by saving a storage variable's reference instead of repeatedly fetching it (`positions[_nftIndex]`)](#nftvaultshowposition-help-the-optimizer-by-saving-a-storage-variables-reference-instead-of-repeatedly-fetching-it-positions_nftindex) - [`NFTVault.borrow()`: `totalDebtPortion` should get cached](#nftvaultborrow-totaldebtportion-should-get-cached) - [`NFTVault.repay()`: L781 should be unchecked due to ternary operator](#nftvaultrepay-l781-should-be-unchecked-due-to-ternary-operator) - [`NFTVault.repay()`: `totalDebtPortion` and `totalDebtAmount` should get cached](#nftvaultrepay-totaldebtportion-and-totaldebtamount-should-get-cached) - [`Controller.setStrategy()`: boolean comparison L87](#controllersetstrategy-boolean-comparison-l87) - [`StrategyPUSDConvex.balanceOfJPEG()`: `jpeg` should get cached](#strategypusdconvexbalanceofjpeg-jpeg-should-get-cached) - [`StrategyPUSDConvex.balanceOfJPEG()`: use a `return` statement instead of `break`](#strategypusdconvexbalanceofjpeg-use-a-return-statement-instead-of-break) - [`StrategyPUSDConvex.withdraw()`: L281 should be unchecked due to L279](#strategypusdconvexwithdraw-l281-should-be-unchecked-due-to-l279) - [`StrategyPUSDConvex.harvest()`: L362 should be unchecked due to L359-L360 and how performanceFee is set L183](#strategypusdconvexharvest-l362-should-be-unchecked-due-to-l359-l360-and-how-performancefee-is-set-l183) - [`yVault.earn()`: `token` and `controller` should get cached](#yvaultearn-token-and-controller-should-get-cached) - [`yVault.withdraw()`: L178 should be unchecked due to L177](#yvaultwithdraw-l178-should-be-unchecked-due-to-l177) - [`yVault.withdraw()`: `token` should get cached](#yvaultwithdraw-token-should-get-cached) - [`yVault.withdrawJPEG()`: `farm` should get cached](#yvaultwithdrawjpeg-farm-should-get-cached) - [Upgrade pragma to at least 0.8.4](#upgrade-pragma-to-at-least-084) - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values) - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof) - [`>=` is cheaper than `>`](#-is-cheaper-than-) - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops) - [`++i` costs less gas compared to `i++` or `i += 1`](#i-costs-less-gas-compared-to-i-or-i--1) - [Increments can be unchecked](#increments-can-be-unchecked) - [Use `calldata` instead of `memory`](#use-calldata-instead-of-memory) - [Consider making some constants as non-public to save gas](#consider-making-some-constants-as-non-public-to-save-gas) - [Public functions to external](#public-functions-to-external) - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings) - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## `NFTEscrow._executeTransfer()`: Cheap Contract Deployment Through Clones  See `@audit` tag:  ```solidity 67:     function _executeTransfer(address _owner, uint256 _idx) internal { 68:         (bytes32 salt, ) = precompute(_owner, _idx); 69:         new FlashEscrow{salt: salt}( //@audit gas: deployment can cost less through clones  70:             nftAddress, 71:             _encodeFlashEscrowPayload(_idx) 72:         ); 73:     } ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  I suggest applying a similar pattern.  ## `LPFarming.newEpoch()`: L128 and L133 should be unchecked due to parent if/else condition  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  I suggest wrapping with an `unchecked` block here (see `@audit` tag):  ```solidity 107:     function newEpoch( ... 111:     ) external onlyOwner { 127:         if (remainingRewards > newRewards) { 128:             jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);  //@audit gas: should be unchecked (can't underflow due to L127) 129:         } else if (remainingRewards < newRewards) { 130:             jpeg.safeTransferFrom( 131:                 msg.sender, 132:                 address(this), 133:                 newRewards - remainingRewards  //@audit gas: should be unchecked (can't underflow due to L129) 134:             ); 135:         } 136:     } ```  ## `LPFarming.withdraw()`: L248 should be unchecked due to L243  See `@audit` tag:  ```solidity 235:     function withdraw(uint256 _pid, uint256 _amount) 236:         external 237:         noContract(msg.sender) 238:     { 239:         require(_amount > 0, "invalid_amount"); 240:  241:         PoolInfo storage pool = poolInfo[_pid]; 242:         UserInfo storage user = userInfo[_pid][msg.sender]; 243:         require(user.amount >= _amount, "insufficient_amount"); 244:  245:         _updatePool(_pid); 246:         _withdrawReward(_pid); 247:  248:         user.amount -= _amount;  //@audit gas: should be unchecked (can't underflow due to L243) ```  ## `LPFarming._withdrawReward()`: `poolInfo[_pid].accRewardPerShare` should get cached  The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, the storage value should get cached in memory (see the `@audit` tags for further details):  ```solidity 315:     function _withdrawReward(uint256 _pid) internal returns (uint256) { 316:         UserInfo storage user = userInfo[_pid][msg.sender]; 317:         uint256 pending = (user.amount * 318:             (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) / //@audit gas: SLOAD 1 poolInfo[_pid].accRewardPerShare 319:             1e36; 320:         if (pending > 0) { 321:             userRewards[msg.sender] += pending; 322:         } 323:  324:         user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare; //@audit gas: SLOAD 2 poolInfo[_pid].accRewardPerShare 325:  326:         return pending; 327:     } ```  ## `yVaultLPFarming.withdraw()`: L124 should be unchecked due to L119  See `@audit` tag:  ```solidity 117:     function withdraw(uint256 _amount) external noContract(msg.sender) { 118:         require(_amount > 0, "invalid_amount"); 119:         require(balanceOf[msg.sender] >= _amount, "insufficient_amount"); 120:  121:         _update(); 122:         _withdrawReward(msg.sender); 123:  124:         balanceOf[msg.sender] -= _amount;  //@audit gas: should be unchecked (can't underflow due to L119) ```  ## `yVaultLPFarming._withdrawReward()`: `accRewardPerShare` should get cached  See `@audit` tags:  ```solidity 177:     function _withdrawReward(address account) internal returns (uint256) { 178:         uint256 pending = (balanceOf[account] * 179:             (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36; //@audit gas: SLOAD 1 accRewardPerShare 180:  181:         if (pending > 0) userPendingRewards[account] += pending; 182:  183:         userLastAccRewardPerShare[account] = accRewardPerShare; //@audit gas: SLOAD 2 accRewardPerShare 184:  185:         return pending; 186:     } ```  ## `JPEGLock.unlock()`: use `storage` instead of copying struct in memory L69  See `@audit` tag:  ```solidity 68:     function unlock(uint256 _nftIndex) external nonReentrant { 69:         LockPosition memory position = positions[_nftIndex]; //@audit gas: costing 3 SLOADs while only lockAmount is needed twice. Replace "memory" with "storage" and cache only position.lockAmount  70:         require(position.owner == msg.sender, "unauthorized"); 71:         require(position.unlockAt <= block.timestamp, "locked"); 72:  73:         delete positions[_nftIndex]; 74:  75:         jpeg.safeTransfer(msg.sender, position.lockAmount); 76:  77:         emit Unlock(msg.sender, _nftIndex, position.lockAmount); 78:     } ```  Here, a copy in memory is costing 3 SLOADs and 3 MSTORES. The, 2 variables are only read once through MLOAD (`position.owner` and `position.unlockAt`) and one is read twice (`position.lockAmount`). I suggest replacing the `memory` keyword with `storage` at L69 and only copying `position.lockAmount` in memory.  ## `FungibleAssetVaultForDAO._collateralPriceUsd()`: `oracle` should get cached  See `@audit` tags:  ```solidity 104:     function _collateralPriceUsd() internal view returns (uint256) { 105:         int256 answer = oracle.latestAnswer();  //@audit gas: SLOAD 1 oracle 106:         uint8 decimals = oracle.decimals();  //@audit gas: SLOAD 2 oracle 107:  ```  ## `FungibleAssetVaultForDAO._collateralPriceUsd()`: return statement should be unchecked  See `@audit` tag:  ```solidity 104:     function _collateralPriceUsd() internal view returns (uint256) { ... 111:         return //@audit gas: whole return statement should be unchecked (obviously can't underflow/overflow here) 112:             decimals > 18 113:                 ? uint256(answer) / 10**(decimals - 18)   114:                 : uint256(answer) * 10**(18 - decimals);   115:     } ```  Due to the ternary condition and the fact that `int256 answer = oracle.latestAnswer();`, the return statement can't underflow and should be unchecked.  ## `FungibleAssetVaultForDAO.deposit()`: `collateralAsset` should get cached  See `@audit` tags:  ```solidity 141:     function deposit(uint256 amount) external payable onlyRole(WHITELISTED_ROLE) { 142:         require(amount > 0, "invalid_amount"); 143:  144:         if (collateralAsset == ETH) {  //@audit gas: SLOAD 1 collateralAsset 145:             require(msg.value == amount, "invalid_msg_value"); 146:         } else { 147:             require(msg.value == 0, "non_zero_eth_value"); 148:             IERC20Upgradeable(collateralAsset).safeTransferFrom(  //@audit gas: SLOAD 2 collateralAsset 149:                 msg.sender, 150:                 address(this), 151:                 amount 152:             ); 153:         } ```  ## `FungibleAssetVaultForDAO.repay)`: L184 should be unchecked due to L182  See `@audit` tag:  ```solidity 179:     function repay(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant { 180:         require(amount > 0, "invalid_amount"); 181:  182:         amount = amount > debtAmount ? debtAmount : amount; 183:  184:         debtAmount -= amount; //@audit gas: should be unchecked (can't underflow due to L182) ```  ## `FungibleAssetVaultForDAO.withdraw()`: L196 should be unchecked due to L194  See `@audit` tag:  ```solidity 193:     function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant { 194:         require(amount > 0 && amount <= collateralAmount, "invalid_amount"); 195:  196:         uint256 creditLimit = getCreditLimit(collateralAmount - amount); //@audit gas: should be unchecked (can't underflow due to L194) ```  ## `FungibleAssetVaultForDAO.withdraw()`: `collateralAmount` should get cached  See `@audit` tags:  ```solidity 193:     function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant { 194:         require(amount > 0 && amount <= collateralAmount, "invalid_amount");  //@audit gas: SLOAD 1 collateralAmount 195:  196:         uint256 creditLimit = getCreditLimit(collateralAmount - amount); //@audit gas: SLOAD 2 collateralAmount 197:         require(creditLimit >= debtAmount, "insufficient_credit"); 198:  199:         collateralAmount -= amount; //@audit gas: SLOAD 3 collateralAmount (could've used the a cached value for calculation) ```  ## `NFTVault._normalizeAggregatorAnswer()`: return statement should be unchecked  See `@audit` tag:  ```solidity 454:     function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator) 455:         internal 456:         view 457:         returns (uint256) 458:     { ... 464:         return //@audit gas: whole return statement should be unchecked (obviously can't underflow/overflow) 465:             decimals > 18 466:                 ? uint256(answer) / 10**(decimals - 18) 467:                 : uint256(answer) * 10**(18 - decimals); 468:     } ```  ## `NFTVault._calculateAdditionalInterest()`: `totalDebtAmount` should get cached  See `@audit` tags:  ```solidity 578:     function _calculateAdditionalInterest() internal view returns (uint256) { ... 585:         if (totalDebtAmount == 0) {  //@audit gas: SLOAD 1 totalDebtAmount 586:             return 0; 587:         } 588:  589:         // Accrue interest 590:         uint256 interestPerYear = (totalDebtAmount *  //@audit gas: SLOAD 2 totalDebtAmount ```  ## `NFTVault.sol`: `struct PositionPreview` can be tightly packed to save 1 storage slot  From (see `@audit` tags):  ```solidity 610:     struct PositionPreview { // @audit gas: can be tightly packed by moving borrowType and liquidatable at the end 611:         address owner; 612:         uint256 nftIndex; 613:         bytes32 nftType; 614:         uint256 nftValueUSD; 615:         VaultSettings vaultSettings; 616:         uint256 creditLimit; 617:         uint256 debtPrincipal; 618:         uint256 debtInterest; // @audit gas: 32 bytes 619:         BorrowType borrowType; // @audit gas: 1 byte (this enum is equivalent to uint8 as it has less than 256 options) 620:         bool liquidatable; // @audit gas: 1 byte 621:         uint256 liquidatedAt; // @audit gas: 32 bytes 622:         address liquidator; // @audit gas: 20 bytes 623:     } ```  To:  ```solidity     struct PositionPreview {         address owner;         uint256 nftIndex;         bytes32 nftType;         uint256 nftValueUSD;         VaultSettings vaultSettings;         uint256 creditLimit;         uint256 debtPrincipal;         uint256 debtInterest; // @audit gas: 32 bytes         uint256 liquidatedAt; // @audit gas: 32 bytes         BorrowType borrowType; // @audit gas: 1 byte (this enum is equivalent to uint8 as it has less than 256 options)         bool liquidatable; // @audit gas: 1 byte         address liquidator; // @audit gas: 20 bytes     } ```  ## `NFTVault.showPosition()`: L659 should be unchecked due to L649  See `@audit` tag:  ```solidity File: NFTVault.sol 628:     function showPosition(uint256 _nftIndex) ... 649:         if (debtPrincipal > debtAmount) debtAmount = debtPrincipal; ... 659:             debtInterest: debtAmount - debtPrincipal, //@audit gas: should be unchecked (can't underflow due to L649) ```  ## `NFTVault.showPosition()`: `positions[_nftIndex].liquidatedAt` should get cached  See `@audit` tags:  ```solidity File: NFTVault.sol 628:     function showPosition(uint256 _nftIndex) ... 661:             liquidatable: positions[_nftIndex].liquidatedAt == 0 &&  //@audit gas: SLOAD 1 positions[_nftIndex].liquidatedAt 662:                 debtAmount >= _getLiquidationLimit(_nftIndex), 663:             liquidatedAt: positions[_nftIndex].liquidatedAt,  //@audit gas: SLOAD 2 positions[_nftIndex].liquidatedAt ```  ## `NFTVault.showPosition()`: Help the optimizer by saving a storage variable's reference instead of repeatedly fetching it (`positions[_nftIndex]`)  To help the optimizer, declare a `storage` type variable and use it instead of repeatedly fetching the reference in a map or an array.  The effect can be quite significant.  Here, instead of repeatedly calling `positions[_nftIndex]`, save its reference like this: `Position storage _position = positions[_nftIndex]` and use it.  Impacted lines (see `@audit` tags):  ```solidity   636:         uint256 debtPrincipal = positions[_nftIndex].debtPrincipal; //@audit gas: use the suggested storage variable "Position storage _position"   637:         uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0 //@audit gas: use the suggested storage variable "Position storage _position"   638:             ? positions[_nftIndex].debtAmountForRepurchase //@audit gas: use the suggested storage variable "Position storage _position"   641:                 positions[_nftIndex].debtPortion, //@audit gas: use the suggested storage variable "Position storage _position"   660:             borrowType: positions[_nftIndex].borrowType, //@audit gas: use the suggested storage variable "Position storage _position"   661:             liquidatable: positions[_nftIndex].liquidatedAt == 0 && //@audit gas: use the suggested storage variable "Position storage _position"   663:             liquidatedAt: positions[_nftIndex].liquidatedAt, //@audit gas: use the suggested storage variable "Position storage _position"   664:             liquidator: positions[_nftIndex].liquidator //@audit gas: use the suggested storage variable "Position storage _position" ```  This practice already exists in the solution, as seen in `NFTVault.borrow()`:  ```solidity 675:     function borrow( ... 697:         Position storage position = positions[_nftIndex]; ```  ## `NFTVault.borrow()`: `totalDebtPortion` should get cached  See `@audit` tags:  ```solidity 675:     function borrow( ... 735:         if (totalDebtPortion == 0) {  //@audit gas: SLOAD 1 totalDebtPortion ... 738:         } else { 739:             uint256 plusPortion = (totalDebtPortion * _amount) / //@audit gas: SLOAD 2 totalDebtPortion 740:                 totalDebtAmount; 741:             totalDebtPortion += plusPortion; //@audit gas: SLOAD 3 totalDebtPortion (could've used cached value for calculation) ```  ## `NFTVault.repay()`: L781 should be unchecked due to ternary operator  See `@audit` tag:  ```solidity 756:     function repay(uint256 _nftIndex, uint256 _amount) ... 780:         uint256 paidPrincipal = _amount > debtInterest 781:             ? _amount - debtInterest //@audit gas: should be unchecked (obviously) 782:             : 0; ```  ## `NFTVault.repay()`: `totalDebtPortion` and `totalDebtAmount` should get cached  See `@audit` tags:  ```solidity 756:     function repay(uint256 _nftIndex, uint256 _amount) ... 784:         uint256 minusPortion = paidPrincipal == debtPrincipal 785:             ? position.debtPortion 786:             : (totalDebtPortion * _amount) / totalDebtAmount; //@audit gas: SLOADs 1 totalDebtPortion & totalDebtAmount 787:  788:         totalDebtPortion -= minusPortion; //@audit gas: SLOAD 2 totalDebtPortion (could've used cached value for calculation) ... 791:         totalDebtAmount -= _amount; //@audit gas: SLOAD 2 totalDebtAmount (could've used cached value for calculation) ```  ## `Controller.setStrategy()`: boolean comparison L87  Comparing to a constant (`true` or `false`) is a bit more expensive than directly checking the returned boolean value. I suggest using `if(directValue)` instead of `if(directValue == true)` and `if(!directValue)` instead of `if(directValue == false)` here (see `@audit` tag):  ```solidity 82:     function setStrategy(IERC20 _token, IStrategy _strategy) 83:         external 84:         onlyRole(STRATEGIST_ROLE) 85:     { 86:         require( 87:             approvedStrategies[_token][_strategy] == true, //@audit gas: instead of comparing to a constant, just use "approvedStrategies[_token][_strategy]" ```  ## `StrategyPUSDConvex.balanceOfJPEG()`: `jpeg` should get cached  See `@audit` tags:  ```solidity 226:     function balanceOfJPEG() external view returns (uint256) { 227:         uint256 availableBalance = jpeg.balanceOf(address(this)); //@audit gas: SLOAD 1 jpeg ... 231:         for (uint256 i = 0; i < length; i++) { ... 233:             if (address(jpeg) == extraReward.rewardToken()) { //@audit gas: SLOADs in Loop for jpeg. Cache it at L227 ```  ## `StrategyPUSDConvex.balanceOfJPEG()`: use a `return` statement instead of `break`  See `@audit` tag:  ```solidity 226:     function balanceOfJPEG() external view returns (uint256) { ... 231:         for (uint256 i = 0; i < length; i++) { ... 233:             if (address(jpeg) == extraReward.rewardToken()) { 234:                 availableBalance += extraReward.earned(); 235:                 //we found jpeg, no need to continue the loop 236:                 break; //@audit gas: instead of adding to availableBalance & breaking, just return here "availableBalance + extraReward.earned()" 237:             } 238:         } 239:  240:         return availableBalance; 241:     } ```  Here, instead of making a memory operation with `availableBalance += extraReward.earned();` and then using `break;` before returning the memory variable `availableBalance`, it would've been more optimized to just return `availableBalance + extraReward.earned()`:  ```solidity     function balanceOfJPEG() external view returns (uint256) { ...         for (uint256 i = 0; i < length; i++) { ...             if (address(jpeg) == extraReward.rewardToken()) {               return availableBalance + extraReward.earned();             }         }     } ```  ## `StrategyPUSDConvex.withdraw()`: L281 should be unchecked due to L279  See `@audit` tag:  ```solidity 273:     function withdraw(uint256 _amount) external onlyController { ... 279:         if (balance < _amount) 280:             convexConfig.baseRewardPool.withdrawAndUnwrap( 281:                 _amount - balance, //@audit gas: should be unchecked (can't underflow due to L279) 282:                 false 283:             ); ```  ## `StrategyPUSDConvex.harvest()`: L362 should be unchecked due to L359-L360 and how performanceFee is set L183  See `@audit` tags:  ```solidity 177:     function setPerformanceFee(Rate memory _performanceFee) ... 181:         require( 182:             _performanceFee.denominator > 0 && 183:                 _performanceFee.denominator >= _performanceFee.numerator, //@audit gas: can uncheck L362 thanks to this 184:             "INVALID_RATE" 185:         ); ... 311:     function harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) { ... 359:         uint256 fee = (usdcBalance * performanceFee.numerator) / 360:             performanceFee.denominator; 361:         usdc.safeTransfer(strategy.controller.feeAddress(), fee); 362:         usdcBalance -= fee; //@audit gas: should be unchecked (can't underflow due to L359-L360 & how performanceFee is set L183) ```  ## `yVault.earn()`: `token` and `controller` should get cached  See `@audit` tags:  ```solidity 129:     function earn() external { 130:         uint256 _bal = available(); 131:         token.safeTransfer(address(controller), _bal); //@audit gas: SLOADs 1 token & controller 132:         controller.earn(address(token), _bal); //@audit gas: SLOADs 2 token & controller 133:     } ```  ## `yVault.withdraw()`: L178 should be unchecked due to L177  See `@audit` tag:  ```solidity 166:     function withdraw(uint256 _shares) public noContract(msg.sender) { ... 177:         if (vaultBalance < backingTokens) { 178:             uint256 toWithdraw = backingTokens - vaultBalance; //@audit gas: should be unchecked (can't underflow due to L177) ```  ## `yVault.withdraw()`: `token` should get cached  See `@audit` tags:  ```solidity 166:     function withdraw(uint256 _shares) public noContract(msg.sender) { ... 176:         uint256 vaultBalance = token.balanceOf(address(this)); //@audit gas: SLOAD 1 token 177:         if (vaultBalance < backingTokens) { 178:             uint256 toWithdraw = backingTokens - vaultBalance; 179:             controller.withdraw(address(token), toWithdraw);  //@audit gas: SLOAD 2 token 180:         } 181:  182:         token.safeTransfer(msg.sender, backingTokens);  //@audit gas: SLOAD 3 token ```  ## `yVault.withdrawJPEG()`: `farm` should get cached  See `@audit` tags:  ```solidity 187:     function withdrawJPEG() external { 188:         require(farm != address(0), "NO_FARM");  //@audit gas: SLOAD 1 farm 189:         controller.withdrawJPEG(address(token), farm);  //@audit gas: SLOAD 2 farm 190:     } ```  ## Upgrade pragma to at least 0.8.4  Across the whole solution, the declared pragma is `^0.8.0`.  Using newer compiler versions and the optimizer give gas optimizations. Also, additional safety checks are available for free.  The advantages here are:  - **Low level inliner** (>= 0.8.2): Cheaper runtime gas (especially relevant when the contract has small functions). - **Optimizer improvements in packed structs** (>= 0.8.3) - **Custom errors** (>= 0.8.4): cheaper deployment cost and runtime cost. *Note*: the runtime cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.  Consider upgrading pragma to at least 0.8.4:  ## No need to explicitly initialize variables with default values  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Instances include:    ```solidity farming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) { farming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) { vaults/FungibleAssetVaultForDAO.sol:45:    address internal constant ETH = address(0); vaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) { vaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) { ```  I suggest removing explicit initializations for default values.  ## `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  I suggest changing `> 0` with `!= 0` here:  ```solidity farming/LPFarming.sol:114:        require(_rewardPerBlock > 0, "Invalid reward per block"); farming/LPFarming.sol:218:        require(_amount > 0, "invalid_amount"); farming/LPFarming.sol:239:        require(_amount > 0, "invalid_amount"); farming/LPFarming.sol:337:        require(rewards > 0, "no_reward"); farming/LPFarming.sol:354:        require(rewards > 0, "no_reward"); farming/yVaultLPFarming.sol:101:        require(_amount > 0, "invalid_amount"); farming/yVaultLPFarming.sol:118:        require(_amount > 0, "invalid_amount"); farming/yVaultLPFarming.sol:139:        require(rewards > 0, "no_reward"); lock/JPEGLock.sol:40:        require(_newTime > 0, "Invalid lock time"); staking/JPEGStaking.sol:32:        require(_amount > 0, "invalid_amount"); vaults/yVault/strategies/StrategyPUSDConvex.sol:182:            _performanceFee.denominator > 0 && vaults/yVault/strategies/StrategyPUSDConvex.sol:334:            require(wethBalance > 0, "NOOP"); vaults/yVault/yVault.sol:100:            _rate.numerator > 0 && _rate.denominator >= _rate.numerator, vaults/yVault/yVault.sol:143:        require(_amount > 0, "INVALID_AMOUNT"); vaults/yVault/yVault.sol:167:        require(_shares > 0, "INVALID_AMOUNT"); vaults/yVault/yVault.sol:170:        require(supply > 0, "NO_TOKENS_DEPOSITED"); vaults/FungibleAssetVaultForDAO.sol:94:            _creditLimitRate.denominator > 0 && vaults/FungibleAssetVaultForDAO.sol:108:        require(answer > 0, "invalid_oracle_answer"); vaults/FungibleAssetVaultForDAO.sol:142:        require(amount > 0, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:164:        require(amount > 0, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:180:        require(amount > 0, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:194:        require(amount > 0 && amount <= collateralAmount, "invalid_amount"); vaults/NFTVault.sol:278:        require(_newFloor > 0, "Invalid floor"); vaults/NFTVault.sol:327:            _type == bytes32(0) || nftTypeValueETH[_type] > 0, vaults/NFTVault.sol:365:        require(pendingValue > 0, "no_pending_value"); vaults/NFTVault.sol:402:            rate.denominator > 0 && rate.denominator >= rate.numerator, vaults/NFTVault.sol:462:        require(answer > 0, "invalid_oracle_answer"); vaults/NFTVault.sol:687:        require(_amount > 0, "invalid_amount"); vaults/NFTVault.sol:764:        require(_amount > 0, "invalid_amount"); vaults/NFTVault.sol:770:        require(debtAmount > 0, "position_not_borrowed"); vaults/NFTVault.sol:882:        require(position.liquidatedAt > 0, "not_liquidated"); vaults/NFTVault.sol:926:        require(position.liquidatedAt > 0, "not_liquidated"); ```  Also, please enable the Optimizer.  ## `>=` is cheaper than `>`  Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)    I suggest using  `>=`  instead of `>` to avoid some opcodes here:  ```solidity vaults/NFTVault.sol:539:        return principal > calculatedDebt ? principal : calculatedDebt; vaults/NFTVault.sol:775:        _amount = _amount > debtAmount ? debtAmount : _amount; ```  ## An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead:  ```solidity farming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) { vaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) { vaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) { ```  This is already done here:  ```solidity farming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) { vaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) { ```  ## `++i` costs less gas compared to `i++` or `i += 1`  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:      ```solidity uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ```solidity uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:    ```solidity farming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) { vaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) { vaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) { ```  I suggest using `++i` instead of `i++` to increment the value of an uint variable.  This is already done here:  ```solidity farming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) { ```  ## Increments can be unchecked  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Instances include:    ```solidity farming/LPFarming.sol:281:        for (uint256 pid = 0; pid < length; ++pid) { farming/LPFarming.sol:348:        for (uint256 i = 0; i < poolInfo.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:145:        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:231:        for (uint256 i = 0; i < length; i++) { vaults/yVault/strategies/StrategyPUSDConvex.sol:319:            for (uint256 i = 0; i < rewardTokens.length; i++) { vaults/NFTVault.sol:181:        for (uint256 i = 0; i < _typeInitializers.length; i++) { vaults/NFTVault.sol:184:            for (uint256 j = 0; j < initializer.nfts.length; j++) { ```  The code would go from:      ```solidity for (uint256 i; i < numIterations; i++) {    // ...   }   ```  to:    ```solidity for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ```  The risk of overflow is inexistant for a `uint256` here.  ## Use `calldata` instead of `memory`  When arguments are read-only on external functions, the data location should be `calldata`:  ```solidity contracts/vaults/NFTVault.sol:   212:     function setDebtInterestApr(Rate memory _debtInterestApr) //@audit gas: should be calldata   222:     function setValueIncreaseLockRate(Rate memory _valueIncreaseLockRate)  //@audit gas: should be calldata   232:     function setCreditLimitRate(Rate memory _creditLimitRate)  //@audit gas: should be calldata   247:     function setLiquidationLimitRate(Rate memory _liquidationLimitRate)  //@audit gas: should be calldata   290:     function setOrganizationFeeRate(Rate memory _organizationFeeRate)  //@audit gas: should be calldata   300:     function setInsurancePurchaseRate(Rate memory _insurancePurchaseRate)  //@audit gas: should be calldata   311:         Rate memory _insuranceLiquidationPenaltyRate  //@audit gas: should be calldata ```  ## Consider making some constants as non-public to save gas  Reducing from `public` to `private` or `internal` can save gas when a constant isn't used outside of its contract. I suggest changing the visibility from `public` to `internal` or `private` here:  ```solidity tokens/JPEG.sol:10:    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE"); tokens/StableCoin.sol:22:    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE"); tokens/StableCoin.sol:23:    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE"); vaults/yVault/strategies/StrategyPUSDConvex.sol:66:    bytes32 public constant STRATEGIST_ROLE = keccak256("STRATEGIST_ROLE"); vaults/yVault/Controller.sol:15:    bytes32 public constant STRATEGIST_ROLE = keccak256("STRATEGIST_ROLE"); vaults/FungibleAssetVaultForDAO.sol:41:    bytes32 public constant WHITELISTED_ROLE = keccak256("WHITELISTED_ROLE"); vaults/NFTVault.sol:71:    bytes32 public constant DAO_ROLE = keccak256("DAO_ROLE"); vaults/NFTVault.sol:72:    bytes32 public constant LIQUIDATOR_ROLE = keccak256("LIQUIDATOR_ROLE"); vaults/NFTVault.sol:74:    bytes32 public constant CUSTOM_NFT_HASH = keccak256("CUSTOM"); ```  ## Public functions to external  The following functions could be set external to save gas and improve code quality. External call cost is less expensive than of public functions.  ```solidity withdraw(IERC20,uint256) should be declared external:  - Controller.withdraw(IERC20,uint256) (contracts/vaults/yVault/Controller.sol#151-154) setFarmingPool(address) should be declared external:  - YVault.setFarmingPool(address) (contracts/vaults/yVault/yVault.sol#115-118) ```  ## Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity tokens/JPEG.sol:23:            "JPEG: must have minter role to mint" tokens/StableCoin.sol:41:            "StableCoin: must have minter role to mint" tokens/StableCoin.sol:55:            "StableCoin: must have pauser role to pause" tokens/StableCoin.sol:69:            "StableCoin: must have pauser role to unpause" vaults/NFTVault.sol:394:            "credit_rate_exceeds_or_equals_liquidation_rate"  ```  I suggest shortening the revert strings to fit in 32 bytes, or using custom errors as described next.  ## Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  ```solidity escrow/NFTEscrow.sol:18:        require(success, "FlashEscrow: call_failed"); escrow/NFTEscrow.sol:86:        require( farming/LPFarming.sol:86:        require( farming/LPFarming.sol:112:        require(_startBlock >= block.number, "Invalid start block"); farming/LPFarming.sol:113:        require(_endBlock > _startBlock, "Invalid end block"); farming/LPFarming.sol:114:        require(_rewardPerBlock > 0, "Invalid reward per block"); farming/LPFarming.sol:218:        require(_amount > 0, "invalid_amount"); farming/LPFarming.sol:239:        require(_amount > 0, "invalid_amount"); farming/LPFarming.sol:243:        require(user.amount >= _amount, "insufficient_amount"); farming/LPFarming.sol:337:        require(rewards > 0, "no_reward"); farming/LPFarming.sol:354:        require(rewards > 0, "no_reward"); farming/yVaultLPFarming.sol:42:        require(_vault != address(0), "INVALID_VAULT"); farming/yVaultLPFarming.sol:43:        require(_jpeg != address(0), "INVALID_JPEG"); farming/yVaultLPFarming.sol:55:        require( farming/yVaultLPFarming.sol:101:        require(_amount > 0, "invalid_amount"); farming/yVaultLPFarming.sol:118:        require(_amount > 0, "invalid_amount"); farming/yVaultLPFarming.sol:119:        require(balanceOf[msg.sender] >= _amount, "insufficient_amount"); farming/yVaultLPFarming.sol:139:        require(rewards > 0, "no_reward"); helpers/CryptoPunksHelper.sol:79:        require( helpers/EtherRocksHelper.sol:81:        require( lock/JPEGLock.sol:40:        require(_newTime > 0, "Invalid lock time"); lock/JPEGLock.sol:70:        require(position.owner == msg.sender, "unauthorized"); lock/JPEGLock.sol:71:        require(position.unlockAt <= block.timestamp, "locked"); staking/JPEGStaking.sol:32:        require(_amount > 0, "invalid_amount"); staking/JPEGStaking.sol:45:        require( tokens/JPEG.sol:21:        require( tokens/StableCoin.sol:39:        require( tokens/StableCoin.sol:53:        require( tokens/StableCoin.sol:67:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:108:        require(_want != address(0), "INVALID_WANT"); vaults/yVault/strategies/StrategyPUSDConvex.sol:109:        require(_jpeg != address(0), "INVALID_JPEG"); vaults/yVault/strategies/StrategyPUSDConvex.sol:110:        require(_pusd != address(0), "INVALID_PUSD"); vaults/yVault/strategies/StrategyPUSDConvex.sol:111:        require(_weth != address(0), "INVALID_WETH"); vaults/yVault/strategies/StrategyPUSDConvex.sol:112:        require(_usdc != address(0), "INVALID_USDC"); vaults/yVault/strategies/StrategyPUSDConvex.sol:113:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:117:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:121:        require(address(_curveConfig.curve) != address(0), "INVALID_CURVE"); vaults/yVault/strategies/StrategyPUSDConvex.sol:122:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:126:        require(_curveConfig.pusdIndex < 4, "INVALID_PUSD_CURVE_INDEX"); vaults/yVault/strategies/StrategyPUSDConvex.sol:127:        require(_curveConfig.usdcIndex < 4, "INVALID_USDC_CURVE_INDEX"); vaults/yVault/strategies/StrategyPUSDConvex.sol:128:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:132:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:136:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:140:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:146:            require( vaults/yVault/strategies/StrategyPUSDConvex.sol:168:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:181:        require( vaults/yVault/strategies/StrategyPUSDConvex.sol:195:        require(_controller != address(0), "INVALID_CONTROLLER"); vaults/yVault/strategies/StrategyPUSDConvex.sol:205:        require(_vault != address(0), "INVALID_USDC_VAULT"); vaults/yVault/strategies/StrategyPUSDConvex.sol:262:        require(want != _asset, "want"); vaults/yVault/strategies/StrategyPUSDConvex.sol:263:        require(pusd != _asset, "pusd"); vaults/yVault/strategies/StrategyPUSDConvex.sol:264:        require(usdc != _asset, "usdc"); vaults/yVault/strategies/StrategyPUSDConvex.sol:265:        require(weth != _asset, "weth"); vaults/yVault/strategies/StrategyPUSDConvex.sol:266:        require(jpeg != _asset, "jpeg"); vaults/yVault/strategies/StrategyPUSDConvex.sol:275:        require(vault != address(0), "ZERO_VAULT"); // additional protection so we don't burn the funds vaults/yVault/strategies/StrategyPUSDConvex.sol:292:        require(vault != address(0), "ZERO_VAULT"); // additional protection so we don't burn the funds vaults/yVault/strategies/StrategyPUSDConvex.sol:334:            require(wethBalance > 0, "NOOP"); vaults/yVault/Controller.sol:37:        require(_feeAddress != address(0), "INVALID_FEE_ADDRESS"); vaults/yVault/Controller.sol:48:        require(vaults[_token] == address(0), "ALREADY_HAS_VAULT"); vaults/yVault/Controller.sol:49:        require(_vault != address(0), "INVALID_VAULT"); vaults/yVault/Controller.sol:60:        require(address(_token) != address(0), "INVALID_TOKEN"); vaults/yVault/Controller.sol:61:        require(address(_strategy) != address(0), "INVALID_STRATEGY"); vaults/yVault/Controller.sol:73:        require(address(_token) != address(0), "INVALID_TOKEN"); vaults/yVault/Controller.sol:74:        require(address(_strategy) != address(0), "INVALID_STRATEGY"); vaults/yVault/Controller.sol:86:        require( vaults/yVault/Controller.sol:152:        require(msg.sender == vaults[_token], "NOT_VAULT"); vaults/yVault/Controller.sol:164:        require(msg.sender == vaults[_token], "NOT_VAULT"); vaults/yVault/yVault.sol:62:        require( vaults/yVault/yVault.sol:99:        require( vaults/yVault/yVault.sol:109:        require(_controller != address(0), "INVALID_CONTROLLER"); vaults/yVault/yVault.sol:116:        require(_farm != address(0), "INVALID_FARMING_POOL"); vaults/yVault/yVault.sol:143:        require(_amount > 0, "INVALID_AMOUNT"); vaults/yVault/yVault.sol:167:        require(_shares > 0, "INVALID_AMOUNT"); vaults/yVault/yVault.sol:170:        require(supply > 0, "NO_TOKENS_DEPOSITED"); vaults/yVault/yVault.sol:188:        require(farm != address(0), "NO_FARM"); vaults/FungibleAssetVaultForDAO.sol:93:        require( vaults/FungibleAssetVaultForDAO.sol:108:        require(answer > 0, "invalid_oracle_answer"); vaults/FungibleAssetVaultForDAO.sol:142:        require(amount > 0, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:145:            require(msg.value == amount, "invalid_msg_value"); vaults/FungibleAssetVaultForDAO.sol:147:            require(msg.value == 0, "non_zero_eth_value"); vaults/FungibleAssetVaultForDAO.sol:164:        require(amount > 0, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:168:        require(newDebtAmount <= creditLimit, "insufficient_credit"); vaults/FungibleAssetVaultForDAO.sol:180:        require(amount > 0, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:194:        require(amount > 0 && amount <= collateralAmount, "invalid_amount"); vaults/FungibleAssetVaultForDAO.sol:197:        require(creditLimit >= debtAmount, "insufficient_credit"); vaults/NFTVault.sol:118:        require(nftContract.ownerOf(nftIndex) != address(0), "invalid_nft"); vaults/NFTVault.sol:278:        require(_newFloor > 0, "Invalid floor"); vaults/NFTVault.sol:326:        require( vaults/NFTVault.sol:365:        require(pendingValue > 0, "no_pending_value"); vaults/NFTVault.sol:391:        require( vaults/NFTVault.sol:401:        require( vaults/NFTVault.sol:462:        require(answer > 0, "invalid_oracle_answer"); vaults/NFTVault.sol:682:        require( vaults/NFTVault.sol:687:        require(_amount > 0, "invalid_amount"); vaults/NFTVault.sol:688:        require( vaults/NFTVault.sol:698:        require(position.liquidatedAt == 0, "liquidated"); vaults/NFTVault.sol:699:        require( vaults/NFTVault.sol:710:        require(debtAmount + _amount <= creditLimit, "insufficient_credit"); vaults/NFTVault.sol:763:        require(msg.sender == positionOwner[_nftIndex], "unauthorized"); vaults/NFTVault.sol:764:        require(_amount > 0, "invalid_amount"); vaults/NFTVault.sol:767:        require(position.liquidatedAt == 0, "liquidated"); vaults/NFTVault.sol:770:        require(debtAmount > 0, "position_not_borrowed"); vaults/NFTVault.sol:805:        require(msg.sender == positionOwner[_nftIndex], "unauthorized"); vaults/NFTVault.sol:806:        require(_getDebtAmount(_nftIndex) == 0, "position_not_repaid"); vaults/NFTVault.sol:839:        require(posOwner != address(0), "position_not_exist"); vaults/NFTVault.sol:842:        require(position.liquidatedAt == 0, "liquidated"); vaults/NFTVault.sol:845:        require( vaults/NFTVault.sol:881:        require(msg.sender == positionOwner[_nftIndex], "unauthorized"); vaults/NFTVault.sol:882:        require(position.liquidatedAt > 0, "not_liquidated"); vaults/NFTVault.sol:883:        require( vaults/NFTVault.sol:887:        require( vaults/NFTVault.sol:925:        require(address(0) != owner, "no_position"); vaults/NFTVault.sol:926:        require(position.liquidatedAt > 0, "not_liquidated"); vaults/NFTVault.sol:927:        require( vaults/NFTVault.sol:932:        require(position.liquidator == msg.sender, "unauthorized"); ```  I suggest replacing revert strings with custom errors. 
1. It was found some `transfer` or `transferFrom` without checking the boolean result, ERC20 standard specify that the token can return false if this call was not made, so it's mandatory to check the result of approve methods. - [NFTVault.sol#L899](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L899) - [JPEGStaking.sol#L34](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/staking/JPEGStaking.sol#L34) - [JPEGStaking.sol#L52](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/staking/JPEGStaking.sol#L52)  2. Lack of input checks. - [LPFarming.sol#L77](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L77) 
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L144-L145   # Vulnerability details  ## Impact In `deposit`, the balance is cached and then a `token.transferFrom` is triggered which can lead to exploits if the `token` is a token that gives control to the sender, like ERC777 tokens.  #### POC Initial state: `balance() = 1000`, shares `supply = 1000`. Depositing 1000 amount should mint 1000 supply, but one can split the 1000 amounts into two 500 deposits and use re-entrancy to profit.  - Outer `deposit(500)`: `balanceBefore = 1000`. Control is given to attacker ... - Inner `deposit(500)`: `balanceBefore = 1000`. `shares = (_amount * supply) / balanceBefore = 500 * 1000 / 1000 = 500` shares are minted ... - Outer `deposit(500)` continues with the mint: `shares = (_amount * supply) / balanceBefore = 500 * 1500 / 1000 = 750` are minted. - Withdrawing the `500 + 750 = 1250` shares via `withdraw(1250)`, the attacker receives `backingTokens = (balance() * _shares) / supply = 2000 * 1250 / 2250 = 1111.111111111`. The attacker makes a profit of `1111 - 1000 = 111` tokens. - They repeat the attack until the vault is drained.  ## Recommended Mitigation Steps The `safeTransferFrom` should be the last call in `deposit`.   
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L799   # Vulnerability details  ## Impact The owner of an **insured** position that has been liquidated can claim back their NFT without paying back the debt by calling `closePosition` instead of `repurchase`.  ```solidity function closePosition(uint256 _nftIndex)     external     // @audit NFT is still valid (ownerOf(nft) == this)     validNFTIndex(_nftIndex) {     accrue();     // @audit owner is still original owner (depositor)     require(msg.sender == positionOwner[_nftIndex], "unauthorized");     // @audit debt is zero as it's been repaid by liquidator     require(_getDebtAmount(_nftIndex) == 0, "position_not_repaid");      positionOwner[_nftIndex] = address(0);     delete positions[_nftIndex];     positionIndexes.remove(_nftIndex);      // transfer nft back to owner if nft was deposited     if (nftContract.ownerOf(_nftIndex) == address(this)) {         nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);     }      emit PositionClosed(msg.sender, _nftIndex); } ```  The `liquidate` function sets `position.debtPortion = 0;` and does not clear the `owner` which means all `closePosition` checks pass. This means that PUSD can be minted for free by:  - Attacker deposits NFT collateral in insured state and borrow PUSD against it - Let it be liquidated (the liquidator unexpectedly loses as they cannot get the NFT through `claimExpiredInsuranceNFT` anymore) - Attacker claims it back through `closePosition` - Repeat  ## Recommended Mitigation Steps Consider checking in `closePosition` that the position has not been liquidated.   
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L212   # Vulnerability details  ## Impact The `setDebtInterestApr` changes the debt interest rate without first accruing the debt. This means that the new debt interest rate is applied retroactively to the unaccrued period on next `accrue()` call.  It should never be applied retroactively to a previous time window as this is unfair & wrong. Borrowers can incur more debt than they should.  ## Recommended Mitigation Steps Call `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`.  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/Controller.sol#L95 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L266   # Vulnerability details  ## Details  The controller calls the `withdraw()` method to withdraw JPEGs from the contract, but the strategy might blacklist the JPEG asset, which is what the PUSDConvex strategy has done.  The migration would therefore revert.  ## Proof of Concept  Insert this test into [`StrategyPUSDConvex.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/StrategyPUSDConvex.ts).  ```jsx it.only("will revert when attempting to migrate strategy", async () => {   await controller.setVault(want.address, yVault.address);   await expect(controller.setStrategy(want.address, strategy.address)).to.be.revertedWith("jpeg"); }); ```  ## Recommended Mitigation Steps  Replace `_current.withdraw(address(jpeg));` with `_current.withdrawJPEG(vaults[_token])`.  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/yVaultLPFarming.sol#L169-L170   # Vulnerability details  ## Details & Impact  yVault users participating in the farm have to trust that:  - `vault.balanceOfJPEG()`  returns the correct claimable JPEG amount by its strategy / strategies - the strategy / strategies will send all claimable JPEG to the farm  Should either of these assumptions break, then it could be possibly be the case that `currentBalance` is less than `previousBalance`, causing deposits and crucially, withdrawals to fail due to subtraction overflow.  ## Proof of Concept  For instance,   - Farm migration occurs. A new farm is set in `yVault`, then `withdrawJPEG()` is called, which sends funds to the new farm. Users of the old farm would be unable to withdraw their deposits.  ```jsx it.only("will revert old farms' deposits and withdrawals if yVault migrates farm", async () => {   // 0. setup   await token.mint(owner.address, units(1000));   await token.approve(yVault.address, units(1000));   await yVault.depositAll();   await yVault.approve(lpFarming.address, units(1000));   // send some JPEG to strategy prior to deposit   await jpeg.mint(strategy.address, units(100));   // deposit twice, so that the second deposit will invoke _update()   await lpFarming.deposit(units(250));   await lpFarming.deposit(units(250));     // 1. change farm and call withdrawJPEG()   await yVault.setFarmingPool(user1.address);   await yVault.withdrawJPEG();     // deposit and withdrawal will fail   await expect(lpFarming.deposit(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');   await expect(lpFarming.withdraw(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)'); }); ```  - Strategy migration occurs, but JPEG funds held by the old strategy were not claimed, causing `vault.balanceOfJPEG()` to report a smaller amount than previously recorded - `jpeg` could be accidentally included in the StrategyConfig, resulting in JPEG being converted to other assets - A future implementation takes a fee on the `jpeg` to be claimed  ## Recommended Mitigation Steps  A simple fix would be to `return` if `currentBalance ≤ previousBalance`. A full fix would properly handle potential shortfall.  ```jsx if (currentBalance <= previousBalance) return; ```  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L105   # Vulnerability details  ## Impact Price can be stale and can lead to wrong `answer` return value.  ## Proof of Concept Oracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong  `answer`  return value.  ``` function _collateralPriceUsd() internal view returns (uint256) {         int256 answer = oracle.latestAnswer();         uint8 decimals = oracle.decimals();          require(answer > 0, "invalid_oracle_answer");          ...  ```  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L105  ## Tools Used Manual review ## Recommended Mitigation Steps Validate data feed  ``` function _collateralPriceUsd() internal view returns (uint256) {  (uint80 roundID, int256 answer, , uint256 timestamp, uint80 answeredInRound) = oracle.latestRoundData();         require(answer > 0, "invalid_oracle_answer");     require(answeredInRound >= roundID, "ChainLink: Stale price");     require(timestamp > 0, "ChainLink: Round not complete");           ...  ```  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L201   # Vulnerability details  ## Impact  Function `FungibleAssetVaultForDAO.withdraw` in line 201 uses native `transfer` function to send ETH to `msg.sender`.  This is unsafe as transfer has hard coded gas budget (2300 gas) and can fail when the user is a smart contract. Especially when this contract is for DAO and ecosystem contracts as documentation.   ## Proof-of-concept https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L201   ## Tools Used Manual code review  ## Recommended Mitigation Steps  All functions have a `nonReentrant` modifier already, so reentrancy is not an issue and `transfer()` can be replaced.  Using low-level call.value(amount) with the corresponding result check or using the OpenZeppelin Address.sendValue is advised https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60   
https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/JPEG.sol#L20 Consider added valid check for the to address. The to address can be of a contract or another token or user. See below test code to replicate the behavior it("should return the correct JPEG balance", async () => {     await controller.approveStrategy(token.address, strategy.address);     await controller.setStrategy(token.address, strategy.address);     await jpeg.mint(token.address, units(500)); --- the to address can be any address.     expect(await controller.balanceOfJPEG(token.address)).to.equal(units(500)); });  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L115 setFarmingPool is declared public but not called from within the contract. Consider makin it external. Public visiility will persist the parameters which can incurr as fees.  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L35 The whitelistedContractMap is not necessary. It can be an address array. If contract is whitelisted, then add to array, if not, remove it. Removing the extra flag will save some space in the contract.  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L187 Function withdrawJPEG() seems duplicate of Controller.withdrawJPEG() and is not necessay. Remove the function or make it a utility.  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L61 Modifier noContract() is duplicated, can be abstracted out  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L89 setContractWhitelisted is duplicated, can be abstracted out
Use ```assert``` instead of ```require``` https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/helpers/CryptoPunksHelper.sol#L79 https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/helpers/EtherRocksHelper.sol#L81   ## proof of concept  https://ethereum.stackexchange.com/questions/15166/difference-between-require-and-assert-and-the-difference-between-revert-and-thro 
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L190   # Vulnerability details  ## Impact ###### LpFarming.sol reward will be locked in the farming, when user execute a direct transfer with lpToken to farm without using deposit    ## Proof of Concept "pls add this test to LpFarming.ts to check"   ``` it("a part of rewards can't be distributed if user execute a direct transfer to farm", async() => {       // manual mine new block         await network.provider.send("evm_setAutomine", [false]);        // prepare        const attacker = bob;       await lpTokens[0].transfer(alice.address, units(1000));       await lpTokens[0].transfer(attacker.address, units(1000));       await lpTokens[0].connect(alice).approve(farming.address, units(1000));       await mineBlocks(1);        // attacker direct deposit lp token to the pool        await lpTokens[0].connect(attacker).transfer(farming.address, units(100));        // create new pool       await farming.add(10, lpTokens[0].address);       await mineBlocks(1);       expect(await farming.poolLength()).to.equal(1);        let pool = await farming.poolInfo(0);       expect(pool.lpToken).to.equal(lpTokens[0].address);       expect(pool.allocPoint).to.equal(10);        // create new epoch ==> balance of pool will be 1000        let blockNumber = await ethers.provider.getBlockNumber();       await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);        // alice deposit        await farming.connect(alice).deposit(0, units(100));       await mineBlocks(1);        expect(await jpeg.balanceOf(farming.address)).to.equal(1000);        // when pool end, alice can just take 500 jpeg, and 500 jpeg will be locked in the contract forever !!!       await mineBlocks(13);       console.log("reward of alice: ", (await   farming.pendingReward(0, alice.address)).toString());       expect(await farming.pendingReward(0, alice.address)).to.equal(BigNumber.from('500'));     }); ``` In the test above, the attacker transfers 100 lpToken to the farm without using deposit function, and alice deposit 100 lpToken. Because the contract uses ```pool.lpToken.balanceOf(address(this))``` to get the total supply of lpToken in the pool, it will sum up 100 lpToken of attacker and 100 lpToken of alice. This will lead to the situation where Alice will only be able to claim 500 token (at epoch.endBlock), the rest will be locked in the pool forever. Not only with this pool, it also affects the following, a part of the reward will be locked in the pool when the farm end.  ## Tools Used typescript   ## Recommended Mitigation Steps Declare a new variable ```totalLPSupply``` to the struct ```PoolInfo```, and use it instead of ```pool.lpToken.balanceOf(address(this))```   
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L148-L153   # Vulnerability details  ## Details  The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.  ## Proof of Concept  - Attacker deposits 1 wei to mint 1 share - Attacker transfers exorbitant amount to the `StrategyPUSDConvex` contract to greatly inflate the share’s price. Note that the strategy deposits its entire balance into Convex when its `deposit()` function is called. - Subsequent depositors instead have to deposit an equivalent sum to avoid minting 0 shares. Otherwise, their deposits accrue to the attacker who holds the only share.  Insert this test into [`yVault.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/yVault.ts).  ```jsx it.only("will cause 0 share issuance", async () => {   // mint 10k + 1 wei tokens to user1   // mint 10k tokens to owner   let depositAmount = units(10_000);   await token.mint(user1.address, depositAmount.add(1));   await token.mint(owner.address, depositAmount);   // token approval to yVault   await token.connect(user1).approve(yVault.address, 1);   await token.connect(owner).approve(yVault.address, depositAmount);      // 1. user1 mints 1 wei = 1 share   await yVault.connect(user1).deposit(1);      // 2. do huge transfer of 10k to strategy   // to greatly inflate share price (1 share = 10k + 1 wei)   await token.connect(user1).transfer(strategy.address, depositAmount);      // 3. owner deposits 10k   await yVault.connect(owner).deposit(depositAmount);   // receives 0 shares in return   expect(await yVault.balanceOf(owner.address)).to.equal(0);    // user1 withdraws both his and owner's deposits   // total amt: 20k + 1 wei   await expect(() => yVault.connect(user1).withdrawAll())     .to.changeTokenBalance(token, user1, depositAmount.mul(2).add(1)); }); ```  ## Recommended Mitigation Steps  - [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. - Ensure the number of shares to be minted is non-zero: `require(_shares != 0, "zero shares minted");`  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/vaults/yVault/yVault.sol#L61 https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/farming/yVaultLPFarming.sol#L54 https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/vaults/yVault/yVault.sol#L61   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  The expectation of the noContract modifier is to allow access only to accounts inside EOA or Whitelist, if access is controlled using ! access control with _account.isContract(), then because isContract() gets the size of the code length of the account in question by relying on extcodesize/address.code.length, this means that the restriction can be bypassed when deploying a smart contract through the smart contract's constructor call.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps  Modify the code to `require(msg.sender == tx.origin);`  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L375 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/lock/JPEGLock.sol#L54-L62   # Vulnerability details  ## Details & Impact  A user’s JPEG lock schedule can be overwritten by another user’s if he (the other user) submits and finalizes a proposal to change the same NFT index’s value.  The existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.  ## Proof of Concept  1. `user` successfully proposes and finalizes a proposal to change his NFT’s collateral value 2. Another user (`owner`) does the same for the same NFT index 3. `user` will be unable to withdraw his locked JPEG because schedule has been overwritten  Insert this test case into [`NFTVault.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/NFTVault.ts).  ```jsx it.only("will overwrite existing user's JPEG lock schedule", async () => {   // 0. setup   const index = 7000;   await erc721.mint(user.address, index);   await nftVault     .connect(dao)     .setPendingNFTValueETH(index, units(50));   await jpeg.transfer(user.address, units(150000));   await jpeg.connect(user).approve(locker.address, units(500000));   await jpeg.connect(owner).approve(locker.address, units(500000));    // 1. user has JPEG locked for finalization   await nftVault.connect(user).finalizePendingNFTValueETH(index);    // 2. owner submit proposal to further increase NFT value   await nftVault     .connect(dao)     .setPendingNFTValueETH(index, units(100));      // 3. owner finalizes, has JPEG locked   await nftVault.connect(owner).finalizePendingNFTValueETH(index);    // user schedule has been overwritten   let schedule = await locker.positions(index);   expect(schedule.owner).to.equal(owner.address);    // user tries to unstake   // wont be able to because schedule was overwritten   await timeTravel(days(366));   await expect(locker.connect(user).unlock(index)).to.be.revertedWith("unauthorized"); }); ```  ## Recommended Mitigation Steps  1. Release the tokens of the existing schedule. Simple and elegant.  ```jsx // in JPEGLock#lockFor() LockPosition memory existingPosition = positions[_nftIndex]; if (existingPosition.owner != address(0)) {   // release jpegs to existing owner   jpeg.safeTransfer(existingPosition.owner, existingPosition.lockAmount); } ```  2. Revert in `finalizePendingNFTValueETH()` there is an existing lock schedule. This is less desirable IMO, as there is a use-case for increasing / decreasing the NFT value.  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L675 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L560   # Vulnerability details  ## Impact In `NFTVault.sol` the `borrow()` function does not follow the Checks Effects Interactions pattern. There are important state updates that occur after an external call which happens in `_openPosition()`.  Assuming that the `nonReentrant` modifier makes this ok is false due to the threat of cross function reentrancy. `require` checks should be done followed by state updates and then any external calls in accord with the Checks Effects Interactions pattern  ## Proof of Concept  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L675  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L560  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  ## Tools Used Manual code review   ## Recommended Mitigation Steps The `borrow()` function should fully implement the Checks Effects Interactions pattern performing all external calls last and not making important state updates after external calls.   
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/FungibleAssetVaultForDAO.sol#L105   # Vulnerability details  ## Impact According to Chainlink's documentation, the latestAnswer function is deprecated. This function might suddenly stop working if Chainlink stop supporting deprecated APIs. And the old API can return stale data.  ## Proof of Concept https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/FungibleAssetVaultForDAO.sol#L105 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L459 ## Tools Used None ## Recommended Mitigation Steps Use the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete https://docs.chain.link/docs/price-feeds-api-reference/  
# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L141-L154   # Vulnerability details  ## Impact In the LPFarming contract, a new staking pool can be added using the add() function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the _lpToken is the same as the reward token (jpeg) or not. ```     function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {         _massUpdatePools();          uint256 lastRewardBlock = _blockNumber();         totalAllocPoint = totalAllocPoint + _allocPoint;         poolInfo.push(             PoolInfo({                 lpToken: _lpToken,                 allocPoint: _allocPoint,                 lastRewardBlock: lastRewardBlock,                 accRewardPerShare: 0             })         );     } ```  When the _lpToken is the same token as jpeg, reward calculation for that pool in the updatePool() function can be incorrect. This is because the current balance of the _lpToken in the contract is used in the calculation of the reward. Since the _lpToken is the same token as the reward, the reward minted to the contract will inflate the value of lpSupply, causing the reward of that pool to be less than what it should be. ```     function _updatePool(uint256 _pid) internal {         PoolInfo storage pool = poolInfo[_pid];         if (pool.allocPoint == 0) {             return;         }          uint256 blockNumber = _blockNumber();         //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch         uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);         if (blockNumber <= lastRewardBlock) {             return;         }         uint256 lpSupply = pool.lpToken.balanceOf(address(this));         if (lpSupply == 0) {             pool.lastRewardBlock = blockNumber;             return;         }         uint256 reward = ((blockNumber - lastRewardBlock) *             epoch.rewardPerBlock *             1e36 *             pool.allocPoint) / totalAllocPoint;         pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;         pool.lastRewardBlock = blockNumber;     } ```  ## Proof of Concept https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L141-L154 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L288-L311 ## Tools Used None  ## Recommended Mitigation Steps  Add a check that _lpToken is not jpeg in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token.   
