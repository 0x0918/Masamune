# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L418 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L147-L151 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L364   # Vulnerability details  ## Impact  Vesting is a legal term that means the point in time where property is earned or gained by some person. The VTVLVesting contract defines: - a start time (Claim::startTimestamp) and an end time (Claim::endTimestamp) at which vesting starts and ends for a entitled user - the calculated points in time when the fractions of the total amount are released and therefore can be withdrawn (which are defined by Claim::releaseIntervalSecs). The entitled user can either withdraw after each interval elapses, or after the whole vesting period is over or any variant of the two options.  The administrator of the contract can revoke the claim for a user at any time, which for vesting assets is expected. For example an employee with a vesting stock allocation of 1000 shares vesting at each quarter over a period of 4 years, may resign after 2 years and therefore the only half of the shares would be vested and therefore sold by the employee. The employee can either sell them at each quarter, or before, or after resigning, in any case the half of the shares have vested and are by legal right owned by the employee.  The VTVLContract revoke has the following defects: - it ignores the amount already vested and now yet withdrawn - if called, say half-way the total period, just after claimer withdraws the already vested amount, it revokes only the right to vest the remaining part in future. - if called, say half-way the total period, right before the claimer withdraws the already vested amount, it revokes both the already vested amount and the right to vest the remaining part in future.  Raising as high impact because it actually causes: - loss of already vested amounts of a user with a valid claim that has already righteously vested a part but not withdrawn - different outcomes depending on the order in which withdraw and revokeClaim functions are called which means that one of the two behavoiurs is certainly in conflict with the other causing a loss on one of the two sides, contract or claimer (by definition of Vesting rights, the claimer). - lack of trust by the potential claimers/users whch can be at any time deprived of righteously vested amounts.  ## Proof of Concept  The following two tests prove the behaviour difference when the order by which revokeClaim vs withdraw are called, whch shows that the vesting right is not guaranteed.  ```solidity   // NOTE: USES ORIGINAL REVOKE BEHAVIOUR   it('sample revoke use case USER LOSE: employee withdraw immediately after resignation', async () => {     const {tokenContract, vestingContract} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens});      const startTimestamp = await getLastBlockTs() + 100;     const endTimestamp = startTimestamp + 2000;     const terminationTimestamp = startTimestamp + 1000 + 50; // half-way vesting, plus half release interval which shall be discarded     const releaseIntervalSecs = 100;      await vestingContract.createClaim(owner2.address, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount);      // move clock to termination timestamp (half-way the vesting period plus a bit, but less than release interval seconds)     await ethers.provider.send("evm_mine", [terminationTimestamp]);          let availableAmt = await vestingContract.claimableAmount(owner2.address)     // revoke the claim preserving the "already vested but not yet withdrawn amount"     await (await vestingContract.revokeClaim(owner2.address)).wait();          let userBalanceBefore = await tokenContract.balanceOf(owner2.address);     await expect(vestingContract.connect(owner2).withdraw()).to.be.revertedWith('NO_ACTIVE_CLAIM');     let userBalanceAfter = await tokenContract.balanceOf(owner2.address);      // move the clock to the programmed end of vesting period     await ethers.provider.send("evm_mine", [endTimestamp]);      // cliffTimestamp < startTimestamp < terminationTimestamp, hence expected cliffAmount + (1/2 * anlinearVestAmount)     let expectedVestedAmount = cliffAmount.add(linearVestAmount.div(2));      // RESIGNING EMPLOYEE LOSES HIS VESTED AMOUNT BECAUSE OF WITHDRAWING IMMEDIATELY AFTER RESIGNATION     expect(userBalanceAfter.sub(userBalanceBefore)).to.be.equal(0);     // VTVLVesting CONTRACT TOOK ALREADY VESTED AMOUNT FROM OWNER2     expect(await vestingContract.finalClaimableAmount(owner2.address)).to.be.equal(0);   });    // NOTE: USES ORIGINAL REVOKE BEHAVIOUR   it('sample revoke use case USER WIN: employee withdraw immediately before resignation', async () => {     const {tokenContract, vestingContract} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens});      const startTimestamp = await getLastBlockTs() + 100;     const endTimestamp = startTimestamp + 2000;     const terminationTimestamp = startTimestamp + 1000 + 50; // half-way vesting, plus half release interval which shall be discarded     const releaseIntervalSecs = 100;      await vestingContract.createClaim(owner2.address, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount);      // move clock to termination timestamp (half-way the vesting period plus a bit, but less than release interval seconds)     await ethers.provider.send("evm_mine", [terminationTimestamp]);      let userBalanceBefore = await tokenContract.balanceOf(owner2.address);     await (await vestingContract.connect(owner2).withdraw()).wait();     let userBalanceAfter = await tokenContract.balanceOf(owner2.address);      // revoke the claim preserving the "already vested but not yet withdrawn amount"     await (await vestingContract.revokeClaim(owner2.address)).wait();          // move the clock to the programmed end of vesting period     await ethers.provider.send("evm_mine", [endTimestamp]);      console.log(userBalanceAfter.sub(userBalanceBefore));     // RESIGNING EMPLOYEE RECEIVES HIS VESTED AMOUNT BY WITHDRAWING IMMEDIATELY BEFORE RESIGNATION     expect(userBalanceAfter.sub(userBalanceBefore)).to.be.greaterThan(0);     expect(await vestingContract.finalClaimableAmount(owner2.address)).to.be.equal(0);   }); ```solidity  ## Tools Used  n/a  ## Recommended Mitigation Steps  Below are, in order, a test and a diff/patch for a proposed fix. The proposed fix is just an idea at how to fix, or in other words, a way to preserve the already vested amount when claim is revoked.  The diff/patch add a deactivationTimestamp to claim, and a new revokeClaimProper that shall replace the revokeClaim function to correct the behaviour. The deactivationTimestamp is used to track the deactivation time for the claim in order to preserve the amount vested so far and allow the user to withdraw the amount righteously earned so far. The _baseVestedAmount and hasActiveClaim have been updated to do proper math when isActive is false but deactivationTimestamp is greater than 0.  The finalVestedAmount has been update to show the "what would be" amount if the vesting would have reached the claim endTimestamp while the finalClaimableAmount takes into consideration the deactivationTimestamp if the claim has been revoked.  The test shows that the already vested amount (cliff + half way linear vesting) is preserved.  ```solidity diff --git a/contracts/VTVLVesting.sol b/contracts/VTVLVesting.sol index 133f19f..7ab955c 100644 --- a/contracts/VTVLVesting.sol +++ b/contracts/VTVLVesting.sol @@ -34,6 +34,7 @@ contract VTVLVesting is Context, AccessProtected {          // Gives us a range from 1 Jan 1970 (Unix epoch) up to approximately 35 thousand years from then (2^40 / (365 * 24 * 60 * 60) ~= 35k)          uint40 startTimestamp; // When does the vesting start (40 bits is enough for TS)          uint40 endTimestamp; // When does the vesting end - the vesting goes linearly between the start and end timestamps +        uint40 deactivationTimestamp;          uint40 cliffReleaseTimestamp; // At which timestamp is the cliffAmount released. This must be <= startTimestamp          uint40 releaseIntervalSecs; // Every how many seconds does the vested amount increase.            @@ -108,7 +109,7 @@ contract VTVLVesting is Context, AccessProtected {            // We however still need the active check, since (due to the name of the function)          // we want to only allow active claims -        require(_claim.isActive == true, "NO_ACTIVE_CLAIM"); +        require(_claim.isActive == true || _claim.deactivationTimestamp > 0, "NO_ACTIVE_CLAIM");            // Save gas, omit further checks          // require(_claim.linearVestAmount + _claim.cliffAmount > 0, "INVALID_VESTED_AMOUNT"); @@ -144,20 +145,20 @@ contract VTVLVesting is Context, AccessProtected {      @param _claim The claim in question      @param _referenceTs Timestamp for which we're calculating       */ -    function _baseVestedAmount(Claim memory _claim, uint40 _referenceTs) internal pure returns (uint112) { +    function _baseVestedAmount(Claim memory _claim, uint40 _referenceTs, uint40 vestEndTimestamp) internal pure returns (uint112) {          uint112 vestAmt = 0; -         -        // the condition to have anything vested is to be active -        if(_claim.isActive) { +             +        if(_claim.isActive || _claim.deactivationTimestamp > 0) {              // no point of looking past the endTimestamp as nothing should vest afterwards              // So if we're past the end, just get the ref frame back to the end -            if(_referenceTs > _claim.endTimestamp) { -                _referenceTs = _claim.endTimestamp; +            if(_referenceTs > vestEndTimestamp) { +                _referenceTs = vestEndTimestamp;              }                // If we're past the cliffReleaseTimestamp, we release the cliffAmount              // We don't check here that cliffReleaseTimestamp is after the startTimestamp  -            if(_referenceTs >= _claim.cliffReleaseTimestamp) { // @audit is _claim.require(cliffReleaseTimestamp < _claim.endTimestamp) ? +            if(_referenceTs >= _claim.cliffReleaseTimestamp) {  // @audit note  cliffReleaseTimestamp cannot? be zero without cliffamoutn being zero +                // @audit NOTE: (cliffReleaseTimestamp is always <= _startTimestamp <= endTimestamp, or 0 if no vesting)                  vestAmt += _claim.cliffAmount;              }   @@ -195,7 +196,8 @@ contract VTVLVesting is Context, AccessProtected {      */      function vestedAmount(address _recipient, uint40 _referenceTs) public view returns (uint112) {          Claim storage _claim = claims[_recipient]; -        return _baseVestedAmount(_claim, _referenceTs); +        uint40 vestEndTimestamp = _claim.isActive ? _claim.endTimestamp : _claim.deactivationTimestamp; +        return _baseVestedAmount(_claim, _referenceTs, vestEndTimestamp);      }        /** @@ -205,7 +207,18 @@ contract VTVLVesting is Context, AccessProtected {       */      function finalVestedAmount(address _recipient) public view returns (uint112) {          Claim storage _claim = claims[_recipient]; -        return _baseVestedAmount(_claim, _claim.endTimestamp); +        return _baseVestedAmount(_claim, _claim.endTimestamp, _claim.endTimestamp); +    } + +    /** +    @notice Calculates how much wil be possible to claim at the end of vesting date, by subtracting the already withdrawn +            amount from the vestedAmount at this moment. Vesting date is either the end timestamp or the deactivation timestamp. +    @param _recipient - The address for whom we're calculating +    */ +    function finalClaimableAmount(address _recipient) external view returns (uint112) { +        Claim storage _claim = claims[_recipient]; +        uint40 vestEndTimestamp = _claim.isActive ? _claim.endTimestamp : _claim.deactivationTimestamp; +        return _baseVestedAmount(_claim, vestEndTimestamp, vestEndTimestamp) - _claim.amountWithdrawn;      }            /** @@ -214,7 +227,8 @@ contract VTVLVesting is Context, AccessProtected {      */      function claimableAmount(address _recipient) external view returns (uint112) {          Claim storage _claim = claims[_recipient]; -        return _baseVestedAmount(_claim, uint40(block.timestamp)) - _claim.amountWithdrawn; +        uint40 vestEndTimestamp = _claim.isActive ? _claim.endTimestamp : _claim.deactivationTimestamp; +        return _baseVestedAmount(_claim, uint40(block.timestamp), vestEndTimestamp) - _claim.amountWithdrawn;      }            /**  @@ -280,6 +294,7 @@ contract VTVLVesting is Context, AccessProtected {          Claim memory _claim = Claim({              startTimestamp: _startTimestamp,              endTimestamp: _endTimestamp, +            deactivationTimestamp: 0,              cliffReleaseTimestamp: _cliffReleaseTimestamp,              releaseIntervalSecs: _releaseIntervalSecs,              cliffAmount: _cliffAmount, @@ -436,6 +451,30 @@ contract VTVLVesting is Context, AccessProtected {          emit ClaimRevoked(_recipient, amountRemaining, uint40(block.timestamp), _claim);      }   +    function revokeClaimProper(address _recipient) external onlyAdmin hasActiveClaim(_recipient) { +        // Fetch the claim +        Claim storage _claim = claims[_recipient]; +        // Calculate what the claim should finally vest to +        uint112 finalVestAmt = finalVestedAmount(_recipient); + +        // No point in revoking something that has been fully consumed +        // so require that there be unconsumed amount +        require( _claim.amountWithdrawn < finalVestAmt, "NO_UNVESTED_AMOUNT"); + +        _claim.isActive = false; +        _claim.deactivationTimestamp = uint40(block.timestamp); + +        uint112 vestedSoFarAmt = vestedAmount(_recipient, uint40(block.timestamp)); +        // The amount that is "reclaimed" is equal to the total allocation less what was already +        // vested without the part that was already withdrawn. +        uint112 amountRemaining = finalVestAmt - (vestedSoFarAmt - _claim.amountWithdrawn); + +        numTokensReservedForVesting -= amountRemaining; // Reduces the allocation + +        // Tell everyone a claim has been revoked. +        emit ClaimRevoked(_recipient, amountRemaining, uint40(block.timestamp), _claim); +    } +      /**      @notice Withdraw a token which isn't controlled by the vesting contract.      @dev This contract controls/vests token at "tokenAddress". However, someone might send a different token.   ```
# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L295 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L388   # Vulnerability details  ## Impact  Some ERC20 token's balance could change, one example is stETH. The balance could become insufficient at the time of `withdraw()`. User's fund will be locked due to DoS. The way to take the fund out is to send more token into the contract, causing fund loss to the protocol. And there is no guarantee that until the end time the balance would stay above the needed amount, the lock and loss issue persist.    ## Proof of Concept  For stETH like tokens, the `balanceOf()` value might go up or down, even without transfer. ```solidity // stETH     function balanceOf(address who) external override view returns (uint256) {         return _shareBalances[who].div(_sharesPerToken);     } ```  In `VTVLVesting`, the `require` check for the spot `balanceOf()` value will pass, but it is possible that as time goes on, the value become smaller and fail the transfer. As a result, the `withdraw()` call will revert, causing DoS, and lock user's fund. ```solidity // contracts/VTVLVesting.sol     function _createClaimUnchecked() private  hasNoClaim(_recipient) {         // ...         require(tokenAddress.balanceOf(address(this)) >= numTokensReservedForVesting + allocatedAmount, "INSUFFICIENT_BALANCE");         // ...     }      function withdraw() hasActiveClaim(_msgSender()) external {         // ...         tokenAddress.safeTransfer(_msgSender(), amountRemaining);         // ...     } ```   #### Reference https://etherscan.io/address/0x312ca0592a39a5fa5c87bb4f1da7b77544a91b87#code   ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  Disallow such kind of variable balance token.
# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L224 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L245 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L302 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L317   # Vulnerability details  ## Impact - L224/245/302/317 - When the smart contracts start to be used, the variable in storage vestingRecipients will start to be filled with addresses, as there is no mechanism to eliminate elements, this will cause the allVestingRecipients() function to generate a DoS yes has many addressess.   ## Recommended Mitigation Steps In the withdraw() function you could remove the element from vestingRecipients that no longer has vesting. This would make the variable not grow without reducing elements. 
# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L183-L187 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L198   # Vulnerability details  ## Description As the comments in `_baseVestedAmount()` explain, once there is any `_claim.amountWithdrawn`, it will be returned if it is greater than the calculated value `vestAmt`. However, `vestAmt` takes account of time, `_referenceTs`, whereas `_claim.amountWithdrawn` is always the amount withdrawn to date. Therefore, for all historical values below `_claim.amountWithdrawn`, including timestamps before `_claim.startTimestamp` and before `_claim.cliffReleaseTimestamp`, `_claim.amountWithdrawn` will be returned.  ## Impact Given that VTVL is intended to be an accessible platform for use by a wide variety of users, this behaviour does create a security risk. Consider these scenarios: - A protocol relies on VTVL as an off-the-shelf solution for vesting, but builds other systems (escrow, NFT grants, access, airdrops) that work by checking the value of `vestedAmount()`. Airdrops are especially likely to be interested in historical values. These values would be distorted by how much users have claimed and so would result in an undesirable distribution of resources. - Even if the above does not occur, consider that VTVL might be passed over as a vesting solution precisely because its historical data is inaccurate. - A contract could be built that inherits from `VTVLVesting` and attempts to use `_baseVestedAmount()` (which is `internal` and so can be used by inheriting contracts). The inheriting contract might apportion rewards based on historical usage. - VTVL itself might wish to inherit from `VTVLVesting` in future.  ## Proof of Concept ```diff diff --git a/test/VTVLVesting.ts b/test/VTVLVestingPOC.ts index bb609fb..073e53f 100644 --- a/test/VTVLVesting.ts +++ b/test/VTVLVestingPOC.ts @@ -500,14 +500,37 @@ describe('Revoke Claim', async () => {    const recipientAddress = await randomAddress();    const [owner, owner2] = await ethers.getSigners();   -  it('allows admin to revoke a valid claim', async () => { +  it('POC: WITHDRAWN DATA IS UNRELIABLE', async () => {      const {vestingContract} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens}); -    await vestingContract.createClaim(recipientAddress, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount); +    const startTimestamp2 = startTimestamp.add(releaseIntervalSecs.mul(100)); +    const endTimestamp2 = endTimestamp.add(releaseIntervalSecs.mul(100)); +    const cliffReleaseTimestamp2 = cliffReleaseTimestamp.add(releaseIntervalSecs.mul(100)); +    await vestingContract.createClaim(owner2.address, startTimestamp2, endTimestamp2, cliffReleaseTimestamp2, releaseIntervalSecs, linearVestAmount, cliffAmount); + +    // Fast forward to middle of claim +    const halfWay = startTimestamp2.toNumber() + (endTimestamp2.toNumber()-startTimestamp2.toNumber())/2; +    await ethers.provider.send("evm_mine", [halfWay]); + +    let vestAmt = await vestingContract.vestedAmount(owner2.address, startTimestamp); +    console.log("NO WITHDRAWAL, BEFORE VEST START: ",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, startTimestamp2); +    console.log("NO WITHDRAWAL, AT VEST START: ",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, halfWay); +    console.log("NO WITHDRAWAL, HALF WAY THROUGH VEST: ",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, endTimestamp2); +    console.log("NO WITHDRAWAL, AT VEST END: ",vestAmt.toString()); + +    await (await vestingContract.connect(owner2).withdraw()).wait();   -    (await vestingContract.revokeClaim(recipientAddress)).wait(); +    vestAmt = await vestingContract.vestedAmount(owner2.address, startTimestamp); +    console.log("WITHDRAWAL, BEFORE VEST START: ",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, startTimestamp2); +    console.log("WITHDRAWAL, AT VEST START: ",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, halfWay); +    console.log("WITHDRAWAL, HALF WAY THROUGH VEST: ",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, endTimestamp2); +    console.log("WITHDRAWAL, AT VEST END: ",vestAmt.toString());   -    // Make sure it gets reverted -    expect(await (await vestingContract.getClaim(recipientAddress)).isActive).to.be.equal(false);    });      it('prohibits a random user from revoking a valid claim', async () => { ```  ## Tools Used Manual Inspection  ## Recommended Mitigation Steps For active claims, there is no reason to consider `_claim.amountWithdrawn`, as it will always have been below or equal to `vestAmt` at any point in time. So only consider `vestAmt` for inactive claims. For them, return the lowest of `vestAmt` and  `_claim.amountWithdrawn`. This will keep the values monotonic with time without distorting the historical values. It will act as though `_claim.amountWithdrawn` was withdrawn and the claim was revoked in the block when `vestAmt` reached `_claim.amountWithdrawn`. That is a distortion, but it is required to provide monotonicity. 
# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L176   # Vulnerability details  ## Description  The _baseVestedAmount() function calculates vested amount for some (claim, timestamp) pair. It is wrapped by several functions, like vestedAmount, which is used in withdraw() to calculate how much a user can retrieve from their claim. Therefore, it is critical that this function will calculate correctly for users to receive their funds.  Below is the calculation of the linear vest amount: ``` uint112 linearVestAmount = _claim.linearVestAmount * truncatedCurrentVestingDurationSecs / finalVestingDurationSecs; ``` Importantly, _claim.linearVestAmount is of type uint112 and truncatedCurrentVestingDurationSecs is of type uint40. Using compiler >= 0.8.0,  the product cannot exceed uint112 or else the function reverts due to overflow. In fact, we can show that uint112 is an inadequate size for this calculation.  The max value for uint112 is 5192296858534827628530496329220096.  Seconds in year = 3600 * 24 * 365 = 31536000  Tokens that inherit from ERC20 like the ones used in VTVL have 18 decimal places -> 1000000000000000000 This means the maximum number of tokens that are safe to vest for one year is 2**112 / 10e18 / (3600 * 24 * 365) = just 16,464,665 tokens.  This is definitely not a very large amount and it is expected that some projects will mint a similar or larger amount for vesting for founders / early employees. For 4 year vesting, the safe amount drops to 4,116,166. Projects that are not forewarned about this size limit are likely to suffer from freeze of funds of employees, which will require very patchy manual revocation and restructuring of the vesting to not overflow.  ## Impact Employees/founders do not have access to their vested tokens.  ## Proof of Concept Below is a test that demonstrates the overflow issue, 1 year after 17,000,000 tokens have matured. ``` describe('Long vest fail', async () => {   let vestingContract: VestingContractType;   // Default params   // linearly Vest 10000, every 1s, between TS 1000 and 2000   // additionally, cliff vests another 5000, at TS = 900   const recipientAddress = await randomAddress();   const startTimestamp = BigNumber.from(1000);   const endTimestamp = BigNumber.from(1000 + 3600 * 24 * 365);   const midTimestamp = BigNumber.from(1000 + (3600 * 24 * 365) / 2);   const cliffReleaseTimestamp = BigNumber.from(0);   const linearVestAmount = BigNumber.from('170000000000000000000000000');   const cliffAmount = BigNumber.from(0);   const releaseIntervalSecs = BigNumber.from(5);    before(async () => {     const {vestingContract: _vc} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens});     vestingContract = _vc;     await vestingContract.createClaim(recipientAddress, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount);   });    it('half term works', async() => {     expect(await vestingContract.vestedAmount(recipientAddress, midTimestamp)).to.be.equal('85000000000000000000000000');   });    it('full term fails', async() => {     // Note: at exactly the cliff time, linear vested amount won't yet come in play as we're only at second 0     await expect(vestingContract.vestedAmount(recipientAddress, endTimestamp)).to.be.revertedWithPanic(0x11     );   }); }); ```  ## Tools Used Manual audit, hardhat / chai.  ## Recommended Mitigation Steps Perform the intermediate calculation of linearVestAmount using the uint256 type. ``` uint112 linearVestAmount = uint112( uint256(_claim.linearVestAmount) * truncatedCurrentVestingDurationSecs / finalVestingDurationSecs); ``` 
# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/main/contracts/token/VariableSupplyERC20Token.sol#L36-L46   # Vulnerability details  ## Impact The admin of the token is not constrained to minting `maxSupply_`, they can mint any number of tokens.  ## Proof of Concept ```js // If we're using maxSupply, we need to make sure we respect it // mintableSupply = 0 means mint at will if(mintableSupply > 0) {  require(amount <= mintableSupply, "INVALID_AMOUNT");  // We need to reduce the amount only if we're using the limit, if not just leave it be  mintableSupply -= amount; } ``` The logic is as follows: if the amount that can be minted is zero, treat this as an infinite mint. Else require that the minted amount is not larger than mintable supply.  One can note that it is possible to mint all mintable supply. Then the mintable supply will be `0` which will be interpreted as infinity and any number of tokens will be possible to be minted.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Treat `2 ** 256 - 1` as infinity instead of `0`. 
# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L418 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L147-L151 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L364   # Vulnerability details  ## Impact  Vesting is a legal term that means the point in time where property is earned or gained by some person. The VTVLVesting contract defines: - a start time (Claim::startTimestamp) and an end time (Claim::endTimestamp) at which vesting starts and ends for a entitled user - the calculated points in time when the fractions of the total amount are released and therefore can be withdrawn (which are defined by Claim::releaseIntervalSecs). The entitled user can either withdraw after each interval elapses, or after the whole vesting period is over or any variant of the two options.  The administrator of the contract can revoke the claim for a user at any time, which for vesting assets is expected. For example an employee with a vesting stock allocation of 1000 shares vesting at each quarter over a period of 4 years, may resign after 2 years and therefore the only half of the shares would be vested and therefore sold by the employee. The employee can either sell them at each quarter, or before, or after resigning, in any case the half of the shares have vested and are by legal right owned by the employee.  The VTVLContract revoke has the following defects: - it ignores the amount already vested and now yet withdrawn - if called, say half-way the total period, just after claimer withdraws the already vested amount, it revokes only the right to vest the remaining part in future. - if called, say half-way the total period, right before the claimer withdraws the already vested amount, it revokes both the already vested amount and the right to vest the remaining part in future.  Raising as high impact because it actually causes: - loss of already vested amounts of a user with a valid claim that has already righteously vested a part but not withdrawn - different outcomes depending on the order in which withdraw and revokeClaim functions are called which means that one of the two behavoiurs is certainly in conflict with the other causing a loss on one of the two sides, contract or claimer (by definition of Vesting rights, the claimer). - lack of trust by the potential claimers/users whch can be at any time deprived of righteously vested amounts.  ## Proof of Concept  The following two tests prove the behaviour difference when the order by which revokeClaim vs withdraw are called, whch shows that the vesting right is not guaranteed.  ```solidity   // NOTE: USES ORIGINAL REVOKE BEHAVIOUR   it('sample revoke use case USER LOSE: employee withdraw immediately after resignation', async () => {     const {tokenContract, vestingContract} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens});      const startTimestamp = await getLastBlockTs() + 100;     const endTimestamp = startTimestamp + 2000;     const terminationTimestamp = startTimestamp + 1000 + 50; // half-way vesting, plus half release interval which shall be discarded     const releaseIntervalSecs = 100;      await vestingContract.createClaim(owner2.address, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount);      // move clock to termination timestamp (half-way the vesting period plus a bit, but less than release interval seconds)     await ethers.provider.send("evm_mine", [terminationTimestamp]);          let availableAmt = await vestingContract.claimableAmount(owner2.address)     // revoke the claim preserving the "already vested but not yet withdrawn amount"     await (await vestingContract.revokeClaim(owner2.address)).wait();          let userBalanceBefore = await tokenContract.balanceOf(owner2.address);     await expect(vestingContract.connect(owner2).withdraw()).to.be.revertedWith('NO_ACTIVE_CLAIM');     let userBalanceAfter = await tokenContract.balanceOf(owner2.address);      // move the clock to the programmed end of vesting period     await ethers.provider.send("evm_mine", [endTimestamp]);      // cliffTimestamp < startTimestamp < terminationTimestamp, hence expected cliffAmount + (1/2 * anlinearVestAmount)     let expectedVestedAmount = cliffAmount.add(linearVestAmount.div(2));      // RESIGNING EMPLOYEE LOSES HIS VESTED AMOUNT BECAUSE OF WITHDRAWING IMMEDIATELY AFTER RESIGNATION     expect(userBalanceAfter.sub(userBalanceBefore)).to.be.equal(0);     // VTVLVesting CONTRACT TOOK ALREADY VESTED AMOUNT FROM OWNER2     expect(await vestingContract.finalClaimableAmount(owner2.address)).to.be.equal(0);   });    // NOTE: USES ORIGINAL REVOKE BEHAVIOUR   it('sample revoke use case USER WIN: employee withdraw immediately before resignation', async () => {     const {tokenContract, vestingContract} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens});      const startTimestamp = await getLastBlockTs() + 100;     const endTimestamp = startTimestamp + 2000;     const terminationTimestamp = startTimestamp + 1000 + 50; // half-way vesting, plus half release interval which shall be discarded     const releaseIntervalSecs = 100;      await vestingContract.createClaim(owner2.address, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount);      // move clock to termination timestamp (half-way the vesting period plus a bit, but less than release interval seconds)     await ethers.provider.send("evm_mine", [terminationTimestamp]);      let userBalanceBefore = await tokenContract.balanceOf(owner2.address);     await (await vestingContract.connect(owner2).withdraw()).wait();     let userBalanceAfter = await tokenContract.balanceOf(owner2.address);      // revoke the claim preserving the "already vested but not yet withdrawn amount"     await (await vestingContract.revokeClaim(owner2.address)).wait();          // move the clock to the programmed end of vesting period     await ethers.provider.send("evm_mine", [endTimestamp]);      console.log(userBalanceAfter.sub(userBalanceBefore));     // RESIGNING EMPLOYEE RECEIVES HIS VESTED AMOUNT BY WITHDRAWING IMMEDIATELY BEFORE RESIGNATION     expect(userBalanceAfter.sub(userBalanceBefore)).to.be.greaterThan(0);     expect(await vestingContract.finalClaimableAmount(owner2.address)).to.be.equal(0);   }); ```solidity  ## Tools Used  n/a  ## Recommended Mitigation Steps  Below are, in order, a test and a diff/patch for a proposed fix. The proposed fix is just an idea at how to fix, or in other words, a way to preserve the already vested amount when claim is revoked.  The diff/patch add a deactivationTimestamp to claim, and a new revokeClaimProper that shall replace the revokeClaim function to correct the behaviour. The deactivationTimestamp is used to track the deactivation time for the claim in order to preserve the amount vested so far and allow the user to withdraw the amount righteously earned so far. The _baseVestedAmount and hasActiveClaim have been updated to do proper math when isActive is false but deactivationTimestamp is greater than 0.  The finalVestedAmount has been update to show the "what would be" amount if the vesting would have reached the claim endTimestamp while the finalClaimableAmount takes into consideration the deactivationTimestamp if the claim has been revoked.  The test shows that the already vested amount (cliff + half way linear vesting) is preserved.  ```solidity diff --git a/contracts/VTVLVesting.sol b/contracts/VTVLVesting.sol index 133f19f..7ab955c 100644 --- a/contracts/VTVLVesting.sol +++ b/contracts/VTVLVesting.sol @@ -34,6 +34,7 @@ contract VTVLVesting is Context, AccessProtected {          // Gives us a range from 1 Jan 1970 (Unix epoch) up to approximately 35 thousand years from then (2^40 / (365 * 24 * 60 * 60) ~= 35k)          uint40 startTimestamp; // When does the vesting start (40 bits is enough for TS)          uint40 endTimestamp; // When does the vesting end - the vesting goes linearly between the start and end timestamps +        uint40 deactivationTimestamp;          uint40 cliffReleaseTimestamp; // At which timestamp is the cliffAmount released. This must be <= startTimestamp          uint40 releaseIntervalSecs; // Every how many seconds does the vested amount increase.            @@ -108,7 +109,7 @@ contract VTVLVesting is Context, AccessProtected {            // We however still need the active check, since (due to the name of the function)          // we want to only allow active claims -        require(_claim.isActive == true, "NO_ACTIVE_CLAIM"); +        require(_claim.isActive == true || _claim.deactivationTimestamp > 0, "NO_ACTIVE_CLAIM");            // Save gas, omit further checks          // require(_claim.linearVestAmount + _claim.cliffAmount > 0, "INVALID_VESTED_AMOUNT"); @@ -144,20 +145,20 @@ contract VTVLVesting is Context, AccessProtected {      @param _claim The claim in question      @param _referenceTs Timestamp for which we're calculating       */ -    function _baseVestedAmount(Claim memory _claim, uint40 _referenceTs) internal pure returns (uint112) { +    function _baseVestedAmount(Claim memory _claim, uint40 _referenceTs, uint40 vestEndTimestamp) internal pure returns (uint112) {          uint112 vestAmt = 0; -         -        // the condition to have anything vested is to be active -        if(_claim.isActive) { +             +        if(_claim.isActive || _claim.deactivationTimestamp > 0) {              // no point of looking past the endTimestamp as nothing should vest afterwards              // So if we're past the end, just get the ref frame back to the end -            if(_referenceTs > _claim.endTimestamp) { -                _referenceTs = _claim.endTimestamp; +            if(_referenceTs > vestEndTimestamp) { +                _referenceTs = vestEndTimestamp;              }                // If we're past the cliffReleaseTimestamp, we release the cliffAmount              // We don't check here that cliffReleaseTimestamp is after the startTimestamp  -            if(_referenceTs >= _claim.cliffReleaseTimestamp) { // @audit is _claim.require(cliffReleaseTimestamp < _claim.endTimestamp) ? +            if(_referenceTs >= _claim.cliffReleaseTimestamp) {  // @audit note  cliffReleaseTimestamp cannot? be zero without cliffamoutn being zero +                // @audit NOTE: (cliffReleaseTimestamp is always <= _startTimestamp <= endTimestamp, or 0 if no vesting)                  vestAmt += _claim.cliffAmount;              }   @@ -195,7 +196,8 @@ contract VTVLVesting is Context, AccessProtected {      */      function vestedAmount(address _recipient, uint40 _referenceTs) public view returns (uint112) {          Claim storage _claim = claims[_recipient]; -        return _baseVestedAmount(_claim, _referenceTs); +        uint40 vestEndTimestamp = _claim.isActive ? _claim.endTimestamp : _claim.deactivationTimestamp; +        return _baseVestedAmount(_claim, _referenceTs, vestEndTimestamp);      }        /** @@ -205,7 +207,18 @@ contract VTVLVesting is Context, AccessProtected {       */      function finalVestedAmount(address _recipient) public view returns (uint112) {          Claim storage _claim = claims[_recipient]; -        return _baseVestedAmount(_claim, _claim.endTimestamp); +        return _baseVestedAmount(_claim, _claim.endTimestamp, _claim.endTimestamp); +    } + +    /** +    @notice Calculates how much wil be possible to claim at the end of vesting date, by subtracting the already withdrawn +            amount from the vestedAmount at this moment. Vesting date is either the end timestamp or the deactivation timestamp. +    @param _recipient - The address for whom we're calculating +    */ +    function finalClaimableAmount(address _recipient) external view returns (uint112) { +        Claim storage _claim = claims[_recipient]; +        uint40 vestEndTimestamp = _claim.isActive ? _claim.endTimestamp : _claim.deactivationTimestamp; +        return _baseVestedAmount(_claim, vestEndTimestamp, vestEndTimestamp) - _claim.amountWithdrawn;      }            /** @@ -214,7 +227,8 @@ contract VTVLVesting is Context, AccessProtected {      */      function claimableAmount(address _recipient) external view returns (uint112) {          Claim storage _claim = claims[_recipient]; -        return _baseVestedAmount(_claim, uint40(block.timestamp)) - _claim.amountWithdrawn; +        uint40 vestEndTimestamp = _claim.isActive ? _claim.endTimestamp : _claim.deactivationTimestamp; +        return _baseVestedAmount(_claim, uint40(block.timestamp), vestEndTimestamp) - _claim.amountWithdrawn;      }            /**  @@ -280,6 +294,7 @@ contract VTVLVesting is Context, AccessProtected {          Claim memory _claim = Claim({              startTimestamp: _startTimestamp,              endTimestamp: _endTimestamp, +            deactivationTimestamp: 0,              cliffReleaseTimestamp: _cliffReleaseTimestamp,              releaseIntervalSecs: _releaseIntervalSecs,              cliffAmount: _cliffAmount, @@ -436,6 +451,30 @@ contract VTVLVesting is Context, AccessProtected {          emit ClaimRevoked(_recipient, amountRemaining, uint40(block.timestamp), _claim);      }   +    function revokeClaimProper(address _recipient) external onlyAdmin hasActiveClaim(_recipient) { +        // Fetch the claim +        Claim storage _claim = claims[_recipient]; +        // Calculate what the claim should finally vest to +        uint112 finalVestAmt = finalVestedAmount(_recipient); + +        // No point in revoking something that has been fully consumed +        // so require that there be unconsumed amount +        require( _claim.amountWithdrawn < finalVestAmt, "NO_UNVESTED_AMOUNT"); + +        _claim.isActive = false; +        _claim.deactivationTimestamp = uint40(block.timestamp); + +        uint112 vestedSoFarAmt = vestedAmount(_recipient, uint40(block.timestamp)); +        // The amount that is "reclaimed" is equal to the total allocation less what was already +        // vested without the part that was already withdrawn. +        uint112 amountRemaining = finalVestAmt - (vestedSoFarAmt - _claim.amountWithdrawn); + +        numTokensReservedForVesting -= amountRemaining; // Reduces the allocation + +        // Tell everyone a claim has been revoked. +        emit ClaimRevoked(_recipient, amountRemaining, uint40(block.timestamp), _claim); +    } +      /**      @notice Withdraw a token which isn't controlled by the vesting contract.      @dev This contract controls/vests token at "tokenAddress". However, someone might send a different token.   ```
# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L295 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L388   # Vulnerability details  ## Impact  Some ERC20 token's balance could change, one example is stETH. The balance could become insufficient at the time of `withdraw()`. User's fund will be locked due to DoS. The way to take the fund out is to send more token into the contract, causing fund loss to the protocol. And there is no guarantee that until the end time the balance would stay above the needed amount, the lock and loss issue persist.    ## Proof of Concept  For stETH like tokens, the `balanceOf()` value might go up or down, even without transfer. ```solidity // stETH     function balanceOf(address who) external override view returns (uint256) {         return _shareBalances[who].div(_sharesPerToken);     } ```  In `VTVLVesting`, the `require` check for the spot `balanceOf()` value will pass, but it is possible that as time goes on, the value become smaller and fail the transfer. As a result, the `withdraw()` call will revert, causing DoS, and lock user's fund. ```solidity // contracts/VTVLVesting.sol     function _createClaimUnchecked() private  hasNoClaim(_recipient) {         // ...         require(tokenAddress.balanceOf(address(this)) >= numTokensReservedForVesting + allocatedAmount, "INSUFFICIENT_BALANCE");         // ...     }      function withdraw() hasActiveClaim(_msgSender()) external {         // ...         tokenAddress.safeTransfer(_msgSender(), amountRemaining);         // ...     } ```   #### Reference https://etherscan.io/address/0x312ca0592a39a5fa5c87bb4f1da7b77544a91b87#code   ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  Disallow such kind of variable balance token.
# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L224 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L245 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L302 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L317   # Vulnerability details  ## Impact - L224/245/302/317 - When the smart contracts start to be used, the variable in storage vestingRecipients will start to be filled with addresses, as there is no mechanism to eliminate elements, this will cause the allVestingRecipients() function to generate a DoS yes has many addressess.   ## Recommended Mitigation Steps In the withdraw() function you could remove the element from vestingRecipients that no longer has vesting. This would make the variable not grow without reducing elements. 
# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L183-L187 https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L198   # Vulnerability details  ## Description As the comments in `_baseVestedAmount()` explain, once there is any `_claim.amountWithdrawn`, it will be returned if it is greater than the calculated value `vestAmt`. However, `vestAmt` takes account of time, `_referenceTs`, whereas `_claim.amountWithdrawn` is always the amount withdrawn to date. Therefore, for all historical values below `_claim.amountWithdrawn`, including timestamps before `_claim.startTimestamp` and before `_claim.cliffReleaseTimestamp`, `_claim.amountWithdrawn` will be returned.  ## Impact Given that VTVL is intended to be an accessible platform for use by a wide variety of users, this behaviour does create a security risk. Consider these scenarios: - A protocol relies on VTVL as an off-the-shelf solution for vesting, but builds other systems (escrow, NFT grants, access, airdrops) that work by checking the value of `vestedAmount()`. Airdrops are especially likely to be interested in historical values. These values would be distorted by how much users have claimed and so would result in an undesirable distribution of resources. - Even if the above does not occur, consider that VTVL might be passed over as a vesting solution precisely because its historical data is inaccurate. - A contract could be built that inherits from `VTVLVesting` and attempts to use `_baseVestedAmount()` (which is `internal` and so can be used by inheriting contracts). The inheriting contract might apportion rewards based on historical usage. - VTVL itself might wish to inherit from `VTVLVesting` in future.  ## Proof of Concept ```diff diff --git a/test/VTVLVesting.ts b/test/VTVLVestingPOC.ts index bb609fb..073e53f 100644 --- a/test/VTVLVesting.ts +++ b/test/VTVLVestingPOC.ts @@ -500,14 +500,37 @@ describe('Revoke Claim', async () => {    const recipientAddress = await randomAddress();    const [owner, owner2] = await ethers.getSigners();   -  it('allows admin to revoke a valid claim', async () => { +  it('POC: WITHDRAWN DATA IS UNRELIABLE', async () => {      const {vestingContract} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens}); -    await vestingContract.createClaim(recipientAddress, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount); +    const startTimestamp2 = startTimestamp.add(releaseIntervalSecs.mul(100)); +    const endTimestamp2 = endTimestamp.add(releaseIntervalSecs.mul(100)); +    const cliffReleaseTimestamp2 = cliffReleaseTimestamp.add(releaseIntervalSecs.mul(100)); +    await vestingContract.createClaim(owner2.address, startTimestamp2, endTimestamp2, cliffReleaseTimestamp2, releaseIntervalSecs, linearVestAmount, cliffAmount); + +    // Fast forward to middle of claim +    const halfWay = startTimestamp2.toNumber() + (endTimestamp2.toNumber()-startTimestamp2.toNumber())/2; +    await ethers.provider.send("evm_mine", [halfWay]); + +    let vestAmt = await vestingContract.vestedAmount(owner2.address, startTimestamp); +    console.log("NO WITHDRAWAL, BEFORE VEST START: ",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, startTimestamp2); +    console.log("NO WITHDRAWAL, AT VEST START: ",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, halfWay); +    console.log("NO WITHDRAWAL, HALF WAY THROUGH VEST: ",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, endTimestamp2); +    console.log("NO WITHDRAWAL, AT VEST END: ",vestAmt.toString()); + +    await (await vestingContract.connect(owner2).withdraw()).wait();   -    (await vestingContract.revokeClaim(recipientAddress)).wait(); +    vestAmt = await vestingContract.vestedAmount(owner2.address, startTimestamp); +    console.log("WITHDRAWAL, BEFORE VEST START: ",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, startTimestamp2); +    console.log("WITHDRAWAL, AT VEST START: ",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, halfWay); +    console.log("WITHDRAWAL, HALF WAY THROUGH VEST: ",vestAmt.toString()); +    vestAmt = await vestingContract.vestedAmount(owner2.address, endTimestamp2); +    console.log("WITHDRAWAL, AT VEST END: ",vestAmt.toString());   -    // Make sure it gets reverted -    expect(await (await vestingContract.getClaim(recipientAddress)).isActive).to.be.equal(false);    });      it('prohibits a random user from revoking a valid claim', async () => { ```  ## Tools Used Manual Inspection  ## Recommended Mitigation Steps For active claims, there is no reason to consider `_claim.amountWithdrawn`, as it will always have been below or equal to `vestAmt` at any point in time. So only consider `vestAmt` for inactive claims. For them, return the lowest of `vestAmt` and  `_claim.amountWithdrawn`. This will keep the values monotonic with time without distorting the historical values. It will act as though `_claim.amountWithdrawn` was withdrawn and the claim was revoked in the block when `vestAmt` reached `_claim.amountWithdrawn`. That is a distortion, but it is required to provide monotonicity. 
# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/f68b7f3e61dad0d873b5b5a1e8126b839afeab5f/contracts/VTVLVesting.sol#L176   # Vulnerability details  ## Description  The _baseVestedAmount() function calculates vested amount for some (claim, timestamp) pair. It is wrapped by several functions, like vestedAmount, which is used in withdraw() to calculate how much a user can retrieve from their claim. Therefore, it is critical that this function will calculate correctly for users to receive their funds.  Below is the calculation of the linear vest amount: ``` uint112 linearVestAmount = _claim.linearVestAmount * truncatedCurrentVestingDurationSecs / finalVestingDurationSecs; ``` Importantly, _claim.linearVestAmount is of type uint112 and truncatedCurrentVestingDurationSecs is of type uint40. Using compiler >= 0.8.0,  the product cannot exceed uint112 or else the function reverts due to overflow. In fact, we can show that uint112 is an inadequate size for this calculation.  The max value for uint112 is 5192296858534827628530496329220096.  Seconds in year = 3600 * 24 * 365 = 31536000  Tokens that inherit from ERC20 like the ones used in VTVL have 18 decimal places -> 1000000000000000000 This means the maximum number of tokens that are safe to vest for one year is 2**112 / 10e18 / (3600 * 24 * 365) = just 16,464,665 tokens.  This is definitely not a very large amount and it is expected that some projects will mint a similar or larger amount for vesting for founders / early employees. For 4 year vesting, the safe amount drops to 4,116,166. Projects that are not forewarned about this size limit are likely to suffer from freeze of funds of employees, which will require very patchy manual revocation and restructuring of the vesting to not overflow.  ## Impact Employees/founders do not have access to their vested tokens.  ## Proof of Concept Below is a test that demonstrates the overflow issue, 1 year after 17,000,000 tokens have matured. ``` describe('Long vest fail', async () => {   let vestingContract: VestingContractType;   // Default params   // linearly Vest 10000, every 1s, between TS 1000 and 2000   // additionally, cliff vests another 5000, at TS = 900   const recipientAddress = await randomAddress();   const startTimestamp = BigNumber.from(1000);   const endTimestamp = BigNumber.from(1000 + 3600 * 24 * 365);   const midTimestamp = BigNumber.from(1000 + (3600 * 24 * 365) / 2);   const cliffReleaseTimestamp = BigNumber.from(0);   const linearVestAmount = BigNumber.from('170000000000000000000000000');   const cliffAmount = BigNumber.from(0);   const releaseIntervalSecs = BigNumber.from(5);    before(async () => {     const {vestingContract: _vc} = await createPrefundedVestingContract({tokenName, tokenSymbol, initialSupplyTokens});     vestingContract = _vc;     await vestingContract.createClaim(recipientAddress, startTimestamp, endTimestamp, cliffReleaseTimestamp, releaseIntervalSecs, linearVestAmount, cliffAmount);   });    it('half term works', async() => {     expect(await vestingContract.vestedAmount(recipientAddress, midTimestamp)).to.be.equal('85000000000000000000000000');   });    it('full term fails', async() => {     // Note: at exactly the cliff time, linear vested amount won't yet come in play as we're only at second 0     await expect(vestingContract.vestedAmount(recipientAddress, endTimestamp)).to.be.revertedWithPanic(0x11     );   }); }); ```  ## Tools Used Manual audit, hardhat / chai.  ## Recommended Mitigation Steps Perform the intermediate calculation of linearVestAmount using the uint256 type. ``` uint112 linearVestAmount = uint112( uint256(_claim.linearVestAmount) * truncatedCurrentVestingDurationSecs / finalVestingDurationSecs); ``` 
# Lines of code  https://github.com/code-423n4/2022-09-vtvl/blob/main/contracts/token/VariableSupplyERC20Token.sol#L36-L46   # Vulnerability details  ## Impact The admin of the token is not constrained to minting `maxSupply_`, they can mint any number of tokens.  ## Proof of Concept ```js // If we're using maxSupply, we need to make sure we respect it // mintableSupply = 0 means mint at will if(mintableSupply > 0) {  require(amount <= mintableSupply, "INVALID_AMOUNT");  // We need to reduce the amount only if we're using the limit, if not just leave it be  mintableSupply -= amount; } ``` The logic is as follows: if the amount that can be minted is zero, treat this as an infinite mint. Else require that the minted amount is not larger than mintable supply.  One can note that it is possible to mint all mintable supply. Then the mintable supply will be `0` which will be interpreted as infinity and any number of tokens will be possible to be minted.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Treat `2 ** 256 - 1` as infinity instead of `0`. 
