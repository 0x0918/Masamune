Judge has assessed an item in Issue #104 as Medium risk. The relevant finding follows:  ## L01: Silent overflow of `_fCashAmount`  ### Line References  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L526](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L526)  ### Description  If a `_fCashAmount` value that is greater than uint88 is passed into the `_mint` function, downcasting it to uint88 will silently overflow.   ### Recommended Mitigation Steps  ```solidity // Use a safe downcast function e.g. wfCashLogic::_safeUint88 function _safeUint88(uint256 x) internal pure returns (uint88) {hil     require(x <= uint256(type(uint88).max));     return uint88(x); } ``` 
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L212-L222   # Vulnerability details  ## Impact Control is transferred to the receiver when receiving the ERC777. They are able to transfer the ERC777 to another account, at which time the before and after balance calculation will be incorrect.  ```         uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);           if (msg.sender != owner) {             _spendAllowance(owner, msg.sender, shares);         }         _redeemInternal(shares, receiver, owner); ///////////// Control is transferred to user. They can alter their balance here. ///////////          uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);         uint256 assets = balanceAfter - balanceBefore;  ////////// Assets can be as low as 0 if they have transferred the same amount out as received. //////////          emit Withdraw(msg.sender, receiver, owner, assets, shares);         return assets; ```  ## Tools Used Manual review  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L639-L647   # Vulnerability details  ## Impact In the `_isWrappedFCash` check, the `notionalTradeModule` check whether the component is a wrappedCash with the following logic.  ```soliditiy         try IWrappedfCash(_fCashPosition).getDecodedID() returns(uint16 _currencyId, uint40 _maturity){             try wrappedfCashFactory.computeAddress(_currencyId, _maturity) returns(address _computedAddress){                 return _fCashPosition == _computedAddress;             } catch {                 return false;             }         } catch {             return false;         } ```  The above logic is dangerous when `_fCashPosition` do not revert on `getDecodedID` but instead give a wrong format of return value. The contract would try to decode the return value into `returns(uint16 _currencyId, uint40 _maturity)` and revert. The revert would consume what ever gas it's provided.  [CETH](https://etherscan.io/address/0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5) is an exmple. There's a fallback function in `ceth` ```soliditiy     function () external payable {         requireNoError(mintInternal(msg.value), "mint failed");     } ``` As a result, calling `getDecodedID` would not revert. Instead, calling `getDecodedID` of `CETH` would consume all remaining gas. This creates so many issues. First, users would waste too much gas on a regular operation. Second, the transaction might fail if `ceth` is not the last position. Third, the wallet contract can not interact with set token with ceth as it consumes all gas.   ## Proof of Concept  The following contract may fail to redeem setTokens as it consumes too much gas (with 20M gas limit).    [Test.sol](https://gist.github.com/Jonah246/fad9e489fe84a6fb8b4894d7377fd8a2)  ```soliditiy     function test(uint256 _amount) external {         cToken.approve(address(issueModule), uint256(-1));         wfCash.approve(address(issueModule), uint256(-1));         issueModule.issue(setToken, _amount, address(this));         issueModule.redeem(setToken, _amount, address(this));     } ```  Also, we can check how much gas it consumes with the following function.  ```soliditiy     function TestWrappedFCash(address _fCashPosition) public view returns(bool){         if(!_fCashPosition.isContract()) {             return false;         }         try IWrappedfCash(_fCashPosition).getDecodedID() returns(uint16 _currencyId, uint40 _maturity){             try wrappedfCashFactory.computeAddress(_currencyId, _maturity) returns(address _computedAddress){                 return _fCashPosition == _computedAddress;             } catch {                 return false;             }         } catch {             return false;         }     } ```  Test this function with `cdai` and `ceth`, we can observe that there's huge difference of gas consumption here. ``` Gas used:            30376 of 130376 Gas used:            19479394 of 19788041 ``` ## Tools Used Manual inspection. Hardhat  ## Recommended Mitigation Steps  I recommend building a map in the notionalTradeModule and inserting the wrappeCash in the `mintFCashPosition` function.  ```soliditiy function addWrappedCash(uint16 _currencyId, uint40 _maturity) public {     address computedAddress = wrappedfCashFactory.computeAddress(_currencyId, _maturity);     wrappedFCash[computedAddress] = true; } ```  Or we could replace the try-catch pattern with a low-level function call and check the return value's length before decoding it.  Something like this might be a fix. ```soliditiy     (bool success, bytes memory returndata) = target.delegatecall(data);     if (!success || returndata.length != DECODED_ID_RETURN_LENGTH) {         return false;     }    // abi.decode .... ```  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L192   # Vulnerability details  `withdraw` will revert if the account has not been settled yet. This is just due to the implementation and can be avoided by, well, settling the account.  ## Impact `withdraw` reverts unnecessarily. Protocols and users which will use wfCash4626 will have to discover this and settle by themselves.  ## Proof of Concept `withdraw` [calls](https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L192) `previewWithdraw`, which ends up calling `_getMaturedValue`, which [will revert](https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L23) if the account is not settled yet.  ## Recommended Mitigation Steps Add to `withdraw`: ``` NotionalV2.settleAccount(address(this)); ``` This will ensure that the account is settled and `withdraw` will not revert.  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L131-L141 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC777/ERC777.sol#L376-L380   # Vulnerability details  ## Impact The `wfCash` is an `erc777` token. [ERC777.sol#L376-L380](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC777/ERC777.sol#L376-L380) Users can get the control flow before sending token and after receiving tokens. This creates attack vectors that require extra caution in designing modules. Any combination of modules may lead to a possible exploit. To elaborate on the dangerousness of the re-entrancy attack, a possible scenario is presented.  Before the exploit, we first elaborate on three attack vectors:  1. [DebtIssuanceModule.sol#L131-L141](https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L131-L141) The issuance module would pull tokens from the sender before minting setToken. Assume there are three compoenents in this set. 1. CDai. 2. wfCash  In the `_callTokensToSend`, the setToken has received `cdai` and the `totalSupply` is still the same.  2. `nonReentrant` does not protect cross-contract re-entrancy. This means, that during the `issue` of issuance module, users can trigger other modules' functions.  3. Restricted functions with `onlyManagerAndValidSet` modifier may be triggered by the exploiter as well. Manager of a setToken is usually a manager contract. Assume it's a multisig-wallet, the exploiter can front-run the execute transaction and replay the payload during his exploit. Note, a private transaction from flash-bot can still be front-run. Please refer to the [uncle bandit risk](https://docs.flashbots.net/flashbots-protect/rpc/uncle-bandits)   Given the above attack vectors, the exploiter have enough weapons to exploit the `setToken` at a propriate time. Note that different combination of modules may have different exploit paths. As long as the above attack vectors remain, the setToken is vulnerable.  Assume a setToken with `CompoundLeverageModule`, `NotionalTradeModule` and `BasicIssuanceModule` with the following positions: 1. CDAI: 100  2. wfCash-DAI 100  and totalSupply = 100. The community decides to remove the `compoundLeverageModule` from the set token. Since `notionalTradeModule` can handle cDAI, the community vote to just call `removeModule` to remove `compoundLeverageModule`. The exploiter has the time to build an exploit and wait the right timing to come.  0. The exploiter listen the manager multisig wallet. 1. Exploiter issue 10 setToken. 2. During the `_callTokensToSend` of `wfcash`, the totalSupply = 100, CDAI = 110, wfCash-DAI = 110. 3. Call `sync` of `CompoundLeverageModule`. `_getCollateralPosition` get  `_cToken.balanceOf(address(_setToken)) = 110` and `totalSupply = 100` and update the `DefaultUnit` of `CETH` 1,1X. 4. Replay multisig wallet's payload and remove `compoundLeverageModule`. 5. The `setToken` can no longer issue / redeem as it would raise `undercollateralized` error. Further, `setValuer` would give a pumped valuation that may cause harm to other protocols.   ## Proof of Concept  [POC](https://gist.github.com/Jonah246/13e58b59765c0334189c99a9f29c6dab) The exploit is quite lengthy. Please check the `Attack.sol` for the main exploit logic. ```soliditiy     function register() public {         _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));         _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));     }      function attack(uint256 _amount) external {         cToken.approve(address(issueModule), uint256(-1));         wfCash.approve(address(issueModule), uint256(-1));         issueModule.issue(setToken, _amount, address(this));     }      function tokensToSend(         address operator,         address from,         address to,         uint256 amount,         bytes calldata userData,         bytes calldata operatorData     ) external {         compoundModule.sync(setToken, false);         manager.removeModule(address(setToken));     } ```  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps  The design choice of wfcash being an `ERC777` seems unnecessary to me. Over the past two years, ERC777 leads to so many exploits. [IMBTC-UNISWAP](https://defirate.com/imbtc-uniswap-hack/) [CREAM-AMP](https://twitter.com/CreamdotFinance/status/1432249771750686721?s=20) I recommend the team using ERC20 instead.  If the SetToken team considers supporting ERC777 necessary, I recommend implementing protocol-wide cross-contract reentrancy prevention. Please refer to Rari-Capital. [Comptroller.sol#L1978-L2002](https://github.com/Rari-Capital/fuse-v1/blob/development/src/core/Comptroller.sol#L1978-L2002)  Note that, `Rari` was [exploited](https://www.coindesk.com/business/2022/04/30/defi-lender-rari-capitalfei-loses-80m-in-hack/) given this reentrancy prevention. Simply making `nonReentrant` cross-contact prevention may not be enough. I recommend to setToken protocol going through every module and re-consider whether it's re-entrancy safe.  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L418 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L493   # Vulnerability details  ## Proof-of-Concept  Whenever `_mintFCashPosition` function is called to mint new fCash position, the contract will call the `_approve` function to set the allowance to `_maxSendAmount` so that the fCash Wrapper contact can pull the payment tokens from the SetToken contract during minting.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L418](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L418)  ```solidity function _mintFCashPosition(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _fCashAmount,     uint256 _maxSendAmount ) internal returns(uint256 sentAmount) {     if(_fCashAmount == 0) return 0;     bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);       _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);      uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));     uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));      _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying)   ..SNIP.. } ```  Note that `_maxSendAmount` is the maximum amount of payment tokens that is allowed to be consumed during minting. This is not the actual amount of payment tokens consumed during the minting process. Thus, after the minting, there will definitely be some residual allowance since it is unlikely that the fCash wrapper contract will consume the exact maximum amount during minting.  The following piece of code shows that having some residual allowance is expected. The `_approve` function will not set the allowance unless there is insufficient allowance.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L493](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L493)  ```solidity /**  * @dev Approve the given wrappedFCash instance to spend the setToken's sendToken   */ function _approve(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _maxAssetAmount ) internal {     if(IERC20(_sendToken).allowance(address(_setToken), address(_fCashPosition)) < _maxAssetAmount) {         bytes memory approveCallData = abi.encodeWithSelector(_sendToken.approve.selector, address(_fCashPosition), _maxAssetAmount);         _setToken.invoke(address(_sendToken), 0, approveCallData);     } } ```  ## Impact  Having residual allowance increases the risk of the asset tokens being stolen from the SetToken contract. SetToken contract is where all the tokens/assets are held. If the Notional's fCash wrapper contract is compromised, it will allow the compromised fCash wrapper contract to withdraw funds from the SetToken contract due to the residual allowance.   Note that Notional's fCash wrapper contract is not totally immutable, as it is a upgradeable contract. This is an additional risk factor to be considered. If the Notional's deployer account is compromised, the attacker could upgrade the Notional's fCash wrapper contract to a malicious one to withdraw funds from the Index Coop's SetToken contract due to the residual allowance.   Index Coop and Notional are two separate protocols and teams. Thus, it is a good security practice not to place any trust on external party wherever possible to ensure that if one party is compromised, it won't affect the another party. Thus, there should not be any residual allowance that allows Notional's contract to withdraw fund from Index Coop's contract in any circumstance.  In the worst case scenario, a "lazy" manager might simply set the `_maxAssetAmount` to `type(uint256).max`. Thus, this will result in large amount of residual allowance left, and expose the SetToken contract to significant risk.  ## Recommended Mitigation Steps  Approve the allowance on-demand whenever _`mintFCashPosition` is called, and reset the allowance back to zero after each minting process to eliminate any residual allowance.  ```diff function _mintFCashPosition(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _fCashAmount,     uint256 _maxSendAmount ) internal returns(uint256 sentAmount) {     if(_fCashAmount == 0) return 0;     bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);       _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);      uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));     uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));      _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying)   ..SNIP..   + // Reset the allowance back to zero after minting + _approve(_setToken, _fCashPosition, _sendToken, 0); } ```  Update the `_approve` accordingly to remove the if-statement related to residual allowance.  ```diff function _approve(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _maxAssetAmount ) internal { -    if(IERC20(_sendToken).allowance(address(_setToken), address(_fCashPosition)) < _maxAssetAmount) {         bytes memory approveCallData = abi.encodeWithSelector(_sendToken.approve.selector, address(_fCashPosition), _maxAssetAmount);         _setToken.invoke(address(_sendToken), 0, approveCallData); -    } } ```  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134   # Vulnerability details  ## Background  Per EIP 4626's Security Considerations (https://eips.ethereum.org/EIPS/eip-4626)  > Finally, ERC-4626 Vault implementers should be aware of the need for specific, opposing rounding directions across the different mutable and view methods, as it is considered most secure to favor the Vault itself during calculations over its users: > > - If (1) it’s calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide or (2) it’s determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round *down*. > - If (1) it’s calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens or (2) it’s calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round *up*.  Thus, the result of the `previewMint` and `previewWithdraw` should be rounded up.  ## Proof-of-Concept  The current implementation of `convertToShares` function will round down the number of shares returned due to how solidity handles Integer Division. ERC4626 expects the returned value of `convertToShares` to be rounded down. Thus, this function behaves as expected.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52)  ```solidity function convertToShares(uint256 assets) public view override returns (uint256 shares) {     uint256 supply = totalSupply();     if (supply == 0) {         // Scales assets by the value of a single unit of fCash         uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));         return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;     }      return (assets * totalSupply()) / totalAssets(); } ```  ERC 4626 expects the result returned from `previewWithdraw` function to be rounded up. However, within the `previewWithdraw` function, it calls the `convertToShares` function. Recall earlier that the `convertToShares` function returned a rounded down value,  thus `previewWithdraw` will return a rounded down value instead of round up value. Thus, this function does not behave as expected.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134)  ```solidity function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {     if (hasMatured()) {         shares = convertToShares(assets);     } else {         // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)         (uint16 currencyId, uint40 maturity) = getDecodedID();         (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(             currencyId,             assets,             maturity,             0,             block.timestamp,             true         );     } } ```  `previewWithdraw` and `previewMint` functions rely on `NotionalV2.getfCashBorrowFromPrincipal` and `NotionalV2.getDepositFromfCashLend` functions. Due to the nature of time-boxed contest, I was unable to verify if `NotionalV2.getfCashBorrowFromPrincipal` and `NotionalV2.getDepositFromfCashLend` functions return a rounded down or up value. If a rounded down value is returned from these functions, `previewWithdraw` and `previewMint` functions would not behave as expected.  ## Impact  Other protocols that integrate with Notional's fCash wrapper might wrongly assume that the functions handle rounding as per ERC4626 expectation. Thus, it might cause some intergration problem in the future that can lead to wide range of issues for both parties.  ## Recommended Mitigation Steps  Ensure that the rounding of vault's functions behave as expected. Following are the expected rounding direction for each vault function:  - previewMint(uint256 shares) - Round Up ⬆  - previewWithdraw(uint256 assets) - Round Up ⬆  - previewRedeem(uint256 shares) - Round Down ⬇  - previewDeposit(uint256 assets) - Round Down ⬇  - convertToAssets(uint256 shares) - Round Down ⬇  - convertToShares(uint256 assets) - Round Down ⬇  `previewMint` returns the  amount of assets that would be deposited to mint specific amount of shares. Thus, the amount of assets must be rounded up, so that the vault won't be shortchanged.  `previewWithdraw` returns the amount of shares that would be burned to withdraw specific amount of asset. Thus, the amount of shares must to be rounded up, so that the vault won't be shortchanged.  Following is the OpenZeppelin's vault implementation for rounding reference:  [https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20TokenizedVault.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20TokenizedVault.sol)  Alternatively, if such alignment of rounding could not be achieved due to technical limitation, at the minimum, document this limitation in the comment so that the developer performing the integration is aware of this.  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L309 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L385   # Vulnerability details  ## Proof-of-Concept  Whenever a setToken is issued or redeemed, the `moduleIssueHook` and `moduleRedeemHook` will be triggered. These two hooks will in turn call the `_redeemMaturedPositions` function to ensure that no matured fCash positions remain in the Set by redeeming any matured fCash position.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L309](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L309)  ```solidity /**  * @dev Hook called once before setToken issuance  * @dev Ensures that no matured fCash positions are in the set when it is issued  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenAmount */) external override onlyModule(_setToken) {     _redeemMaturedPositions(_setToken); }  /**  * @dev Hook called once before setToken redemption  * @dev Ensures that no matured fCash positions are in the set when it is redeemed  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenAmount */) external override onlyModule(_setToken) {     _redeemMaturedPositions(_setToken); } ```  The `_redeemMaturedPositions` will loop through all its fCash positions and attempts to redeem any fCash position that has already matured. However, if one of the fCash redemptions fails, it will cause the entire function to revert. If this happens, no one could purchase or redeem the setToken because `moduleIssueHook` and `modileRedeemHook` hooks will revert every single time. Thus, the setToken issuance and redemption will stop working entirely and  this setToken can be considered "bricked".  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L385](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L385)  ```solidity /**  * @dev Redeem all matured fCash positions for the given SetToken  */ function _redeemMaturedPositions(ISetToken _setToken) internal {     ISetToken.Position[] memory positions = _setToken.getPositions();     uint positionsLength = positions.length;      bool toUnderlying = redeemToUnderlying[_setToken];      for(uint256 i = 0; i < positionsLength; i++) {         // Check that the given position is an equity position         if(positions[i].unit > 0) {             address component = positions[i].component;             if(_isWrappedFCash(component)) {                 IWrappedfCashComplete fCashPosition = IWrappedfCashComplete(component);                 if(fCashPosition.hasMatured()) {                     (IERC20 receiveToken,) = fCashPosition.getToken(toUnderlying);                     if(address(receiveToken) == ETH_ADDRESS) {                         receiveToken = weth;                     }                     uint256 fCashBalance = fCashPosition.balanceOf(address(_setToken));                     _redeemFCashPosition(_setToken, fCashPosition, receiveToken, fCashBalance, 0);                 }             }         }     } } ```  ## Impact  User will not be able to purchase or redeem the setToken. User's fund will stuck in the SetToken Contract. Unable to remove matured fCash positions from SetToken and update positions of its asset token.  ## Recommended Mitigation Steps  This is a problem commonly encountered whenever a method of a smart contract calls another contract – you cannot rely on the other contract to work 100% of the time, and it is dangerous to assume that the external call will always be successful.   It is recommended to:  - Consider alternate method of updating the asset position so that the SetToken's core functions (e.g. issuance and redemption) will not be locked if one of the matured fCash redemptions fails.  - Evaluate if `_redeemMaturedPositions` really need to be called during SetToken's issuance and redemption. If not, consider removing them from the hooks, so that any issue or revert within `_redeemMaturedPositions` won't cause the SetToken's issuance and redemption functions to stop working entirely. - Consider implementing additional function to give manager/user an option to specify a list of matured fCash positions to redeem instead of forcing them to redeem all matured fCash positions at one go.  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashLogic.sol#L131   # Vulnerability details  ## Impact Minting becomes impossible   ## Proof of Concept onERC1155Received is only called when the size of the code deployed at the address contains code. Since create2 is used to deploy the contract, the address can be calculated before the contract is deployed. A malicious actor could send the address fCash of a different maturity or asset before the contract is deployed and since nothing has been deployed, onERC1155Received will not be called and the address will accept the fCash. After the contract is deployed and correct fCash is sent to the address, onERC1155Received will check the length of the assets held by the address and it will be more than 1 (fCash of correct asset and maturity and fCash with wrong maturity or asset sent before deployment). This will cause the contract to always revert essentially breaking the mint completely.   ## Tools Used  ## Recommended Mitigation Steps When the contract is created create a function that reads how many fCash assets are at the address and send them away if they aren't of the correct asset and maturity  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashLogic.sol#L184   # Vulnerability details  ## Impact If maturity is reached and user has asked for redeem with opts.transferfCash as true, then if (hasMatured()) turns true at wfCashLogic.sol#L216 causing fcash to be cashed out in underlying token and then sent to receiver. So receiver obtains underlying when fcash was expected. The sender wont get an error thinking fcash transfer was success  ## Proof of Concept  1. User A calls redeem with opts.transferfCash as true and receiver as User B 2. Since maturity is reached so instead of transferring the fCash, contract would simply cash out fCash and sent the underlying token to the receiver which was not expected  ## Recommended Mitigation Steps If opts.transferfCash is true and maturity is reached then throw an error mentioning that fCash can no longer be transferred  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L558-L575   # Vulnerability details  ## Impact For some `fcash` the asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and `NotionalV2` will not handle minting or burning when it is called with `useUnderlying==True` for those `fcash`s (according to what I asked from sponsor). In summery most of the logics in `NotionalTradeModule ` will not work for those `fcash` tokens because `_isUnderlying()` returns `true` result for those tokens which would make `NotionalTradeModule`'s logic for `mintFCashPosition()` and `redeemFCashPosition()` will eventually call `redeemToUnderlying()` and `mintViaUnderlying()` in `wfCashLogic` and those function in `wfCashLogic` will call `NotionalV2` with `useUnderlying==True` and `NotionalV2` will fail and revert for `fcash` tokens which asset token is underlying token, so the whole transaction will fail and `_mintFCashPosition()` and `_redeemFCashPosition()`  logic in `NotionalTradeModule ` will not work for those `fcash` tokens and manager can't add them to `set` protocol.   ## Proof of Concept when for some `fcash` asset token is underlying token, all calls to `NotionalV2` should be with `useUnderlying==False`. but `_isUnderlying()` in `NotionalTradeModule` contract first check that `isUnderlying = _paymentToken == underlyingToken` so for `fcash` tokens where asset token is underlying token it is going to return `isUnderlying==True`. let's assume that for some specific `fcash` asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and follow the code execution.  This is `_isUnderlying()` code in `NotionalTradeModule`: ```     function _isUnderlying(         IWrappedfCashComplete _fCashPosition,         IERC20 _paymentToken     )     internal     view     returns(bool isUnderlying)     {         (IERC20 underlyingToken, IERC20 assetToken) = _getUnderlyingAndAssetTokens(_fCashPosition);         isUnderlying = _paymentToken == underlyingToken;         if(!isUnderlying) {             require(_paymentToken == assetToken, "Token is neither asset nor underlying token");         }     } ``` As you can see it calls `_getUnderlyingAndAssetTokens()` and then check `_paymentToken == underlyingToken` to see that if payment token is equal to `underlyingToken`. `_getUnderlyingAndAssetTokens()` uses `getUnderlyingToken()` and `getAssetToken()` in `wfCashBase`. This is `getUnderlyingToken()` code in `wfCashBase`: ```     /// @notice Returns the token and precision of the token that this token settles     /// to. For example, fUSDC will return the USDC token address and 1e6. The zero     /// address will represent ETH.     function getUnderlyingToken() public view override returns (IERC20 underlyingToken, int256 underlyingPrecision) {         (Token memory asset, Token memory underlying) = NotionalV2.getCurrency(getCurrencyId());          if (asset.tokenType == TokenType.NonMintable) {             // In this case the asset token is the underlying             return (IERC20(asset.tokenAddress), asset.decimals);         } else {             return (IERC20(underlying.tokenAddress), underlying.decimals);         }     } ``` As you can see for our specific `fcash` token this function will return asset token as underlying token. so for this specific `fcash` token, the asset token and underlying token will be same in `_isUnderlying()` of `NationalTradeModule` but because code first check `isUnderlying = _paymentToken == underlyingToken` so the function will return `isUnderlying=True` as a result for our specific `fcash` token (which asset token is underlying token) This is `_mintFCashPosition()` and `_redeemFCashPosition()` code in `NotionalTradeModule `: ```     /**      * @dev Redeem a given fCash position from the specified send token (either underlying or asset token)      * @dev Alo adjust the components / position of the set token accordingly      */     function _mintFCashPosition(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         IERC20 _sendToken,         uint256 _fCashAmount,         uint256 _maxSendAmount     )     internal     returns(uint256 sentAmount)     {         if(_fCashAmount == 0) return 0;          bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);           _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);          uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));         uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));          _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying);           (sentAmount,) = _updateSetTokenPositions(             _setToken,             address(_sendToken),             preTradeSendTokenBalance,             address(_fCashPosition),             preTradeReceiveTokenBalance         );          require(sentAmount <= _maxSendAmount, "Overspent");         emit FCashMinted(_setToken, _fCashPosition, _sendToken, _fCashAmount, sentAmount);     }      /**      * @dev Redeem a given fCash position for the specified receive token (either underlying or asset token)      * @dev Alo adjust the components / position of the set token accordingly      */     function _redeemFCashPosition(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         IERC20 _receiveToken,         uint256 _fCashAmount,         uint256 _minReceiveAmount     )     internal     returns(uint256 receivedAmount)     {         if(_fCashAmount == 0) return 0;          bool toUnderlying = _isUnderlying(_fCashPosition, _receiveToken);         uint256 preTradeReceiveTokenBalance = _receiveToken.balanceOf(address(_setToken));         uint256 preTradeSendTokenBalance = _fCashPosition.balanceOf(address(_setToken));          _redeem(_setToken, _fCashPosition, _fCashAmount, toUnderlying);           (, receivedAmount) = _updateSetTokenPositions(             _setToken,             address(_fCashPosition),             preTradeSendTokenBalance,             address(_receiveToken),             preTradeReceiveTokenBalance         );           require(receivedAmount >= _minReceiveAmount, "Not enough received amount");         emit FCashRedeemed(_setToken, _fCashPosition, _receiveToken, _fCashAmount, receivedAmount);      } ``` As you can see they both uses `_isUnderlying()` to find out that if `_sendToken` is asset token or underlying token. for our specific `fcash` token, the result of `_isUnderlying()` will be `True` and `_mintFCashPosition()` and `_redeemFCashPosition()`  will call `_mint()` and `_redeem()` with `toUnderlying` set as `True`. This is `_mint()` and `_redeem()` code: ```     /**      * @dev Invokes the wrappedFCash token's mint function from the setToken      */     function _mint(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         uint256 _maxAssetAmount,         uint256 _fCashAmount,         bool _fromUnderlying     )     internal     {         uint32 minImpliedRate = 0;          bytes4 functionSelector =              _fromUnderlying ? _fCashPosition.mintViaUnderlying.selector : _fCashPosition.mintViaAsset.selector;         bytes memory mintCallData = abi.encodeWithSelector(             functionSelector,             _maxAssetAmount,             uint88(_fCashAmount),             address(_setToken),             minImpliedRate,             _fromUnderlying         );         _setToken.invoke(address(_fCashPosition), 0, mintCallData);     }      /**      * @dev Redeems the given amount of fCash token on behalf of the setToken      */     function _redeem(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         uint256 _fCashAmount,         bool _toUnderlying     )     internal     {         uint32 maxImpliedRate = type(uint32).max;          bytes4 functionSelector =             _toUnderlying ? _fCashPosition.redeemToUnderlying.selector : _fCashPosition.redeemToAsset.selector;         bytes memory redeemCallData = abi.encodeWithSelector(             functionSelector,             _fCashAmount,             address(_setToken),             maxImpliedRate         );         _setToken.invoke(address(_fCashPosition), 0, redeemCallData);     } ``` As you can see they are using `_toUnderlying` value to decide calling between (`mintViaUnderlying()` or `mintViaAsset()`) and (`redeemToUnderlying()` or `redeemToAsset()`), for our specific `fcash` `_toUnderlying` will be `True` so those functions will call `mintViaUnderlying()` and `redeemToUnderlying()` in `wfCashLogic`. `mintViaUnderlying()` and `redeemToUnderlying()` in `wfCashLogic` execution flow eventually would call `NotionalV2` functions with `useUnderlying=True` for this specific `fcash` token, but `NotionalV2` will revert for that call because for that `fcash` token asset token is underlying token and `NotionalV2` can't handle calls with `useUnderlying==True` for that `fcash` Token. This will cause all the transaction to fail and manager can't call `redeemFCashPosition()` or `mintFCashPosition()` functions for those `fcash` tokens that asset token is underlying token. In summery `NotionalTradeModule` logic will not work for all `fcash` tokens becasue the logic of `_isUnderlying()` is wrong for `fcash` tokens that asset token is underlying token.  ## Tools Used VIM  ## Recommended Mitigation Steps Change the logic of `_isUnderlying()` in `NotionalTradeModule` so it returns correct results for all `fcash` tokens. one simple solution can be that it first check `payment token`  value with `asset token` value.  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L177-L184 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L168-L175 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L225-L241   # Vulnerability details  ## Impact For some `fcash` the asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and `NotionalV2` will not handle minting with `useUnderlying==True` for those `fcash`s (according to what I asked from sponsor). In summery most of the logics in `wfCashERC4626` will not work for those `fcash` tokens.  when for some `fcash` asset token is underlying token, all calls to `NotionalV2` should be with `useUnderlying==False`. but `deposit()` and `mint()` in `wfCashERC4626` contract call `_mintInternal()` with `useUnderlying==True` and it calls `NotionalV2.batchLend()` with `depositUnderlying==true` so the `NotionV2` call will fail for `fcash` tokens that asset token is underlying token and it would cause  that `deposit()` and `mint()`  logic `wfCashERC4626`  will not work and contract will be useless for those tokens. `_redeemInternal()` issue is similar and it calls `_burn()` with `redeemToUnderlying: true` which execution eventually calls `NotionalV2.batchBalanceAndTradeAction()` with `toUnderlying=True` which will revert so `_redeemInternal()` will fail and because `withdraw()` and `redeem` use it, so they will not work too for those `fcash` tokens that asset token is underlying token.  ## Proof of Concept This is `deposit()` and `mint()`  code in `wfCashERC4626`: ```     /** @dev See {IERC4626-deposit} */     function deposit(uint256 assets, address receiver) public override returns (uint256) {         uint256 shares = previewDeposit(assets);         // Will revert if matured         _mintInternal(assets, _safeUint88(shares), receiver, 0, true);         emit Deposit(msg.sender, receiver, assets, shares);         return shares;     }      /** @dev See {IERC4626-mint} */     function mint(uint256 shares, address receiver) public override returns (uint256) {         uint256 assets = previewMint(shares);         // Will revert if matured         _mintInternal(assets, _safeUint88(shares), receiver, 0, true);         emit Deposit(msg.sender, receiver, assets, shares);         return assets;     } ``` As you can see they both call `_mintInternal()` with last parameter as `true` which is `useUnderlying`'s value. This is `_mintInternal()` code: ```     function _mintInternal(         uint256 depositAmountExternal,         uint88 fCashAmount,         address receiver,         uint32 minImpliedRate,         bool useUnderlying     ) internal nonReentrant {         require(!hasMatured(), "fCash matured");         (IERC20 token, bool isETH) = getToken(useUnderlying);         uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));          // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses         // ETH natively but due to pull payment requirements for batchLend, it does not support         // ETH. batchLend only supports ERC20 tokens like cETH or aETH. Since the wrapper is a compatibility         // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using         // "batchLend" we will use "batchBalanceActionWithTrades". The difference is that "batchLend"         // is more gas efficient (does not require and additional redeem call to asset tokens). If using cETH         // then everything will proceed via batchLend.         if (isETH) {             IERC20((address(WETH))).safeTransferFrom(msg.sender, address(this), depositAmountExternal);             WETH.withdraw(depositAmountExternal);              BalanceActionWithTrades[] memory action = EncodeDecode.encodeLendETHTrade(                 getCurrencyId(),                 getMarketIndex(),                 depositAmountExternal,                 fCashAmount,                 minImpliedRate             );             // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those             // native ETH tokens will be wrapped back to WETH.             NotionalV2.batchBalanceAndTradeAction{value: depositAmountExternal}(address(this), action);         } else {             // Transfers tokens in for lending, Notional will transfer from this contract.             token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);              // Executes a lending action on Notional             BatchLend[] memory action = EncodeDecode.encodeLendTrade(                 getCurrencyId(),                 getMarketIndex(),                 fCashAmount,                 minImpliedRate,                 useUnderlying             );             NotionalV2.batchLend(address(this), action);         }          // Mints ERC20 tokens for the receiver, the false flag denotes that we will not do an         // operatorAck         _mint(receiver, fCashAmount, "", "", false);          _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);     } ``` As you can see it calls `NotionalV2` functions with `useUnderlying=True` but according to sponsor clarification `NotionalV2` would fail and revert for those calls because `useUnderlying=True` and `fcash`'s asset token is underlying token (`asset.tokenType == TokenType.NonMintable`). So in summery for `fcash` tokens which asset token is underlying token `NotionalV2` won't handle calls which include `useUnderlying==True` but in `wfCashERC4626` contract functions like `deposit()`, `mint()`, `withdraw()` and `redeem()` they all uses `useUnderlying==True` always so `wfCashERC4626` won't work for those specific type of tokens which asset token is underlying token(`asset.tokenType == TokenType.NonMintable`)  the detail explanations for functions `withdraw()` and `redeem()` are similar.  ## Tools Used VIM  ## Recommended Mitigation Steps check that if for that `fcash` token asset token  is underlying token or not and set `useUnderlying` based on that.  
Judge has assessed an item in Issue #104 as Medium risk. The relevant finding follows:  ## L01: Silent overflow of `_fCashAmount`  ### Line References  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L526](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L526)  ### Description  If a `_fCashAmount` value that is greater than uint88 is passed into the `_mint` function, downcasting it to uint88 will silently overflow.   ### Recommended Mitigation Steps  ```solidity // Use a safe downcast function e.g. wfCashLogic::_safeUint88 function _safeUint88(uint256 x) internal pure returns (uint88) {hil     require(x <= uint256(type(uint88).max));     return uint88(x); } ``` 
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L212-L222   # Vulnerability details  ## Impact Control is transferred to the receiver when receiving the ERC777. They are able to transfer the ERC777 to another account, at which time the before and after balance calculation will be incorrect.  ```         uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);           if (msg.sender != owner) {             _spendAllowance(owner, msg.sender, shares);         }         _redeemInternal(shares, receiver, owner); ///////////// Control is transferred to user. They can alter their balance here. ///////////          uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);         uint256 assets = balanceAfter - balanceBefore;  ////////// Assets can be as low as 0 if they have transferred the same amount out as received. //////////          emit Withdraw(msg.sender, receiver, owner, assets, shares);         return assets; ```  ## Tools Used Manual review  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L639-L647   # Vulnerability details  ## Impact In the `_isWrappedFCash` check, the `notionalTradeModule` check whether the component is a wrappedCash with the following logic.  ```soliditiy         try IWrappedfCash(_fCashPosition).getDecodedID() returns(uint16 _currencyId, uint40 _maturity){             try wrappedfCashFactory.computeAddress(_currencyId, _maturity) returns(address _computedAddress){                 return _fCashPosition == _computedAddress;             } catch {                 return false;             }         } catch {             return false;         } ```  The above logic is dangerous when `_fCashPosition` do not revert on `getDecodedID` but instead give a wrong format of return value. The contract would try to decode the return value into `returns(uint16 _currencyId, uint40 _maturity)` and revert. The revert would consume what ever gas it's provided.  [CETH](https://etherscan.io/address/0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5) is an exmple. There's a fallback function in `ceth` ```soliditiy     function () external payable {         requireNoError(mintInternal(msg.value), "mint failed");     } ``` As a result, calling `getDecodedID` would not revert. Instead, calling `getDecodedID` of `CETH` would consume all remaining gas. This creates so many issues. First, users would waste too much gas on a regular operation. Second, the transaction might fail if `ceth` is not the last position. Third, the wallet contract can not interact with set token with ceth as it consumes all gas.   ## Proof of Concept  The following contract may fail to redeem setTokens as it consumes too much gas (with 20M gas limit).    [Test.sol](https://gist.github.com/Jonah246/fad9e489fe84a6fb8b4894d7377fd8a2)  ```soliditiy     function test(uint256 _amount) external {         cToken.approve(address(issueModule), uint256(-1));         wfCash.approve(address(issueModule), uint256(-1));         issueModule.issue(setToken, _amount, address(this));         issueModule.redeem(setToken, _amount, address(this));     } ```  Also, we can check how much gas it consumes with the following function.  ```soliditiy     function TestWrappedFCash(address _fCashPosition) public view returns(bool){         if(!_fCashPosition.isContract()) {             return false;         }         try IWrappedfCash(_fCashPosition).getDecodedID() returns(uint16 _currencyId, uint40 _maturity){             try wrappedfCashFactory.computeAddress(_currencyId, _maturity) returns(address _computedAddress){                 return _fCashPosition == _computedAddress;             } catch {                 return false;             }         } catch {             return false;         }     } ```  Test this function with `cdai` and `ceth`, we can observe that there's huge difference of gas consumption here. ``` Gas used:            30376 of 130376 Gas used:            19479394 of 19788041 ``` ## Tools Used Manual inspection. Hardhat  ## Recommended Mitigation Steps  I recommend building a map in the notionalTradeModule and inserting the wrappeCash in the `mintFCashPosition` function.  ```soliditiy function addWrappedCash(uint16 _currencyId, uint40 _maturity) public {     address computedAddress = wrappedfCashFactory.computeAddress(_currencyId, _maturity);     wrappedFCash[computedAddress] = true; } ```  Or we could replace the try-catch pattern with a low-level function call and check the return value's length before decoding it.  Something like this might be a fix. ```soliditiy     (bool success, bytes memory returndata) = target.delegatecall(data);     if (!success || returndata.length != DECODED_ID_RETURN_LENGTH) {         return false;     }    // abi.decode .... ```  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L192   # Vulnerability details  `withdraw` will revert if the account has not been settled yet. This is just due to the implementation and can be avoided by, well, settling the account.  ## Impact `withdraw` reverts unnecessarily. Protocols and users which will use wfCash4626 will have to discover this and settle by themselves.  ## Proof of Concept `withdraw` [calls](https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L192) `previewWithdraw`, which ends up calling `_getMaturedValue`, which [will revert](https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L23) if the account is not settled yet.  ## Recommended Mitigation Steps Add to `withdraw`: ``` NotionalV2.settleAccount(address(this)); ``` This will ensure that the account is settled and `withdraw` will not revert.  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L131-L141 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC777/ERC777.sol#L376-L380   # Vulnerability details  ## Impact The `wfCash` is an `erc777` token. [ERC777.sol#L376-L380](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC777/ERC777.sol#L376-L380) Users can get the control flow before sending token and after receiving tokens. This creates attack vectors that require extra caution in designing modules. Any combination of modules may lead to a possible exploit. To elaborate on the dangerousness of the re-entrancy attack, a possible scenario is presented.  Before the exploit, we first elaborate on three attack vectors:  1. [DebtIssuanceModule.sol#L131-L141](https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L131-L141) The issuance module would pull tokens from the sender before minting setToken. Assume there are three compoenents in this set. 1. CDai. 2. wfCash  In the `_callTokensToSend`, the setToken has received `cdai` and the `totalSupply` is still the same.  2. `nonReentrant` does not protect cross-contract re-entrancy. This means, that during the `issue` of issuance module, users can trigger other modules' functions.  3. Restricted functions with `onlyManagerAndValidSet` modifier may be triggered by the exploiter as well. Manager of a setToken is usually a manager contract. Assume it's a multisig-wallet, the exploiter can front-run the execute transaction and replay the payload during his exploit. Note, a private transaction from flash-bot can still be front-run. Please refer to the [uncle bandit risk](https://docs.flashbots.net/flashbots-protect/rpc/uncle-bandits)   Given the above attack vectors, the exploiter have enough weapons to exploit the `setToken` at a propriate time. Note that different combination of modules may have different exploit paths. As long as the above attack vectors remain, the setToken is vulnerable.  Assume a setToken with `CompoundLeverageModule`, `NotionalTradeModule` and `BasicIssuanceModule` with the following positions: 1. CDAI: 100  2. wfCash-DAI 100  and totalSupply = 100. The community decides to remove the `compoundLeverageModule` from the set token. Since `notionalTradeModule` can handle cDAI, the community vote to just call `removeModule` to remove `compoundLeverageModule`. The exploiter has the time to build an exploit and wait the right timing to come.  0. The exploiter listen the manager multisig wallet. 1. Exploiter issue 10 setToken. 2. During the `_callTokensToSend` of `wfcash`, the totalSupply = 100, CDAI = 110, wfCash-DAI = 110. 3. Call `sync` of `CompoundLeverageModule`. `_getCollateralPosition` get  `_cToken.balanceOf(address(_setToken)) = 110` and `totalSupply = 100` and update the `DefaultUnit` of `CETH` 1,1X. 4. Replay multisig wallet's payload and remove `compoundLeverageModule`. 5. The `setToken` can no longer issue / redeem as it would raise `undercollateralized` error. Further, `setValuer` would give a pumped valuation that may cause harm to other protocols.   ## Proof of Concept  [POC](https://gist.github.com/Jonah246/13e58b59765c0334189c99a9f29c6dab) The exploit is quite lengthy. Please check the `Attack.sol` for the main exploit logic. ```soliditiy     function register() public {         _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));         _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));     }      function attack(uint256 _amount) external {         cToken.approve(address(issueModule), uint256(-1));         wfCash.approve(address(issueModule), uint256(-1));         issueModule.issue(setToken, _amount, address(this));     }      function tokensToSend(         address operator,         address from,         address to,         uint256 amount,         bytes calldata userData,         bytes calldata operatorData     ) external {         compoundModule.sync(setToken, false);         manager.removeModule(address(setToken));     } ```  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps  The design choice of wfcash being an `ERC777` seems unnecessary to me. Over the past two years, ERC777 leads to so many exploits. [IMBTC-UNISWAP](https://defirate.com/imbtc-uniswap-hack/) [CREAM-AMP](https://twitter.com/CreamdotFinance/status/1432249771750686721?s=20) I recommend the team using ERC20 instead.  If the SetToken team considers supporting ERC777 necessary, I recommend implementing protocol-wide cross-contract reentrancy prevention. Please refer to Rari-Capital. [Comptroller.sol#L1978-L2002](https://github.com/Rari-Capital/fuse-v1/blob/development/src/core/Comptroller.sol#L1978-L2002)  Note that, `Rari` was [exploited](https://www.coindesk.com/business/2022/04/30/defi-lender-rari-capitalfei-loses-80m-in-hack/) given this reentrancy prevention. Simply making `nonReentrant` cross-contact prevention may not be enough. I recommend to setToken protocol going through every module and re-consider whether it's re-entrancy safe.  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L418 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L493   # Vulnerability details  ## Proof-of-Concept  Whenever `_mintFCashPosition` function is called to mint new fCash position, the contract will call the `_approve` function to set the allowance to `_maxSendAmount` so that the fCash Wrapper contact can pull the payment tokens from the SetToken contract during minting.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L418](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L418)  ```solidity function _mintFCashPosition(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _fCashAmount,     uint256 _maxSendAmount ) internal returns(uint256 sentAmount) {     if(_fCashAmount == 0) return 0;     bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);       _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);      uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));     uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));      _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying)   ..SNIP.. } ```  Note that `_maxSendAmount` is the maximum amount of payment tokens that is allowed to be consumed during minting. This is not the actual amount of payment tokens consumed during the minting process. Thus, after the minting, there will definitely be some residual allowance since it is unlikely that the fCash wrapper contract will consume the exact maximum amount during minting.  The following piece of code shows that having some residual allowance is expected. The `_approve` function will not set the allowance unless there is insufficient allowance.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L493](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L493)  ```solidity /**  * @dev Approve the given wrappedFCash instance to spend the setToken's sendToken   */ function _approve(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _maxAssetAmount ) internal {     if(IERC20(_sendToken).allowance(address(_setToken), address(_fCashPosition)) < _maxAssetAmount) {         bytes memory approveCallData = abi.encodeWithSelector(_sendToken.approve.selector, address(_fCashPosition), _maxAssetAmount);         _setToken.invoke(address(_sendToken), 0, approveCallData);     } } ```  ## Impact  Having residual allowance increases the risk of the asset tokens being stolen from the SetToken contract. SetToken contract is where all the tokens/assets are held. If the Notional's fCash wrapper contract is compromised, it will allow the compromised fCash wrapper contract to withdraw funds from the SetToken contract due to the residual allowance.   Note that Notional's fCash wrapper contract is not totally immutable, as it is a upgradeable contract. This is an additional risk factor to be considered. If the Notional's deployer account is compromised, the attacker could upgrade the Notional's fCash wrapper contract to a malicious one to withdraw funds from the Index Coop's SetToken contract due to the residual allowance.   Index Coop and Notional are two separate protocols and teams. Thus, it is a good security practice not to place any trust on external party wherever possible to ensure that if one party is compromised, it won't affect the another party. Thus, there should not be any residual allowance that allows Notional's contract to withdraw fund from Index Coop's contract in any circumstance.  In the worst case scenario, a "lazy" manager might simply set the `_maxAssetAmount` to `type(uint256).max`. Thus, this will result in large amount of residual allowance left, and expose the SetToken contract to significant risk.  ## Recommended Mitigation Steps  Approve the allowance on-demand whenever _`mintFCashPosition` is called, and reset the allowance back to zero after each minting process to eliminate any residual allowance.  ```diff function _mintFCashPosition(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _fCashAmount,     uint256 _maxSendAmount ) internal returns(uint256 sentAmount) {     if(_fCashAmount == 0) return 0;     bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);       _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);      uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));     uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));      _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying)   ..SNIP..   + // Reset the allowance back to zero after minting + _approve(_setToken, _fCashPosition, _sendToken, 0); } ```  Update the `_approve` accordingly to remove the if-statement related to residual allowance.  ```diff function _approve(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _maxAssetAmount ) internal { -    if(IERC20(_sendToken).allowance(address(_setToken), address(_fCashPosition)) < _maxAssetAmount) {         bytes memory approveCallData = abi.encodeWithSelector(_sendToken.approve.selector, address(_fCashPosition), _maxAssetAmount);         _setToken.invoke(address(_sendToken), 0, approveCallData); -    } } ```  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134   # Vulnerability details  ## Background  Per EIP 4626's Security Considerations (https://eips.ethereum.org/EIPS/eip-4626)  > Finally, ERC-4626 Vault implementers should be aware of the need for specific, opposing rounding directions across the different mutable and view methods, as it is considered most secure to favor the Vault itself during calculations over its users: > > - If (1) it’s calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide or (2) it’s determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round *down*. > - If (1) it’s calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens or (2) it’s calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round *up*.  Thus, the result of the `previewMint` and `previewWithdraw` should be rounded up.  ## Proof-of-Concept  The current implementation of `convertToShares` function will round down the number of shares returned due to how solidity handles Integer Division. ERC4626 expects the returned value of `convertToShares` to be rounded down. Thus, this function behaves as expected.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52)  ```solidity function convertToShares(uint256 assets) public view override returns (uint256 shares) {     uint256 supply = totalSupply();     if (supply == 0) {         // Scales assets by the value of a single unit of fCash         uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));         return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;     }      return (assets * totalSupply()) / totalAssets(); } ```  ERC 4626 expects the result returned from `previewWithdraw` function to be rounded up. However, within the `previewWithdraw` function, it calls the `convertToShares` function. Recall earlier that the `convertToShares` function returned a rounded down value,  thus `previewWithdraw` will return a rounded down value instead of round up value. Thus, this function does not behave as expected.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134)  ```solidity function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {     if (hasMatured()) {         shares = convertToShares(assets);     } else {         // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)         (uint16 currencyId, uint40 maturity) = getDecodedID();         (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(             currencyId,             assets,             maturity,             0,             block.timestamp,             true         );     } } ```  `previewWithdraw` and `previewMint` functions rely on `NotionalV2.getfCashBorrowFromPrincipal` and `NotionalV2.getDepositFromfCashLend` functions. Due to the nature of time-boxed contest, I was unable to verify if `NotionalV2.getfCashBorrowFromPrincipal` and `NotionalV2.getDepositFromfCashLend` functions return a rounded down or up value. If a rounded down value is returned from these functions, `previewWithdraw` and `previewMint` functions would not behave as expected.  ## Impact  Other protocols that integrate with Notional's fCash wrapper might wrongly assume that the functions handle rounding as per ERC4626 expectation. Thus, it might cause some intergration problem in the future that can lead to wide range of issues for both parties.  ## Recommended Mitigation Steps  Ensure that the rounding of vault's functions behave as expected. Following are the expected rounding direction for each vault function:  - previewMint(uint256 shares) - Round Up ⬆  - previewWithdraw(uint256 assets) - Round Up ⬆  - previewRedeem(uint256 shares) - Round Down ⬇  - previewDeposit(uint256 assets) - Round Down ⬇  - convertToAssets(uint256 shares) - Round Down ⬇  - convertToShares(uint256 assets) - Round Down ⬇  `previewMint` returns the  amount of assets that would be deposited to mint specific amount of shares. Thus, the amount of assets must be rounded up, so that the vault won't be shortchanged.  `previewWithdraw` returns the amount of shares that would be burned to withdraw specific amount of asset. Thus, the amount of shares must to be rounded up, so that the vault won't be shortchanged.  Following is the OpenZeppelin's vault implementation for rounding reference:  [https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20TokenizedVault.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20TokenizedVault.sol)  Alternatively, if such alignment of rounding could not be achieved due to technical limitation, at the minimum, document this limitation in the comment so that the developer performing the integration is aware of this.  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L309 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L385   # Vulnerability details  ## Proof-of-Concept  Whenever a setToken is issued or redeemed, the `moduleIssueHook` and `moduleRedeemHook` will be triggered. These two hooks will in turn call the `_redeemMaturedPositions` function to ensure that no matured fCash positions remain in the Set by redeeming any matured fCash position.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L309](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L309)  ```solidity /**  * @dev Hook called once before setToken issuance  * @dev Ensures that no matured fCash positions are in the set when it is issued  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenAmount */) external override onlyModule(_setToken) {     _redeemMaturedPositions(_setToken); }  /**  * @dev Hook called once before setToken redemption  * @dev Ensures that no matured fCash positions are in the set when it is redeemed  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenAmount */) external override onlyModule(_setToken) {     _redeemMaturedPositions(_setToken); } ```  The `_redeemMaturedPositions` will loop through all its fCash positions and attempts to redeem any fCash position that has already matured. However, if one of the fCash redemptions fails, it will cause the entire function to revert. If this happens, no one could purchase or redeem the setToken because `moduleIssueHook` and `modileRedeemHook` hooks will revert every single time. Thus, the setToken issuance and redemption will stop working entirely and  this setToken can be considered "bricked".  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L385](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L385)  ```solidity /**  * @dev Redeem all matured fCash positions for the given SetToken  */ function _redeemMaturedPositions(ISetToken _setToken) internal {     ISetToken.Position[] memory positions = _setToken.getPositions();     uint positionsLength = positions.length;      bool toUnderlying = redeemToUnderlying[_setToken];      for(uint256 i = 0; i < positionsLength; i++) {         // Check that the given position is an equity position         if(positions[i].unit > 0) {             address component = positions[i].component;             if(_isWrappedFCash(component)) {                 IWrappedfCashComplete fCashPosition = IWrappedfCashComplete(component);                 if(fCashPosition.hasMatured()) {                     (IERC20 receiveToken,) = fCashPosition.getToken(toUnderlying);                     if(address(receiveToken) == ETH_ADDRESS) {                         receiveToken = weth;                     }                     uint256 fCashBalance = fCashPosition.balanceOf(address(_setToken));                     _redeemFCashPosition(_setToken, fCashPosition, receiveToken, fCashBalance, 0);                 }             }         }     } } ```  ## Impact  User will not be able to purchase or redeem the setToken. User's fund will stuck in the SetToken Contract. Unable to remove matured fCash positions from SetToken and update positions of its asset token.  ## Recommended Mitigation Steps  This is a problem commonly encountered whenever a method of a smart contract calls another contract – you cannot rely on the other contract to work 100% of the time, and it is dangerous to assume that the external call will always be successful.   It is recommended to:  - Consider alternate method of updating the asset position so that the SetToken's core functions (e.g. issuance and redemption) will not be locked if one of the matured fCash redemptions fails.  - Evaluate if `_redeemMaturedPositions` really need to be called during SetToken's issuance and redemption. If not, consider removing them from the hooks, so that any issue or revert within `_redeemMaturedPositions` won't cause the SetToken's issuance and redemption functions to stop working entirely. - Consider implementing additional function to give manager/user an option to specify a list of matured fCash positions to redeem instead of forcing them to redeem all matured fCash positions at one go.  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashLogic.sol#L131   # Vulnerability details  ## Impact Minting becomes impossible   ## Proof of Concept onERC1155Received is only called when the size of the code deployed at the address contains code. Since create2 is used to deploy the contract, the address can be calculated before the contract is deployed. A malicious actor could send the address fCash of a different maturity or asset before the contract is deployed and since nothing has been deployed, onERC1155Received will not be called and the address will accept the fCash. After the contract is deployed and correct fCash is sent to the address, onERC1155Received will check the length of the assets held by the address and it will be more than 1 (fCash of correct asset and maturity and fCash with wrong maturity or asset sent before deployment). This will cause the contract to always revert essentially breaking the mint completely.   ## Tools Used  ## Recommended Mitigation Steps When the contract is created create a function that reads how many fCash assets are at the address and send them away if they aren't of the correct asset and maturity  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashLogic.sol#L184   # Vulnerability details  ## Impact If maturity is reached and user has asked for redeem with opts.transferfCash as true, then if (hasMatured()) turns true at wfCashLogic.sol#L216 causing fcash to be cashed out in underlying token and then sent to receiver. So receiver obtains underlying when fcash was expected. The sender wont get an error thinking fcash transfer was success  ## Proof of Concept  1. User A calls redeem with opts.transferfCash as true and receiver as User B 2. Since maturity is reached so instead of transferring the fCash, contract would simply cash out fCash and sent the underlying token to the receiver which was not expected  ## Recommended Mitigation Steps If opts.transferfCash is true and maturity is reached then throw an error mentioning that fCash can no longer be transferred  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L558-L575   # Vulnerability details  ## Impact For some `fcash` the asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and `NotionalV2` will not handle minting or burning when it is called with `useUnderlying==True` for those `fcash`s (according to what I asked from sponsor). In summery most of the logics in `NotionalTradeModule ` will not work for those `fcash` tokens because `_isUnderlying()` returns `true` result for those tokens which would make `NotionalTradeModule`'s logic for `mintFCashPosition()` and `redeemFCashPosition()` will eventually call `redeemToUnderlying()` and `mintViaUnderlying()` in `wfCashLogic` and those function in `wfCashLogic` will call `NotionalV2` with `useUnderlying==True` and `NotionalV2` will fail and revert for `fcash` tokens which asset token is underlying token, so the whole transaction will fail and `_mintFCashPosition()` and `_redeemFCashPosition()`  logic in `NotionalTradeModule ` will not work for those `fcash` tokens and manager can't add them to `set` protocol.   ## Proof of Concept when for some `fcash` asset token is underlying token, all calls to `NotionalV2` should be with `useUnderlying==False`. but `_isUnderlying()` in `NotionalTradeModule` contract first check that `isUnderlying = _paymentToken == underlyingToken` so for `fcash` tokens where asset token is underlying token it is going to return `isUnderlying==True`. let's assume that for some specific `fcash` asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and follow the code execution.  This is `_isUnderlying()` code in `NotionalTradeModule`: ```     function _isUnderlying(         IWrappedfCashComplete _fCashPosition,         IERC20 _paymentToken     )     internal     view     returns(bool isUnderlying)     {         (IERC20 underlyingToken, IERC20 assetToken) = _getUnderlyingAndAssetTokens(_fCashPosition);         isUnderlying = _paymentToken == underlyingToken;         if(!isUnderlying) {             require(_paymentToken == assetToken, "Token is neither asset nor underlying token");         }     } ``` As you can see it calls `_getUnderlyingAndAssetTokens()` and then check `_paymentToken == underlyingToken` to see that if payment token is equal to `underlyingToken`. `_getUnderlyingAndAssetTokens()` uses `getUnderlyingToken()` and `getAssetToken()` in `wfCashBase`. This is `getUnderlyingToken()` code in `wfCashBase`: ```     /// @notice Returns the token and precision of the token that this token settles     /// to. For example, fUSDC will return the USDC token address and 1e6. The zero     /// address will represent ETH.     function getUnderlyingToken() public view override returns (IERC20 underlyingToken, int256 underlyingPrecision) {         (Token memory asset, Token memory underlying) = NotionalV2.getCurrency(getCurrencyId());          if (asset.tokenType == TokenType.NonMintable) {             // In this case the asset token is the underlying             return (IERC20(asset.tokenAddress), asset.decimals);         } else {             return (IERC20(underlying.tokenAddress), underlying.decimals);         }     } ``` As you can see for our specific `fcash` token this function will return asset token as underlying token. so for this specific `fcash` token, the asset token and underlying token will be same in `_isUnderlying()` of `NationalTradeModule` but because code first check `isUnderlying = _paymentToken == underlyingToken` so the function will return `isUnderlying=True` as a result for our specific `fcash` token (which asset token is underlying token) This is `_mintFCashPosition()` and `_redeemFCashPosition()` code in `NotionalTradeModule `: ```     /**      * @dev Redeem a given fCash position from the specified send token (either underlying or asset token)      * @dev Alo adjust the components / position of the set token accordingly      */     function _mintFCashPosition(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         IERC20 _sendToken,         uint256 _fCashAmount,         uint256 _maxSendAmount     )     internal     returns(uint256 sentAmount)     {         if(_fCashAmount == 0) return 0;          bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);           _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);          uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));         uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));          _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying);           (sentAmount,) = _updateSetTokenPositions(             _setToken,             address(_sendToken),             preTradeSendTokenBalance,             address(_fCashPosition),             preTradeReceiveTokenBalance         );          require(sentAmount <= _maxSendAmount, "Overspent");         emit FCashMinted(_setToken, _fCashPosition, _sendToken, _fCashAmount, sentAmount);     }      /**      * @dev Redeem a given fCash position for the specified receive token (either underlying or asset token)      * @dev Alo adjust the components / position of the set token accordingly      */     function _redeemFCashPosition(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         IERC20 _receiveToken,         uint256 _fCashAmount,         uint256 _minReceiveAmount     )     internal     returns(uint256 receivedAmount)     {         if(_fCashAmount == 0) return 0;          bool toUnderlying = _isUnderlying(_fCashPosition, _receiveToken);         uint256 preTradeReceiveTokenBalance = _receiveToken.balanceOf(address(_setToken));         uint256 preTradeSendTokenBalance = _fCashPosition.balanceOf(address(_setToken));          _redeem(_setToken, _fCashPosition, _fCashAmount, toUnderlying);           (, receivedAmount) = _updateSetTokenPositions(             _setToken,             address(_fCashPosition),             preTradeSendTokenBalance,             address(_receiveToken),             preTradeReceiveTokenBalance         );           require(receivedAmount >= _minReceiveAmount, "Not enough received amount");         emit FCashRedeemed(_setToken, _fCashPosition, _receiveToken, _fCashAmount, receivedAmount);      } ``` As you can see they both uses `_isUnderlying()` to find out that if `_sendToken` is asset token or underlying token. for our specific `fcash` token, the result of `_isUnderlying()` will be `True` and `_mintFCashPosition()` and `_redeemFCashPosition()`  will call `_mint()` and `_redeem()` with `toUnderlying` set as `True`. This is `_mint()` and `_redeem()` code: ```     /**      * @dev Invokes the wrappedFCash token's mint function from the setToken      */     function _mint(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         uint256 _maxAssetAmount,         uint256 _fCashAmount,         bool _fromUnderlying     )     internal     {         uint32 minImpliedRate = 0;          bytes4 functionSelector =              _fromUnderlying ? _fCashPosition.mintViaUnderlying.selector : _fCashPosition.mintViaAsset.selector;         bytes memory mintCallData = abi.encodeWithSelector(             functionSelector,             _maxAssetAmount,             uint88(_fCashAmount),             address(_setToken),             minImpliedRate,             _fromUnderlying         );         _setToken.invoke(address(_fCashPosition), 0, mintCallData);     }      /**      * @dev Redeems the given amount of fCash token on behalf of the setToken      */     function _redeem(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         uint256 _fCashAmount,         bool _toUnderlying     )     internal     {         uint32 maxImpliedRate = type(uint32).max;          bytes4 functionSelector =             _toUnderlying ? _fCashPosition.redeemToUnderlying.selector : _fCashPosition.redeemToAsset.selector;         bytes memory redeemCallData = abi.encodeWithSelector(             functionSelector,             _fCashAmount,             address(_setToken),             maxImpliedRate         );         _setToken.invoke(address(_fCashPosition), 0, redeemCallData);     } ``` As you can see they are using `_toUnderlying` value to decide calling between (`mintViaUnderlying()` or `mintViaAsset()`) and (`redeemToUnderlying()` or `redeemToAsset()`), for our specific `fcash` `_toUnderlying` will be `True` so those functions will call `mintViaUnderlying()` and `redeemToUnderlying()` in `wfCashLogic`. `mintViaUnderlying()` and `redeemToUnderlying()` in `wfCashLogic` execution flow eventually would call `NotionalV2` functions with `useUnderlying=True` for this specific `fcash` token, but `NotionalV2` will revert for that call because for that `fcash` token asset token is underlying token and `NotionalV2` can't handle calls with `useUnderlying==True` for that `fcash` Token. This will cause all the transaction to fail and manager can't call `redeemFCashPosition()` or `mintFCashPosition()` functions for those `fcash` tokens that asset token is underlying token. In summery `NotionalTradeModule` logic will not work for all `fcash` tokens becasue the logic of `_isUnderlying()` is wrong for `fcash` tokens that asset token is underlying token.  ## Tools Used VIM  ## Recommended Mitigation Steps Change the logic of `_isUnderlying()` in `NotionalTradeModule` so it returns correct results for all `fcash` tokens. one simple solution can be that it first check `payment token`  value with `asset token` value.  
# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L177-L184 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L168-L175 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L225-L241   # Vulnerability details  ## Impact For some `fcash` the asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and `NotionalV2` will not handle minting with `useUnderlying==True` for those `fcash`s (according to what I asked from sponsor). In summery most of the logics in `wfCashERC4626` will not work for those `fcash` tokens.  when for some `fcash` asset token is underlying token, all calls to `NotionalV2` should be with `useUnderlying==False`. but `deposit()` and `mint()` in `wfCashERC4626` contract call `_mintInternal()` with `useUnderlying==True` and it calls `NotionalV2.batchLend()` with `depositUnderlying==true` so the `NotionV2` call will fail for `fcash` tokens that asset token is underlying token and it would cause  that `deposit()` and `mint()`  logic `wfCashERC4626`  will not work and contract will be useless for those tokens. `_redeemInternal()` issue is similar and it calls `_burn()` with `redeemToUnderlying: true` which execution eventually calls `NotionalV2.batchBalanceAndTradeAction()` with `toUnderlying=True` which will revert so `_redeemInternal()` will fail and because `withdraw()` and `redeem` use it, so they will not work too for those `fcash` tokens that asset token is underlying token.  ## Proof of Concept This is `deposit()` and `mint()`  code in `wfCashERC4626`: ```     /** @dev See {IERC4626-deposit} */     function deposit(uint256 assets, address receiver) public override returns (uint256) {         uint256 shares = previewDeposit(assets);         // Will revert if matured         _mintInternal(assets, _safeUint88(shares), receiver, 0, true);         emit Deposit(msg.sender, receiver, assets, shares);         return shares;     }      /** @dev See {IERC4626-mint} */     function mint(uint256 shares, address receiver) public override returns (uint256) {         uint256 assets = previewMint(shares);         // Will revert if matured         _mintInternal(assets, _safeUint88(shares), receiver, 0, true);         emit Deposit(msg.sender, receiver, assets, shares);         return assets;     } ``` As you can see they both call `_mintInternal()` with last parameter as `true` which is `useUnderlying`'s value. This is `_mintInternal()` code: ```     function _mintInternal(         uint256 depositAmountExternal,         uint88 fCashAmount,         address receiver,         uint32 minImpliedRate,         bool useUnderlying     ) internal nonReentrant {         require(!hasMatured(), "fCash matured");         (IERC20 token, bool isETH) = getToken(useUnderlying);         uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));          // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses         // ETH natively but due to pull payment requirements for batchLend, it does not support         // ETH. batchLend only supports ERC20 tokens like cETH or aETH. Since the wrapper is a compatibility         // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using         // "batchLend" we will use "batchBalanceActionWithTrades". The difference is that "batchLend"         // is more gas efficient (does not require and additional redeem call to asset tokens). If using cETH         // then everything will proceed via batchLend.         if (isETH) {             IERC20((address(WETH))).safeTransferFrom(msg.sender, address(this), depositAmountExternal);             WETH.withdraw(depositAmountExternal);              BalanceActionWithTrades[] memory action = EncodeDecode.encodeLendETHTrade(                 getCurrencyId(),                 getMarketIndex(),                 depositAmountExternal,                 fCashAmount,                 minImpliedRate             );             // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those             // native ETH tokens will be wrapped back to WETH.             NotionalV2.batchBalanceAndTradeAction{value: depositAmountExternal}(address(this), action);         } else {             // Transfers tokens in for lending, Notional will transfer from this contract.             token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);              // Executes a lending action on Notional             BatchLend[] memory action = EncodeDecode.encodeLendTrade(                 getCurrencyId(),                 getMarketIndex(),                 fCashAmount,                 minImpliedRate,                 useUnderlying             );             NotionalV2.batchLend(address(this), action);         }          // Mints ERC20 tokens for the receiver, the false flag denotes that we will not do an         // operatorAck         _mint(receiver, fCashAmount, "", "", false);          _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);     } ``` As you can see it calls `NotionalV2` functions with `useUnderlying=True` but according to sponsor clarification `NotionalV2` would fail and revert for those calls because `useUnderlying=True` and `fcash`'s asset token is underlying token (`asset.tokenType == TokenType.NonMintable`). So in summery for `fcash` tokens which asset token is underlying token `NotionalV2` won't handle calls which include `useUnderlying==True` but in `wfCashERC4626` contract functions like `deposit()`, `mint()`, `withdraw()` and `redeem()` they all uses `useUnderlying==True` always so `wfCashERC4626` won't work for those specific type of tokens which asset token is underlying token(`asset.tokenType == TokenType.NonMintable`)  the detail explanations for functions `withdraw()` and `redeem()` are similar.  ## Tools Used VIM  ## Recommended Mitigation Steps check that if for that `fcash` token asset token  is underlying token or not and set `useUnderlying` based on that.  
