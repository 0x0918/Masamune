# [QA-1] Naming inconsistency - some arguments have ``_`` at their prefixes but others do not at NestedFactory.sol  Throughout the file ``NestedFactory.sol``, arguments of functions have ``_`` at their prefixes like ``function setFeeSplitter(FeeSplitter _feeSplitter)``. However, following 2 arguments do not have ``_`` at their prefixes which are not consistent.  https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L121  https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L133  ---  # [QA-2] Use either ``_msgSender()`` or ``msg.sender``   Throughout the file ``NestedFactory.sol``, ``_msgSender()`` is used to get the sender. However, following 2 places use ``msg.sender`` which seem not consistent.  https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L89  https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L177  
# QA Report  ## Table of Contents  - [summary](#summary) - [Comment Missing function parameter](#comment-missing-function-parameter) - [Constants instead of magic numbers](#constants-instead-of-magic-numbers) - [Events indexing](#events-indexing) - [Public functions can be external](#public-functions-can-be-external) - [Scientific notation](#scientific-notation) - [Typos](#typos) - [Immutable addresses lack zero-address check](#immutable-addresses-lack-zero-address-check) - [Payable functions when using ERC20](#payable-functions-when-using-erc20)   # summary  > Few vulnerabilities were found examining the contracts. The main concerns are with:    # Comment Missing function parameter  ## PROBLEM  Some of the function comments are missing function parameters or returns    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Parameters missing a natspec comment include:   ### BeefyZapBiswapLPVaultOperator.sol  [uint256 reserveA](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L266)\ [uint256 reserveB](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L267)\ [IBiswapRouter02 router](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L268)\ [uint256 swapAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L269)\  ### BeefyZapUniswapLPVaultOperator.sol  [uint256 reserveA](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L265)\ [uint256 reserveB](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L266)\ [IUniswapV2Router02 router](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L267)\ [uint256 swapAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L268)  ### TimelockControllerEmergency.sol  [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L119)\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L126)\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L133)\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L141)\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L149)\ [address target,uint256 value,bytes calldata data,bytes32 predecessor,bytes32 salt](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L167-L171)\ [address[] calldata targets,uint256[] calldata values,bytes[] calldata datas,bytes32 predecessor,bytes32 salt](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L181-L185)\ [address target,uint256 value,bytes calldata data,bytes32 predecessor,bytes32 salt,uint256 delay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L200-L205)\ [address[] calldata targets,uint256[] calldata values,bytes[] calldata datas,bytes32 predecessor,bytes32 salt,uint256 delay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L221-L227)\ [bytes32 id, uint256 delay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L242)\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L255)\ [address target,uint256 value,bytes calldata data,bytes32 predecessor,bytes32 salt](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L275-L279)\ [address target,uint256 value,bytes calldata data](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L296-L298)\ [address[] calldata targets,uint256[] calldata values,bytes[] calldata datas,bytes32 predecessor,bytes32 salt](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L313-L317)\ [bytes32 id, bytes32 predecessor](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L333)\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L341)\ [bytes32 id,uint256 index,address target,uint256 value,bytes calldata data](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L352-L356)\ [uint256 newDelay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L374)    ## TOOLS USED  Manual Analysis    ## MITIGATION  Add a comment for these parameters  # Constants instead of magic numbers  ## PROBLEM  It is best practice to use constant variables rather than literal values to make the code easier to understand and maintain.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### NestedFactory.sol  [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L161)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L169)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L264)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L378)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L629)  ### BeefyZapBiswapLPVaultOperator.sol  [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L271)\ [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L272)  ### BeefyZapUniswapLPVaultOperator.sol  [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L269)\ [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L270)     ## TOOLS USED  Manual Analysis    ## MITIGATION   Define constant variables for the literal values aforementioned.  # Events indexing  ## PROBLEM  Events should use indexed fields    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### MixinOperatorResolver.sol  [event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L14)  ### BeefyVaultStorage.sol  [event VaultAdded(address vault, address tokenOrZapper)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L12)\ [event VaultRemoved(address vault)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L16)  ### YearnVaultStorage.sol  [event VaultAdded(address vault, CurvePool pool)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L17)\ [event VaultRemoved(address vault)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L21)  ### TimelockControllerEmergency.sol  [event MinDelayChange(uint256 oldDuration, uint256 newDuration)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L60)  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add indexed fields to these events so that they have the maximum number of indexed fields possible.   # Scientific notation  ## PROBLEM  For readability, it is best to use scientific notation (e.g `10e5`) rather than decimal literals(`100000`) or exponentiation(`10**5`)    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### NestedFactory.sol  [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L161)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L169)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L264)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L378)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L629)  ### BeefyZapBiswapLPVaultOperator.sol  [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L271)\ [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L272)  ### BeefyZapUniswapLPVaultOperator.sol  [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L269)\ [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L270)    ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace the numbers aforementioned with their scientific notation  # Typos  ## PROBLEM  There are some typos/misspelt words in the contracts.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:  ### BeefyVaultOperator.sol  [WITHDRAWED](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L95)  ### BeefyZapBiswapLPVaultOperator.sol  [WITHDRAWED](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L108)   ### BeefyZapUniswapLPVaultOperator.sol  [WITHDRAWED](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L108)     ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace with `WITHDRAWN`  # Immutable addresses lack zero-address check  ## IMPACT  constructors should check the address written in an immutable address variable is not the zero address   ## SEVERITY  Low    ## PROOF OF CONCEPT  Instances include:   ### Withdrawer.sol  [weth = _weth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L17)  ### YearnCurveVaultOperator.sol  [eth = _eth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48)\ [weth = IWETH(_weth)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48)\ [withdrawer = _withdrawer](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L50)    ## TOOLS USED  Manual Analysis    ## MITIGATION  Add a zero address check for these parameters.  # Payable functions when using ERC20   ## PROBLEM  Some functions have the `payable` modifier but their logic does not make use of `msg.value`. These contracts do not have any way to withdraw ETH, meaning any ETH sent would get locked.     ## SEVERITY  Low     ## PROOF OF CONCEPT  Instances include:   ### ParaswapOperator.sol  scope: `performSwap`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L26)  ### BeefyVaultOperator.sol  scope: `deposit`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L40)  ### BeefyZapBiswapLPVaultOperator.sol  scope: `deposit`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L51)  ### BeefyZapUniswapLPVaultOperator.sol  scope: `deposit`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L51)  ### YearnCurveVaultOperator.sol  scope: `deposit`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L120)  scope: `withdraw128`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L211)  scope: `withdraw256`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L259)   ## TOOLS USED  Manual Analysis    ## MITIGATION  There should be a `require(0 == msg.value)` in these functions to ensure no Ether is being sent. 
# Gas Report  ## Table of Contents  - [Caching storage variables in memory to save gas](#caching-storage-variables-in-memory-to-save-gas) - [Calldata instead of memory for RO function parameters](#calldata-instead-of-memory-for-ro-function-parameters) - [Comparison operators](#comparison-operators) - [Constructor parameters should be avoided when possible](#constructor-parameters-should-be-avoided-when-possible) - [Default value initialization](#default-value-initialization) - [Mathematical optimizations](#mathematical-optimizations) - [Require instead of AND](#require-instead-of-and) - [Revert strings length](#revert-strings-length) - [Shifting cheaper than division](#shifting-cheaper-than-division) - [Tight variable packing](#tight-variable-packing) - [unchecked arithmetic](#unchecked-arithmetic) - [unnecessary computation](#unnecessary-computation)  # Caching storage variables in memory to save gas  ## IMPACT  Anytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable in memory: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.   ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  scope: `_transferFeeWithRoyalty()`  - `feeSplitter` is read 3 times  [line 573](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L573)\ [line 575](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L575)\ [line 577](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L577)   ## TOOLS USED  Manual Analysis  ## MITIGATION  cache these storage variables in memory  # Calldata instead of memory for RO function parameters  ## PROBLEM  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.  Try to use calldata as a data location because it will avoid copies and also makes sure that the data cannot be modified.  ## PROOF OF CONCEPT  Instances include:  ### ExchangeHelpers.sol  scope: `fillQuote()`  - [bytes memory _swapCallData](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/ExchangeHelpers.sol#L18)  ### OwnerProxy.sol  scope: `execute()`  - [bytes memory _data](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L16)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `memory` with `calldata`  # Comparison Operators  ## IMPACT  In the EVM, there is no opcode for ` >=` or `<=`. When using greater than or equal, two operations are performed: `>` and `=`.  Using strict comparison operators hence saves gas  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [_entryFees <= 10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L161)\ [_entryFees <= 10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L169)\ [amountSpent <= _inputTokenAmount - feesAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L379)\ [amountSpent <= _inputTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L428)\ [amounts[1] <= _amountToSpend](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L495)\ [address(this).balance >= _inputTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L544)\ [nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L552)  ### BeefyVaultOperator.sol  [vaultAmount >= minVaultAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L54)  ### BeefyZapBiswapLPVaultOperator.sol  [vaultAmount >= minVaultAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64)\ [amountToDeposit >= depositedAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L65)\ [tokenAmount >= minTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L109)  ### BeefyZapUniswapLPVaultOperator.sol  [vaultAmount >= minVaultAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64)\ [amountToDeposit >= depositedAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L65)\ [tokenAmount >= minTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L109)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `<=` with `<`, and `>=` with `>`. Do not forget to increment/decrement the compared variable  example:  ``` -vaultAmount >= minVaultAmount; +vaultAmount > minVaultAmount - 1; ```  However, if `1` is negligible compared to the value of the variable, we can omit the increment.   # Constructor parameters should be avoided when possible  ## IMPACT  Constructor parameters are expensive. The contract deployment will be cheaper in gas if they are hard coded instead of using constructor parameters. With the compilers parameters in `hardhat.config.ts`, deployment costs approximately `400` more gas per variable written via a constructor parameter.  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [constructor](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L76-L81)  ``` nestedAsset = _nestedAsset; nestedRecords = _nestedRecords; reserve = _reserve; feeSplitter = _feeSplitter; weth = _weth; withdrawer = _withdrawer ```  ### Withdrawer.sol  [weth = _weth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L17)  ### Paraswap.sol  [tokenTransferProxy = _tokenTransferProxy](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L17)\ [augustusSwapper = _augustusSwapper](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L18)  ### YearnCurveVaultOperator.sol  [eth = _eth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48)\ [withdrawer = _withdrawer](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L50)  ### TimelockControllerEmergency.sol  [_minDelay = minDelay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L93)  ### OperatorScripts.sol  [nestedFactory = _nestedFactory](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L21)\ [resolver = _resolver](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L22)   ## TOOLS USED  Manual Analysis, hardhat  ## MITIGATION  Hardcode storage variables with their initial value instead of writing it during contract deployment with constructor parameters.   # Default value initialization  ## IMPACT  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L136)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L196)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L256)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L315)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L333)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L369)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L412)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L651)  ### OperatorResolver.sol  [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L60)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L75)  ### MixinOperatorResolver.sol  [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L56)  ### TimelockControllerEmergency.sol  [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L84)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L89)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L234)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L324)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove explicit initialization for default values.   # Mathematical optimizations  ## PROBLEM  X += Y costs `22` more gas than X = X + Y. This can mean a lot of gas wasted in a function call when the computation is repeated `n` times (loops)  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [amountBought -= amountFees](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L266)\ [amountSpent += _submitOrder(address(tokenSold),_batchedOrders.orders[i].token,_nftId,_batchedOrders.orders[i],true // always to the reserve)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L370-L376)\ [ethNeeded += _batchedOrders[i].amount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L653)  ## TOOLS USED  Manual Analysis  ## MITIGATION  use `X = X + Y` instead of `X += Y` (same with `-`)  # Require instead of AND  ## IMPACT  Require statements including conditions with the `&&` operator can be broken down in multiple require statements to save gas.  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [require(address(_nestedAsset) != address(0) &&  address(_nestedRecords) != address(0) &&address(_reserve) != address(0) &&address(_feeSplitter) != address(0) &&address(_weth) != address(0) &&  _operatorResolver != address(0) &&  address(_withdrawer) != address(0),  "NF: INVALID_ADDRESS" )](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L66-L74)  ### BeefyVaultOperator.sol  [require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BVO: INVALID_AMOUNT_RECEIVED")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L54)  ### BeefyZapBiswapLPVaultOperator.sol  [require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64)\ [require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L65)  ### BeefyZapUniswapLPVaultOperator.sol  [require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64)\ [require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L65)  ### ParaswapOperator.sol  [require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L16)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Break down the statements in multiple require statements.  ``` -require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS"); +require(_tokenTransferProxy != address(0))  +require(_augustusSwapper != address(0)); ``` You can also improve gas savings by using [custom errors](#custom-errors)   # Revert strings length  ## IMPACT  Revert strings cost more gas to deploy if the string is larger than 32 bytes. It costs `9,500` gas upon deployment per string exceeding that 32-byte size.  ## PROOF OF CONCEPT  Revert strings exceeding 32 bytes include:  ### TimelockControllerEmergency.sol  [TimelockController: length mismatch](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L229)\ [TimelockController: length mismatch](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L230)\ [TimelockController: operation already scheduled](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L243)\ [TimelockController: insufficient delay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L244)\ [TimelockController: operation cannot be cancelled](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L256)\ [TimelockController: length mismatch](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L319)\ [TimelockController: length mismatch](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L320)\ [TimelockController: operation is not ready](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L334)\ [TimelockController: missing dependency](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L335)\ [TimelockController: operation is not ready](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L342)\ [TimelockController: underlying transaction reverted](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L359)\ [TimelockController: caller must be timelock](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L375)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Write the error strings so that they do not exceed 32 bytes. For further gas savings, consider also using [custom errors](#custom-errors).   # Shifting cheaper than division  ## IMPACT  A division by 2 can be calculated by shifting one to the right. While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.  ## PROOF OF CONCEPT  Instances include:  ### BeefyZapBiswapLPVaultOperator.sol  [uint256 halfInvestment = investmentA / 2](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275)  ### BeefyZapUniswapLPVaultOperator.sol  [uint256 halfInvestment = investmentA / 2](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L275)  ## TOOLS USED  Manual Analysis  ## MITIGATION  ``` -investmentA / 2; +investmentA >> 1; ```  # Tight Variable Packing  ## PROBLEM  Solidity contracts have contiguous 32 bytes (256 bits) slots used in storage. By arranging the variables, it is possible to minimize the number of slots used within a contract's storage and therefore reduce deployment costs.  address type variables are each of 20 bytes size (way less than 32 bytes). However, they here take up a whole 32 bytes slot (they are contiguous).  As bool type variables are of size 1 byte, there's a slot here that can get saved by moving one bool closer to an address  ## PROOF OF CONCEPT  Instances include:  ### OwnableProxyDelegation.sol  ``` address private _owner; @audit - slot 1  /// @dev Storage slot with the proxy admin (see TransparentUpgradeableProxy from OZ) bytes32 internal constant _ADMIN_SLOT = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);  @audit - slot 2  /// @dev True if the owner is setted bool public initialized;  @audit - slot 3 ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Place `initialized` after `_owner` to save one storage slot  ``` address private _owner; @audit - slot 1  /// @dev True if the owner is setted +bool public initialized;   /// @dev Storage slot with the proxy admin (see TransparentUpgradeableProxy from OZ) bytes32 internal constant _ADMIN_SLOT = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);  @audit - slot 2 ```   # Unchecked arithmetic  ## IMPACT  The default "checked" behavior costs more gas when adding/diving/multiplying, because under-the-hood those checks are implemented as a series of opcodes that, prior to performing the actual arithmetic, check for under/overflow and revert if it is detected.  if it can statically be determined there is no possible way for your arithmetic to under/overflow (such as a condition in an if statement), surrounding the arithmetic in an `unchecked` block will save gas. This is particularly true in for loops, as it saves some gas at each iteration.  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L136)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L196)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L256)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L315)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L333)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L369)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L412)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L651)  ### OperatorResolver.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L60)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L75)  ### MixinOperatorResolver.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L56)  ### BeefyVaultOperator.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L18)  ### BeefyZapBiswapLPVaultOperator.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27)  ### BeefyZapUniswapLPVaultOperator.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27)  ### YearnCurveVaultOperator.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42)  ### CurveHelpers.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L22)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L42)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L62)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L86)  ### OperatorScripts.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L67)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L80)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Place the arithmetic operations in an `unchecked` block  # Unnecessary computation  ## IMPACT  When emitting an event that includes a new and an old value, it is cheaper in gas to avoid caching the old value in memory. Instead, emit the event, then save the new value in storage.  ## PROOF OF CONCEPT  Instances include:  ### OwnableProxyDelegation.sol  [function _setOwner](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L64-L66)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace  ``` address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner) ```  with  ``` emit OwnershipTransferred(_owner_, newOwner) _owner = newOwner; ``` 
 Note: The README lists a bunch of QA/Gas reports from prior findings, but doesn't list the specific issues found therein. Having each warden look at each report and de-dupe is just like adding more files to the scope, and I think is a bit unfair. For the ones that the sponsor has [explicitly listed](https://code4rena.com/contests/2022-06-nested-finance-contest#gas-optimizations-already-surfaced) I've still included them because the sponsor may end up finding them useful, especially after seeing the gas amounts involved, but have the lines with strike-through, so the sponsor and judge can ignore them if they wish  ## Summary  ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | 1 | Unused/empty `receive()`/`fallback()` function | 1 | | 2 | Missing checks for `address(0x0)` when assigning values to `address` state variables | 2 |  Total: 3 instances over 2 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | 1 | Missing `initializer` modifier on constructor | 2 | | 2 | Missing `initializer` modifier | 2 | | 3 | Adding a `return` statement when the function defines a named return variable, is redundant | 4 | | 4 | `public` functions not called by the contract should be declared `external` instead | 2 | | 5 | `constant`s should be defined rather than using magic numbers | 25 | | ~~6~~ | ~~Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`~~ | ~~4~~ | | 7 | Constant redefined elsewhere | 5 | | 8 | NatSpec is incomplete | 10 | | 9 | Event is missing `indexed` fields | 8 | | 10 | Not using the named return variables anywhere in the function is confusing | 8 |  ~~Total: 70 instances over 10 issues~~ Total: 66 instances over 9 issues   ## Low Risk Issues  ### 1. Unused/empty `receive()`/`fallback()` function If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`)  *There is 1 instance of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #1  113:      receive() external payable {} ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L113  ### 2. Missing checks for `address(0x0)` when assigning values to `address` state variables  *There are 2 instances of this issue:* ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol   #1  48:           eth = _eth; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48  ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol   #2  65:           _owner = newOwner; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L65  ## Non-critical Issues  ### 1. Missing `initializer` modifier on constructor OpenZeppelin [recommends](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5) that the `initializer` modifier be applied to constructors  *There are 2 instances of this issue:* ```solidity File: contracts/Withdrawer.sol   #1  16:       constructor(IWETH _weth) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L16  ```solidity File: contracts/NestedFactory.sol   #2  57        constructor( 58            NestedAsset _nestedAsset, 59            NestedRecords _nestedRecords, 60            NestedReserve _reserve, 61            FeeSplitter _feeSplitter, 62            IWETH _weth, 63            address _operatorResolver, 64            Withdrawer _withdrawer 65:       ) MixinOperatorResolver(_operatorResolver) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L57-L65  ### 2. Missing `initializer` modifier The contract extends `ReentrancyGuard`/`ReentrancyGuardUpgradeable` but does not use the `initializer` modifier anywhere  *There are 2 instances of this issue:* ```solidity File: contracts/Withdrawer.sol   #1  13:   contract Withdrawer is ReentrancyGuard { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L13  ```solidity File: contracts/NestedFactory.sol   #2  20:   contract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L20  ### 3. Adding a `return` statement when the function defines a named return variable, is redundant  *There are 4 instances of this issue:* ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol   #1  25:                   return amounts; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L25  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol   #2  45:                   return amounts; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L45  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol   #3  65:                   return amounts; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L65  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol   #4  89:                   return success; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L89  ### 4. `public` functions not called by the contract should be declared `external` instead Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.  *There are 2 instances of this issue:* ```solidity File: contracts/governance/OwnerProxy.sol   #1  16:       function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L16  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #2  295       function executeEmergency( 296           address target, 297           uint256 value, 298           bytes calldata data 299:      ) public payable onlyRole(EMERGENCY_ROLE) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L295-L299  ### 5. `constant`s should be defined rather than using magic numbers Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals  *There are 25 instances of this issue:* ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  /// @audit 1000 271:          require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW");  /// @audit 1000 272:          require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L271  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  /// @audit 1000 269:          require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW");  /// @audit 1000 270:          require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L269  ```solidity File: contracts/governance/OwnerProxy.sol  /// @audit 0x20 21:               let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 0)  /// @audit 0x40 24:               response := mload(0x40)  /// @audit 0x40 25:               mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))  /// @audit 0x20 25:               mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))  /// @audit 0x1f 25:               mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))  /// @audit 0x1f 25:               mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))  /// @audit 0x20 27:               returndatacopy(add(response, 0x20), 0, size)  /// @audit 0x20 32:                   revert(add(response, 0x20), size) ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L21  ```solidity File: contracts/governance/scripts/OperatorScripts.sol  /// @audit 0x20 59:               deployedAddress := create(0, add(bytecode, 0x20), mload(bytecode)) ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L59  ```solidity File: contracts/NestedFactory.sol  /// @audit 10000 161:          require(_entryFees <= 10000, "NF: FEES_OVERFLOW");  /// @audit 10000 169:          require(_exitFees <= 10000, "NF: FEES_OVERFLOW");  /// @audit 10000 264:          uint256 amountFees = (amountBought * exitFees) / 10000; // Exit Fees  /// @audit 10000 378:          feesAmount = (amountSpent * entryFees) / 10000; // Entry Fees  /// @audit 10000 443:              feesAmount = (amountBought * (_toReserve ? entryFees : exitFees)) / 10000;  /// @audit 10000 629:          uint256 feeAmount = (_amount * exitFees) / 10000; // Exit Fee ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L161  ```solidity File: contracts/libraries/StakingLPVaultHelpers.sol  /// @audit 3 38:           } else if (poolCoinAmount == 3) {  /// @audit 3 70:           } else if (poolCoinAmount == 3) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L38  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol  /// @audit 3 41:       ) internal view returns (uint256[3] memory amounts) {  /// @audit 3 42:           for (uint256 i; i < 3; i++) {  /// @audit 4 61:       ) internal view returns (uint256[4] memory amounts) {  /// @audit 4 62:           for (uint256 i; i < 4; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L41  ### ~~6. Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`~~  *There are 4 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #1  25:       bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256("TIMELOCK_ADMIN_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L25  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #2  26:       bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L26  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #3  27:       bytes32 public constant EXECUTOR_ROLE = keccak256("EXECUTOR_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L27  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #4  28:       bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L28  ### 7. Constant redefined elsewhere Consider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.  *There are 5 instances of this issue:* ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  /// @audit seen in contracts/operators/Beefy/BeefyVaultOperator.sol  19:       BeefyVaultStorage public immutable operatorStorage; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L19  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  /// @audit seen in contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  19:       BeefyVaultStorage public immutable operatorStorage; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L19  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  /// @audit seen in contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  20:       YearnVaultStorage public immutable operatorStorage; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L20  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  /// @audit seen in contracts/governance/scripts/OperatorScripts.sol  17:       OperatorResolver public immutable resolver; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L17  ```solidity File: contracts/NestedFactory.sol  /// @audit seen in contracts/Withdrawer.sol  39:       IWETH public immutable weth; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L39  ### 8. NatSpec is incomplete  *There are 10 instances of this issue:* ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  /// @audit Missing: '@return' 230       /// @param path An array of the two paired token addresses 231       /// @param biswapRouter The uniswapV2 router to be used for swap and liquidity addition 232       function _swapAndAddLiquidity( 233           uint256 amount, 234           uint256 swapAmountIn, 235           address[] memory path, 236           IBiswapRouter02 biswapRouter 237:      ) private returns (uint256 mintedLpAmount) {  /// @audit Missing: '@param reserveA' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       /// @param pair The IBiswapPair to be used 264       function _getOptimalSwapAmount( 265           uint256 investmentA, 266           uint256 reserveA, 267           uint256 reserveB, 268           IBiswapRouter02 router, 269           IBiswapPair pair 270:      ) private view returns (uint256 swapAmount) {  /// @audit Missing: '@param reserveB' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       /// @param pair The IBiswapPair to be used 264       function _getOptimalSwapAmount( 265           uint256 investmentA, 266           uint256 reserveA, 267           uint256 reserveB, 268           IBiswapRouter02 router, 269           IBiswapPair pair 270:      ) private view returns (uint256 swapAmount) {  /// @audit Missing: '@param router' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       /// @param pair The IBiswapPair to be used 264       function _getOptimalSwapAmount( 265           uint256 investmentA, 266           uint256 reserveA, 267           uint256 reserveB, 268           IBiswapRouter02 router, 269           IBiswapPair pair 270:      ) private view returns (uint256 swapAmount) {  /// @audit Missing: '@return' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       /// @param pair The IBiswapPair to be used 264       function _getOptimalSwapAmount( 265           uint256 investmentA, 266           uint256 reserveA, 267           uint256 reserveB, 268           IBiswapRouter02 router, 269           IBiswapPair pair 270:      ) private view returns (uint256 swapAmount) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L230-L237  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  /// @audit Missing: '@return' 230       /// @param path An array of the two paired token addresses 231       /// @param uniswapRouter The uniswapV2 router to be used for swap and liquidity addition 232       function _swapAndAddLiquidity( 233           uint256 amount, 234           uint256 swapAmountIn, 235           address[] memory path, 236           IUniswapV2Router02 uniswapRouter 237:      ) private returns (uint256 mintedLpAmount) {  /// @audit Missing: '@param reserveA' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       function _getOptimalSwapAmount( 264           uint256 investmentA, 265           uint256 reserveA, 266           uint256 reserveB, 267           IUniswapV2Router02 router 268:      ) private pure returns (uint256 swapAmount) {  /// @audit Missing: '@param reserveB' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       function _getOptimalSwapAmount( 264           uint256 investmentA, 265           uint256 reserveA, 266           uint256 reserveB, 267           IUniswapV2Router02 router 268:      ) private pure returns (uint256 swapAmount) {  /// @audit Missing: '@param router' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       function _getOptimalSwapAmount( 264           uint256 investmentA, 265           uint256 reserveA, 266           uint256 reserveB, 267           IUniswapV2Router02 router 268:      ) private pure returns (uint256 swapAmount) {  /// @audit Missing: '@return' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       function _getOptimalSwapAmount( 264           uint256 investmentA, 265           uint256 reserveA, 266           uint256 reserveB, 267           IUniswapV2Router02 router 268:      ) private pure returns (uint256 swapAmount) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L230-L237  ### 9. Event is missing `indexed` fields Each `event` should use three `indexed` fields if there are three or more fields  *There are 8 instances of this issue:* ```solidity File: contracts/operators/Beefy/BeefyVaultStorage.sol  12:       event VaultAdded(address vault, address tokenOrZapper);  16:       event VaultRemoved(address vault); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L12  ```solidity File: contracts/operators/Yearn/YearnVaultStorage.sol  17:       event VaultAdded(address vault, CurvePool pool);  21:       event VaultRemoved(address vault); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L17  ```solidity File: contracts/governance/TimelockControllerEmergency.sol  37        event CallScheduled( 38            bytes32 indexed id, 39            uint256 indexed index, 40            address target, 41            uint256 value, 42            bytes data, 43            bytes32 predecessor, 44            uint256 delay 45:       );  50:       event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);  60:       event MinDelayChange(uint256 oldDuration, uint256 newDuration); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L37-L45  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  14:       event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L14  ### 10. Not using the named return variables anywhere in the function is confusing Consider changing the variable to be an unnamed one  *There are 8 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol  /// @audit pending 119:      function isOperation(bytes32 id) public view virtual returns (bool pending) {  /// @audit pending 126:      function isOperationPending(bytes32 id) public view virtual returns (bool pending) {  /// @audit ready 133:      function isOperationReady(bytes32 id) public view virtual returns (bool ready) {  /// @audit done 141:      function isOperationDone(bytes32 id) public view virtual returns (bool done) {  /// @audit timestamp 149:      function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {  /// @audit duration 158:      function getMinDelay() public view virtual returns (uint256 duration) {  /// @audit hash 166       function hashOperation( 167           address target, 168           uint256 value, 169           bytes calldata data, 170           bytes32 predecessor, 171           bytes32 salt 172:      ) public pure virtual returns (bytes32 hash) {  /// @audit hash 180       function hashOperationBatch( 181           address[] calldata targets, 182           uint256[] calldata values, 183           bytes[] calldata datas, 184           bytes32 predecessor, 185           bytes32 salt 186:      ) public pure virtual returns (bytes32 hash) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L119   
 Note: The README lists a bunch of QA/Gas reports from prior findings, but doesn't list the specific issues found therein. Having each warden look at each report and de-dupe is just like adding more files to the scope, and I think is a bit unfair. For the ones that the sponsor has [explicitly listed](https://code4rena.com/contests/2022-06-nested-finance-contest#gas-optimizations-already-surfaced) I've still included them because the sponsor may end up finding them useful, especially after seeing the gas amounts involved, but have the lines with strike-through, so the sponsor and judge can ignore them if they wish  ## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | 1 | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 3 | | 2 | Using `storage` instead of `memory` for structs/arrays saves gas | 1 | | 3 | Multiple accesses of a mapping/array should use a local variable cache | 4 | | 4 | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement | 2 | | ~~5~~ | ~~`<array>.length` should not be looked up in every loop of a `for`-loop~~ | ~~10~~ | | 6 | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 28 | | 7 | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 12 | | 8 | Optimize names to save gas | 2 | | 9 | Using `bool`s for storage incurs overhead | 1 | | 10 | It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied | 18 | | ~~11~~ | ~~`++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)~~ | ~~24~~ | | 12 | Splitting `require()` statements that use `&&` saves gas | 7 | | 13 | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 6 | | 14 | Using `private` rather than `public` for constants, saves gas | 4 | | 15 | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 14 | | 16 | Division by two should use bit shifting | 2 | | 17 | `require()` or `revert()` statements that check input arguments should be at the top of the function | 1 | | 18 | Empty blocks should be removed or emit something | 2 | | ~~19~~ | ~~Use custom errors rather than `revert()`/`require()` strings to save gas~~ | ~~132~~ | | 20 | Functions guaranteed to revert when called by normal users can be marked `payable` | 27 | | 21 | Don't use `_msgSender()` if not supporting EIP-2771 | 13 |  ~~Total: 313 instances over 21 issues~~ Total: 147 instances over 18 issues    ## Gas Optimizations  ### 1. Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution.   If the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one  *There are 3 instances of this issue:* ```solidity File: contracts/governance/scripts/OperatorScripts.sol   #1  28:       function addOperator(IOperatorResolver.Operator memory operator, bytes32 name) external { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L28  ```solidity File: contracts/governance/scripts/OperatorScripts.sol   #2  52:       function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L52  ```solidity File: contracts/governance/scripts/OperatorScripts.sol   #3  52:       function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L52  ### 2. Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There is 1 instance of this issue:* ```solidity File: contracts/NestedFactory.sol   #1  123:          bytes32[] memory operatorsCache = operators; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L123  ### 3. Multiple accesses of a mapping/array should use a local variable cache The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory  *There are 4 instances of this issue:* ```solidity File: contracts/operators/Yearn/YearnVaultStorage.sol   #1  /// @audit vaults[vault] on line 33 34:           require(vaults[vault].lpToken == address(0), "YVS: VAULT_ALREADY_HAS_LP"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L34  ```solidity File: contracts/governance/scripts/OperatorScripts.sol   #2  /// @audit operators[i] on line 68 69:               operatorsToImport[i] = IOperatorResolver.Operator(deployedAddress, operators[i].selector); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L69  ```solidity File: contracts/OperatorResolver.sol   #3  /// @audit operators[<etc>] on line 42 43:                   operators[names[i]].selector != destinations[i].selector ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L43  ```solidity File: contracts/OperatorResolver.sol   #4  /// @audit destinations[i] on line 42 43:                   operators[names[i]].selector != destinations[i].selector ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L43  ### 4. Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There are 2 instances of this issue:* ```solidity File: contracts/NestedFactory.sol   #1  /// @audit require() on line 428 431:                  uint256 underSpentAmount = _inputTokenAmount - amountSpent; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L431  ```solidity File: contracts/NestedFactory.sol   #2  /// @audit require() on line 495 497:                  uint256 underSpentAmount = _amountToSpend - amounts[1]; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L497  ### ~~5. `<array>.length` should not be looked up in every loop of a `for`-loop~~ The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  ~~*There are 10 instances of this issue:*~~ ```solidity File: contracts/governance/TimelockControllerEmergency.sol  84:           for (uint256 i = 0; i < proposers.length; ++i) {  89:           for (uint256 i = 0; i < executors.length; ++i) {  234:          for (uint256 i = 0; i < targets.length; ++i) {  324:          for (uint256 i = 0; i < targets.length; ++i) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L84  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  37:           for (uint256 i = 0; i < requiredOperators.length; i++) {  56:           for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  ```solidity File: contracts/OperatorResolver.sol  60:           for (uint256 i = 0; i < names.length; i++) {  75:           for (uint256 i = 0; i < destinations.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L60  ```solidity File: contracts/NestedFactory.sol  124:          for (uint256 i = 0; i < operatorsCache.length; i++) {  651:          for (uint256 i = 0; i < _batchedOrders.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  ### 6. `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There are 28 instances of this issue:* ```solidity File: contracts/operators/Beefy/BeefyVaultOperator.sol  18:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L18  ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  27:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  27:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  42:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42  ```solidity File: contracts/governance/TimelockControllerEmergency.sol  84:           for (uint256 i = 0; i < proposers.length; ++i) {  89:           for (uint256 i = 0; i < executors.length; ++i) {  234:          for (uint256 i = 0; i < targets.length; ++i) {  324:          for (uint256 i = 0; i < targets.length; ++i) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L84  ```solidity File: contracts/governance/scripts/OperatorScripts.sol  67:           for (uint256 i; i < operatorLength; i++) {  80:           for (uint256 i; i < operatorLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L67  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  37:           for (uint256 i = 0; i < requiredOperators.length; i++) {  56:           for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  ```solidity File: contracts/OperatorResolver.sol  40:           for (uint256 i = 0; i < namesLength; i++) {  60:           for (uint256 i = 0; i < names.length; i++) {  75:           for (uint256 i = 0; i < destinations.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40  ```solidity File: contracts/NestedFactory.sol  124:          for (uint256 i = 0; i < operatorsCache.length; i++) {  136:          for (uint256 i = 0; i < operatorsLength; i++) {  196:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  256:          for (uint256 i = 0; i < tokensLength; i++) {  315:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  333:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  369:          for (uint256 i = 0; i < batchLength; i++) {  412:          for (uint256 i = 0; i < batchLength; i++) {  651:          for (uint256 i = 0; i < _batchedOrders.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol  22:           for (uint256 i; i < 2; i++) {  42:           for (uint256 i; i < 3; i++) {  62:           for (uint256 i; i < 4; i++) {  86:           for (uint256 i; i < poolCoinAmount; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L22  ### 7. `require()`/`revert()` strings longer than 32 bytes cost extra gas Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**  *There are 12 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol  229:          require(targets.length == values.length, "TimelockController: length mismatch");  230:          require(targets.length == datas.length, "TimelockController: length mismatch");  243:          require(!isOperation(id), "TimelockController: operation already scheduled");  244:          require(delay >= getMinDelay(), "TimelockController: insufficient delay");  256:          require(isOperationPending(id), "TimelockController: operation cannot be cancelled");  319:          require(targets.length == values.length, "TimelockController: length mismatch");  320:          require(targets.length == datas.length, "TimelockController: length mismatch");  334:          require(isOperationReady(id), "TimelockController: operation is not ready");  335:          require(predecessor == bytes32(0) || isOperationDone(predecessor), "TimelockController: missing dependency");  342:          require(isOperationReady(id), "TimelockController: operation is not ready");  359:          require(success, "TimelockController: underlying transaction reverted");  375:          require(msg.sender == address(this), "TimelockController: caller must be timelock"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L229  ### 8. Optimize names to save gas `public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)  *There are 2 instances of this issue:* ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol   #1  /// @audit initialize() 10:   abstract contract OwnableProxyDelegation is Context { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L10  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol   #2  /// @audit resolverOperatorsRequired(), rebuildCache(), isResolverCached() 10:   abstract contract MixinOperatorResolver { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L10  ### 9. Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past  *There is 1 instance of this issue:* ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol   #1  18:       bool public initialized; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L18  ### 10. It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied Not overwriting the default for [stack variables](https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves **8 gas**. Storage and memory variables have larger savings  *There are 18 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol  84:           for (uint256 i = 0; i < proposers.length; ++i) {  89:           for (uint256 i = 0; i < executors.length; ++i) {  234:          for (uint256 i = 0; i < targets.length; ++i) {  324:          for (uint256 i = 0; i < targets.length; ++i) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L84  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  37:           for (uint256 i = 0; i < requiredOperators.length; i++) {  56:           for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  ```solidity File: contracts/OperatorResolver.sol  40:           for (uint256 i = 0; i < namesLength; i++) {  60:           for (uint256 i = 0; i < names.length; i++) {  75:           for (uint256 i = 0; i < destinations.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40  ```solidity File: contracts/NestedFactory.sol  124:          for (uint256 i = 0; i < operatorsCache.length; i++) {  136:          for (uint256 i = 0; i < operatorsLength; i++) {  196:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  256:          for (uint256 i = 0; i < tokensLength; i++) {  315:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  333:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  369:          for (uint256 i = 0; i < batchLength; i++) {  412:          for (uint256 i = 0; i < batchLength; i++) {  651:          for (uint256 i = 0; i < _batchedOrders.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  ### ~~11. `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)~~ Saves **6 gas per loop**  ~~*There are 24 instances of this issue:*~~ ```solidity File: contracts/operators/Beefy/BeefyVaultOperator.sol  18:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L18  ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  27:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  27:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  42:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42  ```solidity File: contracts/governance/scripts/OperatorScripts.sol  67:           for (uint256 i; i < operatorLength; i++) {  80:           for (uint256 i; i < operatorLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L67  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  37:           for (uint256 i = 0; i < requiredOperators.length; i++) {  56:           for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  ```solidity File: contracts/OperatorResolver.sol  40:           for (uint256 i = 0; i < namesLength; i++) {  60:           for (uint256 i = 0; i < names.length; i++) {  75:           for (uint256 i = 0; i < destinations.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40  ```solidity File: contracts/NestedFactory.sol  124:          for (uint256 i = 0; i < operatorsCache.length; i++) {  136:          for (uint256 i = 0; i < operatorsLength; i++) {  196:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  256:          for (uint256 i = 0; i < tokensLength; i++) {  315:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  333:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  369:          for (uint256 i = 0; i < batchLength; i++) {  412:          for (uint256 i = 0; i < batchLength; i++) {  651:          for (uint256 i = 0; i < _batchedOrders.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol  22:           for (uint256 i; i < 2; i++) {  42:           for (uint256 i; i < 3; i++) {  62:           for (uint256 i; i < 4; i++) {  86:           for (uint256 i; i < poolCoinAmount; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L22  ### 12. Splitting `require()` statements that use `&&` saves gas See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper  *There are 7 instances of this issue:* ```solidity File: contracts/operators/Beefy/BeefyVaultOperator.sol  54:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BVO: INVALID_AMOUNT_RECEIVED"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L54  ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  64:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED");  65:           require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  64:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED");  65:           require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64  ```solidity File: contracts/operators/Paraswap/ParaswapOperator.sol  16:           require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L16  ```solidity File: contracts/NestedFactory.sol  66            require( 67                address(_nestedAsset) != address(0) && 68                    address(_nestedRecords) != address(0) && 69                    address(_reserve) != address(0) && 70                    address(_feeSplitter) != address(0) && 71                    address(_weth) != address(0) && 72                    _operatorResolver != address(0) && 73                    address(_withdrawer) != address(0), 74                "NF: INVALID_ADDRESS" 75:           ); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L66-L75  ### 13. Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead > When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  *There are 6 instances of this issue:* ```solidity File: contracts/operators/Yearn/YearnVaultStorage.sol  8:        uint96 poolCoinAmount; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L8  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  72:           (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);  122:          (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);  166:          (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);  214:          (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);  262:          (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L72  ### 14. Using `private` rather than `public` for constants, saves gas If needed, the value can be read from the verified contract source code. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table  *There are 4 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #1  25:       bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256("TIMELOCK_ADMIN_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L25  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #2  26:       bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L26  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #3  27:       bytes32 public constant EXECUTOR_ROLE = keccak256("EXECUTOR_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L27  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #4  28:       bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L28  ### 15. Duplicated `require()`/`revert()` checks should be refactored to a modifier or function Saves deployment costs  *There are 14 instances of this issue:* ```solidity File: contracts/operators/Beefy/BeefyVaultOperator.sol  83:           require(amount != 0, "BVO: INVALID_AMOUNT");  85:           require(address(token) != address(0), "BVO: INVALID_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L83  ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  99:           require(router != address(0), "BLVO: INVALID_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L99  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  99:           require(router != address(0), "BLVO: INVALID_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L99  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  121:          require(amount != 0, "YCVO: INVALID_AMOUNT");  123:          require(pool != address(0), "YCVO: INVALID_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L121  ```solidity File: contracts/governance/TimelockControllerEmergency.sol  319:          require(targets.length == values.length, "TimelockController: length mismatch");  320:          require(targets.length == datas.length, "TimelockController: length mismatch");  342:          require(isOperationReady(id), "TimelockController: operation is not ready"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L319  ```solidity File: contracts/NestedFactory.sol  312:          require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS");  289:          require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH");  406:          require(batchLength != 0, "NF: INVALID_ORDERS"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L312  ```solidity File: contracts/libraries/StakingLPVaultHelpers.sol  138:          require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L138  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol  48:           revert("CH: INVALID_INPUT_TOKEN"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L48  ### 16. Division by two should use bit shifting `<x> / 2` is the same as `<x> >> 1`. The `DIV` opcode costs **5 gas**, whereas `SHR` only costs **3 gas**  *There are 2 instances of this issue:* ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol   #1  275:          uint256 halfInvestment = investmentA / 2; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol   #2  273:          uint256 halfInvestment = investmentA / 2; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L273  ### 17. `require()` or `revert()` statements that check input arguments should be at the top of the function Checks that involve constants should come before checks that involve state variables  *There is 1 instance of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #1  244:          require(delay >= getMinDelay(), "TimelockController: insufficient delay"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L244  ### 18. Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)  *There are 2 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #1  113:      receive() external payable {} ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L113  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol   #2  29:       function resolverOperatorsRequired() public view virtual returns (bytes32[] memory) {} ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L29  ### ~~19. Use custom errors rather than `revert()`/`require()` strings to save gas~~ Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hitby [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas  ~~*There are 132 instances of this issue:*~~ ```solidity File: contracts/operators/Beefy/BeefyVaultOperator.sol  15:           require(vaultsLength == tokens.length, "BVO: INVALID_VAULTS_LENGTH");  41:           require(amount != 0, "BVO: INVALID_AMOUNT");  43:           require(address(token) != address(0), "BVO: INVALID_VAULT");  50:           require(success, "BVO: DEPOSIT_CALL_FAILED");  54:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BVO: INVALID_AMOUNT_RECEIVED");  55:           require(amount == tokenAmount, "BVO: INVALID_AMOUNT_DEPOSITED");  83:           require(amount != 0, "BVO: INVALID_AMOUNT");  85:           require(address(token) != address(0), "BVO: INVALID_VAULT");  91:           require(success, "BVO: WITHDRAW_CALL_FAILED");  95:           require(vaultAmount == amount, "BVO: INVALID_AMOUNT_WITHDRAWED");  96:           require(tokenAmount != 0, "BVO: INVALID_AMOUNT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L15  ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  23:           require(vaultsLength == routers.length, "BLVO: INVALID_VAULTS_LENGTH");  52:           require(amountToDeposit != 0, "BLVO: INVALID_AMOUNT");  54:           require(router != address(0), "BLVO: INVALID_VAULT");  64:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED");  65:           require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED");  97:           require(amount != 0, "BLVO: INVALID_AMOUNT");  99:           require(router != address(0), "BLVO: INVALID_VAULT");  108:          require(vaultAmount == amount, "BLVO: INVALID_AMOUNT_WITHDRAWED");  109:          require(tokenAmount >= minTokenAmount, "BLVO: INVALID_OUTPUT_AMOUNT");  142:          require(token0 == token || token1 == token, "BLVO: INVALID_TOKEN");  187:          require(pair.factory() == biswapRouter.factory(), "BLVO: INVALID_VAULT");  198:          require(isInput0 || cachedToken1 == token, "BLVO: INVALID_INPUT_TOKEN");  271:          require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW");  272:          require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L23  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  23:           require(vaultsLength == routers.length, "BLVO: INVALID_VAULTS_LENGTH");  52:           require(amountToDeposit != 0, "BLVO: INVALID_AMOUNT");  54:           require(router != address(0), "BLVO: INVALID_VAULT");  64:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED");  65:           require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED");  97:           require(amount != 0, "BLVO: INVALID_AMOUNT");  99:           require(router != address(0), "BLVO: INVALID_VAULT");  108:          require(vaultAmount == amount, "BLVO: INVALID_AMOUNT_WITHDRAWED");  109:          require(tokenAmount >= minTokenAmount, "BLVO: INVALID_OUTPUT_AMOUNT");  142:          require(token0 == token || token1 == token, "BLVO: INVALID_TOKEN");  187:          require(pair.factory() == uniswapRouter.factory(), "BLVO: INVALID_VAULT");  198:          require(isInput0 || cachedToken1 == token, "BLVO: INVALID_INPUT_TOKEN");  269:          require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW");  270:          require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L23  ```solidity File: contracts/operators/Beefy/BeefyVaultStorage.sol  25:           require(vault != address(0), "BVS: INVALID_VAULT_ADDRESS");  26:           require(tokenOrZapper != address(0), "BVS: INVALID_UNDERLYING_ADDRESS");  27:           require(vaults[vault] == address(0), "BVS: ALREADY_EXISTENT_VAULT");  35:           require(vaults[vault] != address(0), "BVS: NON_EXISTENT_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L25  ```solidity File: contracts/operators/Yearn/YearnVaultStorage.sol  30:           require(vault != address(0), "YVS: INVALID_VAULT_ADDRESS");  31:           require(curvePool.poolAddress != address(0), "YVS: INVALID_POOL_ADDRESS");  32:           require(curvePool.lpToken != address(0), "YVS: INVALID_TOKEN_ADDRESS");  33:           require(vaults[vault].poolAddress == address(0), "YVS: VAULT_ALREADY_HAS_POOL");  34:           require(vaults[vault].lpToken == address(0), "YVS: VAULT_ALREADY_HAS_LP");  42:           require(vaults[vault].poolAddress != address(0), "YVS: NON_EXISTENT_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L30  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  39:           require(vaultsLength == pools.length, "YCVO: INVALID_VAULTS_LENGTH");  70:           require(amount != 0, "YCVO: INVALID_AMOUNT");  73:           require(pool != address(0), "YCVO: INVALID_VAULT");  121:          require(amount != 0, "YCVO: INVALID_AMOUNT");  123:          require(pool != address(0), "YCVO: INVALID_VAULT");  164:          require(amount != 0, "YCVO: INVALID_AMOUNT");  167:          require(pool != address(0), "YCVO: INVALID_VAULT");  212:          require(amount != 0, "YCVO: INVALID_AMOUNT");  215:          require(pool != address(0), "YCVO: INVALID_VAULT");  260:          require(amount != 0, "YCVO: INVALID_AMOUNT");  263:          require(pool != address(0), "YCVO: INVALID_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L39  ```solidity File: contracts/operators/Paraswap/ParaswapOperator.sol  16:           require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS");  27:           require(sellToken != buyToken, "PSO: SAME_INPUT_OUTPUT");  35:           require(success, "PSO: SWAP_FAILED");  39:           require(amountBought != 0, "PSO: INVALID_AMOUNT_BOUGHT");  40:           require(amountSold != 0, "PSO: INVALID_AMOUNT_SOLD"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L16  ```solidity File: contracts/governance/OwnerProxy.sol  17:           require(_target != address(0), "OP: INVALID_TARGET"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L17  ```solidity File: contracts/governance/TimelockControllerEmergency.sol  229:          require(targets.length == values.length, "TimelockController: length mismatch");  230:          require(targets.length == datas.length, "TimelockController: length mismatch");  243:          require(!isOperation(id), "TimelockController: operation already scheduled");  244:          require(delay >= getMinDelay(), "TimelockController: insufficient delay");  256:          require(isOperationPending(id), "TimelockController: operation cannot be cancelled");  319:          require(targets.length == values.length, "TimelockController: length mismatch");  320:          require(targets.length == datas.length, "TimelockController: length mismatch");  334:          require(isOperationReady(id), "TimelockController: operation is not ready");  335:          require(predecessor == bytes32(0) || isOperationDone(predecessor), "TimelockController: missing dependency");  342:          require(isOperationReady(id), "TimelockController: operation is not ready");  359:          require(success, "TimelockController: underlying transaction reverted");  375:          require(msg.sender == address(this), "TimelockController: caller must be timelock"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L229  ```solidity File: contracts/governance/scripts/OperatorScripts.sol  19:           require(_nestedFactory != address(0), "AO-SCRIPT: INVALID_FACTORY_ADDR");  20:           require(_resolver != address(0), "AO-SCRIPT: INVALID_RESOLVER_ADDR");  29:           require(operator.implementation != address(0), "AO-SCRIPT: INVALID_IMPL_ADDRESS");  54:           require(operatorLength != 0, "DAO-SCRIPT: INVALID_OPERATOR_LEN");  55:           require(bytecode.length != 0, "DAO-SCRIPT: BYTECODE_ZERO");  61:           require(deployedAddress != address(0), "DAO-SCRIPT: FAILED_DEPLOY"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L19  ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol  25:           require(ownerAddr != address(0), "OPD: INVALID_ADDRESS");  26:           require(!initialized, "OPD: INITIALIZED");  27:           require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, "OPD: FORBIDDEN");  41:           require(owner() == _msgSender(), "OPD: NOT_OWNER");  57:           require(newOwner != address(0), "OPD: INVALID_ADDRESS"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L25  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  23:           require(_resolver != address(0), "MOR: INVALID_ADDRESS");  77:           require(_foundAddress.implementation != address(0), string(abi.encodePacked("MOR: MISSING_OPERATOR: ", name)));  103:              require(tokens[0] == _outputToken, "MOR: INVALID_OUTPUT_TOKEN");  104:              require(tokens[1] == _inputToken, "MOR: INVALID_INPUT_TOKEN"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L23  ```solidity File: contracts/OperatorResolver.sol  27:           require(_foundOperator.implementation != address(0), reason);  39:           require(namesLength == destinations.length, "OR: INPUTS_LENGTH_MUST_MATCH");  57:           require(names.length == operatorsToImport.length, "OR: INPUTS_LENGTH_MUST_MATCH"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L27  ```solidity File: contracts/Withdrawer.sol  21:           require(msg.sender == address(weth), "WD: ETH_SENDER_NOT_WETH"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L21  ```solidity File: contracts/NestedFactory.sol  66            require( 67                address(_nestedAsset) != address(0) && 68                    address(_nestedRecords) != address(0) && 69                    address(_reserve) != address(0) && 70                    address(_feeSplitter) != address(0) && 71                    address(_weth) != address(0) && 72                    _operatorResolver != address(0) && 73                    address(_withdrawer) != address(0), 74                "NF: INVALID_ADDRESS" 75:           );  99:           require(nestedAsset.ownerOf(_nftId) == _msgSender(), "NF: CALLER_NOT_OWNER");  107:          require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), "NF: LOCKED_NFT");  122:          require(operator != bytes32(""), "NF: INVALID_OPERATOR_NAME");  125:              require(operatorsCache[i] != operator, "NF: EXISTENT_OPERATOR");  153:          require(address(_feeSplitter) != address(0), "NF: INVALID_FEE_SPLITTER_ADDRESS");  160:          require(_entryFees != 0, "NF: ZERO_FEES");  161:          require(_entryFees <= 10000, "NF: FEES_OVERFLOW");  168:          require(_exitFees != 0, "NF: ZERO_FEES");  169:          require(_exitFees <= 10000, "NF: FEES_OVERFLOW");  191:          require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS");  250:          require(_orders.length != 0, "NF: INVALID_ORDERS");  251:          require(tokensLength == _orders.length, "NF: INPUTS_LENGTH_MUST_MATCH");  252:          require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH");  286:          require(assetTokensLength > _tokenIndex, "NF: INVALID_TOKEN_INDEX");  288:          require(assetTokensLength > 1, "NF: UNALLOWED_EMPTY_PORTFOLIO");  289:          require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH");  312:          require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS");  313:          require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH");  330:          require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS");  331:          require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH");  359:          require(batchLength != 0, "NF: INVALID_ORDERS");  379:          require(amountSpent <= _inputTokenAmount - feesAmount, "NF: OVERSPENT");  406:          require(batchLength != 0, "NF: INVALID_ORDERS");  407:          require(_batchedOrders.amounts.length == batchLength, "NF: INPUTS_LENGTH_MUST_MATCH");  428:              require(amountSpent <= _inputTokenAmount, "NF: OVERSPENT");  469:          require(success, "NF: OPERATOR_CALL_FAILED");  495:              require(amounts[1] <= _amountToSpend, "NF: OVERSPENT");  543:              require(!_fromReserve, "NF: NO_ETH_FROM_RESERVE");  544:              require(address(this).balance >= _inputTokenAmount, "NF: INVALID_AMOUNT_IN");  551               require( 552                   nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount, 553                   "NF: INSUFFICIENT_AMOUNT_IN" 554:              );  612:              require(success, "NF: ETH_TRANSFER_ERROR");  656:          require(msg.value == ethNeeded, "NF: WRONG_MSG_VALUE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L66-L75  ```solidity File: contracts/libraries/StakingLPVaultHelpers.sol  108:          require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED");  138:          require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L108  ### 20. Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 27 instances of this issue:* ```solidity File: contracts/operators/Beefy/BeefyVaultStorage.sol  24:       function addVault(address vault, address tokenOrZapper) external onlyOwner {  34:       function removeVault(address vault) external onlyOwner { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L24  ```solidity File: contracts/operators/Yearn/YearnVaultStorage.sol  29:       function addVault(address vault, CurvePool calldata curvePool) external onlyOwner {  41:       function removeVault(address vault) external onlyOwner { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L29  ```solidity File: contracts/governance/OwnerProxy.sol  16:       function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L16  ```solidity File: contracts/governance/TimelockControllerEmergency.sol  199       function schedule( 200           address target, 201           uint256 value, 202           bytes calldata data, 203           bytes32 predecessor, 204           bytes32 salt, 205           uint256 delay 206:      ) public virtual onlyRole(PROPOSER_ROLE) {  221       function scheduleBatch( 222           address[] calldata targets, 223           uint256[] calldata values, 224           bytes[] calldata datas, 225           bytes32 predecessor, 226           bytes32 salt, 227           uint256 delay 228:      ) public virtual onlyRole(PROPOSER_ROLE) {  255:      function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {  274       function execute( 275           address target, 276           uint256 value, 277           bytes calldata data, 278           bytes32 predecessor, 279           bytes32 salt 280:      ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {  295       function executeEmergency( 296           address target, 297           uint256 value, 298           bytes calldata data 299:      ) public payable onlyRole(EMERGENCY_ROLE) {  312       function executeBatch( 313           address[] calldata targets, 314           uint256[] calldata values, 315           bytes[] calldata datas, 316           bytes32 predecessor, 317           bytes32 salt 318:      ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L199-L206  ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol  50:       function renounceOwnership() public virtual onlyOwner {  56:       function transferOwnership(address newOwner) public virtual onlyOwner { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L50  ```solidity File: contracts/OperatorResolver.sol  52        function importOperators( 53            bytes32[] calldata names, 54            Operator[] calldata operatorsToImport, 55            MixinOperatorResolver[] calldata destinations 56:       ) external override onlyOwner {  74:       function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L52-L56  ```solidity File: contracts/NestedFactory.sol  121:      function addOperator(bytes32 operator) external override onlyOwner {  133:      function removeOperator(bytes32 operator) external override onlyOwner {  152:      function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {  159:      function setEntryFees(uint256 _entryFees) external override onlyOwner {  167:      function setExitFees(uint256 _exitFees) external override onlyOwner {  175:      function unlockTokens(IERC20 _token) external override onlyOwner {  205       function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) 206           external 207           payable 208           override 209           nonReentrant 210           onlyTokenOwner(_nftId) 211:          isUnlocked(_nftId)  219       function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) 220           external 221           override 222           nonReentrant 223           onlyTokenOwner(_nftId) 224:          isUnlocked(_nftId)  231       function processInputAndOutputOrders( 232           uint256 _nftId, 233           BatchedInputOrders[] calldata _batchedInputOrders, 234           BatchedOutputOrders[] calldata _batchedOutputOrders 235:      ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {  243       function destroy( 244           uint256 _nftId, 245           IERC20 _buyToken, 246           Order[] calldata _orders 247:      ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {  278       function withdraw(uint256 _nftId, uint256 _tokenIndex) 279           external 280           override 281           nonReentrant 282           onlyTokenOwner(_nftId) 283:          isUnlocked(_nftId)  301:      function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L121  ### 21. Don't use `_msgSender()` if not supporting EIP-2771 Use `msg.sender` if the code does not implement [EIP-2771 trusted forwarder](https://eips.ethereum.org/EIPS/eip-2771) support  *There are 13 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol  77:           _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());  105:              _checkRole(role, _msgSender()); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L77  ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol  41:           require(owner() == _msgSender(), "OPD: NOT_OWNER"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L41  ```solidity File: contracts/NestedFactory.sol  99:           require(nestedAsset.ownerOf(_nftId) == _msgSender(), "NF: CALLER_NOT_OWNER");  194:          uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);  269:              _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());  274:          nestedAsset.burn(_msgSender(), _nftId);  294:          _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);  341:                  _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());  383:                  SafeERC20.safeTransfer(tokenSold, _fromReserve ? address(reserve) : _msgSender(), underSpentAmount);  499:                      _safeTransferWithFees(IERC20(_inputToken), underSpentAmount, _msgSender(), _nftId);  503:              _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);  558:              SafeERC20.safeTransferFrom(_inputToken, _msgSender(), address(this), _inputTokenAmount); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L99  
## Unlimited allowance is very dangerous  Nested finance use unlimited allowance in all contract that sent some token  contracts/libraries/ExchangeHelpers.sol ```         address _swapTarget,         bytes memory _swapCallData     ) internal returns (bool) {         setMaxAllowance(_sellToken, _swapTarget);     /// @param _token The token to use for the allowance setting     /// @param _spender Spender to allow     function setMaxAllowance(IERC20 _token, address _spender) internal { ```  contracts/mocks/DummyRouter.sol ```         NestedFactory(factory).destroy(nftId, IERC20(address(weth)), attackOrders);     }      function setMaxAllowance(IERC20 _token, address _spender) external {         ExchangeHelpers.setMaxAllowance(_token, _spender);     }      function setAllowance( ```  contracts/libraries/StakingLPVaultHelpers.sol ```         uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;         ExchangeHelpers.setMaxAllowance(lpToken, vault);         uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));         ExchangeHelpers.setMaxAllowance(IERC20(token), address(pool));          if (poolCoinAmount == 2) { ```  contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol ```             tokenAmountIn = amount1;         }          ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);          address[] memory path = new address[](2);         require(pair.factory() == biswapRouter.factory(), "BLVO: INVALID_VAULT");          ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vault)); ```  contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol ```             swapToken = token1;             tokenAmountIn = amount1;         }          ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);         require(pair.factory() == uniswapRouter.factory(), "BLVO: INVALID_VAULT");          ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vault));          address cachedToken0 = pair.token0(); ```  contracts/operators/Paraswap/ParaswapOperator.sol ```         ExchangeHelpers.setMaxAllowance(sellToken, tokenTransferProxy);         (bool success, ) = augustusSwapper.call(swapCallData); ```  contracts/operators/Beefy/BeefyVaultOperator.sol ```         uint256 tokenBalanceBefore = token.balanceOf(address(this));          ExchangeHelpers.setMaxAllowance(token, vault); ```  contracts/operators/Yearn/YearnCurveVaultOperator.sol ```         uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));         uint256 ethBalanceBefore = weth.balanceOf(address(this));          ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer)); ```  contracts/NestedFactory.sol ```     ) private {         address originalOwner = nestedAsset.originalOwner(_nftId);         ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));             ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));             withdrawer.withdraw(_amount); ```  If a contract that has max allowance is malicious, it may steal all tokens in the allowing contract. For example, if feeSplitter is malicious, it may steal all tokens in NestedFactory  ## poolCoinAmount validation  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol  poolCoinAmount must be 2, 3, 4 so, if it not fall in this range it should be reverted but now it doesn't  On every functions in this file add  ``` if (poolCoinAmount < 2 || poolCoinAmount > 4) revert ```  Change code to  ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.14;  import "./../Withdrawer.sol"; import "./../libraries/ExchangeHelpers.sol"; import "./../libraries/CurveHelpers/CurveHelpers.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./../interfaces/external/ICurvePool/ICurvePool.sol"; import "./../interfaces/external/ICurvePool/ICurvePoolETH.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "./../interfaces/external/IStakingVault/IStakingVault.sol"; import "./../interfaces/external/ICurvePool/ICurvePoolNonETH.sol";  error InvalidPoolCoinAmount(uint256 poolCoinAmount);  /// @notice Library for LP Staking Vaults deposit/withdraw library StakingLPVaultHelpers {     using SafeERC20 for IERC20;      /// @dev  Add liquidity in a Curve pool with ETH and deposit     ///       the LP token in a staking vault     /// @param vault The staking vault address to deposit into     /// @param pool The Curve pool to add liquitiy in     /// @param lpToken The Curve pool LP token     /// @param poolCoinAmount The number of token in the Curve pool     /// @param eth ETH address     /// @param amount ETH amount to add in the Curve pool     function _addLiquidityAndDepositETH(         address vault,         ICurvePoolETH pool,         IERC20 lpToken,         uint256 poolCoinAmount,         address eth,         uint256 amount     ) internal {         if (poolCoinAmount < 2 || poolCoinAmount > 4) revert InvalidPoolCoinAmount(poolCoinAmount);          uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));          if (poolCoinAmount == 2) {             pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts2Coins(pool, eth, amount), 0);         } else if (poolCoinAmount == 3) {             pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts3Coins(pool, eth, amount), 0);         } else {             pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts4Coins(pool, eth, amount), 0);         }          uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;         ExchangeHelpers.setMaxAllowance(lpToken, vault);         IStakingVault(vault).deposit(lpTokenToDeposit);     }      /// @dev  Add liquidity in a Curve pool and deposit     ///       the LP token in a staking vault     /// @param vault The staking vault address to deposit into     /// @param pool The Curve pool to add liquitiy in     /// @param lpToken The Curve pool lpToken     /// @param poolCoinAmount The number of token in the Curve pool     /// @param token Token to add in the Curve pool liquidity     /// @param amount Token amount to add in the Curve pool     function _addLiquidityAndDeposit(         address vault,         ICurvePoolNonETH pool,         IERC20 lpToken,         uint256 poolCoinAmount,         address token,         uint256 amount     ) internal {         if (poolCoinAmount < 2 || poolCoinAmount > 4) revert InvalidPoolCoinAmount(poolCoinAmount);          uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));         ExchangeHelpers.setMaxAllowance(IERC20(token), address(pool));          if (poolCoinAmount == 2) {             pool.add_liquidity(CurveHelpers.getAmounts2Coins(pool, token, amount), 0);         } else if (poolCoinAmount == 3) {             pool.add_liquidity(CurveHelpers.getAmounts3Coins(pool, token, amount), 0);         } else {             pool.add_liquidity(CurveHelpers.getAmounts4Coins(pool, token, amount), 0);         }          uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;         ExchangeHelpers.setMaxAllowance(lpToken, vault);         IStakingVault(vault).deposit(lpTokenToDeposit);     }      /// @dev Withdraw the LP token from the staking vault and     ///      remove the liquidity from the Curve pool     /// @param vault The staking vault address to withdraw from     /// @param amount The amount to withdraw     /// @param pool The Curve pool to remove liquitiy from     /// @param lpToken The Curve pool LP token     /// @param poolCoinAmount The number of token in the Curve pool     /// @param outputToken Output token to receive     function _withdrawAndRemoveLiquidity128(         address vault,         uint256 amount,         ICurvePool pool,         IERC20 lpToken,         uint256 poolCoinAmount,         address outputToken     ) internal {         if (poolCoinAmount < 2 || poolCoinAmount > 4) revert InvalidPoolCoinAmount(poolCoinAmount);          uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));         IStakingVault(vault).withdraw(amount);          bool success = CurveHelpers.removeLiquidityOneCoin(             pool,             lpToken.balanceOf(address(this)) - lpTokenBalanceBefore,             outputToken,             poolCoinAmount,             bytes4(keccak256(bytes("remove_liquidity_one_coin(uint256,int128,uint256)")))         );          require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED");     }      /// @dev Withdraw the LP token from the staking vault and     ///      remove the liquidity from the Curve pool     /// @param vault The staking vault address to withdraw from     /// @param amount The amount to withdraw     /// @param pool The Curve pool to remove liquitiy from     /// @param lpToken The Curve pool LP token     /// @param poolCoinAmount The number of token in the Curve pool     /// @param outputToken Output token to receive     function _withdrawAndRemoveLiquidity256(         address vault,         uint256 amount,         ICurvePool pool,         IERC20 lpToken,         uint256 poolCoinAmount,         address outputToken     ) internal {         if (poolCoinAmount < 2 || poolCoinAmount > 4) revert InvalidPoolCoinAmount(poolCoinAmount);          uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));         IStakingVault(vault).withdraw(amount);          bool success = CurveHelpers.removeLiquidityOneCoin(             pool,             lpToken.balanceOf(address(this)) - lpTokenBalanceBefore,             outputToken,             poolCoinAmount,             bytes4(keccak256(bytes("remove_liquidity_one_coin(uint256,uint256,uint256)")))         );          require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED");     } } ```  ## @openzeppelin/contracts should be updated to ^4.4.2 as ^4.3.2 has many vulnerables  https://github.com/code-423n4/2022-06-nested/blob/main/package.json is using  ``` "@openzeppelin/contracts": "^4.3.2", ```  @openzeppelin/contracts 4.3.2 has these vulnerabilities from https://snyk.io/vuln/npm:%40openzeppelin%2Fcontracts  - Function Call With Incorrect Argument - Deserialization of Untrusted Data - Numeric Errors - Improper Initialization - Improper Input Validation  You should update @openzeppelin/contracts to ^4.4.2 to avoid these vulnerabilities.
### Add `namesLength > 0` check in `areOperatorsImported()` method  - `areOperatorsImported()` in [OperatorResolver.sol#L32-L49](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L32-L49) returns `true` when input arrays are empty (ie. `[]`, `[]`).  ```solidity function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)     external     view     override     returns (bool) {     uint256 namesLength = names.length;     require(namesLength == destinations.length, "OR: INPUTS_LENGTH_MUST_MATCH");     for (uint256 i = 0; i < namesLength; i++) {         if (             operators[names[i]].implementation != destinations[i].implementation ||             operators[names[i]].selector != destinations[i].selector         ) {             return false;         }     }     return true; } ``` #### Recommendation  ```solidity require(namesLength > 0 "empty names/destinations"); ```
## 1. Can save gas when call `_submitOutOrders()` with `_toReserve = false`  In case `_toReserve = false`, it still calculates `feesAmount` using `entryFees` but do not use the result anywhere. We can save gas by calculating `feesAmount` only when `_toReserve = true`  ## Affected Code  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443  ## Recommended Mitigation Steps  Only calculate `feesAmount` only when `_toReserve = true`  ``` if (_toReserve) {  feesAmount = (amountBought * entryFees) / 10000; _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId); } ```  
## [N-01] Libraries, interfaces, and external imports can be ordered nicely E.g. group all libraries first, then interfaces, then OZ imports  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L4-L12
1. The require statements could be put at the beginning part of a block of statements if it doesn’t affect the logic to save gas. a. [require(_orders.length != 0, "NF: INVALID_ORDERS");]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L250")   2. Initializing i to 0 inside a for loop is redundant. As its initialized to 0 by default.  Also i++ or ++I in the for loops can be put inside an unchecked block to save gas.   a. [for (uint256 i = 0; i < operatorsCache.length; i++) ]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L124") b. [for (uint256 i = 0; i < operatorsLength; i++) ]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L136") c. [for (uint256 i = 0; i < batchedOrdersLength; i++)]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L196") d. [for (uint256 i = 0; i < tokensLength; i++)](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L256") e. [for (uint256 i = 0; i < batchedOrdersLength; i++)]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L315") f. [for (uint256 i = 0; i < batchedOrdersLength; i++)]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L333") g. [for (uint256 i = 0; i < batchLength; i++)]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L369") h. [ for (uint256 i = 0; i < batchLength; i++)]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L412") i. [for (uint256 i = 0; i < _batchedOrders.length; i++)]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L651") j. [for (uint256 i = 0; i < namesLength; i++) ](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L40”) k. [for (uint256 i = 0; i < names.length; i++)](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L60”) l. [for (uint256 i = 0; i < destinations.length; i++) ](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L75”) m. [  for (uint256 i = 0; i < requiredOperators.length; i++)](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L37”) n. [  for (uint256 i = 0; i < requiredOperators.length; i++)](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L56”) o. [for (uint256 i = 0; i < targets.length; ++i)](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L234”) p. [for (uint256 i = 0; i < targets.length; ++i)](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L324”)   3. Unless it was introduced for readability saving memory to memory is redundant. [address token = tokens[i];](“https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L257”)   4. These arithmetic operations can be unchecked. a. [ uint256 halfInvestment = investmentA / 2;](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275”) b. [uint256 halfInvestment = investmentA / 2;](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L273”)   5. This line could be pre-computed and defined as a constant to save gas. a. [bytes4(keccak256(bytes("remove_liquidity_one_coin(uint256,int128,uint256)")))](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L105”) b. [bytes4(keccak256(bytes("remove_liquidity_one_coin(uint256,uint256,uint256)")))](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L135”) 
## State variables that could be set immutable  In the following files there are state variables that could be set immutable to save gas.   ### Code instance:          operator in TestableOperatorCaller.sol    ## Unused state variables  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instances:          WETHMock.sol, symbol         WETHMock.sol, decimals         TestableMixingOperatorResolver.sol, addressesToCache         WETHMock.sol, name    ## Unused declared local variables  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instances:          NestedAssetBatcher.sol, getNfts, amounts         NestedAssetBatcher.sol, getNfts, nftAssets         TestableOperatorCaller.sol, performSwap, data    ## Unnecessary array boundaries check when loading an array element twice       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:       ### Code instances:          NestedFactory.sol._processOutputOrders - double load of _batchedOrders[i]         NestedFactory.sol._processInputOrders - double load of _batchedOrders[i]    ## Caching array length can save gas   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }   ### Code instances:          MixinOperatorResolver.sol, requiredOperators, 56         OperatorResolver.sol, destinations, 75         MixinOperatorResolver.sol, requiredOperators, 37         FeeSplitter.sol, _tokens, 147         TimelockControllerEmergency.sol, targets, 234         FeeSplitter.sol, shareholders, 316         TimelockControllerEmergency.sol, targets, 324         NestedFactory.sol, _batchedOrders, 651         FeeSplitter.sol, _tokens, 164         TimelockControllerEmergency.sol, proposers, 84         OperatorResolver.sol, names, 60         TimelockControllerEmergency.sol, executors, 89         NestedFactory.sol, operatorsCache, 124         FeeSplitter.sol, shareholdersCache, 278         FeeSplitter.sol, shareholders, 259    ## Prefix increments are cheaper than postfix increments  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:   ### Code instances:          change to prefix increment and unchecked: OperatorScripts.sol, i, 67         change to prefix increment and unchecked: OperatorScripts.sol, i, 80         change to prefix increment and unchecked: FeeSplitter.sol, i, 278         change to prefix increment and unchecked: MixinOperatorResolver.sol, i, 56    ## Unnecessary index init   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:  ### Code instances:          NestedFactory.sol, 315         OperatorResolver.sol, 75         NestedFactory.sol, 333         NestedFactory.sol, 196         FeeSplitter.sol, 259    ## Rearrange state variables  You can change the order of the storage variables to decrease memory uses.  ### Code instance:  In OwnableProxyDelegation.sol,rearranging the storage fields can optimize to: 2 slots from: 3 slots. The new order of types (you choose the actual variables):         1. bytes32         2. address         3. bool     ## Use bytes32 instead of string to save gas whenever possible       Use bytes32 instead of string to save gas whenever possible.     String is a dynamic data structure and therefore is more gas consuming then bytes32.       ### Code instances:          WETHMock.sol (L25), string public symbol = "WETH";         WETHMock.sol (L24), string public name = "Wrapped Ether";    ## Short the following require messages  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:   ### Code instances:          Solidity file: TimelockControllerEmergency.sol, In line 320, Require message length to shorten: 35, The message: TimelockController: length mismatch         Solidity file: TimelockControllerEmergency.sol, In line 244, Require message length to shorten: 38, The message: TimelockController: insufficient delay         Solidity file: TimelockControllerEmergency.sol, In line 229, Require message length to shorten: 35, The message: TimelockController: length mismatch         Solidity file: TimelockControllerEmergency.sol, In line 335, Require message length to shorten: 38, The message: TimelockController: missing dependency         Solidity file: TimelockControllerEmergency.sol, In line 319, Require message length to shorten: 35, The message: TimelockController: length mismatch         Solidity file: TimelockControllerEmergency.sol, In line 230, Require message length to shorten: 35, The message: TimelockController: length mismatch    ## Use != 0 instead of > 0   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)   ### Code instances:          WETHMock.sol, 71: change 'balance > 0' to 'balance != 0'         NestedFactory.sol, 544: change 'balance > 0' to 'balance != 0'         WETHMock.sol, 46: change 'balance > 0' to 'balance != 0'    ## Unnecessary cast        ### Code instance:          IERC20 DummyRouter.sol.dummyswapToken - unnecessary casting IERC20(_inputToken)    ## Use unchecked to save gas for certain additive calculations that cannot overflow   You can use unchecked in the following calculations since there is no risk to overflow:  ### Code instance:          TimelockControllerEmergency.sol (L#245) - _timestamps[id] = block.timestamp + delay;    ## Empty else statement can be removed to save gas           Empty else statement can be removed to save gas.               ### Code instance:          StakingLPVaultHelpers.sol._addLiquidityAndDepositETH    ## Empty else if statement can be removed to save gas           Empty else if statement can be removed to save gas by simply doing the following:                  if (a) {             some code 1         }         else if (b) {             empty         } else {             some code 2         }                  change this pattern to:         if (a) {             some code 1         }         else if (!b) {             some code 2         }                ### Code instance:          StakingLPVaultHelpers.sol._addLiquidityAndDepositETH    ## Consider inline the following functions to save gas       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               NestedAsset.sol, _baseURI, { return baseUri; }    ## Inline one time use functions   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.       ### Code instances:          BeefyZapUniswapLPVaultOperator.sol, _swapAndAddLiquidity         MixinOperatorResolver.sol, requireAndGetAddress         NestedBuybacker.sol, trigger         BeefyZapBiswapLPVaultOperator.sol, _swapAndAddLiquidity         ExchangeHelpers.sol, setMaxAllowance         FeeSplitter.sol, _addShareholder         BeefyZapUniswapLPVaultOperator.sol, _zapAndStakeLp         BeefyZapUniswapLPVaultOperator.sol, _withdrawAndSwap         BeefyZapBiswapLPVaultOperator.sol, _zapAndStakeLp         BeefyZapBiswapLPVaultOperator.sol, _withdrawAndSwap   
**Table of Contents:**  - [1. Cheap Contract Deployment Through Clones](#1-cheap-contract-deployment-through-clones) - [2. Reduce the size of error messages (Long revert Strings)](#2-reduce-the-size-of-error-messages-long-revert-strings) - [3. Splitting `require()` statements that use `&&` saves gas](#3-splitting-require-statements-that-use--saves-gas) - [4. Using private rather than public for constants saves gas](#4-using-private-rather-than-public-for-constants-saves-gas) - [5. Use shift right/left instead of division/multiplication if possible](#5-use-shift-rightleft-instead-of-divisionmultiplication-if-possible) - [6. `<array>.length` should not be looked up in every loop of a `for-loop`](#6-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop) - [7. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)](#7-i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1) - [8. Increments/decrements can be unchecked in for-loops](#8-incrementsdecrements-can-be-unchecked-in-for-loops) - [9. It costs more gas to initialize variables with their default value than letting the default value be applied](#9-it-costs-more-gas-to-initialize-variables-with-their-default-value-than-letting-the-default-value-be-applied) - [10. Use Custom Errors instead of Revert Strings to save Gas](#10-use-custom-errors-instead-of-revert-strings-to-save-gas) - [11. Functions guaranteed to revert when called by normal users can be marked `payable`](#11-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable)  ## 1. Cheap Contract Deployment Through Clones  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:25:        operatorStorage = new BeefyVaultStorage(); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:25:        operatorStorage = new BeefyVaultStorage(); operators/Yearn/YearnCurveVaultOperator.sol:40:        operatorStorage = new YearnVaultStorage(); ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  I suggest applying a similar pattern.  ## 2. Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity governance/TimelockControllerEmergency.sol:229:        require(targets.length == values.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:230:        require(targets.length == datas.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:243:        require(!isOperation(id), "TimelockController: operation already scheduled"); governance/TimelockControllerEmergency.sol:244:        require(delay >= getMinDelay(), "TimelockController: insufficient delay"); governance/TimelockControllerEmergency.sol:256:        require(isOperationPending(id), "TimelockController: operation cannot be cancelled"); governance/TimelockControllerEmergency.sol:319:        require(targets.length == values.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:320:        require(targets.length == datas.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:334:        require(isOperationReady(id), "TimelockController: operation is not ready"); governance/TimelockControllerEmergency.sol:335:        require(predecessor == bytes32(0) || isOperationDone(predecessor), "TimelockController: missing dependency"); governance/TimelockControllerEmergency.sol:342:        require(isOperationReady(id), "TimelockController: operation is not ready"); governance/TimelockControllerEmergency.sol:359:        require(success, "TimelockController: underlying transaction reverted"); governance/TimelockControllerEmergency.sol:375:        require(msg.sender == address(this), "TimelockController: caller must be timelock"); ```  I suggest shortening the revert strings to fit in 32 bytes.  ## 3. Splitting `require()` statements that use `&&` saves gas  If you're using the Optimizer at 200, instead of using the `&&` operator in a single require statement to check multiple conditions, I suggest using multiple require statements with 1 condition per require statement:  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:64:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:65:        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:64:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:65:        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED"); operators/Beefy/BeefyVaultOperator.sol:54:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BVO: INVALID_AMOUNT_RECEIVED"); operators/Paraswap/ParaswapOperator.sol:16:        require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS"); NestedFactory.sol:67:            address(_nestedAsset) != address(0) && NestedFactory.sol:68:                address(_nestedRecords) != address(0) && NestedFactory.sol:69:                address(_reserve) != address(0) && NestedFactory.sol:70:                address(_feeSplitter) != address(0) && NestedFactory.sol:71:                address(_weth) != address(0) && NestedFactory.sol:72:                _operatorResolver != address(0) && ```  Please, note that this might not hold true at a higher number of runs for the Optimizer (10k). However, it indeed is true at 200.  ## 4. Using private rather than public for constants saves gas  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  ```solidity governance/TimelockControllerEmergency.sol:25:    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256("TIMELOCK_ADMIN_ROLE"); governance/TimelockControllerEmergency.sol:26:    bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE"); governance/TimelockControllerEmergency.sol:27:    bytes32 public constant EXECUTOR_ROLE = keccak256("EXECUTOR_ROLE"); governance/TimelockControllerEmergency.sol:28:    bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");  ```  ## 5. Use shift right/left instead of division/multiplication if possible  While the `DIV` / `MUL` opcode uses 5 gas, the `SHR` / `SHL` opcode only uses 3 gas. Furthermore, beware that Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting. Eventually, overflow checks are never performed for shift operations as they are done for arithmetic operations. Instead, the result is always truncated.  - Use `>> 1` instead of `/ 2` - Use `>> 2` instead of `/ 4` - Use `<< 3` instead of `* 8`  Affected code:  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:275:        uint256 halfInvestment = investmentA / 2; operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:273:        uint256 halfInvestment = investmentA / 2; ```  ## 6. `<array>.length` should not be looked up in every loop of a `for-loop`  Reading array length at each iteration of the loop consumes more gas than necessary.    In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Here, I suggest storing the array's length in a variable before the for-loop, and use this new variable instead:  ```solidity abstracts/MixinOperatorResolver.sol:37:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts/MixinOperatorResolver.sol:56:        for (uint256 i = 0; i < requiredOperators.length; i++) { governance/TimelockControllerEmergency.sol:84:        for (uint256 i = 0; i < proposers.length; ++i) { governance/TimelockControllerEmergency.sol:89:        for (uint256 i = 0; i < executors.length; ++i) { governance/TimelockControllerEmergency.sol:234:        for (uint256 i = 0; i < targets.length; ++i) { governance/TimelockControllerEmergency.sol:324:        for (uint256 i = 0; i < targets.length; ++i) { NestedFactory.sol:124:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:651:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  ## 7. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)  Pre-increments and pre-decrements are cheaper.  For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1` - `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)  **Decrement:**  - `i -= 1` is the most expensive form - `i--` costs 11 gas less than `i -= 1` - `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:  ```solidity uint i = 1;   uint j = 2; require(j == i++, "This will be false as i is incremented after the comparison"); ```    However, pre-increments (or pre-decrements) return the new value:    ```solidity uint i = 1;   uint j = 2; require(j == ++i, "This will be true as i is incremented before the comparison"); ```    In the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.      Affected code:    ```solidity abstracts/MixinOperatorResolver.sol:37:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts/MixinOperatorResolver.sol:56:        for (uint256 i = 0; i < requiredOperators.length; i++) { governance/scripts/OperatorScripts.sol:67:        for (uint256 i; i < operatorLength; i++) { governance/scripts/OperatorScripts.sol:80:        for (uint256 i; i < operatorLength; i++) { libraries/CurveHelpers/CurveHelpers.sol:22:        for (uint256 i; i < 2; i++) { libraries/CurveHelpers/CurveHelpers.sol:42:        for (uint256 i; i < 3; i++) { libraries/CurveHelpers/CurveHelpers.sol:62:        for (uint256 i; i < 4; i++) { libraries/CurveHelpers/CurveHelpers.sol:86:        for (uint256 i; i < poolCoinAmount; i++) { operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:27:        for (uint256 i; i < vaultsLength; i++) { operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:27:        for (uint256 i; i < vaultsLength; i++) { operators/Beefy/BeefyVaultOperator.sol:18:        for (uint256 i; i < vaultsLength; i++) { operators/Yearn/YearnCurveVaultOperator.sol:42:        for (uint256 i; i < vaultsLength; i++) { utils/NestedAssetBatcher.sol:45:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:60:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:74:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:79:                for (uint256 j; j < tokenLength; j++) { NestedFactory.sol:124:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:136:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:196:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:256:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:315:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:333:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:412:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:651:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  Consider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).  ## 8. Increments/decrements can be unchecked in for-loops  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Affected code:    ```solidity abstracts/MixinOperatorResolver.sol:37:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts/MixinOperatorResolver.sol:56:        for (uint256 i = 0; i < requiredOperators.length; i++) { governance/scripts/OperatorScripts.sol:67:        for (uint256 i; i < operatorLength; i++) { governance/scripts/OperatorScripts.sol:80:        for (uint256 i; i < operatorLength; i++) { governance/TimelockControllerEmergency.sol:84:        for (uint256 i = 0; i < proposers.length; ++i) { governance/TimelockControllerEmergency.sol:89:        for (uint256 i = 0; i < executors.length; ++i) { governance/TimelockControllerEmergency.sol:234:        for (uint256 i = 0; i < targets.length; ++i) { governance/TimelockControllerEmergency.sol:324:        for (uint256 i = 0; i < targets.length; ++i) { libraries/CurveHelpers/CurveHelpers.sol:22:        for (uint256 i; i < 2; i++) { libraries/CurveHelpers/CurveHelpers.sol:42:        for (uint256 i; i < 3; i++) { libraries/CurveHelpers/CurveHelpers.sol:62:        for (uint256 i; i < 4; i++) { libraries/CurveHelpers/CurveHelpers.sol:86:        for (uint256 i; i < poolCoinAmount; i++) { operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:27:        for (uint256 i; i < vaultsLength; i++) { operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:27:        for (uint256 i; i < vaultsLength; i++) { operators/Beefy/BeefyVaultOperator.sol:18:        for (uint256 i; i < vaultsLength; i++) { operators/Yearn/YearnCurveVaultOperator.sol:42:        for (uint256 i; i < vaultsLength; i++) { utils/NestedAssetBatcher.sol:45:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:60:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:74:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:79:                for (uint256 j; j < tokenLength; j++) { NestedFactory.sol:124:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:136:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:196:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:256:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:315:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:333:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:412:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:651:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  The change would be:      ```diff - for (uint256 i; i < numIterations; i++) { + for (uint256 i; i < numIterations;) {  // ...   +   unchecked { ++i; } }   ```  The same can be applied with decrements (which should use `break` when `i == 0`).  The risk of overflow is non-existant for `uint256` here.  ## 9. It costs more gas to initialize variables with their default value than letting the default value be applied  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Affected code:  ```solidity abstracts/MixinOperatorResolver.sol:37:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts/MixinOperatorResolver.sol:56:        for (uint256 i = 0; i < requiredOperators.length; i++) { governance/TimelockControllerEmergency.sol:84:        for (uint256 i = 0; i < proposers.length; ++i) { governance/TimelockControllerEmergency.sol:89:        for (uint256 i = 0; i < executors.length; ++i) { governance/TimelockControllerEmergency.sol:234:        for (uint256 i = 0; i < targets.length; ++i) { governance/TimelockControllerEmergency.sol:324:        for (uint256 i = 0; i < targets.length; ++i) { NestedFactory.sol:124:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:136:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:196:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:256:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:315:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:333:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:412:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:651:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  I suggest removing explicit initializations for default values.  ## 10. Use Custom Errors instead of Revert Strings to save Gas  Solidity 0.8.4 introduced custom errors. They are more gas efficient than revert strings, when it comes to deploy cost as well as runtime cost when the revert condition is met. Use custom errors instead of revert strings for gas savings.  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Consider replacing all revert strings with custom errors in the solution.  ```solidity abstracts/MixinOperatorResolver.sol:23:        require(_resolver != address(0), "MOR: INVALID_ADDRESS"); abstracts/MixinOperatorResolver.sol:77:        require(_foundAddress.implementation != address(0), string(abi.encodePacked("MOR: MISSING_OPERATOR: ", name))); abstracts/MixinOperatorResolver.sol:103:            require(tokens[0] == _outputToken, "MOR: INVALID_OUTPUT_TOKEN"); abstracts/MixinOperatorResolver.sol:104:            require(tokens[1] == _inputToken, "MOR: INVALID_INPUT_TOKEN"); abstracts/OwnableProxyDelegation.sol:25:        require(ownerAddr != address(0), "OPD: INVALID_ADDRESS"); abstracts/OwnableProxyDelegation.sol:26:        require(!initialized, "OPD: INITIALIZED"); abstracts/OwnableProxyDelegation.sol:27:        require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, "OPD: FORBIDDEN"); abstracts/OwnableProxyDelegation.sol:41:        require(owner() == _msgSender(), "OPD: NOT_OWNER"); abstracts/OwnableProxyDelegation.sol:57:        require(newOwner != address(0), "OPD: INVALID_ADDRESS"); governance/scripts/OperatorScripts.sol:19:        require(_nestedFactory != address(0), "AO-SCRIPT: INVALID_FACTORY_ADDR"); governance/scripts/OperatorScripts.sol:20:        require(_resolver != address(0), "AO-SCRIPT: INVALID_RESOLVER_ADDR"); governance/scripts/OperatorScripts.sol:29:        require(operator.implementation != address(0), "AO-SCRIPT: INVALID_IMPL_ADDRESS"); governance/scripts/OperatorScripts.sol:54:        require(operatorLength != 0, "DAO-SCRIPT: INVALID_OPERATOR_LEN"); governance/scripts/OperatorScripts.sol:55:        require(bytecode.length != 0, "DAO-SCRIPT: BYTECODE_ZERO"); governance/scripts/OperatorScripts.sol:61:        require(deployedAddress != address(0), "DAO-SCRIPT: FAILED_DEPLOY"); governance/OwnerProxy.sol:17:        require(_target != address(0), "OP: INVALID_TARGET"); governance/TimelockControllerEmergency.sol:229:        require(targets.length == values.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:230:        require(targets.length == datas.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:243:        require(!isOperation(id), "TimelockController: operation already scheduled"); governance/TimelockControllerEmergency.sol:244:        require(delay >= getMinDelay(), "TimelockController: insufficient delay"); governance/TimelockControllerEmergency.sol:256:        require(isOperationPending(id), "TimelockController: operation cannot be cancelled"); governance/TimelockControllerEmergency.sol:319:        require(targets.length == values.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:320:        require(targets.length == datas.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:334:        require(isOperationReady(id), "TimelockController: operation is not ready"); governance/TimelockControllerEmergency.sol:335:        require(predecessor == bytes32(0) || isOperationDone(predecessor), "TimelockController: missing dependency"); governance/TimelockControllerEmergency.sol:342:        require(isOperationReady(id), "TimelockController: operation is not ready"); governance/TimelockControllerEmergency.sol:359:        require(success, "TimelockController: underlying transaction reverted"); governance/TimelockControllerEmergency.sol:375:        require(msg.sender == address(this), "TimelockController: caller must be timelock"); libraries/StakingLPVaultHelpers.sol:108:        require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED"); libraries/StakingLPVaultHelpers.sol:138:        require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:23:        require(vaultsLength == routers.length, "BLVO: INVALID_VAULTS_LENGTH"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:52:        require(amountToDeposit != 0, "BLVO: INVALID_AMOUNT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:54:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:64:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:65:        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:97:        require(amount != 0, "BLVO: INVALID_AMOUNT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:99:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:108:        require(vaultAmount == amount, "BLVO: INVALID_AMOUNT_WITHDRAWED"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:109:        require(tokenAmount >= minTokenAmount, "BLVO: INVALID_OUTPUT_AMOUNT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:142:        require(token0 == token || token1 == token, "BLVO: INVALID_TOKEN"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:187:        require(pair.factory() == biswapRouter.factory(), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:198:        require(isInput0 || cachedToken1 == token, "BLVO: INVALID_INPUT_TOKEN"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:271:        require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:272:        require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:23:        require(vaultsLength == routers.length, "BLVO: INVALID_VAULTS_LENGTH"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:52:        require(amountToDeposit != 0, "BLVO: INVALID_AMOUNT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:54:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:64:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:65:        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:97:        require(amount != 0, "BLVO: INVALID_AMOUNT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:99:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:108:        require(vaultAmount == amount, "BLVO: INVALID_AMOUNT_WITHDRAWED"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:109:        require(tokenAmount >= minTokenAmount, "BLVO: INVALID_OUTPUT_AMOUNT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:142:        require(token0 == token || token1 == token, "BLVO: INVALID_TOKEN"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:187:        require(pair.factory() == uniswapRouter.factory(), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:198:        require(isInput0 || cachedToken1 == token, "BLVO: INVALID_INPUT_TOKEN"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:269:        require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:270:        require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); operators/Beefy/BeefyVaultOperator.sol:15:        require(vaultsLength == tokens.length, "BVO: INVALID_VAULTS_LENGTH"); operators/Beefy/BeefyVaultOperator.sol:41:        require(amount != 0, "BVO: INVALID_AMOUNT"); operators/Beefy/BeefyVaultOperator.sol:43:        require(address(token) != address(0), "BVO: INVALID_VAULT"); operators/Beefy/BeefyVaultOperator.sol:50:        require(success, "BVO: DEPOSIT_CALL_FAILED"); operators/Beefy/BeefyVaultOperator.sol:54:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BVO: INVALID_AMOUNT_RECEIVED"); operators/Beefy/BeefyVaultOperator.sol:55:        require(amount == tokenAmount, "BVO: INVALID_AMOUNT_DEPOSITED"); operators/Beefy/BeefyVaultOperator.sol:83:        require(amount != 0, "BVO: INVALID_AMOUNT"); operators/Beefy/BeefyVaultOperator.sol:85:        require(address(token) != address(0), "BVO: INVALID_VAULT"); operators/Beefy/BeefyVaultOperator.sol:91:        require(success, "BVO: WITHDRAW_CALL_FAILED"); operators/Beefy/BeefyVaultOperator.sol:95:        require(vaultAmount == amount, "BVO: INVALID_AMOUNT_WITHDRAWED"); operators/Beefy/BeefyVaultOperator.sol:96:        require(tokenAmount != 0, "BVO: INVALID_AMOUNT"); operators/Beefy/BeefyVaultStorage.sol:25:        require(vault != address(0), "BVS: INVALID_VAULT_ADDRESS"); operators/Beefy/BeefyVaultStorage.sol:26:        require(tokenOrZapper != address(0), "BVS: INVALID_UNDERLYING_ADDRESS"); operators/Beefy/BeefyVaultStorage.sol:27:        require(vaults[vault] == address(0), "BVS: ALREADY_EXISTENT_VAULT"); operators/Beefy/BeefyVaultStorage.sol:35:        require(vaults[vault] != address(0), "BVS: NON_EXISTENT_VAULT"); operators/Paraswap/ParaswapOperator.sol:16:        require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS"); operators/Paraswap/ParaswapOperator.sol:27:        require(sellToken != buyToken, "PSO: SAME_INPUT_OUTPUT"); operators/Paraswap/ParaswapOperator.sol:35:        require(success, "PSO: SWAP_FAILED"); operators/Paraswap/ParaswapOperator.sol:39:        require(amountBought != 0, "PSO: INVALID_AMOUNT_BOUGHT"); operators/Paraswap/ParaswapOperator.sol:40:        require(amountSold != 0, "PSO: INVALID_AMOUNT_SOLD"); operators/Yearn/YearnCurveVaultOperator.sol:39:        require(vaultsLength == pools.length, "YCVO: INVALID_VAULTS_LENGTH"); operators/Yearn/YearnCurveVaultOperator.sol:70:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:73:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:121:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:123:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:164:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:167:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:212:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:215:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:260:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:263:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnVaultStorage.sol:30:        require(vault != address(0), "YVS: INVALID_VAULT_ADDRESS"); operators/Yearn/YearnVaultStorage.sol:31:        require(curvePool.poolAddress != address(0), "YVS: INVALID_POOL_ADDRESS"); operators/Yearn/YearnVaultStorage.sol:32:        require(curvePool.lpToken != address(0), "YVS: INVALID_TOKEN_ADDRESS"); operators/Yearn/YearnVaultStorage.sol:33:        require(vaults[vault].poolAddress == address(0), "YVS: VAULT_ALREADY_HAS_POOL"); operators/Yearn/YearnVaultStorage.sol:34:        require(vaults[vault].lpToken == address(0), "YVS: VAULT_ALREADY_HAS_LP"); operators/Yearn/YearnVaultStorage.sol:42:        require(vaults[vault].poolAddress != address(0), "YVS: NON_EXISTENT_VAULT"); utils/NestedAssetBatcher.sol:94:            require(nestedAsset.lastOwnerBeforeBurn(_nftId) != address(0), "NAB: NEVER_CREATED"); NestedFactory.sol:66:        require( NestedFactory.sol:99:        require(nestedAsset.ownerOf(_nftId) == _msgSender(), "NF: CALLER_NOT_OWNER"); NestedFactory.sol:107:        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), "NF: LOCKED_NFT"); NestedFactory.sol:122:        require(operator != bytes32(""), "NF: INVALID_OPERATOR_NAME"); NestedFactory.sol:125:            require(operatorsCache[i] != operator, "NF: EXISTENT_OPERATOR"); NestedFactory.sol:153:        require(address(_feeSplitter) != address(0), "NF: INVALID_FEE_SPLITTER_ADDRESS"); NestedFactory.sol:160:        require(_entryFees != 0, "NF: ZERO_FEES"); NestedFactory.sol:161:        require(_entryFees <= 10000, "NF: FEES_OVERFLOW"); NestedFactory.sol:168:        require(_exitFees != 0, "NF: ZERO_FEES"); NestedFactory.sol:169:        require(_exitFees <= 10000, "NF: FEES_OVERFLOW"); NestedFactory.sol:191:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:250:        require(_orders.length != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:251:        require(tokensLength == _orders.length, "NF: INPUTS_LENGTH_MUST_MATCH"); NestedFactory.sol:252:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:286:        require(assetTokensLength > _tokenIndex, "NF: INVALID_TOKEN_INDEX"); NestedFactory.sol:288:        require(assetTokensLength > 1, "NF: UNALLOWED_EMPTY_PORTFOLIO"); NestedFactory.sol:289:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:312:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:313:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:330:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:331:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:359:        require(batchLength != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:379:        require(amountSpent <= _inputTokenAmount - feesAmount, "NF: OVERSPENT"); NestedFactory.sol:406:        require(batchLength != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:407:        require(_batchedOrders.amounts.length == batchLength, "NF: INPUTS_LENGTH_MUST_MATCH"); NestedFactory.sol:428:            require(amountSpent <= _inputTokenAmount, "NF: OVERSPENT"); NestedFactory.sol:469:        require(success, "NF: OPERATOR_CALL_FAILED"); NestedFactory.sol:495:            require(amounts[1] <= _amountToSpend, "NF: OVERSPENT"); NestedFactory.sol:543:            require(!_fromReserve, "NF: NO_ETH_FROM_RESERVE"); NestedFactory.sol:544:            require(address(this).balance >= _inputTokenAmount, "NF: INVALID_AMOUNT_IN"); NestedFactory.sol:551:            require( NestedFactory.sol:612:            require(success, "NF: ETH_TRANSFER_ERROR"); NestedFactory.sol:656:        require(msg.value == ethNeeded, "NF: WRONG_MSG_VALUE"); OperatorResolver.sol:27:        require(_foundOperator.implementation != address(0), reason); OperatorResolver.sol:39:        require(namesLength == destinations.length, "OR: INPUTS_LENGTH_MUST_MATCH"); OperatorResolver.sol:57:        require(names.length == operatorsToImport.length, "OR: INPUTS_LENGTH_MUST_MATCH"); Withdrawer.sol:21:        require(msg.sender == address(weth), "WD: ETH_SENDER_NOT_WETH"); ```  ## 11. Functions guaranteed to revert when called by normal users can be marked `payable`  If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.  ```solidity operators/Beefy/BeefyVaultStorage.sol:24:    function addVault(address vault, address tokenOrZapper) external onlyOwner { operators/Beefy/BeefyVaultStorage.sol:34:    function removeVault(address vault) external onlyOwner { operators/Yearn/YearnVaultStorage.sol:29:    function addVault(address vault, CurvePool calldata curvePool) external onlyOwner { operators/Yearn/YearnVaultStorage.sol:41:    function removeVault(address vault) external onlyOwner { NestedFactory.sol:121:    function addOperator(bytes32 operator) external override onlyOwner { NestedFactory.sol:133:    function removeOperator(bytes32 operator) external override onlyOwner { NestedFactory.sol:152:    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner { NestedFactory.sol:159:    function setEntryFees(uint256 _entryFees) external override onlyOwner { NestedFactory.sol:167:    function setExitFees(uint256 _exitFees) external override onlyOwner { NestedFactory.sol:175:    function unlockTokens(IERC20 _token) external override onlyOwner { OperatorResolver.sol:56:    ) external override onlyOwner { OperatorResolver.sol:74:    function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner { ``` 
**Overview** Risk Rating | Number of issues --- | --- Low Risk | 6 Non-Critical Risk | 4  **Table of Contents**  - [Low Risk Issues](#low-risk-issues)   - [1. Known vulnerabilities exist in currently used `@openzeppelin/contracts` version](#1-known-vulnerabilities-exist-in-currently-used-openzeppelincontracts-version)   - [2. Missing address(0) checks](#2-missing-address0-checks)   - [3. `OwnableProxyDelegation.initialize()` is front-runnable in the solution](#3-ownableproxydelegationinitialize-is-front-runnable-in-the-solution)   - [4. Use a `constant` instead of duplicating the same string](#4-use-a-constant-instead-of-duplicating-the-same-string)   - [5. Funds can be locked](#5-funds-can-be-locked)   - [6. A magic number should be documented and explained. Use a `constant` instead](#6-a-magic-number-should-be-documented-and-explained-use-a-constant-instead) - [Non-Critical Issues](#non-critical-issues)   - [1. It's better to emit after all processing is done](#1-its-better-to-emit-after-all-processing-is-done)   - [2. Typos](#2-typos)   - [3. Adding a `return` statement when the function defines a named return variable, is redundant](#3-adding-a-return-statement-when-the-function-defines-a-named-return-variable-is-redundant)   - [4. `public` functions not called by the contract should be declared `external` instead](#4-public-functions-not-called-by-the-contract-should-be-declared-external-instead)  # Low Risk Issues  ## 1. Known vulnerabilities exist in currently used `@openzeppelin/contracts` version  As some [known vulnerabilities](https://snyk.io/test/npm/@openzeppelin/contracts/4.3.2) exist in the current `@openzeppelin/contracts` version, consider updating `package.json` with at least `@openzeppelin/contracts@4.4.2` here:  <https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/package.json#L65>  ```json         "@openzeppelin/contracts": "^4.3.2", ```  While vulnerabilities are known, the current scope isn't affected (this might not hold true for the whole solution)  ## 2. Missing address(0) checks  Consider adding an `address(0)` check for immutable variables:  ```solidity operators/Yearn/YearnCurveVaultOperator.sol:23:    address public immutable eth; operators/Yearn/YearnCurveVaultOperator.sol:26:    IWETH private immutable weth; operators/Yearn/YearnCurveVaultOperator.sol:29:    Withdrawer private immutable withdrawer; utils/NestedAssetBatcher.sol:19:    INestedAsset public immutable nestedAsset; utils/NestedAssetBatcher.sol:20:    INestedRecords public immutable nestedRecords; Withdrawer.sol:14:    IWETH public immutable weth; ```  ## 3. `OwnableProxyDelegation.initialize()` is front-runnable in the solution  I suggest adding some access control or atomically initializing the contract:  <https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L24-L32>  ```solidity File: OwnableProxyDelegation.sol 24:     function initialize(address ownerAddr) external { 25:         require(ownerAddr != address(0), "OPD: INVALID_ADDRESS"); 26:         require(!initialized, "OPD: INITIALIZED"); 27:         require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, "OPD: FORBIDDEN"); 28:  29:         _setOwner(ownerAddr); 30:  31:         initialized = true; 32:     } ```  ## 4. Use a `constant` instead of duplicating the same string  ```solidity abstracts/OwnableProxyDelegation.sol:25:        require(ownerAddr != address(0), "OPD: INVALID_ADDRESS"); abstracts/OwnableProxyDelegation.sol:57:        require(newOwner != address(0), "OPD: INVALID_ADDRESS"); ```  ```solidity governance/TimelockControllerEmergency.sol:229:        require(targets.length == values.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:230:        require(targets.length == datas.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:319:        require(targets.length == values.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:320:        require(targets.length == datas.length, "TimelockController: length mismatch"); ```  ```solidity governance/TimelockControllerEmergency.sol:334:        require(isOperationReady(id), "TimelockController: operation is not ready"); governance/TimelockControllerEmergency.sol:342:        require(isOperationReady(id), "TimelockController: operation is not ready"); ```  ```solidity libraries/CurveHelpers/CurveHelpers.sol:28:        revert("CH: INVALID_INPUT_TOKEN"); libraries/CurveHelpers/CurveHelpers.sol:48:        revert("CH: INVALID_INPUT_TOKEN"); libraries/CurveHelpers/CurveHelpers.sol:68:        revert("CH: INVALID_INPUT_TOKEN"); ```  ```solidity libraries/StakingLPVaultHelpers.sol:108:        require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED"); libraries/StakingLPVaultHelpers.sol:138:        require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED"); ```  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:52:        require(amountToDeposit != 0, "BLVO: INVALID_AMOUNT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:97:        require(amount != 0, "BLVO: INVALID_AMOUNT"); ```  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:54:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:99:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:187:        require(pair.factory() == biswapRouter.factory(), "BLVO: INVALID_VAULT"); ```  ```solidity operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:97:        require(amount != 0, "BLVO: INVALID_AMOUNT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:52:        require(amountToDeposit != 0, "BLVO: INVALID_AMOUNT"); ```  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:271:        require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:272:        require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); ```  ```solidity operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:54:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:99:        require(router != address(0), "BLVO: INVALID_VAULT"); ```  ```solidity operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:269:        require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:270:        require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); ```  ```solidity operators/Beefy/BeefyVaultOperator.sol:41:        require(amount != 0, "BVO: INVALID_AMOUNT"); operators/Beefy/BeefyVaultOperator.sol:83:        require(amount != 0, "BVO: INVALID_AMOUNT"); operators/Beefy/BeefyVaultOperator.sol:96:        require(tokenAmount != 0, "BVO: INVALID_AMOUNT"); ```  ```solidity operators/Beefy/BeefyVaultOperator.sol:43:        require(address(token) != address(0), "BVO: INVALID_VAULT"); operators/Beefy/BeefyVaultOperator.sol:85:        require(address(token) != address(0), "BVO: INVALID_VAULT"); ```  ```solidity operators/Yearn/YearnCurveVaultOperator.sol:70:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:121:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:164:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:212:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:260:        require(amount != 0, "YCVO: INVALID_AMOUNT"); ```  ```solidity operators/Yearn/YearnCurveVaultOperator.sol:73:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:123:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:167:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:215:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:263:        require(pool != address(0), "YCVO: INVALID_VAULT"); ```  ```solidity NestedFactory.sol:160:        require(_entryFees != 0, "NF: ZERO_FEES"); NestedFactory.sol:168:        require(_exitFees != 0, "NF: ZERO_FEES"); ```  ```solidity NestedFactory.sol:161:        require(_entryFees <= 10000, "NF: FEES_OVERFLOW"); NestedFactory.sol:169:        require(_exitFees <= 10000, "NF: FEES_OVERFLOW"); ```  ```solidity NestedFactory.sol:191:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:312:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:330:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); ```  ```solidity NestedFactory.sol:250:        require(_orders.length != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:359:        require(batchLength != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:406:        require(batchLength != 0, "NF: INVALID_ORDERS"); ```  ```solidity NestedFactory.sol:251:        require(tokensLength == _orders.length, "NF: INPUTS_LENGTH_MUST_MATCH"); NestedFactory.sol:407:        require(_batchedOrders.amounts.length == batchLength, "NF: INPUTS_LENGTH_MUST_MATCH"); ```  ```solidity NestedFactory.sol:252:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:289:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:313:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:331:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); ```  ```solidity NestedFactory.sol:379:        require(amountSpent <= _inputTokenAmount - feesAmount, "NF: OVERSPENT"); NestedFactory.sol:428:            require(amountSpent <= _inputTokenAmount, "NF: OVERSPENT"); NestedFactory.sol:495:            require(amounts[1] <= _amountToSpend, "NF: OVERSPENT"); ```  ```solidity OperatorResolver.sol:39:        require(namesLength == destinations.length, "OR: INPUTS_LENGTH_MUST_MATCH"); OperatorResolver.sol:57:        require(names.length == operatorsToImport.length, "OR: INPUTS_LENGTH_MUST_MATCH"); ```  ## 5. Funds can be locked  There isn't a withdraw mechanism and several payable methods are implemented:  - BeefyZapBiswapLPVaultOperator.sol:  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:51:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { ```  - YearnCurveVaultOperator.sol:  ```solidity operators/Yearn/YearnCurveVaultOperator.sol:69:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { operators/Yearn/YearnCurveVaultOperator.sol:120:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { operators/Yearn/YearnCurveVaultOperator.sol:163:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { operators/Yearn/YearnCurveVaultOperator.sol:211:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { operators/Yearn/YearnCurveVaultOperator.sol:259:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { ```  ## 6. A magic number should be documented and explained. Use a `constant` instead  *Similar issue in the past: [here](https://github.com/code-423n4/2021-04-marginswap-findings/issues/71)*  - 1:  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:240:            1, operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:251:            1, operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:252:            1, operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:240:            1, operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:251:            1, operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:252:            1, ```  - 10000:  ```solidity NestedFactory.sol:378:        feesAmount = (amountSpent * entryFees) / 10000; // Entry Fees NestedFactory.sol:443:            feesAmount = (amountBought * (_toReserve ? entryFees : exitFees)) / 10000; ```  I suggest using `constant` variables as this would make the code more maintainable and readable while costing nothing gas-wise (constants are replaced by their value at compile-time).  # Non-Critical Issues  ## 1. It's better to emit after all processing is done  - <https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L374-L378> :  ```solidity contracts/governance/TimelockControllerEmergency.sol:   374      function updateDelay(uint256 newDelay) external virtual {   375          require(msg.sender == address(this), "TimelockController: caller must be timelock");   376:         emit MinDelayChange(_minDelay, newDelay);   377          _minDelay = newDelay;   378      } ```  ## 2. Typos  - datas vs data  ```solidity abstracts/MixinOperatorResolver.sol:81:    /// @dev Build the calldata (with safe datas) and call the Operator ```  - setted vs set  ```solidity - abstracts/OwnableProxyDelegation.sol:17:    /// @dev True if the owner is setted + abstracts/OwnableProxyDelegation.sol:17:    /// @dev True if the owner is set ```  - liquitiy vs liquidity  ```solidity libraries/StakingLPVaultHelpers.sol:21:    /// @param pool The Curve pool to add liquitiy in libraries/StakingLPVaultHelpers.sol:52:    /// @param pool The Curve pool to add liquitiy in libraries/StakingLPVaultHelpers.sol:85:    /// @param pool The Curve pool to remove liquitiy from libraries/StakingLPVaultHelpers.sol:115:    /// @param pool The Curve pool to remove liquitiy from ```  - WITHDRAWED vs WITHDREW or WITHDRAWN  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:108:        require(vaultAmount == amount, "BLVO: INVALID_AMOUNT_WITHDRAWED"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:108:        require(vaultAmount == amount, "BLVO: INVALID_AMOUNT_WITHDRAWED"); operators/Beefy/BeefyVaultOperator.sol:95:        require(vaultAmount == amount, "BVO: INVALID_AMOUNT_WITHDRAWED"); NestedFactory.sol:51:    /// @dev Fees when funds are withdrawed NestedFactory.sol:639:    /// @return The withdrawed amount from the reserve ```  - dont vs don't  ```solidity NestedFactory.sol:477:    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail. ```  - transfered vs transferred  ```solidity NestedFactory.sol:534:    /// @return Token transfered (in case of ETH) ```  ## 3. Adding a `return` statement when the function defines a named return variable, is redundant  While not consuming more gas with the Optimizer enabled: using both named returns and a return statement isn't necessary. Removing one of those can improve code clarity.  Affected code:  ```solidity contracts/governance/TimelockControllerEmergency.sol:   119:     function isOperation(bytes32 id) public view virtual returns (bool pending) {   126:     function isOperationPending(bytes32 id) public view virtual returns (bool pending) {   133:     function isOperationReady(bytes32 id) public view virtual returns (bool ready) {   141:     function isOperationDone(bytes32 id) public view virtual returns (bool done) {   149:     function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {   158:     function getMinDelay() public view virtual returns (uint256 duration) {  contracts/libraries/CurveHelpers/CurveHelpers.sol:   21:     ) internal view returns (uint256[2] memory amounts) {   41:     ) internal view returns (uint256[3] memory amounts) {   61:     ) internal view returns (uint256[4] memory amounts) {   85:     ) internal returns (bool success) { ```  ## 4. `public` functions not called by the contract should be declared `external` instead  ```solidity governance/OwnerProxy.sol:16:    function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) { ``` 
#1 Use require instead &&  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L66  use require instead of && for efficient gas cost. change it from                require(             address(_nestedAsset) != address(0) &&                 address(_nestedRecords) != address(0) &&                 address(_reserve) != address(0) &&                 address(_feeSplitter) != address(0) &&                 address(_weth) != address(0) &&                 _operatorResolver != address(0) &&                 address(_withdrawer) != address(0),             "NF: INVALID_ADDRESS"         );  to                require(address(_nestedAsset) != address(0),"NF: INVALID_ADDRESS");               require(address(_nestedRecords) != address(0),"NF: INVALID_ADDRESS");               require(address(_reserve) != address(0),"NF: INVALID_ADDRESS");               require(address(_feeSplitter) != address(0),"NF: INVALID_ADDRESS");               require(address(_weth) != address(0),"NF: INVALID_ADDRESS");               require( _operatorResolver != address(0),"NF: INVALID_ADDRESS");               require(address(_withdrawer) != address(0),"NF: INVALID_ADDRESS");  #2 Change to storage  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L123  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L248  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L466  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L52  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L101  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L33  Use storage instead of  memory to reduce the gas fee.                bytes32[] memory operatorsCache = operators;  to                bytes32[] storage operatorsCache = operators;  apply to others.   #3 Looping  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L651  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L56  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L234  default uint is 0 so remove unnecassary explicit can reduce gas. caching the array length can reduce gas it caused access to a local variable is more cheap than query storage / calldata / memory in solidity. pre increment ++i more cheaper gas than post increment i++. i suggest to use pre increment.  #4 Default value and increment  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L136  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L196  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L315  default uint is 0 so remove unnecassary explicit can reduce gas pre increment ++i more cheaper gas than post increment i++. i suggest to use pre increment.  #5 Inequality  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L286  non strict inequality are cheaper than strict one. i suggest to use >= or <= instead of > and < if possible.  #6 Caching names.length  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L57  caching the names.length can reduce gas it caused access to a local variable is more cheap than query storage / calldata / memory in solidity and it use twice.  #7 Cache the cacheTmp.implementation  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L62-L64  cache the cacheTmp.implementation to the memory for reduce the gas fee because it use multiple times.  #8 Use calldata  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L93  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L13  In the external functions where the function argument is read-only, the function() has an inputed parameter that using memory, if this function didnt change the parameter, its cheaper to use calldata then memory. so we suggest to change it.  #9 Division  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275  A division by 2 can be calculated by shifting one to the right. The div opcode used 5 gas and  SHR opcode used 3 gas. Solidity's division operation also includes a division-by-0 prevention by pass using shifting. so i suggest to use >>1.  #10 Sort struct  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L6-L9  shorting the struct can reduce gas cost, so change it from      struct CurvePool {     address poolAddress;     uint96 poolCoinAmount;     address lpToken; to      struct CurvePool {     uint96 poolCoinAmount;     address poolAddress;     address lpToken;  #11 Short the string  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L243-L244  reduce size of string error message to bytes32 for cheap gas if possible.  #12 Caching the targets.length  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L319-L320  caching the targets.length can reduce gas it caused access to a local variable is more cheap than query storage / calldata / memory in solidity and it use twice.          require(targets.length == values.length, "TimelockController: length mismatch");         require(targets.length == datas.length, "TimelockController: length mismatch");  i suggest to add uint256 _targets = targets.length;               uint256 _targets = targets.length;         require(_targets == values.length, "TimelockController: length mismatch");         require(_targets == datas.length, "TimelockController: length mismatch"); 
 ## Impact  By default, function types and state variables/constants are internal, so the internal keyword can be omitted.  Affected code: 1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L20 2. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L15 3. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L29  ## Proof of Concept      ## Tools Used      ## Recommended Mitigation Steps  --- ## Impact  Consider using IERC20 type instead of address. Or IERC20[] type instead of address[].  Affected code: 1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L248 2. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L257 3. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L291 4. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L371 5. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L422 6. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L423 7. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L460 8. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L461 9. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L487 10. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L488 11. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L587 12. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L640 13. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L91 14. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L92 15. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L101 16. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L19 17. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L39 18. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L59 19. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L82 20. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L62 21. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L95 22. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L125 23. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L24 24. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L133 25. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L140 26. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L141 27. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L153 28. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L181 29. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L191 30. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L192 31. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L133 32. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L140 33. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L141 34. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L153 35. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L181 36. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L191 37. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L192 38. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L11 39. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L117 40. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L226 41. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L274 42. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L9  ## Proof of Concept      ## Tools Used      ## Recommended Mitigation Steps  --- ## Impact  Consider using "_" separate digit capacity i.e "100000" could be replaced to "100_000". This increases code readability.  Affected code: 1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L264 2. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L378 3. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443 4. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L629  ## Proof of Concept      ## Tools Used      ## Recommended Mitigation Steps  ---
## NestedFactory.sol  ### transferToReserveAndStore: balanceReserveAfter can be inlined  In the `_transferToReserveAndStore` function, we store the reserve balance after the transfer in the `balanceReserveAfter` variable, on line [523](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/NestedFactory.sol#L523).  This variable being only used once, we can inline it and save one mstore.  Recommendation:  ``` nestedRecords.store(_nftId, address(_token), _token.balanceOf(reserveAddr) - balanceReserveBefore, reserveAddr); ```  ## TimelockControllerEmergency.sol  ### scheduleBatch: targets.length should be stored in a variable  In the `scheduleBatch` function on line [221](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/governance/TimelockControllerEmergency.sol#L221), we call `targets.length` to compare the targets length and also to loop through the targets and emit the `CallScheduled` event.  For a better code legibility and also to save some mload, targets length should be stored in a variable.  Recommendation:  ``` uint256 _targetsLength = targets.length;  require(targetsLength == values.length, "TimelockController: length mismatch"); require(targetsLength == datas.length, "TimelockController: length mismatch");  bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt); schedule(id, delay); for (uint256 i = 0; i < targetsLength; ++i) {   emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay); } ```  ### executeBatch: targets.length should be stored in a variable  In the `executeBatch` function on line [312](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/governance/TimelockControllerEmergency.sol#L312), we call `targets.length` to compare the targets length and also to loop through the targets and call the `_call` function.  For a better code legibility and also to save some mload, targets length should be stored in a variable.  Recommendation:  ``` uint256 _targetsLength = targets.length;  require(_targetsLength == values.length, "TimelockController: length mismatch"); require(_targetsLength == datas.length, "TimelockController: length mismatch");  bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt); _beforeCall(id, predecessor); for (uint256 i = 0; i < _targetsLength; ++i) {     _call(id, i, targets[i], values[i], datas[i]); } _afterCall(id); ``` 
Typos  The same typo (`withdrawed`) occurs in all five lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L51  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L639  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L95  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L108  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L108  Example:  ```solidity     /// @dev Fees when funds are withdrawed ``` Change `withdrawed` to `withdrawn` in all cases   https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L534 ```solidity     /// @return Token transfered (in case of ETH) ``` Change `transfered` to `transferred`   https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L17 ```solidity     /// @dev True if the owner is setted ``` Change `setted` to `set`   The same typo (`liquitiy`) occurs in all four lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L21  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L52  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L85  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L115  Example:  ```solidity     /// @param pool The Curve pool to add liquitiy in ``` Change `liquitiy` to `liquidity` in each case   The same typo (`orders`) occurs in both lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L346  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L393  ```solidity     /// @dev For every orders, call the operator with the calldata ``` Change `orders` to `order` in both cases   The same typo (`store`) occurs in both lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L397  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L457  ```solidity     /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not. ``` Change `store` to `stored` in both cases   https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L477 ```solidity     /// @dev Call the operator to submit the order but dont stop if the call to the operator fail. ``` Change `fail` to `fails`    https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L8 ```solidity /// @notice Resolve the operators address ``` For clarity, either replace `the operators` with `operator` or else use the actual variable name   https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/ExchangeHelpers.sol#L26 ```solidity     /// @dev sets the allowance for a token to the maximum if it is not already at max ``` For clarity and consistency, capitalize `sets`   The same typo (`token`) occurs in all six lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L83  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L124  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L128  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L83  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L124  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L128  Example:  ```solidity     /// @param token One of the paired token ``` Change `token` to `tokens` in each case   The same typo (`needs`) occurs in both lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L144  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L144  ```solidity         // LP Tokens needs to be sent back to the pair address to be burned ``` Change `needs` to `need` in both cases   The same typo (`allows to add`) occurs in both lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L260  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L260  ```solidity     ///         This allows to add as many tokensA and tokensB as possible ``` Change `allows to add` to `allows us to add` in both cases
# 1 . unused imports  ( its already imported) Ierc20 is already imported in  Inestedfactory.sol Feespliter.sol is already imported Inestedfactory.sol NestedReverse.sol is already imprted Insteadfactory.sol [NestedFactory:6]( https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L6) [NestedFactory:12]( https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L12) safeerc20 imports Ierc20 so you can take out Ierc20 when you import safeerc20.sol [NestedFactory:13]( https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L13) IOperatorResolver.sol is already imported in MixinOperatorResolver.sol take out IOperatorResolver.sol from OperatorResolver.sol [OperatorResolver:4](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L4) https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L10 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L10 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Paraswap/ParaswapOperator.sol#L6 safeerc20.sol is already in exchangehelper.sol https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L10   # 2. Change your imports  ex: import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; instead do your imports like this  import {Ierc20,safeer20} from "import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/NestedFactory.sol#L5 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L10  # 3. no check that address can be zero in array of address  no check that token of i can be zero   address token = tokens[i]; instances:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L257 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/BeefyVaultOperator.sol#L18 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L28   # 4. make  success variable in call function a check in a require statement . instead of a if statment where if success is  false it will just skip execution not revert.  make         if (success)  into:  require(success)   to make sure the call dosnt fail   https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/NestedFactory.sol#L518     # 5. initialize function should have onlyowner modifer anyone can front run the initialize call and become owner. If the initializer is not executed in the same transaction as the constructor, a malicious user can front-run the initialize() call, forcing the contract to be redeployed ex: function initialize(address ownerAddr) external { https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/abstracts/OwnableProxyDelegation.sol#L24  # 6. no check on success variable , if the call function fails bool success  variable should be  checked  with a require statement  if not logic can brake and cause loss of funds https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/libraries/ExchangeHelpers.sol#L22  # 7.typos  instead of : liquitiy  use : liquidity  https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L52  https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L85  https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L115  # 8. Event is missing indexed fields  each event should use three indexed fields if there are there or more fields https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/governance/TimelockControllerEmergency.sol#L50 
## _minDelay can be 0, beating timelock motive  Contract: https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L93  Issue: In constructor, deployer can set _minDelay to 0 which means any proposed transaction can instantly be executed without any delay which beats the basic motive of timelock  Recommendation: Add a check to ensure correct value of _minDelay  ``` require(_minDelay!=0, "Incorrect delay"); ```  ## Missing selector check on operator  Contract: https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/scripts/OperatorScripts.sol#L28 https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L20  Issue: The addOperator function is not checking that selector of added operator is not bytes4(0) Same fix is required for requireAndGetOperator function at OperatorResolver.sol#L20  Recommendation: Add below check  ``` require(operator.selector != bytes4(0), "AO-SCRIPT: INVALID_SELECTOR"); ```  ## Unused imports  Contract: https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L12  Issue: Contract is importing CurveHelpers but not using it  Recommendation: Do not import CurveHelpers.sol in YearnCurveVaultOperator
# [G-01] Redundant zero initialization  Solidity does not recognize null as a value, so uint variables are initialized to zero. Setting a uint variable to zero is redundant and can waste gas.  There were many places where an int is initialized to zero https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L89 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L234 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L324 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L124 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L136 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L196 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L256 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L315 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L333 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L369 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L412 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L651 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L123 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L147 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L164 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L259 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L278 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L316 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L71 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L203 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L40 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L60 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L75  ## Recommended Mitigation Steps  Remove the redundant zero initialization `uint256 i;` instead of `uint256 i = 0;`  # [G-02] Split up require statements instead of &&  Combining require statement conditions with && logic uses unnecessary gas. It is better to split up each part of the logical statement into a separate require statements  One example is ``` require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS"); ```  This can be improved to ``` require(_tokenTransferProxy != address(0)); require(_augustusSwapper != address(0), "PSO: INVALID_ADDRESS"); ```  Several places had require statements with many logical "and"s. Instead, split into two to save gas https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L65 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L65 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L54 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L52 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L67 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L68 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L69 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L70 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L71 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L72  ## Recommended Mitigation Steps  Use separate require statements instead of concatenating with &&  # [G-03] Cache array length before loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop. This saves gas.  This was found in many places https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L89 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L234 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L324 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L124 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L651 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L147 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L164 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L259 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L278 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L316 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L60 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L75  ## Recommended Mitigation Steps  Cache the array length before the for loop  # [G-04] Use != 0 instead of > 0  Using `> 0` uses slightly more gas than using `!= 0`. Use `!= 0` when comparing uint variables to zero, which cannot hold values below zero  Locations where this was found include https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L120  ## Recommended Mitigation Steps  Replace `> 0` with `!= 0` to save gas  # [G-05] Short require strings save gas  Strings in solidity are handled in 32 byte chunks. A require string longer than 32 bytes uses more gas. Shortening these strings will save gas.  Locations where this was found include https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L229 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L230 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L243 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L244 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L256 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L319 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L320 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L334 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L335 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L342 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L359 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L375  ## Recommended Mitigation Steps  Shorten all require strings to less than 32 characters  # [G-06] Use prefix not postfix in loops  Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements.  There are many examples of this in for loops https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L18 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L67 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L80 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L89 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L234 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L324 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L124  ## Recommended Mitigation Steps  Use prefix not postfix to increment in a loop  # [G-07] For loop incrementing can be unsafe  For loops that use i++ do not need to use safemath for this operation because the loop would run out of gas long before this point. Making this addition operation unsafe using unchecked saves gas.  Sample code to make the for loop increment unsafe ``` for (uint i = 0; i < length; i = unchecked_inc(i)) {     // do something that doesn't change the value of i }  function unchecked_inc(uint i) returns (uint) {     unchecked {         return i + 1;     } } ```  Idea borrowed from https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked  There are many for loops and that can use this change https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L18 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L67 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L80 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L89 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L234 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L324 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L124  ## Recommended Mitigation Steps  Make the increment in for loops unsafe to save gas  # [G-08] Use iszero assembly for zero checks  Comparing a value to zero can be done using the `iszero` EVM opcode. This can save gas  Source from t11s https://twitter.com/transmissions11/status/1474465495243898885  There are many places where a value is compared to zero https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L92 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L219 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L70  ## Recommended Mitigation Steps  Use the assembly `iszero` evm opcode to compare values to zero  # [G-09] Add payable to functions that won't receive ETH  Identifying a function as payable saves gas. Functions that have a modifier like onlyOwner cannot be called by normal users and will not mistakenly receive ETH. These functions can be payable to save gas.  There are many functions that have the onlyOwner modifier in the contracts. Some examples are https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L29 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L41 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultStorage.sol#L24 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultStorage.sol#L34 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/OwnerProxy.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableFactoryHandler.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableFactoryHandler.sol#L35 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableProxyDelegation.sol#L50 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableProxyDelegation.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L116 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L122 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L129 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L136 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L61 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L69 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L77 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L91 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L121 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L133 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L152 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L159 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L167 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L175 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L106 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L116 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L131 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L52 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L74 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/mocks/TokenTransferProxy.sol#L40  ## Recommended Mitigation Steps  Add payable to these functions for gas savings  # [G-10] Add payable to constructors that won't receive ETH  Identifying a constructor as payable saves gas. Constructors should only be called by the admin or deployer and should not mistakenly receive ETH. Constructors can be payable to save gas.  Some examples of constructors in the contracts are https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L15 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L31 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L21 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L21 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L13 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L18 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L65 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/Withdrawer.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L22 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L45 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L57 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/utils/NestedAssetBatcher.sol#L32 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L44  ## Recommended Mitigation Steps  Add payable to these functions for gas savings  # [G-11] Use internal function in place of modifier  An internal function can save gas vs. a modifier. A modifier inlines the code of the original function but an internal function does not.  Source https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#dde7  Many modifiers can use this change https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L103 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableFactoryHandler.sol#L20 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableProxyDelegation.sol#L40 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L98 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L106  ## Recommended Mitigation Steps  Use internal functions in place of modifiers to save gas.  # [G-12] Use uint not bool  Booleans are more expensive than uint256 or any type that takes up a full word because each write operation emits an extra SLOAD to first read the slot's contents, replace the bits taken up by the boolean, and then write back. This is the compiler's defense against contract upgrades and pointer aliasing, and it cannot be disabled.  Locations where this was found include https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L34 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L197 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L197 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L49 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L90 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L33 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L116 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L356 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L403 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L464 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L466 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L493 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L540 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L611 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L151 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L36 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/libraries/StakingLPVaultHelpers.sol#L100 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/libraries/StakingLPVaultHelpers.sol#L130 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/libraries/CurveHelpers/CurveHelpers.sol#L85 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/libraries/ExchangeHelpers.sol#L19 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/libraries/ExchangeHelpers.sol#L22  ## Recommended Mitigation Steps  Replace bool variables with uints  # [G-13] Use uint256 not smaller ints  From [the solidity docs](https://docs.soliditylang.org/en/v0.8.15/internals/layout_in_storage.html?highlight=elements%20that%20are%20smaller%20than%2032%20bytes#layout-of-state-variables-in-storage) ``` When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. ```  Locations where this was found include https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L8 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L72 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L122 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L166 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L193 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L214 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L262 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L86 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L116 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L131 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L313 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/libraries/StakingLPVaultHelpers.sol#L105  ## Recommended Mitigation Steps  Replace bool variables with uints  # [G-14] Use Solidity errors instead of require  Solidity errors introduced in version 0.8.4 can save gas on revert conditions https://blog.soliditylang.org/2021/04/21/custom-errors/ https://twitter.com/PatrickAlphaC/status/1505197417884528640  Many require blocks are used in the code which can be replaced with errors to save gas https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L35 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L39 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L40 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L30 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L31 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L32 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L33 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L34 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L39 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L70 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L73 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L121 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L123  ## Recommended Mitigation Steps  Replace require blocks with new solidity errors described in https://blog.soliditylang.org/2021/04/21/custom-errors/  # [G-15] Bitshift for divide by 2  When multiply or dividing by a power of two, it is cheaper to bitshift than to use standard math operations.  There is a divide by 2 operation on these lines https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L273 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275  ## Recommended Mitigation Steps  Bitshift right by one bit instead of dividing by 2 to save gas  # [G-16] Non-public variables save gas  Many constant variables are public, but changing the visibility of these variables to private or internal can save gas. https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L25 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L26 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L28 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/utils/NestedAssetBatcher.sol#L19 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/utils/NestedAssetBatcher.sol#L20 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L11 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L12 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L20 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L23 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L19 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L19 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L11 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L15 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/Withdrawer.sol#L14 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L17 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L32 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L32 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L35 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L39 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L80 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/utils/NestedAssetBatcher.sol#L19 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/utils/NestedAssetBatcher.sol#L20  ## Recommended Mitigation Steps  Declare some public variables as private or internal to save gas  # [G-17] Use calldata instead of memory for function arguments  Using calldata instead of memory for function arguments saves gas sometimes. This can happen when a function is called externally and the memory array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). If the array is used in a for loop, `arr[i]` accesses the value in memory using a `mload`. If calldata is used instead, then instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  One case of function arguments using memory instead of calldata can use this improvement to save gas https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L52  Source https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#use-calldata-instead-of-memory-for-function-parameters  ## Recommended Mitigation Steps  Change function arguments from memory to calldata  # [G-18] Write contracts in vyper  The contracts are all written entirely in solidity. Writing contracts with vyper instead of solidity can save gas.  Source https://twitter.com/eiber_david/status/1515737811881807876 doggo demonstrates https://twitter.com/fubuloubu/status/1528179581974417414?t=-hcq_26JFDaHdAQZ-wYxCA&s=19  ## Recommended Mitigation Steps  Write some or all of the contracts in vyper to save gas  # [G-19] Use `abi.encodePacked()` not `abi.encode()`  Changing `abi.encode` to `abi.encodePacked` can save gas. `abi.encode` pads extra null bytes at the end of the call data which is normally unnecessary. In general, `abi.encodePacked` is more gas-efficient.  There are some places where this change can be made: https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L173 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L187  ## Recommended Mitigation Steps  Change `abi.encode` to `abi.encodePacked`  # [G-20] Save gas with unchecked  Use unchecked math when there is no overflow risk to save gas. Before index is decreased in remove it is checked for zero condition. This means index will not underflow and can be unchecked.  This subtraction do not need to be checked for underflows because it is after a require statements that confirms the underflow will not happen https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L525  ## Recommended Mitigation Steps  Add unchecked around math that can't overflow for gas savings. In Solidity before 0.8.0, use the normal math operators instead of safe math functions.
## Missing Zero-address Validation **Severity**: Low **Context**: [`Withdrawer.sol#L16-L18`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/Withdrawer.sol#L16-L18), [`YearnCurveVaultOperator.sol#L31-L51`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L31-L51)  **Description**: Lack of zero-address validation on address parameters may lead to transaction reverts, waste gas, require resubmission of transactions and may even force contract redeployments in certain cases within the protocol.  **Recommendation**: Add explicit zero-address validation on input parameters of address type.   ## Missing Time locks **Severity**: Low **Context**: [`NestedFactory.sol#L121-L179`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L121-L179), [`BeefyVaultStorage.sol#L34-L38`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/BeefyVaultStorage.sol#L34-L38)  **Description**: When critical parameters of systems need to be changed, it is required to broadcast the change via event emission and recommended to enforce the changes after a time-delay. This is to allow system users to be aware of such critical changes and give them an opportunity to exit or adjust their engagement with the system accordingly. None of the onlyOwner functions that change critical protocol addresses/parameters have a timelock for a time-delayed change to alert: (1) users and give them a chance to engage/exit protocol if they are not agreeable to the changes (2) team in case of compromised owner(s) and give them a chance to perform incident response.  **Recommendation**: Users may be surprised when critical parameters are changed or incentivizer programs completed early without notice. Furthermore, it can erode users' trust since they can’t be sure the protocol rules won’t be changed later on. Compromised owner keys may be used to change protocol addresses/parameters to benefit attackers. Without a time-delay, authorised owners have no time for any planned incident response.   ## Missing Equivalence Checks in Setters **Severity**: Low **Context**: [`NestedFactory.sol#L152-L172`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L152-L172)  **Description**: Setter functions are missing checks to validate if the new value being set is the same as the current value already set in the contract. Such checks will showcase mismatches between on-chain and off-chain states.  **Recommendation**: This may hinder detecting discrepancies between on-chain and off-chain states leading to flawed assumptions of on-chain state and protocol behavior.   ## `receive()` Function Should Emit An Event **Severity**: Low **Context**: [`NestedFactory.sol#L88-L92`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L88-L92), [`Withdrawer.sol#L16-L18`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/Withdrawer.sol#L16-L18)  **Description**: Consider emitting an event inside this function with `msg.sender` and `msg.value` as the parameters. This would make it easier to track incoming ether transfers.  **Recommendation**: Add events to the `receive()` functions.    ## Lack of Event Emission For Critical Functions **Severity**: Low **Context**: [`BeefyVaultOperator.sol#L36-L67`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L36-L67), [`BeefyVaultOperator.sol#L79-L108`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L79-L108), [`BeefyZapBiswapLPVaultOperator.sol#L46-L77`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L46-L77), [`BeefyZapBiswapLPVaultOperator.sol#L91-L121`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L91-L121), [`BeefyZapUniswapLPVaultOperator.sol#L46-L77`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L46-L77), [`BeefyZapUniswapLPVaultOperator.sol#L91-L121`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L91-L121), [`ParaswapOperator.sol#L22-L48`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Paraswap/ParaswapOperator.sol#L22-L48)  **Description**: Several functions update critical parameters that are missing event emission. These should be performed to ensure tracking of changes of such critical parameters.  **Recommendation**: Add events to functions that change critical parameters.   ## Unindexed Event Parameters **Severity** Informational **Context**: [`MixinOperatorResolver.sol#L14`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L14), [`TimelockControllerEmergency.sol#L60`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L60)  **Description**: Parameters of certain events are expected to be indexed so that they’re included in the block’s bloom filter for faster access. Failure to do so might confuse off-chain tooling looking for such indexed events.  **Recommendation**: Add the indexed keyword to event parameters that should include it.   ## Lack of `solhint` To Ignore Warnings **Severity**: Informational **Context**: [`OwnerProxy.sol#L21-L36`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/OwnerProxy.sol#L21-L36), [`OperatorScripts.sol#L58-L60`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/scripts/OperatorScripts.sol#L58-L60)  **Description**: `solhint` is useful to help ignore warnings that aren't really issues. For example the code base has some assembly blocks which promts the warning `Linter: Avoid to use inline assembly. It is acceptable only in rare cases`. Adding in `/* solhint-disable no-inline-assembly */` above it will ignore this warning.  **Recommendation**: Use `solhint` to ignore warnings that aren't really issues.   ## Spelling Errors **Severity**: Informational **Context**: [`NestedFactory.sol#L51 (withdrawed => withdrawn)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L51), [`NestedFactory.sol#L477 (dont => do not)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L477), [`NestedFactory.sol#L534 (transfered => transferred)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L534), [`NestedFactory.sol#L639 (withdrawed => withdrawal)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L639), [`MixinOperatorResolver.sol#L81 (datas => data(it is already plural))`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L81), [`OwnableProxyDelegation.sol#L17 (setted => set)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/OwnableProxyDelegation.sol#L17), [`TimeLockControllerEmergency.sol#L183 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L183), [`TimeLockControllerEmergency.sol#L187 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L187), [`TimeLockControllerEmergency.sol#L224 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L224), [`TimeLockControllerEmergency.sol#L230 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L230), [`TimeLockControllerEmergency.sol#L232 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L232), [`BeefyVaultOperator.sol#L95 (WITHDRAWED => WITHDRAWAL)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L95), [`BeefyZapBiswapLPVaultOperator.sol#L108 (WITHDRAWED => WITHDRAWAL)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L108), [`BeefyZapUniswapLPVaultOperator.sol#L108 (WITHDRAWED => WITHDRAWAL)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L108), [`StakingLPVaultHelpers.sol#L21 (liquitiy => liquidity)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L21), [`StakingLPVaultHelpers.sol#L52 (liquitiy => liquidity)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L52), [`StakingLPVaultHelpers.sol#L85 (liquitiy => liquidity)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L85), [`StakingLPVaultHelpers.sol#L115 (liquitiy => liquidity)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L115)  **Description**: Spelling errors in comments can cause confusion to both users and developers.  **Recommendation**: Check all misspellings to ensure they are corrected.   ## Missing or Incomplete NatSpec **Severity**: Informational **Context**: [`All Contracts`](https://github.com/code-423n4/2022-06-nested)  **Description**: Some functions are missing @notice/@dev NatSpec comments for the function, @param for all/some of their parameters and @return for return values. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability and usability.  **Recommendation**: Add in full NatSpec comments for all functions to have complete code documentation for future use.   ## Too Recent of a Pragma **Severity** Informational **Context**: [`All Contracts`](https://github.com/code-423n4/2022-06-nested)  **Description**: Using too recent of a pragma is risky since they are not battle tested. A rise of a bug that wasn't known on release would cause either a hack or a need to secure funds and redeploy.  **Recommendation**:  Use a Pragma version that has been used for sometime. I would suggest `0.8.4` for the decrease of risk and still has the gas optimizations implemented.
# [QA-1] Naming inconsistency - some arguments have ``_`` at their prefixes but others do not at NestedFactory.sol  Throughout the file ``NestedFactory.sol``, arguments of functions have ``_`` at their prefixes like ``function setFeeSplitter(FeeSplitter _feeSplitter)``. However, following 2 arguments do not have ``_`` at their prefixes which are not consistent.  https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L121  https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L133  ---  # [QA-2] Use either ``_msgSender()`` or ``msg.sender``   Throughout the file ``NestedFactory.sol``, ``_msgSender()`` is used to get the sender. However, following 2 places use ``msg.sender`` which seem not consistent.  https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L89  https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L177  
# QA Report  ## Table of Contents  - [summary](#summary) - [Comment Missing function parameter](#comment-missing-function-parameter) - [Constants instead of magic numbers](#constants-instead-of-magic-numbers) - [Events indexing](#events-indexing) - [Public functions can be external](#public-functions-can-be-external) - [Scientific notation](#scientific-notation) - [Typos](#typos) - [Immutable addresses lack zero-address check](#immutable-addresses-lack-zero-address-check) - [Payable functions when using ERC20](#payable-functions-when-using-erc20)   # summary  > Few vulnerabilities were found examining the contracts. The main concerns are with:    # Comment Missing function parameter  ## PROBLEM  Some of the function comments are missing function parameters or returns    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Parameters missing a natspec comment include:   ### BeefyZapBiswapLPVaultOperator.sol  [uint256 reserveA](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L266)\ [uint256 reserveB](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L267)\ [IBiswapRouter02 router](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L268)\ [uint256 swapAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L269)\  ### BeefyZapUniswapLPVaultOperator.sol  [uint256 reserveA](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L265)\ [uint256 reserveB](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L266)\ [IUniswapV2Router02 router](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L267)\ [uint256 swapAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L268)  ### TimelockControllerEmergency.sol  [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L119)\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L126)\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L133)\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L141)\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L149)\ [address target,uint256 value,bytes calldata data,bytes32 predecessor,bytes32 salt](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L167-L171)\ [address[] calldata targets,uint256[] calldata values,bytes[] calldata datas,bytes32 predecessor,bytes32 salt](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L181-L185)\ [address target,uint256 value,bytes calldata data,bytes32 predecessor,bytes32 salt,uint256 delay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L200-L205)\ [address[] calldata targets,uint256[] calldata values,bytes[] calldata datas,bytes32 predecessor,bytes32 salt,uint256 delay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L221-L227)\ [bytes32 id, uint256 delay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L242)\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L255)\ [address target,uint256 value,bytes calldata data,bytes32 predecessor,bytes32 salt](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L275-L279)\ [address target,uint256 value,bytes calldata data](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L296-L298)\ [address[] calldata targets,uint256[] calldata values,bytes[] calldata datas,bytes32 predecessor,bytes32 salt](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L313-L317)\ [bytes32 id, bytes32 predecessor](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L333)\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L341)\ [bytes32 id,uint256 index,address target,uint256 value,bytes calldata data](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L352-L356)\ [uint256 newDelay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L374)    ## TOOLS USED  Manual Analysis    ## MITIGATION  Add a comment for these parameters  # Constants instead of magic numbers  ## PROBLEM  It is best practice to use constant variables rather than literal values to make the code easier to understand and maintain.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### NestedFactory.sol  [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L161)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L169)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L264)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L378)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L629)  ### BeefyZapBiswapLPVaultOperator.sol  [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L271)\ [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L272)  ### BeefyZapUniswapLPVaultOperator.sol  [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L269)\ [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L270)     ## TOOLS USED  Manual Analysis    ## MITIGATION   Define constant variables for the literal values aforementioned.  # Events indexing  ## PROBLEM  Events should use indexed fields    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### MixinOperatorResolver.sol  [event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L14)  ### BeefyVaultStorage.sol  [event VaultAdded(address vault, address tokenOrZapper)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L12)\ [event VaultRemoved(address vault)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L16)  ### YearnVaultStorage.sol  [event VaultAdded(address vault, CurvePool pool)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L17)\ [event VaultRemoved(address vault)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L21)  ### TimelockControllerEmergency.sol  [event MinDelayChange(uint256 oldDuration, uint256 newDuration)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L60)  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add indexed fields to these events so that they have the maximum number of indexed fields possible.   # Scientific notation  ## PROBLEM  For readability, it is best to use scientific notation (e.g `10e5`) rather than decimal literals(`100000`) or exponentiation(`10**5`)    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### NestedFactory.sol  [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L161)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L169)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L264)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L378)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443)\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L629)  ### BeefyZapBiswapLPVaultOperator.sol  [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L271)\ [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L272)  ### BeefyZapUniswapLPVaultOperator.sol  [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L269)\ [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L270)    ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace the numbers aforementioned with their scientific notation  # Typos  ## PROBLEM  There are some typos/misspelt words in the contracts.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:  ### BeefyVaultOperator.sol  [WITHDRAWED](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L95)  ### BeefyZapBiswapLPVaultOperator.sol  [WITHDRAWED](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L108)   ### BeefyZapUniswapLPVaultOperator.sol  [WITHDRAWED](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L108)     ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace with `WITHDRAWN`  # Immutable addresses lack zero-address check  ## IMPACT  constructors should check the address written in an immutable address variable is not the zero address   ## SEVERITY  Low    ## PROOF OF CONCEPT  Instances include:   ### Withdrawer.sol  [weth = _weth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L17)  ### YearnCurveVaultOperator.sol  [eth = _eth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48)\ [weth = IWETH(_weth)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48)\ [withdrawer = _withdrawer](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L50)    ## TOOLS USED  Manual Analysis    ## MITIGATION  Add a zero address check for these parameters.  # Payable functions when using ERC20   ## PROBLEM  Some functions have the `payable` modifier but their logic does not make use of `msg.value`. These contracts do not have any way to withdraw ETH, meaning any ETH sent would get locked.     ## SEVERITY  Low     ## PROOF OF CONCEPT  Instances include:   ### ParaswapOperator.sol  scope: `performSwap`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L26)  ### BeefyVaultOperator.sol  scope: `deposit`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L40)  ### BeefyZapBiswapLPVaultOperator.sol  scope: `deposit`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L51)  ### BeefyZapUniswapLPVaultOperator.sol  scope: `deposit`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L51)  ### YearnCurveVaultOperator.sol  scope: `deposit`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L120)  scope: `withdraw128`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L211)  scope: `withdraw256`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L259)   ## TOOLS USED  Manual Analysis    ## MITIGATION  There should be a `require(0 == msg.value)` in these functions to ensure no Ether is being sent. 
# Gas Report  ## Table of Contents  - [Caching storage variables in memory to save gas](#caching-storage-variables-in-memory-to-save-gas) - [Calldata instead of memory for RO function parameters](#calldata-instead-of-memory-for-ro-function-parameters) - [Comparison operators](#comparison-operators) - [Constructor parameters should be avoided when possible](#constructor-parameters-should-be-avoided-when-possible) - [Default value initialization](#default-value-initialization) - [Mathematical optimizations](#mathematical-optimizations) - [Require instead of AND](#require-instead-of-and) - [Revert strings length](#revert-strings-length) - [Shifting cheaper than division](#shifting-cheaper-than-division) - [Tight variable packing](#tight-variable-packing) - [unchecked arithmetic](#unchecked-arithmetic) - [unnecessary computation](#unnecessary-computation)  # Caching storage variables in memory to save gas  ## IMPACT  Anytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable in memory: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.   ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  scope: `_transferFeeWithRoyalty()`  - `feeSplitter` is read 3 times  [line 573](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L573)\ [line 575](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L575)\ [line 577](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L577)   ## TOOLS USED  Manual Analysis  ## MITIGATION  cache these storage variables in memory  # Calldata instead of memory for RO function parameters  ## PROBLEM  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.  Try to use calldata as a data location because it will avoid copies and also makes sure that the data cannot be modified.  ## PROOF OF CONCEPT  Instances include:  ### ExchangeHelpers.sol  scope: `fillQuote()`  - [bytes memory _swapCallData](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/ExchangeHelpers.sol#L18)  ### OwnerProxy.sol  scope: `execute()`  - [bytes memory _data](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L16)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `memory` with `calldata`  # Comparison Operators  ## IMPACT  In the EVM, there is no opcode for ` >=` or `<=`. When using greater than or equal, two operations are performed: `>` and `=`.  Using strict comparison operators hence saves gas  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [_entryFees <= 10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L161)\ [_entryFees <= 10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L169)\ [amountSpent <= _inputTokenAmount - feesAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L379)\ [amountSpent <= _inputTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L428)\ [amounts[1] <= _amountToSpend](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L495)\ [address(this).balance >= _inputTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L544)\ [nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L552)  ### BeefyVaultOperator.sol  [vaultAmount >= minVaultAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L54)  ### BeefyZapBiswapLPVaultOperator.sol  [vaultAmount >= minVaultAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64)\ [amountToDeposit >= depositedAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L65)\ [tokenAmount >= minTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L109)  ### BeefyZapUniswapLPVaultOperator.sol  [vaultAmount >= minVaultAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64)\ [amountToDeposit >= depositedAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L65)\ [tokenAmount >= minTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L109)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `<=` with `<`, and `>=` with `>`. Do not forget to increment/decrement the compared variable  example:  ``` -vaultAmount >= minVaultAmount; +vaultAmount > minVaultAmount - 1; ```  However, if `1` is negligible compared to the value of the variable, we can omit the increment.   # Constructor parameters should be avoided when possible  ## IMPACT  Constructor parameters are expensive. The contract deployment will be cheaper in gas if they are hard coded instead of using constructor parameters. With the compilers parameters in `hardhat.config.ts`, deployment costs approximately `400` more gas per variable written via a constructor parameter.  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [constructor](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L76-L81)  ``` nestedAsset = _nestedAsset; nestedRecords = _nestedRecords; reserve = _reserve; feeSplitter = _feeSplitter; weth = _weth; withdrawer = _withdrawer ```  ### Withdrawer.sol  [weth = _weth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L17)  ### Paraswap.sol  [tokenTransferProxy = _tokenTransferProxy](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L17)\ [augustusSwapper = _augustusSwapper](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L18)  ### YearnCurveVaultOperator.sol  [eth = _eth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48)\ [withdrawer = _withdrawer](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L50)  ### TimelockControllerEmergency.sol  [_minDelay = minDelay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L93)  ### OperatorScripts.sol  [nestedFactory = _nestedFactory](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L21)\ [resolver = _resolver](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L22)   ## TOOLS USED  Manual Analysis, hardhat  ## MITIGATION  Hardcode storage variables with their initial value instead of writing it during contract deployment with constructor parameters.   # Default value initialization  ## IMPACT  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L136)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L196)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L256)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L315)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L333)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L369)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L412)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L651)  ### OperatorResolver.sol  [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L60)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L75)  ### MixinOperatorResolver.sol  [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L56)  ### TimelockControllerEmergency.sol  [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L84)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L89)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L234)\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L324)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove explicit initialization for default values.   # Mathematical optimizations  ## PROBLEM  X += Y costs `22` more gas than X = X + Y. This can mean a lot of gas wasted in a function call when the computation is repeated `n` times (loops)  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [amountBought -= amountFees](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L266)\ [amountSpent += _submitOrder(address(tokenSold),_batchedOrders.orders[i].token,_nftId,_batchedOrders.orders[i],true // always to the reserve)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L370-L376)\ [ethNeeded += _batchedOrders[i].amount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L653)  ## TOOLS USED  Manual Analysis  ## MITIGATION  use `X = X + Y` instead of `X += Y` (same with `-`)  # Require instead of AND  ## IMPACT  Require statements including conditions with the `&&` operator can be broken down in multiple require statements to save gas.  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [require(address(_nestedAsset) != address(0) &&  address(_nestedRecords) != address(0) &&address(_reserve) != address(0) &&address(_feeSplitter) != address(0) &&address(_weth) != address(0) &&  _operatorResolver != address(0) &&  address(_withdrawer) != address(0),  "NF: INVALID_ADDRESS" )](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L66-L74)  ### BeefyVaultOperator.sol  [require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BVO: INVALID_AMOUNT_RECEIVED")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L54)  ### BeefyZapBiswapLPVaultOperator.sol  [require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64)\ [require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L65)  ### BeefyZapUniswapLPVaultOperator.sol  [require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64)\ [require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L65)  ### ParaswapOperator.sol  [require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L16)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Break down the statements in multiple require statements.  ``` -require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS"); +require(_tokenTransferProxy != address(0))  +require(_augustusSwapper != address(0)); ``` You can also improve gas savings by using [custom errors](#custom-errors)   # Revert strings length  ## IMPACT  Revert strings cost more gas to deploy if the string is larger than 32 bytes. It costs `9,500` gas upon deployment per string exceeding that 32-byte size.  ## PROOF OF CONCEPT  Revert strings exceeding 32 bytes include:  ### TimelockControllerEmergency.sol  [TimelockController: length mismatch](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L229)\ [TimelockController: length mismatch](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L230)\ [TimelockController: operation already scheduled](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L243)\ [TimelockController: insufficient delay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L244)\ [TimelockController: operation cannot be cancelled](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L256)\ [TimelockController: length mismatch](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L319)\ [TimelockController: length mismatch](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L320)\ [TimelockController: operation is not ready](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L334)\ [TimelockController: missing dependency](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L335)\ [TimelockController: operation is not ready](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L342)\ [TimelockController: underlying transaction reverted](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L359)\ [TimelockController: caller must be timelock](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L375)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Write the error strings so that they do not exceed 32 bytes. For further gas savings, consider also using [custom errors](#custom-errors).   # Shifting cheaper than division  ## IMPACT  A division by 2 can be calculated by shifting one to the right. While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.  ## PROOF OF CONCEPT  Instances include:  ### BeefyZapBiswapLPVaultOperator.sol  [uint256 halfInvestment = investmentA / 2](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275)  ### BeefyZapUniswapLPVaultOperator.sol  [uint256 halfInvestment = investmentA / 2](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L275)  ## TOOLS USED  Manual Analysis  ## MITIGATION  ``` -investmentA / 2; +investmentA >> 1; ```  # Tight Variable Packing  ## PROBLEM  Solidity contracts have contiguous 32 bytes (256 bits) slots used in storage. By arranging the variables, it is possible to minimize the number of slots used within a contract's storage and therefore reduce deployment costs.  address type variables are each of 20 bytes size (way less than 32 bytes). However, they here take up a whole 32 bytes slot (they are contiguous).  As bool type variables are of size 1 byte, there's a slot here that can get saved by moving one bool closer to an address  ## PROOF OF CONCEPT  Instances include:  ### OwnableProxyDelegation.sol  ``` address private _owner; @audit - slot 1  /// @dev Storage slot with the proxy admin (see TransparentUpgradeableProxy from OZ) bytes32 internal constant _ADMIN_SLOT = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);  @audit - slot 2  /// @dev True if the owner is setted bool public initialized;  @audit - slot 3 ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Place `initialized` after `_owner` to save one storage slot  ``` address private _owner; @audit - slot 1  /// @dev True if the owner is setted +bool public initialized;   /// @dev Storage slot with the proxy admin (see TransparentUpgradeableProxy from OZ) bytes32 internal constant _ADMIN_SLOT = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);  @audit - slot 2 ```   # Unchecked arithmetic  ## IMPACT  The default "checked" behavior costs more gas when adding/diving/multiplying, because under-the-hood those checks are implemented as a series of opcodes that, prior to performing the actual arithmetic, check for under/overflow and revert if it is detected.  if it can statically be determined there is no possible way for your arithmetic to under/overflow (such as a condition in an if statement), surrounding the arithmetic in an `unchecked` block will save gas. This is particularly true in for loops, as it saves some gas at each iteration.  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L136)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L196)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L256)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L315)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L333)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L369)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L412)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L651)  ### OperatorResolver.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L60)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L75)  ### MixinOperatorResolver.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L56)  ### BeefyVaultOperator.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L18)  ### BeefyZapBiswapLPVaultOperator.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27)  ### BeefyZapUniswapLPVaultOperator.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27)  ### YearnCurveVaultOperator.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42)  ### CurveHelpers.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L22)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L42)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L62)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L86)  ### OperatorScripts.sol  [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L67)\ [i++](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L80)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Place the arithmetic operations in an `unchecked` block  # Unnecessary computation  ## IMPACT  When emitting an event that includes a new and an old value, it is cheaper in gas to avoid caching the old value in memory. Instead, emit the event, then save the new value in storage.  ## PROOF OF CONCEPT  Instances include:  ### OwnableProxyDelegation.sol  [function _setOwner](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L64-L66)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace  ``` address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner) ```  with  ``` emit OwnershipTransferred(_owner_, newOwner) _owner = newOwner; ``` 
 Note: The README lists a bunch of QA/Gas reports from prior findings, but doesn't list the specific issues found therein. Having each warden look at each report and de-dupe is just like adding more files to the scope, and I think is a bit unfair. For the ones that the sponsor has [explicitly listed](https://code4rena.com/contests/2022-06-nested-finance-contest#gas-optimizations-already-surfaced) I've still included them because the sponsor may end up finding them useful, especially after seeing the gas amounts involved, but have the lines with strike-through, so the sponsor and judge can ignore them if they wish  ## Summary  ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | 1 | Unused/empty `receive()`/`fallback()` function | 1 | | 2 | Missing checks for `address(0x0)` when assigning values to `address` state variables | 2 |  Total: 3 instances over 2 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | 1 | Missing `initializer` modifier on constructor | 2 | | 2 | Missing `initializer` modifier | 2 | | 3 | Adding a `return` statement when the function defines a named return variable, is redundant | 4 | | 4 | `public` functions not called by the contract should be declared `external` instead | 2 | | 5 | `constant`s should be defined rather than using magic numbers | 25 | | ~~6~~ | ~~Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`~~ | ~~4~~ | | 7 | Constant redefined elsewhere | 5 | | 8 | NatSpec is incomplete | 10 | | 9 | Event is missing `indexed` fields | 8 | | 10 | Not using the named return variables anywhere in the function is confusing | 8 |  ~~Total: 70 instances over 10 issues~~ Total: 66 instances over 9 issues   ## Low Risk Issues  ### 1. Unused/empty `receive()`/`fallback()` function If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`)  *There is 1 instance of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #1  113:      receive() external payable {} ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L113  ### 2. Missing checks for `address(0x0)` when assigning values to `address` state variables  *There are 2 instances of this issue:* ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol   #1  48:           eth = _eth; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48  ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol   #2  65:           _owner = newOwner; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L65  ## Non-critical Issues  ### 1. Missing `initializer` modifier on constructor OpenZeppelin [recommends](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5) that the `initializer` modifier be applied to constructors  *There are 2 instances of this issue:* ```solidity File: contracts/Withdrawer.sol   #1  16:       constructor(IWETH _weth) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L16  ```solidity File: contracts/NestedFactory.sol   #2  57        constructor( 58            NestedAsset _nestedAsset, 59            NestedRecords _nestedRecords, 60            NestedReserve _reserve, 61            FeeSplitter _feeSplitter, 62            IWETH _weth, 63            address _operatorResolver, 64            Withdrawer _withdrawer 65:       ) MixinOperatorResolver(_operatorResolver) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L57-L65  ### 2. Missing `initializer` modifier The contract extends `ReentrancyGuard`/`ReentrancyGuardUpgradeable` but does not use the `initializer` modifier anywhere  *There are 2 instances of this issue:* ```solidity File: contracts/Withdrawer.sol   #1  13:   contract Withdrawer is ReentrancyGuard { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L13  ```solidity File: contracts/NestedFactory.sol   #2  20:   contract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L20  ### 3. Adding a `return` statement when the function defines a named return variable, is redundant  *There are 4 instances of this issue:* ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol   #1  25:                   return amounts; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L25  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol   #2  45:                   return amounts; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L45  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol   #3  65:                   return amounts; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L65  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol   #4  89:                   return success; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L89  ### 4. `public` functions not called by the contract should be declared `external` instead Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.  *There are 2 instances of this issue:* ```solidity File: contracts/governance/OwnerProxy.sol   #1  16:       function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L16  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #2  295       function executeEmergency( 296           address target, 297           uint256 value, 298           bytes calldata data 299:      ) public payable onlyRole(EMERGENCY_ROLE) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L295-L299  ### 5. `constant`s should be defined rather than using magic numbers Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals  *There are 25 instances of this issue:* ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  /// @audit 1000 271:          require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW");  /// @audit 1000 272:          require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L271  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  /// @audit 1000 269:          require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW");  /// @audit 1000 270:          require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L269  ```solidity File: contracts/governance/OwnerProxy.sol  /// @audit 0x20 21:               let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 0)  /// @audit 0x40 24:               response := mload(0x40)  /// @audit 0x40 25:               mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))  /// @audit 0x20 25:               mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))  /// @audit 0x1f 25:               mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))  /// @audit 0x1f 25:               mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))  /// @audit 0x20 27:               returndatacopy(add(response, 0x20), 0, size)  /// @audit 0x20 32:                   revert(add(response, 0x20), size) ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L21  ```solidity File: contracts/governance/scripts/OperatorScripts.sol  /// @audit 0x20 59:               deployedAddress := create(0, add(bytecode, 0x20), mload(bytecode)) ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L59  ```solidity File: contracts/NestedFactory.sol  /// @audit 10000 161:          require(_entryFees <= 10000, "NF: FEES_OVERFLOW");  /// @audit 10000 169:          require(_exitFees <= 10000, "NF: FEES_OVERFLOW");  /// @audit 10000 264:          uint256 amountFees = (amountBought * exitFees) / 10000; // Exit Fees  /// @audit 10000 378:          feesAmount = (amountSpent * entryFees) / 10000; // Entry Fees  /// @audit 10000 443:              feesAmount = (amountBought * (_toReserve ? entryFees : exitFees)) / 10000;  /// @audit 10000 629:          uint256 feeAmount = (_amount * exitFees) / 10000; // Exit Fee ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L161  ```solidity File: contracts/libraries/StakingLPVaultHelpers.sol  /// @audit 3 38:           } else if (poolCoinAmount == 3) {  /// @audit 3 70:           } else if (poolCoinAmount == 3) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L38  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol  /// @audit 3 41:       ) internal view returns (uint256[3] memory amounts) {  /// @audit 3 42:           for (uint256 i; i < 3; i++) {  /// @audit 4 61:       ) internal view returns (uint256[4] memory amounts) {  /// @audit 4 62:           for (uint256 i; i < 4; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L41  ### ~~6. Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`~~  *There are 4 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #1  25:       bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256("TIMELOCK_ADMIN_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L25  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #2  26:       bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L26  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #3  27:       bytes32 public constant EXECUTOR_ROLE = keccak256("EXECUTOR_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L27  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #4  28:       bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L28  ### 7. Constant redefined elsewhere Consider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.  *There are 5 instances of this issue:* ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  /// @audit seen in contracts/operators/Beefy/BeefyVaultOperator.sol  19:       BeefyVaultStorage public immutable operatorStorage; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L19  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  /// @audit seen in contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  19:       BeefyVaultStorage public immutable operatorStorage; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L19  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  /// @audit seen in contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  20:       YearnVaultStorage public immutable operatorStorage; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L20  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  /// @audit seen in contracts/governance/scripts/OperatorScripts.sol  17:       OperatorResolver public immutable resolver; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L17  ```solidity File: contracts/NestedFactory.sol  /// @audit seen in contracts/Withdrawer.sol  39:       IWETH public immutable weth; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L39  ### 8. NatSpec is incomplete  *There are 10 instances of this issue:* ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  /// @audit Missing: '@return' 230       /// @param path An array of the two paired token addresses 231       /// @param biswapRouter The uniswapV2 router to be used for swap and liquidity addition 232       function _swapAndAddLiquidity( 233           uint256 amount, 234           uint256 swapAmountIn, 235           address[] memory path, 236           IBiswapRouter02 biswapRouter 237:      ) private returns (uint256 mintedLpAmount) {  /// @audit Missing: '@param reserveA' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       /// @param pair The IBiswapPair to be used 264       function _getOptimalSwapAmount( 265           uint256 investmentA, 266           uint256 reserveA, 267           uint256 reserveB, 268           IBiswapRouter02 router, 269           IBiswapPair pair 270:      ) private view returns (uint256 swapAmount) {  /// @audit Missing: '@param reserveB' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       /// @param pair The IBiswapPair to be used 264       function _getOptimalSwapAmount( 265           uint256 investmentA, 266           uint256 reserveA, 267           uint256 reserveB, 268           IBiswapRouter02 router, 269           IBiswapPair pair 270:      ) private view returns (uint256 swapAmount) {  /// @audit Missing: '@param router' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       /// @param pair The IBiswapPair to be used 264       function _getOptimalSwapAmount( 265           uint256 investmentA, 266           uint256 reserveA, 267           uint256 reserveB, 268           IBiswapRouter02 router, 269           IBiswapPair pair 270:      ) private view returns (uint256 swapAmount) {  /// @audit Missing: '@return' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       /// @param pair The IBiswapPair to be used 264       function _getOptimalSwapAmount( 265           uint256 investmentA, 266           uint256 reserveA, 267           uint256 reserveB, 268           IBiswapRouter02 router, 269           IBiswapPair pair 270:      ) private view returns (uint256 swapAmount) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L230-L237  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  /// @audit Missing: '@return' 230       /// @param path An array of the two paired token addresses 231       /// @param uniswapRouter The uniswapV2 router to be used for swap and liquidity addition 232       function _swapAndAddLiquidity( 233           uint256 amount, 234           uint256 swapAmountIn, 235           address[] memory path, 236           IUniswapV2Router02 uniswapRouter 237:      ) private returns (uint256 mintedLpAmount) {  /// @audit Missing: '@param reserveA' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       function _getOptimalSwapAmount( 264           uint256 investmentA, 265           uint256 reserveA, 266           uint256 reserveB, 267           IUniswapV2Router02 router 268:      ) private pure returns (uint256 swapAmount) {  /// @audit Missing: '@param reserveB' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       function _getOptimalSwapAmount( 264           uint256 investmentA, 265           uint256 reserveA, 266           uint256 reserveB, 267           IUniswapV2Router02 router 268:      ) private pure returns (uint256 swapAmount) {  /// @audit Missing: '@param router' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       function _getOptimalSwapAmount( 264           uint256 investmentA, 265           uint256 reserveA, 266           uint256 reserveB, 267           IUniswapV2Router02 router 268:      ) private pure returns (uint256 swapAmount) {  /// @audit Missing: '@return' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       function _getOptimalSwapAmount( 264           uint256 investmentA, 265           uint256 reserveA, 266           uint256 reserveB, 267           IUniswapV2Router02 router 268:      ) private pure returns (uint256 swapAmount) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L230-L237  ### 9. Event is missing `indexed` fields Each `event` should use three `indexed` fields if there are three or more fields  *There are 8 instances of this issue:* ```solidity File: contracts/operators/Beefy/BeefyVaultStorage.sol  12:       event VaultAdded(address vault, address tokenOrZapper);  16:       event VaultRemoved(address vault); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L12  ```solidity File: contracts/operators/Yearn/YearnVaultStorage.sol  17:       event VaultAdded(address vault, CurvePool pool);  21:       event VaultRemoved(address vault); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L17  ```solidity File: contracts/governance/TimelockControllerEmergency.sol  37        event CallScheduled( 38            bytes32 indexed id, 39            uint256 indexed index, 40            address target, 41            uint256 value, 42            bytes data, 43            bytes32 predecessor, 44            uint256 delay 45:       );  50:       event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);  60:       event MinDelayChange(uint256 oldDuration, uint256 newDuration); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L37-L45  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  14:       event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L14  ### 10. Not using the named return variables anywhere in the function is confusing Consider changing the variable to be an unnamed one  *There are 8 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol  /// @audit pending 119:      function isOperation(bytes32 id) public view virtual returns (bool pending) {  /// @audit pending 126:      function isOperationPending(bytes32 id) public view virtual returns (bool pending) {  /// @audit ready 133:      function isOperationReady(bytes32 id) public view virtual returns (bool ready) {  /// @audit done 141:      function isOperationDone(bytes32 id) public view virtual returns (bool done) {  /// @audit timestamp 149:      function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {  /// @audit duration 158:      function getMinDelay() public view virtual returns (uint256 duration) {  /// @audit hash 166       function hashOperation( 167           address target, 168           uint256 value, 169           bytes calldata data, 170           bytes32 predecessor, 171           bytes32 salt 172:      ) public pure virtual returns (bytes32 hash) {  /// @audit hash 180       function hashOperationBatch( 181           address[] calldata targets, 182           uint256[] calldata values, 183           bytes[] calldata datas, 184           bytes32 predecessor, 185           bytes32 salt 186:      ) public pure virtual returns (bytes32 hash) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L119   
 Note: The README lists a bunch of QA/Gas reports from prior findings, but doesn't list the specific issues found therein. Having each warden look at each report and de-dupe is just like adding more files to the scope, and I think is a bit unfair. For the ones that the sponsor has [explicitly listed](https://code4rena.com/contests/2022-06-nested-finance-contest#gas-optimizations-already-surfaced) I've still included them because the sponsor may end up finding them useful, especially after seeing the gas amounts involved, but have the lines with strike-through, so the sponsor and judge can ignore them if they wish  ## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | 1 | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 3 | | 2 | Using `storage` instead of `memory` for structs/arrays saves gas | 1 | | 3 | Multiple accesses of a mapping/array should use a local variable cache | 4 | | 4 | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement | 2 | | ~~5~~ | ~~`<array>.length` should not be looked up in every loop of a `for`-loop~~ | ~~10~~ | | 6 | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 28 | | 7 | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 12 | | 8 | Optimize names to save gas | 2 | | 9 | Using `bool`s for storage incurs overhead | 1 | | 10 | It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied | 18 | | ~~11~~ | ~~`++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)~~ | ~~24~~ | | 12 | Splitting `require()` statements that use `&&` saves gas | 7 | | 13 | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 6 | | 14 | Using `private` rather than `public` for constants, saves gas | 4 | | 15 | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 14 | | 16 | Division by two should use bit shifting | 2 | | 17 | `require()` or `revert()` statements that check input arguments should be at the top of the function | 1 | | 18 | Empty blocks should be removed or emit something | 2 | | ~~19~~ | ~~Use custom errors rather than `revert()`/`require()` strings to save gas~~ | ~~132~~ | | 20 | Functions guaranteed to revert when called by normal users can be marked `payable` | 27 | | 21 | Don't use `_msgSender()` if not supporting EIP-2771 | 13 |  ~~Total: 313 instances over 21 issues~~ Total: 147 instances over 18 issues    ## Gas Optimizations  ### 1. Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution.   If the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one  *There are 3 instances of this issue:* ```solidity File: contracts/governance/scripts/OperatorScripts.sol   #1  28:       function addOperator(IOperatorResolver.Operator memory operator, bytes32 name) external { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L28  ```solidity File: contracts/governance/scripts/OperatorScripts.sol   #2  52:       function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L52  ```solidity File: contracts/governance/scripts/OperatorScripts.sol   #3  52:       function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L52  ### 2. Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There is 1 instance of this issue:* ```solidity File: contracts/NestedFactory.sol   #1  123:          bytes32[] memory operatorsCache = operators; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L123  ### 3. Multiple accesses of a mapping/array should use a local variable cache The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory  *There are 4 instances of this issue:* ```solidity File: contracts/operators/Yearn/YearnVaultStorage.sol   #1  /// @audit vaults[vault] on line 33 34:           require(vaults[vault].lpToken == address(0), "YVS: VAULT_ALREADY_HAS_LP"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L34  ```solidity File: contracts/governance/scripts/OperatorScripts.sol   #2  /// @audit operators[i] on line 68 69:               operatorsToImport[i] = IOperatorResolver.Operator(deployedAddress, operators[i].selector); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L69  ```solidity File: contracts/OperatorResolver.sol   #3  /// @audit operators[<etc>] on line 42 43:                   operators[names[i]].selector != destinations[i].selector ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L43  ```solidity File: contracts/OperatorResolver.sol   #4  /// @audit destinations[i] on line 42 43:                   operators[names[i]].selector != destinations[i].selector ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L43  ### 4. Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There are 2 instances of this issue:* ```solidity File: contracts/NestedFactory.sol   #1  /// @audit require() on line 428 431:                  uint256 underSpentAmount = _inputTokenAmount - amountSpent; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L431  ```solidity File: contracts/NestedFactory.sol   #2  /// @audit require() on line 495 497:                  uint256 underSpentAmount = _amountToSpend - amounts[1]; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L497  ### ~~5. `<array>.length` should not be looked up in every loop of a `for`-loop~~ The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  ~~*There are 10 instances of this issue:*~~ ```solidity File: contracts/governance/TimelockControllerEmergency.sol  84:           for (uint256 i = 0; i < proposers.length; ++i) {  89:           for (uint256 i = 0; i < executors.length; ++i) {  234:          for (uint256 i = 0; i < targets.length; ++i) {  324:          for (uint256 i = 0; i < targets.length; ++i) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L84  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  37:           for (uint256 i = 0; i < requiredOperators.length; i++) {  56:           for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  ```solidity File: contracts/OperatorResolver.sol  60:           for (uint256 i = 0; i < names.length; i++) {  75:           for (uint256 i = 0; i < destinations.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L60  ```solidity File: contracts/NestedFactory.sol  124:          for (uint256 i = 0; i < operatorsCache.length; i++) {  651:          for (uint256 i = 0; i < _batchedOrders.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  ### 6. `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There are 28 instances of this issue:* ```solidity File: contracts/operators/Beefy/BeefyVaultOperator.sol  18:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L18  ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  27:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  27:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  42:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42  ```solidity File: contracts/governance/TimelockControllerEmergency.sol  84:           for (uint256 i = 0; i < proposers.length; ++i) {  89:           for (uint256 i = 0; i < executors.length; ++i) {  234:          for (uint256 i = 0; i < targets.length; ++i) {  324:          for (uint256 i = 0; i < targets.length; ++i) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L84  ```solidity File: contracts/governance/scripts/OperatorScripts.sol  67:           for (uint256 i; i < operatorLength; i++) {  80:           for (uint256 i; i < operatorLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L67  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  37:           for (uint256 i = 0; i < requiredOperators.length; i++) {  56:           for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  ```solidity File: contracts/OperatorResolver.sol  40:           for (uint256 i = 0; i < namesLength; i++) {  60:           for (uint256 i = 0; i < names.length; i++) {  75:           for (uint256 i = 0; i < destinations.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40  ```solidity File: contracts/NestedFactory.sol  124:          for (uint256 i = 0; i < operatorsCache.length; i++) {  136:          for (uint256 i = 0; i < operatorsLength; i++) {  196:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  256:          for (uint256 i = 0; i < tokensLength; i++) {  315:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  333:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  369:          for (uint256 i = 0; i < batchLength; i++) {  412:          for (uint256 i = 0; i < batchLength; i++) {  651:          for (uint256 i = 0; i < _batchedOrders.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol  22:           for (uint256 i; i < 2; i++) {  42:           for (uint256 i; i < 3; i++) {  62:           for (uint256 i; i < 4; i++) {  86:           for (uint256 i; i < poolCoinAmount; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L22  ### 7. `require()`/`revert()` strings longer than 32 bytes cost extra gas Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**  *There are 12 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol  229:          require(targets.length == values.length, "TimelockController: length mismatch");  230:          require(targets.length == datas.length, "TimelockController: length mismatch");  243:          require(!isOperation(id), "TimelockController: operation already scheduled");  244:          require(delay >= getMinDelay(), "TimelockController: insufficient delay");  256:          require(isOperationPending(id), "TimelockController: operation cannot be cancelled");  319:          require(targets.length == values.length, "TimelockController: length mismatch");  320:          require(targets.length == datas.length, "TimelockController: length mismatch");  334:          require(isOperationReady(id), "TimelockController: operation is not ready");  335:          require(predecessor == bytes32(0) || isOperationDone(predecessor), "TimelockController: missing dependency");  342:          require(isOperationReady(id), "TimelockController: operation is not ready");  359:          require(success, "TimelockController: underlying transaction reverted");  375:          require(msg.sender == address(this), "TimelockController: caller must be timelock"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L229  ### 8. Optimize names to save gas `public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)  *There are 2 instances of this issue:* ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol   #1  /// @audit initialize() 10:   abstract contract OwnableProxyDelegation is Context { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L10  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol   #2  /// @audit resolverOperatorsRequired(), rebuildCache(), isResolverCached() 10:   abstract contract MixinOperatorResolver { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L10  ### 9. Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past  *There is 1 instance of this issue:* ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol   #1  18:       bool public initialized; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L18  ### 10. It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied Not overwriting the default for [stack variables](https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves **8 gas**. Storage and memory variables have larger savings  *There are 18 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol  84:           for (uint256 i = 0; i < proposers.length; ++i) {  89:           for (uint256 i = 0; i < executors.length; ++i) {  234:          for (uint256 i = 0; i < targets.length; ++i) {  324:          for (uint256 i = 0; i < targets.length; ++i) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L84  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  37:           for (uint256 i = 0; i < requiredOperators.length; i++) {  56:           for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  ```solidity File: contracts/OperatorResolver.sol  40:           for (uint256 i = 0; i < namesLength; i++) {  60:           for (uint256 i = 0; i < names.length; i++) {  75:           for (uint256 i = 0; i < destinations.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40  ```solidity File: contracts/NestedFactory.sol  124:          for (uint256 i = 0; i < operatorsCache.length; i++) {  136:          for (uint256 i = 0; i < operatorsLength; i++) {  196:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  256:          for (uint256 i = 0; i < tokensLength; i++) {  315:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  333:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  369:          for (uint256 i = 0; i < batchLength; i++) {  412:          for (uint256 i = 0; i < batchLength; i++) {  651:          for (uint256 i = 0; i < _batchedOrders.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  ### ~~11. `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)~~ Saves **6 gas per loop**  ~~*There are 24 instances of this issue:*~~ ```solidity File: contracts/operators/Beefy/BeefyVaultOperator.sol  18:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L18  ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  27:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  27:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  42:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42  ```solidity File: contracts/governance/scripts/OperatorScripts.sol  67:           for (uint256 i; i < operatorLength; i++) {  80:           for (uint256 i; i < operatorLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L67  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  37:           for (uint256 i = 0; i < requiredOperators.length; i++) {  56:           for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  ```solidity File: contracts/OperatorResolver.sol  40:           for (uint256 i = 0; i < namesLength; i++) {  60:           for (uint256 i = 0; i < names.length; i++) {  75:           for (uint256 i = 0; i < destinations.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40  ```solidity File: contracts/NestedFactory.sol  124:          for (uint256 i = 0; i < operatorsCache.length; i++) {  136:          for (uint256 i = 0; i < operatorsLength; i++) {  196:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  256:          for (uint256 i = 0; i < tokensLength; i++) {  315:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  333:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  369:          for (uint256 i = 0; i < batchLength; i++) {  412:          for (uint256 i = 0; i < batchLength; i++) {  651:          for (uint256 i = 0; i < _batchedOrders.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol  22:           for (uint256 i; i < 2; i++) {  42:           for (uint256 i; i < 3; i++) {  62:           for (uint256 i; i < 4; i++) {  86:           for (uint256 i; i < poolCoinAmount; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L22  ### 12. Splitting `require()` statements that use `&&` saves gas See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper  *There are 7 instances of this issue:* ```solidity File: contracts/operators/Beefy/BeefyVaultOperator.sol  54:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BVO: INVALID_AMOUNT_RECEIVED"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L54  ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  64:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED");  65:           require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  64:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED");  65:           require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64  ```solidity File: contracts/operators/Paraswap/ParaswapOperator.sol  16:           require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L16  ```solidity File: contracts/NestedFactory.sol  66            require( 67                address(_nestedAsset) != address(0) && 68                    address(_nestedRecords) != address(0) && 69                    address(_reserve) != address(0) && 70                    address(_feeSplitter) != address(0) && 71                    address(_weth) != address(0) && 72                    _operatorResolver != address(0) && 73                    address(_withdrawer) != address(0), 74                "NF: INVALID_ADDRESS" 75:           ); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L66-L75  ### 13. Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead > When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  *There are 6 instances of this issue:* ```solidity File: contracts/operators/Yearn/YearnVaultStorage.sol  8:        uint96 poolCoinAmount; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L8  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  72:           (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);  122:          (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);  166:          (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);  214:          (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);  262:          (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L72  ### 14. Using `private` rather than `public` for constants, saves gas If needed, the value can be read from the verified contract source code. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table  *There are 4 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #1  25:       bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256("TIMELOCK_ADMIN_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L25  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #2  26:       bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L26  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #3  27:       bytes32 public constant EXECUTOR_ROLE = keccak256("EXECUTOR_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L27  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #4  28:       bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L28  ### 15. Duplicated `require()`/`revert()` checks should be refactored to a modifier or function Saves deployment costs  *There are 14 instances of this issue:* ```solidity File: contracts/operators/Beefy/BeefyVaultOperator.sol  83:           require(amount != 0, "BVO: INVALID_AMOUNT");  85:           require(address(token) != address(0), "BVO: INVALID_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L83  ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  99:           require(router != address(0), "BLVO: INVALID_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L99  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  99:           require(router != address(0), "BLVO: INVALID_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L99  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  121:          require(amount != 0, "YCVO: INVALID_AMOUNT");  123:          require(pool != address(0), "YCVO: INVALID_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L121  ```solidity File: contracts/governance/TimelockControllerEmergency.sol  319:          require(targets.length == values.length, "TimelockController: length mismatch");  320:          require(targets.length == datas.length, "TimelockController: length mismatch");  342:          require(isOperationReady(id), "TimelockController: operation is not ready"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L319  ```solidity File: contracts/NestedFactory.sol  312:          require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS");  289:          require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH");  406:          require(batchLength != 0, "NF: INVALID_ORDERS"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L312  ```solidity File: contracts/libraries/StakingLPVaultHelpers.sol  138:          require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L138  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol  48:           revert("CH: INVALID_INPUT_TOKEN"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L48  ### 16. Division by two should use bit shifting `<x> / 2` is the same as `<x> >> 1`. The `DIV` opcode costs **5 gas**, whereas `SHR` only costs **3 gas**  *There are 2 instances of this issue:* ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol   #1  275:          uint256 halfInvestment = investmentA / 2; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol   #2  273:          uint256 halfInvestment = investmentA / 2; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L273  ### 17. `require()` or `revert()` statements that check input arguments should be at the top of the function Checks that involve constants should come before checks that involve state variables  *There is 1 instance of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #1  244:          require(delay >= getMinDelay(), "TimelockController: insufficient delay"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L244  ### 18. Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)  *There are 2 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #1  113:      receive() external payable {} ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L113  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol   #2  29:       function resolverOperatorsRequired() public view virtual returns (bytes32[] memory) {} ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L29  ### ~~19. Use custom errors rather than `revert()`/`require()` strings to save gas~~ Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hitby [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas  ~~*There are 132 instances of this issue:*~~ ```solidity File: contracts/operators/Beefy/BeefyVaultOperator.sol  15:           require(vaultsLength == tokens.length, "BVO: INVALID_VAULTS_LENGTH");  41:           require(amount != 0, "BVO: INVALID_AMOUNT");  43:           require(address(token) != address(0), "BVO: INVALID_VAULT");  50:           require(success, "BVO: DEPOSIT_CALL_FAILED");  54:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BVO: INVALID_AMOUNT_RECEIVED");  55:           require(amount == tokenAmount, "BVO: INVALID_AMOUNT_DEPOSITED");  83:           require(amount != 0, "BVO: INVALID_AMOUNT");  85:           require(address(token) != address(0), "BVO: INVALID_VAULT");  91:           require(success, "BVO: WITHDRAW_CALL_FAILED");  95:           require(vaultAmount == amount, "BVO: INVALID_AMOUNT_WITHDRAWED");  96:           require(tokenAmount != 0, "BVO: INVALID_AMOUNT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L15  ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  23:           require(vaultsLength == routers.length, "BLVO: INVALID_VAULTS_LENGTH");  52:           require(amountToDeposit != 0, "BLVO: INVALID_AMOUNT");  54:           require(router != address(0), "BLVO: INVALID_VAULT");  64:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED");  65:           require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED");  97:           require(amount != 0, "BLVO: INVALID_AMOUNT");  99:           require(router != address(0), "BLVO: INVALID_VAULT");  108:          require(vaultAmount == amount, "BLVO: INVALID_AMOUNT_WITHDRAWED");  109:          require(tokenAmount >= minTokenAmount, "BLVO: INVALID_OUTPUT_AMOUNT");  142:          require(token0 == token || token1 == token, "BLVO: INVALID_TOKEN");  187:          require(pair.factory() == biswapRouter.factory(), "BLVO: INVALID_VAULT");  198:          require(isInput0 || cachedToken1 == token, "BLVO: INVALID_INPUT_TOKEN");  271:          require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW");  272:          require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L23  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  23:           require(vaultsLength == routers.length, "BLVO: INVALID_VAULTS_LENGTH");  52:           require(amountToDeposit != 0, "BLVO: INVALID_AMOUNT");  54:           require(router != address(0), "BLVO: INVALID_VAULT");  64:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED");  65:           require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED");  97:           require(amount != 0, "BLVO: INVALID_AMOUNT");  99:           require(router != address(0), "BLVO: INVALID_VAULT");  108:          require(vaultAmount == amount, "BLVO: INVALID_AMOUNT_WITHDRAWED");  109:          require(tokenAmount >= minTokenAmount, "BLVO: INVALID_OUTPUT_AMOUNT");  142:          require(token0 == token || token1 == token, "BLVO: INVALID_TOKEN");  187:          require(pair.factory() == uniswapRouter.factory(), "BLVO: INVALID_VAULT");  198:          require(isInput0 || cachedToken1 == token, "BLVO: INVALID_INPUT_TOKEN");  269:          require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW");  270:          require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L23  ```solidity File: contracts/operators/Beefy/BeefyVaultStorage.sol  25:           require(vault != address(0), "BVS: INVALID_VAULT_ADDRESS");  26:           require(tokenOrZapper != address(0), "BVS: INVALID_UNDERLYING_ADDRESS");  27:           require(vaults[vault] == address(0), "BVS: ALREADY_EXISTENT_VAULT");  35:           require(vaults[vault] != address(0), "BVS: NON_EXISTENT_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L25  ```solidity File: contracts/operators/Yearn/YearnVaultStorage.sol  30:           require(vault != address(0), "YVS: INVALID_VAULT_ADDRESS");  31:           require(curvePool.poolAddress != address(0), "YVS: INVALID_POOL_ADDRESS");  32:           require(curvePool.lpToken != address(0), "YVS: INVALID_TOKEN_ADDRESS");  33:           require(vaults[vault].poolAddress == address(0), "YVS: VAULT_ALREADY_HAS_POOL");  34:           require(vaults[vault].lpToken == address(0), "YVS: VAULT_ALREADY_HAS_LP");  42:           require(vaults[vault].poolAddress != address(0), "YVS: NON_EXISTENT_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L30  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  39:           require(vaultsLength == pools.length, "YCVO: INVALID_VAULTS_LENGTH");  70:           require(amount != 0, "YCVO: INVALID_AMOUNT");  73:           require(pool != address(0), "YCVO: INVALID_VAULT");  121:          require(amount != 0, "YCVO: INVALID_AMOUNT");  123:          require(pool != address(0), "YCVO: INVALID_VAULT");  164:          require(amount != 0, "YCVO: INVALID_AMOUNT");  167:          require(pool != address(0), "YCVO: INVALID_VAULT");  212:          require(amount != 0, "YCVO: INVALID_AMOUNT");  215:          require(pool != address(0), "YCVO: INVALID_VAULT");  260:          require(amount != 0, "YCVO: INVALID_AMOUNT");  263:          require(pool != address(0), "YCVO: INVALID_VAULT"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L39  ```solidity File: contracts/operators/Paraswap/ParaswapOperator.sol  16:           require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS");  27:           require(sellToken != buyToken, "PSO: SAME_INPUT_OUTPUT");  35:           require(success, "PSO: SWAP_FAILED");  39:           require(amountBought != 0, "PSO: INVALID_AMOUNT_BOUGHT");  40:           require(amountSold != 0, "PSO: INVALID_AMOUNT_SOLD"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L16  ```solidity File: contracts/governance/OwnerProxy.sol  17:           require(_target != address(0), "OP: INVALID_TARGET"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L17  ```solidity File: contracts/governance/TimelockControllerEmergency.sol  229:          require(targets.length == values.length, "TimelockController: length mismatch");  230:          require(targets.length == datas.length, "TimelockController: length mismatch");  243:          require(!isOperation(id), "TimelockController: operation already scheduled");  244:          require(delay >= getMinDelay(), "TimelockController: insufficient delay");  256:          require(isOperationPending(id), "TimelockController: operation cannot be cancelled");  319:          require(targets.length == values.length, "TimelockController: length mismatch");  320:          require(targets.length == datas.length, "TimelockController: length mismatch");  334:          require(isOperationReady(id), "TimelockController: operation is not ready");  335:          require(predecessor == bytes32(0) || isOperationDone(predecessor), "TimelockController: missing dependency");  342:          require(isOperationReady(id), "TimelockController: operation is not ready");  359:          require(success, "TimelockController: underlying transaction reverted");  375:          require(msg.sender == address(this), "TimelockController: caller must be timelock"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L229  ```solidity File: contracts/governance/scripts/OperatorScripts.sol  19:           require(_nestedFactory != address(0), "AO-SCRIPT: INVALID_FACTORY_ADDR");  20:           require(_resolver != address(0), "AO-SCRIPT: INVALID_RESOLVER_ADDR");  29:           require(operator.implementation != address(0), "AO-SCRIPT: INVALID_IMPL_ADDRESS");  54:           require(operatorLength != 0, "DAO-SCRIPT: INVALID_OPERATOR_LEN");  55:           require(bytecode.length != 0, "DAO-SCRIPT: BYTECODE_ZERO");  61:           require(deployedAddress != address(0), "DAO-SCRIPT: FAILED_DEPLOY"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L19  ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol  25:           require(ownerAddr != address(0), "OPD: INVALID_ADDRESS");  26:           require(!initialized, "OPD: INITIALIZED");  27:           require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, "OPD: FORBIDDEN");  41:           require(owner() == _msgSender(), "OPD: NOT_OWNER");  57:           require(newOwner != address(0), "OPD: INVALID_ADDRESS"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L25  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  23:           require(_resolver != address(0), "MOR: INVALID_ADDRESS");  77:           require(_foundAddress.implementation != address(0), string(abi.encodePacked("MOR: MISSING_OPERATOR: ", name)));  103:              require(tokens[0] == _outputToken, "MOR: INVALID_OUTPUT_TOKEN");  104:              require(tokens[1] == _inputToken, "MOR: INVALID_INPUT_TOKEN"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L23  ```solidity File: contracts/OperatorResolver.sol  27:           require(_foundOperator.implementation != address(0), reason);  39:           require(namesLength == destinations.length, "OR: INPUTS_LENGTH_MUST_MATCH");  57:           require(names.length == operatorsToImport.length, "OR: INPUTS_LENGTH_MUST_MATCH"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L27  ```solidity File: contracts/Withdrawer.sol  21:           require(msg.sender == address(weth), "WD: ETH_SENDER_NOT_WETH"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L21  ```solidity File: contracts/NestedFactory.sol  66            require( 67                address(_nestedAsset) != address(0) && 68                    address(_nestedRecords) != address(0) && 69                    address(_reserve) != address(0) && 70                    address(_feeSplitter) != address(0) && 71                    address(_weth) != address(0) && 72                    _operatorResolver != address(0) && 73                    address(_withdrawer) != address(0), 74                "NF: INVALID_ADDRESS" 75:           );  99:           require(nestedAsset.ownerOf(_nftId) == _msgSender(), "NF: CALLER_NOT_OWNER");  107:          require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), "NF: LOCKED_NFT");  122:          require(operator != bytes32(""), "NF: INVALID_OPERATOR_NAME");  125:              require(operatorsCache[i] != operator, "NF: EXISTENT_OPERATOR");  153:          require(address(_feeSplitter) != address(0), "NF: INVALID_FEE_SPLITTER_ADDRESS");  160:          require(_entryFees != 0, "NF: ZERO_FEES");  161:          require(_entryFees <= 10000, "NF: FEES_OVERFLOW");  168:          require(_exitFees != 0, "NF: ZERO_FEES");  169:          require(_exitFees <= 10000, "NF: FEES_OVERFLOW");  191:          require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS");  250:          require(_orders.length != 0, "NF: INVALID_ORDERS");  251:          require(tokensLength == _orders.length, "NF: INPUTS_LENGTH_MUST_MATCH");  252:          require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH");  286:          require(assetTokensLength > _tokenIndex, "NF: INVALID_TOKEN_INDEX");  288:          require(assetTokensLength > 1, "NF: UNALLOWED_EMPTY_PORTFOLIO");  289:          require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH");  312:          require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS");  313:          require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH");  330:          require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS");  331:          require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH");  359:          require(batchLength != 0, "NF: INVALID_ORDERS");  379:          require(amountSpent <= _inputTokenAmount - feesAmount, "NF: OVERSPENT");  406:          require(batchLength != 0, "NF: INVALID_ORDERS");  407:          require(_batchedOrders.amounts.length == batchLength, "NF: INPUTS_LENGTH_MUST_MATCH");  428:              require(amountSpent <= _inputTokenAmount, "NF: OVERSPENT");  469:          require(success, "NF: OPERATOR_CALL_FAILED");  495:              require(amounts[1] <= _amountToSpend, "NF: OVERSPENT");  543:              require(!_fromReserve, "NF: NO_ETH_FROM_RESERVE");  544:              require(address(this).balance >= _inputTokenAmount, "NF: INVALID_AMOUNT_IN");  551               require( 552                   nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount, 553                   "NF: INSUFFICIENT_AMOUNT_IN" 554:              );  612:              require(success, "NF: ETH_TRANSFER_ERROR");  656:          require(msg.value == ethNeeded, "NF: WRONG_MSG_VALUE"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L66-L75  ```solidity File: contracts/libraries/StakingLPVaultHelpers.sol  108:          require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED");  138:          require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L108  ### 20. Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 27 instances of this issue:* ```solidity File: contracts/operators/Beefy/BeefyVaultStorage.sol  24:       function addVault(address vault, address tokenOrZapper) external onlyOwner {  34:       function removeVault(address vault) external onlyOwner { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L24  ```solidity File: contracts/operators/Yearn/YearnVaultStorage.sol  29:       function addVault(address vault, CurvePool calldata curvePool) external onlyOwner {  41:       function removeVault(address vault) external onlyOwner { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L29  ```solidity File: contracts/governance/OwnerProxy.sol  16:       function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L16  ```solidity File: contracts/governance/TimelockControllerEmergency.sol  199       function schedule( 200           address target, 201           uint256 value, 202           bytes calldata data, 203           bytes32 predecessor, 204           bytes32 salt, 205           uint256 delay 206:      ) public virtual onlyRole(PROPOSER_ROLE) {  221       function scheduleBatch( 222           address[] calldata targets, 223           uint256[] calldata values, 224           bytes[] calldata datas, 225           bytes32 predecessor, 226           bytes32 salt, 227           uint256 delay 228:      ) public virtual onlyRole(PROPOSER_ROLE) {  255:      function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {  274       function execute( 275           address target, 276           uint256 value, 277           bytes calldata data, 278           bytes32 predecessor, 279           bytes32 salt 280:      ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {  295       function executeEmergency( 296           address target, 297           uint256 value, 298           bytes calldata data 299:      ) public payable onlyRole(EMERGENCY_ROLE) {  312       function executeBatch( 313           address[] calldata targets, 314           uint256[] calldata values, 315           bytes[] calldata datas, 316           bytes32 predecessor, 317           bytes32 salt 318:      ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L199-L206  ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol  50:       function renounceOwnership() public virtual onlyOwner {  56:       function transferOwnership(address newOwner) public virtual onlyOwner { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L50  ```solidity File: contracts/OperatorResolver.sol  52        function importOperators( 53            bytes32[] calldata names, 54            Operator[] calldata operatorsToImport, 55            MixinOperatorResolver[] calldata destinations 56:       ) external override onlyOwner {  74:       function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L52-L56  ```solidity File: contracts/NestedFactory.sol  121:      function addOperator(bytes32 operator) external override onlyOwner {  133:      function removeOperator(bytes32 operator) external override onlyOwner {  152:      function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {  159:      function setEntryFees(uint256 _entryFees) external override onlyOwner {  167:      function setExitFees(uint256 _exitFees) external override onlyOwner {  175:      function unlockTokens(IERC20 _token) external override onlyOwner {  205       function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) 206           external 207           payable 208           override 209           nonReentrant 210           onlyTokenOwner(_nftId) 211:          isUnlocked(_nftId)  219       function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) 220           external 221           override 222           nonReentrant 223           onlyTokenOwner(_nftId) 224:          isUnlocked(_nftId)  231       function processInputAndOutputOrders( 232           uint256 _nftId, 233           BatchedInputOrders[] calldata _batchedInputOrders, 234           BatchedOutputOrders[] calldata _batchedOutputOrders 235:      ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {  243       function destroy( 244           uint256 _nftId, 245           IERC20 _buyToken, 246           Order[] calldata _orders 247:      ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {  278       function withdraw(uint256 _nftId, uint256 _tokenIndex) 279           external 280           override 281           nonReentrant 282           onlyTokenOwner(_nftId) 283:          isUnlocked(_nftId)  301:      function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L121  ### 21. Don't use `_msgSender()` if not supporting EIP-2771 Use `msg.sender` if the code does not implement [EIP-2771 trusted forwarder](https://eips.ethereum.org/EIPS/eip-2771) support  *There are 13 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol  77:           _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());  105:              _checkRole(role, _msgSender()); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L77  ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol  41:           require(owner() == _msgSender(), "OPD: NOT_OWNER"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L41  ```solidity File: contracts/NestedFactory.sol  99:           require(nestedAsset.ownerOf(_nftId) == _msgSender(), "NF: CALLER_NOT_OWNER");  194:          uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);  269:              _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());  274:          nestedAsset.burn(_msgSender(), _nftId);  294:          _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);  341:                  _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());  383:                  SafeERC20.safeTransfer(tokenSold, _fromReserve ? address(reserve) : _msgSender(), underSpentAmount);  499:                      _safeTransferWithFees(IERC20(_inputToken), underSpentAmount, _msgSender(), _nftId);  503:              _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);  558:              SafeERC20.safeTransferFrom(_inputToken, _msgSender(), address(this), _inputTokenAmount); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L99  
## Unlimited allowance is very dangerous  Nested finance use unlimited allowance in all contract that sent some token  contracts/libraries/ExchangeHelpers.sol ```         address _swapTarget,         bytes memory _swapCallData     ) internal returns (bool) {         setMaxAllowance(_sellToken, _swapTarget);     /// @param _token The token to use for the allowance setting     /// @param _spender Spender to allow     function setMaxAllowance(IERC20 _token, address _spender) internal { ```  contracts/mocks/DummyRouter.sol ```         NestedFactory(factory).destroy(nftId, IERC20(address(weth)), attackOrders);     }      function setMaxAllowance(IERC20 _token, address _spender) external {         ExchangeHelpers.setMaxAllowance(_token, _spender);     }      function setAllowance( ```  contracts/libraries/StakingLPVaultHelpers.sol ```         uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;         ExchangeHelpers.setMaxAllowance(lpToken, vault);         uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));         ExchangeHelpers.setMaxAllowance(IERC20(token), address(pool));          if (poolCoinAmount == 2) { ```  contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol ```             tokenAmountIn = amount1;         }          ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);          address[] memory path = new address[](2);         require(pair.factory() == biswapRouter.factory(), "BLVO: INVALID_VAULT");          ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vault)); ```  contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol ```             swapToken = token1;             tokenAmountIn = amount1;         }          ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);         require(pair.factory() == uniswapRouter.factory(), "BLVO: INVALID_VAULT");          ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vault));          address cachedToken0 = pair.token0(); ```  contracts/operators/Paraswap/ParaswapOperator.sol ```         ExchangeHelpers.setMaxAllowance(sellToken, tokenTransferProxy);         (bool success, ) = augustusSwapper.call(swapCallData); ```  contracts/operators/Beefy/BeefyVaultOperator.sol ```         uint256 tokenBalanceBefore = token.balanceOf(address(this));          ExchangeHelpers.setMaxAllowance(token, vault); ```  contracts/operators/Yearn/YearnCurveVaultOperator.sol ```         uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));         uint256 ethBalanceBefore = weth.balanceOf(address(this));          ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer)); ```  contracts/NestedFactory.sol ```     ) private {         address originalOwner = nestedAsset.originalOwner(_nftId);         ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));             ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));             withdrawer.withdraw(_amount); ```  If a contract that has max allowance is malicious, it may steal all tokens in the allowing contract. For example, if feeSplitter is malicious, it may steal all tokens in NestedFactory  ## poolCoinAmount validation  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol  poolCoinAmount must be 2, 3, 4 so, if it not fall in this range it should be reverted but now it doesn't  On every functions in this file add  ``` if (poolCoinAmount < 2 || poolCoinAmount > 4) revert ```  Change code to  ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.14;  import "./../Withdrawer.sol"; import "./../libraries/ExchangeHelpers.sol"; import "./../libraries/CurveHelpers/CurveHelpers.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./../interfaces/external/ICurvePool/ICurvePool.sol"; import "./../interfaces/external/ICurvePool/ICurvePoolETH.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "./../interfaces/external/IStakingVault/IStakingVault.sol"; import "./../interfaces/external/ICurvePool/ICurvePoolNonETH.sol";  error InvalidPoolCoinAmount(uint256 poolCoinAmount);  /// @notice Library for LP Staking Vaults deposit/withdraw library StakingLPVaultHelpers {     using SafeERC20 for IERC20;      /// @dev  Add liquidity in a Curve pool with ETH and deposit     ///       the LP token in a staking vault     /// @param vault The staking vault address to deposit into     /// @param pool The Curve pool to add liquitiy in     /// @param lpToken The Curve pool LP token     /// @param poolCoinAmount The number of token in the Curve pool     /// @param eth ETH address     /// @param amount ETH amount to add in the Curve pool     function _addLiquidityAndDepositETH(         address vault,         ICurvePoolETH pool,         IERC20 lpToken,         uint256 poolCoinAmount,         address eth,         uint256 amount     ) internal {         if (poolCoinAmount < 2 || poolCoinAmount > 4) revert InvalidPoolCoinAmount(poolCoinAmount);          uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));          if (poolCoinAmount == 2) {             pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts2Coins(pool, eth, amount), 0);         } else if (poolCoinAmount == 3) {             pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts3Coins(pool, eth, amount), 0);         } else {             pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts4Coins(pool, eth, amount), 0);         }          uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;         ExchangeHelpers.setMaxAllowance(lpToken, vault);         IStakingVault(vault).deposit(lpTokenToDeposit);     }      /// @dev  Add liquidity in a Curve pool and deposit     ///       the LP token in a staking vault     /// @param vault The staking vault address to deposit into     /// @param pool The Curve pool to add liquitiy in     /// @param lpToken The Curve pool lpToken     /// @param poolCoinAmount The number of token in the Curve pool     /// @param token Token to add in the Curve pool liquidity     /// @param amount Token amount to add in the Curve pool     function _addLiquidityAndDeposit(         address vault,         ICurvePoolNonETH pool,         IERC20 lpToken,         uint256 poolCoinAmount,         address token,         uint256 amount     ) internal {         if (poolCoinAmount < 2 || poolCoinAmount > 4) revert InvalidPoolCoinAmount(poolCoinAmount);          uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));         ExchangeHelpers.setMaxAllowance(IERC20(token), address(pool));          if (poolCoinAmount == 2) {             pool.add_liquidity(CurveHelpers.getAmounts2Coins(pool, token, amount), 0);         } else if (poolCoinAmount == 3) {             pool.add_liquidity(CurveHelpers.getAmounts3Coins(pool, token, amount), 0);         } else {             pool.add_liquidity(CurveHelpers.getAmounts4Coins(pool, token, amount), 0);         }          uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;         ExchangeHelpers.setMaxAllowance(lpToken, vault);         IStakingVault(vault).deposit(lpTokenToDeposit);     }      /// @dev Withdraw the LP token from the staking vault and     ///      remove the liquidity from the Curve pool     /// @param vault The staking vault address to withdraw from     /// @param amount The amount to withdraw     /// @param pool The Curve pool to remove liquitiy from     /// @param lpToken The Curve pool LP token     /// @param poolCoinAmount The number of token in the Curve pool     /// @param outputToken Output token to receive     function _withdrawAndRemoveLiquidity128(         address vault,         uint256 amount,         ICurvePool pool,         IERC20 lpToken,         uint256 poolCoinAmount,         address outputToken     ) internal {         if (poolCoinAmount < 2 || poolCoinAmount > 4) revert InvalidPoolCoinAmount(poolCoinAmount);          uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));         IStakingVault(vault).withdraw(amount);          bool success = CurveHelpers.removeLiquidityOneCoin(             pool,             lpToken.balanceOf(address(this)) - lpTokenBalanceBefore,             outputToken,             poolCoinAmount,             bytes4(keccak256(bytes("remove_liquidity_one_coin(uint256,int128,uint256)")))         );          require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED");     }      /// @dev Withdraw the LP token from the staking vault and     ///      remove the liquidity from the Curve pool     /// @param vault The staking vault address to withdraw from     /// @param amount The amount to withdraw     /// @param pool The Curve pool to remove liquitiy from     /// @param lpToken The Curve pool LP token     /// @param poolCoinAmount The number of token in the Curve pool     /// @param outputToken Output token to receive     function _withdrawAndRemoveLiquidity256(         address vault,         uint256 amount,         ICurvePool pool,         IERC20 lpToken,         uint256 poolCoinAmount,         address outputToken     ) internal {         if (poolCoinAmount < 2 || poolCoinAmount > 4) revert InvalidPoolCoinAmount(poolCoinAmount);          uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));         IStakingVault(vault).withdraw(amount);          bool success = CurveHelpers.removeLiquidityOneCoin(             pool,             lpToken.balanceOf(address(this)) - lpTokenBalanceBefore,             outputToken,             poolCoinAmount,             bytes4(keccak256(bytes("remove_liquidity_one_coin(uint256,uint256,uint256)")))         );          require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED");     } } ```  ## @openzeppelin/contracts should be updated to ^4.4.2 as ^4.3.2 has many vulnerables  https://github.com/code-423n4/2022-06-nested/blob/main/package.json is using  ``` "@openzeppelin/contracts": "^4.3.2", ```  @openzeppelin/contracts 4.3.2 has these vulnerabilities from https://snyk.io/vuln/npm:%40openzeppelin%2Fcontracts  - Function Call With Incorrect Argument - Deserialization of Untrusted Data - Numeric Errors - Improper Initialization - Improper Input Validation  You should update @openzeppelin/contracts to ^4.4.2 to avoid these vulnerabilities.
### Add `namesLength > 0` check in `areOperatorsImported()` method  - `areOperatorsImported()` in [OperatorResolver.sol#L32-L49](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L32-L49) returns `true` when input arrays are empty (ie. `[]`, `[]`).  ```solidity function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)     external     view     override     returns (bool) {     uint256 namesLength = names.length;     require(namesLength == destinations.length, "OR: INPUTS_LENGTH_MUST_MATCH");     for (uint256 i = 0; i < namesLength; i++) {         if (             operators[names[i]].implementation != destinations[i].implementation ||             operators[names[i]].selector != destinations[i].selector         ) {             return false;         }     }     return true; } ``` #### Recommendation  ```solidity require(namesLength > 0 "empty names/destinations"); ```
## 1. Can save gas when call `_submitOutOrders()` with `_toReserve = false`  In case `_toReserve = false`, it still calculates `feesAmount` using `entryFees` but do not use the result anywhere. We can save gas by calculating `feesAmount` only when `_toReserve = true`  ## Affected Code  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443  ## Recommended Mitigation Steps  Only calculate `feesAmount` only when `_toReserve = true`  ``` if (_toReserve) {  feesAmount = (amountBought * entryFees) / 10000; _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId); } ```  
## [N-01] Libraries, interfaces, and external imports can be ordered nicely E.g. group all libraries first, then interfaces, then OZ imports  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L4-L12
1. The require statements could be put at the beginning part of a block of statements if it doesn’t affect the logic to save gas. a. [require(_orders.length != 0, "NF: INVALID_ORDERS");]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L250")   2. Initializing i to 0 inside a for loop is redundant. As its initialized to 0 by default.  Also i++ or ++I in the for loops can be put inside an unchecked block to save gas.   a. [for (uint256 i = 0; i < operatorsCache.length; i++) ]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L124") b. [for (uint256 i = 0; i < operatorsLength; i++) ]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L136") c. [for (uint256 i = 0; i < batchedOrdersLength; i++)]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L196") d. [for (uint256 i = 0; i < tokensLength; i++)](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L256") e. [for (uint256 i = 0; i < batchedOrdersLength; i++)]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L315") f. [for (uint256 i = 0; i < batchedOrdersLength; i++)]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L333") g. [for (uint256 i = 0; i < batchLength; i++)]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L369") h. [ for (uint256 i = 0; i < batchLength; i++)]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L412") i. [for (uint256 i = 0; i < _batchedOrders.length; i++)]("https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L651") j. [for (uint256 i = 0; i < namesLength; i++) ](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L40”) k. [for (uint256 i = 0; i < names.length; i++)](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L60”) l. [for (uint256 i = 0; i < destinations.length; i++) ](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L75”) m. [  for (uint256 i = 0; i < requiredOperators.length; i++)](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L37”) n. [  for (uint256 i = 0; i < requiredOperators.length; i++)](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L56”) o. [for (uint256 i = 0; i < targets.length; ++i)](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L234”) p. [for (uint256 i = 0; i < targets.length; ++i)](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L324”)   3. Unless it was introduced for readability saving memory to memory is redundant. [address token = tokens[i];](“https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L257”)   4. These arithmetic operations can be unchecked. a. [ uint256 halfInvestment = investmentA / 2;](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275”) b. [uint256 halfInvestment = investmentA / 2;](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L273”)   5. This line could be pre-computed and defined as a constant to save gas. a. [bytes4(keccak256(bytes("remove_liquidity_one_coin(uint256,int128,uint256)")))](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L105”) b. [bytes4(keccak256(bytes("remove_liquidity_one_coin(uint256,uint256,uint256)")))](“https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L135”) 
## State variables that could be set immutable  In the following files there are state variables that could be set immutable to save gas.   ### Code instance:          operator in TestableOperatorCaller.sol    ## Unused state variables  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instances:          WETHMock.sol, symbol         WETHMock.sol, decimals         TestableMixingOperatorResolver.sol, addressesToCache         WETHMock.sol, name    ## Unused declared local variables  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instances:          NestedAssetBatcher.sol, getNfts, amounts         NestedAssetBatcher.sol, getNfts, nftAssets         TestableOperatorCaller.sol, performSwap, data    ## Unnecessary array boundaries check when loading an array element twice       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:       ### Code instances:          NestedFactory.sol._processOutputOrders - double load of _batchedOrders[i]         NestedFactory.sol._processInputOrders - double load of _batchedOrders[i]    ## Caching array length can save gas   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }   ### Code instances:          MixinOperatorResolver.sol, requiredOperators, 56         OperatorResolver.sol, destinations, 75         MixinOperatorResolver.sol, requiredOperators, 37         FeeSplitter.sol, _tokens, 147         TimelockControllerEmergency.sol, targets, 234         FeeSplitter.sol, shareholders, 316         TimelockControllerEmergency.sol, targets, 324         NestedFactory.sol, _batchedOrders, 651         FeeSplitter.sol, _tokens, 164         TimelockControllerEmergency.sol, proposers, 84         OperatorResolver.sol, names, 60         TimelockControllerEmergency.sol, executors, 89         NestedFactory.sol, operatorsCache, 124         FeeSplitter.sol, shareholdersCache, 278         FeeSplitter.sol, shareholders, 259    ## Prefix increments are cheaper than postfix increments  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:   ### Code instances:          change to prefix increment and unchecked: OperatorScripts.sol, i, 67         change to prefix increment and unchecked: OperatorScripts.sol, i, 80         change to prefix increment and unchecked: FeeSplitter.sol, i, 278         change to prefix increment and unchecked: MixinOperatorResolver.sol, i, 56    ## Unnecessary index init   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:  ### Code instances:          NestedFactory.sol, 315         OperatorResolver.sol, 75         NestedFactory.sol, 333         NestedFactory.sol, 196         FeeSplitter.sol, 259    ## Rearrange state variables  You can change the order of the storage variables to decrease memory uses.  ### Code instance:  In OwnableProxyDelegation.sol,rearranging the storage fields can optimize to: 2 slots from: 3 slots. The new order of types (you choose the actual variables):         1. bytes32         2. address         3. bool     ## Use bytes32 instead of string to save gas whenever possible       Use bytes32 instead of string to save gas whenever possible.     String is a dynamic data structure and therefore is more gas consuming then bytes32.       ### Code instances:          WETHMock.sol (L25), string public symbol = "WETH";         WETHMock.sol (L24), string public name = "Wrapped Ether";    ## Short the following require messages  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:   ### Code instances:          Solidity file: TimelockControllerEmergency.sol, In line 320, Require message length to shorten: 35, The message: TimelockController: length mismatch         Solidity file: TimelockControllerEmergency.sol, In line 244, Require message length to shorten: 38, The message: TimelockController: insufficient delay         Solidity file: TimelockControllerEmergency.sol, In line 229, Require message length to shorten: 35, The message: TimelockController: length mismatch         Solidity file: TimelockControllerEmergency.sol, In line 335, Require message length to shorten: 38, The message: TimelockController: missing dependency         Solidity file: TimelockControllerEmergency.sol, In line 319, Require message length to shorten: 35, The message: TimelockController: length mismatch         Solidity file: TimelockControllerEmergency.sol, In line 230, Require message length to shorten: 35, The message: TimelockController: length mismatch    ## Use != 0 instead of > 0   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)   ### Code instances:          WETHMock.sol, 71: change 'balance > 0' to 'balance != 0'         NestedFactory.sol, 544: change 'balance > 0' to 'balance != 0'         WETHMock.sol, 46: change 'balance > 0' to 'balance != 0'    ## Unnecessary cast        ### Code instance:          IERC20 DummyRouter.sol.dummyswapToken - unnecessary casting IERC20(_inputToken)    ## Use unchecked to save gas for certain additive calculations that cannot overflow   You can use unchecked in the following calculations since there is no risk to overflow:  ### Code instance:          TimelockControllerEmergency.sol (L#245) - _timestamps[id] = block.timestamp + delay;    ## Empty else statement can be removed to save gas           Empty else statement can be removed to save gas.               ### Code instance:          StakingLPVaultHelpers.sol._addLiquidityAndDepositETH    ## Empty else if statement can be removed to save gas           Empty else if statement can be removed to save gas by simply doing the following:                  if (a) {             some code 1         }         else if (b) {             empty         } else {             some code 2         }                  change this pattern to:         if (a) {             some code 1         }         else if (!b) {             some code 2         }                ### Code instance:          StakingLPVaultHelpers.sol._addLiquidityAndDepositETH    ## Consider inline the following functions to save gas       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               NestedAsset.sol, _baseURI, { return baseUri; }    ## Inline one time use functions   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.       ### Code instances:          BeefyZapUniswapLPVaultOperator.sol, _swapAndAddLiquidity         MixinOperatorResolver.sol, requireAndGetAddress         NestedBuybacker.sol, trigger         BeefyZapBiswapLPVaultOperator.sol, _swapAndAddLiquidity         ExchangeHelpers.sol, setMaxAllowance         FeeSplitter.sol, _addShareholder         BeefyZapUniswapLPVaultOperator.sol, _zapAndStakeLp         BeefyZapUniswapLPVaultOperator.sol, _withdrawAndSwap         BeefyZapBiswapLPVaultOperator.sol, _zapAndStakeLp         BeefyZapBiswapLPVaultOperator.sol, _withdrawAndSwap   
**Table of Contents:**  - [1. Cheap Contract Deployment Through Clones](#1-cheap-contract-deployment-through-clones) - [2. Reduce the size of error messages (Long revert Strings)](#2-reduce-the-size-of-error-messages-long-revert-strings) - [3. Splitting `require()` statements that use `&&` saves gas](#3-splitting-require-statements-that-use--saves-gas) - [4. Using private rather than public for constants saves gas](#4-using-private-rather-than-public-for-constants-saves-gas) - [5. Use shift right/left instead of division/multiplication if possible](#5-use-shift-rightleft-instead-of-divisionmultiplication-if-possible) - [6. `<array>.length` should not be looked up in every loop of a `for-loop`](#6-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop) - [7. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)](#7-i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1) - [8. Increments/decrements can be unchecked in for-loops](#8-incrementsdecrements-can-be-unchecked-in-for-loops) - [9. It costs more gas to initialize variables with their default value than letting the default value be applied](#9-it-costs-more-gas-to-initialize-variables-with-their-default-value-than-letting-the-default-value-be-applied) - [10. Use Custom Errors instead of Revert Strings to save Gas](#10-use-custom-errors-instead-of-revert-strings-to-save-gas) - [11. Functions guaranteed to revert when called by normal users can be marked `payable`](#11-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable)  ## 1. Cheap Contract Deployment Through Clones  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:25:        operatorStorage = new BeefyVaultStorage(); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:25:        operatorStorage = new BeefyVaultStorage(); operators/Yearn/YearnCurveVaultOperator.sol:40:        operatorStorage = new YearnVaultStorage(); ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  I suggest applying a similar pattern.  ## 2. Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity governance/TimelockControllerEmergency.sol:229:        require(targets.length == values.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:230:        require(targets.length == datas.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:243:        require(!isOperation(id), "TimelockController: operation already scheduled"); governance/TimelockControllerEmergency.sol:244:        require(delay >= getMinDelay(), "TimelockController: insufficient delay"); governance/TimelockControllerEmergency.sol:256:        require(isOperationPending(id), "TimelockController: operation cannot be cancelled"); governance/TimelockControllerEmergency.sol:319:        require(targets.length == values.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:320:        require(targets.length == datas.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:334:        require(isOperationReady(id), "TimelockController: operation is not ready"); governance/TimelockControllerEmergency.sol:335:        require(predecessor == bytes32(0) || isOperationDone(predecessor), "TimelockController: missing dependency"); governance/TimelockControllerEmergency.sol:342:        require(isOperationReady(id), "TimelockController: operation is not ready"); governance/TimelockControllerEmergency.sol:359:        require(success, "TimelockController: underlying transaction reverted"); governance/TimelockControllerEmergency.sol:375:        require(msg.sender == address(this), "TimelockController: caller must be timelock"); ```  I suggest shortening the revert strings to fit in 32 bytes.  ## 3. Splitting `require()` statements that use `&&` saves gas  If you're using the Optimizer at 200, instead of using the `&&` operator in a single require statement to check multiple conditions, I suggest using multiple require statements with 1 condition per require statement:  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:64:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:65:        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:64:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:65:        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED"); operators/Beefy/BeefyVaultOperator.sol:54:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BVO: INVALID_AMOUNT_RECEIVED"); operators/Paraswap/ParaswapOperator.sol:16:        require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS"); NestedFactory.sol:67:            address(_nestedAsset) != address(0) && NestedFactory.sol:68:                address(_nestedRecords) != address(0) && NestedFactory.sol:69:                address(_reserve) != address(0) && NestedFactory.sol:70:                address(_feeSplitter) != address(0) && NestedFactory.sol:71:                address(_weth) != address(0) && NestedFactory.sol:72:                _operatorResolver != address(0) && ```  Please, note that this might not hold true at a higher number of runs for the Optimizer (10k). However, it indeed is true at 200.  ## 4. Using private rather than public for constants saves gas  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  ```solidity governance/TimelockControllerEmergency.sol:25:    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256("TIMELOCK_ADMIN_ROLE"); governance/TimelockControllerEmergency.sol:26:    bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE"); governance/TimelockControllerEmergency.sol:27:    bytes32 public constant EXECUTOR_ROLE = keccak256("EXECUTOR_ROLE"); governance/TimelockControllerEmergency.sol:28:    bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");  ```  ## 5. Use shift right/left instead of division/multiplication if possible  While the `DIV` / `MUL` opcode uses 5 gas, the `SHR` / `SHL` opcode only uses 3 gas. Furthermore, beware that Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting. Eventually, overflow checks are never performed for shift operations as they are done for arithmetic operations. Instead, the result is always truncated.  - Use `>> 1` instead of `/ 2` - Use `>> 2` instead of `/ 4` - Use `<< 3` instead of `* 8`  Affected code:  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:275:        uint256 halfInvestment = investmentA / 2; operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:273:        uint256 halfInvestment = investmentA / 2; ```  ## 6. `<array>.length` should not be looked up in every loop of a `for-loop`  Reading array length at each iteration of the loop consumes more gas than necessary.    In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Here, I suggest storing the array's length in a variable before the for-loop, and use this new variable instead:  ```solidity abstracts/MixinOperatorResolver.sol:37:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts/MixinOperatorResolver.sol:56:        for (uint256 i = 0; i < requiredOperators.length; i++) { governance/TimelockControllerEmergency.sol:84:        for (uint256 i = 0; i < proposers.length; ++i) { governance/TimelockControllerEmergency.sol:89:        for (uint256 i = 0; i < executors.length; ++i) { governance/TimelockControllerEmergency.sol:234:        for (uint256 i = 0; i < targets.length; ++i) { governance/TimelockControllerEmergency.sol:324:        for (uint256 i = 0; i < targets.length; ++i) { NestedFactory.sol:124:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:651:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  ## 7. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)  Pre-increments and pre-decrements are cheaper.  For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1` - `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)  **Decrement:**  - `i -= 1` is the most expensive form - `i--` costs 11 gas less than `i -= 1` - `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:  ```solidity uint i = 1;   uint j = 2; require(j == i++, "This will be false as i is incremented after the comparison"); ```    However, pre-increments (or pre-decrements) return the new value:    ```solidity uint i = 1;   uint j = 2; require(j == ++i, "This will be true as i is incremented before the comparison"); ```    In the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.      Affected code:    ```solidity abstracts/MixinOperatorResolver.sol:37:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts/MixinOperatorResolver.sol:56:        for (uint256 i = 0; i < requiredOperators.length; i++) { governance/scripts/OperatorScripts.sol:67:        for (uint256 i; i < operatorLength; i++) { governance/scripts/OperatorScripts.sol:80:        for (uint256 i; i < operatorLength; i++) { libraries/CurveHelpers/CurveHelpers.sol:22:        for (uint256 i; i < 2; i++) { libraries/CurveHelpers/CurveHelpers.sol:42:        for (uint256 i; i < 3; i++) { libraries/CurveHelpers/CurveHelpers.sol:62:        for (uint256 i; i < 4; i++) { libraries/CurveHelpers/CurveHelpers.sol:86:        for (uint256 i; i < poolCoinAmount; i++) { operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:27:        for (uint256 i; i < vaultsLength; i++) { operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:27:        for (uint256 i; i < vaultsLength; i++) { operators/Beefy/BeefyVaultOperator.sol:18:        for (uint256 i; i < vaultsLength; i++) { operators/Yearn/YearnCurveVaultOperator.sol:42:        for (uint256 i; i < vaultsLength; i++) { utils/NestedAssetBatcher.sol:45:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:60:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:74:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:79:                for (uint256 j; j < tokenLength; j++) { NestedFactory.sol:124:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:136:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:196:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:256:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:315:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:333:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:412:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:651:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  Consider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).  ## 8. Increments/decrements can be unchecked in for-loops  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Affected code:    ```solidity abstracts/MixinOperatorResolver.sol:37:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts/MixinOperatorResolver.sol:56:        for (uint256 i = 0; i < requiredOperators.length; i++) { governance/scripts/OperatorScripts.sol:67:        for (uint256 i; i < operatorLength; i++) { governance/scripts/OperatorScripts.sol:80:        for (uint256 i; i < operatorLength; i++) { governance/TimelockControllerEmergency.sol:84:        for (uint256 i = 0; i < proposers.length; ++i) { governance/TimelockControllerEmergency.sol:89:        for (uint256 i = 0; i < executors.length; ++i) { governance/TimelockControllerEmergency.sol:234:        for (uint256 i = 0; i < targets.length; ++i) { governance/TimelockControllerEmergency.sol:324:        for (uint256 i = 0; i < targets.length; ++i) { libraries/CurveHelpers/CurveHelpers.sol:22:        for (uint256 i; i < 2; i++) { libraries/CurveHelpers/CurveHelpers.sol:42:        for (uint256 i; i < 3; i++) { libraries/CurveHelpers/CurveHelpers.sol:62:        for (uint256 i; i < 4; i++) { libraries/CurveHelpers/CurveHelpers.sol:86:        for (uint256 i; i < poolCoinAmount; i++) { operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:27:        for (uint256 i; i < vaultsLength; i++) { operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:27:        for (uint256 i; i < vaultsLength; i++) { operators/Beefy/BeefyVaultOperator.sol:18:        for (uint256 i; i < vaultsLength; i++) { operators/Yearn/YearnCurveVaultOperator.sol:42:        for (uint256 i; i < vaultsLength; i++) { utils/NestedAssetBatcher.sol:45:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:60:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:74:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:79:                for (uint256 j; j < tokenLength; j++) { NestedFactory.sol:124:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:136:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:196:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:256:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:315:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:333:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:412:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:651:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  The change would be:      ```diff - for (uint256 i; i < numIterations; i++) { + for (uint256 i; i < numIterations;) {  // ...   +   unchecked { ++i; } }   ```  The same can be applied with decrements (which should use `break` when `i == 0`).  The risk of overflow is non-existant for `uint256` here.  ## 9. It costs more gas to initialize variables with their default value than letting the default value be applied  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Affected code:  ```solidity abstracts/MixinOperatorResolver.sol:37:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts/MixinOperatorResolver.sol:56:        for (uint256 i = 0; i < requiredOperators.length; i++) { governance/TimelockControllerEmergency.sol:84:        for (uint256 i = 0; i < proposers.length; ++i) { governance/TimelockControllerEmergency.sol:89:        for (uint256 i = 0; i < executors.length; ++i) { governance/TimelockControllerEmergency.sol:234:        for (uint256 i = 0; i < targets.length; ++i) { governance/TimelockControllerEmergency.sol:324:        for (uint256 i = 0; i < targets.length; ++i) { NestedFactory.sol:124:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:136:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:196:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:256:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:315:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:333:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:412:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:651:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  I suggest removing explicit initializations for default values.  ## 10. Use Custom Errors instead of Revert Strings to save Gas  Solidity 0.8.4 introduced custom errors. They are more gas efficient than revert strings, when it comes to deploy cost as well as runtime cost when the revert condition is met. Use custom errors instead of revert strings for gas savings.  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Consider replacing all revert strings with custom errors in the solution.  ```solidity abstracts/MixinOperatorResolver.sol:23:        require(_resolver != address(0), "MOR: INVALID_ADDRESS"); abstracts/MixinOperatorResolver.sol:77:        require(_foundAddress.implementation != address(0), string(abi.encodePacked("MOR: MISSING_OPERATOR: ", name))); abstracts/MixinOperatorResolver.sol:103:            require(tokens[0] == _outputToken, "MOR: INVALID_OUTPUT_TOKEN"); abstracts/MixinOperatorResolver.sol:104:            require(tokens[1] == _inputToken, "MOR: INVALID_INPUT_TOKEN"); abstracts/OwnableProxyDelegation.sol:25:        require(ownerAddr != address(0), "OPD: INVALID_ADDRESS"); abstracts/OwnableProxyDelegation.sol:26:        require(!initialized, "OPD: INITIALIZED"); abstracts/OwnableProxyDelegation.sol:27:        require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, "OPD: FORBIDDEN"); abstracts/OwnableProxyDelegation.sol:41:        require(owner() == _msgSender(), "OPD: NOT_OWNER"); abstracts/OwnableProxyDelegation.sol:57:        require(newOwner != address(0), "OPD: INVALID_ADDRESS"); governance/scripts/OperatorScripts.sol:19:        require(_nestedFactory != address(0), "AO-SCRIPT: INVALID_FACTORY_ADDR"); governance/scripts/OperatorScripts.sol:20:        require(_resolver != address(0), "AO-SCRIPT: INVALID_RESOLVER_ADDR"); governance/scripts/OperatorScripts.sol:29:        require(operator.implementation != address(0), "AO-SCRIPT: INVALID_IMPL_ADDRESS"); governance/scripts/OperatorScripts.sol:54:        require(operatorLength != 0, "DAO-SCRIPT: INVALID_OPERATOR_LEN"); governance/scripts/OperatorScripts.sol:55:        require(bytecode.length != 0, "DAO-SCRIPT: BYTECODE_ZERO"); governance/scripts/OperatorScripts.sol:61:        require(deployedAddress != address(0), "DAO-SCRIPT: FAILED_DEPLOY"); governance/OwnerProxy.sol:17:        require(_target != address(0), "OP: INVALID_TARGET"); governance/TimelockControllerEmergency.sol:229:        require(targets.length == values.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:230:        require(targets.length == datas.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:243:        require(!isOperation(id), "TimelockController: operation already scheduled"); governance/TimelockControllerEmergency.sol:244:        require(delay >= getMinDelay(), "TimelockController: insufficient delay"); governance/TimelockControllerEmergency.sol:256:        require(isOperationPending(id), "TimelockController: operation cannot be cancelled"); governance/TimelockControllerEmergency.sol:319:        require(targets.length == values.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:320:        require(targets.length == datas.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:334:        require(isOperationReady(id), "TimelockController: operation is not ready"); governance/TimelockControllerEmergency.sol:335:        require(predecessor == bytes32(0) || isOperationDone(predecessor), "TimelockController: missing dependency"); governance/TimelockControllerEmergency.sol:342:        require(isOperationReady(id), "TimelockController: operation is not ready"); governance/TimelockControllerEmergency.sol:359:        require(success, "TimelockController: underlying transaction reverted"); governance/TimelockControllerEmergency.sol:375:        require(msg.sender == address(this), "TimelockController: caller must be timelock"); libraries/StakingLPVaultHelpers.sol:108:        require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED"); libraries/StakingLPVaultHelpers.sol:138:        require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:23:        require(vaultsLength == routers.length, "BLVO: INVALID_VAULTS_LENGTH"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:52:        require(amountToDeposit != 0, "BLVO: INVALID_AMOUNT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:54:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:64:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:65:        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:97:        require(amount != 0, "BLVO: INVALID_AMOUNT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:99:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:108:        require(vaultAmount == amount, "BLVO: INVALID_AMOUNT_WITHDRAWED"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:109:        require(tokenAmount >= minTokenAmount, "BLVO: INVALID_OUTPUT_AMOUNT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:142:        require(token0 == token || token1 == token, "BLVO: INVALID_TOKEN"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:187:        require(pair.factory() == biswapRouter.factory(), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:198:        require(isInput0 || cachedToken1 == token, "BLVO: INVALID_INPUT_TOKEN"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:271:        require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:272:        require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:23:        require(vaultsLength == routers.length, "BLVO: INVALID_VAULTS_LENGTH"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:52:        require(amountToDeposit != 0, "BLVO: INVALID_AMOUNT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:54:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:64:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BLVO: INVALID_AMOUNT_RECEIVED"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:65:        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, "BLVO: INVALID_AMOUNT_DEPOSITED"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:97:        require(amount != 0, "BLVO: INVALID_AMOUNT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:99:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:108:        require(vaultAmount == amount, "BLVO: INVALID_AMOUNT_WITHDRAWED"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:109:        require(tokenAmount >= minTokenAmount, "BLVO: INVALID_OUTPUT_AMOUNT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:142:        require(token0 == token || token1 == token, "BLVO: INVALID_TOKEN"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:187:        require(pair.factory() == uniswapRouter.factory(), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:198:        require(isInput0 || cachedToken1 == token, "BLVO: INVALID_INPUT_TOKEN"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:269:        require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:270:        require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); operators/Beefy/BeefyVaultOperator.sol:15:        require(vaultsLength == tokens.length, "BVO: INVALID_VAULTS_LENGTH"); operators/Beefy/BeefyVaultOperator.sol:41:        require(amount != 0, "BVO: INVALID_AMOUNT"); operators/Beefy/BeefyVaultOperator.sol:43:        require(address(token) != address(0), "BVO: INVALID_VAULT"); operators/Beefy/BeefyVaultOperator.sol:50:        require(success, "BVO: DEPOSIT_CALL_FAILED"); operators/Beefy/BeefyVaultOperator.sol:54:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, "BVO: INVALID_AMOUNT_RECEIVED"); operators/Beefy/BeefyVaultOperator.sol:55:        require(amount == tokenAmount, "BVO: INVALID_AMOUNT_DEPOSITED"); operators/Beefy/BeefyVaultOperator.sol:83:        require(amount != 0, "BVO: INVALID_AMOUNT"); operators/Beefy/BeefyVaultOperator.sol:85:        require(address(token) != address(0), "BVO: INVALID_VAULT"); operators/Beefy/BeefyVaultOperator.sol:91:        require(success, "BVO: WITHDRAW_CALL_FAILED"); operators/Beefy/BeefyVaultOperator.sol:95:        require(vaultAmount == amount, "BVO: INVALID_AMOUNT_WITHDRAWED"); operators/Beefy/BeefyVaultOperator.sol:96:        require(tokenAmount != 0, "BVO: INVALID_AMOUNT"); operators/Beefy/BeefyVaultStorage.sol:25:        require(vault != address(0), "BVS: INVALID_VAULT_ADDRESS"); operators/Beefy/BeefyVaultStorage.sol:26:        require(tokenOrZapper != address(0), "BVS: INVALID_UNDERLYING_ADDRESS"); operators/Beefy/BeefyVaultStorage.sol:27:        require(vaults[vault] == address(0), "BVS: ALREADY_EXISTENT_VAULT"); operators/Beefy/BeefyVaultStorage.sol:35:        require(vaults[vault] != address(0), "BVS: NON_EXISTENT_VAULT"); operators/Paraswap/ParaswapOperator.sol:16:        require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS"); operators/Paraswap/ParaswapOperator.sol:27:        require(sellToken != buyToken, "PSO: SAME_INPUT_OUTPUT"); operators/Paraswap/ParaswapOperator.sol:35:        require(success, "PSO: SWAP_FAILED"); operators/Paraswap/ParaswapOperator.sol:39:        require(amountBought != 0, "PSO: INVALID_AMOUNT_BOUGHT"); operators/Paraswap/ParaswapOperator.sol:40:        require(amountSold != 0, "PSO: INVALID_AMOUNT_SOLD"); operators/Yearn/YearnCurveVaultOperator.sol:39:        require(vaultsLength == pools.length, "YCVO: INVALID_VAULTS_LENGTH"); operators/Yearn/YearnCurveVaultOperator.sol:70:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:73:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:121:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:123:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:164:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:167:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:212:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:215:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:260:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:263:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnVaultStorage.sol:30:        require(vault != address(0), "YVS: INVALID_VAULT_ADDRESS"); operators/Yearn/YearnVaultStorage.sol:31:        require(curvePool.poolAddress != address(0), "YVS: INVALID_POOL_ADDRESS"); operators/Yearn/YearnVaultStorage.sol:32:        require(curvePool.lpToken != address(0), "YVS: INVALID_TOKEN_ADDRESS"); operators/Yearn/YearnVaultStorage.sol:33:        require(vaults[vault].poolAddress == address(0), "YVS: VAULT_ALREADY_HAS_POOL"); operators/Yearn/YearnVaultStorage.sol:34:        require(vaults[vault].lpToken == address(0), "YVS: VAULT_ALREADY_HAS_LP"); operators/Yearn/YearnVaultStorage.sol:42:        require(vaults[vault].poolAddress != address(0), "YVS: NON_EXISTENT_VAULT"); utils/NestedAssetBatcher.sol:94:            require(nestedAsset.lastOwnerBeforeBurn(_nftId) != address(0), "NAB: NEVER_CREATED"); NestedFactory.sol:66:        require( NestedFactory.sol:99:        require(nestedAsset.ownerOf(_nftId) == _msgSender(), "NF: CALLER_NOT_OWNER"); NestedFactory.sol:107:        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), "NF: LOCKED_NFT"); NestedFactory.sol:122:        require(operator != bytes32(""), "NF: INVALID_OPERATOR_NAME"); NestedFactory.sol:125:            require(operatorsCache[i] != operator, "NF: EXISTENT_OPERATOR"); NestedFactory.sol:153:        require(address(_feeSplitter) != address(0), "NF: INVALID_FEE_SPLITTER_ADDRESS"); NestedFactory.sol:160:        require(_entryFees != 0, "NF: ZERO_FEES"); NestedFactory.sol:161:        require(_entryFees <= 10000, "NF: FEES_OVERFLOW"); NestedFactory.sol:168:        require(_exitFees != 0, "NF: ZERO_FEES"); NestedFactory.sol:169:        require(_exitFees <= 10000, "NF: FEES_OVERFLOW"); NestedFactory.sol:191:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:250:        require(_orders.length != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:251:        require(tokensLength == _orders.length, "NF: INPUTS_LENGTH_MUST_MATCH"); NestedFactory.sol:252:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:286:        require(assetTokensLength > _tokenIndex, "NF: INVALID_TOKEN_INDEX"); NestedFactory.sol:288:        require(assetTokensLength > 1, "NF: UNALLOWED_EMPTY_PORTFOLIO"); NestedFactory.sol:289:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:312:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:313:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:330:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:331:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:359:        require(batchLength != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:379:        require(amountSpent <= _inputTokenAmount - feesAmount, "NF: OVERSPENT"); NestedFactory.sol:406:        require(batchLength != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:407:        require(_batchedOrders.amounts.length == batchLength, "NF: INPUTS_LENGTH_MUST_MATCH"); NestedFactory.sol:428:            require(amountSpent <= _inputTokenAmount, "NF: OVERSPENT"); NestedFactory.sol:469:        require(success, "NF: OPERATOR_CALL_FAILED"); NestedFactory.sol:495:            require(amounts[1] <= _amountToSpend, "NF: OVERSPENT"); NestedFactory.sol:543:            require(!_fromReserve, "NF: NO_ETH_FROM_RESERVE"); NestedFactory.sol:544:            require(address(this).balance >= _inputTokenAmount, "NF: INVALID_AMOUNT_IN"); NestedFactory.sol:551:            require( NestedFactory.sol:612:            require(success, "NF: ETH_TRANSFER_ERROR"); NestedFactory.sol:656:        require(msg.value == ethNeeded, "NF: WRONG_MSG_VALUE"); OperatorResolver.sol:27:        require(_foundOperator.implementation != address(0), reason); OperatorResolver.sol:39:        require(namesLength == destinations.length, "OR: INPUTS_LENGTH_MUST_MATCH"); OperatorResolver.sol:57:        require(names.length == operatorsToImport.length, "OR: INPUTS_LENGTH_MUST_MATCH"); Withdrawer.sol:21:        require(msg.sender == address(weth), "WD: ETH_SENDER_NOT_WETH"); ```  ## 11. Functions guaranteed to revert when called by normal users can be marked `payable`  If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.  ```solidity operators/Beefy/BeefyVaultStorage.sol:24:    function addVault(address vault, address tokenOrZapper) external onlyOwner { operators/Beefy/BeefyVaultStorage.sol:34:    function removeVault(address vault) external onlyOwner { operators/Yearn/YearnVaultStorage.sol:29:    function addVault(address vault, CurvePool calldata curvePool) external onlyOwner { operators/Yearn/YearnVaultStorage.sol:41:    function removeVault(address vault) external onlyOwner { NestedFactory.sol:121:    function addOperator(bytes32 operator) external override onlyOwner { NestedFactory.sol:133:    function removeOperator(bytes32 operator) external override onlyOwner { NestedFactory.sol:152:    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner { NestedFactory.sol:159:    function setEntryFees(uint256 _entryFees) external override onlyOwner { NestedFactory.sol:167:    function setExitFees(uint256 _exitFees) external override onlyOwner { NestedFactory.sol:175:    function unlockTokens(IERC20 _token) external override onlyOwner { OperatorResolver.sol:56:    ) external override onlyOwner { OperatorResolver.sol:74:    function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner { ``` 
**Overview** Risk Rating | Number of issues --- | --- Low Risk | 6 Non-Critical Risk | 4  **Table of Contents**  - [Low Risk Issues](#low-risk-issues)   - [1. Known vulnerabilities exist in currently used `@openzeppelin/contracts` version](#1-known-vulnerabilities-exist-in-currently-used-openzeppelincontracts-version)   - [2. Missing address(0) checks](#2-missing-address0-checks)   - [3. `OwnableProxyDelegation.initialize()` is front-runnable in the solution](#3-ownableproxydelegationinitialize-is-front-runnable-in-the-solution)   - [4. Use a `constant` instead of duplicating the same string](#4-use-a-constant-instead-of-duplicating-the-same-string)   - [5. Funds can be locked](#5-funds-can-be-locked)   - [6. A magic number should be documented and explained. Use a `constant` instead](#6-a-magic-number-should-be-documented-and-explained-use-a-constant-instead) - [Non-Critical Issues](#non-critical-issues)   - [1. It's better to emit after all processing is done](#1-its-better-to-emit-after-all-processing-is-done)   - [2. Typos](#2-typos)   - [3. Adding a `return` statement when the function defines a named return variable, is redundant](#3-adding-a-return-statement-when-the-function-defines-a-named-return-variable-is-redundant)   - [4. `public` functions not called by the contract should be declared `external` instead](#4-public-functions-not-called-by-the-contract-should-be-declared-external-instead)  # Low Risk Issues  ## 1. Known vulnerabilities exist in currently used `@openzeppelin/contracts` version  As some [known vulnerabilities](https://snyk.io/test/npm/@openzeppelin/contracts/4.3.2) exist in the current `@openzeppelin/contracts` version, consider updating `package.json` with at least `@openzeppelin/contracts@4.4.2` here:  <https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/package.json#L65>  ```json         "@openzeppelin/contracts": "^4.3.2", ```  While vulnerabilities are known, the current scope isn't affected (this might not hold true for the whole solution)  ## 2. Missing address(0) checks  Consider adding an `address(0)` check for immutable variables:  ```solidity operators/Yearn/YearnCurveVaultOperator.sol:23:    address public immutable eth; operators/Yearn/YearnCurveVaultOperator.sol:26:    IWETH private immutable weth; operators/Yearn/YearnCurveVaultOperator.sol:29:    Withdrawer private immutable withdrawer; utils/NestedAssetBatcher.sol:19:    INestedAsset public immutable nestedAsset; utils/NestedAssetBatcher.sol:20:    INestedRecords public immutable nestedRecords; Withdrawer.sol:14:    IWETH public immutable weth; ```  ## 3. `OwnableProxyDelegation.initialize()` is front-runnable in the solution  I suggest adding some access control or atomically initializing the contract:  <https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L24-L32>  ```solidity File: OwnableProxyDelegation.sol 24:     function initialize(address ownerAddr) external { 25:         require(ownerAddr != address(0), "OPD: INVALID_ADDRESS"); 26:         require(!initialized, "OPD: INITIALIZED"); 27:         require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, "OPD: FORBIDDEN"); 28:  29:         _setOwner(ownerAddr); 30:  31:         initialized = true; 32:     } ```  ## 4. Use a `constant` instead of duplicating the same string  ```solidity abstracts/OwnableProxyDelegation.sol:25:        require(ownerAddr != address(0), "OPD: INVALID_ADDRESS"); abstracts/OwnableProxyDelegation.sol:57:        require(newOwner != address(0), "OPD: INVALID_ADDRESS"); ```  ```solidity governance/TimelockControllerEmergency.sol:229:        require(targets.length == values.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:230:        require(targets.length == datas.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:319:        require(targets.length == values.length, "TimelockController: length mismatch"); governance/TimelockControllerEmergency.sol:320:        require(targets.length == datas.length, "TimelockController: length mismatch"); ```  ```solidity governance/TimelockControllerEmergency.sol:334:        require(isOperationReady(id), "TimelockController: operation is not ready"); governance/TimelockControllerEmergency.sol:342:        require(isOperationReady(id), "TimelockController: operation is not ready"); ```  ```solidity libraries/CurveHelpers/CurveHelpers.sol:28:        revert("CH: INVALID_INPUT_TOKEN"); libraries/CurveHelpers/CurveHelpers.sol:48:        revert("CH: INVALID_INPUT_TOKEN"); libraries/CurveHelpers/CurveHelpers.sol:68:        revert("CH: INVALID_INPUT_TOKEN"); ```  ```solidity libraries/StakingLPVaultHelpers.sol:108:        require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED"); libraries/StakingLPVaultHelpers.sol:138:        require(success, "SDCSO: CURVE_RM_LIQUIDITY_FAILED"); ```  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:52:        require(amountToDeposit != 0, "BLVO: INVALID_AMOUNT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:97:        require(amount != 0, "BLVO: INVALID_AMOUNT"); ```  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:54:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:99:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:187:        require(pair.factory() == biswapRouter.factory(), "BLVO: INVALID_VAULT"); ```  ```solidity operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:97:        require(amount != 0, "BLVO: INVALID_AMOUNT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:52:        require(amountToDeposit != 0, "BLVO: INVALID_AMOUNT"); ```  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:271:        require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:272:        require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); ```  ```solidity operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:54:        require(router != address(0), "BLVO: INVALID_VAULT"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:99:        require(router != address(0), "BLVO: INVALID_VAULT"); ```  ```solidity operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:269:        require(reserveA > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:270:        require(reserveB > 1000, "BLVO: PAIR_RESERVE_TOO_LOW"); ```  ```solidity operators/Beefy/BeefyVaultOperator.sol:41:        require(amount != 0, "BVO: INVALID_AMOUNT"); operators/Beefy/BeefyVaultOperator.sol:83:        require(amount != 0, "BVO: INVALID_AMOUNT"); operators/Beefy/BeefyVaultOperator.sol:96:        require(tokenAmount != 0, "BVO: INVALID_AMOUNT"); ```  ```solidity operators/Beefy/BeefyVaultOperator.sol:43:        require(address(token) != address(0), "BVO: INVALID_VAULT"); operators/Beefy/BeefyVaultOperator.sol:85:        require(address(token) != address(0), "BVO: INVALID_VAULT"); ```  ```solidity operators/Yearn/YearnCurveVaultOperator.sol:70:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:121:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:164:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:212:        require(amount != 0, "YCVO: INVALID_AMOUNT"); operators/Yearn/YearnCurveVaultOperator.sol:260:        require(amount != 0, "YCVO: INVALID_AMOUNT"); ```  ```solidity operators/Yearn/YearnCurveVaultOperator.sol:73:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:123:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:167:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:215:        require(pool != address(0), "YCVO: INVALID_VAULT"); operators/Yearn/YearnCurveVaultOperator.sol:263:        require(pool != address(0), "YCVO: INVALID_VAULT"); ```  ```solidity NestedFactory.sol:160:        require(_entryFees != 0, "NF: ZERO_FEES"); NestedFactory.sol:168:        require(_exitFees != 0, "NF: ZERO_FEES"); ```  ```solidity NestedFactory.sol:161:        require(_entryFees <= 10000, "NF: FEES_OVERFLOW"); NestedFactory.sol:169:        require(_exitFees <= 10000, "NF: FEES_OVERFLOW"); ```  ```solidity NestedFactory.sol:191:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:312:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:330:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); ```  ```solidity NestedFactory.sol:250:        require(_orders.length != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:359:        require(batchLength != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:406:        require(batchLength != 0, "NF: INVALID_ORDERS"); ```  ```solidity NestedFactory.sol:251:        require(tokensLength == _orders.length, "NF: INPUTS_LENGTH_MUST_MATCH"); NestedFactory.sol:407:        require(_batchedOrders.amounts.length == batchLength, "NF: INPUTS_LENGTH_MUST_MATCH"); ```  ```solidity NestedFactory.sol:252:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:289:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:313:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:331:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); ```  ```solidity NestedFactory.sol:379:        require(amountSpent <= _inputTokenAmount - feesAmount, "NF: OVERSPENT"); NestedFactory.sol:428:            require(amountSpent <= _inputTokenAmount, "NF: OVERSPENT"); NestedFactory.sol:495:            require(amounts[1] <= _amountToSpend, "NF: OVERSPENT"); ```  ```solidity OperatorResolver.sol:39:        require(namesLength == destinations.length, "OR: INPUTS_LENGTH_MUST_MATCH"); OperatorResolver.sol:57:        require(names.length == operatorsToImport.length, "OR: INPUTS_LENGTH_MUST_MATCH"); ```  ## 5. Funds can be locked  There isn't a withdraw mechanism and several payable methods are implemented:  - BeefyZapBiswapLPVaultOperator.sol:  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:51:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { ```  - YearnCurveVaultOperator.sol:  ```solidity operators/Yearn/YearnCurveVaultOperator.sol:69:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { operators/Yearn/YearnCurveVaultOperator.sol:120:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { operators/Yearn/YearnCurveVaultOperator.sol:163:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { operators/Yearn/YearnCurveVaultOperator.sol:211:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { operators/Yearn/YearnCurveVaultOperator.sol:259:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { ```  ## 6. A magic number should be documented and explained. Use a `constant` instead  *Similar issue in the past: [here](https://github.com/code-423n4/2021-04-marginswap-findings/issues/71)*  - 1:  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:240:            1, operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:251:            1, operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:252:            1, operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:240:            1, operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:251:            1, operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:252:            1, ```  - 10000:  ```solidity NestedFactory.sol:378:        feesAmount = (amountSpent * entryFees) / 10000; // Entry Fees NestedFactory.sol:443:            feesAmount = (amountBought * (_toReserve ? entryFees : exitFees)) / 10000; ```  I suggest using `constant` variables as this would make the code more maintainable and readable while costing nothing gas-wise (constants are replaced by their value at compile-time).  # Non-Critical Issues  ## 1. It's better to emit after all processing is done  - <https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L374-L378> :  ```solidity contracts/governance/TimelockControllerEmergency.sol:   374      function updateDelay(uint256 newDelay) external virtual {   375          require(msg.sender == address(this), "TimelockController: caller must be timelock");   376:         emit MinDelayChange(_minDelay, newDelay);   377          _minDelay = newDelay;   378      } ```  ## 2. Typos  - datas vs data  ```solidity abstracts/MixinOperatorResolver.sol:81:    /// @dev Build the calldata (with safe datas) and call the Operator ```  - setted vs set  ```solidity - abstracts/OwnableProxyDelegation.sol:17:    /// @dev True if the owner is setted + abstracts/OwnableProxyDelegation.sol:17:    /// @dev True if the owner is set ```  - liquitiy vs liquidity  ```solidity libraries/StakingLPVaultHelpers.sol:21:    /// @param pool The Curve pool to add liquitiy in libraries/StakingLPVaultHelpers.sol:52:    /// @param pool The Curve pool to add liquitiy in libraries/StakingLPVaultHelpers.sol:85:    /// @param pool The Curve pool to remove liquitiy from libraries/StakingLPVaultHelpers.sol:115:    /// @param pool The Curve pool to remove liquitiy from ```  - WITHDRAWED vs WITHDREW or WITHDRAWN  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:108:        require(vaultAmount == amount, "BLVO: INVALID_AMOUNT_WITHDRAWED"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:108:        require(vaultAmount == amount, "BLVO: INVALID_AMOUNT_WITHDRAWED"); operators/Beefy/BeefyVaultOperator.sol:95:        require(vaultAmount == amount, "BVO: INVALID_AMOUNT_WITHDRAWED"); NestedFactory.sol:51:    /// @dev Fees when funds are withdrawed NestedFactory.sol:639:    /// @return The withdrawed amount from the reserve ```  - dont vs don't  ```solidity NestedFactory.sol:477:    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail. ```  - transfered vs transferred  ```solidity NestedFactory.sol:534:    /// @return Token transfered (in case of ETH) ```  ## 3. Adding a `return` statement when the function defines a named return variable, is redundant  While not consuming more gas with the Optimizer enabled: using both named returns and a return statement isn't necessary. Removing one of those can improve code clarity.  Affected code:  ```solidity contracts/governance/TimelockControllerEmergency.sol:   119:     function isOperation(bytes32 id) public view virtual returns (bool pending) {   126:     function isOperationPending(bytes32 id) public view virtual returns (bool pending) {   133:     function isOperationReady(bytes32 id) public view virtual returns (bool ready) {   141:     function isOperationDone(bytes32 id) public view virtual returns (bool done) {   149:     function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {   158:     function getMinDelay() public view virtual returns (uint256 duration) {  contracts/libraries/CurveHelpers/CurveHelpers.sol:   21:     ) internal view returns (uint256[2] memory amounts) {   41:     ) internal view returns (uint256[3] memory amounts) {   61:     ) internal view returns (uint256[4] memory amounts) {   85:     ) internal returns (bool success) { ```  ## 4. `public` functions not called by the contract should be declared `external` instead  ```solidity governance/OwnerProxy.sol:16:    function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) { ``` 
#1 Use require instead &&  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L66  use require instead of && for efficient gas cost. change it from                require(             address(_nestedAsset) != address(0) &&                 address(_nestedRecords) != address(0) &&                 address(_reserve) != address(0) &&                 address(_feeSplitter) != address(0) &&                 address(_weth) != address(0) &&                 _operatorResolver != address(0) &&                 address(_withdrawer) != address(0),             "NF: INVALID_ADDRESS"         );  to                require(address(_nestedAsset) != address(0),"NF: INVALID_ADDRESS");               require(address(_nestedRecords) != address(0),"NF: INVALID_ADDRESS");               require(address(_reserve) != address(0),"NF: INVALID_ADDRESS");               require(address(_feeSplitter) != address(0),"NF: INVALID_ADDRESS");               require(address(_weth) != address(0),"NF: INVALID_ADDRESS");               require( _operatorResolver != address(0),"NF: INVALID_ADDRESS");               require(address(_withdrawer) != address(0),"NF: INVALID_ADDRESS");  #2 Change to storage  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L123  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L248  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L466  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L52  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L101  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L33  Use storage instead of  memory to reduce the gas fee.                bytes32[] memory operatorsCache = operators;  to                bytes32[] storage operatorsCache = operators;  apply to others.   #3 Looping  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L651  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L56  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L234  default uint is 0 so remove unnecassary explicit can reduce gas. caching the array length can reduce gas it caused access to a local variable is more cheap than query storage / calldata / memory in solidity. pre increment ++i more cheaper gas than post increment i++. i suggest to use pre increment.  #4 Default value and increment  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L136  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L196  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L315  default uint is 0 so remove unnecassary explicit can reduce gas pre increment ++i more cheaper gas than post increment i++. i suggest to use pre increment.  #5 Inequality  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L286  non strict inequality are cheaper than strict one. i suggest to use >= or <= instead of > and < if possible.  #6 Caching names.length  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L57  caching the names.length can reduce gas it caused access to a local variable is more cheap than query storage / calldata / memory in solidity and it use twice.  #7 Cache the cacheTmp.implementation  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L62-L64  cache the cacheTmp.implementation to the memory for reduce the gas fee because it use multiple times.  #8 Use calldata  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L93  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L13  In the external functions where the function argument is read-only, the function() has an inputed parameter that using memory, if this function didnt change the parameter, its cheaper to use calldata then memory. so we suggest to change it.  #9 Division  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275  A division by 2 can be calculated by shifting one to the right. The div opcode used 5 gas and  SHR opcode used 3 gas. Solidity's division operation also includes a division-by-0 prevention by pass using shifting. so i suggest to use >>1.  #10 Sort struct  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L6-L9  shorting the struct can reduce gas cost, so change it from      struct CurvePool {     address poolAddress;     uint96 poolCoinAmount;     address lpToken; to      struct CurvePool {     uint96 poolCoinAmount;     address poolAddress;     address lpToken;  #11 Short the string  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L243-L244  reduce size of string error message to bytes32 for cheap gas if possible.  #12 Caching the targets.length  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L319-L320  caching the targets.length can reduce gas it caused access to a local variable is more cheap than query storage / calldata / memory in solidity and it use twice.          require(targets.length == values.length, "TimelockController: length mismatch");         require(targets.length == datas.length, "TimelockController: length mismatch");  i suggest to add uint256 _targets = targets.length;               uint256 _targets = targets.length;         require(_targets == values.length, "TimelockController: length mismatch");         require(_targets == datas.length, "TimelockController: length mismatch"); 
 ## Impact  By default, function types and state variables/constants are internal, so the internal keyword can be omitted.  Affected code: 1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L20 2. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L15 3. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L29  ## Proof of Concept      ## Tools Used      ## Recommended Mitigation Steps  --- ## Impact  Consider using IERC20 type instead of address. Or IERC20[] type instead of address[].  Affected code: 1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L248 2. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L257 3. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L291 4. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L371 5. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L422 6. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L423 7. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L460 8. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L461 9. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L487 10. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L488 11. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L587 12. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L640 13. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L91 14. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L92 15. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L101 16. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L19 17. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L39 18. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L59 19. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L82 20. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L62 21. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L95 22. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L125 23. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L24 24. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L133 25. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L140 26. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L141 27. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L153 28. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L181 29. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L191 30. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L192 31. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L133 32. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L140 33. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L141 34. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L153 35. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L181 36. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L191 37. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L192 38. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L11 39. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L117 40. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L226 41. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L274 42. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L9  ## Proof of Concept      ## Tools Used      ## Recommended Mitigation Steps  --- ## Impact  Consider using "_" separate digit capacity i.e "100000" could be replaced to "100_000". This increases code readability.  Affected code: 1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L264 2. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L378 3. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443 4. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L629  ## Proof of Concept      ## Tools Used      ## Recommended Mitigation Steps  ---
## NestedFactory.sol  ### transferToReserveAndStore: balanceReserveAfter can be inlined  In the `_transferToReserveAndStore` function, we store the reserve balance after the transfer in the `balanceReserveAfter` variable, on line [523](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/NestedFactory.sol#L523).  This variable being only used once, we can inline it and save one mstore.  Recommendation:  ``` nestedRecords.store(_nftId, address(_token), _token.balanceOf(reserveAddr) - balanceReserveBefore, reserveAddr); ```  ## TimelockControllerEmergency.sol  ### scheduleBatch: targets.length should be stored in a variable  In the `scheduleBatch` function on line [221](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/governance/TimelockControllerEmergency.sol#L221), we call `targets.length` to compare the targets length and also to loop through the targets and emit the `CallScheduled` event.  For a better code legibility and also to save some mload, targets length should be stored in a variable.  Recommendation:  ``` uint256 _targetsLength = targets.length;  require(targetsLength == values.length, "TimelockController: length mismatch"); require(targetsLength == datas.length, "TimelockController: length mismatch");  bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt); schedule(id, delay); for (uint256 i = 0; i < targetsLength; ++i) {   emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay); } ```  ### executeBatch: targets.length should be stored in a variable  In the `executeBatch` function on line [312](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/governance/TimelockControllerEmergency.sol#L312), we call `targets.length` to compare the targets length and also to loop through the targets and call the `_call` function.  For a better code legibility and also to save some mload, targets length should be stored in a variable.  Recommendation:  ``` uint256 _targetsLength = targets.length;  require(_targetsLength == values.length, "TimelockController: length mismatch"); require(_targetsLength == datas.length, "TimelockController: length mismatch");  bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt); _beforeCall(id, predecessor); for (uint256 i = 0; i < _targetsLength; ++i) {     _call(id, i, targets[i], values[i], datas[i]); } _afterCall(id); ``` 
Typos  The same typo (`withdrawed`) occurs in all five lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L51  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L639  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L95  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L108  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L108  Example:  ```solidity     /// @dev Fees when funds are withdrawed ``` Change `withdrawed` to `withdrawn` in all cases   https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L534 ```solidity     /// @return Token transfered (in case of ETH) ``` Change `transfered` to `transferred`   https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L17 ```solidity     /// @dev True if the owner is setted ``` Change `setted` to `set`   The same typo (`liquitiy`) occurs in all four lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L21  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L52  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L85  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L115  Example:  ```solidity     /// @param pool The Curve pool to add liquitiy in ``` Change `liquitiy` to `liquidity` in each case   The same typo (`orders`) occurs in both lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L346  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L393  ```solidity     /// @dev For every orders, call the operator with the calldata ``` Change `orders` to `order` in both cases   The same typo (`store`) occurs in both lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L397  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L457  ```solidity     /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not. ``` Change `store` to `stored` in both cases   https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L477 ```solidity     /// @dev Call the operator to submit the order but dont stop if the call to the operator fail. ``` Change `fail` to `fails`    https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L8 ```solidity /// @notice Resolve the operators address ``` For clarity, either replace `the operators` with `operator` or else use the actual variable name   https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/ExchangeHelpers.sol#L26 ```solidity     /// @dev sets the allowance for a token to the maximum if it is not already at max ``` For clarity and consistency, capitalize `sets`   The same typo (`token`) occurs in all six lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L83  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L124  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L128  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L83  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L124  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L128  Example:  ```solidity     /// @param token One of the paired token ``` Change `token` to `tokens` in each case   The same typo (`needs`) occurs in both lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L144  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L144  ```solidity         // LP Tokens needs to be sent back to the pair address to be burned ``` Change `needs` to `need` in both cases   The same typo (`allows to add`) occurs in both lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L260  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L260  ```solidity     ///         This allows to add as many tokensA and tokensB as possible ``` Change `allows to add` to `allows us to add` in both cases
# 1 . unused imports  ( its already imported) Ierc20 is already imported in  Inestedfactory.sol Feespliter.sol is already imported Inestedfactory.sol NestedReverse.sol is already imprted Insteadfactory.sol [NestedFactory:6]( https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L6) [NestedFactory:12]( https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L12) safeerc20 imports Ierc20 so you can take out Ierc20 when you import safeerc20.sol [NestedFactory:13]( https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L13) IOperatorResolver.sol is already imported in MixinOperatorResolver.sol take out IOperatorResolver.sol from OperatorResolver.sol [OperatorResolver:4](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L4) https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L10 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L10 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Paraswap/ParaswapOperator.sol#L6 safeerc20.sol is already in exchangehelper.sol https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L10   # 2. Change your imports  ex: import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; instead do your imports like this  import {Ierc20,safeer20} from "import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/NestedFactory.sol#L5 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L10  # 3. no check that address can be zero in array of address  no check that token of i can be zero   address token = tokens[i]; instances:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L257 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/BeefyVaultOperator.sol#L18 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L28   # 4. make  success variable in call function a check in a require statement . instead of a if statment where if success is  false it will just skip execution not revert.  make         if (success)  into:  require(success)   to make sure the call dosnt fail   https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/NestedFactory.sol#L518     # 5. initialize function should have onlyowner modifer anyone can front run the initialize call and become owner. If the initializer is not executed in the same transaction as the constructor, a malicious user can front-run the initialize() call, forcing the contract to be redeployed ex: function initialize(address ownerAddr) external { https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/abstracts/OwnableProxyDelegation.sol#L24  # 6. no check on success variable , if the call function fails bool success  variable should be  checked  with a require statement  if not logic can brake and cause loss of funds https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/libraries/ExchangeHelpers.sol#L22  # 7.typos  instead of : liquitiy  use : liquidity  https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L52  https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L85  https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L115  # 8. Event is missing indexed fields  each event should use three indexed fields if there are there or more fields https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/governance/TimelockControllerEmergency.sol#L50 
## _minDelay can be 0, beating timelock motive  Contract: https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L93  Issue: In constructor, deployer can set _minDelay to 0 which means any proposed transaction can instantly be executed without any delay which beats the basic motive of timelock  Recommendation: Add a check to ensure correct value of _minDelay  ``` require(_minDelay!=0, "Incorrect delay"); ```  ## Missing selector check on operator  Contract: https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/scripts/OperatorScripts.sol#L28 https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L20  Issue: The addOperator function is not checking that selector of added operator is not bytes4(0) Same fix is required for requireAndGetOperator function at OperatorResolver.sol#L20  Recommendation: Add below check  ``` require(operator.selector != bytes4(0), "AO-SCRIPT: INVALID_SELECTOR"); ```  ## Unused imports  Contract: https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L12  Issue: Contract is importing CurveHelpers but not using it  Recommendation: Do not import CurveHelpers.sol in YearnCurveVaultOperator
# [G-01] Redundant zero initialization  Solidity does not recognize null as a value, so uint variables are initialized to zero. Setting a uint variable to zero is redundant and can waste gas.  There were many places where an int is initialized to zero https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L89 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L234 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L324 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L124 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L136 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L196 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L256 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L315 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L333 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L369 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L412 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L651 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L123 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L147 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L164 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L259 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L278 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L316 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L71 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L203 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L40 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L60 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L75  ## Recommended Mitigation Steps  Remove the redundant zero initialization `uint256 i;` instead of `uint256 i = 0;`  # [G-02] Split up require statements instead of &&  Combining require statement conditions with && logic uses unnecessary gas. It is better to split up each part of the logical statement into a separate require statements  One example is ``` require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), "PSO: INVALID_ADDRESS"); ```  This can be improved to ``` require(_tokenTransferProxy != address(0)); require(_augustusSwapper != address(0), "PSO: INVALID_ADDRESS"); ```  Several places had require statements with many logical "and"s. Instead, split into two to save gas https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L65 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L65 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L54 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L52 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L67 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L68 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L69 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L70 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L71 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L72  ## Recommended Mitigation Steps  Use separate require statements instead of concatenating with &&  # [G-03] Cache array length before loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop. This saves gas.  This was found in many places https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L89 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L234 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L324 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L124 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L651 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L147 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L164 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L259 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L278 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L316 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L60 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L75  ## Recommended Mitigation Steps  Cache the array length before the for loop  # [G-04] Use != 0 instead of > 0  Using `> 0` uses slightly more gas than using `!= 0`. Use `!= 0` when comparing uint variables to zero, which cannot hold values below zero  Locations where this was found include https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L120  ## Recommended Mitigation Steps  Replace `> 0` with `!= 0` to save gas  # [G-05] Short require strings save gas  Strings in solidity are handled in 32 byte chunks. A require string longer than 32 bytes uses more gas. Shortening these strings will save gas.  Locations where this was found include https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L229 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L230 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L243 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L244 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L256 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L319 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L320 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L334 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L335 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L342 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L359 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L375  ## Recommended Mitigation Steps  Shorten all require strings to less than 32 characters  # [G-06] Use prefix not postfix in loops  Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements.  There are many examples of this in for loops https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L18 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L67 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L80 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L89 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L234 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L324 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L124  ## Recommended Mitigation Steps  Use prefix not postfix to increment in a loop  # [G-07] For loop incrementing can be unsafe  For loops that use i++ do not need to use safemath for this operation because the loop would run out of gas long before this point. Making this addition operation unsafe using unchecked saves gas.  Sample code to make the for loop increment unsafe ``` for (uint i = 0; i < length; i = unchecked_inc(i)) {     // do something that doesn't change the value of i }  function unchecked_inc(uint i) returns (uint) {     unchecked {         return i + 1;     } } ```  Idea borrowed from https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked  There are many for loops and that can use this change https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L18 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L67 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L80 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L89 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L234 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L324 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L124  ## Recommended Mitigation Steps  Make the increment in for loops unsafe to save gas  # [G-08] Use iszero assembly for zero checks  Comparing a value to zero can be done using the `iszero` EVM opcode. This can save gas  Source from t11s https://twitter.com/transmissions11/status/1474465495243898885  There are many places where a value is compared to zero https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L92 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L219 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L70  ## Recommended Mitigation Steps  Use the assembly `iszero` evm opcode to compare values to zero  # [G-09] Add payable to functions that won't receive ETH  Identifying a function as payable saves gas. Functions that have a modifier like onlyOwner cannot be called by normal users and will not mistakenly receive ETH. These functions can be payable to save gas.  There are many functions that have the onlyOwner modifier in the contracts. Some examples are https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L29 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L41 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultStorage.sol#L24 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultStorage.sol#L34 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/OwnerProxy.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableFactoryHandler.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableFactoryHandler.sol#L35 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableProxyDelegation.sol#L50 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableProxyDelegation.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L116 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L122 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L129 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L136 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L61 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L69 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L77 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L91 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L121 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L133 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L152 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L159 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L167 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L175 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L106 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L116 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L131 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L52 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L74 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/mocks/TokenTransferProxy.sol#L40  ## Recommended Mitigation Steps  Add payable to these functions for gas savings  # [G-10] Add payable to constructors that won't receive ETH  Identifying a constructor as payable saves gas. Constructors should only be called by the admin or deployer and should not mistakenly receive ETH. Constructors can be payable to save gas.  Some examples of constructors in the contracts are https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L15 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L31 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L21 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L21 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L13 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L18 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L65 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/Withdrawer.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L22 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L45 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L57 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/utils/NestedAssetBatcher.sol#L32 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L44  ## Recommended Mitigation Steps  Add payable to these functions for gas savings  # [G-11] Use internal function in place of modifier  An internal function can save gas vs. a modifier. A modifier inlines the code of the original function but an internal function does not.  Source https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#dde7  Many modifiers can use this change https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L103 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableFactoryHandler.sol#L20 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableProxyDelegation.sol#L40 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L98 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L106  ## Recommended Mitigation Steps  Use internal functions in place of modifiers to save gas.  # [G-12] Use uint not bool  Booleans are more expensive than uint256 or any type that takes up a full word because each write operation emits an extra SLOAD to first read the slot's contents, replace the bits taken up by the boolean, and then write back. This is the compiler's defense against contract upgrades and pointer aliasing, and it cannot be disabled.  Locations where this was found include https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L34 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L197 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L197 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L49 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L90 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L33 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L116 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L356 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L403 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L464 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L466 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L493 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L540 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L611 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L151 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L36 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/libraries/StakingLPVaultHelpers.sol#L100 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/libraries/StakingLPVaultHelpers.sol#L130 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/libraries/CurveHelpers/CurveHelpers.sol#L85 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/libraries/ExchangeHelpers.sol#L19 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/libraries/ExchangeHelpers.sol#L22  ## Recommended Mitigation Steps  Replace bool variables with uints  # [G-13] Use uint256 not smaller ints  From [the solidity docs](https://docs.soliditylang.org/en/v0.8.15/internals/layout_in_storage.html?highlight=elements%20that%20are%20smaller%20than%2032%20bytes#layout-of-state-variables-in-storage) ``` When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. ```  Locations where this was found include https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L8 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L72 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L122 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L166 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L193 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L214 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L262 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L86 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L116 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L131 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L313 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/libraries/StakingLPVaultHelpers.sol#L105  ## Recommended Mitigation Steps  Replace bool variables with uints  # [G-14] Use Solidity errors instead of require  Solidity errors introduced in version 0.8.4 can save gas on revert conditions https://blog.soliditylang.org/2021/04/21/custom-errors/ https://twitter.com/PatrickAlphaC/status/1505197417884528640  Many require blocks are used in the code which can be replaced with errors to save gas https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L35 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L39 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L40 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L30 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L31 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L32 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L33 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L34 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L39 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L70 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L73 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L121 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L123  ## Recommended Mitigation Steps  Replace require blocks with new solidity errors described in https://blog.soliditylang.org/2021/04/21/custom-errors/  # [G-15] Bitshift for divide by 2  When multiply or dividing by a power of two, it is cheaper to bitshift than to use standard math operations.  There is a divide by 2 operation on these lines https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L273 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275  ## Recommended Mitigation Steps  Bitshift right by one bit instead of dividing by 2 to save gas  # [G-16] Non-public variables save gas  Many constant variables are public, but changing the visibility of these variables to private or internal can save gas. https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L25 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L26 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L28 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/utils/NestedAssetBatcher.sol#L19 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/utils/NestedAssetBatcher.sol#L20 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L11 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L12 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L20 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L23 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L19 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L19 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L11 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L15 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/Withdrawer.sol#L14 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L17 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L32 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L32 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L35 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L39 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L80 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/utils/NestedAssetBatcher.sol#L19 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/utils/NestedAssetBatcher.sol#L20  ## Recommended Mitigation Steps  Declare some public variables as private or internal to save gas  # [G-17] Use calldata instead of memory for function arguments  Using calldata instead of memory for function arguments saves gas sometimes. This can happen when a function is called externally and the memory array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). If the array is used in a for loop, `arr[i]` accesses the value in memory using a `mload`. If calldata is used instead, then instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  One case of function arguments using memory instead of calldata can use this improvement to save gas https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L52  Source https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#use-calldata-instead-of-memory-for-function-parameters  ## Recommended Mitigation Steps  Change function arguments from memory to calldata  # [G-18] Write contracts in vyper  The contracts are all written entirely in solidity. Writing contracts with vyper instead of solidity can save gas.  Source https://twitter.com/eiber_david/status/1515737811881807876 doggo demonstrates https://twitter.com/fubuloubu/status/1528179581974417414?t=-hcq_26JFDaHdAQZ-wYxCA&s=19  ## Recommended Mitigation Steps  Write some or all of the contracts in vyper to save gas  # [G-19] Use `abi.encodePacked()` not `abi.encode()`  Changing `abi.encode` to `abi.encodePacked` can save gas. `abi.encode` pads extra null bytes at the end of the call data which is normally unnecessary. In general, `abi.encodePacked` is more gas-efficient.  There are some places where this change can be made: https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L173 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L187  ## Recommended Mitigation Steps  Change `abi.encode` to `abi.encodePacked`  # [G-20] Save gas with unchecked  Use unchecked math when there is no overflow risk to save gas. Before index is decreased in remove it is checked for zero condition. This means index will not underflow and can be unchecked.  This subtraction do not need to be checked for underflows because it is after a require statements that confirms the underflow will not happen https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L525  ## Recommended Mitigation Steps  Add unchecked around math that can't overflow for gas savings. In Solidity before 0.8.0, use the normal math operators instead of safe math functions.
## Missing Zero-address Validation **Severity**: Low **Context**: [`Withdrawer.sol#L16-L18`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/Withdrawer.sol#L16-L18), [`YearnCurveVaultOperator.sol#L31-L51`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L31-L51)  **Description**: Lack of zero-address validation on address parameters may lead to transaction reverts, waste gas, require resubmission of transactions and may even force contract redeployments in certain cases within the protocol.  **Recommendation**: Add explicit zero-address validation on input parameters of address type.   ## Missing Time locks **Severity**: Low **Context**: [`NestedFactory.sol#L121-L179`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L121-L179), [`BeefyVaultStorage.sol#L34-L38`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/BeefyVaultStorage.sol#L34-L38)  **Description**: When critical parameters of systems need to be changed, it is required to broadcast the change via event emission and recommended to enforce the changes after a time-delay. This is to allow system users to be aware of such critical changes and give them an opportunity to exit or adjust their engagement with the system accordingly. None of the onlyOwner functions that change critical protocol addresses/parameters have a timelock for a time-delayed change to alert: (1) users and give them a chance to engage/exit protocol if they are not agreeable to the changes (2) team in case of compromised owner(s) and give them a chance to perform incident response.  **Recommendation**: Users may be surprised when critical parameters are changed or incentivizer programs completed early without notice. Furthermore, it can erode users' trust since they can’t be sure the protocol rules won’t be changed later on. Compromised owner keys may be used to change protocol addresses/parameters to benefit attackers. Without a time-delay, authorised owners have no time for any planned incident response.   ## Missing Equivalence Checks in Setters **Severity**: Low **Context**: [`NestedFactory.sol#L152-L172`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L152-L172)  **Description**: Setter functions are missing checks to validate if the new value being set is the same as the current value already set in the contract. Such checks will showcase mismatches between on-chain and off-chain states.  **Recommendation**: This may hinder detecting discrepancies between on-chain and off-chain states leading to flawed assumptions of on-chain state and protocol behavior.   ## `receive()` Function Should Emit An Event **Severity**: Low **Context**: [`NestedFactory.sol#L88-L92`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L88-L92), [`Withdrawer.sol#L16-L18`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/Withdrawer.sol#L16-L18)  **Description**: Consider emitting an event inside this function with `msg.sender` and `msg.value` as the parameters. This would make it easier to track incoming ether transfers.  **Recommendation**: Add events to the `receive()` functions.    ## Lack of Event Emission For Critical Functions **Severity**: Low **Context**: [`BeefyVaultOperator.sol#L36-L67`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L36-L67), [`BeefyVaultOperator.sol#L79-L108`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L79-L108), [`BeefyZapBiswapLPVaultOperator.sol#L46-L77`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L46-L77), [`BeefyZapBiswapLPVaultOperator.sol#L91-L121`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L91-L121), [`BeefyZapUniswapLPVaultOperator.sol#L46-L77`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L46-L77), [`BeefyZapUniswapLPVaultOperator.sol#L91-L121`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L91-L121), [`ParaswapOperator.sol#L22-L48`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Paraswap/ParaswapOperator.sol#L22-L48)  **Description**: Several functions update critical parameters that are missing event emission. These should be performed to ensure tracking of changes of such critical parameters.  **Recommendation**: Add events to functions that change critical parameters.   ## Unindexed Event Parameters **Severity** Informational **Context**: [`MixinOperatorResolver.sol#L14`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L14), [`TimelockControllerEmergency.sol#L60`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L60)  **Description**: Parameters of certain events are expected to be indexed so that they’re included in the block’s bloom filter for faster access. Failure to do so might confuse off-chain tooling looking for such indexed events.  **Recommendation**: Add the indexed keyword to event parameters that should include it.   ## Lack of `solhint` To Ignore Warnings **Severity**: Informational **Context**: [`OwnerProxy.sol#L21-L36`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/OwnerProxy.sol#L21-L36), [`OperatorScripts.sol#L58-L60`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/scripts/OperatorScripts.sol#L58-L60)  **Description**: `solhint` is useful to help ignore warnings that aren't really issues. For example the code base has some assembly blocks which promts the warning `Linter: Avoid to use inline assembly. It is acceptable only in rare cases`. Adding in `/* solhint-disable no-inline-assembly */` above it will ignore this warning.  **Recommendation**: Use `solhint` to ignore warnings that aren't really issues.   ## Spelling Errors **Severity**: Informational **Context**: [`NestedFactory.sol#L51 (withdrawed => withdrawn)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L51), [`NestedFactory.sol#L477 (dont => do not)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L477), [`NestedFactory.sol#L534 (transfered => transferred)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L534), [`NestedFactory.sol#L639 (withdrawed => withdrawal)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L639), [`MixinOperatorResolver.sol#L81 (datas => data(it is already plural))`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L81), [`OwnableProxyDelegation.sol#L17 (setted => set)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/OwnableProxyDelegation.sol#L17), [`TimeLockControllerEmergency.sol#L183 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L183), [`TimeLockControllerEmergency.sol#L187 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L187), [`TimeLockControllerEmergency.sol#L224 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L224), [`TimeLockControllerEmergency.sol#L230 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L230), [`TimeLockControllerEmergency.sol#L232 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L232), [`BeefyVaultOperator.sol#L95 (WITHDRAWED => WITHDRAWAL)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L95), [`BeefyZapBiswapLPVaultOperator.sol#L108 (WITHDRAWED => WITHDRAWAL)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L108), [`BeefyZapUniswapLPVaultOperator.sol#L108 (WITHDRAWED => WITHDRAWAL)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L108), [`StakingLPVaultHelpers.sol#L21 (liquitiy => liquidity)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L21), [`StakingLPVaultHelpers.sol#L52 (liquitiy => liquidity)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L52), [`StakingLPVaultHelpers.sol#L85 (liquitiy => liquidity)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L85), [`StakingLPVaultHelpers.sol#L115 (liquitiy => liquidity)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L115)  **Description**: Spelling errors in comments can cause confusion to both users and developers.  **Recommendation**: Check all misspellings to ensure they are corrected.   ## Missing or Incomplete NatSpec **Severity**: Informational **Context**: [`All Contracts`](https://github.com/code-423n4/2022-06-nested)  **Description**: Some functions are missing @notice/@dev NatSpec comments for the function, @param for all/some of their parameters and @return for return values. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability and usability.  **Recommendation**: Add in full NatSpec comments for all functions to have complete code documentation for future use.   ## Too Recent of a Pragma **Severity** Informational **Context**: [`All Contracts`](https://github.com/code-423n4/2022-06-nested)  **Description**: Using too recent of a pragma is risky since they are not battle tested. A rise of a bug that wasn't known on release would cause either a hack or a need to secure funds and redeploy.  **Recommendation**:  Use a Pragma version that has been used for sometime. I would suggest `0.8.4` for the decrease of risk and still has the gas optimizations implemented.
