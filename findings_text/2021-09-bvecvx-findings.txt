# Handle  JMukesh   # Vulnerability details  ## Impact setWithdrawalFee(), setPerformanceFeeStrategist()  has no event, so it is difficult to track off-chain changes in the fee   ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/deps/BaseStrategy.sol#L126  ## Tools Used manual review  ## Recommended Mitigation Steps add event to above function  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CvxLocker.setBoost` function does not validate the `_max, _rate` parameters, instead it validates the already set **storage** variables.  ```solidity // @audit this is checking the already-set storage variables, not the parameters require(maximumBoostPayment < 1500, "over max payment"); //max 15% require(boostRate < 30000, "over max rate"); //max 3x ```  ## Impact Once wrong boost values are set (which are not validated when they are set), they cannot be set to new values anymore, breaking core contract functionality.  ## Recommended Mitigation Steps Implement these two checks instead:  ```solidity require(_max < 1500, "over max payment"); //max 15% require(_rate < 30000, "over max rate"); //max 3x ```   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CvxLocker.setStakeLimits` function does not check `_minimum <= _maximum`.  ## Recommended Mitigation Steps Implement these two checks instead:  ```solidity require(_minimum <= _maximum, "min range"); require(_maximum <= denominator, "max range"); ```  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `veCVXStrategy.manualRebalance` function computes two ratios `currentLockRatio` and `newLockRatio` and compares them.  However, these ratios compute different things and are not comparable: - `currentLockRatio = balanceInLock.mul(10**18).div(totalCVXBalance)` is a **percentage value** with 18 decimals (i.e. `1e18 = 100%`). Its max value can at most be `1e18`. - `newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS)` is a **CVX token amount**. It's unbounded and just depends on the `totalCVXBalance` amount.  The comparison that follows does not make sense:  ```solidity if (newLockRatio <= currentLockRatio) {   // ... } ```  ## Impact The rebalancing is broken and does not correctly rebalance. It usually leads to locking nearly everything if `totalCVXBalance` is high.  ## Recommended Mitigation Steps Judging from the `cvxToLock = newLockRatio.sub(currentLockRatio)` it seems the desired computation is that the "ratios" should actually be in CVX amounts and not in percentages. Therefore, `currentLockRatio` should just be `balanceInLock`. (The variables should be renamed as they aren't really ratios but absolute CVX balance amounts.)   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `Debug` event in `veCVXStrategy` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TendState` event in `StrategyCvxHelper` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `HarvestState` event in `StrategyCvxHelper` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.   
# Handle  hickuphh3   # Vulnerability details  ### Impact  `_swapcvxCRVToWant()` swaps `cvxCRV -> ETH -> CVX` via sushiswap.  Looking at sushiswap analytics, this may also not be the most optimal trading path. The cvxCRV-CRV pool seems to have substantially better liquidity than the cvxCRV-ETH pool as r[eported here](https://www.notion.so/6a2dc64a1969e19c23e4f579f9810aa7) (Note that cvxCRV-CRV's liquidity is overstated, [clicking into the pool](https://www.notion.so/a2a8a54062e021873bcaee006cdf4007) gives a more reasonable amount). It is therefore better to do `cvxCRV -> CRV -> ETH -> CVX`, though this comes at the cost of higher gas usage.  ### Recommended Mitigation Steps  Switch the trading path to `cvxCRV -> CRV -> ETH -> CVX`, as it means more CVX tokens received, translating to higher APY, while the higher gas cost is borne by the caller.  Additionally, given how liquidity can shift between pools over time, the most optimal trade path may change accordingly. Hence, it may be beneficial to make the pool path configurable.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `setWithdrawalSafetyCheck()`, `setHarvestOnRebalance()`, `setProcessLocksOnReinvest()` and `setProcessLocksOnRebalance()` functions are unused internally but have `public` visibility. Their visibility can be changed to `external`.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  - L211: `// We receive bCVX -> Convert to bCVX` → `We receive bCVX -> Convert to CVX` - L443: `/// @notice toLock = 100, lock everything (CVX) you have` → `/// @notice toLock = MAX_BPS, lock everything (CVX) you have` since MAX_BPS (10_000) is the base used  
# Handle  hickuphh3   # Vulnerability details  ### Impact  This was probably an oversight since  - the veCVXStrategy contract used `safeApprove()` for token approvals - `using SafeERC20Upgradeable for IERC20Upgradeable;` was declared  ### Recommended Mitigation Steps  Change  `cvxToken.approve(address(cvxRewardsPool), MAX_UINT_256);`  to  `cvxToken.safeApprove(address(cvxRewardsPool), MAX_UINT_256);`  
# Handle  pauliax   # Vulnerability details  ## Impact even the comment says it, delete to save some gas:     /// @notice Delete if you don't need!     function setKeepReward(uint256 _setKeepReward) external {         _onlyGovernance();     }   
# Handle  pauliax   # Vulnerability details  ## Impact functions setWithdrawalSafetyCheck, setHarvestOnRebalance, setProcessLocksOnReinvest, and setProcessLocksOnRebalance are public but can be external as they are only supposed to be invoked from the outside.   
# Handle  pauliax   # Vulnerability details  ## Impact because function tend() always reverts, you can remove authorization checks and modifiers to save some gas.   
# Handle  pauliax   # Vulnerability details  ## Impact Variables that do not change can be marked as immutable. This greatly reduces gas cots. Examples of such variables are:   ICvxLocker public LOCKER;   uint256 MAX_BPS = 10_000;   address public lpComponent;   address public reward;   
# Handle  pauliax   # Vulnerability details  ## Impact function _processPerformanceFees is not used. functions _processPerformanceFees and _processRewardsFees are way too similar. _processPerformanceFees can be eliminated and _processRewardsFees used by passing want as a _token parameter.  
# Handle  pauliax   # Vulnerability details  ## Impact function withdrawAll in BaseStrategy declares 'returns (uint256 balance)', however, no actual value is returned. function reinvest in MyStrategy declares to return 'uint256 reinvested', however, it also actually does not return anything so they always get assigned a default value of 0.  ## Recommended Mitigation Steps Either remove the return declarations or return the intended values. Otherwise, it may confuse other protocols that later may want to integrate with you.  
# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  The input `toLock` in the `manualRebalance` function should in terms of BPS else `toLock` should be changed accordingly in the function. The comments incorrectly indicate the range in which the input `toLock` should be given. https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L443  ## Recommended Mitigation Steps In the comments `toLock` should be = 10_000 as we are comparing with `MAX_BPS` https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L446  
# Handle  patitonar   # Vulnerability details  ## Impact Gas optimization to store variables as immutable instead of storage similar to `_decimals`  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/locker/CvxLocker.sol#L112-L114  ## Tools Used Manual review  ## Recommended Mitigation Steps Declare as following: string private immutable _name; string private immutable _symbol;   
# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `MAX_BPS` in the veCVXStrategy is never reset after initialization. Declaring it as a constant saves gas.  ## Tools Used slither  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The function `reinvest` in the veCVXStrategy always returns 0 as the return variable `reinvested` is never updated.  The function is `onlyGovernance` and the return value probably does not matter if the caller is a multi-sig. However, if a protocol is set as `onlyGovernance` the faulty return value would have to be ignored by the caller to not transition into an incorrect state.  ## Proof of Concept The variable `reinvested` is declared as return variable (line 400) but not updated to reflect the actual amount reinvested which is saved in variable `toDeposit`.  Therefore always the default value is returned (0).  Link: https://github.com/code-423n4/2021-09-bvecvx/blob/32ecfd005d421f29c3846f4609fec33eaad388b9/veCVX/contracts/veCVXStrategy.sol#L400  ## Recommended Mitigation Steps  Add `reinvested = toDeposit;` after line 412.  
# Handle  tensors   # Vulnerability details  ## Impact We have previously seen that the harvest function can be exploited for almost all the tokens at stake. Since ManualRebalance calls harvest, it is also unsafe and funds swapped using it will likely be lost.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L444-L453  ## Recommended Mitigation Steps Adding an amount out minimum here will work that should be passed on to the harvest method.  
# Handle  tensors   # Vulnerability details  ## Impact The code includes unused functions, like tend(), L319. It's best practice to remove these. It will also save gas.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L319  ## Recommended Mitigation Steps Remove the unused function.  
# Handle  tensors   # Vulnerability details  ## Impact The setKeepReward function is unfinished.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L203  ## Recommended Mitigation Steps Either complete the function or follow the comment above the code and remove it.  
# Handle  JMukesh   # Vulnerability details  ## Impact setWithdrawalFee(), setPerformanceFeeStrategist()  has no event, so it is difficult to track off-chain changes in the fee   ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/deps/BaseStrategy.sol#L126  ## Tools Used manual review  ## Recommended Mitigation Steps add event to above function  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CvxLocker.setBoost` function does not validate the `_max, _rate` parameters, instead it validates the already set **storage** variables.  ```solidity // @audit this is checking the already-set storage variables, not the parameters require(maximumBoostPayment < 1500, "over max payment"); //max 15% require(boostRate < 30000, "over max rate"); //max 3x ```  ## Impact Once wrong boost values are set (which are not validated when they are set), they cannot be set to new values anymore, breaking core contract functionality.  ## Recommended Mitigation Steps Implement these two checks instead:  ```solidity require(_max < 1500, "over max payment"); //max 15% require(_rate < 30000, "over max rate"); //max 3x ```   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CvxLocker.setStakeLimits` function does not check `_minimum <= _maximum`.  ## Recommended Mitigation Steps Implement these two checks instead:  ```solidity require(_minimum <= _maximum, "min range"); require(_maximum <= denominator, "max range"); ```  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `veCVXStrategy.manualRebalance` function computes two ratios `currentLockRatio` and `newLockRatio` and compares them.  However, these ratios compute different things and are not comparable: - `currentLockRatio = balanceInLock.mul(10**18).div(totalCVXBalance)` is a **percentage value** with 18 decimals (i.e. `1e18 = 100%`). Its max value can at most be `1e18`. - `newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS)` is a **CVX token amount**. It's unbounded and just depends on the `totalCVXBalance` amount.  The comparison that follows does not make sense:  ```solidity if (newLockRatio <= currentLockRatio) {   // ... } ```  ## Impact The rebalancing is broken and does not correctly rebalance. It usually leads to locking nearly everything if `totalCVXBalance` is high.  ## Recommended Mitigation Steps Judging from the `cvxToLock = newLockRatio.sub(currentLockRatio)` it seems the desired computation is that the "ratios" should actually be in CVX amounts and not in percentages. Therefore, `currentLockRatio` should just be `balanceInLock`. (The variables should be renamed as they aren't really ratios but absolute CVX balance amounts.)   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `Debug` event in `veCVXStrategy` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TendState` event in `StrategyCvxHelper` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `HarvestState` event in `StrategyCvxHelper` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.   
# Handle  hickuphh3   # Vulnerability details  ### Impact  `_swapcvxCRVToWant()` swaps `cvxCRV -> ETH -> CVX` via sushiswap.  Looking at sushiswap analytics, this may also not be the most optimal trading path. The cvxCRV-CRV pool seems to have substantially better liquidity than the cvxCRV-ETH pool as r[eported here](https://www.notion.so/6a2dc64a1969e19c23e4f579f9810aa7) (Note that cvxCRV-CRV's liquidity is overstated, [clicking into the pool](https://www.notion.so/a2a8a54062e021873bcaee006cdf4007) gives a more reasonable amount). It is therefore better to do `cvxCRV -> CRV -> ETH -> CVX`, though this comes at the cost of higher gas usage.  ### Recommended Mitigation Steps  Switch the trading path to `cvxCRV -> CRV -> ETH -> CVX`, as it means more CVX tokens received, translating to higher APY, while the higher gas cost is borne by the caller.  Additionally, given how liquidity can shift between pools over time, the most optimal trade path may change accordingly. Hence, it may be beneficial to make the pool path configurable.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `setWithdrawalSafetyCheck()`, `setHarvestOnRebalance()`, `setProcessLocksOnReinvest()` and `setProcessLocksOnRebalance()` functions are unused internally but have `public` visibility. Their visibility can be changed to `external`.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  - L211: `// We receive bCVX -> Convert to bCVX` → `We receive bCVX -> Convert to CVX` - L443: `/// @notice toLock = 100, lock everything (CVX) you have` → `/// @notice toLock = MAX_BPS, lock everything (CVX) you have` since MAX_BPS (10_000) is the base used  
# Handle  hickuphh3   # Vulnerability details  ### Impact  This was probably an oversight since  - the veCVXStrategy contract used `safeApprove()` for token approvals - `using SafeERC20Upgradeable for IERC20Upgradeable;` was declared  ### Recommended Mitigation Steps  Change  `cvxToken.approve(address(cvxRewardsPool), MAX_UINT_256);`  to  `cvxToken.safeApprove(address(cvxRewardsPool), MAX_UINT_256);`  
# Handle  pauliax   # Vulnerability details  ## Impact even the comment says it, delete to save some gas:     /// @notice Delete if you don't need!     function setKeepReward(uint256 _setKeepReward) external {         _onlyGovernance();     }   
# Handle  pauliax   # Vulnerability details  ## Impact functions setWithdrawalSafetyCheck, setHarvestOnRebalance, setProcessLocksOnReinvest, and setProcessLocksOnRebalance are public but can be external as they are only supposed to be invoked from the outside.   
# Handle  pauliax   # Vulnerability details  ## Impact because function tend() always reverts, you can remove authorization checks and modifiers to save some gas.   
# Handle  pauliax   # Vulnerability details  ## Impact Variables that do not change can be marked as immutable. This greatly reduces gas cots. Examples of such variables are:   ICvxLocker public LOCKER;   uint256 MAX_BPS = 10_000;   address public lpComponent;   address public reward;   
# Handle  pauliax   # Vulnerability details  ## Impact function _processPerformanceFees is not used. functions _processPerformanceFees and _processRewardsFees are way too similar. _processPerformanceFees can be eliminated and _processRewardsFees used by passing want as a _token parameter.  
# Handle  pauliax   # Vulnerability details  ## Impact function withdrawAll in BaseStrategy declares 'returns (uint256 balance)', however, no actual value is returned. function reinvest in MyStrategy declares to return 'uint256 reinvested', however, it also actually does not return anything so they always get assigned a default value of 0.  ## Recommended Mitigation Steps Either remove the return declarations or return the intended values. Otherwise, it may confuse other protocols that later may want to integrate with you.  
# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  The input `toLock` in the `manualRebalance` function should in terms of BPS else `toLock` should be changed accordingly in the function. The comments incorrectly indicate the range in which the input `toLock` should be given. https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L443  ## Recommended Mitigation Steps In the comments `toLock` should be = 10_000 as we are comparing with `MAX_BPS` https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L446  
# Handle  patitonar   # Vulnerability details  ## Impact Gas optimization to store variables as immutable instead of storage similar to `_decimals`  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/locker/CvxLocker.sol#L112-L114  ## Tools Used Manual review  ## Recommended Mitigation Steps Declare as following: string private immutable _name; string private immutable _symbol;   
# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `MAX_BPS` in the veCVXStrategy is never reset after initialization. Declaring it as a constant saves gas.  ## Tools Used slither  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The function `reinvest` in the veCVXStrategy always returns 0 as the return variable `reinvested` is never updated.  The function is `onlyGovernance` and the return value probably does not matter if the caller is a multi-sig. However, if a protocol is set as `onlyGovernance` the faulty return value would have to be ignored by the caller to not transition into an incorrect state.  ## Proof of Concept The variable `reinvested` is declared as return variable (line 400) but not updated to reflect the actual amount reinvested which is saved in variable `toDeposit`.  Therefore always the default value is returned (0).  Link: https://github.com/code-423n4/2021-09-bvecvx/blob/32ecfd005d421f29c3846f4609fec33eaad388b9/veCVX/contracts/veCVXStrategy.sol#L400  ## Recommended Mitigation Steps  Add `reinvested = toDeposit;` after line 412.  
# Handle  tensors   # Vulnerability details  ## Impact We have previously seen that the harvest function can be exploited for almost all the tokens at stake. Since ManualRebalance calls harvest, it is also unsafe and funds swapped using it will likely be lost.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L444-L453  ## Recommended Mitigation Steps Adding an amount out minimum here will work that should be passed on to the harvest method.  
# Handle  tensors   # Vulnerability details  ## Impact The code includes unused functions, like tend(), L319. It's best practice to remove these. It will also save gas.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L319  ## Recommended Mitigation Steps Remove the unused function.  
# Handle  tensors   # Vulnerability details  ## Impact The setKeepReward function is unfinished.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L203  ## Recommended Mitigation Steps Either complete the function or follow the comment above the code and remove it.  
# Handle  JMukesh   # Vulnerability details  ## Impact setWithdrawalFee(), setPerformanceFeeStrategist()  has no event, so it is difficult to track off-chain changes in the fee   ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/deps/BaseStrategy.sol#L126  ## Tools Used manual review  ## Recommended Mitigation Steps add event to above function  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CvxLocker.setBoost` function does not validate the `_max, _rate` parameters, instead it validates the already set **storage** variables.  ```solidity // @audit this is checking the already-set storage variables, not the parameters require(maximumBoostPayment < 1500, "over max payment"); //max 15% require(boostRate < 30000, "over max rate"); //max 3x ```  ## Impact Once wrong boost values are set (which are not validated when they are set), they cannot be set to new values anymore, breaking core contract functionality.  ## Recommended Mitigation Steps Implement these two checks instead:  ```solidity require(_max < 1500, "over max payment"); //max 15% require(_rate < 30000, "over max rate"); //max 3x ```   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CvxLocker.setStakeLimits` function does not check `_minimum <= _maximum`.  ## Recommended Mitigation Steps Implement these two checks instead:  ```solidity require(_minimum <= _maximum, "min range"); require(_maximum <= denominator, "max range"); ```  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `veCVXStrategy.manualRebalance` function computes two ratios `currentLockRatio` and `newLockRatio` and compares them.  However, these ratios compute different things and are not comparable: - `currentLockRatio = balanceInLock.mul(10**18).div(totalCVXBalance)` is a **percentage value** with 18 decimals (i.e. `1e18 = 100%`). Its max value can at most be `1e18`. - `newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS)` is a **CVX token amount**. It's unbounded and just depends on the `totalCVXBalance` amount.  The comparison that follows does not make sense:  ```solidity if (newLockRatio <= currentLockRatio) {   // ... } ```  ## Impact The rebalancing is broken and does not correctly rebalance. It usually leads to locking nearly everything if `totalCVXBalance` is high.  ## Recommended Mitigation Steps Judging from the `cvxToLock = newLockRatio.sub(currentLockRatio)` it seems the desired computation is that the "ratios" should actually be in CVX amounts and not in percentages. Therefore, `currentLockRatio` should just be `balanceInLock`. (The variables should be renamed as they aren't really ratios but absolute CVX balance amounts.)   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `Debug` event in `veCVXStrategy` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TendState` event in `StrategyCvxHelper` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `HarvestState` event in `StrategyCvxHelper` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.   
# Handle  hickuphh3   # Vulnerability details  ### Impact  `_swapcvxCRVToWant()` swaps `cvxCRV -> ETH -> CVX` via sushiswap.  Looking at sushiswap analytics, this may also not be the most optimal trading path. The cvxCRV-CRV pool seems to have substantially better liquidity than the cvxCRV-ETH pool as r[eported here](https://www.notion.so/6a2dc64a1969e19c23e4f579f9810aa7) (Note that cvxCRV-CRV's liquidity is overstated, [clicking into the pool](https://www.notion.so/a2a8a54062e021873bcaee006cdf4007) gives a more reasonable amount). It is therefore better to do `cvxCRV -> CRV -> ETH -> CVX`, though this comes at the cost of higher gas usage.  ### Recommended Mitigation Steps  Switch the trading path to `cvxCRV -> CRV -> ETH -> CVX`, as it means more CVX tokens received, translating to higher APY, while the higher gas cost is borne by the caller.  Additionally, given how liquidity can shift between pools over time, the most optimal trade path may change accordingly. Hence, it may be beneficial to make the pool path configurable.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `setWithdrawalSafetyCheck()`, `setHarvestOnRebalance()`, `setProcessLocksOnReinvest()` and `setProcessLocksOnRebalance()` functions are unused internally but have `public` visibility. Their visibility can be changed to `external`.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  - L211: `// We receive bCVX -> Convert to bCVX` → `We receive bCVX -> Convert to CVX` - L443: `/// @notice toLock = 100, lock everything (CVX) you have` → `/// @notice toLock = MAX_BPS, lock everything (CVX) you have` since MAX_BPS (10_000) is the base used  
# Handle  hickuphh3   # Vulnerability details  ### Impact  This was probably an oversight since  - the veCVXStrategy contract used `safeApprove()` for token approvals - `using SafeERC20Upgradeable for IERC20Upgradeable;` was declared  ### Recommended Mitigation Steps  Change  `cvxToken.approve(address(cvxRewardsPool), MAX_UINT_256);`  to  `cvxToken.safeApprove(address(cvxRewardsPool), MAX_UINT_256);`  
# Handle  pauliax   # Vulnerability details  ## Impact even the comment says it, delete to save some gas:     /// @notice Delete if you don't need!     function setKeepReward(uint256 _setKeepReward) external {         _onlyGovernance();     }   
# Handle  pauliax   # Vulnerability details  ## Impact functions setWithdrawalSafetyCheck, setHarvestOnRebalance, setProcessLocksOnReinvest, and setProcessLocksOnRebalance are public but can be external as they are only supposed to be invoked from the outside.   
# Handle  pauliax   # Vulnerability details  ## Impact because function tend() always reverts, you can remove authorization checks and modifiers to save some gas.   
# Handle  pauliax   # Vulnerability details  ## Impact Variables that do not change can be marked as immutable. This greatly reduces gas cots. Examples of such variables are:   ICvxLocker public LOCKER;   uint256 MAX_BPS = 10_000;   address public lpComponent;   address public reward;   
# Handle  pauliax   # Vulnerability details  ## Impact function _processPerformanceFees is not used. functions _processPerformanceFees and _processRewardsFees are way too similar. _processPerformanceFees can be eliminated and _processRewardsFees used by passing want as a _token parameter.  
# Handle  pauliax   # Vulnerability details  ## Impact function withdrawAll in BaseStrategy declares 'returns (uint256 balance)', however, no actual value is returned. function reinvest in MyStrategy declares to return 'uint256 reinvested', however, it also actually does not return anything so they always get assigned a default value of 0.  ## Recommended Mitigation Steps Either remove the return declarations or return the intended values. Otherwise, it may confuse other protocols that later may want to integrate with you.  
# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  The input `toLock` in the `manualRebalance` function should in terms of BPS else `toLock` should be changed accordingly in the function. The comments incorrectly indicate the range in which the input `toLock` should be given. https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L443  ## Recommended Mitigation Steps In the comments `toLock` should be = 10_000 as we are comparing with `MAX_BPS` https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L446  
# Handle  patitonar   # Vulnerability details  ## Impact Gas optimization to store variables as immutable instead of storage similar to `_decimals`  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/locker/CvxLocker.sol#L112-L114  ## Tools Used Manual review  ## Recommended Mitigation Steps Declare as following: string private immutable _name; string private immutable _symbol;   
# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `MAX_BPS` in the veCVXStrategy is never reset after initialization. Declaring it as a constant saves gas.  ## Tools Used slither  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The function `reinvest` in the veCVXStrategy always returns 0 as the return variable `reinvested` is never updated.  The function is `onlyGovernance` and the return value probably does not matter if the caller is a multi-sig. However, if a protocol is set as `onlyGovernance` the faulty return value would have to be ignored by the caller to not transition into an incorrect state.  ## Proof of Concept The variable `reinvested` is declared as return variable (line 400) but not updated to reflect the actual amount reinvested which is saved in variable `toDeposit`.  Therefore always the default value is returned (0).  Link: https://github.com/code-423n4/2021-09-bvecvx/blob/32ecfd005d421f29c3846f4609fec33eaad388b9/veCVX/contracts/veCVXStrategy.sol#L400  ## Recommended Mitigation Steps  Add `reinvested = toDeposit;` after line 412.  
# Handle  tensors   # Vulnerability details  ## Impact We have previously seen that the harvest function can be exploited for almost all the tokens at stake. Since ManualRebalance calls harvest, it is also unsafe and funds swapped using it will likely be lost.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L444-L453  ## Recommended Mitigation Steps Adding an amount out minimum here will work that should be passed on to the harvest method.  
# Handle  tensors   # Vulnerability details  ## Impact The code includes unused functions, like tend(), L319. It's best practice to remove these. It will also save gas.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L319  ## Recommended Mitigation Steps Remove the unused function.  
# Handle  tensors   # Vulnerability details  ## Impact The setKeepReward function is unfinished.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L203  ## Recommended Mitigation Steps Either complete the function or follow the comment above the code and remove it.  
