# Lines of code  https://github.com/code-423n4/2023-03-neotokyo/blob/dfa5887062e47e2d0c801ef33062d44c09f6f36e/contracts/staking/NeoTokyoStaker.sol#L1378   # Vulnerability details  ## Impact one of the main features that the staking contract that should always and carefully operate is the reward calculation, there is a miscalculation on every time the getPoolReward is being called on first time staking with a pool of a single window reward count, where lastPoolRewardTime is initially equal to 0, that leads that the timeSinceReward is equal to block timestamp, which massively inflate totalReward. but since the points initially are 0, it gets multiplied by 0 so it would lead to a share of 0. It is advised that the internal calculations are correct at all times.  ## Proof of Concept To help on illustrating the miscalculation, we would apply it on LP, but it's also applicable to S1 and S2.   - We import hardhat console in `NeoTokyoStaker.sol`: ```solidity import "hardhat/console.sol"; ``` - we add the following test case to `NeoTokyoStaker.test.js` within `with example configuration` describe test suite:  ```js   describe('internal miscalculation', function () {    it("internally calculates an inflatable LP totalReward", async function () {     // Configure the LP token contract address on the staker.     await NTStaking.connect(owner.signer).configureLP(LPToken.address);      // Stake Alice's LP tokens to have a non zero pool total points     await NTStaking.connect(alice.signer).stake(      ASSETS.LP.id,      TIMELOCK_OPTION_IDS['30'],      ethers.utils.parseEther('40'),      0,      0     );      // Stake Bob's LP tokens     await NTStaking.connect(bob.signer).stake(      ASSETS.LP.id,      TIMELOCK_OPTION_IDS['1080'],      ethers.utils.parseEther('10'),      0,      0     );    })   }) ``` - we finally add the debugging console.log within the `NeoTokyoStaker.sol` contract: ```solidity     function getPoolReward(AssetType _assetType, address _recipient) public view returns (uint256, uint256) {     // ...                 } else if (i == windowCount - 1) {                     unchecked {                         uint256 timeSinceReward = block.timestamp - lastPoolRewardTime;                         console.log("last pool reward time", lastPoolRewardTime); // +                         console.log("time passed", timeSinceReward); // +                         totalReward = window.reward * timeSinceReward;                     }                     break;                 }    // ...    // Return final shares.             unchecked {                 uint256 share = points * _PRECISION / pool.totalPoints * totalReward;                 uint256 daoShare = share * pool.daoTax / (100 * _DIVISOR);                 share /= _PRECISION;                 daoShare /= _PRECISION;                  console.log("points", points); // +                 console.log("pool total points", pool.totalPoints); // +                 console.log("total reward", totalReward); // +                 return ((share - daoShare), daoShare);             }         }         return (0, 0);     } ``` - after running the test case, we would have the following output:  ```sh       internal miscalculation last pool reward time 0 time passed 2678881252 points 0 pool total points 4000 total reward 1550278502314812929676156         âˆš internally calculates an inflateable LP totalReward ```  - We can see clearly that initially the total reward is directly correlated with the block timestamp, which would lead to the total reward to be internally calculated in an inflated manner. on the mainnet at block.timestamp of 1678881350, we have in the test case a time passed of 2678881252, so it would result in:  - totalReward = 1550278502314812929676156 / 2678881252 * 1678881350 / 10**18 = 971574.855324 BYTES2.0  ## Tools Used Vs code  ## Recommended Mitigation Steps  - for a safer internal reward calculation, we may simply add a check that ensure that the user's getPoolReward call is not the first time call:  ```solidity     function getPoolReward(AssetType _assetType, address _recipient) public view returns (uint256, uint256) {         /*     During the very first stake, there will not be any points in the pool. In      this case, do not attempt to grant any rewards so as to prevent reversion.         */         PoolData storage pool = _pools[_assetType];         uint256 lastPoolRewardTime = lastRewardTime[_recipient][_assetType];         if (pool.totalPoints != 0 && lastPoolRewardTime != 0) {              // ...         }         return (0, 0);    }  ```
