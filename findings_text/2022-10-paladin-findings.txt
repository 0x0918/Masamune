# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L387 https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L432   # Vulnerability details  ## Impact Total reward amount in `extendPledge` and `increasePledgeRewardPerVote` can be calculated incorrectly due to cached `pledgeParams.votesDifference`, which can lead to two outcomes: 1. total reward amount is higher, thus a portion of it won't be claimable; 1. total reward amount is lower, thus the pledge target won't be reached.  ## Proof of Concept When a pledge is created, the creator chooses the targetâ€“the total amount of votes they want to reach with the pledge. Based on a target, the number of missing votes is calculated, which is then used to calculated the total reward amount ([WardenPledge.sol#L325-L327](https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L325-L327)): ```solidity function createPledge(     address receiver,     address rewardToken,     uint256 targetVotes,     uint256 rewardPerVote, // reward/veToken/second     uint256 endTimestamp,     uint256 maxTotalRewardAmount,     uint256 maxFeeAmount ) external whenNotPaused nonReentrant returns(uint256){     ...     // Get the missing votes for the given receiver to reach the target votes     // We ignore any delegated boost here because they might expire during the Pledge duration     // (we can have a future version of this contract using adjusted_balance)     vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);      vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;     ...   } ```  When extending a pledge or increasing a pledge reward per vote, current veToken balance of the pledge's receiver (`votingEscrow.balanceOf(receiver)`) can be different from the one it had when the pledge was created (e.g. the receiver managed to lock more CRV or some of locked tokens have expired). However `pledgeParams.votesDifference` is not recalculated ([WardenPledge.sol#L387](https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L387), [WardenPledge.sol#L432](https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L432)): ```solidity function extendPledge(     uint256 pledgeId,     uint256 newEndTimestamp,     uint256 maxTotalRewardAmount,     uint256 maxFeeAmount ) external whenNotPaused nonReentrant {     ...     Pledge storage pledgeParams = pledges[pledgeId];     ...     uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;     ... }  function increasePledgeRewardPerVote(     uint256 pledgeId,     uint256 newRewardPerVote,     uint256 maxTotalRewardAmount,     uint256 maxFeeAmount ) external whenNotPaused nonReentrant {     ...     Pledge storage pledgeParams = pledges[pledgeId];     ...     uint256 totalRewardAmount = (rewardPerVoteDiff * pledgeParams.votesDifference * remainingDuration) / UNIT;     ... } ```  This can lead to two consequences: 1. When receiver's veToken balance has increased (i.e. `votesDifference` got in fact smaller), pledge creator will overpay for pledge extension and pledge reward per vote increase. This extra reward cannot be received by pledgers because a receiver cannot get more votes than `pledgeParams.targetVotes` (which is not updated when modifying a pledge):     ```solidity     function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {         ...         // Check that this will not go over the Pledge target of votes         if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();         ...     }     ``` 1. When receiver's veToken balance has decreased (i.e. `votesDifference` got in fact bigger), the pledge target cannot be reached because the reward amount was underpaid in `extendPledge`/`increasePledgeRewardPerVote`.  ## Tools Used Manual review ## Recommended Mitigation Steps Consider updating `votesDifference` when extending a pledge or increasing a pledge reward per vote.
# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L368-L404   # Vulnerability details  ## Impact  Delisted reward tokens can continue to be use by extending current pledges that already use it  ## Proof of Concept      if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();     address creator = pledgeOwner[pledgeId];     if(msg.sender != creator) revert Errors.NotPledgeCreator();       Pledge storage pledgeParams = pledges[pledgeId];     if(pledgeParams.closed) revert Errors.PledgeClosed();     if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();     if(newEndTimestamp == 0) revert Errors.NullEndTimestamp();     uint256 oldEndTimestamp = pledgeParams.endTimestamp;     if(newEndTimestamp != _getRoundedTimestamp(newEndTimestamp) || newEndTimestamp < oldEndTimestamp) revert Errors.InvalidEndTimestamp();       uint256 addedDuration = newEndTimestamp - oldEndTimestamp;     if(addedDuration < minDelegationTime) revert Errors.DurationTooShort();     uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;     uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;     if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();     if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();  During the input validation checks, it's never checked that reward token of the pledge being extended is still a valid reward token. This would allow creators using delisted tokens to continue using them as long as they wanted, by simply extending their currently active pledges.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Add the following check during the input validation block:      +   if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted();
# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L451-L452 https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L469   # Vulnerability details  ## Impact Pledge can be silently closed by calling retrievePledgeRewards.  ## Proof of Concept The comments for `retrievePledgeRewards` says: https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L451-L452 ```     /**     * @notice Retrieves all non distributed rewards from a closed Pledge     * @dev Retrieves all non distributed rewards from a closed Pledge & send them to the given receiver     * @param pledgeId ID fo the Pledge     * @param receiver Address to receive the remaining rewards     */ ``` There's no line of code in `retrievePledgeRewards` method to ensure the pledge is indeed closed, instead the pledge is set to `closed` state if it is not closed. https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L469 ```solidity if(!pledgeParams.closed) pledgeParams.closed = true;  ``` This implementation doesn't follow the sepc and the pledge is closed silently(without triggering the `ClosePledge` event) if the pledge is not closed, which could lead to the pledge creator unexpectedly close the pledge that he doesn't intend to.  ## Tools Used manual review  ## Recommended Mitigation Steps `retrievePledgeRewards` can only retrieve distribution rewards from a closed pledge. ```solidity function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {        ......          // Get the current remaining amount of rewards not distributed for the Pledge         uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];          if (!pledgeParams.closed) revert Errors.PledgeNotClosed();          if(remainingAmount > 0) {             // Transfer the non used rewards and reset storage             pledgeAvailableRewardAmounts[pledgeId] = 0;              IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);              emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);          }     } ```
# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L233-L237   # Vulnerability details  ## Impact The `_pledge()` function contains checks ensuring that the `endTimestamp` is not greater than the `pledgeParams.endTimestamp` and that `endTimestamp` is rounded to the week, but it does not check that `endTimestamp` is larger than some minimum pledge time. Currently, an "attacker" or griefer can pledge a large amount for a small amount of time. They can pledge for a length of time where the receiver may not even have enough time to submit a transaction to take advantage of the boost.  This most likely will not provide a large monetary incentive to the attacker, but the pledge creator's reward funds will be paid out for no reason.  ## Proof of Concept - A malicious actor realizes that the week timestamp is approaching in 10 minutes.  - They pledge a large amount of points to the pledge creator with the `endTimestamp` equal to the upcoming week timestamp (10 minutes away). - The receiver doesn't feasibly have enough time to act while the boost is active.  - The malicious actor receives some reward without providing any benefit to the receiver.  ## Tools Used  ## Recommended Mitigation Steps Add a check for `MIN_PLEDGE_TIME`, a constant equal to a value that makes sense, e.g. 86400 (1 day).
# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L325-L335 https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L259-L268   # Vulnerability details  ## Impact Pledge may be out of reward due to the decay in veCRV balance. The receiver may lose his reward given to boosters but get nothing in return since her targetVotes is never reached.  ## Proof of Concept According to Curve documentation at https://curve.readthedocs.io/dao-vecrv.html  ``` A userâ€™s veCRV balance decays linearly as the remaining time until the CRV unlock decreases. For example, a balance of 4000 CRV locked for one year provides the same amount of veCRV as 2000 CRV locked for two years, or 1000 CRV locked for four years. ```  On creation, targetVotes = 100, balance = 20 -> votesDifference = 80 -> reward is allocated for 80 votes  ```solidity         // Get the missing votes for the given receiver to reach the target votes         // We ignore any delegated boost here because they might expire during the Pledge duration         // (we can have a future version of this contract using adjusted_balance)         vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);          vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;         vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;         if(vars.totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();         if(vars.feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();          // Pull all the rewards in this contract         IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);         // And transfer the fees from the Pledge creator to the Chest contract         IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount); ```  Then 1 week passed, receiver's balance decay to 10  On creation, targetVotes = 100, balance = 10 but votesDifference stays 80, and reward has only allocated for 80 votes.  ```solidity         // Rewards are set in the Pledge as reward/veToken/sec         // To find the total amount of veToken delegated through the whole Boost duration         // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases         // each second of the Boost duration         uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;         // Then we can calculate the total amount of rewards for this Boost         uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;          if(rewardAmount > pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();         pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount; ```  A booster boosts 80 votes and takes all rewards in the pool. However, only 80 (From booster) + 10 (From receiver) = 90 votes is active. Not 100 votes that receiver promise in the targetVotes.  Then, if another booster tries to boost 10 votes, it will be reverted with RewardsBalanceTooLow since the first booster has taken all reward that is allocated for only 80 votes.  ## Recommended Mitigation Steps You should provide a way for the creator to provide additional rewards after the pledge creation. Or provide some reward refreshment function that recalculates votesDifference and transfers the required additional reward.
# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L387 https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L432   # Vulnerability details  ## Impact Total reward amount in `extendPledge` and `increasePledgeRewardPerVote` can be calculated incorrectly due to cached `pledgeParams.votesDifference`, which can lead to two outcomes: 1. total reward amount is higher, thus a portion of it won't be claimable; 1. total reward amount is lower, thus the pledge target won't be reached.  ## Proof of Concept When a pledge is created, the creator chooses the targetâ€“the total amount of votes they want to reach with the pledge. Based on a target, the number of missing votes is calculated, which is then used to calculated the total reward amount ([WardenPledge.sol#L325-L327](https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L325-L327)): ```solidity function createPledge(     address receiver,     address rewardToken,     uint256 targetVotes,     uint256 rewardPerVote, // reward/veToken/second     uint256 endTimestamp,     uint256 maxTotalRewardAmount,     uint256 maxFeeAmount ) external whenNotPaused nonReentrant returns(uint256){     ...     // Get the missing votes for the given receiver to reach the target votes     // We ignore any delegated boost here because they might expire during the Pledge duration     // (we can have a future version of this contract using adjusted_balance)     vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);      vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;     ...   } ```  When extending a pledge or increasing a pledge reward per vote, current veToken balance of the pledge's receiver (`votingEscrow.balanceOf(receiver)`) can be different from the one it had when the pledge was created (e.g. the receiver managed to lock more CRV or some of locked tokens have expired). However `pledgeParams.votesDifference` is not recalculated ([WardenPledge.sol#L387](https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L387), [WardenPledge.sol#L432](https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L432)): ```solidity function extendPledge(     uint256 pledgeId,     uint256 newEndTimestamp,     uint256 maxTotalRewardAmount,     uint256 maxFeeAmount ) external whenNotPaused nonReentrant {     ...     Pledge storage pledgeParams = pledges[pledgeId];     ...     uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;     ... }  function increasePledgeRewardPerVote(     uint256 pledgeId,     uint256 newRewardPerVote,     uint256 maxTotalRewardAmount,     uint256 maxFeeAmount ) external whenNotPaused nonReentrant {     ...     Pledge storage pledgeParams = pledges[pledgeId];     ...     uint256 totalRewardAmount = (rewardPerVoteDiff * pledgeParams.votesDifference * remainingDuration) / UNIT;     ... } ```  This can lead to two consequences: 1. When receiver's veToken balance has increased (i.e. `votesDifference` got in fact smaller), pledge creator will overpay for pledge extension and pledge reward per vote increase. This extra reward cannot be received by pledgers because a receiver cannot get more votes than `pledgeParams.targetVotes` (which is not updated when modifying a pledge):     ```solidity     function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {         ...         // Check that this will not go over the Pledge target of votes         if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();         ...     }     ``` 1. When receiver's veToken balance has decreased (i.e. `votesDifference` got in fact bigger), the pledge target cannot be reached because the reward amount was underpaid in `extendPledge`/`increasePledgeRewardPerVote`.  ## Tools Used Manual review ## Recommended Mitigation Steps Consider updating `votesDifference` when extending a pledge or increasing a pledge reward per vote.
# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L368-L404   # Vulnerability details  ## Impact  Delisted reward tokens can continue to be use by extending current pledges that already use it  ## Proof of Concept      if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();     address creator = pledgeOwner[pledgeId];     if(msg.sender != creator) revert Errors.NotPledgeCreator();       Pledge storage pledgeParams = pledges[pledgeId];     if(pledgeParams.closed) revert Errors.PledgeClosed();     if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();     if(newEndTimestamp == 0) revert Errors.NullEndTimestamp();     uint256 oldEndTimestamp = pledgeParams.endTimestamp;     if(newEndTimestamp != _getRoundedTimestamp(newEndTimestamp) || newEndTimestamp < oldEndTimestamp) revert Errors.InvalidEndTimestamp();       uint256 addedDuration = newEndTimestamp - oldEndTimestamp;     if(addedDuration < minDelegationTime) revert Errors.DurationTooShort();     uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;     uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;     if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();     if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();  During the input validation checks, it's never checked that reward token of the pledge being extended is still a valid reward token. This would allow creators using delisted tokens to continue using them as long as they wanted, by simply extending their currently active pledges.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Add the following check during the input validation block:      +   if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted();
# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L451-L452 https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L469   # Vulnerability details  ## Impact Pledge can be silently closed by calling retrievePledgeRewards.  ## Proof of Concept The comments for `retrievePledgeRewards` says: https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L451-L452 ```     /**     * @notice Retrieves all non distributed rewards from a closed Pledge     * @dev Retrieves all non distributed rewards from a closed Pledge & send them to the given receiver     * @param pledgeId ID fo the Pledge     * @param receiver Address to receive the remaining rewards     */ ``` There's no line of code in `retrievePledgeRewards` method to ensure the pledge is indeed closed, instead the pledge is set to `closed` state if it is not closed. https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L469 ```solidity if(!pledgeParams.closed) pledgeParams.closed = true;  ``` This implementation doesn't follow the sepc and the pledge is closed silently(without triggering the `ClosePledge` event) if the pledge is not closed, which could lead to the pledge creator unexpectedly close the pledge that he doesn't intend to.  ## Tools Used manual review  ## Recommended Mitigation Steps `retrievePledgeRewards` can only retrieve distribution rewards from a closed pledge. ```solidity function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {        ......          // Get the current remaining amount of rewards not distributed for the Pledge         uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];          if (!pledgeParams.closed) revert Errors.PledgeNotClosed();          if(remainingAmount > 0) {             // Transfer the non used rewards and reset storage             pledgeAvailableRewardAmounts[pledgeId] = 0;              IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);              emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);          }     } ```
# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L233-L237   # Vulnerability details  ## Impact The `_pledge()` function contains checks ensuring that the `endTimestamp` is not greater than the `pledgeParams.endTimestamp` and that `endTimestamp` is rounded to the week, but it does not check that `endTimestamp` is larger than some minimum pledge time. Currently, an "attacker" or griefer can pledge a large amount for a small amount of time. They can pledge for a length of time where the receiver may not even have enough time to submit a transaction to take advantage of the boost.  This most likely will not provide a large monetary incentive to the attacker, but the pledge creator's reward funds will be paid out for no reason.  ## Proof of Concept - A malicious actor realizes that the week timestamp is approaching in 10 minutes.  - They pledge a large amount of points to the pledge creator with the `endTimestamp` equal to the upcoming week timestamp (10 minutes away). - The receiver doesn't feasibly have enough time to act while the boost is active.  - The malicious actor receives some reward without providing any benefit to the receiver.  ## Tools Used  ## Recommended Mitigation Steps Add a check for `MIN_PLEDGE_TIME`, a constant equal to a value that makes sense, e.g. 86400 (1 day).
# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L325-L335 https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L259-L268   # Vulnerability details  ## Impact Pledge may be out of reward due to the decay in veCRV balance. The receiver may lose his reward given to boosters but get nothing in return since her targetVotes is never reached.  ## Proof of Concept According to Curve documentation at https://curve.readthedocs.io/dao-vecrv.html  ``` A userâ€™s veCRV balance decays linearly as the remaining time until the CRV unlock decreases. For example, a balance of 4000 CRV locked for one year provides the same amount of veCRV as 2000 CRV locked for two years, or 1000 CRV locked for four years. ```  On creation, targetVotes = 100, balance = 20 -> votesDifference = 80 -> reward is allocated for 80 votes  ```solidity         // Get the missing votes for the given receiver to reach the target votes         // We ignore any delegated boost here because they might expire during the Pledge duration         // (we can have a future version of this contract using adjusted_balance)         vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);          vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;         vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;         if(vars.totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();         if(vars.feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();          // Pull all the rewards in this contract         IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);         // And transfer the fees from the Pledge creator to the Chest contract         IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount); ```  Then 1 week passed, receiver's balance decay to 10  On creation, targetVotes = 100, balance = 10 but votesDifference stays 80, and reward has only allocated for 80 votes.  ```solidity         // Rewards are set in the Pledge as reward/veToken/sec         // To find the total amount of veToken delegated through the whole Boost duration         // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases         // each second of the Boost duration         uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;         // Then we can calculate the total amount of rewards for this Boost         uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;          if(rewardAmount > pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();         pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount; ```  A booster boosts 80 votes and takes all rewards in the pool. However, only 80 (From booster) + 10 (From receiver) = 90 votes is active. Not 100 votes that receiver promise in the targetVotes.  Then, if another booster tries to boost 10 votes, it will be reverted with RewardsBalanceTooLow since the first booster has taken all reward that is allocated for only 80 votes.  ## Recommended Mitigation Steps You should provide a way for the creator to provide additional rewards after the pledge creation. Or provide some reward refreshment function that recalculates votesDifference and transfers the required additional reward.
