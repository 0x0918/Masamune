# Handle  pedroais   # Vulnerability details  ## Impact Save gas ## Proof of Concept The cheaper operation should be done first to save gas . auctionStart == 0 is cheaper than block.timestamp < auctionStart  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L291     
# Handle  gzeon   # Vulnerability details  ## Impact If `msg.sender == issuer`, we don't need to call `pairBalance(msg.sender)` https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L447 ```         uint256 balance = pairBalance(msg.sender);         user.hasWithdrawnPair = true;          if (msg.sender == issuer) {             balance = lpSupply / 2;              emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);              if (tokenReserve > 0) {                 uint256 amount = tokenReserve;                 tokenReserve = 0;                 token.transfer(msg.sender, amount);             }         } else {             emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);         } ``` to ```         uint256 balance;         user.hasWithdrawnPair = true;          if (msg.sender == issuer) {             balance = lpSupply / 2;              emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);              if (tokenReserve > 0) {                 uint256 amount = tokenReserve;                 tokenReserve = 0;                 token.transfer(msg.sender, amount);             }         } else {             balance = pairBalance(msg.sender);             emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);         } ```  
# Handle  hyh   # Vulnerability details  ## Impact  Being instantiated with wrong configuration the contract will be inoperable.  If a misconfiguration is noticed too late the various types of malfunctions become possible.  ## Proof of Concept  RocketJoeStaking.initialize doesn't check input parameters, which are immutable due to initializer pattern:  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L72-75   ## Recommended Mitigation Steps  Consider checking joe, rJoe addresses and lastRewardTimestamp to be non-zero and also checking rJoePerSec to be within pre specified bounds  
# Handle  rfa   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L169-L172  ## Tools Used  ## Recommended Mitigation Steps ```             accRJoePerShare  +=             (rJoeReward * PRECISION) /             joeSupply; ```  
# Handle  sirhashalot   # Vulnerability details  ## Impact  Some functions in RocketJoeFactory.sol have zero checks for setting specific state variables, but there zero address checks are not always applied. Setting some of these state variables to the zero address, whether intentional or not, can break the protocol functionality. Adding these checks consistently would prevent this scenario.  ## Proof of Concept  The [constructor in RocketJoeFactory.sol](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L53-L61) performs zero address checks before setting the router, factory, penaltyCollector, and rJoe state variables.  Later in the same contract, the functions `setRJoe()`, `setPenaltyCollector()`, `setRouter()`, and `setFactory()` [omit the same zero address checks](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L159-L188) that were applied earlier. Since the issues that can be caused by setting these state variables to the zero address exist whether setting the value in the constructor or in the setter function, these checks should be applied consistently.  ## Recommended Mitigation Steps  Add zero address checks in the setter functions for these state variables just like is done in the constructor. If it is determined that a zero check for any of these state variables is not needed, then the zero check can be removed from the RocketJoeFactory.sol constructor for consistency.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `withdrawAVAX()` function of LaunchEvent.sol and `initialize()` function of RocketJoeStaking.sol can be declared external for gas savings  ## Proof of Concept  - [withdrawAVAX](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L349) - [initialize](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L57)  ## Recommended Mitigation Steps  Declare functions as external instead of public when possible  
# Handle  Jujic   # Vulnerability details  ## Impact The `rJoePerSec` does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L151 ``` function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {         updatePool();         rJoePerSec = _rJoePerSec;         emit UpdateEmissionRate(msg.sender, _rJoePerSec);     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Consider define  upper and lower bounds on the `_rJoePerSec`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/119e12d715ececc31478e833297f124cc15d27c2/contracts/RocketJoeFactory.sol#L97-L154  ```solidity function createRJLaunchEvent(     address _issuer,     uint256 _phaseOneStartTime,     address _token,     uint256 _tokenAmount,     uint256 _tokenIncentivesPercent,     uint256 _floorPrice,     uint256 _maxWithdrawPenalty,     uint256 _fixedWithdrawPenalty,     uint256 _maxAllocation,     uint256 _userTimelock,     uint256 _issuerTimelock ) external override returns (address) {     require(         getRJLaunchEvent[_token] == address(0),         "RJFactory: token has already been issued"     );     require(_issuer != address(0), "RJFactory: issuer can't be 0 address");     require(_token != address(0), "RJFactory: token can't be 0 address");     require(_token != wavax, "RJFactory: token can't be wavax");     require(         _tokenAmount > 0,         "RJFactory: token amount needs to be greater than 0"     );     require(         IJoeFactory(factory).getPair(_token, wavax) == address(0) ||             IJoePair(IJoeFactory(factory).getPair(_token, wavax))                 .totalSupply() ==             0,         "RJFactory: liquid pair already exists"     );      address launchEvent = Clones.clone(eventImplementation);      // msg.sender needs to approve RocketJoeFactory     IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);      ILaunchEvent(payable(launchEvent)).initialize(         _issuer,         _phaseOneStartTime,         _token,         _tokenIncentivesPercent,         _floorPrice,         _maxWithdrawPenalty,         _fixedWithdrawPenalty,         _maxAllocation,         _userTimelock,         _issuerTimelock     );      getRJLaunchEvent[_token] = launchEvent;     isRJLaunchEvent[launchEvent] = true;     allRJLaunchEvents.push(launchEvent);      _emitLaunchedEvent(_issuer, _token, _phaseOneStartTime);      return launchEvent; } ```  At L132, `_token.transferFrom()` can be used to re-enter the `createRJLaunchEvent()` function, before the storage change at L147-149.  This will allow the attacker to create multiple `launchEvent` contracts and get them listed in `allRJLaunchEvents`.  Even though there is no significant impact as far as we can tell from the smart contract code. We believe this is still unexpected and may cause other parts of the system, say the frontend to malfunction in some cases.  ### Recommendation  Consider moving L132 `_token.transferFrom()` to after L147-149 to prevent re-entrance.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L98-L155  ```solidity     function createRJLaunchEvent(         address _issuer,         uint256 _phaseOneStartTime,         address _token,         uint256 _tokenAmount,         uint256 _tokenIncentivesPercent,         uint256 _floorPrice,         uint256 _maxWithdrawPenalty,         uint256 _fixedWithdrawPenalty,         uint256 _maxAllocation,         uint256 _userTimelock,         uint256 _issuerTimelock     ) external override returns (address) {         require(             getRJLaunchEvent[_token] == address(0),             "RJFactory: token has already been issued"         );         require(_issuer != address(0), "RJFactory: issuer can't be 0 address");         require(_token != address(0), "RJFactory: token can't be 0 address");         require(_token != wavax, "RJFactory: token can't be wavax");         require(             _tokenAmount > 0,             "RJFactory: token amount needs to be greater than 0"         );         require(             IJoeFactory(factory).getPair(_token, wavax) == address(0) ||                 IJoePair(IJoeFactory(factory).getPair(_token, wavax))                     .totalSupply() ==                 0,             "RJFactory: liquid pair already exists"         );         // ...     } ```  `_issuer != address(0)`, `_token != address(0)`, `_tokenAmount > 0` are cheaper than other checks who read storage or do external call.   Therefore, checking `_issuer != address(0)`, `_token != address(0)`, `_tokenAmount > 0` first can save some gas.   ### Recommendation  Change to:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L98-L155  ```solidity     function createRJLaunchEvent(         address _issuer,         uint256 _phaseOneStartTime,         address _token,         uint256 _tokenAmount,         uint256 _tokenIncentivesPercent,         uint256 _floorPrice,         uint256 _maxWithdrawPenalty,         uint256 _fixedWithdrawPenalty,         uint256 _maxAllocation,         uint256 _userTimelock,         uint256 _issuerTimelock     ) external override returns (address) {         require(_issuer != address(0), "RJFactory: issuer can't be 0 address");         require(_token != address(0), "RJFactory: token can't be 0 address");         require(             _tokenAmount != 0,             "RJFactory: token amount needs to be greater than 0"         );         require(             getRJLaunchEvent[_token] == address(0),             "RJFactory: token has already been issued"         );         require(_token != wavax, "RJFactory: token can't be wavax");         require(             IJoeFactory(factory).getPair(_token, wavax) == address(0) ||                 IJoePair(IJoeFactory(factory).getPair(_token, wavax))                     .totalSupply() ==                 0,             "RJFactory: liquid pair already exists"         );         // ...     } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L19-L19  ```solidity contract LaunchEvent is Ownable { ```  The `LaunchEvent.sol` contract never utilized `onlyOwner` / `owner()` or any other features provided by the `Ownable` library.  Therefore, `is Ownable` can be removed.   
# Handle  WatchPug   # Vulnerability details  It is cheaper to use `!= 0` than `> 0` for uint256.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L101-L101  ```solidity if (user.amount > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L119-L119  ```solidity _tokenAmount > 0, ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L338-L338  ```solidity if (rJoeNeeded > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L355-L355  ```solidity require(_amount > 0, "LaunchEvent: invalid withdraw amount"); ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L370-L370  ```solidity if (feeAmount > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L455-L455  ```solidity if (tokenReserve > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L537-L537  ```solidity if (excessToken > 0) { ```  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  `factory.getPair(wavaxAddress, tokenAddress)` and `factory.getPair(tokenAddress, wavaxAddress)` in `LaunchEvent#createPair()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L377-L435  ```solidity function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {     // ...     require(         factory.getPair(wavaxAddress, tokenAddress) == address(0) ||             IJoePair(                 IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)             ).totalSupply() ==             0,         "LaunchEvent: liquid pair already exists"     );     // ...     pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));     // ... } ```  note: `factory.getPair(a, b)` 与  `factory.getPair(b, a)` 相同, see  [code at github](https://github.com/traderjoe-xyz/joe-core/blob/5c2ca96c3835e7f2660f2904a1224bb7c8f3b7a7/contracts/traderjoe/JoeFactory.sol#L41-L42) or [code at avascan](https://avascan.info/blockchain/c/address/0x9Ad6C38BE94206cA50bb0d90783181662f0Cfa10/contract#:~:text=getPair%5Btoken1%5D%5Btoken0%5D%20%3D%20pair%3B%20//%20populate%20mapping%20in%20the%20reverse%20direction)  ```solidity getPair[token0][token1] = pair; getPair[token1][token0] = pair; // populate mapping in the reverse direction ```  `IJoeFactory(factory).getPair(_token, wavax)` in `RocketJoeFactory#createRJLaunchEvent()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L122-L128  ```solidity require(     IJoeFactory(factory).getPair(_token, wavax) == address(0) ||         IJoePair(IJoeFactory(factory).getPair(_token, wavax))             .totalSupply() ==         0,     "RJFactory: liquid pair already exists" ); ```   `token.decimals()` in `LaunchEvent#createPair()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L395-L405  ```solidity if (     floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated ) {     tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;     // ... } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L82-L82  ```solidity IJoeFactory private factory; ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L385-L385  ```solidity IJoeFactory(factory).getPair(wavaxAddress, tokenAddress) ```  `factory` is defined as `IJoeFactory` already, the type casting is redundant.  
# Handle  WatchPug   # Vulnerability details  Non-constant (especially public) variables should not be in `SCREAMING_SNAKE_CASE`, or they may be misunderstood as constants.  Consider changing to `camelCase`.  See: https://docs.soliditylang.org/en/v0.8.11/style-guide.html?highlight=name#local-and-state-variable-names  Instances include:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/interfaces/IRocketJoeFactory.sol#L35-L39  ```solidity function PHASE_ONE_DURATION() external view returns (uint256);  function PHASE_ONE_NO_FEE_DURATION() external view returns (uint256);  function PHASE_TWO_DURATION() external view returns (uint256); ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L29-L31  ```solidity uint256 public override PHASE_ONE_DURATION = 2 days; uint256 public override PHASE_ONE_NO_FEE_DURATION = 1 days; uint256 public override PHASE_TWO_DURATION = 1 days; ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L200-L214  ```solidity function setPhaseDuration(uint256 _phaseNumber, uint256 _duration)     external     override     onlyOwner {     if (_phaseNumber == 1) {         require(             _duration > PHASE_ONE_NO_FEE_DURATION,             "RJFactory: phase one duration lower than no fee duration"         );         PHASE_ONE_DURATION = _duration;     } else if (_phaseNumber == 2) {         PHASE_TWO_DURATION = _duration;     } } ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L218-L228  ```solidity function setPhaseOneNoFeeDuration(uint256 _noFeeDuration)     external     override     onlyOwner {     require(         _noFeeDuration < PHASE_ONE_DURATION,         "RJFactory: no fee duration bigger than phase one duration"     );     PHASE_ONE_NO_FEE_DURATION = _noFeeDuration; } ```  
# Handle  cmichel   # Vulnerability details  `RocketJoeStaking.withdraw`: The `_safeRJoeTransfer(msg.sender, pending)` only needs to be performed if `pending > 0`.  
# Handle  cmichel   # Vulnerability details  `LaunchEvent.getReserves`: The comment says: `@notice Returns the current balance of the pool`. The "of the pool" part can be misleading as the `tokenIncentivesBalance` are never part of the _pool pair_. Consider changing this to "Returns the outstanding balance of the launch event contract".  
# Handle  cmichel   # Vulnerability details  `LaunchEvent.tokenIncentivesPercent`: The math in the comment is wrong: `/// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives`. It should be `105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives`  
# Handle  cmichel   # Vulnerability details  The `RocketJoeStaking.lastRewardTimestamp` is initialized to zero. Usually, this does not matter as `updatePool` is called before the first deposit and when `joeSupply = joe.balanceOf(address(this)) == 0`, it is set to the current time.  ```solidity function updatePool() public {     if (block.timestamp <= lastRewardTimestamp) {         return;     }     uint256 joeSupply = joe.balanceOf(address(this));      // @audit lastRewardTimestamp is not initialized. can send 1 Joe to this contract directly => lots of rJoe minted to this contract     if (joeSupply == 0) {         lastRewardTimestamp = block.timestamp;         return;     }     uint256 multiplier = block.timestamp - lastRewardTimestamp;     uint256 rJoeReward = multiplier * rJoePerSec;     accRJoePerShare =         accRJoePerShare +         (rJoeReward * PRECISION) /         joeSupply;     lastRewardTimestamp = block.timestamp;      rJoe.mint(address(this), rJoeReward); } ```  However, if a user first directly transfers `Joe` tokens to the contract before the first `updatePool` call, the `block.timestamp - lastRewardTimestamp = block.timestamp` will be a large timestamp value and lots of `rJoe` will be minted (but not distributed to users). Even though they are not distributed to the users, inflating the `rJoe` total supply might not be desired.  #### Recommendation Consider tracking the actual total deposits in a storage variable and using this value instead of the current balance for `joeSupply`. This way, transferring tokens to the contract has no influence and depositing through `deposit` first calls `updatePool` and initializes `lastRewardTimestamp`.   
# Handle  cmichel   # Vulnerability details  The `LaunchEvent.rJoePerAvax` variable is an _unscaled_ integer value and used to compute the `rJoeAmount` as:  ```solidity function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {     return _avaxAmount * rJoePerAvax; } ```  This means the required `rJoeAmount` to burn can never be less than the deposited `avaxAmount`. If a launch event desires to use `0.5 rJoe` per AVAX, this is not possible.  #### Recommendation Consider the `rJoePerAvax` value as a value scaled by `1e18` and then divide by this scale in `getRJoeAmount` again.  
# Handle  cmichel   # Vulnerability details  Imagine the following sequence of events:  - `LaunchEvent.createPair()` is called which sets `wavaxReserve = 0`, adds liquidity to the pair and receives `lpSupply` LP tokens. - `LaunchEvent.allowEmergencyWithdraw()` is called which enters emergency / paused mode and disallows normal withdrawals. - Users can only call `LaunchEvent.emergencyWithdraw` which reverts as the WAVAX reserve was already used to provide liquidity and cannot be paid out. Users don't receive their LP tokens either. The users lost their entire deposit in this case.  #### Recommendation Consider paying out LP tokens in `emergencyWithdraw`.   
# Handle  cmichel   # Vulnerability details  The `LaunchEvent.createPair` requires that no previous pool was created for the `WAVAX <> _token` pair.  ```solidity function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {     (address wavaxAddress, address tokenAddress) = (         address(WAVAX),         address(token)     );     // @audit grief: anyone can create pair     require(         factory.getPair(wavaxAddress, tokenAddress) == address(0),         "LaunchEvent: pair already created"     );      // ... } ```  A griefer can create a pool for the `WAVAX <> _token` pair by calling [`JoeFactory.createPair(WAVAX, _token)`](https://snowtrace.io/address/0x9ad6c38be94206ca50bb0d90783181662f0cfa10#contracts) while the launch event phase 1 or 2 is running. No liquidity can then be provided and an emergency state must be triggered for users and the issuer to be able to withdraw again.  #### Recommendation It must be assumed that the pool is already created and even initialized as pool creation and liquidity provisioning is permissionless. Special attention must be paid if the pool is already initialized with liquidity at a different price than the launch event price.  It would be enough to have a standard min. LP return "slippage" check (using parameter values for `amountAMin/amountBMin` instead of the hardcoded ones in `router.addLiquidity`) in `LaunchEvent.createPair()`. The function must then be callable with special privileges only, for example, by the issuer. Alternatively, the slippage check can be hardcoded as a percentage of the raised amounts (`amountADesired = 0.95 * wavaxReserve, amountBDesired = 0.95 * tokenAllocated`).  This will prevent attacks that try to provide LP at a bad pool price as the transaction will revert when receiving less than the slippage parameter. If the pool is already initialized, it should just get arbitraged to the auction token price and liquidity can then be provided at the expected rate again.   
# Handle  cmichel   # Vulnerability details  In `LaunchEvent.createPair`, when the floor price is not reached (`floorPrice > wavaxReserve * 1e18 / tokenAllocated`), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price.  Note that the `floorPrice` is supposed to have a precision of 18:  > /// @param _floorPrice Price of each token in AVAX, scaled to 1e18  The `floorPrice > (wavaxReserve * 1e18) / tokenAllocated` check is correct but the `tokenAllocated` computation involves the `token` decimals:  ```solidity // @audit should be wavaxReserve * 1e18 / floorPrice tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice; ```  This computation does not work for `token`s that don't have 18 decimals.  #### Example Assume I want to sell `1.0 wBTC = 1e8 wBTC` (8 decimals) at `2,000.0 AVAX = 2,000 * 1e18 AVAX`. The `floorPrice` is `2000e18 * 1e18 / 1e8 = 2e31`  Assume the Launch event only raised `1,000.0 AVAX` - half of the floor price for the issued token amount of `1.0 WBTC` (it should therefore allocate only half a WBTC) - and the token amount will be reduced as: `floorPrice = 2e31 > 1000e18 * 1e18 / 1e8 = 1e31 = actualPrice`. Then, `tokenAllocated = 1000e18 * 1e8 / 2e31 = 1e29 / 2e31 = 0` and no tokens would be allocated, instead of `0.5 WBTC = 0.5e8 WBTC`.  The computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice = 1000e18 * 1e18 / 2e31 = 1e39 / 2e31 = 10e38 / 2e31 = 5e7 = 0.5e8`.  #### Recommendation The new `tokenAllocated` computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice;`.   
# Handle  hyh   # Vulnerability details  ## Impact  As different compiler versions have critical behavior specifics if the contract gets accidentally deployed using another compiler version compared to one they tested with, various types of undesired behavior can be introduced.  ## Proof of Concept  All the contracts in scope use unlocked pragma: ```pragma solidity ^0.8.0```, allowing wide enough range of versions.  Examples:  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L4  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeToken.sol#L3   ## Recommended Mitigation Steps  Consider locking compiler version, for example `pragma solidity 0.8.6`.  This can have additional benefits, for example using custom errors to save gas and so forth.  
# Handle  kirk-baird   # Vulnerability details  ## Impact  The function [allowEmergencyWithdraw()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L520) may be called by the `rocketJoeFactory.owner()` at any time. If it is called while the protocol is in Stage 3 and a pair has been created then the LP tokens will be locked and both issues and depositors will be unable to withdraw.  ## Proof of Concept  If `allowEmergencyWithdraw()`  is called `stopped` is set to `true`. As a result functions [withdrawIncentives()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L468) and [withdrawLiquidity()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L438) will revert due to the `isStopped(false)` modifier reverting.  Additionally, [emergencyWithdraw()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L494) will revert since all the `WAVAX` and `token` balances have been transferred to the liquidity pool.  Thus, depositors and issuers will have no methods of removing their LP tokens or incentives.   ## Recommended Mitigation Steps  Consider adding the requirement `require(address(pair) != address(0), "LaunchEvent: pair not created");` to the function `allowEmergencyWithdraw()`.  
# Handle  kirk-baird   # Vulnerability details  ## Impact  The logic in [_atPhase()`](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L590) can be simplified to save gas and code complexity.  The code can be simplified to the follwoing.  ```solidity     function _atPhase(Phase _phase) internal view {             require(currentPhase() == _phase, "LaunchEvent: incorrect phase");     } ```  ## Proof of Concept  n/a  ## Tools Used  n/a  ## Recommended Mitigation Steps  Consider updating the code to that procided above.  
# Handle  wuwe1   # Vulnerability details  ## Impact Causing confuse to user and developer.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L55  `105000 * 1e18 / (1e18 + 5e16)` is equal to `100000`    ## Recommended Mitigation Steps  change to  `105000 - 105000 * 1e18 / (1e18 + 5e16) = 5000`  
# Handle  wuwe1   # Vulnerability details  ## Impact Off-chain tools will not work as expected.  ## Proof of Concept  Missing UserWithdrawn  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L132](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L132)  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L372](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L372)  Missing IssuingTokenDeposited  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L124](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L124)  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L287](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L287)   ## Recommended Mitigation Steps  Add `emit UserWithdrawn(user, amountMinusFee)` after L372  Add `emit IssuingTokenDeposited(_token, balance)` after L287  
# Handle  Dravee   # Vulnerability details  ## Impact A division by 0 could occur  ## Proof of Concept There are no checks that the denominator is `!= 0` here: ``` File: LaunchEvent.sol 392:         uint256 tokenAllocated = tokenReserve; 393:  394:         // Adjust the amount of tokens sent to the pool if floor price not met 395:         if ( 396:             floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated 397:         ) { ```  tokenReserve (`uint256 tokenAllocated = tokenReserve;`) can be equal to 0 according to this comment: https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L106  Therefore this could happen  ## Tools Used VS Code  ## Recommended Mitigation Steps Check for `tokenAllocated != 0` before this division  
# Handle  kirk-baird   # Vulnerability details  ## Impact  Note: this attack requires `rJoe` to relinquish control during `tranfer()` which under the current [RocketJoeToken](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeToken.sol) it does not. Thus this vulnerability is raised as medium rather than high. Although it's not exploitable currently, it is a highly risky code pattern that should be avoided.  This vulnerability would allow the entire rJoe balance to be drained from the contract.  ## Proof of Concept  The function [deposit()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L96) would be vulnerable to reentrancy if rJoe relinquished control flow.  The following lines show the reward calculations in variable `pending`. These calculations use two state variables `user.amount` and `user.rewardDebt`. Each of these are updated after `_safeRJoeTransfer()`.  Thus if an attacker was able to get control flow during the `rJoe::tranfer()` function they would be able to reenter `deposit()` and the value calculated for `pending`would be the same as the previous iteration hence they would again be transferred `pending` rJoe tokens. During the rJoe transfer the would again gain control of the execution and call `deposit()` again. The process could be repeated until the entire rJoe balance of the contract has been transferred to the attacker.  ```solidity         if (user.amount > 0) {             uint256 pending = (user.amount * accRJoePerShare) /                 PRECISION -                 user.rewardDebt;             _safeRJoeTransfer(msg.sender, pending);         }         user.amount = user.amount + _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION; ```   ## Tools Used  n/a  ## Recommended Mitigation Steps  There are two possible mitigations. First is to use the [openzeppelin reentrancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) over the `deposit()` function which will prevent multiple deposits being made simultaneously.  The second mitigation is to follow the [checks-effects-interactions](https://docs.soliditylang.org/en/v0.8.11/security-considerations.html#re-entrancy) pattern. This would involve updating all state variables before making any external calls.  
# Handle  p4st13r4   # Vulnerability details  ## Impact  `pendingRJoe()` reads a user into a storage variable, which is redundant since it’s a `view()` function and the variable is never modified in place. It can be replaced by a `memory` variable for readability  ## Proof of Concept  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L82](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L82)  ## Tools Used  Editor  ## Recommended Mitigation Steps  ```jsx UserInfo memory user = userInfo[_user]; ```  
# Handle  rfa   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeFactory.sol#L53-L59 && operator cost more gas. ## Tools Used  ## Recommended Mitigation Steps use require multiple times instead of && ``` require(_eventImplementation != address(0), "RJFactory: Addresses can't be null address"); require(_rJoe != address(0),  "RJFactory: Addresses can't be null address"); ...  ```  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  LaunchEvent has an explicit `initialized` variable which is in storage. https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L228  To save an SSTORE we could just check that `_auctionStart > 0` as this is a sufficient check for initialisation. If a getter is needed then a function like the below could be added.  ``` function initialized() external view returns bool {   return auctionStart > 0; } ```  ## Recommended Mitigation Steps  As above.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  LaunchEvent pays out fewer incentives than expected.  ## Proof of Concept  When creating a launch event, issuers must provide the total amount of tokens they want to send to the contract and what percentage of these are reserved for incentives.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L84-L86  Note that there's an inconsistency between the documentation and the implementation. Documentation implies that the issuer provides `_tokenAmount` tokens and an additional `_tokenAmount * _tokenIncentivesPercent / 1e18` as an incentive whereas in reality they only provide `_tokenAmount`   This can be seen here:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L133  For us to pay out the correct percentage of `_tokenAmount` as incentives would expect that amount to be `(_tokenAmount * _tokenIncentivesPercent) / 1e18` however as can be seen we pay out `_tokenAmount - (_tokenAmount * 1e18) / (1e18 + _tokenIncentivesPercent)`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L273  This will consistently pay out a smaller percentage of the total amount of tokens than `_tokenIncentivesPercent`.  ## Recommended Mitigation Steps  Switch to having the issuer provide explicit amounts `_tokenIssuanceAmount` and `_tokenIncentivesAmount` to avoid mistakes about how percentages are handled.  Add tests to ensure that the contract is initialised with the correct state.  
# Handle  defsec   # Vulnerability details  ## Impact  In the JoeStaking contract, the amount check should be placed on the contract. IF the amount is more than transfer operations should be completed.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L129  2. _amount is not checked if Its more than zero.  ```     function withdraw(uint256 _amount) external {         UserInfo storage user = userInfo[msg.sender];         require(             user.amount >= _amount,             "RocketJoeStaking: withdraw amount exceeds balance"         );          updatePool();          uint256 pending = (user.amount * accRJoePerShare) /             PRECISION -             user.rewardDebt;          user.amount = user.amount - _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;          _safeRJoeTransfer(msg.sender, pending);         joe.safeTransfer(address(msg.sender), _amount);         emit Withdraw(msg.sender, _amount);     }  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to add the following check.   ```     function withdraw(uint256 _amount) external {         UserInfo storage user = userInfo[msg.sender];         require(             user.amount >= _amount,             "RocketJoeStaking: withdraw amount exceeds balance"         );          updatePool();          uint256 pending = (user.amount * accRJoePerShare) /             PRECISION -             user.rewardDebt;          user.amount = user.amount - _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;   if(pending != 0) {         _safeRJoeTransfer(msg.sender, pending); }  if(_amount != 0){         joe.safeTransfer(address(msg.sender), _amount); }          emit Withdraw(msg.sender, _amount);      }   ```   
# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been observed that the token can be same as WAVAX. The initialize function should not allow if token is equals to wavax. That would affect all asset management.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L219  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L411  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  On the Launchevent, token should not be equal to wavax.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In LauchEvent.sol the withdrawAVAX() function makes an external call to the msg.sender by way of _safeTransferAVAX.  This allows the caller to reenter this and other functions in this and other protocol files.  To prevent reentrancy and cross function reentrancy there should be reentrancy guard modifiers placed on the withdrawAVAX() function and any other function that makes external calls to the caller.   ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L368  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L370  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add reentrancy guard modifier to withdrawAVAX() function.   
# Handle  0x1f8b   # Vulnerability details  ## Impact Owner can Denial of service.  ## Proof of Concept In the contract `RocketJoeStaking` there are two ways to set `rJoePerSec`, one in the `initialize` and the second one in `updateEmissionRate`, in both of them there are no checks of the received value, so it's possible to use a high value and deny the service in line `updatePool:168`.  ## Tools Used Manual review  ## Recommended Mitigation Steps Change the type to uint128 for `rJoePerSec`.  
# Handle  cccz   # Vulnerability details  ## Impact  It is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelin’s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L457  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L463  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L489  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L513  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L537  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Consider using safeTransfer/safeTransferFrom or require() consistently.   
# Handle  pedroais   # Vulnerability details  ## Impact Save gas ## Proof of Concept The cheaper operation should be done first to save gas . auctionStart == 0 is cheaper than block.timestamp < auctionStart  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L291     
# Handle  gzeon   # Vulnerability details  ## Impact If `msg.sender == issuer`, we don't need to call `pairBalance(msg.sender)` https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L447 ```         uint256 balance = pairBalance(msg.sender);         user.hasWithdrawnPair = true;          if (msg.sender == issuer) {             balance = lpSupply / 2;              emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);              if (tokenReserve > 0) {                 uint256 amount = tokenReserve;                 tokenReserve = 0;                 token.transfer(msg.sender, amount);             }         } else {             emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);         } ``` to ```         uint256 balance;         user.hasWithdrawnPair = true;          if (msg.sender == issuer) {             balance = lpSupply / 2;              emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);              if (tokenReserve > 0) {                 uint256 amount = tokenReserve;                 tokenReserve = 0;                 token.transfer(msg.sender, amount);             }         } else {             balance = pairBalance(msg.sender);             emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);         } ```  
# Handle  hyh   # Vulnerability details  ## Impact  Being instantiated with wrong configuration the contract will be inoperable.  If a misconfiguration is noticed too late the various types of malfunctions become possible.  ## Proof of Concept  RocketJoeStaking.initialize doesn't check input parameters, which are immutable due to initializer pattern:  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L72-75   ## Recommended Mitigation Steps  Consider checking joe, rJoe addresses and lastRewardTimestamp to be non-zero and also checking rJoePerSec to be within pre specified bounds  
# Handle  rfa   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L169-L172  ## Tools Used  ## Recommended Mitigation Steps ```             accRJoePerShare  +=             (rJoeReward * PRECISION) /             joeSupply; ```  
# Handle  sirhashalot   # Vulnerability details  ## Impact  Some functions in RocketJoeFactory.sol have zero checks for setting specific state variables, but there zero address checks are not always applied. Setting some of these state variables to the zero address, whether intentional or not, can break the protocol functionality. Adding these checks consistently would prevent this scenario.  ## Proof of Concept  The [constructor in RocketJoeFactory.sol](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L53-L61) performs zero address checks before setting the router, factory, penaltyCollector, and rJoe state variables.  Later in the same contract, the functions `setRJoe()`, `setPenaltyCollector()`, `setRouter()`, and `setFactory()` [omit the same zero address checks](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L159-L188) that were applied earlier. Since the issues that can be caused by setting these state variables to the zero address exist whether setting the value in the constructor or in the setter function, these checks should be applied consistently.  ## Recommended Mitigation Steps  Add zero address checks in the setter functions for these state variables just like is done in the constructor. If it is determined that a zero check for any of these state variables is not needed, then the zero check can be removed from the RocketJoeFactory.sol constructor for consistency.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `withdrawAVAX()` function of LaunchEvent.sol and `initialize()` function of RocketJoeStaking.sol can be declared external for gas savings  ## Proof of Concept  - [withdrawAVAX](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L349) - [initialize](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L57)  ## Recommended Mitigation Steps  Declare functions as external instead of public when possible  
# Handle  Jujic   # Vulnerability details  ## Impact The `rJoePerSec` does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L151 ``` function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {         updatePool();         rJoePerSec = _rJoePerSec;         emit UpdateEmissionRate(msg.sender, _rJoePerSec);     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Consider define  upper and lower bounds on the `_rJoePerSec`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/119e12d715ececc31478e833297f124cc15d27c2/contracts/RocketJoeFactory.sol#L97-L154  ```solidity function createRJLaunchEvent(     address _issuer,     uint256 _phaseOneStartTime,     address _token,     uint256 _tokenAmount,     uint256 _tokenIncentivesPercent,     uint256 _floorPrice,     uint256 _maxWithdrawPenalty,     uint256 _fixedWithdrawPenalty,     uint256 _maxAllocation,     uint256 _userTimelock,     uint256 _issuerTimelock ) external override returns (address) {     require(         getRJLaunchEvent[_token] == address(0),         "RJFactory: token has already been issued"     );     require(_issuer != address(0), "RJFactory: issuer can't be 0 address");     require(_token != address(0), "RJFactory: token can't be 0 address");     require(_token != wavax, "RJFactory: token can't be wavax");     require(         _tokenAmount > 0,         "RJFactory: token amount needs to be greater than 0"     );     require(         IJoeFactory(factory).getPair(_token, wavax) == address(0) ||             IJoePair(IJoeFactory(factory).getPair(_token, wavax))                 .totalSupply() ==             0,         "RJFactory: liquid pair already exists"     );      address launchEvent = Clones.clone(eventImplementation);      // msg.sender needs to approve RocketJoeFactory     IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);      ILaunchEvent(payable(launchEvent)).initialize(         _issuer,         _phaseOneStartTime,         _token,         _tokenIncentivesPercent,         _floorPrice,         _maxWithdrawPenalty,         _fixedWithdrawPenalty,         _maxAllocation,         _userTimelock,         _issuerTimelock     );      getRJLaunchEvent[_token] = launchEvent;     isRJLaunchEvent[launchEvent] = true;     allRJLaunchEvents.push(launchEvent);      _emitLaunchedEvent(_issuer, _token, _phaseOneStartTime);      return launchEvent; } ```  At L132, `_token.transferFrom()` can be used to re-enter the `createRJLaunchEvent()` function, before the storage change at L147-149.  This will allow the attacker to create multiple `launchEvent` contracts and get them listed in `allRJLaunchEvents`.  Even though there is no significant impact as far as we can tell from the smart contract code. We believe this is still unexpected and may cause other parts of the system, say the frontend to malfunction in some cases.  ### Recommendation  Consider moving L132 `_token.transferFrom()` to after L147-149 to prevent re-entrance.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L98-L155  ```solidity     function createRJLaunchEvent(         address _issuer,         uint256 _phaseOneStartTime,         address _token,         uint256 _tokenAmount,         uint256 _tokenIncentivesPercent,         uint256 _floorPrice,         uint256 _maxWithdrawPenalty,         uint256 _fixedWithdrawPenalty,         uint256 _maxAllocation,         uint256 _userTimelock,         uint256 _issuerTimelock     ) external override returns (address) {         require(             getRJLaunchEvent[_token] == address(0),             "RJFactory: token has already been issued"         );         require(_issuer != address(0), "RJFactory: issuer can't be 0 address");         require(_token != address(0), "RJFactory: token can't be 0 address");         require(_token != wavax, "RJFactory: token can't be wavax");         require(             _tokenAmount > 0,             "RJFactory: token amount needs to be greater than 0"         );         require(             IJoeFactory(factory).getPair(_token, wavax) == address(0) ||                 IJoePair(IJoeFactory(factory).getPair(_token, wavax))                     .totalSupply() ==                 0,             "RJFactory: liquid pair already exists"         );         // ...     } ```  `_issuer != address(0)`, `_token != address(0)`, `_tokenAmount > 0` are cheaper than other checks who read storage or do external call.   Therefore, checking `_issuer != address(0)`, `_token != address(0)`, `_tokenAmount > 0` first can save some gas.   ### Recommendation  Change to:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L98-L155  ```solidity     function createRJLaunchEvent(         address _issuer,         uint256 _phaseOneStartTime,         address _token,         uint256 _tokenAmount,         uint256 _tokenIncentivesPercent,         uint256 _floorPrice,         uint256 _maxWithdrawPenalty,         uint256 _fixedWithdrawPenalty,         uint256 _maxAllocation,         uint256 _userTimelock,         uint256 _issuerTimelock     ) external override returns (address) {         require(_issuer != address(0), "RJFactory: issuer can't be 0 address");         require(_token != address(0), "RJFactory: token can't be 0 address");         require(             _tokenAmount != 0,             "RJFactory: token amount needs to be greater than 0"         );         require(             getRJLaunchEvent[_token] == address(0),             "RJFactory: token has already been issued"         );         require(_token != wavax, "RJFactory: token can't be wavax");         require(             IJoeFactory(factory).getPair(_token, wavax) == address(0) ||                 IJoePair(IJoeFactory(factory).getPair(_token, wavax))                     .totalSupply() ==                 0,             "RJFactory: liquid pair already exists"         );         // ...     } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L19-L19  ```solidity contract LaunchEvent is Ownable { ```  The `LaunchEvent.sol` contract never utilized `onlyOwner` / `owner()` or any other features provided by the `Ownable` library.  Therefore, `is Ownable` can be removed.   
# Handle  WatchPug   # Vulnerability details  It is cheaper to use `!= 0` than `> 0` for uint256.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L101-L101  ```solidity if (user.amount > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L119-L119  ```solidity _tokenAmount > 0, ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L338-L338  ```solidity if (rJoeNeeded > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L355-L355  ```solidity require(_amount > 0, "LaunchEvent: invalid withdraw amount"); ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L370-L370  ```solidity if (feeAmount > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L455-L455  ```solidity if (tokenReserve > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L537-L537  ```solidity if (excessToken > 0) { ```  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  `factory.getPair(wavaxAddress, tokenAddress)` and `factory.getPair(tokenAddress, wavaxAddress)` in `LaunchEvent#createPair()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L377-L435  ```solidity function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {     // ...     require(         factory.getPair(wavaxAddress, tokenAddress) == address(0) ||             IJoePair(                 IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)             ).totalSupply() ==             0,         "LaunchEvent: liquid pair already exists"     );     // ...     pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));     // ... } ```  note: `factory.getPair(a, b)` 与  `factory.getPair(b, a)` 相同, see  [code at github](https://github.com/traderjoe-xyz/joe-core/blob/5c2ca96c3835e7f2660f2904a1224bb7c8f3b7a7/contracts/traderjoe/JoeFactory.sol#L41-L42) or [code at avascan](https://avascan.info/blockchain/c/address/0x9Ad6C38BE94206cA50bb0d90783181662f0Cfa10/contract#:~:text=getPair%5Btoken1%5D%5Btoken0%5D%20%3D%20pair%3B%20//%20populate%20mapping%20in%20the%20reverse%20direction)  ```solidity getPair[token0][token1] = pair; getPair[token1][token0] = pair; // populate mapping in the reverse direction ```  `IJoeFactory(factory).getPair(_token, wavax)` in `RocketJoeFactory#createRJLaunchEvent()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L122-L128  ```solidity require(     IJoeFactory(factory).getPair(_token, wavax) == address(0) ||         IJoePair(IJoeFactory(factory).getPair(_token, wavax))             .totalSupply() ==         0,     "RJFactory: liquid pair already exists" ); ```   `token.decimals()` in `LaunchEvent#createPair()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L395-L405  ```solidity if (     floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated ) {     tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;     // ... } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L82-L82  ```solidity IJoeFactory private factory; ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L385-L385  ```solidity IJoeFactory(factory).getPair(wavaxAddress, tokenAddress) ```  `factory` is defined as `IJoeFactory` already, the type casting is redundant.  
# Handle  WatchPug   # Vulnerability details  Non-constant (especially public) variables should not be in `SCREAMING_SNAKE_CASE`, or they may be misunderstood as constants.  Consider changing to `camelCase`.  See: https://docs.soliditylang.org/en/v0.8.11/style-guide.html?highlight=name#local-and-state-variable-names  Instances include:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/interfaces/IRocketJoeFactory.sol#L35-L39  ```solidity function PHASE_ONE_DURATION() external view returns (uint256);  function PHASE_ONE_NO_FEE_DURATION() external view returns (uint256);  function PHASE_TWO_DURATION() external view returns (uint256); ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L29-L31  ```solidity uint256 public override PHASE_ONE_DURATION = 2 days; uint256 public override PHASE_ONE_NO_FEE_DURATION = 1 days; uint256 public override PHASE_TWO_DURATION = 1 days; ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L200-L214  ```solidity function setPhaseDuration(uint256 _phaseNumber, uint256 _duration)     external     override     onlyOwner {     if (_phaseNumber == 1) {         require(             _duration > PHASE_ONE_NO_FEE_DURATION,             "RJFactory: phase one duration lower than no fee duration"         );         PHASE_ONE_DURATION = _duration;     } else if (_phaseNumber == 2) {         PHASE_TWO_DURATION = _duration;     } } ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L218-L228  ```solidity function setPhaseOneNoFeeDuration(uint256 _noFeeDuration)     external     override     onlyOwner {     require(         _noFeeDuration < PHASE_ONE_DURATION,         "RJFactory: no fee duration bigger than phase one duration"     );     PHASE_ONE_NO_FEE_DURATION = _noFeeDuration; } ```  
# Handle  cmichel   # Vulnerability details  `RocketJoeStaking.withdraw`: The `_safeRJoeTransfer(msg.sender, pending)` only needs to be performed if `pending > 0`.  
# Handle  cmichel   # Vulnerability details  `LaunchEvent.getReserves`: The comment says: `@notice Returns the current balance of the pool`. The "of the pool" part can be misleading as the `tokenIncentivesBalance` are never part of the _pool pair_. Consider changing this to "Returns the outstanding balance of the launch event contract".  
# Handle  cmichel   # Vulnerability details  `LaunchEvent.tokenIncentivesPercent`: The math in the comment is wrong: `/// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives`. It should be `105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives`  
# Handle  cmichel   # Vulnerability details  The `RocketJoeStaking.lastRewardTimestamp` is initialized to zero. Usually, this does not matter as `updatePool` is called before the first deposit and when `joeSupply = joe.balanceOf(address(this)) == 0`, it is set to the current time.  ```solidity function updatePool() public {     if (block.timestamp <= lastRewardTimestamp) {         return;     }     uint256 joeSupply = joe.balanceOf(address(this));      // @audit lastRewardTimestamp is not initialized. can send 1 Joe to this contract directly => lots of rJoe minted to this contract     if (joeSupply == 0) {         lastRewardTimestamp = block.timestamp;         return;     }     uint256 multiplier = block.timestamp - lastRewardTimestamp;     uint256 rJoeReward = multiplier * rJoePerSec;     accRJoePerShare =         accRJoePerShare +         (rJoeReward * PRECISION) /         joeSupply;     lastRewardTimestamp = block.timestamp;      rJoe.mint(address(this), rJoeReward); } ```  However, if a user first directly transfers `Joe` tokens to the contract before the first `updatePool` call, the `block.timestamp - lastRewardTimestamp = block.timestamp` will be a large timestamp value and lots of `rJoe` will be minted (but not distributed to users). Even though they are not distributed to the users, inflating the `rJoe` total supply might not be desired.  #### Recommendation Consider tracking the actual total deposits in a storage variable and using this value instead of the current balance for `joeSupply`. This way, transferring tokens to the contract has no influence and depositing through `deposit` first calls `updatePool` and initializes `lastRewardTimestamp`.   
# Handle  cmichel   # Vulnerability details  The `LaunchEvent.rJoePerAvax` variable is an _unscaled_ integer value and used to compute the `rJoeAmount` as:  ```solidity function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {     return _avaxAmount * rJoePerAvax; } ```  This means the required `rJoeAmount` to burn can never be less than the deposited `avaxAmount`. If a launch event desires to use `0.5 rJoe` per AVAX, this is not possible.  #### Recommendation Consider the `rJoePerAvax` value as a value scaled by `1e18` and then divide by this scale in `getRJoeAmount` again.  
# Handle  cmichel   # Vulnerability details  Imagine the following sequence of events:  - `LaunchEvent.createPair()` is called which sets `wavaxReserve = 0`, adds liquidity to the pair and receives `lpSupply` LP tokens. - `LaunchEvent.allowEmergencyWithdraw()` is called which enters emergency / paused mode and disallows normal withdrawals. - Users can only call `LaunchEvent.emergencyWithdraw` which reverts as the WAVAX reserve was already used to provide liquidity and cannot be paid out. Users don't receive their LP tokens either. The users lost their entire deposit in this case.  #### Recommendation Consider paying out LP tokens in `emergencyWithdraw`.   
# Handle  cmichel   # Vulnerability details  The `LaunchEvent.createPair` requires that no previous pool was created for the `WAVAX <> _token` pair.  ```solidity function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {     (address wavaxAddress, address tokenAddress) = (         address(WAVAX),         address(token)     );     // @audit grief: anyone can create pair     require(         factory.getPair(wavaxAddress, tokenAddress) == address(0),         "LaunchEvent: pair already created"     );      // ... } ```  A griefer can create a pool for the `WAVAX <> _token` pair by calling [`JoeFactory.createPair(WAVAX, _token)`](https://snowtrace.io/address/0x9ad6c38be94206ca50bb0d90783181662f0cfa10#contracts) while the launch event phase 1 or 2 is running. No liquidity can then be provided and an emergency state must be triggered for users and the issuer to be able to withdraw again.  #### Recommendation It must be assumed that the pool is already created and even initialized as pool creation and liquidity provisioning is permissionless. Special attention must be paid if the pool is already initialized with liquidity at a different price than the launch event price.  It would be enough to have a standard min. LP return "slippage" check (using parameter values for `amountAMin/amountBMin` instead of the hardcoded ones in `router.addLiquidity`) in `LaunchEvent.createPair()`. The function must then be callable with special privileges only, for example, by the issuer. Alternatively, the slippage check can be hardcoded as a percentage of the raised amounts (`amountADesired = 0.95 * wavaxReserve, amountBDesired = 0.95 * tokenAllocated`).  This will prevent attacks that try to provide LP at a bad pool price as the transaction will revert when receiving less than the slippage parameter. If the pool is already initialized, it should just get arbitraged to the auction token price and liquidity can then be provided at the expected rate again.   
# Handle  cmichel   # Vulnerability details  In `LaunchEvent.createPair`, when the floor price is not reached (`floorPrice > wavaxReserve * 1e18 / tokenAllocated`), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price.  Note that the `floorPrice` is supposed to have a precision of 18:  > /// @param _floorPrice Price of each token in AVAX, scaled to 1e18  The `floorPrice > (wavaxReserve * 1e18) / tokenAllocated` check is correct but the `tokenAllocated` computation involves the `token` decimals:  ```solidity // @audit should be wavaxReserve * 1e18 / floorPrice tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice; ```  This computation does not work for `token`s that don't have 18 decimals.  #### Example Assume I want to sell `1.0 wBTC = 1e8 wBTC` (8 decimals) at `2,000.0 AVAX = 2,000 * 1e18 AVAX`. The `floorPrice` is `2000e18 * 1e18 / 1e8 = 2e31`  Assume the Launch event only raised `1,000.0 AVAX` - half of the floor price for the issued token amount of `1.0 WBTC` (it should therefore allocate only half a WBTC) - and the token amount will be reduced as: `floorPrice = 2e31 > 1000e18 * 1e18 / 1e8 = 1e31 = actualPrice`. Then, `tokenAllocated = 1000e18 * 1e8 / 2e31 = 1e29 / 2e31 = 0` and no tokens would be allocated, instead of `0.5 WBTC = 0.5e8 WBTC`.  The computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice = 1000e18 * 1e18 / 2e31 = 1e39 / 2e31 = 10e38 / 2e31 = 5e7 = 0.5e8`.  #### Recommendation The new `tokenAllocated` computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice;`.   
# Handle  hyh   # Vulnerability details  ## Impact  As different compiler versions have critical behavior specifics if the contract gets accidentally deployed using another compiler version compared to one they tested with, various types of undesired behavior can be introduced.  ## Proof of Concept  All the contracts in scope use unlocked pragma: ```pragma solidity ^0.8.0```, allowing wide enough range of versions.  Examples:  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L4  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeToken.sol#L3   ## Recommended Mitigation Steps  Consider locking compiler version, for example `pragma solidity 0.8.6`.  This can have additional benefits, for example using custom errors to save gas and so forth.  
# Handle  kirk-baird   # Vulnerability details  ## Impact  The function [allowEmergencyWithdraw()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L520) may be called by the `rocketJoeFactory.owner()` at any time. If it is called while the protocol is in Stage 3 and a pair has been created then the LP tokens will be locked and both issues and depositors will be unable to withdraw.  ## Proof of Concept  If `allowEmergencyWithdraw()`  is called `stopped` is set to `true`. As a result functions [withdrawIncentives()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L468) and [withdrawLiquidity()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L438) will revert due to the `isStopped(false)` modifier reverting.  Additionally, [emergencyWithdraw()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L494) will revert since all the `WAVAX` and `token` balances have been transferred to the liquidity pool.  Thus, depositors and issuers will have no methods of removing their LP tokens or incentives.   ## Recommended Mitigation Steps  Consider adding the requirement `require(address(pair) != address(0), "LaunchEvent: pair not created");` to the function `allowEmergencyWithdraw()`.  
# Handle  kirk-baird   # Vulnerability details  ## Impact  The logic in [_atPhase()`](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L590) can be simplified to save gas and code complexity.  The code can be simplified to the follwoing.  ```solidity     function _atPhase(Phase _phase) internal view {             require(currentPhase() == _phase, "LaunchEvent: incorrect phase");     } ```  ## Proof of Concept  n/a  ## Tools Used  n/a  ## Recommended Mitigation Steps  Consider updating the code to that procided above.  
# Handle  wuwe1   # Vulnerability details  ## Impact Causing confuse to user and developer.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L55  `105000 * 1e18 / (1e18 + 5e16)` is equal to `100000`    ## Recommended Mitigation Steps  change to  `105000 - 105000 * 1e18 / (1e18 + 5e16) = 5000`  
# Handle  wuwe1   # Vulnerability details  ## Impact Off-chain tools will not work as expected.  ## Proof of Concept  Missing UserWithdrawn  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L132](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L132)  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L372](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L372)  Missing IssuingTokenDeposited  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L124](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L124)  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L287](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L287)   ## Recommended Mitigation Steps  Add `emit UserWithdrawn(user, amountMinusFee)` after L372  Add `emit IssuingTokenDeposited(_token, balance)` after L287  
# Handle  Dravee   # Vulnerability details  ## Impact A division by 0 could occur  ## Proof of Concept There are no checks that the denominator is `!= 0` here: ``` File: LaunchEvent.sol 392:         uint256 tokenAllocated = tokenReserve; 393:  394:         // Adjust the amount of tokens sent to the pool if floor price not met 395:         if ( 396:             floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated 397:         ) { ```  tokenReserve (`uint256 tokenAllocated = tokenReserve;`) can be equal to 0 according to this comment: https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L106  Therefore this could happen  ## Tools Used VS Code  ## Recommended Mitigation Steps Check for `tokenAllocated != 0` before this division  
# Handle  kirk-baird   # Vulnerability details  ## Impact  Note: this attack requires `rJoe` to relinquish control during `tranfer()` which under the current [RocketJoeToken](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeToken.sol) it does not. Thus this vulnerability is raised as medium rather than high. Although it's not exploitable currently, it is a highly risky code pattern that should be avoided.  This vulnerability would allow the entire rJoe balance to be drained from the contract.  ## Proof of Concept  The function [deposit()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L96) would be vulnerable to reentrancy if rJoe relinquished control flow.  The following lines show the reward calculations in variable `pending`. These calculations use two state variables `user.amount` and `user.rewardDebt`. Each of these are updated after `_safeRJoeTransfer()`.  Thus if an attacker was able to get control flow during the `rJoe::tranfer()` function they would be able to reenter `deposit()` and the value calculated for `pending`would be the same as the previous iteration hence they would again be transferred `pending` rJoe tokens. During the rJoe transfer the would again gain control of the execution and call `deposit()` again. The process could be repeated until the entire rJoe balance of the contract has been transferred to the attacker.  ```solidity         if (user.amount > 0) {             uint256 pending = (user.amount * accRJoePerShare) /                 PRECISION -                 user.rewardDebt;             _safeRJoeTransfer(msg.sender, pending);         }         user.amount = user.amount + _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION; ```   ## Tools Used  n/a  ## Recommended Mitigation Steps  There are two possible mitigations. First is to use the [openzeppelin reentrancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) over the `deposit()` function which will prevent multiple deposits being made simultaneously.  The second mitigation is to follow the [checks-effects-interactions](https://docs.soliditylang.org/en/v0.8.11/security-considerations.html#re-entrancy) pattern. This would involve updating all state variables before making any external calls.  
# Handle  p4st13r4   # Vulnerability details  ## Impact  `pendingRJoe()` reads a user into a storage variable, which is redundant since it’s a `view()` function and the variable is never modified in place. It can be replaced by a `memory` variable for readability  ## Proof of Concept  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L82](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L82)  ## Tools Used  Editor  ## Recommended Mitigation Steps  ```jsx UserInfo memory user = userInfo[_user]; ```  
# Handle  rfa   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeFactory.sol#L53-L59 && operator cost more gas. ## Tools Used  ## Recommended Mitigation Steps use require multiple times instead of && ``` require(_eventImplementation != address(0), "RJFactory: Addresses can't be null address"); require(_rJoe != address(0),  "RJFactory: Addresses can't be null address"); ...  ```  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  LaunchEvent has an explicit `initialized` variable which is in storage. https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L228  To save an SSTORE we could just check that `_auctionStart > 0` as this is a sufficient check for initialisation. If a getter is needed then a function like the below could be added.  ``` function initialized() external view returns bool {   return auctionStart > 0; } ```  ## Recommended Mitigation Steps  As above.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  LaunchEvent pays out fewer incentives than expected.  ## Proof of Concept  When creating a launch event, issuers must provide the total amount of tokens they want to send to the contract and what percentage of these are reserved for incentives.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L84-L86  Note that there's an inconsistency between the documentation and the implementation. Documentation implies that the issuer provides `_tokenAmount` tokens and an additional `_tokenAmount * _tokenIncentivesPercent / 1e18` as an incentive whereas in reality they only provide `_tokenAmount`   This can be seen here:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L133  For us to pay out the correct percentage of `_tokenAmount` as incentives would expect that amount to be `(_tokenAmount * _tokenIncentivesPercent) / 1e18` however as can be seen we pay out `_tokenAmount - (_tokenAmount * 1e18) / (1e18 + _tokenIncentivesPercent)`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L273  This will consistently pay out a smaller percentage of the total amount of tokens than `_tokenIncentivesPercent`.  ## Recommended Mitigation Steps  Switch to having the issuer provide explicit amounts `_tokenIssuanceAmount` and `_tokenIncentivesAmount` to avoid mistakes about how percentages are handled.  Add tests to ensure that the contract is initialised with the correct state.  
# Handle  defsec   # Vulnerability details  ## Impact  In the JoeStaking contract, the amount check should be placed on the contract. IF the amount is more than transfer operations should be completed.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L129  2. _amount is not checked if Its more than zero.  ```     function withdraw(uint256 _amount) external {         UserInfo storage user = userInfo[msg.sender];         require(             user.amount >= _amount,             "RocketJoeStaking: withdraw amount exceeds balance"         );          updatePool();          uint256 pending = (user.amount * accRJoePerShare) /             PRECISION -             user.rewardDebt;          user.amount = user.amount - _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;          _safeRJoeTransfer(msg.sender, pending);         joe.safeTransfer(address(msg.sender), _amount);         emit Withdraw(msg.sender, _amount);     }  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to add the following check.   ```     function withdraw(uint256 _amount) external {         UserInfo storage user = userInfo[msg.sender];         require(             user.amount >= _amount,             "RocketJoeStaking: withdraw amount exceeds balance"         );          updatePool();          uint256 pending = (user.amount * accRJoePerShare) /             PRECISION -             user.rewardDebt;          user.amount = user.amount - _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;   if(pending != 0) {         _safeRJoeTransfer(msg.sender, pending); }  if(_amount != 0){         joe.safeTransfer(address(msg.sender), _amount); }          emit Withdraw(msg.sender, _amount);      }   ```   
# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been observed that the token can be same as WAVAX. The initialize function should not allow if token is equals to wavax. That would affect all asset management.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L219  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L411  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  On the Launchevent, token should not be equal to wavax.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In LauchEvent.sol the withdrawAVAX() function makes an external call to the msg.sender by way of _safeTransferAVAX.  This allows the caller to reenter this and other functions in this and other protocol files.  To prevent reentrancy and cross function reentrancy there should be reentrancy guard modifiers placed on the withdrawAVAX() function and any other function that makes external calls to the caller.   ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L368  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L370  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add reentrancy guard modifier to withdrawAVAX() function.   
# Handle  0x1f8b   # Vulnerability details  ## Impact Owner can Denial of service.  ## Proof of Concept In the contract `RocketJoeStaking` there are two ways to set `rJoePerSec`, one in the `initialize` and the second one in `updateEmissionRate`, in both of them there are no checks of the received value, so it's possible to use a high value and deny the service in line `updatePool:168`.  ## Tools Used Manual review  ## Recommended Mitigation Steps Change the type to uint128 for `rJoePerSec`.  
# Handle  cccz   # Vulnerability details  ## Impact  It is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelin’s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L457  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L463  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L489  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L513  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L537  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Consider using safeTransfer/safeTransferFrom or require() consistently.   
# Handle  pedroais   # Vulnerability details  ## Impact Save gas ## Proof of Concept The cheaper operation should be done first to save gas . auctionStart == 0 is cheaper than block.timestamp < auctionStart  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L291     
# Handle  gzeon   # Vulnerability details  ## Impact If `msg.sender == issuer`, we don't need to call `pairBalance(msg.sender)` https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L447 ```         uint256 balance = pairBalance(msg.sender);         user.hasWithdrawnPair = true;          if (msg.sender == issuer) {             balance = lpSupply / 2;              emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);              if (tokenReserve > 0) {                 uint256 amount = tokenReserve;                 tokenReserve = 0;                 token.transfer(msg.sender, amount);             }         } else {             emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);         } ``` to ```         uint256 balance;         user.hasWithdrawnPair = true;          if (msg.sender == issuer) {             balance = lpSupply / 2;              emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);              if (tokenReserve > 0) {                 uint256 amount = tokenReserve;                 tokenReserve = 0;                 token.transfer(msg.sender, amount);             }         } else {             balance = pairBalance(msg.sender);             emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);         } ```  
# Handle  hyh   # Vulnerability details  ## Impact  Being instantiated with wrong configuration the contract will be inoperable.  If a misconfiguration is noticed too late the various types of malfunctions become possible.  ## Proof of Concept  RocketJoeStaking.initialize doesn't check input parameters, which are immutable due to initializer pattern:  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L72-75   ## Recommended Mitigation Steps  Consider checking joe, rJoe addresses and lastRewardTimestamp to be non-zero and also checking rJoePerSec to be within pre specified bounds  
# Handle  rfa   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L169-L172  ## Tools Used  ## Recommended Mitigation Steps ```             accRJoePerShare  +=             (rJoeReward * PRECISION) /             joeSupply; ```  
# Handle  sirhashalot   # Vulnerability details  ## Impact  Some functions in RocketJoeFactory.sol have zero checks for setting specific state variables, but there zero address checks are not always applied. Setting some of these state variables to the zero address, whether intentional or not, can break the protocol functionality. Adding these checks consistently would prevent this scenario.  ## Proof of Concept  The [constructor in RocketJoeFactory.sol](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L53-L61) performs zero address checks before setting the router, factory, penaltyCollector, and rJoe state variables.  Later in the same contract, the functions `setRJoe()`, `setPenaltyCollector()`, `setRouter()`, and `setFactory()` [omit the same zero address checks](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L159-L188) that were applied earlier. Since the issues that can be caused by setting these state variables to the zero address exist whether setting the value in the constructor or in the setter function, these checks should be applied consistently.  ## Recommended Mitigation Steps  Add zero address checks in the setter functions for these state variables just like is done in the constructor. If it is determined that a zero check for any of these state variables is not needed, then the zero check can be removed from the RocketJoeFactory.sol constructor for consistency.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `withdrawAVAX()` function of LaunchEvent.sol and `initialize()` function of RocketJoeStaking.sol can be declared external for gas savings  ## Proof of Concept  - [withdrawAVAX](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L349) - [initialize](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L57)  ## Recommended Mitigation Steps  Declare functions as external instead of public when possible  
# Handle  Jujic   # Vulnerability details  ## Impact The `rJoePerSec` does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L151 ``` function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {         updatePool();         rJoePerSec = _rJoePerSec;         emit UpdateEmissionRate(msg.sender, _rJoePerSec);     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Consider define  upper and lower bounds on the `_rJoePerSec`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/119e12d715ececc31478e833297f124cc15d27c2/contracts/RocketJoeFactory.sol#L97-L154  ```solidity function createRJLaunchEvent(     address _issuer,     uint256 _phaseOneStartTime,     address _token,     uint256 _tokenAmount,     uint256 _tokenIncentivesPercent,     uint256 _floorPrice,     uint256 _maxWithdrawPenalty,     uint256 _fixedWithdrawPenalty,     uint256 _maxAllocation,     uint256 _userTimelock,     uint256 _issuerTimelock ) external override returns (address) {     require(         getRJLaunchEvent[_token] == address(0),         "RJFactory: token has already been issued"     );     require(_issuer != address(0), "RJFactory: issuer can't be 0 address");     require(_token != address(0), "RJFactory: token can't be 0 address");     require(_token != wavax, "RJFactory: token can't be wavax");     require(         _tokenAmount > 0,         "RJFactory: token amount needs to be greater than 0"     );     require(         IJoeFactory(factory).getPair(_token, wavax) == address(0) ||             IJoePair(IJoeFactory(factory).getPair(_token, wavax))                 .totalSupply() ==             0,         "RJFactory: liquid pair already exists"     );      address launchEvent = Clones.clone(eventImplementation);      // msg.sender needs to approve RocketJoeFactory     IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);      ILaunchEvent(payable(launchEvent)).initialize(         _issuer,         _phaseOneStartTime,         _token,         _tokenIncentivesPercent,         _floorPrice,         _maxWithdrawPenalty,         _fixedWithdrawPenalty,         _maxAllocation,         _userTimelock,         _issuerTimelock     );      getRJLaunchEvent[_token] = launchEvent;     isRJLaunchEvent[launchEvent] = true;     allRJLaunchEvents.push(launchEvent);      _emitLaunchedEvent(_issuer, _token, _phaseOneStartTime);      return launchEvent; } ```  At L132, `_token.transferFrom()` can be used to re-enter the `createRJLaunchEvent()` function, before the storage change at L147-149.  This will allow the attacker to create multiple `launchEvent` contracts and get them listed in `allRJLaunchEvents`.  Even though there is no significant impact as far as we can tell from the smart contract code. We believe this is still unexpected and may cause other parts of the system, say the frontend to malfunction in some cases.  ### Recommendation  Consider moving L132 `_token.transferFrom()` to after L147-149 to prevent re-entrance.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L98-L155  ```solidity     function createRJLaunchEvent(         address _issuer,         uint256 _phaseOneStartTime,         address _token,         uint256 _tokenAmount,         uint256 _tokenIncentivesPercent,         uint256 _floorPrice,         uint256 _maxWithdrawPenalty,         uint256 _fixedWithdrawPenalty,         uint256 _maxAllocation,         uint256 _userTimelock,         uint256 _issuerTimelock     ) external override returns (address) {         require(             getRJLaunchEvent[_token] == address(0),             "RJFactory: token has already been issued"         );         require(_issuer != address(0), "RJFactory: issuer can't be 0 address");         require(_token != address(0), "RJFactory: token can't be 0 address");         require(_token != wavax, "RJFactory: token can't be wavax");         require(             _tokenAmount > 0,             "RJFactory: token amount needs to be greater than 0"         );         require(             IJoeFactory(factory).getPair(_token, wavax) == address(0) ||                 IJoePair(IJoeFactory(factory).getPair(_token, wavax))                     .totalSupply() ==                 0,             "RJFactory: liquid pair already exists"         );         // ...     } ```  `_issuer != address(0)`, `_token != address(0)`, `_tokenAmount > 0` are cheaper than other checks who read storage or do external call.   Therefore, checking `_issuer != address(0)`, `_token != address(0)`, `_tokenAmount > 0` first can save some gas.   ### Recommendation  Change to:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L98-L155  ```solidity     function createRJLaunchEvent(         address _issuer,         uint256 _phaseOneStartTime,         address _token,         uint256 _tokenAmount,         uint256 _tokenIncentivesPercent,         uint256 _floorPrice,         uint256 _maxWithdrawPenalty,         uint256 _fixedWithdrawPenalty,         uint256 _maxAllocation,         uint256 _userTimelock,         uint256 _issuerTimelock     ) external override returns (address) {         require(_issuer != address(0), "RJFactory: issuer can't be 0 address");         require(_token != address(0), "RJFactory: token can't be 0 address");         require(             _tokenAmount != 0,             "RJFactory: token amount needs to be greater than 0"         );         require(             getRJLaunchEvent[_token] == address(0),             "RJFactory: token has already been issued"         );         require(_token != wavax, "RJFactory: token can't be wavax");         require(             IJoeFactory(factory).getPair(_token, wavax) == address(0) ||                 IJoePair(IJoeFactory(factory).getPair(_token, wavax))                     .totalSupply() ==                 0,             "RJFactory: liquid pair already exists"         );         // ...     } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L19-L19  ```solidity contract LaunchEvent is Ownable { ```  The `LaunchEvent.sol` contract never utilized `onlyOwner` / `owner()` or any other features provided by the `Ownable` library.  Therefore, `is Ownable` can be removed.   
# Handle  WatchPug   # Vulnerability details  It is cheaper to use `!= 0` than `> 0` for uint256.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L101-L101  ```solidity if (user.amount > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L119-L119  ```solidity _tokenAmount > 0, ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L338-L338  ```solidity if (rJoeNeeded > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L355-L355  ```solidity require(_amount > 0, "LaunchEvent: invalid withdraw amount"); ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L370-L370  ```solidity if (feeAmount > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L455-L455  ```solidity if (tokenReserve > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L537-L537  ```solidity if (excessToken > 0) { ```  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  `factory.getPair(wavaxAddress, tokenAddress)` and `factory.getPair(tokenAddress, wavaxAddress)` in `LaunchEvent#createPair()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L377-L435  ```solidity function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {     // ...     require(         factory.getPair(wavaxAddress, tokenAddress) == address(0) ||             IJoePair(                 IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)             ).totalSupply() ==             0,         "LaunchEvent: liquid pair already exists"     );     // ...     pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));     // ... } ```  note: `factory.getPair(a, b)` 与  `factory.getPair(b, a)` 相同, see  [code at github](https://github.com/traderjoe-xyz/joe-core/blob/5c2ca96c3835e7f2660f2904a1224bb7c8f3b7a7/contracts/traderjoe/JoeFactory.sol#L41-L42) or [code at avascan](https://avascan.info/blockchain/c/address/0x9Ad6C38BE94206cA50bb0d90783181662f0Cfa10/contract#:~:text=getPair%5Btoken1%5D%5Btoken0%5D%20%3D%20pair%3B%20//%20populate%20mapping%20in%20the%20reverse%20direction)  ```solidity getPair[token0][token1] = pair; getPair[token1][token0] = pair; // populate mapping in the reverse direction ```  `IJoeFactory(factory).getPair(_token, wavax)` in `RocketJoeFactory#createRJLaunchEvent()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L122-L128  ```solidity require(     IJoeFactory(factory).getPair(_token, wavax) == address(0) ||         IJoePair(IJoeFactory(factory).getPair(_token, wavax))             .totalSupply() ==         0,     "RJFactory: liquid pair already exists" ); ```   `token.decimals()` in `LaunchEvent#createPair()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L395-L405  ```solidity if (     floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated ) {     tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;     // ... } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L82-L82  ```solidity IJoeFactory private factory; ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L385-L385  ```solidity IJoeFactory(factory).getPair(wavaxAddress, tokenAddress) ```  `factory` is defined as `IJoeFactory` already, the type casting is redundant.  
# Handle  WatchPug   # Vulnerability details  Non-constant (especially public) variables should not be in `SCREAMING_SNAKE_CASE`, or they may be misunderstood as constants.  Consider changing to `camelCase`.  See: https://docs.soliditylang.org/en/v0.8.11/style-guide.html?highlight=name#local-and-state-variable-names  Instances include:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/interfaces/IRocketJoeFactory.sol#L35-L39  ```solidity function PHASE_ONE_DURATION() external view returns (uint256);  function PHASE_ONE_NO_FEE_DURATION() external view returns (uint256);  function PHASE_TWO_DURATION() external view returns (uint256); ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L29-L31  ```solidity uint256 public override PHASE_ONE_DURATION = 2 days; uint256 public override PHASE_ONE_NO_FEE_DURATION = 1 days; uint256 public override PHASE_TWO_DURATION = 1 days; ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L200-L214  ```solidity function setPhaseDuration(uint256 _phaseNumber, uint256 _duration)     external     override     onlyOwner {     if (_phaseNumber == 1) {         require(             _duration > PHASE_ONE_NO_FEE_DURATION,             "RJFactory: phase one duration lower than no fee duration"         );         PHASE_ONE_DURATION = _duration;     } else if (_phaseNumber == 2) {         PHASE_TWO_DURATION = _duration;     } } ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L218-L228  ```solidity function setPhaseOneNoFeeDuration(uint256 _noFeeDuration)     external     override     onlyOwner {     require(         _noFeeDuration < PHASE_ONE_DURATION,         "RJFactory: no fee duration bigger than phase one duration"     );     PHASE_ONE_NO_FEE_DURATION = _noFeeDuration; } ```  
# Handle  cmichel   # Vulnerability details  `RocketJoeStaking.withdraw`: The `_safeRJoeTransfer(msg.sender, pending)` only needs to be performed if `pending > 0`.  
# Handle  cmichel   # Vulnerability details  `LaunchEvent.getReserves`: The comment says: `@notice Returns the current balance of the pool`. The "of the pool" part can be misleading as the `tokenIncentivesBalance` are never part of the _pool pair_. Consider changing this to "Returns the outstanding balance of the launch event contract".  
# Handle  cmichel   # Vulnerability details  `LaunchEvent.tokenIncentivesPercent`: The math in the comment is wrong: `/// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives`. It should be `105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives`  
# Handle  cmichel   # Vulnerability details  The `RocketJoeStaking.lastRewardTimestamp` is initialized to zero. Usually, this does not matter as `updatePool` is called before the first deposit and when `joeSupply = joe.balanceOf(address(this)) == 0`, it is set to the current time.  ```solidity function updatePool() public {     if (block.timestamp <= lastRewardTimestamp) {         return;     }     uint256 joeSupply = joe.balanceOf(address(this));      // @audit lastRewardTimestamp is not initialized. can send 1 Joe to this contract directly => lots of rJoe minted to this contract     if (joeSupply == 0) {         lastRewardTimestamp = block.timestamp;         return;     }     uint256 multiplier = block.timestamp - lastRewardTimestamp;     uint256 rJoeReward = multiplier * rJoePerSec;     accRJoePerShare =         accRJoePerShare +         (rJoeReward * PRECISION) /         joeSupply;     lastRewardTimestamp = block.timestamp;      rJoe.mint(address(this), rJoeReward); } ```  However, if a user first directly transfers `Joe` tokens to the contract before the first `updatePool` call, the `block.timestamp - lastRewardTimestamp = block.timestamp` will be a large timestamp value and lots of `rJoe` will be minted (but not distributed to users). Even though they are not distributed to the users, inflating the `rJoe` total supply might not be desired.  #### Recommendation Consider tracking the actual total deposits in a storage variable and using this value instead of the current balance for `joeSupply`. This way, transferring tokens to the contract has no influence and depositing through `deposit` first calls `updatePool` and initializes `lastRewardTimestamp`.   
# Handle  cmichel   # Vulnerability details  The `LaunchEvent.rJoePerAvax` variable is an _unscaled_ integer value and used to compute the `rJoeAmount` as:  ```solidity function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {     return _avaxAmount * rJoePerAvax; } ```  This means the required `rJoeAmount` to burn can never be less than the deposited `avaxAmount`. If a launch event desires to use `0.5 rJoe` per AVAX, this is not possible.  #### Recommendation Consider the `rJoePerAvax` value as a value scaled by `1e18` and then divide by this scale in `getRJoeAmount` again.  
# Handle  cmichel   # Vulnerability details  Imagine the following sequence of events:  - `LaunchEvent.createPair()` is called which sets `wavaxReserve = 0`, adds liquidity to the pair and receives `lpSupply` LP tokens. - `LaunchEvent.allowEmergencyWithdraw()` is called which enters emergency / paused mode and disallows normal withdrawals. - Users can only call `LaunchEvent.emergencyWithdraw` which reverts as the WAVAX reserve was already used to provide liquidity and cannot be paid out. Users don't receive their LP tokens either. The users lost their entire deposit in this case.  #### Recommendation Consider paying out LP tokens in `emergencyWithdraw`.   
# Handle  cmichel   # Vulnerability details  The `LaunchEvent.createPair` requires that no previous pool was created for the `WAVAX <> _token` pair.  ```solidity function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {     (address wavaxAddress, address tokenAddress) = (         address(WAVAX),         address(token)     );     // @audit grief: anyone can create pair     require(         factory.getPair(wavaxAddress, tokenAddress) == address(0),         "LaunchEvent: pair already created"     );      // ... } ```  A griefer can create a pool for the `WAVAX <> _token` pair by calling [`JoeFactory.createPair(WAVAX, _token)`](https://snowtrace.io/address/0x9ad6c38be94206ca50bb0d90783181662f0cfa10#contracts) while the launch event phase 1 or 2 is running. No liquidity can then be provided and an emergency state must be triggered for users and the issuer to be able to withdraw again.  #### Recommendation It must be assumed that the pool is already created and even initialized as pool creation and liquidity provisioning is permissionless. Special attention must be paid if the pool is already initialized with liquidity at a different price than the launch event price.  It would be enough to have a standard min. LP return "slippage" check (using parameter values for `amountAMin/amountBMin` instead of the hardcoded ones in `router.addLiquidity`) in `LaunchEvent.createPair()`. The function must then be callable with special privileges only, for example, by the issuer. Alternatively, the slippage check can be hardcoded as a percentage of the raised amounts (`amountADesired = 0.95 * wavaxReserve, amountBDesired = 0.95 * tokenAllocated`).  This will prevent attacks that try to provide LP at a bad pool price as the transaction will revert when receiving less than the slippage parameter. If the pool is already initialized, it should just get arbitraged to the auction token price and liquidity can then be provided at the expected rate again.   
# Handle  cmichel   # Vulnerability details  In `LaunchEvent.createPair`, when the floor price is not reached (`floorPrice > wavaxReserve * 1e18 / tokenAllocated`), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price.  Note that the `floorPrice` is supposed to have a precision of 18:  > /// @param _floorPrice Price of each token in AVAX, scaled to 1e18  The `floorPrice > (wavaxReserve * 1e18) / tokenAllocated` check is correct but the `tokenAllocated` computation involves the `token` decimals:  ```solidity // @audit should be wavaxReserve * 1e18 / floorPrice tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice; ```  This computation does not work for `token`s that don't have 18 decimals.  #### Example Assume I want to sell `1.0 wBTC = 1e8 wBTC` (8 decimals) at `2,000.0 AVAX = 2,000 * 1e18 AVAX`. The `floorPrice` is `2000e18 * 1e18 / 1e8 = 2e31`  Assume the Launch event only raised `1,000.0 AVAX` - half of the floor price for the issued token amount of `1.0 WBTC` (it should therefore allocate only half a WBTC) - and the token amount will be reduced as: `floorPrice = 2e31 > 1000e18 * 1e18 / 1e8 = 1e31 = actualPrice`. Then, `tokenAllocated = 1000e18 * 1e8 / 2e31 = 1e29 / 2e31 = 0` and no tokens would be allocated, instead of `0.5 WBTC = 0.5e8 WBTC`.  The computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice = 1000e18 * 1e18 / 2e31 = 1e39 / 2e31 = 10e38 / 2e31 = 5e7 = 0.5e8`.  #### Recommendation The new `tokenAllocated` computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice;`.   
# Handle  hyh   # Vulnerability details  ## Impact  As different compiler versions have critical behavior specifics if the contract gets accidentally deployed using another compiler version compared to one they tested with, various types of undesired behavior can be introduced.  ## Proof of Concept  All the contracts in scope use unlocked pragma: ```pragma solidity ^0.8.0```, allowing wide enough range of versions.  Examples:  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L4  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeToken.sol#L3   ## Recommended Mitigation Steps  Consider locking compiler version, for example `pragma solidity 0.8.6`.  This can have additional benefits, for example using custom errors to save gas and so forth.  
# Handle  kirk-baird   # Vulnerability details  ## Impact  The function [allowEmergencyWithdraw()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L520) may be called by the `rocketJoeFactory.owner()` at any time. If it is called while the protocol is in Stage 3 and a pair has been created then the LP tokens will be locked and both issues and depositors will be unable to withdraw.  ## Proof of Concept  If `allowEmergencyWithdraw()`  is called `stopped` is set to `true`. As a result functions [withdrawIncentives()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L468) and [withdrawLiquidity()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L438) will revert due to the `isStopped(false)` modifier reverting.  Additionally, [emergencyWithdraw()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L494) will revert since all the `WAVAX` and `token` balances have been transferred to the liquidity pool.  Thus, depositors and issuers will have no methods of removing their LP tokens or incentives.   ## Recommended Mitigation Steps  Consider adding the requirement `require(address(pair) != address(0), "LaunchEvent: pair not created");` to the function `allowEmergencyWithdraw()`.  
# Handle  kirk-baird   # Vulnerability details  ## Impact  The logic in [_atPhase()`](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L590) can be simplified to save gas and code complexity.  The code can be simplified to the follwoing.  ```solidity     function _atPhase(Phase _phase) internal view {             require(currentPhase() == _phase, "LaunchEvent: incorrect phase");     } ```  ## Proof of Concept  n/a  ## Tools Used  n/a  ## Recommended Mitigation Steps  Consider updating the code to that procided above.  
# Handle  wuwe1   # Vulnerability details  ## Impact Causing confuse to user and developer.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L55  `105000 * 1e18 / (1e18 + 5e16)` is equal to `100000`    ## Recommended Mitigation Steps  change to  `105000 - 105000 * 1e18 / (1e18 + 5e16) = 5000`  
# Handle  wuwe1   # Vulnerability details  ## Impact Off-chain tools will not work as expected.  ## Proof of Concept  Missing UserWithdrawn  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L132](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L132)  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L372](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L372)  Missing IssuingTokenDeposited  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L124](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L124)  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L287](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L287)   ## Recommended Mitigation Steps  Add `emit UserWithdrawn(user, amountMinusFee)` after L372  Add `emit IssuingTokenDeposited(_token, balance)` after L287  
# Handle  Dravee   # Vulnerability details  ## Impact A division by 0 could occur  ## Proof of Concept There are no checks that the denominator is `!= 0` here: ``` File: LaunchEvent.sol 392:         uint256 tokenAllocated = tokenReserve; 393:  394:         // Adjust the amount of tokens sent to the pool if floor price not met 395:         if ( 396:             floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated 397:         ) { ```  tokenReserve (`uint256 tokenAllocated = tokenReserve;`) can be equal to 0 according to this comment: https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L106  Therefore this could happen  ## Tools Used VS Code  ## Recommended Mitigation Steps Check for `tokenAllocated != 0` before this division  
# Handle  kirk-baird   # Vulnerability details  ## Impact  Note: this attack requires `rJoe` to relinquish control during `tranfer()` which under the current [RocketJoeToken](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeToken.sol) it does not. Thus this vulnerability is raised as medium rather than high. Although it's not exploitable currently, it is a highly risky code pattern that should be avoided.  This vulnerability would allow the entire rJoe balance to be drained from the contract.  ## Proof of Concept  The function [deposit()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L96) would be vulnerable to reentrancy if rJoe relinquished control flow.  The following lines show the reward calculations in variable `pending`. These calculations use two state variables `user.amount` and `user.rewardDebt`. Each of these are updated after `_safeRJoeTransfer()`.  Thus if an attacker was able to get control flow during the `rJoe::tranfer()` function they would be able to reenter `deposit()` and the value calculated for `pending`would be the same as the previous iteration hence they would again be transferred `pending` rJoe tokens. During the rJoe transfer the would again gain control of the execution and call `deposit()` again. The process could be repeated until the entire rJoe balance of the contract has been transferred to the attacker.  ```solidity         if (user.amount > 0) {             uint256 pending = (user.amount * accRJoePerShare) /                 PRECISION -                 user.rewardDebt;             _safeRJoeTransfer(msg.sender, pending);         }         user.amount = user.amount + _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION; ```   ## Tools Used  n/a  ## Recommended Mitigation Steps  There are two possible mitigations. First is to use the [openzeppelin reentrancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) over the `deposit()` function which will prevent multiple deposits being made simultaneously.  The second mitigation is to follow the [checks-effects-interactions](https://docs.soliditylang.org/en/v0.8.11/security-considerations.html#re-entrancy) pattern. This would involve updating all state variables before making any external calls.  
# Handle  p4st13r4   # Vulnerability details  ## Impact  `pendingRJoe()` reads a user into a storage variable, which is redundant since it’s a `view()` function and the variable is never modified in place. It can be replaced by a `memory` variable for readability  ## Proof of Concept  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L82](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L82)  ## Tools Used  Editor  ## Recommended Mitigation Steps  ```jsx UserInfo memory user = userInfo[_user]; ```  
# Handle  rfa   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeFactory.sol#L53-L59 && operator cost more gas. ## Tools Used  ## Recommended Mitigation Steps use require multiple times instead of && ``` require(_eventImplementation != address(0), "RJFactory: Addresses can't be null address"); require(_rJoe != address(0),  "RJFactory: Addresses can't be null address"); ...  ```  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  LaunchEvent has an explicit `initialized` variable which is in storage. https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L228  To save an SSTORE we could just check that `_auctionStart > 0` as this is a sufficient check for initialisation. If a getter is needed then a function like the below could be added.  ``` function initialized() external view returns bool {   return auctionStart > 0; } ```  ## Recommended Mitigation Steps  As above.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  LaunchEvent pays out fewer incentives than expected.  ## Proof of Concept  When creating a launch event, issuers must provide the total amount of tokens they want to send to the contract and what percentage of these are reserved for incentives.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L84-L86  Note that there's an inconsistency between the documentation and the implementation. Documentation implies that the issuer provides `_tokenAmount` tokens and an additional `_tokenAmount * _tokenIncentivesPercent / 1e18` as an incentive whereas in reality they only provide `_tokenAmount`   This can be seen here:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L133  For us to pay out the correct percentage of `_tokenAmount` as incentives would expect that amount to be `(_tokenAmount * _tokenIncentivesPercent) / 1e18` however as can be seen we pay out `_tokenAmount - (_tokenAmount * 1e18) / (1e18 + _tokenIncentivesPercent)`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L273  This will consistently pay out a smaller percentage of the total amount of tokens than `_tokenIncentivesPercent`.  ## Recommended Mitigation Steps  Switch to having the issuer provide explicit amounts `_tokenIssuanceAmount` and `_tokenIncentivesAmount` to avoid mistakes about how percentages are handled.  Add tests to ensure that the contract is initialised with the correct state.  
# Handle  defsec   # Vulnerability details  ## Impact  In the JoeStaking contract, the amount check should be placed on the contract. IF the amount is more than transfer operations should be completed.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L129  2. _amount is not checked if Its more than zero.  ```     function withdraw(uint256 _amount) external {         UserInfo storage user = userInfo[msg.sender];         require(             user.amount >= _amount,             "RocketJoeStaking: withdraw amount exceeds balance"         );          updatePool();          uint256 pending = (user.amount * accRJoePerShare) /             PRECISION -             user.rewardDebt;          user.amount = user.amount - _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;          _safeRJoeTransfer(msg.sender, pending);         joe.safeTransfer(address(msg.sender), _amount);         emit Withdraw(msg.sender, _amount);     }  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to add the following check.   ```     function withdraw(uint256 _amount) external {         UserInfo storage user = userInfo[msg.sender];         require(             user.amount >= _amount,             "RocketJoeStaking: withdraw amount exceeds balance"         );          updatePool();          uint256 pending = (user.amount * accRJoePerShare) /             PRECISION -             user.rewardDebt;          user.amount = user.amount - _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;   if(pending != 0) {         _safeRJoeTransfer(msg.sender, pending); }  if(_amount != 0){         joe.safeTransfer(address(msg.sender), _amount); }          emit Withdraw(msg.sender, _amount);      }   ```   
# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been observed that the token can be same as WAVAX. The initialize function should not allow if token is equals to wavax. That would affect all asset management.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L219  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L411  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  On the Launchevent, token should not be equal to wavax.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In LauchEvent.sol the withdrawAVAX() function makes an external call to the msg.sender by way of _safeTransferAVAX.  This allows the caller to reenter this and other functions in this and other protocol files.  To prevent reentrancy and cross function reentrancy there should be reentrancy guard modifiers placed on the withdrawAVAX() function and any other function that makes external calls to the caller.   ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L368  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L370  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add reentrancy guard modifier to withdrawAVAX() function.   
# Handle  0x1f8b   # Vulnerability details  ## Impact Owner can Denial of service.  ## Proof of Concept In the contract `RocketJoeStaking` there are two ways to set `rJoePerSec`, one in the `initialize` and the second one in `updateEmissionRate`, in both of them there are no checks of the received value, so it's possible to use a high value and deny the service in line `updatePool:168`.  ## Tools Used Manual review  ## Recommended Mitigation Steps Change the type to uint128 for `rJoePerSec`.  
# Handle  cccz   # Vulnerability details  ## Impact  It is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelin’s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L457  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L463  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L489  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L513  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L537  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Consider using safeTransfer/safeTransferFrom or require() consistently.   
