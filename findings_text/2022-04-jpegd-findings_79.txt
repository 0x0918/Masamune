# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L799   # Vulnerability details  ## Impact The owner of an **insured** position that has been liquidated can claim back their NFT without paying back the debt by calling `closePosition` instead of `repurchase`.  ```solidity function closePosition(uint256 _nftIndex)     external     // @audit NFT is still valid (ownerOf(nft) == this)     validNFTIndex(_nftIndex) {     accrue();     // @audit owner is still original owner (depositor)     require(msg.sender == positionOwner[_nftIndex], "unauthorized");     // @audit debt is zero as it's been repaid by liquidator     require(_getDebtAmount(_nftIndex) == 0, "position_not_repaid");      positionOwner[_nftIndex] = address(0);     delete positions[_nftIndex];     positionIndexes.remove(_nftIndex);      // transfer nft back to owner if nft was deposited     if (nftContract.ownerOf(_nftIndex) == address(this)) {         nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);     }      emit PositionClosed(msg.sender, _nftIndex); } ```  The `liquidate` function sets `position.debtPortion = 0;` and does not clear the `owner` which means all `closePosition` checks pass. This means that PUSD can be minted for free by:  - Attacker deposits NFT collateral in insured state and borrow PUSD against it - Let it be liquidated (the liquidator unexpectedly loses as they cannot get the NFT through `claimExpiredInsuranceNFT` anymore) - Attacker claims it back through `closePosition` - Repeat  ## Recommended Mitigation Steps Consider checking in `closePosition` that the position has not been liquidated.   
