## NestedFactory.sol  ### transferToReserveAndStore: balanceReserveAfter can be inlined  In the `_transferToReserveAndStore` function, we store the reserve balance after the transfer in the `balanceReserveAfter` variable, on line [523](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/NestedFactory.sol#L523).  This variable being only used once, we can inline it and save one mstore.  Recommendation:  ``` nestedRecords.store(_nftId, address(_token), _token.balanceOf(reserveAddr) - balanceReserveBefore, reserveAddr); ```  ## TimelockControllerEmergency.sol  ### scheduleBatch: targets.length should be stored in a variable  In the `scheduleBatch` function on line [221](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/governance/TimelockControllerEmergency.sol#L221), we call `targets.length` to compare the targets length and also to loop through the targets and emit the `CallScheduled` event.  For a better code legibility and also to save some mload, targets length should be stored in a variable.  Recommendation:  ``` uint256 _targetsLength = targets.length;  require(targetsLength == values.length, "TimelockController: length mismatch"); require(targetsLength == datas.length, "TimelockController: length mismatch");  bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt); schedule(id, delay); for (uint256 i = 0; i < targetsLength; ++i) {   emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay); } ```  ### executeBatch: targets.length should be stored in a variable  In the `executeBatch` function on line [312](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/governance/TimelockControllerEmergency.sol#L312), we call `targets.length` to compare the targets length and also to loop through the targets and call the `_call` function.  For a better code legibility and also to save some mload, targets length should be stored in a variable.  Recommendation:  ``` uint256 _targetsLength = targets.length;  require(_targetsLength == values.length, "TimelockController: length mismatch"); require(_targetsLength == datas.length, "TimelockController: length mismatch");  bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt); _beforeCall(id, predecessor); for (uint256 i = 0; i < _targetsLength; ++i) {     _call(id, i, targets[i], values[i], datas[i]); } _afterCall(id); ``` 
