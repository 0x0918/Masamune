# Gas Optimizations ## optimize the for loop in the pay function of the TimeswapPair contracts The for loop in the pay function can be optimized. Let's look at the for loop: ```sol for (uint256 i; i < param.ids.length;) {     Due storage due = dues[param.ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');     due.debt -= param.assetsIn[i];     due.collateral -= param.collateralsOut[i];     assetIn += param.assetsIn[i];     collateralOut += param.collateralsOut[i];     unchecked { ++i; } } ```  It is pretty optimized, but it can be more optimized: 1. The array's length can be saved instead of being accessed in every iteration. 2. `param.assetsIn[i]` and `param.collateralsOut[i]` can be saved in order to save gas. Instead of accessing it multiple times in every iteration, these values can be saved in a local variable.  The code after these changes will look like this: ```sol uint length = param.ids.length; uint112 collateralOut_i; uint112 assetsIn_i;  for (uint256 i; i < length;) {     Due storage due = dues[param.ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');      assetsIn_i = param.assetsIn[i];     collateralOut_i = param.collateralOut[i];      if (param.owner != msg.sender) require(collateralOut_i == 0, 'E213');     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');     due.debt -= assetsIn_i;     due.collateral -= collateralOut_i;     assetIn += assetsIn_i;     collateralOut += collateralOut_i;     unchecked { ++i; } } ```   ## Use local variables (memory) instead of storage variables In order to save gas, local variables can be used instead of storage variables. For example, let's look at the `mint` function of the `TimeswapPair` contract: ```sol     function mint(MintParam calldata param)         external         override         lock         returns (             uint256 assetIn,             uint256 liquidityOut,             uint256 id,             Due memory dueOut         )     {            // ...          Pool storage pool = pools[param.maturity];          uint256 feeStoredIncrease;         (liquidityOut, dueOut, feeStoredIncrease) = TimeswapMath.mint(             param.maturity,             pool.state,             param.xIncrease,             param.yIncrease,             param.zIncrease         );          require(liquidityOut != 0, 'E212');         pool.state.totalLiquidity += liquidityOut;         pool.liquidities[param.liquidityTo] += liquidityOut;          pool.state.feeStored += feeStoredIncrease;           id = pool.dues[param.dueTo].insert(dueOut);          pool.state.reserves.asset += param.xIncrease;         pool.state.reserves.collateral += dueOut.collateral;         pool.state.totalDebtCreated += dueOut.debt;          pool.state.x += param.xIncrease;         pool.state.y += param.yIncrease;         pool.state.z += param.zIncrease;          assetIn = param.xIncrease;         assetIn += feeStoredIncrease;         Callback.mint(asset, collateral, assetIn, dueOut.collateral, param.data);          // ...     } ``` Here, a lot of changes are made to the pool variable. The pool variable is a storage variable (as we can see in here `Pool storage pool = pools[param.maturity]`), and instead of modifying it we can use a local (memory) variable and assign it to the storage memory in the end. That will made all the memory operations cheaper in gas and will cocnsume less gas.  This optimization can be done to the `pool` variable in more function in the `TimeswapPair` contract - the `burn`, `lend`, `withdraw`, `borrow` and `pay` functions.  ## optimize the `returnDataToString` function in the `SafeMetadata` library ```sol function returnDataToString(bytes memory data) private pure returns (string memory) {     if (data.length >= 64) {         return abi.decode(data, (string));     } else if (data.length == 32) {         uint8 i = 0;         while (i < 32 && data[i] != 0) {             i++;         }         bytes memory bytesArray = new bytes(i);         for (i = 0; i < 32 && data[i] != 0; i++) {             bytesArray[i] = data[i];         }         return string(bytesArray);     } else {         return '???';     } } ```  This function can be optimized in several ways: 1. Use ++i instead of i++. 2. Use unchecked on the increment of i. 3. Not initializing i to it's default value - when declaring the i variable, initializing it to zero actually costs more gas than just declaring it (`uint8 i;` is cheaper than `uint8 i = 0;`). 4. Instead of checking 2 conditions in the second loop, we can run using the new array length (the old i value).     The code after the mentioned changes will look like this: ```sol function returnDataToString(bytes memory data) private pure returns (string memory) {     if (data.length >= 64) {         return abi.decode(data, (string));     } else if (data.length == 32) {         uint8 i;         while (i < 32 && data[i] != 0) {             unchecked { ++i; }         }         bytes memory bytesArray = new bytes(i);         uint length = bytesArray.length;         for (i = 0; i < length; ) {             bytesArray[i] = data[i];             unchecked { ++i; }         }         return string(bytesArray);     } else {         return '???';     } } ```  These changes will save a great amount of gas spent on unnecessary stuff.
