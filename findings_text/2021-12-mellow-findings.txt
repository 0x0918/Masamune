# Handle  0x421f   # Vulnerability details  This one  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/YearnVault.sol#L99  Its maybe gap in my knowledge, but I have never seen this pattern  What it does ?  
# Handle  0x421f   # Vulnerability details  If we see vault registry   https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/VaultRegistry.sol#L18  There are two mappings on L18 and L19  On 18 its map(address) => nftID, which is fine  but one on 19. we can remove,  Nft IDs are incremental, and are stored in same position in _vaults[] array so it can be accessed like for id of x => _vaults[x-1]  with this we dont need to maintain it whenever new vault is deployed, again saving gas cost :)  
# Handle  ye0lde   # Vulnerability details  ## Impact  Changing the variables from constant to immutable will reduce keccak operations and save gas.  ## Proof of Concept  The variables that can be changed from `constant` to `immutable` are here: https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/DefaultAccessControl.sol#L11-L12  A previous finding with additional explanation and a pointer to the Ethereum/solidity issue is here: https://github.com/code-423n4/2021-10-slingshot-findings/issues/3  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the constant variables to immutable.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/YearnVault.sol#L84-L101  ```solidity=84     for (uint256 i = 0; i < _yTokens.length; i++) {         if (tokenAmounts[i] == 0) {             continue;         }          IYearnVault yToken = IYearnVault(_yTokens[i]);         uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());         uint256 balance = yToken.balanceOf(address(this));         if (yTokenAmount > balance) {             yTokenAmount = balance;         }         if (yTokenAmount == 0) {             continue;         }         yToken.withdraw(yTokenAmount, to, maxLoss);         (tokenAmounts[i], address(this));     }     actualTokenAmounts = tokenAmounts; ```  The actual token withdrew from `yToken.withdraw()` will most certainly be less than the `tokenAmounts[i]`, due to precision loss in the calculation of `yTokenAmount`.  As a result, `IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);` in `LpIssuer.sol#withdraw()` will revert due to insufficant balance.   ### Recommendation  Change to:  ```solidity=98 tokenAmounts[i] = yToken.withdraw(yTokenAmount, to, maxLoss); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/AaveVault.sol#L80-L94  ```solidity=80 function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         address[] memory tokens = _vaultTokens;         for (uint256 i = 0; i < _aTokens.length; i++) {             if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {                 continue;             }             _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);         }         updateTvls();         actualTokenAmounts = tokenAmounts;     } ```  In Aave LendingPool, the actual amount withdrawn may be different from the requested amount, we suggest using the return amount as `actualTokenAmount`.  https://github.com/aave/protocol-v2/blob/master/contracts/protocol/lendingpool/LendingPool.sol#L155-L157  ```solidity if (amount == type(uint256).max) {     amountToWithdraw = userBalance; } ```  ### Recommendation  Change to:  ```solidity function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         address[] memory tokens = _vaultTokens;         for (uint256 i = 0; i < _aTokens.length; i++) {             if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {                 continue;             }             tokenAmounts[i] = _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);         }         updateTvls();         actualTokenAmounts = tokenAmounts;     } ```  
# Handle  pauliax   # Vulnerability details  ## Impact function adminApprove intends to allow an admin to approve NFTs on behalf of users: ```solidity   function adminApprove(address newAddress, uint256 nft) external {     require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);     IERC721(address(this)).approve(newAddress, nft);   } ```  However, when it calls .approve, it will check the ownership again, so only the calls from admin and owner/approved will pass: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L116-L119  This makes this function ineffective.  ## Recommended Mitigation Steps Based on my understanding, it should call ._approve(...).  
# Handle  WatchPug   # Vulnerability details  When a caller calls `ChiefTrader.sol#swapExactInput()`, it will call `ITrader(traderAddress).swapExactInput()`.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L59-L59  ```solidity=59 return ITrader(traderAddress).swapExactInput(0, amount, recipient, path, options); ```  However, in the current implementation, inputToken is not approved to the `traderAddress`.  For example, in `UniV3Trader.sol#_swapExactInputSingle`, at L89, it tries to transfer inputToken from `msg.sender` (which is `ChiefTrader`), since it's not approved, this will revert.  Plus, the inputToken should also be transferred from the caller before calling the subtrader.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/UniV3Trader.sol#L89-L89  ```solidity=89     IERC20(input).safeTransferFrom(msg.sender, address(this), amount); ```  The same problem exits in `swapExactOutput()`:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L63-L75  ```solidity=63 function swapExactOutput(         uint256 traderId,         uint256 amount,         address,         PathItem[] calldata path,         bytes calldata options     ) external returns (uint256) {         require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);         _requireAllowedTokens(path);         address traderAddress = _traders[traderId];         address recipient = msg.sender;         return ITrader(traderAddress).swapExactOutput(0, amount, recipient, path, options);     } ```  ### Recommendation  Approve the inputToken to the subtrader and transfer from the caller before calling `ITrader.swapExactInput()` and `ITrader.swapExactOutput()`.  Or maybe just remove support of `swapExactInput()` and `swapExactOutput()` in `ChiefTrader`.  
# Handle  cuong_qnom   # Vulnerability details  ### Impact There should be a guard to initialize the factory in the VaultGovernance. Otherwise, some guys (e.g. miners) can front-run the initialization transaction with fake Factory address.  ### Proof of Concept https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/VaultGovernance.sol#L77 ### Tools used Manual Analysis ### Recommendation steps Maybe can put some requirements at the start: _requireProtocolAdmin()   
# Handle  WatchPug   # Vulnerability details  The current design requires the number of `_vaultTokens` to be 2 in `UniV3Vault`, therefore `_vaultTokens.length` can be replaced with literal `2` to save ~800 gas from storage read (`SLOAD` after Berlin).  Instances include:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L101-L101  ```solidity=101 tokenAmounts = new uint256[](_vaultTokens.length); ```  
# Handle  WatchPug   # Vulnerability details  For `UniV3Vault`, it seems that lp fees are collected through `collectEarnings()` callable by the `strategy` and reinvested (rebalanced).  However, in the current implementation, unharvested yields are not included in `tvl()`, making it vulnerable to front-run attacks that steal pending yields.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L100-L122  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L80-L97  ### POC  Given:  - Current `tvl()` is `10 ETH` and `40,000 USDC`; - Current unclaimed yields (trading fees) is `1 ETH` and `4,000 USDC`;  1. `strategy` calls `collectEarnings()` to collect fees and reinvest; 2. The attacker sends a deposit tx with a higher gas price to deposit `10 ETH` and `40,000 USDC`, take 50% share of the pool; 3. After the transaction in step 1 is packed, the attacker calls `withdraw()` and retrieves `10.5 ETH` and `42,000 USDC`.  As a result, the attacker has stolen half of the pending yields in about 1 block of time.  ### Recommendation  Consider including fees in `tvl()`.  For the code to calculate fees earned, please reference `_computeFeesEarned()` in G-UNI project:  https://github.com/gelatodigital/g-uni-v1-core/blob/master/contracts/GUniPool.sol#L762-L806  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L20-L20  ```solidity=20 IVaultGovernance internal _vaultGovernance; ```  ```solidity=35 constructor(     IVaultGovernance vaultGovernance_,     address[] memory vaultTokens_,     string memory name_,     string memory symbol_ ) ERC20(name_, symbol_) {     require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);     _vaultGovernance = vaultGovernance_;     _vaultTokens = vaultTokens_;     // ... } ```  `_vaultGovernance` will never change, use immutable variable instead of storage variable can save gas.   https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/UniV3Trader.sol#L26-L30  ```solidity=26 ISwapRouter public swapRouter;  constructor(address _swapRouter) {     swapRouter = ISwapRouter(_swapRouter); } ```  `swapRouter` will never change, use immutable variable instead of storage variable can save gas.  
# Handle  WatchPug   # Vulnerability details  A certain amount of lp tokens (shares of the vault) will be minted to the `strategyPerformanceTreasury` as `performanceFee`, the amount is calculated based on the `minLpPriceFactor`.  However, the current formula for `toMint` is wrong, which issues more than 100% of the current totalSupply of the lp token to the `strategyPerformanceTreasury` each time. Causing users to lose 50% to 100% of their funds after a few times.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L269-L271  ```solidity=269 address treasury = strategyParams.strategyPerformanceTreasury; uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR; _mint(treasury, toMint); ```  ### PoC  Given:  - `strategyParams.performanceFee`: `10e7` (1%)  1. Alice deposited `1,000 USDC`, received `1000` lpToken; the totalSupply of the lpToken is now: `1000`; 2. 3 days later, `baseTvl` increased to `1,001 USDC`, Bob deposited `1 USDC` and trigegred `_chargeFees()`:  - Expected Result: `strategyPerformanceTreasury` to receive about `0.01` lpToken (1% of 1 USDC); - Actual Result: `minLpPriceFactor` is about `1.001`, and `strategyPerformanceTreasury` will received `1001` lpToken as performanceFee; Alice lose 50% of deposited funds.  ### Recommendation  Change to:  ```solidity address treasury = strategyParams.strategyPerformanceTreasury; uint256 toMint = (baseSupply * (minLpPriceFactor - CommonLibrary.DENOMINATOR) * performanceFee  / CommonLibrary.DENOMINATOR) / CommonLibrary.DENOMINATOR; _mint(treasury, toMint); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L249-L252  ```solidity=249 uint256 performanceFee = strategyParams.performanceFee; uint256[] memory hwms = _lpPriceHighWaterMarks; if (performanceFee > 0) {     uint256 minLpPriceFactor = type(uint256).max;     ... ```  Check `if (performanceFee > 0)` at L251 can be done earlier to avoid unnecessary code execution (read `_lpPriceHighWaterMarks` and copy to memory) at L250 and save some gas when performanceFee == 0.  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/AaveVault.sol#L101-L109  ```solidity=101 function _allowTokenIfNecessary(address token) internal {     if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {         IERC20(token).approve(address(_lendingPool()), type(uint256).max);     } }  function _lendingPool() internal view returns (ILendingPool) {     return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool; } ```  Considering that `_lendingPool()` is a internal call that includes a storage read of `_vaultGovernance` and an external call of `IAaveVaultGovernance.delayedProtocolParams()`. Cache the result of `_lendingPool()` in the stack can save some gas.  ### Recommendation  Change to:  ```solidity function _allowTokenIfNecessary(address token) internal {     address lendingPool = address(_lendingPool());     if (IERC20(token).allowance(address(this), lendingPool) < type(uint256).max / 2) {         IERC20(token).approve(lendingPool, type(uint256).max);     } } ```  
# Handle  WatchPug   # Vulnerability details  Calling `ERC20.transfer()` without handling the returned value is unsafe.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/ERC20Vault.sol#L81-L90  ```solidity=81 function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         for (uint256 i = 0; i < tokenAmounts.length; i++) {             IERC20(_vaultTokens[i]).transfer(to, tokenAmounts[i]);         }         actualTokenAmounts = tokenAmounts;     } ```  ### Recommendation  Consider using OpenZeppelin's `SafeERC20` library with safe versions of transfer functions.  
# Handle  gzeon   # Vulnerability details  ## Impact The comment in https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/YearnVault.sol#L14 > The TVL of the vault is cached and updated after each deposit withdraw.  But it actually does not cache tvl. This behavior is desired or otherwise would have same issue as `AaveVault`.  ## Recommended Mitigation Steps Remove the cache description in comment.   
# Handle  gzeon   # Vulnerability details  ## Impact `AaveVault` cache `tvl` and update it at the end of each `_push` and `_pull`. When withdrawing from `LpIssuer`,  `tokenAmounts` is calculated using the cached `tvl` to be pulled from `AaveVault`. This will lead to user missing out their share of the accrued interest / donations to Aave since the last `updateTvls`.  ## Proof of Concept https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L150 https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/AaveVault.sol#L13  ## Recommended Mitigation Steps Call `updateTvls` at the beginning of `withdraw` function if the `_subvault` will cache tvl  
# Handle  defsec   # Vulnerability details  ## Impact  The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  _msgSender() is utilized three times where msg.sender could have been used in the following function.   """ https://github.com/code-423n4/2021-12-mellow/blob/main/mellow-vaults/contracts/VaultRegistry.sol#L96  https://github.com/code-423n4/2021-12-mellow/blob/main/mellow-vaults/contracts/VaultRegistry.sol#L106  https://github.com/code-423n4/2021-12-mellow/blob/main/mellow-vaults/contracts/VaultRegistry.sol#L88  """   ## Tools Used  None  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  
# Handle  0x0x0x   # Vulnerability details  In `protocolGovernance.sol`, there is parameter `maxTokensPerVault`. This parameter is never utilized, therefore does not provide the functionality stated in comments.  
# Handle  gzeon   # Vulnerability details  ## Impact Reduce 1 storage slot by reordering from https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/interfaces/IProtocolGovernance.sol#L13 ```     struct Params {         bool permissionless;         uint256 maxTokensPerVault;         uint256 governanceDelay;         address protocolTreasury;     } ``` to ```     struct Params {         bool permissionless;         address protocolTreasury;         uint256 maxTokensPerVault;         uint256 governanceDelay;     } ```   
# Handle  cmichel   # Vulnerability details  The `LPIssuer.deposit` first computes _balanced amounts_ on the user's defined `tokenAmounts`. The idea is that LP tokens give the same percentage share of each vault tokens' tvl, therefore the provided amounts should be _balanced_, meaning, the `depositAmount / tvl` ratio should be equal for all vault tokens.  But the strategist can frontrun the user's deposit and rebalance the vault tokens, changing the tvl for each vault token which changes the rebalance. This frontrun can happen accidentally whenever the strategist rebalances  ## POC There's a vault with two tokens A and B, tvls are `[500, 1500]`  - The user provides `[500, 1500]`, expecting to get 50% of the share supply (is minted 100% of old total supply). - The strategist rebalances to `[1000, 1000]` - The user's balanceFactor is `min(500/1000, 1500/1000) = 1/2`, their balancedAmounts are thus `tvl * balanceFactor = [500, 500]`, the `1000` excess token B are refunded. In the end, they only received `500/(1000+500) = 33.3%` of the total supply but used up all of their token A which they might have wanted to hold on to if they had known they'd only get 33.3% of the supply.  ## Impact Users can get rekt when depositing as the received LP amount is unpredictable and lead to a trade using a very different balanced token mix that they never intended.  ## Recommended Mitigation Steps Add minimum return amount checks. Accept a function parameter that can be chosen by the user indicating their _expected LP amount_ for their deposit `tokenAmounts`, then check that the actually minted LP token amount is above this parameter.   
# Handle  cmichel   # Vulnerability details  The `CollectProtocolFees` and `CollectStrategyFees` events in `GatewayVault` are not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  
# Handle  cmichel   # Vulnerability details  The `GatewayVault._push()` function gets `redirects` from the `strategyParams`. If `redirects[i] = j`, vault index `i`'s deposits are redirected to vault index `j`.  Note that the deposits for vault index `i` are cleared, as they are redirected:  ```solidity for (uint256 j = 0; j < _vaultTokens.length; j++) {     uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];     amountsByVault[vaultIndex][j] += amountsByVault[i][j];     amountsByVault[i][j] = 0; } ```  > The same is true for withdrawals in the `_pull` function. Users might not be able to withdraw this way.  If the `redirects` array is misconfigured, it's possible that all `amountsByVault` are set to zero. For example, if `0` redirects to `1` and `1` redirects to `0`. Or `0` redirects to itself, etc. There are many misconfigurations that can lead to not being able to deposit to the pool anymore.   ## Recommended Mitigation Steps The `redirects[i] = j` matrix needs to be restricted. If `i` is redirected to `j`, `j` may not redirect itself. Check for this when setting the `redirects` array.  
# Handle  cmichel   # Vulnerability details  Aave uses **rebasing** tokens which means the token balance `aToken.balanceOf(this)` increases over time with the accrued interest. The `AaveVault.tvl` uses a cached value that needs to be updated using a `updateTvls` call. This call is not done when depositing tokens which allows an attacker to deposit tokens, get a fair share _of the old tvl_, update the tvl to include the interest, and then withdraw the LP tokens receiving a larger share of the _new tvl_, receiving back their initial deposit + the share of the interest. This can be done risk-free in a single transaction.  ## POC - Imagine an Aave Vault with a single vault token, and current TVL = `1,000 aTokens` - Attacker calls `LPIssuer.push([1000])`. This loads the old, cached `tvl`. No `updateTvl` is called. - The `1000` underlying tokens are already balanced as there's only one aToken, then the entire amount is pushed: `aaveVault.transferAndPush([1000])`. This deposists `1000` underlying tokens to the Aave lending pool and returns `actualTokenAmounts = [1000]`. **After that** the internal `_tvls` variable is updated with the latest aTokens. This includes the 1000 aTokens just deposited **but also the new rebased aToken amounts**, the interest the vault received from supplying the tokens since last `updateTvls` call. `_tvls = _tvls + interest + 1000` - The LP amount to mint `amountToMint` is still calculated on the old cached `tvl` memory variable, i.e., attacker receives `amount / oldTvl = 1000/1000 = 100%` of existing LP supply - Attacker withdraws the LP tokens for 50% of the new TVL (it has been updated in `deposit`'s `transferAndPush` call). Attacker receives `50% * _newTvl = 50% * (2,000 + interest) = 1000 + 0.5 * interest`. - Attacker makes a profit of `0.5 * interest`  ## Impact The interest since the last TVL storage update can be stolen as Aave uses rebasing tokens but the tvl is not first recomputed when depositing. If the vaults experience low activity a significant amount of interest can accrue which can all be captured by taking a flashloan and depositing and withdrawing a large amount to capture a large share of this interest  ## Recommended Mitigation Steps Update the tvl when depositing and withdrawing before doing anything else.   
# Handle  0x1f8b   # Vulnerability details  # Vulnerability details  ## Impact Gas optimization.  ## Proof of Concept The method remove of the library AddressSet doesn't fail if the entry was not found (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a05312f1b72acca6904ffe32ef83ccdbad20cb4f/contracts/utils/structs/EnumerableSet.sol#L72), this method return true or false if was removed, so it's not needed to check if _vaultGovernances.contains(addr) in the method removeFromVaultGovernances from ProtocolGovernance contract.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove the contains conditional  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept Inside the contract `ChiefTrader` It's better to store the variable `protocolGovernance` as `IProtocolGovernance` because otherwise you need to cast it everytime.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use `IProtocolGovernance` instead of address for store `protocolGovernance`  
# Handle  0x1f8b   # Vulnerability details  ## Impact Mandatory check that could produce undesired results.  ## Proof of Concept The smart contract ChiefTrader was in charge of the swaps, and the method _requireAllowedTokens is in charge to know that all paths are valid, it's mandatory to check that token0 and token1 are not equal, you can see a previous hack in the following link, where the hacker use the same from and to for change the price of the token https://twitter.com/mudit__gupta/status/1465726874974187524?s=12 .  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require for check that token0 and token1 are different.  
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           AaveVaultGovernance.sol, line 3, import "./interfaces/IProtocolGovernance.sol";         ERC20Vault.sol, line 3, import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";         ERC20VaultGovernance.sol, line 4, import "./interfaces/IProtocolGovernance.sol";         GatewayVaultGovernance.sol, line 3, import "./interfaces/IProtocolGovernance.sol";         ILpIssuer.sol, line 3, import "./IVault.sol";         IProtocolGovernance.sol, line 4, import "./IVaultRegistry.sol";         IVaultFactory.sol, line 3, import "./IVaultGovernance.sol";         IVaultGovernance.sol, line 3, import "@openzeppelin/contracts/token/ERC721/IERC721.sol";         IVaultRegistry.sol, line 5, import "./IVaultFactory.sol";         IVaultRegistry.sol, line 6, import "./IVaultGovernance.sol";         LpIssuer.sol, line 9, import "./interfaces/IProtocolGovernance.sol";         LpIssuer.sol, line 11, import "./DefaultAccessControl.sol";         LpIssuerGovernance.sol, line 4, import "./interfaces/IProtocolGovernance.sol";         AaveVaultGovernanceTest.sol, line 3, import "../interfaces/IAaveVaultGovernance.sol";         ERC20VaultTest.sol, line 4, import "../interfaces/IVaultFactory.sol";         GatewayVaultTest.sol, line 4, import "../interfaces/IVaultFactory.sol";         TestEncoding.sol, line 4, import "../interfaces/IVaultGovernance.sol";         TestEncoding.sol, line 5, import "../interfaces/IVaultRegistry.sol";         TestFunctionEncoding.sol, line 4, import "../interfaces/IVaultGovernance.sol";         TestFunctionEncoding.sol, line 5, import "../interfaces/IVault.sol";         UniV3VaultGovernanceTest.sol, line 3, import "../interfaces/IUniV3VaultGovernance.sol";         UniV3VaultTest.sol, line 4, import "../interfaces/IVaultFactory.sol";         IChiefTrader.sol, line 3, import "../../interfaces/IProtocolGovernance.sol";         UniV3Vault.sol, line 3, import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";         UniV3Vault.sol, line 5, import "@openzeppelin/contracts/security/ReentrancyGuard.sol";         UniV3VaultGovernance.sol, line 3, import "./interfaces/IProtocolGovernance.sol";         VaultGovernance.sol, line 3, import "@openzeppelin/contracts/token/ERC721/IERC721.sol";         VaultRegistry.sol, line 6, import "./interfaces/IVaultFactory.sol";         YearnVault.sol, line 3, import "./interfaces/external/aave/ILendingPool.sol";         YearnVault.sol, line 7, import "./libraries/ExceptionsLibrary.sol";         YearnVaultGovernance.sol, line 3, import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";         YearnVaultGovernance.sol, line 4, import "./interfaces/IProtocolGovernance.sol";         YearnVaultGovernance.sol, line 7, import "./libraries/ExceptionsLibrary.sol";   
# Handle  0x421f   # Vulnerability details  This one  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/YearnVault.sol#L99  Its maybe gap in my knowledge, but I have never seen this pattern  What it does ?  
# Handle  0x421f   # Vulnerability details  If we see vault registry   https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/VaultRegistry.sol#L18  There are two mappings on L18 and L19  On 18 its map(address) => nftID, which is fine  but one on 19. we can remove,  Nft IDs are incremental, and are stored in same position in _vaults[] array so it can be accessed like for id of x => _vaults[x-1]  with this we dont need to maintain it whenever new vault is deployed, again saving gas cost :)  
# Handle  ye0lde   # Vulnerability details  ## Impact  Changing the variables from constant to immutable will reduce keccak operations and save gas.  ## Proof of Concept  The variables that can be changed from `constant` to `immutable` are here: https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/DefaultAccessControl.sol#L11-L12  A previous finding with additional explanation and a pointer to the Ethereum/solidity issue is here: https://github.com/code-423n4/2021-10-slingshot-findings/issues/3  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the constant variables to immutable.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/YearnVault.sol#L84-L101  ```solidity=84     for (uint256 i = 0; i < _yTokens.length; i++) {         if (tokenAmounts[i] == 0) {             continue;         }          IYearnVault yToken = IYearnVault(_yTokens[i]);         uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());         uint256 balance = yToken.balanceOf(address(this));         if (yTokenAmount > balance) {             yTokenAmount = balance;         }         if (yTokenAmount == 0) {             continue;         }         yToken.withdraw(yTokenAmount, to, maxLoss);         (tokenAmounts[i], address(this));     }     actualTokenAmounts = tokenAmounts; ```  The actual token withdrew from `yToken.withdraw()` will most certainly be less than the `tokenAmounts[i]`, due to precision loss in the calculation of `yTokenAmount`.  As a result, `IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);` in `LpIssuer.sol#withdraw()` will revert due to insufficant balance.   ### Recommendation  Change to:  ```solidity=98 tokenAmounts[i] = yToken.withdraw(yTokenAmount, to, maxLoss); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/AaveVault.sol#L80-L94  ```solidity=80 function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         address[] memory tokens = _vaultTokens;         for (uint256 i = 0; i < _aTokens.length; i++) {             if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {                 continue;             }             _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);         }         updateTvls();         actualTokenAmounts = tokenAmounts;     } ```  In Aave LendingPool, the actual amount withdrawn may be different from the requested amount, we suggest using the return amount as `actualTokenAmount`.  https://github.com/aave/protocol-v2/blob/master/contracts/protocol/lendingpool/LendingPool.sol#L155-L157  ```solidity if (amount == type(uint256).max) {     amountToWithdraw = userBalance; } ```  ### Recommendation  Change to:  ```solidity function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         address[] memory tokens = _vaultTokens;         for (uint256 i = 0; i < _aTokens.length; i++) {             if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {                 continue;             }             tokenAmounts[i] = _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);         }         updateTvls();         actualTokenAmounts = tokenAmounts;     } ```  
# Handle  pauliax   # Vulnerability details  ## Impact function adminApprove intends to allow an admin to approve NFTs on behalf of users: ```solidity   function adminApprove(address newAddress, uint256 nft) external {     require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);     IERC721(address(this)).approve(newAddress, nft);   } ```  However, when it calls .approve, it will check the ownership again, so only the calls from admin and owner/approved will pass: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L116-L119  This makes this function ineffective.  ## Recommended Mitigation Steps Based on my understanding, it should call ._approve(...).  
# Handle  WatchPug   # Vulnerability details  When a caller calls `ChiefTrader.sol#swapExactInput()`, it will call `ITrader(traderAddress).swapExactInput()`.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L59-L59  ```solidity=59 return ITrader(traderAddress).swapExactInput(0, amount, recipient, path, options); ```  However, in the current implementation, inputToken is not approved to the `traderAddress`.  For example, in `UniV3Trader.sol#_swapExactInputSingle`, at L89, it tries to transfer inputToken from `msg.sender` (which is `ChiefTrader`), since it's not approved, this will revert.  Plus, the inputToken should also be transferred from the caller before calling the subtrader.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/UniV3Trader.sol#L89-L89  ```solidity=89     IERC20(input).safeTransferFrom(msg.sender, address(this), amount); ```  The same problem exits in `swapExactOutput()`:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L63-L75  ```solidity=63 function swapExactOutput(         uint256 traderId,         uint256 amount,         address,         PathItem[] calldata path,         bytes calldata options     ) external returns (uint256) {         require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);         _requireAllowedTokens(path);         address traderAddress = _traders[traderId];         address recipient = msg.sender;         return ITrader(traderAddress).swapExactOutput(0, amount, recipient, path, options);     } ```  ### Recommendation  Approve the inputToken to the subtrader and transfer from the caller before calling `ITrader.swapExactInput()` and `ITrader.swapExactOutput()`.  Or maybe just remove support of `swapExactInput()` and `swapExactOutput()` in `ChiefTrader`.  
# Handle  cuong_qnom   # Vulnerability details  ### Impact There should be a guard to initialize the factory in the VaultGovernance. Otherwise, some guys (e.g. miners) can front-run the initialization transaction with fake Factory address.  ### Proof of Concept https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/VaultGovernance.sol#L77 ### Tools used Manual Analysis ### Recommendation steps Maybe can put some requirements at the start: _requireProtocolAdmin()   
# Handle  WatchPug   # Vulnerability details  The current design requires the number of `_vaultTokens` to be 2 in `UniV3Vault`, therefore `_vaultTokens.length` can be replaced with literal `2` to save ~800 gas from storage read (`SLOAD` after Berlin).  Instances include:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L101-L101  ```solidity=101 tokenAmounts = new uint256[](_vaultTokens.length); ```  
# Handle  WatchPug   # Vulnerability details  For `UniV3Vault`, it seems that lp fees are collected through `collectEarnings()` callable by the `strategy` and reinvested (rebalanced).  However, in the current implementation, unharvested yields are not included in `tvl()`, making it vulnerable to front-run attacks that steal pending yields.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L100-L122  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L80-L97  ### POC  Given:  - Current `tvl()` is `10 ETH` and `40,000 USDC`; - Current unclaimed yields (trading fees) is `1 ETH` and `4,000 USDC`;  1. `strategy` calls `collectEarnings()` to collect fees and reinvest; 2. The attacker sends a deposit tx with a higher gas price to deposit `10 ETH` and `40,000 USDC`, take 50% share of the pool; 3. After the transaction in step 1 is packed, the attacker calls `withdraw()` and retrieves `10.5 ETH` and `42,000 USDC`.  As a result, the attacker has stolen half of the pending yields in about 1 block of time.  ### Recommendation  Consider including fees in `tvl()`.  For the code to calculate fees earned, please reference `_computeFeesEarned()` in G-UNI project:  https://github.com/gelatodigital/g-uni-v1-core/blob/master/contracts/GUniPool.sol#L762-L806  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L20-L20  ```solidity=20 IVaultGovernance internal _vaultGovernance; ```  ```solidity=35 constructor(     IVaultGovernance vaultGovernance_,     address[] memory vaultTokens_,     string memory name_,     string memory symbol_ ) ERC20(name_, symbol_) {     require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);     _vaultGovernance = vaultGovernance_;     _vaultTokens = vaultTokens_;     // ... } ```  `_vaultGovernance` will never change, use immutable variable instead of storage variable can save gas.   https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/UniV3Trader.sol#L26-L30  ```solidity=26 ISwapRouter public swapRouter;  constructor(address _swapRouter) {     swapRouter = ISwapRouter(_swapRouter); } ```  `swapRouter` will never change, use immutable variable instead of storage variable can save gas.  
# Handle  WatchPug   # Vulnerability details  A certain amount of lp tokens (shares of the vault) will be minted to the `strategyPerformanceTreasury` as `performanceFee`, the amount is calculated based on the `minLpPriceFactor`.  However, the current formula for `toMint` is wrong, which issues more than 100% of the current totalSupply of the lp token to the `strategyPerformanceTreasury` each time. Causing users to lose 50% to 100% of their funds after a few times.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L269-L271  ```solidity=269 address treasury = strategyParams.strategyPerformanceTreasury; uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR; _mint(treasury, toMint); ```  ### PoC  Given:  - `strategyParams.performanceFee`: `10e7` (1%)  1. Alice deposited `1,000 USDC`, received `1000` lpToken; the totalSupply of the lpToken is now: `1000`; 2. 3 days later, `baseTvl` increased to `1,001 USDC`, Bob deposited `1 USDC` and trigegred `_chargeFees()`:  - Expected Result: `strategyPerformanceTreasury` to receive about `0.01` lpToken (1% of 1 USDC); - Actual Result: `minLpPriceFactor` is about `1.001`, and `strategyPerformanceTreasury` will received `1001` lpToken as performanceFee; Alice lose 50% of deposited funds.  ### Recommendation  Change to:  ```solidity address treasury = strategyParams.strategyPerformanceTreasury; uint256 toMint = (baseSupply * (minLpPriceFactor - CommonLibrary.DENOMINATOR) * performanceFee  / CommonLibrary.DENOMINATOR) / CommonLibrary.DENOMINATOR; _mint(treasury, toMint); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L249-L252  ```solidity=249 uint256 performanceFee = strategyParams.performanceFee; uint256[] memory hwms = _lpPriceHighWaterMarks; if (performanceFee > 0) {     uint256 minLpPriceFactor = type(uint256).max;     ... ```  Check `if (performanceFee > 0)` at L251 can be done earlier to avoid unnecessary code execution (read `_lpPriceHighWaterMarks` and copy to memory) at L250 and save some gas when performanceFee == 0.  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/AaveVault.sol#L101-L109  ```solidity=101 function _allowTokenIfNecessary(address token) internal {     if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {         IERC20(token).approve(address(_lendingPool()), type(uint256).max);     } }  function _lendingPool() internal view returns (ILendingPool) {     return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool; } ```  Considering that `_lendingPool()` is a internal call that includes a storage read of `_vaultGovernance` and an external call of `IAaveVaultGovernance.delayedProtocolParams()`. Cache the result of `_lendingPool()` in the stack can save some gas.  ### Recommendation  Change to:  ```solidity function _allowTokenIfNecessary(address token) internal {     address lendingPool = address(_lendingPool());     if (IERC20(token).allowance(address(this), lendingPool) < type(uint256).max / 2) {         IERC20(token).approve(lendingPool, type(uint256).max);     } } ```  
# Handle  WatchPug   # Vulnerability details  Calling `ERC20.transfer()` without handling the returned value is unsafe.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/ERC20Vault.sol#L81-L90  ```solidity=81 function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         for (uint256 i = 0; i < tokenAmounts.length; i++) {             IERC20(_vaultTokens[i]).transfer(to, tokenAmounts[i]);         }         actualTokenAmounts = tokenAmounts;     } ```  ### Recommendation  Consider using OpenZeppelin's `SafeERC20` library with safe versions of transfer functions.  
# Handle  gzeon   # Vulnerability details  ## Impact The comment in https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/YearnVault.sol#L14 > The TVL of the vault is cached and updated after each deposit withdraw.  But it actually does not cache tvl. This behavior is desired or otherwise would have same issue as `AaveVault`.  ## Recommended Mitigation Steps Remove the cache description in comment.   
# Handle  gzeon   # Vulnerability details  ## Impact `AaveVault` cache `tvl` and update it at the end of each `_push` and `_pull`. When withdrawing from `LpIssuer`,  `tokenAmounts` is calculated using the cached `tvl` to be pulled from `AaveVault`. This will lead to user missing out their share of the accrued interest / donations to Aave since the last `updateTvls`.  ## Proof of Concept https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L150 https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/AaveVault.sol#L13  ## Recommended Mitigation Steps Call `updateTvls` at the beginning of `withdraw` function if the `_subvault` will cache tvl  
# Handle  defsec   # Vulnerability details  ## Impact  The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  _msgSender() is utilized three times where msg.sender could have been used in the following function.   """ https://github.com/code-423n4/2021-12-mellow/blob/main/mellow-vaults/contracts/VaultRegistry.sol#L96  https://github.com/code-423n4/2021-12-mellow/blob/main/mellow-vaults/contracts/VaultRegistry.sol#L106  https://github.com/code-423n4/2021-12-mellow/blob/main/mellow-vaults/contracts/VaultRegistry.sol#L88  """   ## Tools Used  None  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  
# Handle  0x0x0x   # Vulnerability details  In `protocolGovernance.sol`, there is parameter `maxTokensPerVault`. This parameter is never utilized, therefore does not provide the functionality stated in comments.  
# Handle  gzeon   # Vulnerability details  ## Impact Reduce 1 storage slot by reordering from https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/interfaces/IProtocolGovernance.sol#L13 ```     struct Params {         bool permissionless;         uint256 maxTokensPerVault;         uint256 governanceDelay;         address protocolTreasury;     } ``` to ```     struct Params {         bool permissionless;         address protocolTreasury;         uint256 maxTokensPerVault;         uint256 governanceDelay;     } ```   
# Handle  cmichel   # Vulnerability details  The `LPIssuer.deposit` first computes _balanced amounts_ on the user's defined `tokenAmounts`. The idea is that LP tokens give the same percentage share of each vault tokens' tvl, therefore the provided amounts should be _balanced_, meaning, the `depositAmount / tvl` ratio should be equal for all vault tokens.  But the strategist can frontrun the user's deposit and rebalance the vault tokens, changing the tvl for each vault token which changes the rebalance. This frontrun can happen accidentally whenever the strategist rebalances  ## POC There's a vault with two tokens A and B, tvls are `[500, 1500]`  - The user provides `[500, 1500]`, expecting to get 50% of the share supply (is minted 100% of old total supply). - The strategist rebalances to `[1000, 1000]` - The user's balanceFactor is `min(500/1000, 1500/1000) = 1/2`, their balancedAmounts are thus `tvl * balanceFactor = [500, 500]`, the `1000` excess token B are refunded. In the end, they only received `500/(1000+500) = 33.3%` of the total supply but used up all of their token A which they might have wanted to hold on to if they had known they'd only get 33.3% of the supply.  ## Impact Users can get rekt when depositing as the received LP amount is unpredictable and lead to a trade using a very different balanced token mix that they never intended.  ## Recommended Mitigation Steps Add minimum return amount checks. Accept a function parameter that can be chosen by the user indicating their _expected LP amount_ for their deposit `tokenAmounts`, then check that the actually minted LP token amount is above this parameter.   
# Handle  cmichel   # Vulnerability details  The `CollectProtocolFees` and `CollectStrategyFees` events in `GatewayVault` are not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  
# Handle  cmichel   # Vulnerability details  The `GatewayVault._push()` function gets `redirects` from the `strategyParams`. If `redirects[i] = j`, vault index `i`'s deposits are redirected to vault index `j`.  Note that the deposits for vault index `i` are cleared, as they are redirected:  ```solidity for (uint256 j = 0; j < _vaultTokens.length; j++) {     uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];     amountsByVault[vaultIndex][j] += amountsByVault[i][j];     amountsByVault[i][j] = 0; } ```  > The same is true for withdrawals in the `_pull` function. Users might not be able to withdraw this way.  If the `redirects` array is misconfigured, it's possible that all `amountsByVault` are set to zero. For example, if `0` redirects to `1` and `1` redirects to `0`. Or `0` redirects to itself, etc. There are many misconfigurations that can lead to not being able to deposit to the pool anymore.   ## Recommended Mitigation Steps The `redirects[i] = j` matrix needs to be restricted. If `i` is redirected to `j`, `j` may not redirect itself. Check for this when setting the `redirects` array.  
# Handle  cmichel   # Vulnerability details  Aave uses **rebasing** tokens which means the token balance `aToken.balanceOf(this)` increases over time with the accrued interest. The `AaveVault.tvl` uses a cached value that needs to be updated using a `updateTvls` call. This call is not done when depositing tokens which allows an attacker to deposit tokens, get a fair share _of the old tvl_, update the tvl to include the interest, and then withdraw the LP tokens receiving a larger share of the _new tvl_, receiving back their initial deposit + the share of the interest. This can be done risk-free in a single transaction.  ## POC - Imagine an Aave Vault with a single vault token, and current TVL = `1,000 aTokens` - Attacker calls `LPIssuer.push([1000])`. This loads the old, cached `tvl`. No `updateTvl` is called. - The `1000` underlying tokens are already balanced as there's only one aToken, then the entire amount is pushed: `aaveVault.transferAndPush([1000])`. This deposists `1000` underlying tokens to the Aave lending pool and returns `actualTokenAmounts = [1000]`. **After that** the internal `_tvls` variable is updated with the latest aTokens. This includes the 1000 aTokens just deposited **but also the new rebased aToken amounts**, the interest the vault received from supplying the tokens since last `updateTvls` call. `_tvls = _tvls + interest + 1000` - The LP amount to mint `amountToMint` is still calculated on the old cached `tvl` memory variable, i.e., attacker receives `amount / oldTvl = 1000/1000 = 100%` of existing LP supply - Attacker withdraws the LP tokens for 50% of the new TVL (it has been updated in `deposit`'s `transferAndPush` call). Attacker receives `50% * _newTvl = 50% * (2,000 + interest) = 1000 + 0.5 * interest`. - Attacker makes a profit of `0.5 * interest`  ## Impact The interest since the last TVL storage update can be stolen as Aave uses rebasing tokens but the tvl is not first recomputed when depositing. If the vaults experience low activity a significant amount of interest can accrue which can all be captured by taking a flashloan and depositing and withdrawing a large amount to capture a large share of this interest  ## Recommended Mitigation Steps Update the tvl when depositing and withdrawing before doing anything else.   
# Handle  0x1f8b   # Vulnerability details  # Vulnerability details  ## Impact Gas optimization.  ## Proof of Concept The method remove of the library AddressSet doesn't fail if the entry was not found (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a05312f1b72acca6904ffe32ef83ccdbad20cb4f/contracts/utils/structs/EnumerableSet.sol#L72), this method return true or false if was removed, so it's not needed to check if _vaultGovernances.contains(addr) in the method removeFromVaultGovernances from ProtocolGovernance contract.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove the contains conditional  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept Inside the contract `ChiefTrader` It's better to store the variable `protocolGovernance` as `IProtocolGovernance` because otherwise you need to cast it everytime.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use `IProtocolGovernance` instead of address for store `protocolGovernance`  
# Handle  0x1f8b   # Vulnerability details  ## Impact Mandatory check that could produce undesired results.  ## Proof of Concept The smart contract ChiefTrader was in charge of the swaps, and the method _requireAllowedTokens is in charge to know that all paths are valid, it's mandatory to check that token0 and token1 are not equal, you can see a previous hack in the following link, where the hacker use the same from and to for change the price of the token https://twitter.com/mudit__gupta/status/1465726874974187524?s=12 .  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require for check that token0 and token1 are different.  
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           AaveVaultGovernance.sol, line 3, import "./interfaces/IProtocolGovernance.sol";         ERC20Vault.sol, line 3, import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";         ERC20VaultGovernance.sol, line 4, import "./interfaces/IProtocolGovernance.sol";         GatewayVaultGovernance.sol, line 3, import "./interfaces/IProtocolGovernance.sol";         ILpIssuer.sol, line 3, import "./IVault.sol";         IProtocolGovernance.sol, line 4, import "./IVaultRegistry.sol";         IVaultFactory.sol, line 3, import "./IVaultGovernance.sol";         IVaultGovernance.sol, line 3, import "@openzeppelin/contracts/token/ERC721/IERC721.sol";         IVaultRegistry.sol, line 5, import "./IVaultFactory.sol";         IVaultRegistry.sol, line 6, import "./IVaultGovernance.sol";         LpIssuer.sol, line 9, import "./interfaces/IProtocolGovernance.sol";         LpIssuer.sol, line 11, import "./DefaultAccessControl.sol";         LpIssuerGovernance.sol, line 4, import "./interfaces/IProtocolGovernance.sol";         AaveVaultGovernanceTest.sol, line 3, import "../interfaces/IAaveVaultGovernance.sol";         ERC20VaultTest.sol, line 4, import "../interfaces/IVaultFactory.sol";         GatewayVaultTest.sol, line 4, import "../interfaces/IVaultFactory.sol";         TestEncoding.sol, line 4, import "../interfaces/IVaultGovernance.sol";         TestEncoding.sol, line 5, import "../interfaces/IVaultRegistry.sol";         TestFunctionEncoding.sol, line 4, import "../interfaces/IVaultGovernance.sol";         TestFunctionEncoding.sol, line 5, import "../interfaces/IVault.sol";         UniV3VaultGovernanceTest.sol, line 3, import "../interfaces/IUniV3VaultGovernance.sol";         UniV3VaultTest.sol, line 4, import "../interfaces/IVaultFactory.sol";         IChiefTrader.sol, line 3, import "../../interfaces/IProtocolGovernance.sol";         UniV3Vault.sol, line 3, import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";         UniV3Vault.sol, line 5, import "@openzeppelin/contracts/security/ReentrancyGuard.sol";         UniV3VaultGovernance.sol, line 3, import "./interfaces/IProtocolGovernance.sol";         VaultGovernance.sol, line 3, import "@openzeppelin/contracts/token/ERC721/IERC721.sol";         VaultRegistry.sol, line 6, import "./interfaces/IVaultFactory.sol";         YearnVault.sol, line 3, import "./interfaces/external/aave/ILendingPool.sol";         YearnVault.sol, line 7, import "./libraries/ExceptionsLibrary.sol";         YearnVaultGovernance.sol, line 3, import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";         YearnVaultGovernance.sol, line 4, import "./interfaces/IProtocolGovernance.sol";         YearnVaultGovernance.sol, line 7, import "./libraries/ExceptionsLibrary.sol";   
# Handle  0x421f   # Vulnerability details  This one  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/YearnVault.sol#L99  Its maybe gap in my knowledge, but I have never seen this pattern  What it does ?  
# Handle  0x421f   # Vulnerability details  If we see vault registry   https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/VaultRegistry.sol#L18  There are two mappings on L18 and L19  On 18 its map(address) => nftID, which is fine  but one on 19. we can remove,  Nft IDs are incremental, and are stored in same position in _vaults[] array so it can be accessed like for id of x => _vaults[x-1]  with this we dont need to maintain it whenever new vault is deployed, again saving gas cost :)  
# Handle  ye0lde   # Vulnerability details  ## Impact  Changing the variables from constant to immutable will reduce keccak operations and save gas.  ## Proof of Concept  The variables that can be changed from `constant` to `immutable` are here: https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/DefaultAccessControl.sol#L11-L12  A previous finding with additional explanation and a pointer to the Ethereum/solidity issue is here: https://github.com/code-423n4/2021-10-slingshot-findings/issues/3  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the constant variables to immutable.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/YearnVault.sol#L84-L101  ```solidity=84     for (uint256 i = 0; i < _yTokens.length; i++) {         if (tokenAmounts[i] == 0) {             continue;         }          IYearnVault yToken = IYearnVault(_yTokens[i]);         uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());         uint256 balance = yToken.balanceOf(address(this));         if (yTokenAmount > balance) {             yTokenAmount = balance;         }         if (yTokenAmount == 0) {             continue;         }         yToken.withdraw(yTokenAmount, to, maxLoss);         (tokenAmounts[i], address(this));     }     actualTokenAmounts = tokenAmounts; ```  The actual token withdrew from `yToken.withdraw()` will most certainly be less than the `tokenAmounts[i]`, due to precision loss in the calculation of `yTokenAmount`.  As a result, `IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);` in `LpIssuer.sol#withdraw()` will revert due to insufficant balance.   ### Recommendation  Change to:  ```solidity=98 tokenAmounts[i] = yToken.withdraw(yTokenAmount, to, maxLoss); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/AaveVault.sol#L80-L94  ```solidity=80 function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         address[] memory tokens = _vaultTokens;         for (uint256 i = 0; i < _aTokens.length; i++) {             if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {                 continue;             }             _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);         }         updateTvls();         actualTokenAmounts = tokenAmounts;     } ```  In Aave LendingPool, the actual amount withdrawn may be different from the requested amount, we suggest using the return amount as `actualTokenAmount`.  https://github.com/aave/protocol-v2/blob/master/contracts/protocol/lendingpool/LendingPool.sol#L155-L157  ```solidity if (amount == type(uint256).max) {     amountToWithdraw = userBalance; } ```  ### Recommendation  Change to:  ```solidity function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         address[] memory tokens = _vaultTokens;         for (uint256 i = 0; i < _aTokens.length; i++) {             if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {                 continue;             }             tokenAmounts[i] = _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);         }         updateTvls();         actualTokenAmounts = tokenAmounts;     } ```  
# Handle  pauliax   # Vulnerability details  ## Impact function adminApprove intends to allow an admin to approve NFTs on behalf of users: ```solidity   function adminApprove(address newAddress, uint256 nft) external {     require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);     IERC721(address(this)).approve(newAddress, nft);   } ```  However, when it calls .approve, it will check the ownership again, so only the calls from admin and owner/approved will pass: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L116-L119  This makes this function ineffective.  ## Recommended Mitigation Steps Based on my understanding, it should call ._approve(...).  
# Handle  WatchPug   # Vulnerability details  When a caller calls `ChiefTrader.sol#swapExactInput()`, it will call `ITrader(traderAddress).swapExactInput()`.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L59-L59  ```solidity=59 return ITrader(traderAddress).swapExactInput(0, amount, recipient, path, options); ```  However, in the current implementation, inputToken is not approved to the `traderAddress`.  For example, in `UniV3Trader.sol#_swapExactInputSingle`, at L89, it tries to transfer inputToken from `msg.sender` (which is `ChiefTrader`), since it's not approved, this will revert.  Plus, the inputToken should also be transferred from the caller before calling the subtrader.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/UniV3Trader.sol#L89-L89  ```solidity=89     IERC20(input).safeTransferFrom(msg.sender, address(this), amount); ```  The same problem exits in `swapExactOutput()`:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L63-L75  ```solidity=63 function swapExactOutput(         uint256 traderId,         uint256 amount,         address,         PathItem[] calldata path,         bytes calldata options     ) external returns (uint256) {         require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);         _requireAllowedTokens(path);         address traderAddress = _traders[traderId];         address recipient = msg.sender;         return ITrader(traderAddress).swapExactOutput(0, amount, recipient, path, options);     } ```  ### Recommendation  Approve the inputToken to the subtrader and transfer from the caller before calling `ITrader.swapExactInput()` and `ITrader.swapExactOutput()`.  Or maybe just remove support of `swapExactInput()` and `swapExactOutput()` in `ChiefTrader`.  
# Handle  cuong_qnom   # Vulnerability details  ### Impact There should be a guard to initialize the factory in the VaultGovernance. Otherwise, some guys (e.g. miners) can front-run the initialization transaction with fake Factory address.  ### Proof of Concept https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/VaultGovernance.sol#L77 ### Tools used Manual Analysis ### Recommendation steps Maybe can put some requirements at the start: _requireProtocolAdmin()   
# Handle  WatchPug   # Vulnerability details  The current design requires the number of `_vaultTokens` to be 2 in `UniV3Vault`, therefore `_vaultTokens.length` can be replaced with literal `2` to save ~800 gas from storage read (`SLOAD` after Berlin).  Instances include:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L101-L101  ```solidity=101 tokenAmounts = new uint256[](_vaultTokens.length); ```  
# Handle  WatchPug   # Vulnerability details  For `UniV3Vault`, it seems that lp fees are collected through `collectEarnings()` callable by the `strategy` and reinvested (rebalanced).  However, in the current implementation, unharvested yields are not included in `tvl()`, making it vulnerable to front-run attacks that steal pending yields.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L100-L122  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L80-L97  ### POC  Given:  - Current `tvl()` is `10 ETH` and `40,000 USDC`; - Current unclaimed yields (trading fees) is `1 ETH` and `4,000 USDC`;  1. `strategy` calls `collectEarnings()` to collect fees and reinvest; 2. The attacker sends a deposit tx with a higher gas price to deposit `10 ETH` and `40,000 USDC`, take 50% share of the pool; 3. After the transaction in step 1 is packed, the attacker calls `withdraw()` and retrieves `10.5 ETH` and `42,000 USDC`.  As a result, the attacker has stolen half of the pending yields in about 1 block of time.  ### Recommendation  Consider including fees in `tvl()`.  For the code to calculate fees earned, please reference `_computeFeesEarned()` in G-UNI project:  https://github.com/gelatodigital/g-uni-v1-core/blob/master/contracts/GUniPool.sol#L762-L806  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L20-L20  ```solidity=20 IVaultGovernance internal _vaultGovernance; ```  ```solidity=35 constructor(     IVaultGovernance vaultGovernance_,     address[] memory vaultTokens_,     string memory name_,     string memory symbol_ ) ERC20(name_, symbol_) {     require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);     _vaultGovernance = vaultGovernance_;     _vaultTokens = vaultTokens_;     // ... } ```  `_vaultGovernance` will never change, use immutable variable instead of storage variable can save gas.   https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/UniV3Trader.sol#L26-L30  ```solidity=26 ISwapRouter public swapRouter;  constructor(address _swapRouter) {     swapRouter = ISwapRouter(_swapRouter); } ```  `swapRouter` will never change, use immutable variable instead of storage variable can save gas.  
# Handle  WatchPug   # Vulnerability details  A certain amount of lp tokens (shares of the vault) will be minted to the `strategyPerformanceTreasury` as `performanceFee`, the amount is calculated based on the `minLpPriceFactor`.  However, the current formula for `toMint` is wrong, which issues more than 100% of the current totalSupply of the lp token to the `strategyPerformanceTreasury` each time. Causing users to lose 50% to 100% of their funds after a few times.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L269-L271  ```solidity=269 address treasury = strategyParams.strategyPerformanceTreasury; uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR; _mint(treasury, toMint); ```  ### PoC  Given:  - `strategyParams.performanceFee`: `10e7` (1%)  1. Alice deposited `1,000 USDC`, received `1000` lpToken; the totalSupply of the lpToken is now: `1000`; 2. 3 days later, `baseTvl` increased to `1,001 USDC`, Bob deposited `1 USDC` and trigegred `_chargeFees()`:  - Expected Result: `strategyPerformanceTreasury` to receive about `0.01` lpToken (1% of 1 USDC); - Actual Result: `minLpPriceFactor` is about `1.001`, and `strategyPerformanceTreasury` will received `1001` lpToken as performanceFee; Alice lose 50% of deposited funds.  ### Recommendation  Change to:  ```solidity address treasury = strategyParams.strategyPerformanceTreasury; uint256 toMint = (baseSupply * (minLpPriceFactor - CommonLibrary.DENOMINATOR) * performanceFee  / CommonLibrary.DENOMINATOR) / CommonLibrary.DENOMINATOR; _mint(treasury, toMint); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L249-L252  ```solidity=249 uint256 performanceFee = strategyParams.performanceFee; uint256[] memory hwms = _lpPriceHighWaterMarks; if (performanceFee > 0) {     uint256 minLpPriceFactor = type(uint256).max;     ... ```  Check `if (performanceFee > 0)` at L251 can be done earlier to avoid unnecessary code execution (read `_lpPriceHighWaterMarks` and copy to memory) at L250 and save some gas when performanceFee == 0.  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/AaveVault.sol#L101-L109  ```solidity=101 function _allowTokenIfNecessary(address token) internal {     if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {         IERC20(token).approve(address(_lendingPool()), type(uint256).max);     } }  function _lendingPool() internal view returns (ILendingPool) {     return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool; } ```  Considering that `_lendingPool()` is a internal call that includes a storage read of `_vaultGovernance` and an external call of `IAaveVaultGovernance.delayedProtocolParams()`. Cache the result of `_lendingPool()` in the stack can save some gas.  ### Recommendation  Change to:  ```solidity function _allowTokenIfNecessary(address token) internal {     address lendingPool = address(_lendingPool());     if (IERC20(token).allowance(address(this), lendingPool) < type(uint256).max / 2) {         IERC20(token).approve(lendingPool, type(uint256).max);     } } ```  
# Handle  WatchPug   # Vulnerability details  Calling `ERC20.transfer()` without handling the returned value is unsafe.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/ERC20Vault.sol#L81-L90  ```solidity=81 function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         for (uint256 i = 0; i < tokenAmounts.length; i++) {             IERC20(_vaultTokens[i]).transfer(to, tokenAmounts[i]);         }         actualTokenAmounts = tokenAmounts;     } ```  ### Recommendation  Consider using OpenZeppelin's `SafeERC20` library with safe versions of transfer functions.  
# Handle  gzeon   # Vulnerability details  ## Impact The comment in https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/YearnVault.sol#L14 > The TVL of the vault is cached and updated after each deposit withdraw.  But it actually does not cache tvl. This behavior is desired or otherwise would have same issue as `AaveVault`.  ## Recommended Mitigation Steps Remove the cache description in comment.   
# Handle  gzeon   # Vulnerability details  ## Impact `AaveVault` cache `tvl` and update it at the end of each `_push` and `_pull`. When withdrawing from `LpIssuer`,  `tokenAmounts` is calculated using the cached `tvl` to be pulled from `AaveVault`. This will lead to user missing out their share of the accrued interest / donations to Aave since the last `updateTvls`.  ## Proof of Concept https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L150 https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/AaveVault.sol#L13  ## Recommended Mitigation Steps Call `updateTvls` at the beginning of `withdraw` function if the `_subvault` will cache tvl  
# Handle  defsec   # Vulnerability details  ## Impact  The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  _msgSender() is utilized three times where msg.sender could have been used in the following function.   """ https://github.com/code-423n4/2021-12-mellow/blob/main/mellow-vaults/contracts/VaultRegistry.sol#L96  https://github.com/code-423n4/2021-12-mellow/blob/main/mellow-vaults/contracts/VaultRegistry.sol#L106  https://github.com/code-423n4/2021-12-mellow/blob/main/mellow-vaults/contracts/VaultRegistry.sol#L88  """   ## Tools Used  None  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  
# Handle  0x0x0x   # Vulnerability details  In `protocolGovernance.sol`, there is parameter `maxTokensPerVault`. This parameter is never utilized, therefore does not provide the functionality stated in comments.  
# Handle  gzeon   # Vulnerability details  ## Impact Reduce 1 storage slot by reordering from https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/interfaces/IProtocolGovernance.sol#L13 ```     struct Params {         bool permissionless;         uint256 maxTokensPerVault;         uint256 governanceDelay;         address protocolTreasury;     } ``` to ```     struct Params {         bool permissionless;         address protocolTreasury;         uint256 maxTokensPerVault;         uint256 governanceDelay;     } ```   
# Handle  cmichel   # Vulnerability details  The `LPIssuer.deposit` first computes _balanced amounts_ on the user's defined `tokenAmounts`. The idea is that LP tokens give the same percentage share of each vault tokens' tvl, therefore the provided amounts should be _balanced_, meaning, the `depositAmount / tvl` ratio should be equal for all vault tokens.  But the strategist can frontrun the user's deposit and rebalance the vault tokens, changing the tvl for each vault token which changes the rebalance. This frontrun can happen accidentally whenever the strategist rebalances  ## POC There's a vault with two tokens A and B, tvls are `[500, 1500]`  - The user provides `[500, 1500]`, expecting to get 50% of the share supply (is minted 100% of old total supply). - The strategist rebalances to `[1000, 1000]` - The user's balanceFactor is `min(500/1000, 1500/1000) = 1/2`, their balancedAmounts are thus `tvl * balanceFactor = [500, 500]`, the `1000` excess token B are refunded. In the end, they only received `500/(1000+500) = 33.3%` of the total supply but used up all of their token A which they might have wanted to hold on to if they had known they'd only get 33.3% of the supply.  ## Impact Users can get rekt when depositing as the received LP amount is unpredictable and lead to a trade using a very different balanced token mix that they never intended.  ## Recommended Mitigation Steps Add minimum return amount checks. Accept a function parameter that can be chosen by the user indicating their _expected LP amount_ for their deposit `tokenAmounts`, then check that the actually minted LP token amount is above this parameter.   
# Handle  cmichel   # Vulnerability details  The `CollectProtocolFees` and `CollectStrategyFees` events in `GatewayVault` are not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  
# Handle  cmichel   # Vulnerability details  The `GatewayVault._push()` function gets `redirects` from the `strategyParams`. If `redirects[i] = j`, vault index `i`'s deposits are redirected to vault index `j`.  Note that the deposits for vault index `i` are cleared, as they are redirected:  ```solidity for (uint256 j = 0; j < _vaultTokens.length; j++) {     uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];     amountsByVault[vaultIndex][j] += amountsByVault[i][j];     amountsByVault[i][j] = 0; } ```  > The same is true for withdrawals in the `_pull` function. Users might not be able to withdraw this way.  If the `redirects` array is misconfigured, it's possible that all `amountsByVault` are set to zero. For example, if `0` redirects to `1` and `1` redirects to `0`. Or `0` redirects to itself, etc. There are many misconfigurations that can lead to not being able to deposit to the pool anymore.   ## Recommended Mitigation Steps The `redirects[i] = j` matrix needs to be restricted. If `i` is redirected to `j`, `j` may not redirect itself. Check for this when setting the `redirects` array.  
# Handle  cmichel   # Vulnerability details  Aave uses **rebasing** tokens which means the token balance `aToken.balanceOf(this)` increases over time with the accrued interest. The `AaveVault.tvl` uses a cached value that needs to be updated using a `updateTvls` call. This call is not done when depositing tokens which allows an attacker to deposit tokens, get a fair share _of the old tvl_, update the tvl to include the interest, and then withdraw the LP tokens receiving a larger share of the _new tvl_, receiving back their initial deposit + the share of the interest. This can be done risk-free in a single transaction.  ## POC - Imagine an Aave Vault with a single vault token, and current TVL = `1,000 aTokens` - Attacker calls `LPIssuer.push([1000])`. This loads the old, cached `tvl`. No `updateTvl` is called. - The `1000` underlying tokens are already balanced as there's only one aToken, then the entire amount is pushed: `aaveVault.transferAndPush([1000])`. This deposists `1000` underlying tokens to the Aave lending pool and returns `actualTokenAmounts = [1000]`. **After that** the internal `_tvls` variable is updated with the latest aTokens. This includes the 1000 aTokens just deposited **but also the new rebased aToken amounts**, the interest the vault received from supplying the tokens since last `updateTvls` call. `_tvls = _tvls + interest + 1000` - The LP amount to mint `amountToMint` is still calculated on the old cached `tvl` memory variable, i.e., attacker receives `amount / oldTvl = 1000/1000 = 100%` of existing LP supply - Attacker withdraws the LP tokens for 50% of the new TVL (it has been updated in `deposit`'s `transferAndPush` call). Attacker receives `50% * _newTvl = 50% * (2,000 + interest) = 1000 + 0.5 * interest`. - Attacker makes a profit of `0.5 * interest`  ## Impact The interest since the last TVL storage update can be stolen as Aave uses rebasing tokens but the tvl is not first recomputed when depositing. If the vaults experience low activity a significant amount of interest can accrue which can all be captured by taking a flashloan and depositing and withdrawing a large amount to capture a large share of this interest  ## Recommended Mitigation Steps Update the tvl when depositing and withdrawing before doing anything else.   
# Handle  0x1f8b   # Vulnerability details  # Vulnerability details  ## Impact Gas optimization.  ## Proof of Concept The method remove of the library AddressSet doesn't fail if the entry was not found (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a05312f1b72acca6904ffe32ef83ccdbad20cb4f/contracts/utils/structs/EnumerableSet.sol#L72), this method return true or false if was removed, so it's not needed to check if _vaultGovernances.contains(addr) in the method removeFromVaultGovernances from ProtocolGovernance contract.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove the contains conditional  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept Inside the contract `ChiefTrader` It's better to store the variable `protocolGovernance` as `IProtocolGovernance` because otherwise you need to cast it everytime.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use `IProtocolGovernance` instead of address for store `protocolGovernance`  
# Handle  0x1f8b   # Vulnerability details  ## Impact Mandatory check that could produce undesired results.  ## Proof of Concept The smart contract ChiefTrader was in charge of the swaps, and the method _requireAllowedTokens is in charge to know that all paths are valid, it's mandatory to check that token0 and token1 are not equal, you can see a previous hack in the following link, where the hacker use the same from and to for change the price of the token https://twitter.com/mudit__gupta/status/1465726874974187524?s=12 .  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require for check that token0 and token1 are different.  
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           AaveVaultGovernance.sol, line 3, import "./interfaces/IProtocolGovernance.sol";         ERC20Vault.sol, line 3, import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";         ERC20VaultGovernance.sol, line 4, import "./interfaces/IProtocolGovernance.sol";         GatewayVaultGovernance.sol, line 3, import "./interfaces/IProtocolGovernance.sol";         ILpIssuer.sol, line 3, import "./IVault.sol";         IProtocolGovernance.sol, line 4, import "./IVaultRegistry.sol";         IVaultFactory.sol, line 3, import "./IVaultGovernance.sol";         IVaultGovernance.sol, line 3, import "@openzeppelin/contracts/token/ERC721/IERC721.sol";         IVaultRegistry.sol, line 5, import "./IVaultFactory.sol";         IVaultRegistry.sol, line 6, import "./IVaultGovernance.sol";         LpIssuer.sol, line 9, import "./interfaces/IProtocolGovernance.sol";         LpIssuer.sol, line 11, import "./DefaultAccessControl.sol";         LpIssuerGovernance.sol, line 4, import "./interfaces/IProtocolGovernance.sol";         AaveVaultGovernanceTest.sol, line 3, import "../interfaces/IAaveVaultGovernance.sol";         ERC20VaultTest.sol, line 4, import "../interfaces/IVaultFactory.sol";         GatewayVaultTest.sol, line 4, import "../interfaces/IVaultFactory.sol";         TestEncoding.sol, line 4, import "../interfaces/IVaultGovernance.sol";         TestEncoding.sol, line 5, import "../interfaces/IVaultRegistry.sol";         TestFunctionEncoding.sol, line 4, import "../interfaces/IVaultGovernance.sol";         TestFunctionEncoding.sol, line 5, import "../interfaces/IVault.sol";         UniV3VaultGovernanceTest.sol, line 3, import "../interfaces/IUniV3VaultGovernance.sol";         UniV3VaultTest.sol, line 4, import "../interfaces/IVaultFactory.sol";         IChiefTrader.sol, line 3, import "../../interfaces/IProtocolGovernance.sol";         UniV3Vault.sol, line 3, import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";         UniV3Vault.sol, line 5, import "@openzeppelin/contracts/security/ReentrancyGuard.sol";         UniV3VaultGovernance.sol, line 3, import "./interfaces/IProtocolGovernance.sol";         VaultGovernance.sol, line 3, import "@openzeppelin/contracts/token/ERC721/IERC721.sol";         VaultRegistry.sol, line 6, import "./interfaces/IVaultFactory.sol";         YearnVault.sol, line 3, import "./interfaces/external/aave/ILendingPool.sol";         YearnVault.sol, line 7, import "./libraries/ExceptionsLibrary.sol";         YearnVaultGovernance.sol, line 3, import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";         YearnVaultGovernance.sol, line 4, import "./interfaces/IProtocolGovernance.sol";         YearnVaultGovernance.sol, line 7, import "./libraries/ExceptionsLibrary.sol";   
