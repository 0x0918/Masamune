## Wrong Comment in `SetLimit` Function  There is a wrong comment in `SetLimit` function. The comment doesn't explain the parameters used in the function. this can confuse the reader when reading the code. The comment is located below: https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L118-L122
# Lines of code  https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L232   # Vulnerability details  ## Impact It was observed that the debt and collateral which moves for Auction is calculated incorrectly. In case where line.proportion is set to small value, chances are art will become lower than min debt. This causes whole collateral to go for auction, which was not expected  ___  ## Proof of Concept 1. Assume line.proportion is set to 10% which is a [valid value](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L108)  2. Auction is started on Vault associated with collateral & base representing line from Step 1  3. Now debt and collateral to be sold are calculated in [_calcAuction](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L223)  ``` uint128 art = uint256(balances.art).wmul(line.proportion).u128();         if (art < debt.min * (10**debt.dec)) art = balances.art;         uint128 ink = (art == balances.art)             ? balances.ink             : uint256(balances.ink).wmul(line.proportion).u128(); ```  4. Now lets say **debt (art)** on this vault was **amount 10**, **collateral (ink)** was **amount 9**, debt.min * (10**debt.dec) was **amount 2**  5. Below calculation occurs  ``` uint128 art = uint256(balances.art).wmul(line.proportion).u128(); // which makes art = 10*10% =1         if (art < debt.min * (10**debt.dec)) art = balances.art;   // since 1<2 so art=10         uint128 ink = (art == balances.art)                                 // Since art is 10 so ink=9             ? balances.ink             : uint256(balances.ink).wmul(line.proportion).u128(); ```  6. So full collateral and full debt are placed for Auction even though only 10% was meant for Auction. Even if it was lower than min debt, auction amount should have only increased upto the point where minimum debt limit is reached  ___  ## Recommended Mitigation Steps Revise the calculation like below  ``` uint128 art = uint256(balances.art).wmul(line.proportion).u128(); uint128 ink=0;         if (art < debt.min * (10**debt.dec))  { art = debt.min * (10**debt.dec); (balances.ink<art) ? (ink=balances.ink) : (ink=art) } else { ink=uint256(balances.ink).wmul(line.proportion).u128(); } ```  
# no return natspec for these functions https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L177 # typos instead of : overriden use : overridden https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L213 https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L268 instead of : specialised use : specialized https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L213 https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L268 instead of : differente use   different https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L387 instead of : quoutes use : quotes https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L522  ## no adress zero check https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L247 https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L390 ##  its best practice to remove todos from the code  https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L577 ## its best practice to remove commented code out from the contract https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L570 ## make sure external functions are comments as a part of the contract becuase there are external functions at the end of the contract after even internal functions. so as best practice make external and importent functions at the begaining of the contract then put the internal functions just to make it easier to read. https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L287 https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L253 these 2 functions are external and very importent but are in  between internal functions and the other external functions arenet which makes these functions hard to read or devs/auditors will miss these functions and think they are view or internal and not test them. ## its best practice to emit the old variable and the new variable for an importent admin function https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L84 ## make an absolute value with point function becuase if the admin is comprimsed then the attacker can set ladle to any value so instead make a require statement like ``` require(ladle<100); ``` https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L86
# Lines of code  https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L176 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L399   # Vulnerability details  ## Impact might lead to systematic debt. Cause errors for liquidators to run normally.  ## Proof of Concept In the function `auction`, there is on input validation around whether the `to` is `address(0)` or not. and if the `auctioneerReward` is set to an value > 0 (as default),  each liquidate call will call `Join` module to pay out to `auctioneer` with the following line:  ```jsx if (auctioneerCut > 0) {     ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128()); } ```  This line will revert if `auctioneer` is set to `address(0)` on some tokens (revert on transferring to address(0) is a [default behaviour of the OpenZeppelin template](https://www.notion.so/Yield-Witch-555e6981c26b41008d03a504077b4770)). So if someone start an `auction` with `to = address(0)`, this auction becomes un-liquidatable.  A malicious user can run a bot to monitor his own vault, and if the got underwater and they don’t have enough collateral to top up, they can immediately start an auction on their own vault and set actioneer to `0` to avoid actually being liquidated, which breaks the design of the system.   ## Recommended Mitigation Steps  Add check while starting an auction:  ```jsx function auction(bytes12 vaultId, address to)     external     returns (DataTypes.Auction memory auction_) {     require (to != address(0), "invalid auctioneer");   ... }   ```  
## Summary Alberto asked [on Twitter](https://twitter.com/alcueca/status/1547548084594515970) whether the Yield team succeeded in making their contracts as easily auditable as possible. I think so. I appreciated the sequence diagrams and design decisions in the audit README, the general protocol docs, and the narrow focus in this audit on a single contract.  Here are a few more recommendations: - I find Maker terminology like `ilk`, `ink`, and `art` very useful in the domain of lending protocols, but it can be confusing to the uninitiated. It would be helpful to provide a glossary of these key terms in your project docs. Additionally, it would be helpful to note anywhere that Yield's definition of some concept diverges from Maker's. For example, a Yield `ilk` is a `bytes6` ID, while a Maker `ilk` is a `bytes32`. - Since this audit was limited in scope, it included a fairly narrow set of tests in `Witch.t.sol`, with external dependencies mocked or stubbed. However, at least one of my findings was related to interactions with other protocol contracts. I wrote a stubbed out test for this finding using the existing test harness, but if it was easy to write an integration/simulation test as a PoC, I would have. The hardest part of writing a test like this for an unfamiliar protocol is orchestrating all the dependencies. Consider providing a test harness that sets up all the core contracts as a tool for auditors. - Highlighting key changes between Witch V1 and Witch V2 with references to the code might have been useful, especially to motivate why you chose to make certain changes in the new design.  All in all though, your documentation is great. Thank you for investing the time and effort required to make auditing as easy as possible.  ## Low  ### Auctioneer reward can be sent to protocol contracts  I don't see a clear exploit path here, but it's possible for the caller of `auction` to send their auctioneer reward to Yield protocol contracts, for example the `Witch` itself, or the `Join` contract corresponding to the liquidated asset. The `Join` contracts appear to handle unexpected assets correctly, but consider whether there may be places in the protocol where this sort of transfer could interfere with internal accounting.  ## QA  ### Emit all auction parameters in an event  The `Auction` data type created and stored in `Witch#_calcAuction` includes the initial parameters for a given auction, and writes these values to a storage mapping:  [`Witch#_calcAuction`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L239-L248)  ```solidity             DataTypes.Auction({                 owner: vault.owner,                 start: uint32(block.timestamp), // Overflow is fine                 seriesId: vault.seriesId,                 baseId: series.baseId,                 ilkId: vault.ilkId,                 art: art,                 ink: ink,                 auctioneer: to             }); ```  However, the `Auctioned` event emitted from `Witch#_auctionStarted` includes only the vault ID and timestamp:  [`Witch#_auctionStarted`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L212-L218)  ```solidity     /// @dev Moves the vault ownership to the witch.     /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties     function _auctionStarted(bytes12 vaultId) internal virtual {         // The Witch is now in control of the vault under auction         cauldron.give(vaultId, address(this));         emit Auctioned(vaultId, uint32(block.timestamp));     } ```  It's possible to look up these parameters on chain by looking up the auction by vault ID in the `auctions` mapping, but not to access them from an event. However, since offchain indexers like the Graph primarily rely on event data, it is probably useful to emit all initial auction parameters and subsequent changes to the auction state through events. (I would also recommend including line `duration` and `initialProportion` for the auction in this event). Since an ongoing auction's current parameters are a pure function of initial conditions, remaining `art`/`ink` and time, this makes it possible to calculate the current state of any auction offchain using only event data.  This recommendation comes from personal experience: I helped develop and maintain an indexing service for Maker liquidation auctions, and having access to necessary data through events rather than having to look it up from contract storage was extremely useful for offchain monitoring tools, liquidation bots, and frontend UIs.  ### Consider a shared `Witch` registry  Witch v2 is designed to allow multiple `Witch` contracts to run in parallel. As part of this design, each `Witch` maintains its own registry of all sibling `Witch` contracts:  [`Witch#setAnotherWitch`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L138-L145)  ```solidity     /// @dev Governance function to set other liquidation contracts that may have taken vaults already.     /// @param value The address that may be set/unset as another witch     /// @param isWitch Is this address a witch or not     function setAnotherWitch(address value, bool isWitch) external auth {         otherWitches[value] = isWitch;         emit AnotherWitchSet(value, isWitch);     } ```  With this design, adding `Witch` number `n` requires `2n - 2` transactions: one tx to each of the existing contracts to register the new sibling `Witch`, plus `n - 1` to the new `Witch` to register all of its siblings. This may be expensive and error prone if there are many `Witch`es. (And it is probably perfectly fine if there are not).  Consider whether a single, shared registry of `Witch` contracts would simplify the design or save gas.  ### Use either custom errors or require statements  Both custom errors and `require` statements are used throughout the codebase. Consider adopting one or the other pattern for handling errors. This is more consistent, lowers the cognitive overhead of reading and understanding the code, and is less prone to error.  (I find it easy to accidentally reverse an error condition when switching between `require` and custom errors, since their logic is typically reversed: custom error conditions usually evaluate `true` to revert while `require` conditions should evaluate `false`).  ### Errors/improvements in comments  The comments on [`L#118-122`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L118-L122) related to `setLimit` seem out of place or outdated. The `setLimit` function only manages the "maximum collateral" value referenced in these comments, but not duration, proportion, minimum collateral, or decimals:  ```solidity     ///  - the auction duration to calculate liquidation prices     ///  - the proportion of the collateral that will be sold at auction start     ///  - the maximum collateral that can be auctioned at the same time     ///  - the minimum collateral that must be left when buying, unless buying all     ///  - The decimals for maximum and minimum ```  Review whether these comments are relevant to the `setLimit` function.  I found the comment on [`L#418`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L418-L421) confusing:  ```solidity         // Update concurrent collateral under auction         DataTypes.Limits memory limits_ = limits[auction_.ilkId][             auction_.baseId         ]; ```  This line loads the current limit into memory, but does not actually update it. The updates happens on [`L#430`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L430) and [`L#450`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L450).  The comment on [`L#92`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L92) might be clearer if it referred to "Time that auctions take to offer max collateral" rather than "go to minimal price":  ```solidity     /// @param duration Time that auctions take to go to minimal price ```  ### Typos  The custom error [`VaultNotLiqudable`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L27) should probably be `VaultNotLiquidatable`, or perhaps something like `VaultFullyCollateralized`.  [`Witch.sol#L520`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L520)  ```solidity -   /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount +   /// @dev quotes how much ink a liquidator is expected to get if it repays an `artIn` amount ```  [`Witch.sol#L385`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L385-L386)  ```solidity -    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people) +    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're different people) ```  ## Informational  ### Google Calendar reminder may be insufficiently robust  The Yield team have set a Google Calendar reminder to replace the `Witch` contract before 7 February 2106:  [`Witch#L575`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L575-L578)  ```solidity         // If the world has not turned to ashes and darkness, auctions will malfunction on         // the 7th of February 2106, at 06:28:16 GMT         // TODO: Replace this contract before then 😰         // UPDATE: Added reminder to Google calendar ✅ ```  However, a Google Calendar reminder may be insufficient to serve as a warning to the future Yield team. In the past, Google has shut down widely used and beloved services (e.g. Reader and Inbox), and there is no guarantee that Google will exist as we know it in the year 2106. Consider taking additional steps to limit this single point of failure.  Suggestions: - Create a timeless and popular work of art that tells the story of replacing the `Witch`, like a film, novel, or folk song. - Hire a Paradigm Fellow and entrust them with the contract upgrade. They will be at most 107 years old in 2106. - Add a reminder in the "Reminders" app on your iPhone.
## WRONG ERROR MESSAGE STRING IN FUNCTION auction()  ```solidity= Line200: require(limits_.sum <= limits_.max, "Collateral limit reached"); ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L200  The above error massage would be relevent if it was only **less then** not **less then or equal**  ### Recommended Mitigation Steps Correct error message string  ```solidity= Line200: require(limits_.sum <= limits_.max, "Collateral limit exceeded"); ``` 
# [2022-07-fractional] QA report  ###### tags: `c4`, `2022-07-yield`, `QA`  ### no need to cast to uint128  `cauldron.debtFromBase()` will [return a uint128](https://github.com/yieldprotocol/vault-v2/blob/3d22b3d460ba031783678948cbb5f84484113990/packages/foundry/contracts/Cauldron.sol#L271-L273), so it's not necessary to cast to uint128 in this line  * https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L303-L305  ### typo comment differente -> different  * https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L385  ### typo comment quoutes -> quote * https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L520
Low risk, non-critical   Quality coding :  1. Line number 191, 192 can be above Line number 202,       https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L191-L192           https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L202      Because, balances  and debt  are used after this line 202 only. This could save the execution cost. Its type of gas savings too. I believe this is better       way of coding.  2.  Comment could be corrected as under-collateralized in,      https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L14  3. initialization : its better to initialize as zero in below line of code. Relying on the unknown storage data could be risky.     https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L133  4. variable name suggestion in below line of code.     https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L99-L100     proportion = VaultProportion,     initialOffer = ColletralProportion   5. code simplification:     https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L303-L309     Since artIn already knw from the line - 303, I would write the condition as below instead of using the ternary operator. Because the code could      simple and readable.    if( artIn > auction_.art )         artIn = auction_.art;  6. I would suggest the contract name as LiquidEngine.sol instead of Witch.sol    Similarly, the variable , otherWitches could be OtherLiquidEngine    Function name, setAnotherWitch could be seAnotherLiquidEngine  7. Its better to use the same datatype in all places. I see there are too many castings. it could tough to track each of the casting to verify appropriate      data type during coding. There could be possibility of missing in some places.  8. For more decentralization: It could better if the governor related cautions is displayed in front end. For example, displaying the auctioner reward in front end.         
**Overview** Risk Rating | Number of issues --- | --- Low Risk | 2 Non-Critical Risk | 3  **Table of Contents**  - [1. Low Risk Issues](#1-low-risk-issues)   - [1.1. Missing address(0) checks](#11-missing-address0-checks)   - [1.2. Unsafe casting may overflow](#12-unsafe-casting-may-overflow) - [2. Non-Critical Issues](#2-non-critical-issues)   - [2.1. Typos](#21-typos)   - [2.2. Open TODOS](#22-open-todos)   - [2.3. Use a `constant` instead of duplicating the same string or replace the following revert strings with Errors](#23-use-a-constant-instead-of-duplicating-the-same-string-or-replace-the-following-revert-strings-with-errors)  # 1. Low Risk Issues  ## 1.1. Missing address(0) checks  Consider adding an `address(0)` check for immutable variables:  ```diff File: Witch.sol 59:     ICauldron public immutable cauldron; ... 71:     constructor(ICauldron cauldron_, ILadle ladle_) { + 72:     require(cauldron_ != address(0)); 72:         cauldron = cauldron_; 73:         ladle = ladle_; 74:     } ```  ## 1.2. Unsafe casting may overflow  SafeMath and Solidity 0.8.* handles overflows for basic math operations but not for casting. Even if the comment says "Overflow is fine", consider using OpenZeppelin's SafeCast library to prevent unexpected behaviors here:  ```solidity Witch.sol:217:        emit Auctioned(vaultId, uint32(block.timestamp)); Witch.sol:241:                start: uint32(block.timestamp), // Overflow is fine Witch.sol:582:            elapsed = uint32(block.timestamp) - uint256(auction_.start); // Overflow on block.timestamp is fine ```  ```solidity File: Witch.sol 302:         // Find out how much debt is being repaid 303:         uint128 artIn = uint128( 304:             cauldron.debtFromBase(auction_.seriesId, maxBaseIn) 305:         ); ```  # 2. Non-Critical Issues  ## 2.1. Typos  - specialised  ```solidity Witch.sol:213:    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties Witch.sol:267:    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties Witch.sol:462:    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties ```  - differente  ```solidity Witch.sol:385:    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people) ```  - quoutes  ```solidity Witch.sol:520:    /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount ```  ## 2.2. Open TODOS  Consider resolving the TODOs before deploying.  ```solidity Witch.sol:577:        // TODO: Replace this contract before then 😰 ```  ## 2.3. Use a `constant` instead of duplicating the same string or replace the following revert strings with Errors  ```solidity Witch.sol:255:        require(auction_.start > 0, "Vault not under auction"); Witch.sol:300:        require(auction_.start > 0, "Vault not under auction"); Witch.sol:358:        require(auction_.start > 0, "Vault not under auction"); Witch.sol:416:        require(auction_.start > 0, "Vault not under auction"); ```  ```solidity Witch.sol:365:        require(liquidatorCut >= minInkOut, "Not enough bought"); Witch.sol:313:        require(liquidatorCut >= minInkOut, "Not enough bought"); ```  ```solidity Witch.sol:328:            require(baseJoin != IJoin(address(0)), "Join not found"); Witch.sol:395:            require(ilkJoin != IJoin(address(0)), "Join not found"); ``` 
Gas saving:  Handling validation check Condition check could be  >=  in below line of code. This could save gas by skipping the calculation done in the else part.  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L586 When elapsed==duration, below calculation will always return 1e18 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L588-L592  memory can be used instead of storage in following lines of codes https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L254 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L231
## [L-01] MISSING ZERO-ADDRESS CHECK Addresses should be checked against `address(0)` to prevent unintended actions, unexpected loss of assets, etc. Please consider checking the following address inputs. ``` contracts\Witch.sol   83: function point(bytes32 param, address value) external auth {   141: function setAnotherWitch(address value, bool isWitch) external auth {   176: function auction(bytes12 vaultId, address to)   286-291:     function payBase(       bytes12 vaultId,       address to,       uint128 minInkOut,       uint128 maxBaseIn     )   344-349:     function payFYToken(       bytes12 vaultId,       address to,       uint128 minInkOut,       uint128 maxArtIn     )   528-532：     function calcPayout(       bytes12 vaultId,       address to,       uint256 maxArtIn     ) ```  ## [L-02] CONSTANTS CAN BE USED INSTEAD OF MAGIC NUMBERS To improve readability and maintainability, constants can be used instead of magic numbers. Please consider replacing the magic numbers in the following code with constants. ``` contracts\Witch.sol   102: require(initialOffer <= 1e18, "InitialOffer above 100%");   103: require(proportion <= 1e18, "Proportion above 100%");   105: initialOffer == 0 || initialOffer >= 0.01e18,   108: require(proportion >= 0.01e18, "Proportion below 1%");   162: if (auctioneerReward_ > 1e18) {   163: revert AuctioneerRewardTooHigh(1e18, auctioneerReward_);   587: proportionNow = 1e18;   591: uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration)); ```  ## [N-01] REDUNDANT CAST `initialProportion` does not need to be converted to uint256 because it is already stored as uint256 for the following code. ``` contracts\Witch.sol   573-591:     uint256 initialProportion = line_.initialOffer;     ...     proportionNow =       uint256(initialProportion) +       uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration)); ```  ## [N-02] REVERT REASON CAN BE MORE EXACT Because of the `initialOffer == 0` condition, `initialOffer` can be 0, which is below 1%. The revert reason can clarify that `initialOffer` can also be 0. ``` contracts\Witch.sol   104-107:     require(       initialOffer == 0 || initialOffer >= 0.01e18,       "InitialOffer below 1%"     ); ```  ## [N-03] REVERT REASON CAN BE MORE DESCRIPTIVE Instead of just mentioning "Unrecognized", the revert reason can describe what is unrecognized. ``` contracts\Witch.sol   83-84:     function point(bytes32 param, address value) external auth {       require(param == "ladle", "Unrecognized");  ```  ## [N-04] INCOMPLETE NATSPEC COMMENTS NatSpec provides rich documentation for code. @param and/or @return are missing for the following NatSpec comments: ``` contracts\Witch.sol   212-214:     /// @dev Moves the vault ownership to the witch.     /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties     function _auctionStarted(bytes12 vaultId) internal virtual {     220-229:     /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repayed     /// and what's the max ink that will be offered in exchange. For the realtime amount of ink that's on offer     /// use `_calcPayout`     function _calcAuction(       DataTypes.Vault memory vault,       DataTypes.Series memory series,       address to,       DataTypes.Balances memory balances,       DataTypes.Debt memory debt     ) internal view returns (DataTypes.Auction memory) {     266-268:     /// @dev Moves the vault ownership back to the original owner & clean internal state.     /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties     function _auctionEnded(bytes12 vaultId, address owner) internal virtual {      385-391:     /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people)     function _payInk(       DataTypes.Auction memory auction_,       address to,       uint256 liquidatorCut,       uint256 auctioneerCut     ) internal {     407-414:     /// @notice Update accounting on the Witch and on the Cauldron. Delete the auction and give back the vault if finished.     /// This function doesn't verify the vaultId matches the vault and auction passed. Check before calling.     function _updateAccounting(       bytes12 vaultId,       DataTypes.Auction memory auction_,       uint256 inkOut,       uint256 artIn     ) internal {    461-468:     /// @dev Logs that a certain amount of a vault was liquidated     /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties     function _collateralBought(       bytes12 vaultId,       address buyer,       uint256 ink,       uint256 art     ) internal virtual {     561-566:     /// @notice Return how much collateral should be given out.     function _calcPayout(       DataTypes.Auction memory auction_,       address to,       uint256 artIn     ) internal view returns (uint256 liquidatorCut, uint256 auctioneerCut) { ```  ## [N-05] @NOTICE PLACEMENT IN NATSPEC COMMENTS It is a convention to place @notice above @dev and @param in NatSpec comments, which is not the case in the following code: ``` contracts\Witch.sol   335-343:     /// @dev Pay up to `maxArtIn` debt from a vault in liquidation using fyToken, getting at least `minInkOut` collateral.     /// @notice If too much fyToken are offered, only the necessary amount are taken.     /// @param vaultId Id of vault to buy     /// @param to Receiver for the collateral bought     /// @param maxArtIn Maximum amount of fyToken that will be paid     /// @param minInkOut Minimum amount of collateral that must be received     /// @return liquidatorCut Amount paid to `to`.     /// @return auctioneerCut Amount paid to whomever started the auction. 0 if it's the same address that's calling this method     /// @return artIn Amount of fyToken taken ```
  #### Variable name  The name `value` could be related to `_address`. `value` may confuse others with fund or numeric type.  ```     /// @dev Governance function to set other liquidation contracts that may have taken vaults already.     /// @param value The address that may be set/unset as another witch     /// @param isWitch Is this address a witch or not     function setAnotherWitch(address value, bool isWitch) external auth {         otherWitches[value] = isWitch;         emit AnotherWitchSet(value, isWitch);     } ```   #### NATSPEC not complete   ```     /// @notice Return how much collateral should be given out.     function _calcPayout(         DataTypes.Auction memory auction_,         address to,         uint256 artIn     ) internal view returns (uint256 liquidatorCut, uint256 auctioneerCut) { ```  suggestion: Follow NATSPEC.     #### MAGICAL NUMBER CAN BE DOCUMENTED AND EXPLAINED  `1e18` is used several times through the code. This may both obscure the purpose of the function and unnecessarily lead to potential error if the constants are changed during development.  ``` 102-108:         require(initialOffer <= 1e18, "InitialOffer above 100%");         require(proportion <= 1e18, "Proportion above 100%");         require(             initialOffer == 0 || initialOffer >= 0.01e18,             "InitialOffer below 1%"         );  162-164:         if (auctioneerReward_ > 1e18) {             revert AuctioneerRewardTooHigh(1e18, auctioneerReward_);         }  587:         proportionNow = 1e18;  591:         uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration)); ```  Suggestion: Use constants as this would make the code more maintainable and readable while costing nothing gas-wise.      #### Arithmic operation order  The division is performed first, and multiplication later.  ``` 594:        uint256 inkAtEnd = uint256(artIn).wdiv(auction_.art).wmul(auction_.ink); ```  It might be arithmically safer to do the multiplication first instead.   
# Yield-Witch-v2-code4rena Report  - [Yield-Witch-v2-code4rena Report](#yield-witch-v2-code4rena-report)   - [QA Report](#qa-report)   - [Files Description Table](#files-description-table)   - [Issues found](#issues-found)     - [[N-01]: Typos](#n-01-typos)       - [Impact](#impact)       - [Code Affected and Mitigation](#code-affected-and-mitigation)       - [Tools used](#tools-used)  ##  QA Report  ##  Files Description Table | File Name                         | SHA-1 Hash                               | | --------------------------------- | ---------------------------------------- | | 2022-07-yield/contracts/Witch.sol | 07190e9e6d7769e20bcc07030eee3802ee199a5f |  ## Issues found  ### [N-01]: Typos  #### Impact None.  #### Code Affected and Mitigation  ```diff diff --git a/contracts/Witch.sol b/contracts/Witch.sol index f98dd6a..92ca566 100644 --- a/contracts/Witch.sol +++ b/contracts/Witch.sol @@ -217,7 +217,7 @@ contract Witch is AccessControl {          emit Auctioned(vaultId, uint32(block.timestamp));      }   -    /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repayed +    /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repaid      /// and what's the max ink that will be offered in exchange. For the realtime amount of ink that's on offer      /// use `_calcPayout`      function _calcAuction( @@ -264,7 +264,7 @@ contract Witch is AccessControl {      }        /// @dev Moves the vault ownership back to the original owner & clean internal state. -    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties +    /// Useful as a method so it can be overridden by specialised witches that may need to do extra accounting or notify 3rd parties      function _auctionEnded(bytes12 vaultId, address owner) internal virtual {          cauldron.give(vaultId, owner);          delete auctions[vaultId]; @@ -382,7 +382,7 @@ contract Witch is AccessControl {          _collateralBought(vaultId, to, liquidatorCut + auctioneerCut, artIn);      }   -    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people) +    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're different people)      function _payInk(          DataTypes.Auction memory auction_,          address to, @@ -459,7 +459,7 @@ contract Witch is AccessControl {      }        /// @dev Logs that a certain amount of a vault was liquidated -    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties +    /// Useful as a method so it can be overridden by specialised witches that may need to do extra accounting or notify 3rd parties      function _collateralBought(          bytes12 vaultId,          address buyer, @@ -517,7 +517,7 @@ contract Witch is AccessControl {          */ -    /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount +    /// @dev Quotes how much ink a liquidator is expected to get if it repays an `artIn` amount      /// Works for both Auctioned and ToBeAuctioned vaults      /// @param vaultId The vault to get a quote for      /// @param to Address that would get the collateral bought  ```  #### Tools used VS Code 
**Missing Non-zero address check in `payBase()` can result in lost funds for liquidator**  **Proof of concept:** If a liquidator mistakenly passes the zero address as the `to` argument of the `payBase()` function, then the collateral will be sent to the zero address.   **Recommended Mitigation Steps:** Add a non-zero address check for the `to` parameter in `payBase()`      **Misleading comment in `_updateAccounting()`**  **Proof of concept:** In `_updateAccounting()` there is the following piece of code:  ```jsx // Update concurrent collateral under auction  DataTypes.Limits memory limits_ = limits[auction_.ilkId][     auction_.baseId  ]; ```  The comment says the following code will “update” something, but it is just a memory copied variable.  **Recommended Mitigation Steps:** Remove the misleading comment
#1 Immutable  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L60  add immutable on ladle state because  ladle state  must be initialize through constructor  #3 Code and comment not match  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L392          // If liquidatorCut is 0, then auctioneerCut is 0 too, so no need to double check         if (liquidatorCut > 0) {             IJoin ilkJoin = ladle.joins(auction_.ilkId);             require(ilkJoin != IJoin(address(0)), "Join not found");               // Pay auctioneer's cut if necessary             if (auctioneerCut > 0) {                 ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128());             } because liquidator is 0, and then auctioneerCut is 0 too. so           if (liquidatorCut > 0) { ----->  if (liquidatorCut => 0) { and          if (auctioneerCut > 0) { -----> if (auctioneerCut => 0)  {     #3 Typo  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L520      /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount  change hoy to how  #4 unused natspec comment  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L567-L568  remove the natspec comment if unused. it decrase readibility  #5 Missing param comment vaultid  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L213  add natspec comment param vaultid  #6 Missing param comment  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L220  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L407  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L461  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L562  function have natspec comment which is missing. Add natspec comments include all parameter in the function. 
## Summary   ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | [L&#x2011;01] | `setLine()` parameters inconsistently followed | 1 | | [L&#x2011;02] | Events will contain the wrong timestamp in the future | 1 | | [L&#x2011;03] | Integer overflow due to casting will cause contract accounting to break | 1 |  Total: 3 instances over 3 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | [N&#x2011;01] | Incomplete documentation | 1 | | [N&#x2011;02] | Timestamps in events are redundant | 1 | | [N&#x2011;03] | `constant`s should be defined rather than using magic numbers | 8 | | [N&#x2011;04] | Redundant cast | 2 | | [N&#x2011;05] | Typos | 6 | | [N&#x2011;06] | NatSpec is incomplete | 1 | | [N&#x2011;07] | Event is missing `indexed` fields | 6 | | [N&#x2011;08] | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 2 |  Total: 27 instances over 8 issues   ## Low Risk Issues  ### [L&#x2011;01]  `setLine()` parameters inconsistently followed In `setLine()` there's a [require()](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L104-L107) that ensures that the initial offer is either equal to zero, or greater than 1%. It stands to reason that therefore, offers less than 1% are considered dust and are not actionable. If this is the case, then in the `else`-block on line 589, does not follow this same dust-skipping logic when `initialProportion` is set to zero, and will waste time offering proportions that nobody will take. This may lead to auctions taking longer than necessary, and more funds being lost. It is incorrect state handling and therefore of Low risk. If there was some other meaning behind the conditions, there should be a `require()` enforcing it  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  584          if (duration == type(uint32).max) {     // Interpreted as infinite duration 585              proportionNow = initialProportion; 586          } else if (elapsed > duration) { 587              proportionNow = 1e18; 588          } else { 589              proportionNow = 590                  uint256(initialProportion) + 591                  uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration)); 592:         }  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L584-L592  ### [L&#x2011;02]  Events will contain the wrong timestamp in the future While the timestamp field in the event might not affect on-chain processing, it _will_ impact off-chain tools that have to parse it. This is incorrect state handling and therefore of Low risk  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  217:         emit Auctioned(vaultId, uint32(block.timestamp));  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L217  ### [L&#x2011;03]  Integer overflow due to casting will cause contract accounting to break When `block.timestamp` becomes larger than `type(uint32).max`, the cast on line 582 will overflow, causing the elapsed time calculation to be extremely large and wrong if the auction start time was before the wrap. This will cause the proportion to be greater than 100%, and will allow a liquidator to earn a massive fee. Comments in code are not sufficient to prevent client fund loss, and relying on Google calendar is obviously not either. This should be a Medium, but I'm guessing the sponsor will argue that it's already documented here in the code (though it needs to be in the `README.md` and in Yield's risks documentation), so it's not worth while to write up the whole thing just to have it downgraded by a judge that decides not to follow that rule.  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  575          // If the world has not turned to ashes and darkness, auctions will malfunction on 576          // the 7th of February 2106, at 06:28:16 GMT 577          // TODO: Replace this contract before then 😰 578          // UPDATE: Added reminder to Google calendar ✅ 579          uint256 elapsed; 580          uint256 proportionNow; 581          unchecked { 582              elapsed = uint32(block.timestamp) - uint256(auction_.start); // Overflow on block.timestamp is fine 583:         }  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L575-L583  ## Non-critical Issues  ### [N&#x2011;01]  Incomplete documentation The infinite duration comment should be in NatSpec, not a normal comment hidden in the code  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  584:         if (duration == type(uint32).max) {     // Interpreted as infinite duration  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L584  ### [N&#x2011;02]  Timestamps in events are redundant `block.timestamp` and `block.number` are added to event information by default so adding them manually wastes gas and is redundant  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  217:         emit Auctioned(vaultId, uint32(block.timestamp));  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L217  ### [N&#x2011;03]  `constant`s should be defined rather than using magic numbers Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals  *There are 8 instances of this issue:* ```solidity File: contracts/Witch.sol  /// @audit 1e18 102:          require(initialOffer <= 1e18, "InitialOffer above 100%");  /// @audit 1e18 103:          require(proportion <= 1e18, "Proportion above 100%");  /// @audit 0.01e18 105:              initialOffer == 0 || initialOffer >= 0.01e18,  /// @audit 0.01e18 108:          require(proportion >= 0.01e18, "Proportion below 1%");  /// @audit 1e18 162:          if (auctioneerReward_ > 1e18) {  /// @audit 1e18 163:              revert AuctioneerRewardTooHigh(1e18, auctioneerReward_);  /// @audit 1e18 587:              proportionNow = 1e18;  /// @audit 1e18 591:                  uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration));  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L102  ### [N&#x2011;04]  Redundant cast The type of the variable is the same as the type to which the variable is being cast  *There are 2 instances of this issue:* ```solidity File: contracts/Witch.sol  /// @audit uint256(initialProportion) 590:                  uint256(initialProportion) +  /// @audit uint256(artIn) 594:          uint256 inkAtEnd = uint256(artIn).wdiv(auction_.art).wmul(auction_.ink);  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L590  ### [N&#x2011;05]  Typos  *There are 6 instances of this issue:* ```solidity File: contracts/Witch.sol  /// @audit overriden 213:      /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties  /// @audit repayed 220:      /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repayed  /// @audit overriden 267:      /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties  /// @audit differente 385:      /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people)  /// @audit overriden 462:      /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties  /// @audit quoutes 520:      /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L213  ### [N&#x2011;06]  NatSpec is incomplete  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  /// @audit Missing: '@return' 174       /// @param vaultId Id of vault to liquidate 175       /// @param to Receiver of the auctioneer reward 176       function auction(bytes12 vaultId, address to) 177           external 178:          returns (DataTypes.Auction memory auction_)  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L174-L178  ### [N&#x2011;07]  Event is missing `indexed` fields Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (threefields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question  *There are 6 instances of this issue:* ```solidity File: contracts/Witch.sol  33        event Bought( 34            bytes12 indexed vaultId, 35            address indexed buyer, 36            uint256 ink, 37            uint256 art 38:       );  43        event LineSet( 44            bytes6 indexed ilkId, 45            bytes6 indexed baseId, 46            uint32 duration, 47            uint64 proportion, 48            uint64 initialOffer 49:       );  50:       event LimitSet(bytes6 indexed ilkId, bytes6 indexed baseId, uint128 max);  51:       event AnotherWitchSet(address indexed value, bool isWitch);  52        event IgnoredPairSet( 53            bytes6 indexed ilkId, 54            bytes6 indexed baseId, 55            bool ignore 56:       );  57:       event AuctioneerRewardSet(uint128 auctioneerReward);  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L33-L38  ### [N&#x2011;08]  Duplicated `require()`/`revert()` checks should be refactored to a modifier or function The compiler will inline the function, which will avoid `JUMP` instructions usually associated with functions  *There are 2 instances of this issue:* ```solidity File: contracts/Witch.sol  300:          require(auction_.start > 0, "Vault not under auction");  365:          require(liquidatorCut >= minInkOut, "Not enough bought");  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L300   
## Mixed Use of Custom Errors and `require(condition, "msg"` **Severity**: Informational **Context**: [`Witch.sol`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol)  **Description**: It's better to stick to one or the other to stay consistent.  **Recommendation**: I would recommend the use of just custom errors to save gas on deployment.   ## `otherWitches` Possible Name Suggestion **Severity**: Informational **Context**: [`Witch.sol#L68`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L68)  **Description**: "The name is a bit misleading, as any address can be entered. Better naming suggestions are welcome."  **Recommendation**: Maybe `Witched`, `VaultTaken`, `bewitched` or `hexed`   ## Contract Code Size Exceeds Bytes Limit **Severity**: Informational **Context**: [`Witch.sol`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol)  **Description**: Contract code size is 28515 bytes and exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on mainnet.   **Recommendation**: Consider enabling the optimizer (with a low "runs" value!), turning off revert strings, or using libraries.   ## TODOs Left In The Code **Severity**: Informational **Context**: [`Witch.sol#L577`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L577)  **Description**: There should never be any TODOs in the code when deploying.  **Recommendation**: Add this TODO to the docs instead.   ## Spelling Errors **Severity**: Informational **Context**: [`Witch.sol#L213 (overriden => overridden)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L213), [`Witch.sol#L220 (repayed => repaid)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L220), [`Witch.sol#L267 (overriden => overridden)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L267), [`Witch.sol#L267 (differente => different)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L267), [`Witch.sol#L462 (overriden => overridden)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L462), [`Witch.sol#L512 (Delete the extra space)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L512), [`Witch.sol#L520 (quoutes => quotes)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L520), [`Witch.sol#L520 (hoy => how)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L520)  **Description**: Spelling errors in comments can cause confusion to both users and developers.  **Recommendation**: Check all misspellings to ensure they are corrected.   ## Missing or Incomplete NatSpec **Severity**: Informational **Context**: [`Witch.sol`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol)  **Description**: Some functions are missing @notice/@dev NatSpec comments for the function, @param for all/some of their parameters and @return for return values. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability and usability.  **Recommendation**: Add in full NatSpec comments for all functions to have complete code documentation for future use.
## 1 zero address check missing  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L71 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L176 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L288 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L346  ## 2. variable name `otherWitches` can be change to `witches` only ( as sponsor wants name suggestions )  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L68 
# Codebase Impressions & Summary  ### Functionality  The revised witch (liquidation engine) contract includes the following improvements over the previous version. As stated in the README, they are:  1. Greater flexibility in exploring different liquidation models. 2. Making liquidations more profitable for liquidators by allowing payments in `fyToken`. 3. Introduce a mechanism to reward starting an auction. 4. Allow fine-tuning of all parameters for any collateral/underlying pair. 5. Correct bugs.  The liquidations flow was quite easy to follow as it consists of the following:  1. Liquidation parameters are defined by governance functions (auction duration, vault proportion, auctioneer reward etc.) 2. Starting an auction: `auction()` 3. Liquidators executing the liquidations: `payBase()` and `payFYToken()` 4. Either the entire vault collateral has been auctioned off, or `cancel()` is called to prematurely end the auction  ### Documentation  The README was very extensive and thorough, and succinctly explained design considerations made. Flow diagrams were provided to help visualise the interactions required between different contracts. Inline comments were appropriate too, aided in understanding the functionality.  ### Tests  All foundry tests passed as expected. One area of improvement is to have mainnet forking tests, since mocking is used for the external contracts. Running `forge coverage` unfortunately didn’t work. I suspect it is due to the instability of the feature rather than the fault of the tests.   ### Gas Optimizations  Casting could be avoided if input / output params were defined appropriately. For instance, `inkOut`, `artIn` in `_updateAccounting()`, and `liquidatorCut` and `auctioneerCut` could have been `uint128` instead of `uint256`.  # Low Severity Findings  ## L01: Vaults that are over-collateralised after partial liquidation are possibly subject to further liquidations  ### Description  If a vault becomes over-collateralised after a partial liquidation, it is still subject to further liquidation as the auction isn’t closed. The vault owner has to call `cancel()` himself, or trust other altruistic actors to perform this action on his behalf. Liquidators will unlikely do it because they are economically incentivised not to do so.  One can however argue that this is mitigated by the fact that protocol (governance) sets the vault proportion that can be auctioned. Regardless of whether the fact that the vault is over-collateralised after partial liquidations, the liquidators arguably are given the right to carry out further liquidations up to the proportion set.  Nevertheless, a reason for a revised liquidations witch contract is that “More often than not, liquidated users have lost all their collateral as we have failed to make liquidations competitive.”. Hence, it might make sense to ensure that users need not lose more collateral than necessary.  ### Recommended Mitigation Steps  Consider checking if the vault is over-collateralized (maybe in `_updateAccounting()`) and close the auction if it is. This however adds complexity to the liquidation logic, as you have to update the cauldron first `cauldron.slurp()` before checking and updating the collateralization status. It will also break the CEI pattern, which might be unfavourable.  ## L02: Comparison in `_calcPayout()` should include equality  ### Line References  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L586](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L586)  ### TLDR  ```diff - else if (elapsed > duration) + else if (elapsed >= duration) ```  ### Description  In the case where `elapsed == duration`, `proportionNow` evaluates to `1e18`, which is the same result when `elapsed > duration`. Proof below.  ```solidity proportionNow =   uint256(initialProportion) +   uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration));  // = initialProportion + (1e18 - initialProportion).wmul(1e18) // = initialProportion + (1e18 - initialProportion) * 1e18 / 1e18 // = initialProportion + 1e18 - initialProportion // = 1e18 ```  Of slightly greater importance, this handles the edge case when `elapsed = duration = 0`, ie. the liquidation transaction is included in the same block / has the same timestamp as the auction initialization transaction  ### Recommended Mitigation Steps  As per the TLDR.  ### P.S. Regarding zero duration auctions  Since the proportion given for zero duration auctions is `1e18`, it is equivalent to an auction of infinite duration with 100% initial offer: `duration == type(uint32).max` and `line_.initialOffer = 1e18`.  ## L03: Incorrect description for `auctioneerCut`  ### Line References  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L284](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L284)  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L342](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L342)  ### Description  Technically, the `auctioneerCut` goes to the `to` address specified by the auctioneer when `auction()` is called, which, while unlikely, may not be the auctioneer himself. Also, the comparison is done against the `to` address specified, not the caller / `msg.sender` as the comment implies.  ### Recommended Mitigation Steps  ```diff - Amount paid to whomever started the auction. 0 if it's the same address that's calling this method + Amount paid to address specified by whomever started the auction. 0 if it's the same as the `to` address ```  ## L04: Incorrect natspec for `setLimit()`  ### Line References  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L118-L122](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L118-L122)  ### Description  The comments seem outdated as the only parameter that is updated by the function is the maximum collateral that can be concurrently auctioned off.  ```solidity ///  - the auction duration to calculate liquidation prices ///  - the proportion of the collateral that will be sold at auction start ///  - the maximum collateral that can be auctioned at the same time ///  - the minimum collateral that must be left when buying, unless buying all ///  - The decimals for maximum and minimum ```  ### Recommended Mitigation Steps  Suggest removing / updating the referenced comments.  # Non-Critical Findings  ## NC01: Modify comment to soft limit check for clarity  ### Line References  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L194-L196](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L194-L196)  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L200](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L200)  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L204](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L204)   ### Description  The limit check is done before the summation to the total collateral allowable for liquidation. One may consider this to be a bug, but the README explains why this is the case:  ```markdown Note that the first auction to reach the limit is allowed to pass it, so that there is never the situation where a vault would be too big to ever be auctioned. ```  The inline comments have this as well, but isn’t as clearly put as the README.  ```solidity // There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit. // If the limit has been surpassed, no more vaults of that collateral can be put for auction. // This avoids the scenario where some vaults might be too large to be auctioned. ```  ### Recommended Mitigation Steps  For greater clarity, I would suggesting modifying the inline comment to be worded similar as the README.  ```diff // There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit. - // If the limit has been surpassed, no more vaults of that collateral can be put for auction. + // The first auction to reach or exceed the limit is allowed to pass it, but subsequently, no more vaults of that collateral can be put for auction. // This avoids the scenario where some vaults might be too large to be auctioned. ```  ## NC02: Typos  ```diff - bellow + below  - differente + different  // Extra spacing - The Join  then dishes out + The Join then dishes out  - quoutes hoy much ink + quotes how much ink ```
## typo in comments:  overriden --> overridden  - [Witch.sol#L213](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L213) - [Witch.sol#L267](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L267) - [Witch.sol#L462](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L462)   repayed --> repaid  - [Witch.sol#L220](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L220)  differente --> different  - [Witch.sol#L385](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L385)  quoutes --> quotes  - [Witch.sol#L520](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L520)  hoy --> how   - [Witch.sol#L520](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L520)  
### Low Risk Findings Overview |        | Finding                    |  Instances  | |:-------|:---------------------------|:-----------:| | [L-01] | Missing `address(0)` check |      3      | ### Non-critical Findings Overview |        | Finding                                     |  Instances  | |:-------|:--------------------------------------------|:-----------:| | [N-01] | The use of magic numbers is not recommended |      5      | | [N-02] | Typo                                        |      2      | | [N-03] | Remove TODO’s                               |      1      | ### QA overview per contract | Contract                                                                                                                   |  Total Instances  |  Total Findings  |  Low Findings  |  Low Instances  |  NC Findings  |  NC Instances  | |:---------------------------------------------------------------------------------------------------------------------------|:-----------------:|:----------------:|:--------------:|:---------------:|:-------------:|:--------------:| | [Witch.sol](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol) |        10         |        4         |       1        |        3        |       3       |       7        | | [Witch.sol](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol)                                     |         1         |        1         |       0        |        0        |       1       |       1        | ## Low Risk Findings ### [L-01] Missing `address(0)` check Funds might be lost by accident if check is not implemented. ***3 instances of this issue have been found:*** ###### [L-01] [Witch.sol#L286-L301](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L286-L301) ```solidity      function payBase(         bytes12 vaultId,         address to,         uint128 minInkOut,         uint128 maxBaseIn     )         external         returns (             uint256 liquidatorCut,             uint256 auctioneerCut,             uint256 baseIn         )     {         DataTypes.Auction memory auction_ = auctions[vaultId];         require(auction_.start > 0, "Vault not under auction");  ``` ###### [L-01b] [Witch.sol#L176-L177](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L176-L177) ```solidity      function auction(bytes12 vaultId, address to)  ``` ###### [L-01c] [Witch.sol#L344-L359](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L344-L359) ```solidity      function payFYToken(         bytes12 vaultId,         address to,         uint128 minInkOut,         uint128 maxArtIn     )         external         returns (             uint256 liquidatorCut,             uint256 auctioneerCut,             uint256 artIn         )     {         DataTypes.Auction memory auction_ = auctions[vaultId];         require(auction_.start > 0, "Vault not under auction");  ```  ## Non-critical Findings ### [N-01] The use of magic numbers is not recommended Consider setting constant numbers as a `constant` variable for better readability and clarity. ***5 instances of this issue have been found:*** ###### [N-01] [Witch.sol#L587-L588](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L587-L588) ```solidity              proportionNow = 1e18;  ``` ###### [N-01b] [Witch.sol#L105-L106](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L105-L106) ```solidity              initialOffer == 0 || initialOffer >= 0.01e18,  ``` ###### [N-01c] [Witch.sol#L108-L109](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L108-L109) ```solidity          require(proportion >= 0.01e18, "Proportion below 1%");  ``` ###### [N-01d] [Witch.sol#L162-L163](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L162-L163) ```solidity          if (auctioneerReward_ > 1e18) {  ``` ###### [N-01e] [Witch.sol#L591-L592](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L591-L592) ```solidity                  uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration));  ``` ### [N-02] Typo Please fix typos. ***2 instances of this issue have been found:*** ###### [N-02] [Witch.sol#L81](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L81) ```solidity  /// @param param Name of parameter to set (must be "ladle") ``` ###### [N-02b] [Witch.sol#L14](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L14) ```solidity  uncollateralized -> undercollateralized ``` ### [N-03] Remove TODO’s They add unnecessary cluttler and harm readbility for auditors. ***1 instance of this issue has been found:*** ###### [N-03] [Witch.sol#L577-L578](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L577-L578) ```solidity          // TODO: Replace this contract before then 😰 -> This is funny though  ``` 
## Wrong Comment in `SetLimit` Function  There is a wrong comment in `SetLimit` function. The comment doesn't explain the parameters used in the function. this can confuse the reader when reading the code. The comment is located below: https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L118-L122
# Lines of code  https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L232   # Vulnerability details  ## Impact It was observed that the debt and collateral which moves for Auction is calculated incorrectly. In case where line.proportion is set to small value, chances are art will become lower than min debt. This causes whole collateral to go for auction, which was not expected  ___  ## Proof of Concept 1. Assume line.proportion is set to 10% which is a [valid value](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L108)  2. Auction is started on Vault associated with collateral & base representing line from Step 1  3. Now debt and collateral to be sold are calculated in [_calcAuction](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L223)  ``` uint128 art = uint256(balances.art).wmul(line.proportion).u128();         if (art < debt.min * (10**debt.dec)) art = balances.art;         uint128 ink = (art == balances.art)             ? balances.ink             : uint256(balances.ink).wmul(line.proportion).u128(); ```  4. Now lets say **debt (art)** on this vault was **amount 10**, **collateral (ink)** was **amount 9**, debt.min * (10**debt.dec) was **amount 2**  5. Below calculation occurs  ``` uint128 art = uint256(balances.art).wmul(line.proportion).u128(); // which makes art = 10*10% =1         if (art < debt.min * (10**debt.dec)) art = balances.art;   // since 1<2 so art=10         uint128 ink = (art == balances.art)                                 // Since art is 10 so ink=9             ? balances.ink             : uint256(balances.ink).wmul(line.proportion).u128(); ```  6. So full collateral and full debt are placed for Auction even though only 10% was meant for Auction. Even if it was lower than min debt, auction amount should have only increased upto the point where minimum debt limit is reached  ___  ## Recommended Mitigation Steps Revise the calculation like below  ``` uint128 art = uint256(balances.art).wmul(line.proportion).u128(); uint128 ink=0;         if (art < debt.min * (10**debt.dec))  { art = debt.min * (10**debt.dec); (balances.ink<art) ? (ink=balances.ink) : (ink=art) } else { ink=uint256(balances.ink).wmul(line.proportion).u128(); } ```  
# no return natspec for these functions https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L177 # typos instead of : overriden use : overridden https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L213 https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L268 instead of : specialised use : specialized https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L213 https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L268 instead of : differente use   different https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L387 instead of : quoutes use : quotes https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L522  ## no adress zero check https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L247 https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L390 ##  its best practice to remove todos from the code  https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L577 ## its best practice to remove commented code out from the contract https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L570 ## make sure external functions are comments as a part of the contract becuase there are external functions at the end of the contract after even internal functions. so as best practice make external and importent functions at the begaining of the contract then put the internal functions just to make it easier to read. https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L287 https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L253 these 2 functions are external and very importent but are in  between internal functions and the other external functions arenet which makes these functions hard to read or devs/auditors will miss these functions and think they are view or internal and not test them. ## its best practice to emit the old variable and the new variable for an importent admin function https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L84 ## make an absolute value with point function becuase if the admin is comprimsed then the attacker can set ladle to any value so instead make a require statement like ``` require(ladle<100); ``` https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L86
# Lines of code  https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L176 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L399   # Vulnerability details  ## Impact might lead to systematic debt. Cause errors for liquidators to run normally.  ## Proof of Concept In the function `auction`, there is on input validation around whether the `to` is `address(0)` or not. and if the `auctioneerReward` is set to an value > 0 (as default),  each liquidate call will call `Join` module to pay out to `auctioneer` with the following line:  ```jsx if (auctioneerCut > 0) {     ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128()); } ```  This line will revert if `auctioneer` is set to `address(0)` on some tokens (revert on transferring to address(0) is a [default behaviour of the OpenZeppelin template](https://www.notion.so/Yield-Witch-555e6981c26b41008d03a504077b4770)). So if someone start an `auction` with `to = address(0)`, this auction becomes un-liquidatable.  A malicious user can run a bot to monitor his own vault, and if the got underwater and they don’t have enough collateral to top up, they can immediately start an auction on their own vault and set actioneer to `0` to avoid actually being liquidated, which breaks the design of the system.   ## Recommended Mitigation Steps  Add check while starting an auction:  ```jsx function auction(bytes12 vaultId, address to)     external     returns (DataTypes.Auction memory auction_) {     require (to != address(0), "invalid auctioneer");   ... }   ```  
## Summary Alberto asked [on Twitter](https://twitter.com/alcueca/status/1547548084594515970) whether the Yield team succeeded in making their contracts as easily auditable as possible. I think so. I appreciated the sequence diagrams and design decisions in the audit README, the general protocol docs, and the narrow focus in this audit on a single contract.  Here are a few more recommendations: - I find Maker terminology like `ilk`, `ink`, and `art` very useful in the domain of lending protocols, but it can be confusing to the uninitiated. It would be helpful to provide a glossary of these key terms in your project docs. Additionally, it would be helpful to note anywhere that Yield's definition of some concept diverges from Maker's. For example, a Yield `ilk` is a `bytes6` ID, while a Maker `ilk` is a `bytes32`. - Since this audit was limited in scope, it included a fairly narrow set of tests in `Witch.t.sol`, with external dependencies mocked or stubbed. However, at least one of my findings was related to interactions with other protocol contracts. I wrote a stubbed out test for this finding using the existing test harness, but if it was easy to write an integration/simulation test as a PoC, I would have. The hardest part of writing a test like this for an unfamiliar protocol is orchestrating all the dependencies. Consider providing a test harness that sets up all the core contracts as a tool for auditors. - Highlighting key changes between Witch V1 and Witch V2 with references to the code might have been useful, especially to motivate why you chose to make certain changes in the new design.  All in all though, your documentation is great. Thank you for investing the time and effort required to make auditing as easy as possible.  ## Low  ### Auctioneer reward can be sent to protocol contracts  I don't see a clear exploit path here, but it's possible for the caller of `auction` to send their auctioneer reward to Yield protocol contracts, for example the `Witch` itself, or the `Join` contract corresponding to the liquidated asset. The `Join` contracts appear to handle unexpected assets correctly, but consider whether there may be places in the protocol where this sort of transfer could interfere with internal accounting.  ## QA  ### Emit all auction parameters in an event  The `Auction` data type created and stored in `Witch#_calcAuction` includes the initial parameters for a given auction, and writes these values to a storage mapping:  [`Witch#_calcAuction`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L239-L248)  ```solidity             DataTypes.Auction({                 owner: vault.owner,                 start: uint32(block.timestamp), // Overflow is fine                 seriesId: vault.seriesId,                 baseId: series.baseId,                 ilkId: vault.ilkId,                 art: art,                 ink: ink,                 auctioneer: to             }); ```  However, the `Auctioned` event emitted from `Witch#_auctionStarted` includes only the vault ID and timestamp:  [`Witch#_auctionStarted`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L212-L218)  ```solidity     /// @dev Moves the vault ownership to the witch.     /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties     function _auctionStarted(bytes12 vaultId) internal virtual {         // The Witch is now in control of the vault under auction         cauldron.give(vaultId, address(this));         emit Auctioned(vaultId, uint32(block.timestamp));     } ```  It's possible to look up these parameters on chain by looking up the auction by vault ID in the `auctions` mapping, but not to access them from an event. However, since offchain indexers like the Graph primarily rely on event data, it is probably useful to emit all initial auction parameters and subsequent changes to the auction state through events. (I would also recommend including line `duration` and `initialProportion` for the auction in this event). Since an ongoing auction's current parameters are a pure function of initial conditions, remaining `art`/`ink` and time, this makes it possible to calculate the current state of any auction offchain using only event data.  This recommendation comes from personal experience: I helped develop and maintain an indexing service for Maker liquidation auctions, and having access to necessary data through events rather than having to look it up from contract storage was extremely useful for offchain monitoring tools, liquidation bots, and frontend UIs.  ### Consider a shared `Witch` registry  Witch v2 is designed to allow multiple `Witch` contracts to run in parallel. As part of this design, each `Witch` maintains its own registry of all sibling `Witch` contracts:  [`Witch#setAnotherWitch`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L138-L145)  ```solidity     /// @dev Governance function to set other liquidation contracts that may have taken vaults already.     /// @param value The address that may be set/unset as another witch     /// @param isWitch Is this address a witch or not     function setAnotherWitch(address value, bool isWitch) external auth {         otherWitches[value] = isWitch;         emit AnotherWitchSet(value, isWitch);     } ```  With this design, adding `Witch` number `n` requires `2n - 2` transactions: one tx to each of the existing contracts to register the new sibling `Witch`, plus `n - 1` to the new `Witch` to register all of its siblings. This may be expensive and error prone if there are many `Witch`es. (And it is probably perfectly fine if there are not).  Consider whether a single, shared registry of `Witch` contracts would simplify the design or save gas.  ### Use either custom errors or require statements  Both custom errors and `require` statements are used throughout the codebase. Consider adopting one or the other pattern for handling errors. This is more consistent, lowers the cognitive overhead of reading and understanding the code, and is less prone to error.  (I find it easy to accidentally reverse an error condition when switching between `require` and custom errors, since their logic is typically reversed: custom error conditions usually evaluate `true` to revert while `require` conditions should evaluate `false`).  ### Errors/improvements in comments  The comments on [`L#118-122`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L118-L122) related to `setLimit` seem out of place or outdated. The `setLimit` function only manages the "maximum collateral" value referenced in these comments, but not duration, proportion, minimum collateral, or decimals:  ```solidity     ///  - the auction duration to calculate liquidation prices     ///  - the proportion of the collateral that will be sold at auction start     ///  - the maximum collateral that can be auctioned at the same time     ///  - the minimum collateral that must be left when buying, unless buying all     ///  - The decimals for maximum and minimum ```  Review whether these comments are relevant to the `setLimit` function.  I found the comment on [`L#418`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L418-L421) confusing:  ```solidity         // Update concurrent collateral under auction         DataTypes.Limits memory limits_ = limits[auction_.ilkId][             auction_.baseId         ]; ```  This line loads the current limit into memory, but does not actually update it. The updates happens on [`L#430`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L430) and [`L#450`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L450).  The comment on [`L#92`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L92) might be clearer if it referred to "Time that auctions take to offer max collateral" rather than "go to minimal price":  ```solidity     /// @param duration Time that auctions take to go to minimal price ```  ### Typos  The custom error [`VaultNotLiqudable`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L27) should probably be `VaultNotLiquidatable`, or perhaps something like `VaultFullyCollateralized`.  [`Witch.sol#L520`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L520)  ```solidity -   /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount +   /// @dev quotes how much ink a liquidator is expected to get if it repays an `artIn` amount ```  [`Witch.sol#L385`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L385-L386)  ```solidity -    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people) +    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're different people) ```  ## Informational  ### Google Calendar reminder may be insufficiently robust  The Yield team have set a Google Calendar reminder to replace the `Witch` contract before 7 February 2106:  [`Witch#L575`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L575-L578)  ```solidity         // If the world has not turned to ashes and darkness, auctions will malfunction on         // the 7th of February 2106, at 06:28:16 GMT         // TODO: Replace this contract before then 😰         // UPDATE: Added reminder to Google calendar ✅ ```  However, a Google Calendar reminder may be insufficient to serve as a warning to the future Yield team. In the past, Google has shut down widely used and beloved services (e.g. Reader and Inbox), and there is no guarantee that Google will exist as we know it in the year 2106. Consider taking additional steps to limit this single point of failure.  Suggestions: - Create a timeless and popular work of art that tells the story of replacing the `Witch`, like a film, novel, or folk song. - Hire a Paradigm Fellow and entrust them with the contract upgrade. They will be at most 107 years old in 2106. - Add a reminder in the "Reminders" app on your iPhone.
## WRONG ERROR MESSAGE STRING IN FUNCTION auction()  ```solidity= Line200: require(limits_.sum <= limits_.max, "Collateral limit reached"); ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L200  The above error massage would be relevent if it was only **less then** not **less then or equal**  ### Recommended Mitigation Steps Correct error message string  ```solidity= Line200: require(limits_.sum <= limits_.max, "Collateral limit exceeded"); ``` 
# [2022-07-fractional] QA report  ###### tags: `c4`, `2022-07-yield`, `QA`  ### no need to cast to uint128  `cauldron.debtFromBase()` will [return a uint128](https://github.com/yieldprotocol/vault-v2/blob/3d22b3d460ba031783678948cbb5f84484113990/packages/foundry/contracts/Cauldron.sol#L271-L273), so it's not necessary to cast to uint128 in this line  * https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L303-L305  ### typo comment differente -> different  * https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L385  ### typo comment quoutes -> quote * https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L520
Low risk, non-critical   Quality coding :  1. Line number 191, 192 can be above Line number 202,       https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L191-L192           https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L202      Because, balances  and debt  are used after this line 202 only. This could save the execution cost. Its type of gas savings too. I believe this is better       way of coding.  2.  Comment could be corrected as under-collateralized in,      https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L14  3. initialization : its better to initialize as zero in below line of code. Relying on the unknown storage data could be risky.     https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L133  4. variable name suggestion in below line of code.     https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L99-L100     proportion = VaultProportion,     initialOffer = ColletralProportion   5. code simplification:     https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L303-L309     Since artIn already knw from the line - 303, I would write the condition as below instead of using the ternary operator. Because the code could      simple and readable.    if( artIn > auction_.art )         artIn = auction_.art;  6. I would suggest the contract name as LiquidEngine.sol instead of Witch.sol    Similarly, the variable , otherWitches could be OtherLiquidEngine    Function name, setAnotherWitch could be seAnotherLiquidEngine  7. Its better to use the same datatype in all places. I see there are too many castings. it could tough to track each of the casting to verify appropriate      data type during coding. There could be possibility of missing in some places.  8. For more decentralization: It could better if the governor related cautions is displayed in front end. For example, displaying the auctioner reward in front end.         
**Overview** Risk Rating | Number of issues --- | --- Low Risk | 2 Non-Critical Risk | 3  **Table of Contents**  - [1. Low Risk Issues](#1-low-risk-issues)   - [1.1. Missing address(0) checks](#11-missing-address0-checks)   - [1.2. Unsafe casting may overflow](#12-unsafe-casting-may-overflow) - [2. Non-Critical Issues](#2-non-critical-issues)   - [2.1. Typos](#21-typos)   - [2.2. Open TODOS](#22-open-todos)   - [2.3. Use a `constant` instead of duplicating the same string or replace the following revert strings with Errors](#23-use-a-constant-instead-of-duplicating-the-same-string-or-replace-the-following-revert-strings-with-errors)  # 1. Low Risk Issues  ## 1.1. Missing address(0) checks  Consider adding an `address(0)` check for immutable variables:  ```diff File: Witch.sol 59:     ICauldron public immutable cauldron; ... 71:     constructor(ICauldron cauldron_, ILadle ladle_) { + 72:     require(cauldron_ != address(0)); 72:         cauldron = cauldron_; 73:         ladle = ladle_; 74:     } ```  ## 1.2. Unsafe casting may overflow  SafeMath and Solidity 0.8.* handles overflows for basic math operations but not for casting. Even if the comment says "Overflow is fine", consider using OpenZeppelin's SafeCast library to prevent unexpected behaviors here:  ```solidity Witch.sol:217:        emit Auctioned(vaultId, uint32(block.timestamp)); Witch.sol:241:                start: uint32(block.timestamp), // Overflow is fine Witch.sol:582:            elapsed = uint32(block.timestamp) - uint256(auction_.start); // Overflow on block.timestamp is fine ```  ```solidity File: Witch.sol 302:         // Find out how much debt is being repaid 303:         uint128 artIn = uint128( 304:             cauldron.debtFromBase(auction_.seriesId, maxBaseIn) 305:         ); ```  # 2. Non-Critical Issues  ## 2.1. Typos  - specialised  ```solidity Witch.sol:213:    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties Witch.sol:267:    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties Witch.sol:462:    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties ```  - differente  ```solidity Witch.sol:385:    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people) ```  - quoutes  ```solidity Witch.sol:520:    /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount ```  ## 2.2. Open TODOS  Consider resolving the TODOs before deploying.  ```solidity Witch.sol:577:        // TODO: Replace this contract before then 😰 ```  ## 2.3. Use a `constant` instead of duplicating the same string or replace the following revert strings with Errors  ```solidity Witch.sol:255:        require(auction_.start > 0, "Vault not under auction"); Witch.sol:300:        require(auction_.start > 0, "Vault not under auction"); Witch.sol:358:        require(auction_.start > 0, "Vault not under auction"); Witch.sol:416:        require(auction_.start > 0, "Vault not under auction"); ```  ```solidity Witch.sol:365:        require(liquidatorCut >= minInkOut, "Not enough bought"); Witch.sol:313:        require(liquidatorCut >= minInkOut, "Not enough bought"); ```  ```solidity Witch.sol:328:            require(baseJoin != IJoin(address(0)), "Join not found"); Witch.sol:395:            require(ilkJoin != IJoin(address(0)), "Join not found"); ``` 
Gas saving:  Handling validation check Condition check could be  >=  in below line of code. This could save gas by skipping the calculation done in the else part.  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L586 When elapsed==duration, below calculation will always return 1e18 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L588-L592  memory can be used instead of storage in following lines of codes https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L254 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L231
## [L-01] MISSING ZERO-ADDRESS CHECK Addresses should be checked against `address(0)` to prevent unintended actions, unexpected loss of assets, etc. Please consider checking the following address inputs. ``` contracts\Witch.sol   83: function point(bytes32 param, address value) external auth {   141: function setAnotherWitch(address value, bool isWitch) external auth {   176: function auction(bytes12 vaultId, address to)   286-291:     function payBase(       bytes12 vaultId,       address to,       uint128 minInkOut,       uint128 maxBaseIn     )   344-349:     function payFYToken(       bytes12 vaultId,       address to,       uint128 minInkOut,       uint128 maxArtIn     )   528-532：     function calcPayout(       bytes12 vaultId,       address to,       uint256 maxArtIn     ) ```  ## [L-02] CONSTANTS CAN BE USED INSTEAD OF MAGIC NUMBERS To improve readability and maintainability, constants can be used instead of magic numbers. Please consider replacing the magic numbers in the following code with constants. ``` contracts\Witch.sol   102: require(initialOffer <= 1e18, "InitialOffer above 100%");   103: require(proportion <= 1e18, "Proportion above 100%");   105: initialOffer == 0 || initialOffer >= 0.01e18,   108: require(proportion >= 0.01e18, "Proportion below 1%");   162: if (auctioneerReward_ > 1e18) {   163: revert AuctioneerRewardTooHigh(1e18, auctioneerReward_);   587: proportionNow = 1e18;   591: uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration)); ```  ## [N-01] REDUNDANT CAST `initialProportion` does not need to be converted to uint256 because it is already stored as uint256 for the following code. ``` contracts\Witch.sol   573-591:     uint256 initialProportion = line_.initialOffer;     ...     proportionNow =       uint256(initialProportion) +       uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration)); ```  ## [N-02] REVERT REASON CAN BE MORE EXACT Because of the `initialOffer == 0` condition, `initialOffer` can be 0, which is below 1%. The revert reason can clarify that `initialOffer` can also be 0. ``` contracts\Witch.sol   104-107:     require(       initialOffer == 0 || initialOffer >= 0.01e18,       "InitialOffer below 1%"     ); ```  ## [N-03] REVERT REASON CAN BE MORE DESCRIPTIVE Instead of just mentioning "Unrecognized", the revert reason can describe what is unrecognized. ``` contracts\Witch.sol   83-84:     function point(bytes32 param, address value) external auth {       require(param == "ladle", "Unrecognized");  ```  ## [N-04] INCOMPLETE NATSPEC COMMENTS NatSpec provides rich documentation for code. @param and/or @return are missing for the following NatSpec comments: ``` contracts\Witch.sol   212-214:     /// @dev Moves the vault ownership to the witch.     /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties     function _auctionStarted(bytes12 vaultId) internal virtual {     220-229:     /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repayed     /// and what's the max ink that will be offered in exchange. For the realtime amount of ink that's on offer     /// use `_calcPayout`     function _calcAuction(       DataTypes.Vault memory vault,       DataTypes.Series memory series,       address to,       DataTypes.Balances memory balances,       DataTypes.Debt memory debt     ) internal view returns (DataTypes.Auction memory) {     266-268:     /// @dev Moves the vault ownership back to the original owner & clean internal state.     /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties     function _auctionEnded(bytes12 vaultId, address owner) internal virtual {      385-391:     /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people)     function _payInk(       DataTypes.Auction memory auction_,       address to,       uint256 liquidatorCut,       uint256 auctioneerCut     ) internal {     407-414:     /// @notice Update accounting on the Witch and on the Cauldron. Delete the auction and give back the vault if finished.     /// This function doesn't verify the vaultId matches the vault and auction passed. Check before calling.     function _updateAccounting(       bytes12 vaultId,       DataTypes.Auction memory auction_,       uint256 inkOut,       uint256 artIn     ) internal {    461-468:     /// @dev Logs that a certain amount of a vault was liquidated     /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties     function _collateralBought(       bytes12 vaultId,       address buyer,       uint256 ink,       uint256 art     ) internal virtual {     561-566:     /// @notice Return how much collateral should be given out.     function _calcPayout(       DataTypes.Auction memory auction_,       address to,       uint256 artIn     ) internal view returns (uint256 liquidatorCut, uint256 auctioneerCut) { ```  ## [N-05] @NOTICE PLACEMENT IN NATSPEC COMMENTS It is a convention to place @notice above @dev and @param in NatSpec comments, which is not the case in the following code: ``` contracts\Witch.sol   335-343:     /// @dev Pay up to `maxArtIn` debt from a vault in liquidation using fyToken, getting at least `minInkOut` collateral.     /// @notice If too much fyToken are offered, only the necessary amount are taken.     /// @param vaultId Id of vault to buy     /// @param to Receiver for the collateral bought     /// @param maxArtIn Maximum amount of fyToken that will be paid     /// @param minInkOut Minimum amount of collateral that must be received     /// @return liquidatorCut Amount paid to `to`.     /// @return auctioneerCut Amount paid to whomever started the auction. 0 if it's the same address that's calling this method     /// @return artIn Amount of fyToken taken ```
  #### Variable name  The name `value` could be related to `_address`. `value` may confuse others with fund or numeric type.  ```     /// @dev Governance function to set other liquidation contracts that may have taken vaults already.     /// @param value The address that may be set/unset as another witch     /// @param isWitch Is this address a witch or not     function setAnotherWitch(address value, bool isWitch) external auth {         otherWitches[value] = isWitch;         emit AnotherWitchSet(value, isWitch);     } ```   #### NATSPEC not complete   ```     /// @notice Return how much collateral should be given out.     function _calcPayout(         DataTypes.Auction memory auction_,         address to,         uint256 artIn     ) internal view returns (uint256 liquidatorCut, uint256 auctioneerCut) { ```  suggestion: Follow NATSPEC.     #### MAGICAL NUMBER CAN BE DOCUMENTED AND EXPLAINED  `1e18` is used several times through the code. This may both obscure the purpose of the function and unnecessarily lead to potential error if the constants are changed during development.  ``` 102-108:         require(initialOffer <= 1e18, "InitialOffer above 100%");         require(proportion <= 1e18, "Proportion above 100%");         require(             initialOffer == 0 || initialOffer >= 0.01e18,             "InitialOffer below 1%"         );  162-164:         if (auctioneerReward_ > 1e18) {             revert AuctioneerRewardTooHigh(1e18, auctioneerReward_);         }  587:         proportionNow = 1e18;  591:         uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration)); ```  Suggestion: Use constants as this would make the code more maintainable and readable while costing nothing gas-wise.      #### Arithmic operation order  The division is performed first, and multiplication later.  ``` 594:        uint256 inkAtEnd = uint256(artIn).wdiv(auction_.art).wmul(auction_.ink); ```  It might be arithmically safer to do the multiplication first instead.   
# Yield-Witch-v2-code4rena Report  - [Yield-Witch-v2-code4rena Report](#yield-witch-v2-code4rena-report)   - [QA Report](#qa-report)   - [Files Description Table](#files-description-table)   - [Issues found](#issues-found)     - [[N-01]: Typos](#n-01-typos)       - [Impact](#impact)       - [Code Affected and Mitigation](#code-affected-and-mitigation)       - [Tools used](#tools-used)  ##  QA Report  ##  Files Description Table | File Name                         | SHA-1 Hash                               | | --------------------------------- | ---------------------------------------- | | 2022-07-yield/contracts/Witch.sol | 07190e9e6d7769e20bcc07030eee3802ee199a5f |  ## Issues found  ### [N-01]: Typos  #### Impact None.  #### Code Affected and Mitigation  ```diff diff --git a/contracts/Witch.sol b/contracts/Witch.sol index f98dd6a..92ca566 100644 --- a/contracts/Witch.sol +++ b/contracts/Witch.sol @@ -217,7 +217,7 @@ contract Witch is AccessControl {          emit Auctioned(vaultId, uint32(block.timestamp));      }   -    /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repayed +    /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repaid      /// and what's the max ink that will be offered in exchange. For the realtime amount of ink that's on offer      /// use `_calcPayout`      function _calcAuction( @@ -264,7 +264,7 @@ contract Witch is AccessControl {      }        /// @dev Moves the vault ownership back to the original owner & clean internal state. -    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties +    /// Useful as a method so it can be overridden by specialised witches that may need to do extra accounting or notify 3rd parties      function _auctionEnded(bytes12 vaultId, address owner) internal virtual {          cauldron.give(vaultId, owner);          delete auctions[vaultId]; @@ -382,7 +382,7 @@ contract Witch is AccessControl {          _collateralBought(vaultId, to, liquidatorCut + auctioneerCut, artIn);      }   -    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people) +    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're different people)      function _payInk(          DataTypes.Auction memory auction_,          address to, @@ -459,7 +459,7 @@ contract Witch is AccessControl {      }        /// @dev Logs that a certain amount of a vault was liquidated -    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties +    /// Useful as a method so it can be overridden by specialised witches that may need to do extra accounting or notify 3rd parties      function _collateralBought(          bytes12 vaultId,          address buyer, @@ -517,7 +517,7 @@ contract Witch is AccessControl {          */ -    /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount +    /// @dev Quotes how much ink a liquidator is expected to get if it repays an `artIn` amount      /// Works for both Auctioned and ToBeAuctioned vaults      /// @param vaultId The vault to get a quote for      /// @param to Address that would get the collateral bought  ```  #### Tools used VS Code 
**Missing Non-zero address check in `payBase()` can result in lost funds for liquidator**  **Proof of concept:** If a liquidator mistakenly passes the zero address as the `to` argument of the `payBase()` function, then the collateral will be sent to the zero address.   **Recommended Mitigation Steps:** Add a non-zero address check for the `to` parameter in `payBase()`      **Misleading comment in `_updateAccounting()`**  **Proof of concept:** In `_updateAccounting()` there is the following piece of code:  ```jsx // Update concurrent collateral under auction  DataTypes.Limits memory limits_ = limits[auction_.ilkId][     auction_.baseId  ]; ```  The comment says the following code will “update” something, but it is just a memory copied variable.  **Recommended Mitigation Steps:** Remove the misleading comment
#1 Immutable  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L60  add immutable on ladle state because  ladle state  must be initialize through constructor  #3 Code and comment not match  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L392          // If liquidatorCut is 0, then auctioneerCut is 0 too, so no need to double check         if (liquidatorCut > 0) {             IJoin ilkJoin = ladle.joins(auction_.ilkId);             require(ilkJoin != IJoin(address(0)), "Join not found");               // Pay auctioneer's cut if necessary             if (auctioneerCut > 0) {                 ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128());             } because liquidator is 0, and then auctioneerCut is 0 too. so           if (liquidatorCut > 0) { ----->  if (liquidatorCut => 0) { and          if (auctioneerCut > 0) { -----> if (auctioneerCut => 0)  {     #3 Typo  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L520      /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount  change hoy to how  #4 unused natspec comment  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L567-L568  remove the natspec comment if unused. it decrase readibility  #5 Missing param comment vaultid  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L213  add natspec comment param vaultid  #6 Missing param comment  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L220  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L407  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L461  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L562  function have natspec comment which is missing. Add natspec comments include all parameter in the function. 
## Summary   ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | [L&#x2011;01] | `setLine()` parameters inconsistently followed | 1 | | [L&#x2011;02] | Events will contain the wrong timestamp in the future | 1 | | [L&#x2011;03] | Integer overflow due to casting will cause contract accounting to break | 1 |  Total: 3 instances over 3 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | [N&#x2011;01] | Incomplete documentation | 1 | | [N&#x2011;02] | Timestamps in events are redundant | 1 | | [N&#x2011;03] | `constant`s should be defined rather than using magic numbers | 8 | | [N&#x2011;04] | Redundant cast | 2 | | [N&#x2011;05] | Typos | 6 | | [N&#x2011;06] | NatSpec is incomplete | 1 | | [N&#x2011;07] | Event is missing `indexed` fields | 6 | | [N&#x2011;08] | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 2 |  Total: 27 instances over 8 issues   ## Low Risk Issues  ### [L&#x2011;01]  `setLine()` parameters inconsistently followed In `setLine()` there's a [require()](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L104-L107) that ensures that the initial offer is either equal to zero, or greater than 1%. It stands to reason that therefore, offers less than 1% are considered dust and are not actionable. If this is the case, then in the `else`-block on line 589, does not follow this same dust-skipping logic when `initialProportion` is set to zero, and will waste time offering proportions that nobody will take. This may lead to auctions taking longer than necessary, and more funds being lost. It is incorrect state handling and therefore of Low risk. If there was some other meaning behind the conditions, there should be a `require()` enforcing it  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  584          if (duration == type(uint32).max) {     // Interpreted as infinite duration 585              proportionNow = initialProportion; 586          } else if (elapsed > duration) { 587              proportionNow = 1e18; 588          } else { 589              proportionNow = 590                  uint256(initialProportion) + 591                  uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration)); 592:         }  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L584-L592  ### [L&#x2011;02]  Events will contain the wrong timestamp in the future While the timestamp field in the event might not affect on-chain processing, it _will_ impact off-chain tools that have to parse it. This is incorrect state handling and therefore of Low risk  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  217:         emit Auctioned(vaultId, uint32(block.timestamp));  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L217  ### [L&#x2011;03]  Integer overflow due to casting will cause contract accounting to break When `block.timestamp` becomes larger than `type(uint32).max`, the cast on line 582 will overflow, causing the elapsed time calculation to be extremely large and wrong if the auction start time was before the wrap. This will cause the proportion to be greater than 100%, and will allow a liquidator to earn a massive fee. Comments in code are not sufficient to prevent client fund loss, and relying on Google calendar is obviously not either. This should be a Medium, but I'm guessing the sponsor will argue that it's already documented here in the code (though it needs to be in the `README.md` and in Yield's risks documentation), so it's not worth while to write up the whole thing just to have it downgraded by a judge that decides not to follow that rule.  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  575          // If the world has not turned to ashes and darkness, auctions will malfunction on 576          // the 7th of February 2106, at 06:28:16 GMT 577          // TODO: Replace this contract before then 😰 578          // UPDATE: Added reminder to Google calendar ✅ 579          uint256 elapsed; 580          uint256 proportionNow; 581          unchecked { 582              elapsed = uint32(block.timestamp) - uint256(auction_.start); // Overflow on block.timestamp is fine 583:         }  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L575-L583  ## Non-critical Issues  ### [N&#x2011;01]  Incomplete documentation The infinite duration comment should be in NatSpec, not a normal comment hidden in the code  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  584:         if (duration == type(uint32).max) {     // Interpreted as infinite duration  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L584  ### [N&#x2011;02]  Timestamps in events are redundant `block.timestamp` and `block.number` are added to event information by default so adding them manually wastes gas and is redundant  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  217:         emit Auctioned(vaultId, uint32(block.timestamp));  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L217  ### [N&#x2011;03]  `constant`s should be defined rather than using magic numbers Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals  *There are 8 instances of this issue:* ```solidity File: contracts/Witch.sol  /// @audit 1e18 102:          require(initialOffer <= 1e18, "InitialOffer above 100%");  /// @audit 1e18 103:          require(proportion <= 1e18, "Proportion above 100%");  /// @audit 0.01e18 105:              initialOffer == 0 || initialOffer >= 0.01e18,  /// @audit 0.01e18 108:          require(proportion >= 0.01e18, "Proportion below 1%");  /// @audit 1e18 162:          if (auctioneerReward_ > 1e18) {  /// @audit 1e18 163:              revert AuctioneerRewardTooHigh(1e18, auctioneerReward_);  /// @audit 1e18 587:              proportionNow = 1e18;  /// @audit 1e18 591:                  uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration));  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L102  ### [N&#x2011;04]  Redundant cast The type of the variable is the same as the type to which the variable is being cast  *There are 2 instances of this issue:* ```solidity File: contracts/Witch.sol  /// @audit uint256(initialProportion) 590:                  uint256(initialProportion) +  /// @audit uint256(artIn) 594:          uint256 inkAtEnd = uint256(artIn).wdiv(auction_.art).wmul(auction_.ink);  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L590  ### [N&#x2011;05]  Typos  *There are 6 instances of this issue:* ```solidity File: contracts/Witch.sol  /// @audit overriden 213:      /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties  /// @audit repayed 220:      /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repayed  /// @audit overriden 267:      /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties  /// @audit differente 385:      /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people)  /// @audit overriden 462:      /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties  /// @audit quoutes 520:      /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L213  ### [N&#x2011;06]  NatSpec is incomplete  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  /// @audit Missing: '@return' 174       /// @param vaultId Id of vault to liquidate 175       /// @param to Receiver of the auctioneer reward 176       function auction(bytes12 vaultId, address to) 177           external 178:          returns (DataTypes.Auction memory auction_)  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L174-L178  ### [N&#x2011;07]  Event is missing `indexed` fields Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (threefields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question  *There are 6 instances of this issue:* ```solidity File: contracts/Witch.sol  33        event Bought( 34            bytes12 indexed vaultId, 35            address indexed buyer, 36            uint256 ink, 37            uint256 art 38:       );  43        event LineSet( 44            bytes6 indexed ilkId, 45            bytes6 indexed baseId, 46            uint32 duration, 47            uint64 proportion, 48            uint64 initialOffer 49:       );  50:       event LimitSet(bytes6 indexed ilkId, bytes6 indexed baseId, uint128 max);  51:       event AnotherWitchSet(address indexed value, bool isWitch);  52        event IgnoredPairSet( 53            bytes6 indexed ilkId, 54            bytes6 indexed baseId, 55            bool ignore 56:       );  57:       event AuctioneerRewardSet(uint128 auctioneerReward);  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L33-L38  ### [N&#x2011;08]  Duplicated `require()`/`revert()` checks should be refactored to a modifier or function The compiler will inline the function, which will avoid `JUMP` instructions usually associated with functions  *There are 2 instances of this issue:* ```solidity File: contracts/Witch.sol  300:          require(auction_.start > 0, "Vault not under auction");  365:          require(liquidatorCut >= minInkOut, "Not enough bought");  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L300   
## Mixed Use of Custom Errors and `require(condition, "msg"` **Severity**: Informational **Context**: [`Witch.sol`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol)  **Description**: It's better to stick to one or the other to stay consistent.  **Recommendation**: I would recommend the use of just custom errors to save gas on deployment.   ## `otherWitches` Possible Name Suggestion **Severity**: Informational **Context**: [`Witch.sol#L68`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L68)  **Description**: "The name is a bit misleading, as any address can be entered. Better naming suggestions are welcome."  **Recommendation**: Maybe `Witched`, `VaultTaken`, `bewitched` or `hexed`   ## Contract Code Size Exceeds Bytes Limit **Severity**: Informational **Context**: [`Witch.sol`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol)  **Description**: Contract code size is 28515 bytes and exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on mainnet.   **Recommendation**: Consider enabling the optimizer (with a low "runs" value!), turning off revert strings, or using libraries.   ## TODOs Left In The Code **Severity**: Informational **Context**: [`Witch.sol#L577`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L577)  **Description**: There should never be any TODOs in the code when deploying.  **Recommendation**: Add this TODO to the docs instead.   ## Spelling Errors **Severity**: Informational **Context**: [`Witch.sol#L213 (overriden => overridden)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L213), [`Witch.sol#L220 (repayed => repaid)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L220), [`Witch.sol#L267 (overriden => overridden)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L267), [`Witch.sol#L267 (differente => different)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L267), [`Witch.sol#L462 (overriden => overridden)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L462), [`Witch.sol#L512 (Delete the extra space)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L512), [`Witch.sol#L520 (quoutes => quotes)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L520), [`Witch.sol#L520 (hoy => how)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L520)  **Description**: Spelling errors in comments can cause confusion to both users and developers.  **Recommendation**: Check all misspellings to ensure they are corrected.   ## Missing or Incomplete NatSpec **Severity**: Informational **Context**: [`Witch.sol`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol)  **Description**: Some functions are missing @notice/@dev NatSpec comments for the function, @param for all/some of their parameters and @return for return values. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability and usability.  **Recommendation**: Add in full NatSpec comments for all functions to have complete code documentation for future use.
## 1 zero address check missing  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L71 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L176 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L288 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L346  ## 2. variable name `otherWitches` can be change to `witches` only ( as sponsor wants name suggestions )  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L68 
# Codebase Impressions & Summary  ### Functionality  The revised witch (liquidation engine) contract includes the following improvements over the previous version. As stated in the README, they are:  1. Greater flexibility in exploring different liquidation models. 2. Making liquidations more profitable for liquidators by allowing payments in `fyToken`. 3. Introduce a mechanism to reward starting an auction. 4. Allow fine-tuning of all parameters for any collateral/underlying pair. 5. Correct bugs.  The liquidations flow was quite easy to follow as it consists of the following:  1. Liquidation parameters are defined by governance functions (auction duration, vault proportion, auctioneer reward etc.) 2. Starting an auction: `auction()` 3. Liquidators executing the liquidations: `payBase()` and `payFYToken()` 4. Either the entire vault collateral has been auctioned off, or `cancel()` is called to prematurely end the auction  ### Documentation  The README was very extensive and thorough, and succinctly explained design considerations made. Flow diagrams were provided to help visualise the interactions required between different contracts. Inline comments were appropriate too, aided in understanding the functionality.  ### Tests  All foundry tests passed as expected. One area of improvement is to have mainnet forking tests, since mocking is used for the external contracts. Running `forge coverage` unfortunately didn’t work. I suspect it is due to the instability of the feature rather than the fault of the tests.   ### Gas Optimizations  Casting could be avoided if input / output params were defined appropriately. For instance, `inkOut`, `artIn` in `_updateAccounting()`, and `liquidatorCut` and `auctioneerCut` could have been `uint128` instead of `uint256`.  # Low Severity Findings  ## L01: Vaults that are over-collateralised after partial liquidation are possibly subject to further liquidations  ### Description  If a vault becomes over-collateralised after a partial liquidation, it is still subject to further liquidation as the auction isn’t closed. The vault owner has to call `cancel()` himself, or trust other altruistic actors to perform this action on his behalf. Liquidators will unlikely do it because they are economically incentivised not to do so.  One can however argue that this is mitigated by the fact that protocol (governance) sets the vault proportion that can be auctioned. Regardless of whether the fact that the vault is over-collateralised after partial liquidations, the liquidators arguably are given the right to carry out further liquidations up to the proportion set.  Nevertheless, a reason for a revised liquidations witch contract is that “More often than not, liquidated users have lost all their collateral as we have failed to make liquidations competitive.”. Hence, it might make sense to ensure that users need not lose more collateral than necessary.  ### Recommended Mitigation Steps  Consider checking if the vault is over-collateralized (maybe in `_updateAccounting()`) and close the auction if it is. This however adds complexity to the liquidation logic, as you have to update the cauldron first `cauldron.slurp()` before checking and updating the collateralization status. It will also break the CEI pattern, which might be unfavourable.  ## L02: Comparison in `_calcPayout()` should include equality  ### Line References  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L586](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L586)  ### TLDR  ```diff - else if (elapsed > duration) + else if (elapsed >= duration) ```  ### Description  In the case where `elapsed == duration`, `proportionNow` evaluates to `1e18`, which is the same result when `elapsed > duration`. Proof below.  ```solidity proportionNow =   uint256(initialProportion) +   uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration));  // = initialProportion + (1e18 - initialProportion).wmul(1e18) // = initialProportion + (1e18 - initialProportion) * 1e18 / 1e18 // = initialProportion + 1e18 - initialProportion // = 1e18 ```  Of slightly greater importance, this handles the edge case when `elapsed = duration = 0`, ie. the liquidation transaction is included in the same block / has the same timestamp as the auction initialization transaction  ### Recommended Mitigation Steps  As per the TLDR.  ### P.S. Regarding zero duration auctions  Since the proportion given for zero duration auctions is `1e18`, it is equivalent to an auction of infinite duration with 100% initial offer: `duration == type(uint32).max` and `line_.initialOffer = 1e18`.  ## L03: Incorrect description for `auctioneerCut`  ### Line References  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L284](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L284)  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L342](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L342)  ### Description  Technically, the `auctioneerCut` goes to the `to` address specified by the auctioneer when `auction()` is called, which, while unlikely, may not be the auctioneer himself. Also, the comparison is done against the `to` address specified, not the caller / `msg.sender` as the comment implies.  ### Recommended Mitigation Steps  ```diff - Amount paid to whomever started the auction. 0 if it's the same address that's calling this method + Amount paid to address specified by whomever started the auction. 0 if it's the same as the `to` address ```  ## L04: Incorrect natspec for `setLimit()`  ### Line References  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L118-L122](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L118-L122)  ### Description  The comments seem outdated as the only parameter that is updated by the function is the maximum collateral that can be concurrently auctioned off.  ```solidity ///  - the auction duration to calculate liquidation prices ///  - the proportion of the collateral that will be sold at auction start ///  - the maximum collateral that can be auctioned at the same time ///  - the minimum collateral that must be left when buying, unless buying all ///  - The decimals for maximum and minimum ```  ### Recommended Mitigation Steps  Suggest removing / updating the referenced comments.  # Non-Critical Findings  ## NC01: Modify comment to soft limit check for clarity  ### Line References  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L194-L196](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L194-L196)  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L200](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L200)  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L204](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L204)   ### Description  The limit check is done before the summation to the total collateral allowable for liquidation. One may consider this to be a bug, but the README explains why this is the case:  ```markdown Note that the first auction to reach the limit is allowed to pass it, so that there is never the situation where a vault would be too big to ever be auctioned. ```  The inline comments have this as well, but isn’t as clearly put as the README.  ```solidity // There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit. // If the limit has been surpassed, no more vaults of that collateral can be put for auction. // This avoids the scenario where some vaults might be too large to be auctioned. ```  ### Recommended Mitigation Steps  For greater clarity, I would suggesting modifying the inline comment to be worded similar as the README.  ```diff // There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit. - // If the limit has been surpassed, no more vaults of that collateral can be put for auction. + // The first auction to reach or exceed the limit is allowed to pass it, but subsequently, no more vaults of that collateral can be put for auction. // This avoids the scenario where some vaults might be too large to be auctioned. ```  ## NC02: Typos  ```diff - bellow + below  - differente + different  // Extra spacing - The Join  then dishes out + The Join then dishes out  - quoutes hoy much ink + quotes how much ink ```
## typo in comments:  overriden --> overridden  - [Witch.sol#L213](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L213) - [Witch.sol#L267](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L267) - [Witch.sol#L462](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L462)   repayed --> repaid  - [Witch.sol#L220](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L220)  differente --> different  - [Witch.sol#L385](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L385)  quoutes --> quotes  - [Witch.sol#L520](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L520)  hoy --> how   - [Witch.sol#L520](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L520)  
### Low Risk Findings Overview |        | Finding                    |  Instances  | |:-------|:---------------------------|:-----------:| | [L-01] | Missing `address(0)` check |      3      | ### Non-critical Findings Overview |        | Finding                                     |  Instances  | |:-------|:--------------------------------------------|:-----------:| | [N-01] | The use of magic numbers is not recommended |      5      | | [N-02] | Typo                                        |      2      | | [N-03] | Remove TODO’s                               |      1      | ### QA overview per contract | Contract                                                                                                                   |  Total Instances  |  Total Findings  |  Low Findings  |  Low Instances  |  NC Findings  |  NC Instances  | |:---------------------------------------------------------------------------------------------------------------------------|:-----------------:|:----------------:|:--------------:|:---------------:|:-------------:|:--------------:| | [Witch.sol](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol) |        10         |        4         |       1        |        3        |       3       |       7        | | [Witch.sol](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol)                                     |         1         |        1         |       0        |        0        |       1       |       1        | ## Low Risk Findings ### [L-01] Missing `address(0)` check Funds might be lost by accident if check is not implemented. ***3 instances of this issue have been found:*** ###### [L-01] [Witch.sol#L286-L301](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L286-L301) ```solidity      function payBase(         bytes12 vaultId,         address to,         uint128 minInkOut,         uint128 maxBaseIn     )         external         returns (             uint256 liquidatorCut,             uint256 auctioneerCut,             uint256 baseIn         )     {         DataTypes.Auction memory auction_ = auctions[vaultId];         require(auction_.start > 0, "Vault not under auction");  ``` ###### [L-01b] [Witch.sol#L176-L177](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L176-L177) ```solidity      function auction(bytes12 vaultId, address to)  ``` ###### [L-01c] [Witch.sol#L344-L359](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L344-L359) ```solidity      function payFYToken(         bytes12 vaultId,         address to,         uint128 minInkOut,         uint128 maxArtIn     )         external         returns (             uint256 liquidatorCut,             uint256 auctioneerCut,             uint256 artIn         )     {         DataTypes.Auction memory auction_ = auctions[vaultId];         require(auction_.start > 0, "Vault not under auction");  ```  ## Non-critical Findings ### [N-01] The use of magic numbers is not recommended Consider setting constant numbers as a `constant` variable for better readability and clarity. ***5 instances of this issue have been found:*** ###### [N-01] [Witch.sol#L587-L588](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L587-L588) ```solidity              proportionNow = 1e18;  ``` ###### [N-01b] [Witch.sol#L105-L106](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L105-L106) ```solidity              initialOffer == 0 || initialOffer >= 0.01e18,  ``` ###### [N-01c] [Witch.sol#L108-L109](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L108-L109) ```solidity          require(proportion >= 0.01e18, "Proportion below 1%");  ``` ###### [N-01d] [Witch.sol#L162-L163](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L162-L163) ```solidity          if (auctioneerReward_ > 1e18) {  ``` ###### [N-01e] [Witch.sol#L591-L592](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L591-L592) ```solidity                  uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration));  ``` ### [N-02] Typo Please fix typos. ***2 instances of this issue have been found:*** ###### [N-02] [Witch.sol#L81](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L81) ```solidity  /// @param param Name of parameter to set (must be "ladle") ``` ###### [N-02b] [Witch.sol#L14](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L14) ```solidity  uncollateralized -> undercollateralized ``` ### [N-03] Remove TODO’s They add unnecessary cluttler and harm readbility for auditors. ***1 instance of this issue has been found:*** ###### [N-03] [Witch.sol#L577-L578](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L577-L578) ```solidity          // TODO: Replace this contract before then 😰 -> This is funny though  ``` 
