# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L306-L329   # Vulnerability details  In `Collateral`, the getter functions `getAmountForShares()` and `getSharesForAmount()` is using `totalAssets()` instead of `_strategyController.totalValue()`, making the results can be different than the actual shares amount needed to `withdraw()` a certain amount of `_baseToken` and the amount of shares expected to get by `deposit()` a certain amount.  Specifically, `totalAssets()` includes the extra amount of `_baseToken.balanceOf(Collateral)`.  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L306-L329  ```solidity function getAmountForShares(uint256 _shares)     external     view     override     returns (uint256) {     if (totalSupply() == 0) {         return _shares;     }     return (_shares * totalAssets()) / totalSupply(); }  function getSharesForAmount(uint256 _amount)     external     view     override     returns (uint256) {     uint256 _totalAssets = totalAssets();     return         (_totalAssets > 0)             ? ((_amount * totalSupply()) / _totalAssets)             : 0; } ```  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L339-L343  ```solidity function totalAssets() public view override returns (uint256) {     return         _baseToken.balanceOf(address(this)) +         _strategyController.totalValue(); } ```  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L137-L148  ```solidity function withdraw(uint256 _amount)     external     override     nonReentrant     returns (uint256) {     require(_withdrawalsAllowed, "Withdrawals not allowed");     if (_delayedWithdrawalExpiry != 0) {         _processDelayedWithdrawal(msg.sender, _amount);     }     uint256 _owed = (_strategyController.totalValue() * _amount) /         totalSupply();     ... ```  ### PoC  Given:  - `_baseToken.balanceOf(Collateral)` == 90 - `_strategyController.totalValue()` == 110 - totalSupply of shares = 100  `totalAssets()` returns: 200  `getSharesForAmount(100)` returns: 50, while `withdraw(50)` will actual only get: 55.  When `Collateral` is used by another contract that manages many users' funds, and if it's using `getSharesForAmount()` to calculate the amount of shares needed for a certain amount of underlying tokens to be withdrawn.  This issue can potentially cause fund loss to the user of that contract because it will actually send a lesser amount of `_baseToken` than expected.  ### Recommendation  Consider changing `Collateral.totalValue()` to:   ```solidity function totalAssets() public view override returns (uint256) {     return         _strategyController.totalValue(); } ```  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72 https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/interfaces/IStrategy.sol#L52   # Vulnerability details  ## Impact When migrating from one strategy to another, the controller pulls out the funds of the old strategy and deposits them into the new one. But, it doesn't verify that both strategies use the same base token. If the new one uses a different base token, it won't "know" about the tokens it received on migration. It won't be able to deposit and transfer them. Effectively they would be lost.  The migration is done by the owner. So the owner must make a mistake and migrate to the wrong strategy by accident. In a basic protocol with 1 controller and a single active strategy managing that should be straightforward. There shouldn't be a real risk of that mistake happening. But, if you have multiple controllers running at the same time each with a different base token, it gets increasingly likelier.   According to the `IStrategy` interface, there is a function to retrieve the strategy's base token: `getBaseToken()`. I'd recommend adding a check in the `migrate()` function to verify that the new strategy uses the correct base token to prevent this issue from being possible.  ## Proof of Concept https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/interfaces/IStrategy.sol#L52  ## Tools Used none  ## Recommended Mitigation Steps Add  `require(_baseToken == _newStrategy.getBaseToken());` to the beginning of `migrate()`  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L328   # Vulnerability details  ## Impact The [`getSharesForAmount`](https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L328) function returns `0` if `totalAssets == 0`.  However, if **`totalSupply == 0`**, the actual shares that are minted in a [`deposit` are `_amount`](https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L83) even if `totalAssets == 0`.  Contracts / frontends that use this function to estimate their deposit when `totalSupply == 0` will return a wrong value.  ## Recommended Mitigation Steps  ```diff function getSharesForAmount(uint256 _amount)     external     view     override     returns (uint256) { +   // to match the code in `deposit` +   if (totalSupply() == 0) return _amount;      uint256 _totalAssets = totalAssets();     return         (_totalAssets > 0)             ? ((_amount * totalSupply()) / _totalAssets)             : 0; // @audit this should be _amount according to `deposit` } ```  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L97   # Vulnerability details  ## Impact After initiating a withdrawal with `initiateWithdrawal`, it's still possible to transfer the collateral tokens. This can be used to create a second account, transfer the accounts to them and initiate withdrawals at a different time frame such that one of the accounts is always in a valid withdrawal window, no matter what time it is. If the token owner now wants to withdraw they just transfer the funds to the account that is currently in a valid withdrawal window.  Also, note that each account can withdraw the specified `amount`. Creating several accounts and circling & initiating withdrawals with all of them allows withdrawing larger amounts **even at the same block** as they are purchased in the future.  I consider this high severity because it breaks core functionality of the Collateral token.  #### POC For example, assume the `_delayedWithdrawalExpiry = 20` blocks. Account A owns 1000 collateral tokens, they create a second account B. - At `block=0`, A calls `initiateWithdrawal(1000)`. They send their balance to account B. - At `block=10`, B calls `initiateWithdrawal(1000)`. They send their balance to account A. - They repeat these steps, alternating the withdrawal initiation every 10 blocks. - One of the accounts is always in a valid withdrawal window (`initiationBlock < block && block <= initiationBlock + 20`). They can withdraw their funds at any time.  ## Recommended Mitigation Steps If there's a withdrawal request for the token owner (`_accountToWithdrawalRequest[owner].blockNumber > 0`), disable their transfers for the time.  ```solidity // pseudo-code not tested beforeTransfer(from, to, amount) {   super();   uint256 withdrawalStart =  _accountToWithdrawalRequest[from].blockNumber;   if(withdrawalStart > 0 && withdrawalStart + _delayedWithdrawalExpiry < block.number) {     revert(); // still in withdrawal window   } } ```  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/Collateral.sol#L82-L91   # Vulnerability details  ## Details  The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.  ## Proof of Concept  - Attacker deposits 2 wei (so that it is greater than min fee) to mint 1 share - Attacker transfers exorbitant amount to `_strategyController` to greatly inflate the share’s price. Note that the `_strategyController` deposits its entire balance to the strategy when its `deposit()` function is called. - Subsequent depositors instead have to deposit an equivalent sum to avoid minting 0 shares. Otherwise, their deposits accrue to the attacker who holds the only share.  ```jsx it("will cause 0 share issuance", async () => {  // 1. first user deposits 2 wei because 1 wei will be deducted for fee  let firstDepositAmount = ethers.BigNumber.from(2)  await transferAndApproveForDeposit(      user,      collateral.address,      firstDepositAmount  )    await collateral      .connect(user)      .deposit(firstDepositAmount)    // 2. do huge transfer of 1M to strategy to controller  // to greatly inflate share price  await baseToken.transfer(strategyController.address, ethers.utils.parseEther("1000000"));    // 3. deployer tries to deposit reasonable amount of 10_000  let subsequentDepositAmount = ethers.utils.parseEther("10000");  await transferAndApproveForDeposit(      deployer,      collateral.address,      subsequentDepositAmount  )   await collateral      .connect(deployer)      .deposit(subsequentDepositAmount)    // receives 0 shares in return  expect(await collateral.balanceOf(deployer.address)).to.be.eq(0) }); ```  ## Recommended Mitigation Steps  - [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. - Ensure the number of shares to be minted is non-zero: `require(_shares != 0, "zero shares minted");` - Create a periphery contract that contains a wrapper function that atomically calls `initialize()` and `deposit()` - Call `deposit()` once in `initialize()` to achieve the same effect as the suggestion above.  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72   # Vulnerability details  ## Impact  If a strategy does not have sufficient funds to `withdraw()` for the full amount then it is possible that tokens will be left in this yield contract during `migrate()`.  It is common for withdrawal from a strategy to withdraw less than a user's balance. The reason is that these yield protocols may lend the deposited funds to borrowers, if there is less funds in the pool than the withdrawal amount the withdrawal may succeed but only transfer the funds available rather than the full withdrawal amount.  The impact of tokens remaining in the old strategy is that when we call `StrategyController.totalValue()` this will only account for the tokens deposited in the new strategy and not those stuck in the previous strategy. Therefore `totalValue()` is undervalued.   Thus, when a user calls `Collateral.deposit()` the share calculations `_shares = (_amountToDeposit * totalSupply()) / (_valueBefore);` will be over stated (note: `uint256 _valueBefore = _strategyController.totalValue();`). Hence, the user will receive more shares than they should.  The old tokens may be recovered by calling `migrate()` back to the old strategy. If this is done then `totalValue()` will now include the tokens previously stuck. The recent depositer may now withdraw and will be owed `(_strategyController.totalValue() * _amount) / totalSupply()`. Since `totalValue()` is now includes the previously stuck tokens  `_owed` will be overstated and the user will receive more collateral than they should.  The remaining users who had deposited before `migrate()` will lose tokens proportional to their share of the `totalSupply()`.  ## Proof of Concept  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72 ```     function migrate(IStrategy _newStrategy)         external         override         onlyOwner         nonReentrant     {         uint256 _oldStrategyBalance;         IStrategy _oldStrategy = _strategy;         _strategy = _newStrategy;         _baseToken.approve(address(_newStrategy), type(uint256).max);         if (address(_oldStrategy) != address(0)) {             _baseToken.approve(address(_oldStrategy), 0);             _oldStrategyBalance = _oldStrategy.totalValue();             _oldStrategy.withdraw(address(this), _oldStrategyBalance);             _newStrategy.deposit(_baseToken.balanceOf(address(this)));         }         emit StrategyMigrated(             address(_oldStrategy),             address(_newStrategy),             _oldStrategyBalance         );     } ```  ## Recommended Mitigation Steps  The recommendation is to ensure that `require(_oldStrategy.totalValue() == 0)` after calling `_oldStrategy.withdraw()`. This ensures that no funds are left in the strategy. Consider the code example below.  ```     function migrate(IStrategy _newStrategy)         external         override         onlyOwner         nonReentrant     {         uint256 _oldStrategyBalance;         IStrategy _oldStrategy = _strategy;         _strategy = _newStrategy;         _baseToken.approve(address(_newStrategy), type(uint256).max);         if (address(_oldStrategy) != address(0)) {             _baseToken.approve(address(_oldStrategy), 0);             _oldStrategyBalance = _oldStrategy.totalValue();             _oldStrategy.withdraw(address(this), _oldStrategyBalance);             require(_oldStrategy.totalValue() == 0)             _newStrategy.deposit(_baseToken.balanceOf(address(this)));         }         emit StrategyMigrated(             address(_oldStrategy),             address(_newStrategy),             _oldStrategyBalance         );     } ```  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/PrePOMarketFactory.sol#L42   # Vulnerability details  ## Impacted Function: createMarket  ## Description:  1. Owner calls createMarket with  _tokenNameSuffix S1 and _tokenSymbolSuffix S2 which creates a new market M1 with _deployedMarkets[_salt] pointing to M1. Here salt can be S which is computed using  _tokenNameSuffix and _tokenSymbolSuffix 2. This market is now being used 3. After some time owner again mistakenly calls createMarket with  _tokenNameSuffix S1 and _tokenSymbolSuffix S2  4. Instead of returning error mentioning that this name and symbol already exists, new market gets created. The problem here is that salt which is computed using _tokenNameSuffix and _tokenSymbolSuffix will again come as S (as in step 1) which means _deployedMarkets[_salt] will now get updated to M2. This means reference to M1 is gone  ## Recommendation: Add below check:  ``` require(_deployedMarkets[_salt]==address(0), "Market already exists"); ```  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L306-L329   # Vulnerability details  In `Collateral`, the getter functions `getAmountForShares()` and `getSharesForAmount()` is using `totalAssets()` instead of `_strategyController.totalValue()`, making the results can be different than the actual shares amount needed to `withdraw()` a certain amount of `_baseToken` and the amount of shares expected to get by `deposit()` a certain amount.  Specifically, `totalAssets()` includes the extra amount of `_baseToken.balanceOf(Collateral)`.  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L306-L329  ```solidity function getAmountForShares(uint256 _shares)     external     view     override     returns (uint256) {     if (totalSupply() == 0) {         return _shares;     }     return (_shares * totalAssets()) / totalSupply(); }  function getSharesForAmount(uint256 _amount)     external     view     override     returns (uint256) {     uint256 _totalAssets = totalAssets();     return         (_totalAssets > 0)             ? ((_amount * totalSupply()) / _totalAssets)             : 0; } ```  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L339-L343  ```solidity function totalAssets() public view override returns (uint256) {     return         _baseToken.balanceOf(address(this)) +         _strategyController.totalValue(); } ```  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L137-L148  ```solidity function withdraw(uint256 _amount)     external     override     nonReentrant     returns (uint256) {     require(_withdrawalsAllowed, "Withdrawals not allowed");     if (_delayedWithdrawalExpiry != 0) {         _processDelayedWithdrawal(msg.sender, _amount);     }     uint256 _owed = (_strategyController.totalValue() * _amount) /         totalSupply();     ... ```  ### PoC  Given:  - `_baseToken.balanceOf(Collateral)` == 90 - `_strategyController.totalValue()` == 110 - totalSupply of shares = 100  `totalAssets()` returns: 200  `getSharesForAmount(100)` returns: 50, while `withdraw(50)` will actual only get: 55.  When `Collateral` is used by another contract that manages many users' funds, and if it's using `getSharesForAmount()` to calculate the amount of shares needed for a certain amount of underlying tokens to be withdrawn.  This issue can potentially cause fund loss to the user of that contract because it will actually send a lesser amount of `_baseToken` than expected.  ### Recommendation  Consider changing `Collateral.totalValue()` to:   ```solidity function totalAssets() public view override returns (uint256) {     return         _strategyController.totalValue(); } ```  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72 https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/interfaces/IStrategy.sol#L52   # Vulnerability details  ## Impact When migrating from one strategy to another, the controller pulls out the funds of the old strategy and deposits them into the new one. But, it doesn't verify that both strategies use the same base token. If the new one uses a different base token, it won't "know" about the tokens it received on migration. It won't be able to deposit and transfer them. Effectively they would be lost.  The migration is done by the owner. So the owner must make a mistake and migrate to the wrong strategy by accident. In a basic protocol with 1 controller and a single active strategy managing that should be straightforward. There shouldn't be a real risk of that mistake happening. But, if you have multiple controllers running at the same time each with a different base token, it gets increasingly likelier.   According to the `IStrategy` interface, there is a function to retrieve the strategy's base token: `getBaseToken()`. I'd recommend adding a check in the `migrate()` function to verify that the new strategy uses the correct base token to prevent this issue from being possible.  ## Proof of Concept https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/interfaces/IStrategy.sol#L52  ## Tools Used none  ## Recommended Mitigation Steps Add  `require(_baseToken == _newStrategy.getBaseToken());` to the beginning of `migrate()`  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L328   # Vulnerability details  ## Impact The [`getSharesForAmount`](https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L328) function returns `0` if `totalAssets == 0`.  However, if **`totalSupply == 0`**, the actual shares that are minted in a [`deposit` are `_amount`](https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L83) even if `totalAssets == 0`.  Contracts / frontends that use this function to estimate their deposit when `totalSupply == 0` will return a wrong value.  ## Recommended Mitigation Steps  ```diff function getSharesForAmount(uint256 _amount)     external     view     override     returns (uint256) { +   // to match the code in `deposit` +   if (totalSupply() == 0) return _amount;      uint256 _totalAssets = totalAssets();     return         (_totalAssets > 0)             ? ((_amount * totalSupply()) / _totalAssets)             : 0; // @audit this should be _amount according to `deposit` } ```  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L97   # Vulnerability details  ## Impact After initiating a withdrawal with `initiateWithdrawal`, it's still possible to transfer the collateral tokens. This can be used to create a second account, transfer the accounts to them and initiate withdrawals at a different time frame such that one of the accounts is always in a valid withdrawal window, no matter what time it is. If the token owner now wants to withdraw they just transfer the funds to the account that is currently in a valid withdrawal window.  Also, note that each account can withdraw the specified `amount`. Creating several accounts and circling & initiating withdrawals with all of them allows withdrawing larger amounts **even at the same block** as they are purchased in the future.  I consider this high severity because it breaks core functionality of the Collateral token.  #### POC For example, assume the `_delayedWithdrawalExpiry = 20` blocks. Account A owns 1000 collateral tokens, they create a second account B. - At `block=0`, A calls `initiateWithdrawal(1000)`. They send their balance to account B. - At `block=10`, B calls `initiateWithdrawal(1000)`. They send their balance to account A. - They repeat these steps, alternating the withdrawal initiation every 10 blocks. - One of the accounts is always in a valid withdrawal window (`initiationBlock < block && block <= initiationBlock + 20`). They can withdraw their funds at any time.  ## Recommended Mitigation Steps If there's a withdrawal request for the token owner (`_accountToWithdrawalRequest[owner].blockNumber > 0`), disable their transfers for the time.  ```solidity // pseudo-code not tested beforeTransfer(from, to, amount) {   super();   uint256 withdrawalStart =  _accountToWithdrawalRequest[from].blockNumber;   if(withdrawalStart > 0 && withdrawalStart + _delayedWithdrawalExpiry < block.number) {     revert(); // still in withdrawal window   } } ```  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/Collateral.sol#L82-L91   # Vulnerability details  ## Details  The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.  ## Proof of Concept  - Attacker deposits 2 wei (so that it is greater than min fee) to mint 1 share - Attacker transfers exorbitant amount to `_strategyController` to greatly inflate the share’s price. Note that the `_strategyController` deposits its entire balance to the strategy when its `deposit()` function is called. - Subsequent depositors instead have to deposit an equivalent sum to avoid minting 0 shares. Otherwise, their deposits accrue to the attacker who holds the only share.  ```jsx it("will cause 0 share issuance", async () => {  // 1. first user deposits 2 wei because 1 wei will be deducted for fee  let firstDepositAmount = ethers.BigNumber.from(2)  await transferAndApproveForDeposit(      user,      collateral.address,      firstDepositAmount  )    await collateral      .connect(user)      .deposit(firstDepositAmount)    // 2. do huge transfer of 1M to strategy to controller  // to greatly inflate share price  await baseToken.transfer(strategyController.address, ethers.utils.parseEther("1000000"));    // 3. deployer tries to deposit reasonable amount of 10_000  let subsequentDepositAmount = ethers.utils.parseEther("10000");  await transferAndApproveForDeposit(      deployer,      collateral.address,      subsequentDepositAmount  )   await collateral      .connect(deployer)      .deposit(subsequentDepositAmount)    // receives 0 shares in return  expect(await collateral.balanceOf(deployer.address)).to.be.eq(0) }); ```  ## Recommended Mitigation Steps  - [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. - Ensure the number of shares to be minted is non-zero: `require(_shares != 0, "zero shares minted");` - Create a periphery contract that contains a wrapper function that atomically calls `initialize()` and `deposit()` - Call `deposit()` once in `initialize()` to achieve the same effect as the suggestion above.  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72   # Vulnerability details  ## Impact  If a strategy does not have sufficient funds to `withdraw()` for the full amount then it is possible that tokens will be left in this yield contract during `migrate()`.  It is common for withdrawal from a strategy to withdraw less than a user's balance. The reason is that these yield protocols may lend the deposited funds to borrowers, if there is less funds in the pool than the withdrawal amount the withdrawal may succeed but only transfer the funds available rather than the full withdrawal amount.  The impact of tokens remaining in the old strategy is that when we call `StrategyController.totalValue()` this will only account for the tokens deposited in the new strategy and not those stuck in the previous strategy. Therefore `totalValue()` is undervalued.   Thus, when a user calls `Collateral.deposit()` the share calculations `_shares = (_amountToDeposit * totalSupply()) / (_valueBefore);` will be over stated (note: `uint256 _valueBefore = _strategyController.totalValue();`). Hence, the user will receive more shares than they should.  The old tokens may be recovered by calling `migrate()` back to the old strategy. If this is done then `totalValue()` will now include the tokens previously stuck. The recent depositer may now withdraw and will be owed `(_strategyController.totalValue() * _amount) / totalSupply()`. Since `totalValue()` is now includes the previously stuck tokens  `_owed` will be overstated and the user will receive more collateral than they should.  The remaining users who had deposited before `migrate()` will lose tokens proportional to their share of the `totalSupply()`.  ## Proof of Concept  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72 ```     function migrate(IStrategy _newStrategy)         external         override         onlyOwner         nonReentrant     {         uint256 _oldStrategyBalance;         IStrategy _oldStrategy = _strategy;         _strategy = _newStrategy;         _baseToken.approve(address(_newStrategy), type(uint256).max);         if (address(_oldStrategy) != address(0)) {             _baseToken.approve(address(_oldStrategy), 0);             _oldStrategyBalance = _oldStrategy.totalValue();             _oldStrategy.withdraw(address(this), _oldStrategyBalance);             _newStrategy.deposit(_baseToken.balanceOf(address(this)));         }         emit StrategyMigrated(             address(_oldStrategy),             address(_newStrategy),             _oldStrategyBalance         );     } ```  ## Recommended Mitigation Steps  The recommendation is to ensure that `require(_oldStrategy.totalValue() == 0)` after calling `_oldStrategy.withdraw()`. This ensures that no funds are left in the strategy. Consider the code example below.  ```     function migrate(IStrategy _newStrategy)         external         override         onlyOwner         nonReentrant     {         uint256 _oldStrategyBalance;         IStrategy _oldStrategy = _strategy;         _strategy = _newStrategy;         _baseToken.approve(address(_newStrategy), type(uint256).max);         if (address(_oldStrategy) != address(0)) {             _baseToken.approve(address(_oldStrategy), 0);             _oldStrategyBalance = _oldStrategy.totalValue();             _oldStrategy.withdraw(address(this), _oldStrategyBalance);             require(_oldStrategy.totalValue() == 0)             _newStrategy.deposit(_baseToken.balanceOf(address(this)));         }         emit StrategyMigrated(             address(_oldStrategy),             address(_newStrategy),             _oldStrategyBalance         );     } ```  
# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/PrePOMarketFactory.sol#L42   # Vulnerability details  ## Impacted Function: createMarket  ## Description:  1. Owner calls createMarket with  _tokenNameSuffix S1 and _tokenSymbolSuffix S2 which creates a new market M1 with _deployedMarkets[_salt] pointing to M1. Here salt can be S which is computed using  _tokenNameSuffix and _tokenSymbolSuffix 2. This market is now being used 3. After some time owner again mistakenly calls createMarket with  _tokenNameSuffix S1 and _tokenSymbolSuffix S2  4. Instead of returning error mentioning that this name and symbol already exists, new market gets created. The problem here is that salt which is computed using _tokenNameSuffix and _tokenSymbolSuffix will again come as S (as in step 1) which means _deployedMarkets[_salt] will now get updated to M2. This means reference to M1 is gone  ## Recommendation: Add below check:  ``` require(_deployedMarkets[_salt]==address(0), "Market already exists"); ```  
