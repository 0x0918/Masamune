# Handle  GreyArt   # Vulnerability details  ## Impact  In the function `_sellVaultTokenETH`, the parameter `minWethOut` should be `minEthOut`  ## Recommended Mitigation Steps  Replace `minWethOut` with `minEthOut`  
# Handle  GreyArt   # Vulnerability details  ## Impact  The MarketplaceZap contract conducts a sanity check on the `to` address. One can therefore expect that this check is in place for the StakingZap contract as well.  We also suggest adding another check to ensure that the `to` address is not the StakingZap contract itself. Although there is a `rescue()` function to retrieve funds in these cases, it would be a hassle to do so.   ## Recommended Mitigation Steps  Include the sanity check(s) of the `to` address in the `addLiquidity*()` functions.  ```jsx require(to != address(0) && to != address(this)); ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  A `rescue()` function exists for the StakingZap contract to help retrieve any accidental fund transfer to it. It would be beneficial to have this function exist in the MarketplaceZap contract too.  ## Recommended Mitigation Steps  Include the `rescue()` function.  ```jsx function rescue(address token) external onlyOwner {  IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this))); } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  Native fund transfers into the zap contract are only expected from the WETH contract. Hence, it would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  This is also true even though `sushiRouter.swapExactTokensForETH()` is called, as the recipient of the swap is expected to not be the marketplace zap contract.  ## Recommended Mitigation Steps  Modify the `receive()` function to only accept transfers from the wrapped token contract.  ```jsx receive() external payable {   require(msg.sender == address(WETH), "Only WETH"); } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  In the `_sendForReceiver()` function, there are 2 comments: `// If the receive is not properly processed, send it to the treasury instead.`   and  `// If the allowance has not been spent, it means we can pass it forward to next`  which are contradictory in nature, except for the case of the last receiver in the feeReceivers array.  Looking at the `distribute()` function implementation, should the `receiveRewards()` function return false, fail, or if the `transferFrom()` was not called in its implementation, the rewards will be given to the next receiver, and not the treasury.  ```jsx // Note: some irrelevant lines were omitted for (uint256 i = 0; i < length; i++) {   uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);   bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);   if (!complete) {     leftover = amountToSend;   } else {     leftover = 0;  } } ```  ## Recommended Mitigation Steps  Based on the implementation, the comment `// If the receive is not properly processed, send it to the treasury instead.` should be edited or removed.  
# Handle  GreyArt   # Vulnerability details  ## Impact  From what we understand, the contracts upgrade will be performed in place, where the relevant current proxies will be pointing to the new implementations. An important restriction when doing so is that the order of which the contract state variables are declared, and their types **must be preserved.** More information can be found in [OpenZeppelin’s documentation](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts).  For the NFTXLPStaking contract, the [version of the May contest review](https://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol) was:  ```jsx contract NFTXLPStaking is OwnableUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable;      INFTXVaultFactory public nftxVaultFactory;     INFTXFeeDistributor public feeDistributor;     RewardDistributionTokenUpgradeable public rewardDistTokenImpl;     StakingTokenProvider public stakingTokenProvider;      event PoolCreated(uint256 vaultId, address pool);     event PoolUpdated(uint256 vaultId, address pool);     event FeesReceived(uint256 vaultId, uint256 amount);      struct StakingPool {         address stakingToken;         address rewardToken;     }     mapping(uint256 => StakingPool) public vaultStakingInfo;      function __NFTXLPStaking__init(address _stakingTokenProvider) external initializer { ... ```  while the new version is  ```jsx contract NFTXLPStaking is PausableUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable;      INFTXVaultFactory public nftxVaultFactory;     IRewardDistributionToken public rewardDistTokenImpl;     StakingTokenProvider public stakingTokenProvider;      event PoolCreated(uint256 vaultId, address pool);     event PoolUpdated(uint256 vaultId, address pool);     event FeesReceived(uint256 vaultId, uint256 amount);      struct StakingPool {         address stakingToken;         address rewardToken;     }     mapping(uint256 => StakingPool) public vaultStakingInfo;      TimelockRewardDistributionTokenImpl public newTimelockRewardDistTokenImpl;      function __NFTXLPStaking__init(address _stakingTokenProvider) external initializer { ... ```  Note that the `feeDistributor` has been removed. Also note that a new base contract has been added (`PausableUpgradeable` which inherits `OwnableUpgradeable`), which has 2 mappings `isGuardian` and `isPaused`.   We however note that the current `NFTXLPStaking` implementation at [`https://etherscan.io/address/0xa64c2f3f965f055e51482bf0960ebb5f2904bf68#code`](https://etherscan.io/address/0xa64c2f3f965f055e51482bf0960ebb5f2904bf68#code) is a more recent version than that of the previous contest review. There is no change in the storage layout between this deployed version against the one being reviewed.  The ordering of state variables is determined by the C3-linearized order of contracts, so there does not seem to have been any storage collision with the change from `OwnableUpgradeable` to `PausableUpgradeable`. It also appears that the public variables are returning expected values.  ## Recommended Mitigation Steps  Upgrading implementations are a tricky affair. It is highly recommended to use tools like OpenZeppelin’s upgrade plugins that validate that the new implementation is upgrade safe and is compatible with the previous one.  
# Handle  GreyArt   # Vulnerability details  ## Impact  `xTokensMinted` is assigned in `provideInventory721()` and `provideInventory1155()`, but is unused.  ## Recommended Mitigation Steps  Remove the local variable `xTokensMinted`.  
# Handle  Dravee   # Vulnerability details  ## Impact Since the defined constants are unneeded elsewhere, it can be defined to be internal or private to save gas.  ## Proof of Concept ``` https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L28-L30 ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change the visibility from public to private or internal  
# Handle  pauliax   # Vulnerability details  ## Impact 'unchecked' directive can be used where an underflow/overflow cannot happen, e.g. here: ```solidity   if (amountEth < msg.value) {     WETH.withdraw(msg.value-amountEth);     payable(to).call{value: msg.value-amountEth};   } ``` Also, to reduce gas usage, ```msg.value-amountEth``` should be cached and not re-calculated several times.  
# Handle  Dravee   # Vulnerability details  ## Impact Explicit initialization with zero is not required for variable declaration because uints are 0 by default. Removing this will reduce contract size and save a bit of gas.  ## Proof of Concept Instances include: ``` ./NFTXEligibilityManager.sol:85:        for (uint256 i = 0; i < modulesCopy.length; i++) { ./NFTXLPStaking.sol:81:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXLPStaking.sol:206:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXMarketplaceZap.sol:263:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:297:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:379:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:399:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:414:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:437:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXSimpleFeeDistributor.sol:62:    for (uint256 i = 0; i < length; i++) {  { ./NFTXVaultUpgradeable.sol:364:        for (uint256 i = 0; i < len; i++) { ./NFTXVaultUpgradeable.sol:406:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:419:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:442:        for (uint256 i = 0; i < amount; i++) { ```  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove explicit initialization with zero.  
# Handle  PPrieditis   # Vulnerability details  ## Impact NFTXMarketplaceZap.sol function _buyVaultToken() has unused parameter "vault"  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L497  ## Recommended Mitigation Steps Remove parameter "vault" from _buyVaultToken() and update necessary _buyVaultToken() calls.  
# Handle  Dravee   # Vulnerability details  ## Impact `++i` costs less gass compared to `i++` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration)  ## Proof of Concept `i++` increments `i` and returns the initial value of `i`. Which means:  ``` uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ``` uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`  Instances include: ``` ./NFTXEligibilityManager.sol:85:        for (uint256 i = 0; i < modulesCopy.length; i++) { ./NFTXLPStaking.sol:81:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXLPStaking.sol:206:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXMarketplaceZap.sol:263:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:297:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:379:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:399:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:414:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:437:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXSimpleFeeDistributor.sol:62:    for (uint256 i = 0; i < length; i++) { ./NFTXStakingZap.sol:192:    for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXStakingZap.sol:203:    for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXStakingZap.sol:341:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXVaultUpgradeable.sol:267:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:406:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:419:            for (uint256 i = 0; i < tokenIds.length; i++) { ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use `++i` instead of `i++` to increment the value of an uint variable  
# Handle  Dravee   # Vulnerability details  ## Impact In Solidity, a `constant` expression in a variable will compute the expression everytime the variable is called. It's not the result of the expression that is stored, but the expression itself.  As Solidity supports the scientific notation, constants of form `10**X` can be rewritten as `1eX` to save the gas cost from the calculation with the exponentiation operator `**`.  ## Proof of Concept ``` NFTXInventoryStaking.sol:   28:     uint256 public constant BASE = 10**18;  NFTXMarketplaceZap.sol:   158:   uint256 constant BASE = 10**18;  NFTXStakingZap.sol:   163:   uint256 constant BASE = 10**18;  NFTXVaultUpgradeable.sol:   33:     uint256 constant base = 10**18; ```  ## Tools Used Vs Code  ## Recommended Mitigation Steps Replace `10**18` with `1e18`  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `vaultFactory` in `NFTXVaultUpgradeable#_chargeAndDistributeFees()`      https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L470-L484      ```solidity=470     function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {         // Do not charge fees if the zap contract is calling         // Added in v1.0.3. Changed to mapping in v1.0.5.         if (vaultFactory.excludedFromFees(msg.sender)) {             return;         }                  // Mint fees directly to the distributor and distribute.         if (amount > 0) {             address feeDistributor = vaultFactory.feeDistributor();             // Changed to a _transfer() in v1.0.3.             _transfer(user, feeDistributor, amount);             INFTXFeeDistributor(feeDistributor).distribute(vaultId);         }     }     ```  
# Handle  gzeon   # Vulnerability details  ## Impact Calculation of `xTokenAddr` can further save gas by caching the creation hash as a immutable state.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L136 ``` address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode)); ```  ## Recommended Mitigation Steps ```     bytes32 internal immutable beaconhash = keccak256(type(Create2BeaconProxy).creationCode);     function xTokenAddr(address baseToken) public view virtual override returns (address) {         bytes32 salt = keccak256(abi.encodePacked(baseToken));         address tokenAddr = Create2.computeAddress(salt, beaconhash);         return tokenAddr;     } ```  
# Handle  0x1f8b   # Vulnerability details  ## Impact Unsafe approve was done.  ## Proof of Concept In the method `NFTXSimpleFeeDistributor._sendForReceiver` it's made a approve without checking the boolean result, ERC20 standard specify that the token can return false if the approve was not made, so it's mandatory to check the result of approve methods.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use safe approve or check the boolean result  
# Handle  hyh   # Vulnerability details  ## Impact  `transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`. It transfers to `address(this)` instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is `to`).  ## Proof of Concept  NFTXStakingZap: transferFromERC721 https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L416  NFTXMarketplaceZap: transferFromERC721 https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L556  Both functions are called by user facing Marketplace buy/sell and Staking addLiquidity/provideInventory functions.  ## Recommended Mitigation Steps  Fix the address:  Now: ``` // Cryptokitties. data = abi.encodeWithSignature("transferFrom(address,address,uint256)", msg.sender, address(this), tokenId); ```  To be: ``` // Cryptokitties. data = abi.encodeWithSignature("transferFrom(address,address,uint256)", msg.sender, to, tokenId); ```   
# Handle  gzeon   # Vulnerability details  ## Impact `changeReceiverAlloc` did not check if the idx exists unlike other functions in the same contract  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L93 ```   function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {     FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];     allocTotal -= feeReceiver.allocPoint;     feeReceiver.allocPoint = _allocPoint;     allocTotal += _allocPoint;     emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);   } ```  ## Recommended Mitigation Steps ```require(_receiverIdx < feeReceivers.length, "FeeDistributor: Out of bounds");```  
# Handle  gzeon   # Vulnerability details  ## Impact The default value of `inventoryLockTime` in `NFTXStakingZap` is `7 days` while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock value are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in `XTokenUpgradeable`.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L74 ```     function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {         uint256 timelockFinish = block.timestamp + timelockLength;         timelock[account] = timelockFinish;         emit Timelocked(account, timelockFinish);         _mint(account, amount);     } ```  The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling `deposit` in `NFTXInventoryStaking`  ## Proof of Concept https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L160 https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L30  ## Recommended Mitigation Steps ```     function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {         uint256 timelockFinish = block.timestamp + timelockLength;         if(timelockFinish > timelock[account]){             timelock[account] = timelockFinish;             emit Timelocked(account, timelockFinish);         }         _mint(account, amount);     } ```  
# Handle  hyh   # Vulnerability details  ## Impact  `NFTXVaultFactory` contract holds information regarding vaults, assets and permissions (vaults, _vaultsForAsset and excludedFromFees mappings). As there is no mechanics present that transfers this information to another implementation, the switch of nftxVaultFactory to another address performed while in production will break the system.  ## Proof of Concept  `setNFTXVaultFactory` function allows an owner to reset `nftxVaultFactory` without restrictions in the following contracts:  NFTXLPStaking https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L59  NFTXInventoryStaking https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L51  NFTXSimpleFeeDistributor https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L135  ## Recommended Mitigation Steps  Either restrict the ability to change the factory implementation to pre-production stages or make `nftxVaultFactory` immutable by allowing changing it only once:  Now: ``` function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {   require(newFactory != address(0));   nftxVaultFactory = INFTXVaultFactory(newFactory); } ```  To be: ``` function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {   require(nftxVaultFactory == address(0), "nftxVaultFactory is immutable");   nftxVaultFactory = INFTXVaultFactory(newFactory); } ```  If the implementation upgrades in production is desired, the factory data migration logic should be implemented and then used atomically together with the implementation switch in all affected contracts.   
# Handle  pauliax   # Vulnerability details  ## Impact When emitting Sell event, it assumes that the path is always of length 2, as amounts[1] is used for the ethReceived parameter. However, the path does not have any restrictions on its length, so it is completely possible, that this is not the final amount. Events are used to inform the outside world and this may trick the consumers.  ## Recommended Mitigation Steps amounts[1] should be replaced with amounts[amounts.length - 1]  
# Handle  pauliax   # Vulnerability details  ## Impact Consider introducing a reasonable global upper limit for timelockLength in XTokenUpgradeable and TimelockRewardDistributionTokenImpl, so the users can't be locked out of their tokens forever.  ## Recommended Mitigation Steps XTokenUpgradeable and TimelockRewardDistributionTokenImpl should not trust the external input but have explicitly declared boundaries for values like timelock length to reduce possibilities of unexpected outcomes.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L247-L248  ```solidity=247 uint256 remaining = WETH.balanceOf(address(this)); WETH.transfer(to, remaining); ```  Since `WETH.balanceOf(address(this))` can to be `0`. Checking `if (remaining > 0)` before the transfer can potentially save an external call and the unnecessary gas cost of a 0 token transfer.  
# Handle  WatchPug   # Vulnerability details  Unused function parameters increase contract size and gas usage at deployment.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L496-L511  ```solidity=496   function _buyVaultToken(     address vault,      uint256 minTokenOut,      uint256 maxWethIn,      address[] calldata path   ) internal returns (uint256[] memory) {     uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(       minTokenOut,       maxWethIn,       path,        address(this),       block.timestamp     );      return amounts;   } ```  `vault` is unused.  
# Handle  WatchPug   # Vulnerability details  Unused local variables in contracts increase contract size and gas usage at deployment.  Instances include:  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L187-L187  ```solidity=187 uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime); ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L207-L207  ```solidity=207 uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime); ```  
# Handle  WatchPug   # Vulnerability details  Unused events increase contract size and gas usage at deployment.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/eligibility/NFTXMintRequestEligibility.sol#L62-L62  ```solidity event Reject(uint256[] nftIds); ```  `Reject` is unused.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L285-L290  ```solidity=285     function _deposit(StakingPool memory pool, uint256 amount) internal {         require(pool.stakingToken != address(0), "LPStaking: Nonexistent pool");         IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);         // Timelock for 2 seconds to prevent flash loans.         _rewardDistributionTokenAddr(pool).timelockMint(msg.sender, amount, 2);     } ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L124-L130  ```solidity=124     function deposit(uint256 vaultId, uint256 amount) external {         onlyOwnerIfPaused(10);         // Check the pool in case its been updated.         updatePoolForVault(vaultId);         StakingPool memory pool = vaultStakingInfo[vaultId];         _deposit(pool, amount);     } ```   `_deposit()` is unnecessary as it's being used only once. Therefore it can be inlined in `deposit()` to make the code simpler and save gas.  ## Recommendation  Change to:  ```solidity=124     function deposit(uint256 vaultId, uint256 amount) external {         onlyOwnerIfPaused(10);         // Check the pool in case its been updated.         updatePoolForVault(vaultId);         StakingPool memory pool = vaultStakingInfo[vaultId];          require(pool.stakingToken != address(0), "LPStaking: Nonexistent pool");         IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);         // Timelock for 2 seconds to prevent flash loans.         _rewardDistributionTokenAddr(pool).timelockMint(msg.sender, amount, 2);     } ```  Other examples include:  -   `NFTXFlashSwipe.sol#flashRedeem()`, `NFTXFlashSwipe.sol#flashMint()` can be inlined in `NFTXFlashSwipe.sol#onFlashLoan()` -   `UniswapV3SparkleEligibility.sol#isRare()` can be inlined in `UniswapV3SparkleEligibility.sol#_checkIfEligible()`   
# Handle  cmichel   # Vulnerability details  The comment in `TimelockRewardDistributionTokenImpl.burnFrom` says: > the caller must have allowance for ``accounts``'s tokens of at least `amount`.  This was the case in a previous version but not anymore. The owner does not need to be approved to burn tokens anymore.  ## Recommended Mitigation Steps Update the comment to clarify the behavior.   
# Handle  cmichel   # Vulnerability details  The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded.  ## Impact If the call fails, the refunds did not succeed and the caller will lose all refunds of `msg.value - amountEth`.  ## Recommended Mitigation Steps Revert the entire transaction if the refund call fails by checking that the `success` return value of the `payable(to).call(...)` returns `true`.  
# Handle  cmichel   # Vulnerability details  The `NFTXInventoryStaking` contract distributes new rewards to all previous stakers when the owner calls the `receiveRewards` function. This allows an attacker to frontrun this `receiveRewards` transaction when they see it in the mem pool with a `deposit` function. The attacker will receive the rewards pro-rata to their deposits. The deposit will be locked for 2 seconds only (`DEFAULT_LOCKTIME`) after which the depositor can withdraw their initial deposit & the rewards again for a profit.  The rewards can be gamed this way and one does not actually have to _stake_, only be in the staking contract at the time of reward distribution for 2 seconds. The rest of the time they can be used for other purposes.  ## Recommended Mitigation Steps Distribute the rewards equally over time to the stakers instead of in a single chunk on each `receiveRewards` call. This is more of a "streaming rewards" approach.   
# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) {   uint length = arr.length;   for (uint i = 0; i < arr.length; i++) {       sum += arr[i];   } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) {   uint length = arr.length;   for (uint i = 0; i < arr.length; i++) {       sum += arr[i];   } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L297`  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  Multiple internal functions do not have a name that starts with an underscore. The lack of clarity over the functions visibility could lead to misuse of these functions.  ## Proof of Concept Both the NFTXMarketplaceZap.sol and NFTXStakingZap.sol contracts have three internal functions names without underscores: approveERC721 in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L574 approveERC721 in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L434 pairFor in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L593 pairFor in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L453 sortTokens in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L604 sortTokens in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L464  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Rename internal functions following best practices to clarify function visibility  
# Handle  sirhashalot   # Vulnerability details  ## Impact  If two variables with the same name exist in a function, but one is imported from another contract while the other is created locally, it is unclear which value is being used or should be used. Avoiding variable name collisions avoids confusion and the risks of using the wrong variable.  https://swcregistry.io/docs/SWC-119  ## Proof of Concept  Several instance of this issue exist. 1. mintAndSell1155() function in NFTXMarketplaceZap.sol has `uint256[] memory amounts` as an input parameter and later it is redeclared in the function https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L368,L376 2. pauseFeeDistribution() function in NFTXSimpleFeeDistributor.sol uses a pause return bool which shadows PausableUpgradeable.pause https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L140 3. transferFromERC721() function in NFTXStakingZap.sol declares an `address owner` which shadows Ownable.owner(): https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L422 4. transferFromERC721() function in NFTXMarketplaceZap.sol declares an `address owner` which shadows Ownable.owner(): https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L562  ## Tools Used  Slither, shadowing-local detector: https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing  ## Recommended Mitigation Steps  Rename local variables to avoid shadowing. For instance, add an underscore in front of the name of local variables.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_sendForReceiver()` function only sets a return function in the "if" code block, not the "else" case. If the "else" case is true, no value is returned. The result of this oversight is that the `_sendForReceiver()` function called from the `distribute()` function could sucessfully enter its `else` block if a receiver has `isContract` set to False and successfully transfer the `amountToSend` value. The `ditribute()` function will then have `leftover > 0` and send `currentTokenBalance` to the treasury. This issue is partially due to [Solidity using implicit returns](https://github.com/ethereum/solidity/issues/2951), so if no bool value is explicitly returned, the default bool value of False will be returned.  This problem currently occurs for any receiver with `isContract` set to False. The `_addReceiver` function allows for `isContract` to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.  ## Proof of Concept  The `else` block is missing a return value https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L167-L169  ## Tools Used  VS Code "Solidity Visual Developer" extension  ## Recommended Mitigation Steps  Verify that functions with a return value do actually return a value in all cases. Adding the line `return true;` can be added to the end of the `else` block as one way to resolve this.  Alternatively, if `isContract` should never be set to False, the code should be designed to prevent a receiver from being added with this value.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `provideInventory1155()` function in contracts/solidity/NFTXStakingZap.sol contains a for loop that uses tokenIds.length to loop through the amounts array. However, if these two arrays are not the same length, the loop with trigger an error. The error could be triggered after many operations already occur, so checking that these two lengths are equal first could save gas.  ## Proof of Concept  The `provideInventory1155()` function contracts/solidity/NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L201  ## Recommended Mitigation Steps  There are two main options to reducing the gas spend in an error condition: 1. Add the following line as the first line of the `provideInventory1155()` function: `require(tokenIds.length == amounts.length)` 2. In the for loop within the `provideInventory1155()` function, replace `i < tokenIds.length` with `i < amounts.length;`  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The file contracts/solidity/testing/NFTXFeeDistributor2.sol references the old NFTXFeeDistributor.sol and instead should reference the new NFTXSimpleFeeDistributor.sol  ## Proof of Concept  The import and contract inheritance of contracts/solidity/testing/NFTXFeeDistributor2.sol  ## Tools Used  `npx hardhat test` fails due to this issue because the ../NFTXFeeDistributor.sol imported file is not found  ## Recommended Mitigation Steps  Reference the new NFTXSimpleFeeDistributor.sol and not NFTXFeeDistributor.sol in the import and contract inheritance  
# Handle  hyh   # Vulnerability details  ## Impact  deployXTokenForVault call will not revert on deploy failure.  ## Proof of Concept  NFTXInventoryStaking._deployXToken is called by deployXTokenForVault: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L64  _deployXToken uses deploy generated address without check: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L160  ## Recommended Mitigation Steps  Require non zero deployedXToken address before calling __XToken_init.  
# Handle  hyh   # Vulnerability details  # Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. mintTo and swapTo outcome will not be as expected by a caller.  ## Proof of Concept  The arrays are used whenever Vault is ERC1155, i.e. when is1155 is true.  swap -> swapTo uses the arrays as given: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L258  mint -> mintTo, arrays are passed on without checks to receiveNFTs: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L190  receiveNFTs uses the arrays in a loop, assuming equal lengths without a check: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L389  ## Recommended Mitigation Steps  Add `require(tokenIds.length == amounts.length, "tokenIds and amounts length should match")` check in the beginning of public mintTo and swapTo endpoints.   
# Handle  p4st13r4   # Vulnerability details  ## Impact  `XTokenUpgradeable.sol` contains many comments regarding SushiBar. It looks like the comments have been copy-pasted from another contract, and may be deceiving for a reader  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L14](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L14)  ## Tools Used  ## Recommended Mitigation Steps  Remove said comments  
# Handle  p4st13r4   # Vulnerability details  ## Impact  Detailed description of the impact of this finding.  Fee distribution algorithm in `NFTXSimpleFeeDistributor.sol` can led to unfair distribution of fees among receivers. The `_sendForReceiver` function returns `success = true` only when the call to receiver' `receiveRewards` is successful and the whole amount is transfered to the receiver. Otherwise, the entire fee is moved up to the next receiver, and finally to the treasury.  If a badly implemented receiver leaves a part of the fee (even 1 wei) to the fee distributor, the operation is considered unsuccessful and the entire amount of the fee is moved up to the next receiver. This could lead to the situation where one of the late receivers is unable to receive any fee at all, since some previous receiver has received more than it should have.  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L166](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L166)  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L69](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L69)  ## Tools Used  Editor  ## Recommended Mitigation Steps  `_sendForReceiver` should return a tuple: `(bool success, uint256 amountLeft)`. Then `amountLeft` should be used by `distribute` for the `leftover` variable  
# Handle  p4st13r4   # Vulnerability details  ## Impact  Any user that owns a vToken of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone.  Every operation performed by the marketplace, that deals with vToken minting, performs this check:  ```jsx require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), "Did not receive expected balance"); ```  A malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421)  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Remove this logic from the marketplace and staking zap contracts, and add it to the vaults (if necessary)  
# Handle  hyh   # Vulnerability details  # Impact  Double spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones. As `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.  ## Proof of Concept  `distribute` use `_sendForReceiver` to transfer current vault balance across `feeReceivers`: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L67  `_sendForReceiver` returns a boolean that is used to move current distribution amount to the next receiver when last transfer failed. When `_receiver.isContract` is `false` nothing is returned, while `safeTransfer` is done: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L168  This way `_sendForReceiver` will indicate that transfer is failed and leftover amount to be added to the next transfer, i.e. the `amountToSend` will be spent twice: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L64  ## Recommended Mitigation Steps  Now: ``` function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {  if (_receiver.isContract) {  ...  } else {   IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);  } } ```  To be: ``` function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {  if (_receiver.isContract) {  ...  } else {   IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);   return true;  } } ```  
# Handle  WatchPug   # Vulnerability details  Since the introduction of `transfer()`, it has typically been recommended by the security community because it helps guard against reentrancy attacks. This guidance made sense under the assumption that gas costs wouldn’t change. It's now recommended that transfer() and send() be avoided, as gas costs can and will change and reentrancy guard is more commonly used.  Any smart contract that uses `transfer()` is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.  It's recommended to stop using `transfer()` and switch to using `call()` instead.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXV1Buyout.sol#L44-L44  ```solidity payable(msg.sender).transfer(amount); ```  Can be changed to:  ```solidity (bool success, ) = msg.sender.call{value: amount}(""); require(success, "ETH transfer failed"); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L15-L15  ```solidity=15 contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable { ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L41-L47  ```solidity=41   function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {     __Pausable_init();     setTreasuryAddress(_treasury);     setLPStakingAddress(_lpStaking);      _addReceiver(0.8 ether, lpStaking, true);   } ```  For the upgradeable variants of OpenZipplin contracts, they should be initialized by calling the `__***_init()` function in the initializer function.  Therefore, `__SimpleFeeDistributor__init__()` should call `__ReentrancyGuard_init()` at L42.  
# Handle  WatchPug   # Vulnerability details  There are many functions across the codebase that will perform an ERC20.approve() call but does not check the success return value. Some tokens do not revert if the approval failed but return false instead.  Instances include:  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L167-L167  ```solidity=167 IERC20Upgradeable(address(_pairedToken)).approve(_sushiRouter, type(uint256).max); ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L313  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L299  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L519  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L538  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L159  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L398  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L171  It is usually good to add a require-statement that checks the return value or to use something like `safeApprove`; unless one is sure the given token reverts in case of a failure.  
# Handle  leastwood   # Vulnerability details  ## Impact  `TimelockRewardDistributionTokenImpl` calculates the accumulative reward according to the following function: ``` function accumulativeRewardOf(address _owner) public view returns(uint256) {   return magnifiedRewardPerShare.mul(balanceOf(_owner)).toInt256()     .add(magnifiedRewardCorrections[_owner]).toUint256Safe() / magnitude; } ```  The calculation takes into consideration the LP token balance of token holders. Hence, if the token holder has called `emergencyExit` or `withdraw` in `NFTXLPStaking`, the LP tokens are removed from the staking contract without claiming rewards prior to this action. Therefore, in order for users to claim their fair share of rewards they must restake LP tokens and call `claimRewards`.   Similarly, `_transfer` in `TimelockRewardDistributionTokenImpl` also does not force the `from` account to claim rewards first.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L195-L198 ``` function withdraw(uint256 vaultId, uint256 amount) external {     StakingPool memory pool = vaultStakingInfo[vaultId];     _withdraw(pool, amount, msg.sender); } ```  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L157-L162 ``` function emergencyExit(address _stakingToken, address _rewardToken) external {     StakingPool memory pool = StakingPool(_stakingToken, _rewardToken);     TimelockRewardDistributionTokenImpl dist = _rewardDistributionTokenAddr(pool);     require(isContract(address(dist)), "Not a pool");     _withdraw(pool, dist.balanceOf(msg.sender), msg.sender); } ```  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/TimelockRewardDistributionTokenImpl.sol#L199-L206 ``` function _transfer(address from, address to, uint256 value) internal override {   require(block.timestamp > timelock[from], "User locked");   super._transfer(from, to, value);    int256 _magCorrection = magnifiedRewardPerShare.mul(value).toInt256();   magnifiedRewardCorrections[from] = magnifiedRewardCorrections[from].add(_magCorrection);   magnifiedRewardCorrections[to] = magnifiedRewardCorrections[to].sub(_magCorrection); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing functions in `NFTXLPStaking` that do not claim token rewards before unstaking LP tokens or alternatively add code to the affected functions such that rewards are claimed before withdrawing LP tokens.  
# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the _sendForReceiver function to distribute the fee  ```   function distribute(uint256 vaultId) external override virtual nonReentrant {     require(nftxVaultFactory != address(0));     address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);      uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));      if (distributionPaused || allocTotal == 0) {       IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);       return;     }      uint256 length = feeReceivers.length;     uint256 leftover;     for (uint256 i = 0; i <length; i++) {       FeeReceiver memory _feeReceiver = feeReceivers[i];       uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);       uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));       amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;       bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);       if (!complete) {         leftover = amountToSend;       } else {         leftover = 0;       }     } ```  In the _sendForReceiver function, when the _receiver is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success,) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ```  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L166  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  The contract can store the fee sent to the receiver in a state variable, and then the receiver can take it out by calling a function.  
# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXSimpleFeeDistributor.sol contract, the distribute function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the _sendForReceiver function.  ```   function distribute(uint256 vaultId) external override virtual nonReentrant {     require(nftxVaultFactory != address(0));     address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);      uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));      if (distributionPaused || allocTotal == 0) {       IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);       return;     }      uint256 length = feeReceivers.length;     uint256 leftover;     for (uint256 i = 0; i <length; i++) {       FeeReceiver memory _feeReceiver = feeReceivers[i];       uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);       uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));       amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;       bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);       if (!complete) {         leftover = amountToSend;       } else {         leftover = 0;       }     } ```  In the _sendForReceiver function, when _receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success,) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ``` ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L168  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L49-L67  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success, ) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       - IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);       + return IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ```  
# Handle  leastwood   # Vulnerability details  ## Impact  `assignDefaultFeatures` is intended to be called by the `dev` account, however, the function itself does not take in any arguments and instead sets the `enableRandomSwap` and `enableTargetSwap` state variables to itself.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L111-L117 ``` function assignDefaultFeatures() external {     require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, "Not dev");     enableRandomSwap = enableRandomRedeem;     enableTargetSwap = enableTargetRedeem;     emit EnableRandomSwapUpdated(enableRandomSwap);     emit EnableTargetSwapUpdated(enableTargetSwap); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing this function altogether or adding the necessary arguments such that the `dev` account can actually set the proper state variables.  
# Handle  ych18   # Vulnerability details  In If the Vault owner decides to set factoryMintFee and factoryRandomRedeemFee to zero, any user could call the function NFTXVaultFactoryUpgradeable.assignFees() and hence all the fees are updated.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping `ERC1155` tokens within a single transaction. The function expects to transfer `WETH` tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in `buyAndSwap1155WETH` actually uses `msg.value` and not `maxWethIn`. As a result, the function will not work unless the user supplies both `WETH` and native `ETH` amounts, equivalent to the `maxWethIn` amount.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L284-L314 ``` function buyAndSwap1155WETH(   uint256 vaultId,    uint256[] memory idsIn,    uint256[] memory amounts,    uint256[] memory specificIds,    uint256 maxWethIn,    address[] calldata path,   address to ) public payable nonReentrant {   require(to != address(0));   require(idsIn.length != 0);   IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);   uint256 count;   for (uint256 i = 0; i < idsIn.length; i++) {       uint256 amount = amounts[i];       require(amount > 0, "Transferring < 1");       count += amount;   }   INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));   uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (       vault.randomSwapFee() * (count - specificIds.length)   );   uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);   _swap1155(vaultId, idsIn, amounts, specificIds, to);    emit Swap(count, swapAmounts[0], to);    // Return extras.   uint256 remaining = WETH.balanceOf(address(this));   WETH.transfer(to, remaining); } ```  ## Tools Used  Manual code review. Discussions with Kiwi.  ## Recommended Mitigation Steps  Consider updating the `buyAndSwap1155WETH` function such that the following line of code is used instead of [this](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L306).  ``` uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path); ```  
# Handle  robee   # Vulnerability details  Need to use safeTransfer instead of transfer. As there are popular tokens, such as USDT that transfer/trasnferFrom method doesn’t return anything. The transfer return value has to be checked (as there are some other tokens that returns false instead revert), that means you must   1. Check the transfer return value Another popular possibility is to add a whiteList. Those are the appearances (solidity file, line number, actual line):          NFTXStakingZap.sol, 401, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);          NFTXStakingZap.sol, 474, IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));          PalmNFTXStakingZap.sol, 190, pairedToken.transferFrom(msg.sender, address(this), wethIn);          PalmNFTXStakingZap.sol, 195, pairedToken.transfer(to, wethIn-amountEth);          PalmNFTXStakingZap.sol, 219, pairedToken.transferFrom(msg.sender, address(this), wethIn);          PalmNFTXStakingZap.sol, 224, pairedToken.transfer(to, wethIn-amountEth);          PalmNFTXStakingZap.sol, 316, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);          XTokenUpgradeable.sol, 54, baseToken.transfer(who, what);          NFTXFlashSwipe.sol, 51, IERC20Upgradeable(vault).transferFrom(msg.sender, address(this), mintFee + targetRedeemFee);    
# Handle  robee   # Vulnerability details          Deprecated safeApprove in NFTXMarketplaceZap.sol line 518: IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);          Deprecated safeApprove in NFTXMarketplaceZap.sol line 537: IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);          Deprecated safeApprove in NFTXSimpleFeeDistributor.sol line 158: IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);          Deprecated safeApprove in NFTXStakingZap.sol line 170: IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);          Deprecated safeApprove in NFTXStakingZap.sol line 383: IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);          Deprecated safeApprove in NFTXStakingZap.sol line 397: IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);          Deprecated safeApprove in PalmNFTXStakingZap.sol line 166: IERC20Upgradeable(address(_pairedToken)).approve(_sushiRouter, type(uint256).max);          Deprecated safeApprove in PalmNFTXStakingZap.sol line 298: IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);          Deprecated safeApprove in PalmNFTXStakingZap.sol line 312: IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);          Deprecated safeApprove in NFTXFlashSwipe.sol line 56: IERC20Upgradeable(vault).approve(address(vault), allowance + count);   
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           IPrevNftxContract.sol, line 4, import "./IERC165Upgradeable.sol";         NFTXEligibilityManager.sol, line 5, import "./interface/INFTXVaultFactory.sol";         NFTXInventoryStaking.sol, line 6, import "./interface/INFTXFeeDistributor.sol";         NFTXInventoryStaking.sol, line 10, import "./token/IERC721Upgradeable.sol";         NFTXInventoryStaking.sol, line 11, import "./token/IERC1155Upgradeable.sol";         NFTXInventoryStaking.sol, line 16, import "./proxy/Initializable.sol";         NFTXLPStaking.sol, line 5, import "./interface/INFTXFeeDistributor.sol";         NFTXLPStaking.sol, line 12, import "./proxy/Initializable.sol";         NFTXMarketplaceZap.sol, line 8, import "./interface/ITimelockRewardDistributionToken.sol";         NFTXMarketplaceZap.sol, line 10, import "./testing/IERC721.sol";         NFTXMarketplaceZap.sol, line 15, import "./util/OwnableUpgradeable.sol";         NFTXSimpleFeeDistributor.sol, line 10, import "./util/SafeMathUpgradeable.sol";         NFTXStakingZap.sol, line 9, import "./interface/ITimelockRewardDistributionToken.sol";         NFTXStakingZap.sol, line 11, import "./testing/IERC721.sol";         NFTXStakingZap.sol, line 16, import "./util/OwnableUpgradeable.sol";         NFTXVaultFactoryUpgradeable.sol, line 5, import "./interface/INFTXLPStaking.sol";         NFTXVaultFactoryUpgradeable.sol, line 7, import "./proxy/ClonesUpgradeable.sol";         NFTXVaultUpgradeable.sol, line 8, import "./interface/INFTXLPStaking.sol";         NFTXVaultUpgradeable.sol, line 10, import "./interface/IERC165Upgradeable.sol";         PalmNFTXStakingZap.sol, line 15, import "../util/OwnableUpgradeable.sol";         StakingTokenProvider.sol, line 7, import "./token/IERC20Upgradeable.sol";         ERC20FlashMintUpgradeable.sol, line 4, import "../interface/IERC3156Upgradeable.sol";         RewardDistributionTokenUpgradeable.sol, line 5, import "../interface/IRewardDistributionToken.sol";         RewardDistributionTokenUpgradeable.sol, line 11, import "hardhat/console.sol";         TimelockRewardDistributionTokenImpl.sol, line 5, import "../interface/IRewardDistributionToken.sol";         NFTXFlashSwipe.sol, line 4, import "../interface/IERC3156Upgradeable.sol";         PausableUpgradeable.sol, line 5, import "./SafeMathUpgradeable.sol";    
# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXMarketplaceZap.sol contract, the buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the _buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail.  ``` function buyAndSwap1155WETH(   uint256 vaultId,   uint256[] memory idsIn,   uint256[] memory amounts,   uint256[] memory specificIds,   uint256 maxWethIn,   address[] calldata path,   address to ) public payable nonReentrant {   require(to != address(0));   require(idsIn.length != 0);   IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);   uint256 count;   for (uint256 i = 0; i <idsIn.length; i++) {       uint256 amount = amounts[i];       require(amount> 0, "Transferring <1");       count += amount;   }   INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));   uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (       vault.randomSwapFee() * (count-specificIds.length)   );   uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path); ```  In extreme cases, when the user provides both ETH and WETH (the user approves the contract WETH in advance and calls the buyAndSwap1155WETH function instead of the buyAndSwap1155 function by mistake), the _buyVaultToken function will execute successfully, but because the buyAndSwap1155WETH function will not convert ETH to WETH, The user’s ETH will be locked in the contract, causing loss of user assets.  ```    function _buyVaultToken(      address vault,      uint256 minTokenOut,      uint256 maxWethIn,      address[] calldata path    ) internal returns (uint256[] memory) {      uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(        minTokenOut,        maxWethIn,        path,        address(this),        block.timestamp      );       return amounts;    } ```   ## Tools Used  Manual audit  ## Recommended Mitigation Steps   ``` - uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path); + uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path); ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  In the function `_sellVaultTokenETH`, the parameter `minWethOut` should be `minEthOut`  ## Recommended Mitigation Steps  Replace `minWethOut` with `minEthOut`  
# Handle  GreyArt   # Vulnerability details  ## Impact  The MarketplaceZap contract conducts a sanity check on the `to` address. One can therefore expect that this check is in place for the StakingZap contract as well.  We also suggest adding another check to ensure that the `to` address is not the StakingZap contract itself. Although there is a `rescue()` function to retrieve funds in these cases, it would be a hassle to do so.   ## Recommended Mitigation Steps  Include the sanity check(s) of the `to` address in the `addLiquidity*()` functions.  ```jsx require(to != address(0) && to != address(this)); ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  A `rescue()` function exists for the StakingZap contract to help retrieve any accidental fund transfer to it. It would be beneficial to have this function exist in the MarketplaceZap contract too.  ## Recommended Mitigation Steps  Include the `rescue()` function.  ```jsx function rescue(address token) external onlyOwner {  IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this))); } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  Native fund transfers into the zap contract are only expected from the WETH contract. Hence, it would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  This is also true even though `sushiRouter.swapExactTokensForETH()` is called, as the recipient of the swap is expected to not be the marketplace zap contract.  ## Recommended Mitigation Steps  Modify the `receive()` function to only accept transfers from the wrapped token contract.  ```jsx receive() external payable {   require(msg.sender == address(WETH), "Only WETH"); } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  In the `_sendForReceiver()` function, there are 2 comments: `// If the receive is not properly processed, send it to the treasury instead.`   and  `// If the allowance has not been spent, it means we can pass it forward to next`  which are contradictory in nature, except for the case of the last receiver in the feeReceivers array.  Looking at the `distribute()` function implementation, should the `receiveRewards()` function return false, fail, or if the `transferFrom()` was not called in its implementation, the rewards will be given to the next receiver, and not the treasury.  ```jsx // Note: some irrelevant lines were omitted for (uint256 i = 0; i < length; i++) {   uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);   bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);   if (!complete) {     leftover = amountToSend;   } else {     leftover = 0;  } } ```  ## Recommended Mitigation Steps  Based on the implementation, the comment `// If the receive is not properly processed, send it to the treasury instead.` should be edited or removed.  
# Handle  GreyArt   # Vulnerability details  ## Impact  From what we understand, the contracts upgrade will be performed in place, where the relevant current proxies will be pointing to the new implementations. An important restriction when doing so is that the order of which the contract state variables are declared, and their types **must be preserved.** More information can be found in [OpenZeppelin’s documentation](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts).  For the NFTXLPStaking contract, the [version of the May contest review](https://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol) was:  ```jsx contract NFTXLPStaking is OwnableUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable;      INFTXVaultFactory public nftxVaultFactory;     INFTXFeeDistributor public feeDistributor;     RewardDistributionTokenUpgradeable public rewardDistTokenImpl;     StakingTokenProvider public stakingTokenProvider;      event PoolCreated(uint256 vaultId, address pool);     event PoolUpdated(uint256 vaultId, address pool);     event FeesReceived(uint256 vaultId, uint256 amount);      struct StakingPool {         address stakingToken;         address rewardToken;     }     mapping(uint256 => StakingPool) public vaultStakingInfo;      function __NFTXLPStaking__init(address _stakingTokenProvider) external initializer { ... ```  while the new version is  ```jsx contract NFTXLPStaking is PausableUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable;      INFTXVaultFactory public nftxVaultFactory;     IRewardDistributionToken public rewardDistTokenImpl;     StakingTokenProvider public stakingTokenProvider;      event PoolCreated(uint256 vaultId, address pool);     event PoolUpdated(uint256 vaultId, address pool);     event FeesReceived(uint256 vaultId, uint256 amount);      struct StakingPool {         address stakingToken;         address rewardToken;     }     mapping(uint256 => StakingPool) public vaultStakingInfo;      TimelockRewardDistributionTokenImpl public newTimelockRewardDistTokenImpl;      function __NFTXLPStaking__init(address _stakingTokenProvider) external initializer { ... ```  Note that the `feeDistributor` has been removed. Also note that a new base contract has been added (`PausableUpgradeable` which inherits `OwnableUpgradeable`), which has 2 mappings `isGuardian` and `isPaused`.   We however note that the current `NFTXLPStaking` implementation at [`https://etherscan.io/address/0xa64c2f3f965f055e51482bf0960ebb5f2904bf68#code`](https://etherscan.io/address/0xa64c2f3f965f055e51482bf0960ebb5f2904bf68#code) is a more recent version than that of the previous contest review. There is no change in the storage layout between this deployed version against the one being reviewed.  The ordering of state variables is determined by the C3-linearized order of contracts, so there does not seem to have been any storage collision with the change from `OwnableUpgradeable` to `PausableUpgradeable`. It also appears that the public variables are returning expected values.  ## Recommended Mitigation Steps  Upgrading implementations are a tricky affair. It is highly recommended to use tools like OpenZeppelin’s upgrade plugins that validate that the new implementation is upgrade safe and is compatible with the previous one.  
# Handle  GreyArt   # Vulnerability details  ## Impact  `xTokensMinted` is assigned in `provideInventory721()` and `provideInventory1155()`, but is unused.  ## Recommended Mitigation Steps  Remove the local variable `xTokensMinted`.  
# Handle  Dravee   # Vulnerability details  ## Impact Since the defined constants are unneeded elsewhere, it can be defined to be internal or private to save gas.  ## Proof of Concept ``` https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L28-L30 ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change the visibility from public to private or internal  
# Handle  pauliax   # Vulnerability details  ## Impact 'unchecked' directive can be used where an underflow/overflow cannot happen, e.g. here: ```solidity   if (amountEth < msg.value) {     WETH.withdraw(msg.value-amountEth);     payable(to).call{value: msg.value-amountEth};   } ``` Also, to reduce gas usage, ```msg.value-amountEth``` should be cached and not re-calculated several times.  
# Handle  Dravee   # Vulnerability details  ## Impact Explicit initialization with zero is not required for variable declaration because uints are 0 by default. Removing this will reduce contract size and save a bit of gas.  ## Proof of Concept Instances include: ``` ./NFTXEligibilityManager.sol:85:        for (uint256 i = 0; i < modulesCopy.length; i++) { ./NFTXLPStaking.sol:81:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXLPStaking.sol:206:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXMarketplaceZap.sol:263:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:297:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:379:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:399:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:414:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:437:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXSimpleFeeDistributor.sol:62:    for (uint256 i = 0; i < length; i++) {  { ./NFTXVaultUpgradeable.sol:364:        for (uint256 i = 0; i < len; i++) { ./NFTXVaultUpgradeable.sol:406:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:419:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:442:        for (uint256 i = 0; i < amount; i++) { ```  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove explicit initialization with zero.  
# Handle  PPrieditis   # Vulnerability details  ## Impact NFTXMarketplaceZap.sol function _buyVaultToken() has unused parameter "vault"  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L497  ## Recommended Mitigation Steps Remove parameter "vault" from _buyVaultToken() and update necessary _buyVaultToken() calls.  
# Handle  Dravee   # Vulnerability details  ## Impact `++i` costs less gass compared to `i++` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration)  ## Proof of Concept `i++` increments `i` and returns the initial value of `i`. Which means:  ``` uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ``` uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`  Instances include: ``` ./NFTXEligibilityManager.sol:85:        for (uint256 i = 0; i < modulesCopy.length; i++) { ./NFTXLPStaking.sol:81:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXLPStaking.sol:206:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXMarketplaceZap.sol:263:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:297:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:379:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:399:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:414:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:437:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXSimpleFeeDistributor.sol:62:    for (uint256 i = 0; i < length; i++) { ./NFTXStakingZap.sol:192:    for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXStakingZap.sol:203:    for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXStakingZap.sol:341:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXVaultUpgradeable.sol:267:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:406:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:419:            for (uint256 i = 0; i < tokenIds.length; i++) { ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use `++i` instead of `i++` to increment the value of an uint variable  
# Handle  Dravee   # Vulnerability details  ## Impact In Solidity, a `constant` expression in a variable will compute the expression everytime the variable is called. It's not the result of the expression that is stored, but the expression itself.  As Solidity supports the scientific notation, constants of form `10**X` can be rewritten as `1eX` to save the gas cost from the calculation with the exponentiation operator `**`.  ## Proof of Concept ``` NFTXInventoryStaking.sol:   28:     uint256 public constant BASE = 10**18;  NFTXMarketplaceZap.sol:   158:   uint256 constant BASE = 10**18;  NFTXStakingZap.sol:   163:   uint256 constant BASE = 10**18;  NFTXVaultUpgradeable.sol:   33:     uint256 constant base = 10**18; ```  ## Tools Used Vs Code  ## Recommended Mitigation Steps Replace `10**18` with `1e18`  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `vaultFactory` in `NFTXVaultUpgradeable#_chargeAndDistributeFees()`      https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L470-L484      ```solidity=470     function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {         // Do not charge fees if the zap contract is calling         // Added in v1.0.3. Changed to mapping in v1.0.5.         if (vaultFactory.excludedFromFees(msg.sender)) {             return;         }                  // Mint fees directly to the distributor and distribute.         if (amount > 0) {             address feeDistributor = vaultFactory.feeDistributor();             // Changed to a _transfer() in v1.0.3.             _transfer(user, feeDistributor, amount);             INFTXFeeDistributor(feeDistributor).distribute(vaultId);         }     }     ```  
# Handle  gzeon   # Vulnerability details  ## Impact Calculation of `xTokenAddr` can further save gas by caching the creation hash as a immutable state.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L136 ``` address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode)); ```  ## Recommended Mitigation Steps ```     bytes32 internal immutable beaconhash = keccak256(type(Create2BeaconProxy).creationCode);     function xTokenAddr(address baseToken) public view virtual override returns (address) {         bytes32 salt = keccak256(abi.encodePacked(baseToken));         address tokenAddr = Create2.computeAddress(salt, beaconhash);         return tokenAddr;     } ```  
# Handle  0x1f8b   # Vulnerability details  ## Impact Unsafe approve was done.  ## Proof of Concept In the method `NFTXSimpleFeeDistributor._sendForReceiver` it's made a approve without checking the boolean result, ERC20 standard specify that the token can return false if the approve was not made, so it's mandatory to check the result of approve methods.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use safe approve or check the boolean result  
# Handle  hyh   # Vulnerability details  ## Impact  `transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`. It transfers to `address(this)` instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is `to`).  ## Proof of Concept  NFTXStakingZap: transferFromERC721 https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L416  NFTXMarketplaceZap: transferFromERC721 https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L556  Both functions are called by user facing Marketplace buy/sell and Staking addLiquidity/provideInventory functions.  ## Recommended Mitigation Steps  Fix the address:  Now: ``` // Cryptokitties. data = abi.encodeWithSignature("transferFrom(address,address,uint256)", msg.sender, address(this), tokenId); ```  To be: ``` // Cryptokitties. data = abi.encodeWithSignature("transferFrom(address,address,uint256)", msg.sender, to, tokenId); ```   
# Handle  gzeon   # Vulnerability details  ## Impact `changeReceiverAlloc` did not check if the idx exists unlike other functions in the same contract  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L93 ```   function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {     FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];     allocTotal -= feeReceiver.allocPoint;     feeReceiver.allocPoint = _allocPoint;     allocTotal += _allocPoint;     emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);   } ```  ## Recommended Mitigation Steps ```require(_receiverIdx < feeReceivers.length, "FeeDistributor: Out of bounds");```  
# Handle  gzeon   # Vulnerability details  ## Impact The default value of `inventoryLockTime` in `NFTXStakingZap` is `7 days` while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock value are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in `XTokenUpgradeable`.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L74 ```     function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {         uint256 timelockFinish = block.timestamp + timelockLength;         timelock[account] = timelockFinish;         emit Timelocked(account, timelockFinish);         _mint(account, amount);     } ```  The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling `deposit` in `NFTXInventoryStaking`  ## Proof of Concept https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L160 https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L30  ## Recommended Mitigation Steps ```     function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {         uint256 timelockFinish = block.timestamp + timelockLength;         if(timelockFinish > timelock[account]){             timelock[account] = timelockFinish;             emit Timelocked(account, timelockFinish);         }         _mint(account, amount);     } ```  
# Handle  hyh   # Vulnerability details  ## Impact  `NFTXVaultFactory` contract holds information regarding vaults, assets and permissions (vaults, _vaultsForAsset and excludedFromFees mappings). As there is no mechanics present that transfers this information to another implementation, the switch of nftxVaultFactory to another address performed while in production will break the system.  ## Proof of Concept  `setNFTXVaultFactory` function allows an owner to reset `nftxVaultFactory` without restrictions in the following contracts:  NFTXLPStaking https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L59  NFTXInventoryStaking https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L51  NFTXSimpleFeeDistributor https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L135  ## Recommended Mitigation Steps  Either restrict the ability to change the factory implementation to pre-production stages or make `nftxVaultFactory` immutable by allowing changing it only once:  Now: ``` function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {   require(newFactory != address(0));   nftxVaultFactory = INFTXVaultFactory(newFactory); } ```  To be: ``` function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {   require(nftxVaultFactory == address(0), "nftxVaultFactory is immutable");   nftxVaultFactory = INFTXVaultFactory(newFactory); } ```  If the implementation upgrades in production is desired, the factory data migration logic should be implemented and then used atomically together with the implementation switch in all affected contracts.   
# Handle  pauliax   # Vulnerability details  ## Impact When emitting Sell event, it assumes that the path is always of length 2, as amounts[1] is used for the ethReceived parameter. However, the path does not have any restrictions on its length, so it is completely possible, that this is not the final amount. Events are used to inform the outside world and this may trick the consumers.  ## Recommended Mitigation Steps amounts[1] should be replaced with amounts[amounts.length - 1]  
# Handle  pauliax   # Vulnerability details  ## Impact Consider introducing a reasonable global upper limit for timelockLength in XTokenUpgradeable and TimelockRewardDistributionTokenImpl, so the users can't be locked out of their tokens forever.  ## Recommended Mitigation Steps XTokenUpgradeable and TimelockRewardDistributionTokenImpl should not trust the external input but have explicitly declared boundaries for values like timelock length to reduce possibilities of unexpected outcomes.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L247-L248  ```solidity=247 uint256 remaining = WETH.balanceOf(address(this)); WETH.transfer(to, remaining); ```  Since `WETH.balanceOf(address(this))` can to be `0`. Checking `if (remaining > 0)` before the transfer can potentially save an external call and the unnecessary gas cost of a 0 token transfer.  
# Handle  WatchPug   # Vulnerability details  Unused function parameters increase contract size and gas usage at deployment.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L496-L511  ```solidity=496   function _buyVaultToken(     address vault,      uint256 minTokenOut,      uint256 maxWethIn,      address[] calldata path   ) internal returns (uint256[] memory) {     uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(       minTokenOut,       maxWethIn,       path,        address(this),       block.timestamp     );      return amounts;   } ```  `vault` is unused.  
# Handle  WatchPug   # Vulnerability details  Unused local variables in contracts increase contract size and gas usage at deployment.  Instances include:  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L187-L187  ```solidity=187 uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime); ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L207-L207  ```solidity=207 uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime); ```  
# Handle  WatchPug   # Vulnerability details  Unused events increase contract size and gas usage at deployment.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/eligibility/NFTXMintRequestEligibility.sol#L62-L62  ```solidity event Reject(uint256[] nftIds); ```  `Reject` is unused.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L285-L290  ```solidity=285     function _deposit(StakingPool memory pool, uint256 amount) internal {         require(pool.stakingToken != address(0), "LPStaking: Nonexistent pool");         IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);         // Timelock for 2 seconds to prevent flash loans.         _rewardDistributionTokenAddr(pool).timelockMint(msg.sender, amount, 2);     } ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L124-L130  ```solidity=124     function deposit(uint256 vaultId, uint256 amount) external {         onlyOwnerIfPaused(10);         // Check the pool in case its been updated.         updatePoolForVault(vaultId);         StakingPool memory pool = vaultStakingInfo[vaultId];         _deposit(pool, amount);     } ```   `_deposit()` is unnecessary as it's being used only once. Therefore it can be inlined in `deposit()` to make the code simpler and save gas.  ## Recommendation  Change to:  ```solidity=124     function deposit(uint256 vaultId, uint256 amount) external {         onlyOwnerIfPaused(10);         // Check the pool in case its been updated.         updatePoolForVault(vaultId);         StakingPool memory pool = vaultStakingInfo[vaultId];          require(pool.stakingToken != address(0), "LPStaking: Nonexistent pool");         IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);         // Timelock for 2 seconds to prevent flash loans.         _rewardDistributionTokenAddr(pool).timelockMint(msg.sender, amount, 2);     } ```  Other examples include:  -   `NFTXFlashSwipe.sol#flashRedeem()`, `NFTXFlashSwipe.sol#flashMint()` can be inlined in `NFTXFlashSwipe.sol#onFlashLoan()` -   `UniswapV3SparkleEligibility.sol#isRare()` can be inlined in `UniswapV3SparkleEligibility.sol#_checkIfEligible()`   
# Handle  cmichel   # Vulnerability details  The comment in `TimelockRewardDistributionTokenImpl.burnFrom` says: > the caller must have allowance for ``accounts``'s tokens of at least `amount`.  This was the case in a previous version but not anymore. The owner does not need to be approved to burn tokens anymore.  ## Recommended Mitigation Steps Update the comment to clarify the behavior.   
# Handle  cmichel   # Vulnerability details  The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded.  ## Impact If the call fails, the refunds did not succeed and the caller will lose all refunds of `msg.value - amountEth`.  ## Recommended Mitigation Steps Revert the entire transaction if the refund call fails by checking that the `success` return value of the `payable(to).call(...)` returns `true`.  
# Handle  cmichel   # Vulnerability details  The `NFTXInventoryStaking` contract distributes new rewards to all previous stakers when the owner calls the `receiveRewards` function. This allows an attacker to frontrun this `receiveRewards` transaction when they see it in the mem pool with a `deposit` function. The attacker will receive the rewards pro-rata to their deposits. The deposit will be locked for 2 seconds only (`DEFAULT_LOCKTIME`) after which the depositor can withdraw their initial deposit & the rewards again for a profit.  The rewards can be gamed this way and one does not actually have to _stake_, only be in the staking contract at the time of reward distribution for 2 seconds. The rest of the time they can be used for other purposes.  ## Recommended Mitigation Steps Distribute the rewards equally over time to the stakers instead of in a single chunk on each `receiveRewards` call. This is more of a "streaming rewards" approach.   
# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) {   uint length = arr.length;   for (uint i = 0; i < arr.length; i++) {       sum += arr[i];   } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) {   uint length = arr.length;   for (uint i = 0; i < arr.length; i++) {       sum += arr[i];   } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L297`  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  Multiple internal functions do not have a name that starts with an underscore. The lack of clarity over the functions visibility could lead to misuse of these functions.  ## Proof of Concept Both the NFTXMarketplaceZap.sol and NFTXStakingZap.sol contracts have three internal functions names without underscores: approveERC721 in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L574 approveERC721 in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L434 pairFor in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L593 pairFor in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L453 sortTokens in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L604 sortTokens in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L464  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Rename internal functions following best practices to clarify function visibility  
# Handle  sirhashalot   # Vulnerability details  ## Impact  If two variables with the same name exist in a function, but one is imported from another contract while the other is created locally, it is unclear which value is being used or should be used. Avoiding variable name collisions avoids confusion and the risks of using the wrong variable.  https://swcregistry.io/docs/SWC-119  ## Proof of Concept  Several instance of this issue exist. 1. mintAndSell1155() function in NFTXMarketplaceZap.sol has `uint256[] memory amounts` as an input parameter and later it is redeclared in the function https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L368,L376 2. pauseFeeDistribution() function in NFTXSimpleFeeDistributor.sol uses a pause return bool which shadows PausableUpgradeable.pause https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L140 3. transferFromERC721() function in NFTXStakingZap.sol declares an `address owner` which shadows Ownable.owner(): https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L422 4. transferFromERC721() function in NFTXMarketplaceZap.sol declares an `address owner` which shadows Ownable.owner(): https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L562  ## Tools Used  Slither, shadowing-local detector: https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing  ## Recommended Mitigation Steps  Rename local variables to avoid shadowing. For instance, add an underscore in front of the name of local variables.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_sendForReceiver()` function only sets a return function in the "if" code block, not the "else" case. If the "else" case is true, no value is returned. The result of this oversight is that the `_sendForReceiver()` function called from the `distribute()` function could sucessfully enter its `else` block if a receiver has `isContract` set to False and successfully transfer the `amountToSend` value. The `ditribute()` function will then have `leftover > 0` and send `currentTokenBalance` to the treasury. This issue is partially due to [Solidity using implicit returns](https://github.com/ethereum/solidity/issues/2951), so if no bool value is explicitly returned, the default bool value of False will be returned.  This problem currently occurs for any receiver with `isContract` set to False. The `_addReceiver` function allows for `isContract` to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.  ## Proof of Concept  The `else` block is missing a return value https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L167-L169  ## Tools Used  VS Code "Solidity Visual Developer" extension  ## Recommended Mitigation Steps  Verify that functions with a return value do actually return a value in all cases. Adding the line `return true;` can be added to the end of the `else` block as one way to resolve this.  Alternatively, if `isContract` should never be set to False, the code should be designed to prevent a receiver from being added with this value.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `provideInventory1155()` function in contracts/solidity/NFTXStakingZap.sol contains a for loop that uses tokenIds.length to loop through the amounts array. However, if these two arrays are not the same length, the loop with trigger an error. The error could be triggered after many operations already occur, so checking that these two lengths are equal first could save gas.  ## Proof of Concept  The `provideInventory1155()` function contracts/solidity/NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L201  ## Recommended Mitigation Steps  There are two main options to reducing the gas spend in an error condition: 1. Add the following line as the first line of the `provideInventory1155()` function: `require(tokenIds.length == amounts.length)` 2. In the for loop within the `provideInventory1155()` function, replace `i < tokenIds.length` with `i < amounts.length;`  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The file contracts/solidity/testing/NFTXFeeDistributor2.sol references the old NFTXFeeDistributor.sol and instead should reference the new NFTXSimpleFeeDistributor.sol  ## Proof of Concept  The import and contract inheritance of contracts/solidity/testing/NFTXFeeDistributor2.sol  ## Tools Used  `npx hardhat test` fails due to this issue because the ../NFTXFeeDistributor.sol imported file is not found  ## Recommended Mitigation Steps  Reference the new NFTXSimpleFeeDistributor.sol and not NFTXFeeDistributor.sol in the import and contract inheritance  
# Handle  hyh   # Vulnerability details  ## Impact  deployXTokenForVault call will not revert on deploy failure.  ## Proof of Concept  NFTXInventoryStaking._deployXToken is called by deployXTokenForVault: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L64  _deployXToken uses deploy generated address without check: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L160  ## Recommended Mitigation Steps  Require non zero deployedXToken address before calling __XToken_init.  
# Handle  hyh   # Vulnerability details  # Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. mintTo and swapTo outcome will not be as expected by a caller.  ## Proof of Concept  The arrays are used whenever Vault is ERC1155, i.e. when is1155 is true.  swap -> swapTo uses the arrays as given: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L258  mint -> mintTo, arrays are passed on without checks to receiveNFTs: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L190  receiveNFTs uses the arrays in a loop, assuming equal lengths without a check: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L389  ## Recommended Mitigation Steps  Add `require(tokenIds.length == amounts.length, "tokenIds and amounts length should match")` check in the beginning of public mintTo and swapTo endpoints.   
# Handle  p4st13r4   # Vulnerability details  ## Impact  `XTokenUpgradeable.sol` contains many comments regarding SushiBar. It looks like the comments have been copy-pasted from another contract, and may be deceiving for a reader  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L14](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L14)  ## Tools Used  ## Recommended Mitigation Steps  Remove said comments  
# Handle  p4st13r4   # Vulnerability details  ## Impact  Detailed description of the impact of this finding.  Fee distribution algorithm in `NFTXSimpleFeeDistributor.sol` can led to unfair distribution of fees among receivers. The `_sendForReceiver` function returns `success = true` only when the call to receiver' `receiveRewards` is successful and the whole amount is transfered to the receiver. Otherwise, the entire fee is moved up to the next receiver, and finally to the treasury.  If a badly implemented receiver leaves a part of the fee (even 1 wei) to the fee distributor, the operation is considered unsuccessful and the entire amount of the fee is moved up to the next receiver. This could lead to the situation where one of the late receivers is unable to receive any fee at all, since some previous receiver has received more than it should have.  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L166](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L166)  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L69](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L69)  ## Tools Used  Editor  ## Recommended Mitigation Steps  `_sendForReceiver` should return a tuple: `(bool success, uint256 amountLeft)`. Then `amountLeft` should be used by `distribute` for the `leftover` variable  
# Handle  p4st13r4   # Vulnerability details  ## Impact  Any user that owns a vToken of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone.  Every operation performed by the marketplace, that deals with vToken minting, performs this check:  ```jsx require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), "Did not receive expected balance"); ```  A malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421)  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Remove this logic from the marketplace and staking zap contracts, and add it to the vaults (if necessary)  
# Handle  hyh   # Vulnerability details  # Impact  Double spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones. As `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.  ## Proof of Concept  `distribute` use `_sendForReceiver` to transfer current vault balance across `feeReceivers`: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L67  `_sendForReceiver` returns a boolean that is used to move current distribution amount to the next receiver when last transfer failed. When `_receiver.isContract` is `false` nothing is returned, while `safeTransfer` is done: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L168  This way `_sendForReceiver` will indicate that transfer is failed and leftover amount to be added to the next transfer, i.e. the `amountToSend` will be spent twice: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L64  ## Recommended Mitigation Steps  Now: ``` function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {  if (_receiver.isContract) {  ...  } else {   IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);  } } ```  To be: ``` function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {  if (_receiver.isContract) {  ...  } else {   IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);   return true;  } } ```  
# Handle  WatchPug   # Vulnerability details  Since the introduction of `transfer()`, it has typically been recommended by the security community because it helps guard against reentrancy attacks. This guidance made sense under the assumption that gas costs wouldn’t change. It's now recommended that transfer() and send() be avoided, as gas costs can and will change and reentrancy guard is more commonly used.  Any smart contract that uses `transfer()` is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.  It's recommended to stop using `transfer()` and switch to using `call()` instead.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXV1Buyout.sol#L44-L44  ```solidity payable(msg.sender).transfer(amount); ```  Can be changed to:  ```solidity (bool success, ) = msg.sender.call{value: amount}(""); require(success, "ETH transfer failed"); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L15-L15  ```solidity=15 contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable { ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L41-L47  ```solidity=41   function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {     __Pausable_init();     setTreasuryAddress(_treasury);     setLPStakingAddress(_lpStaking);      _addReceiver(0.8 ether, lpStaking, true);   } ```  For the upgradeable variants of OpenZipplin contracts, they should be initialized by calling the `__***_init()` function in the initializer function.  Therefore, `__SimpleFeeDistributor__init__()` should call `__ReentrancyGuard_init()` at L42.  
# Handle  WatchPug   # Vulnerability details  There are many functions across the codebase that will perform an ERC20.approve() call but does not check the success return value. Some tokens do not revert if the approval failed but return false instead.  Instances include:  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L167-L167  ```solidity=167 IERC20Upgradeable(address(_pairedToken)).approve(_sushiRouter, type(uint256).max); ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L313  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L299  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L519  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L538  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L159  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L398  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L171  It is usually good to add a require-statement that checks the return value or to use something like `safeApprove`; unless one is sure the given token reverts in case of a failure.  
# Handle  leastwood   # Vulnerability details  ## Impact  `TimelockRewardDistributionTokenImpl` calculates the accumulative reward according to the following function: ``` function accumulativeRewardOf(address _owner) public view returns(uint256) {   return magnifiedRewardPerShare.mul(balanceOf(_owner)).toInt256()     .add(magnifiedRewardCorrections[_owner]).toUint256Safe() / magnitude; } ```  The calculation takes into consideration the LP token balance of token holders. Hence, if the token holder has called `emergencyExit` or `withdraw` in `NFTXLPStaking`, the LP tokens are removed from the staking contract without claiming rewards prior to this action. Therefore, in order for users to claim their fair share of rewards they must restake LP tokens and call `claimRewards`.   Similarly, `_transfer` in `TimelockRewardDistributionTokenImpl` also does not force the `from` account to claim rewards first.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L195-L198 ``` function withdraw(uint256 vaultId, uint256 amount) external {     StakingPool memory pool = vaultStakingInfo[vaultId];     _withdraw(pool, amount, msg.sender); } ```  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L157-L162 ``` function emergencyExit(address _stakingToken, address _rewardToken) external {     StakingPool memory pool = StakingPool(_stakingToken, _rewardToken);     TimelockRewardDistributionTokenImpl dist = _rewardDistributionTokenAddr(pool);     require(isContract(address(dist)), "Not a pool");     _withdraw(pool, dist.balanceOf(msg.sender), msg.sender); } ```  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/TimelockRewardDistributionTokenImpl.sol#L199-L206 ``` function _transfer(address from, address to, uint256 value) internal override {   require(block.timestamp > timelock[from], "User locked");   super._transfer(from, to, value);    int256 _magCorrection = magnifiedRewardPerShare.mul(value).toInt256();   magnifiedRewardCorrections[from] = magnifiedRewardCorrections[from].add(_magCorrection);   magnifiedRewardCorrections[to] = magnifiedRewardCorrections[to].sub(_magCorrection); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing functions in `NFTXLPStaking` that do not claim token rewards before unstaking LP tokens or alternatively add code to the affected functions such that rewards are claimed before withdrawing LP tokens.  
# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the _sendForReceiver function to distribute the fee  ```   function distribute(uint256 vaultId) external override virtual nonReentrant {     require(nftxVaultFactory != address(0));     address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);      uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));      if (distributionPaused || allocTotal == 0) {       IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);       return;     }      uint256 length = feeReceivers.length;     uint256 leftover;     for (uint256 i = 0; i <length; i++) {       FeeReceiver memory _feeReceiver = feeReceivers[i];       uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);       uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));       amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;       bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);       if (!complete) {         leftover = amountToSend;       } else {         leftover = 0;       }     } ```  In the _sendForReceiver function, when the _receiver is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success,) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ```  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L166  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  The contract can store the fee sent to the receiver in a state variable, and then the receiver can take it out by calling a function.  
# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXSimpleFeeDistributor.sol contract, the distribute function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the _sendForReceiver function.  ```   function distribute(uint256 vaultId) external override virtual nonReentrant {     require(nftxVaultFactory != address(0));     address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);      uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));      if (distributionPaused || allocTotal == 0) {       IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);       return;     }      uint256 length = feeReceivers.length;     uint256 leftover;     for (uint256 i = 0; i <length; i++) {       FeeReceiver memory _feeReceiver = feeReceivers[i];       uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);       uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));       amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;       bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);       if (!complete) {         leftover = amountToSend;       } else {         leftover = 0;       }     } ```  In the _sendForReceiver function, when _receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success,) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ``` ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L168  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L49-L67  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success, ) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       - IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);       + return IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ```  
# Handle  leastwood   # Vulnerability details  ## Impact  `assignDefaultFeatures` is intended to be called by the `dev` account, however, the function itself does not take in any arguments and instead sets the `enableRandomSwap` and `enableTargetSwap` state variables to itself.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L111-L117 ``` function assignDefaultFeatures() external {     require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, "Not dev");     enableRandomSwap = enableRandomRedeem;     enableTargetSwap = enableTargetRedeem;     emit EnableRandomSwapUpdated(enableRandomSwap);     emit EnableTargetSwapUpdated(enableTargetSwap); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing this function altogether or adding the necessary arguments such that the `dev` account can actually set the proper state variables.  
# Handle  ych18   # Vulnerability details  In If the Vault owner decides to set factoryMintFee and factoryRandomRedeemFee to zero, any user could call the function NFTXVaultFactoryUpgradeable.assignFees() and hence all the fees are updated.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping `ERC1155` tokens within a single transaction. The function expects to transfer `WETH` tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in `buyAndSwap1155WETH` actually uses `msg.value` and not `maxWethIn`. As a result, the function will not work unless the user supplies both `WETH` and native `ETH` amounts, equivalent to the `maxWethIn` amount.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L284-L314 ``` function buyAndSwap1155WETH(   uint256 vaultId,    uint256[] memory idsIn,    uint256[] memory amounts,    uint256[] memory specificIds,    uint256 maxWethIn,    address[] calldata path,   address to ) public payable nonReentrant {   require(to != address(0));   require(idsIn.length != 0);   IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);   uint256 count;   for (uint256 i = 0; i < idsIn.length; i++) {       uint256 amount = amounts[i];       require(amount > 0, "Transferring < 1");       count += amount;   }   INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));   uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (       vault.randomSwapFee() * (count - specificIds.length)   );   uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);   _swap1155(vaultId, idsIn, amounts, specificIds, to);    emit Swap(count, swapAmounts[0], to);    // Return extras.   uint256 remaining = WETH.balanceOf(address(this));   WETH.transfer(to, remaining); } ```  ## Tools Used  Manual code review. Discussions with Kiwi.  ## Recommended Mitigation Steps  Consider updating the `buyAndSwap1155WETH` function such that the following line of code is used instead of [this](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L306).  ``` uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path); ```  
# Handle  robee   # Vulnerability details  Need to use safeTransfer instead of transfer. As there are popular tokens, such as USDT that transfer/trasnferFrom method doesn’t return anything. The transfer return value has to be checked (as there are some other tokens that returns false instead revert), that means you must   1. Check the transfer return value Another popular possibility is to add a whiteList. Those are the appearances (solidity file, line number, actual line):          NFTXStakingZap.sol, 401, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);          NFTXStakingZap.sol, 474, IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));          PalmNFTXStakingZap.sol, 190, pairedToken.transferFrom(msg.sender, address(this), wethIn);          PalmNFTXStakingZap.sol, 195, pairedToken.transfer(to, wethIn-amountEth);          PalmNFTXStakingZap.sol, 219, pairedToken.transferFrom(msg.sender, address(this), wethIn);          PalmNFTXStakingZap.sol, 224, pairedToken.transfer(to, wethIn-amountEth);          PalmNFTXStakingZap.sol, 316, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);          XTokenUpgradeable.sol, 54, baseToken.transfer(who, what);          NFTXFlashSwipe.sol, 51, IERC20Upgradeable(vault).transferFrom(msg.sender, address(this), mintFee + targetRedeemFee);    
# Handle  robee   # Vulnerability details          Deprecated safeApprove in NFTXMarketplaceZap.sol line 518: IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);          Deprecated safeApprove in NFTXMarketplaceZap.sol line 537: IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);          Deprecated safeApprove in NFTXSimpleFeeDistributor.sol line 158: IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);          Deprecated safeApprove in NFTXStakingZap.sol line 170: IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);          Deprecated safeApprove in NFTXStakingZap.sol line 383: IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);          Deprecated safeApprove in NFTXStakingZap.sol line 397: IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);          Deprecated safeApprove in PalmNFTXStakingZap.sol line 166: IERC20Upgradeable(address(_pairedToken)).approve(_sushiRouter, type(uint256).max);          Deprecated safeApprove in PalmNFTXStakingZap.sol line 298: IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);          Deprecated safeApprove in PalmNFTXStakingZap.sol line 312: IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);          Deprecated safeApprove in NFTXFlashSwipe.sol line 56: IERC20Upgradeable(vault).approve(address(vault), allowance + count);   
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           IPrevNftxContract.sol, line 4, import "./IERC165Upgradeable.sol";         NFTXEligibilityManager.sol, line 5, import "./interface/INFTXVaultFactory.sol";         NFTXInventoryStaking.sol, line 6, import "./interface/INFTXFeeDistributor.sol";         NFTXInventoryStaking.sol, line 10, import "./token/IERC721Upgradeable.sol";         NFTXInventoryStaking.sol, line 11, import "./token/IERC1155Upgradeable.sol";         NFTXInventoryStaking.sol, line 16, import "./proxy/Initializable.sol";         NFTXLPStaking.sol, line 5, import "./interface/INFTXFeeDistributor.sol";         NFTXLPStaking.sol, line 12, import "./proxy/Initializable.sol";         NFTXMarketplaceZap.sol, line 8, import "./interface/ITimelockRewardDistributionToken.sol";         NFTXMarketplaceZap.sol, line 10, import "./testing/IERC721.sol";         NFTXMarketplaceZap.sol, line 15, import "./util/OwnableUpgradeable.sol";         NFTXSimpleFeeDistributor.sol, line 10, import "./util/SafeMathUpgradeable.sol";         NFTXStakingZap.sol, line 9, import "./interface/ITimelockRewardDistributionToken.sol";         NFTXStakingZap.sol, line 11, import "./testing/IERC721.sol";         NFTXStakingZap.sol, line 16, import "./util/OwnableUpgradeable.sol";         NFTXVaultFactoryUpgradeable.sol, line 5, import "./interface/INFTXLPStaking.sol";         NFTXVaultFactoryUpgradeable.sol, line 7, import "./proxy/ClonesUpgradeable.sol";         NFTXVaultUpgradeable.sol, line 8, import "./interface/INFTXLPStaking.sol";         NFTXVaultUpgradeable.sol, line 10, import "./interface/IERC165Upgradeable.sol";         PalmNFTXStakingZap.sol, line 15, import "../util/OwnableUpgradeable.sol";         StakingTokenProvider.sol, line 7, import "./token/IERC20Upgradeable.sol";         ERC20FlashMintUpgradeable.sol, line 4, import "../interface/IERC3156Upgradeable.sol";         RewardDistributionTokenUpgradeable.sol, line 5, import "../interface/IRewardDistributionToken.sol";         RewardDistributionTokenUpgradeable.sol, line 11, import "hardhat/console.sol";         TimelockRewardDistributionTokenImpl.sol, line 5, import "../interface/IRewardDistributionToken.sol";         NFTXFlashSwipe.sol, line 4, import "../interface/IERC3156Upgradeable.sol";         PausableUpgradeable.sol, line 5, import "./SafeMathUpgradeable.sol";    
# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXMarketplaceZap.sol contract, the buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the _buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail.  ``` function buyAndSwap1155WETH(   uint256 vaultId,   uint256[] memory idsIn,   uint256[] memory amounts,   uint256[] memory specificIds,   uint256 maxWethIn,   address[] calldata path,   address to ) public payable nonReentrant {   require(to != address(0));   require(idsIn.length != 0);   IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);   uint256 count;   for (uint256 i = 0; i <idsIn.length; i++) {       uint256 amount = amounts[i];       require(amount> 0, "Transferring <1");       count += amount;   }   INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));   uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (       vault.randomSwapFee() * (count-specificIds.length)   );   uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path); ```  In extreme cases, when the user provides both ETH and WETH (the user approves the contract WETH in advance and calls the buyAndSwap1155WETH function instead of the buyAndSwap1155 function by mistake), the _buyVaultToken function will execute successfully, but because the buyAndSwap1155WETH function will not convert ETH to WETH, The user’s ETH will be locked in the contract, causing loss of user assets.  ```    function _buyVaultToken(      address vault,      uint256 minTokenOut,      uint256 maxWethIn,      address[] calldata path    ) internal returns (uint256[] memory) {      uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(        minTokenOut,        maxWethIn,        path,        address(this),        block.timestamp      );       return amounts;    } ```   ## Tools Used  Manual audit  ## Recommended Mitigation Steps   ``` - uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path); + uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path); ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  In the function `_sellVaultTokenETH`, the parameter `minWethOut` should be `minEthOut`  ## Recommended Mitigation Steps  Replace `minWethOut` with `minEthOut`  
# Handle  GreyArt   # Vulnerability details  ## Impact  The MarketplaceZap contract conducts a sanity check on the `to` address. One can therefore expect that this check is in place for the StakingZap contract as well.  We also suggest adding another check to ensure that the `to` address is not the StakingZap contract itself. Although there is a `rescue()` function to retrieve funds in these cases, it would be a hassle to do so.   ## Recommended Mitigation Steps  Include the sanity check(s) of the `to` address in the `addLiquidity*()` functions.  ```jsx require(to != address(0) && to != address(this)); ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  A `rescue()` function exists for the StakingZap contract to help retrieve any accidental fund transfer to it. It would be beneficial to have this function exist in the MarketplaceZap contract too.  ## Recommended Mitigation Steps  Include the `rescue()` function.  ```jsx function rescue(address token) external onlyOwner {  IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this))); } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  Native fund transfers into the zap contract are only expected from the WETH contract. Hence, it would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  This is also true even though `sushiRouter.swapExactTokensForETH()` is called, as the recipient of the swap is expected to not be the marketplace zap contract.  ## Recommended Mitigation Steps  Modify the `receive()` function to only accept transfers from the wrapped token contract.  ```jsx receive() external payable {   require(msg.sender == address(WETH), "Only WETH"); } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  In the `_sendForReceiver()` function, there are 2 comments: `// If the receive is not properly processed, send it to the treasury instead.`   and  `// If the allowance has not been spent, it means we can pass it forward to next`  which are contradictory in nature, except for the case of the last receiver in the feeReceivers array.  Looking at the `distribute()` function implementation, should the `receiveRewards()` function return false, fail, or if the `transferFrom()` was not called in its implementation, the rewards will be given to the next receiver, and not the treasury.  ```jsx // Note: some irrelevant lines were omitted for (uint256 i = 0; i < length; i++) {   uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);   bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);   if (!complete) {     leftover = amountToSend;   } else {     leftover = 0;  } } ```  ## Recommended Mitigation Steps  Based on the implementation, the comment `// If the receive is not properly processed, send it to the treasury instead.` should be edited or removed.  
# Handle  GreyArt   # Vulnerability details  ## Impact  From what we understand, the contracts upgrade will be performed in place, where the relevant current proxies will be pointing to the new implementations. An important restriction when doing so is that the order of which the contract state variables are declared, and their types **must be preserved.** More information can be found in [OpenZeppelin’s documentation](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts).  For the NFTXLPStaking contract, the [version of the May contest review](https://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol) was:  ```jsx contract NFTXLPStaking is OwnableUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable;      INFTXVaultFactory public nftxVaultFactory;     INFTXFeeDistributor public feeDistributor;     RewardDistributionTokenUpgradeable public rewardDistTokenImpl;     StakingTokenProvider public stakingTokenProvider;      event PoolCreated(uint256 vaultId, address pool);     event PoolUpdated(uint256 vaultId, address pool);     event FeesReceived(uint256 vaultId, uint256 amount);      struct StakingPool {         address stakingToken;         address rewardToken;     }     mapping(uint256 => StakingPool) public vaultStakingInfo;      function __NFTXLPStaking__init(address _stakingTokenProvider) external initializer { ... ```  while the new version is  ```jsx contract NFTXLPStaking is PausableUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable;      INFTXVaultFactory public nftxVaultFactory;     IRewardDistributionToken public rewardDistTokenImpl;     StakingTokenProvider public stakingTokenProvider;      event PoolCreated(uint256 vaultId, address pool);     event PoolUpdated(uint256 vaultId, address pool);     event FeesReceived(uint256 vaultId, uint256 amount);      struct StakingPool {         address stakingToken;         address rewardToken;     }     mapping(uint256 => StakingPool) public vaultStakingInfo;      TimelockRewardDistributionTokenImpl public newTimelockRewardDistTokenImpl;      function __NFTXLPStaking__init(address _stakingTokenProvider) external initializer { ... ```  Note that the `feeDistributor` has been removed. Also note that a new base contract has been added (`PausableUpgradeable` which inherits `OwnableUpgradeable`), which has 2 mappings `isGuardian` and `isPaused`.   We however note that the current `NFTXLPStaking` implementation at [`https://etherscan.io/address/0xa64c2f3f965f055e51482bf0960ebb5f2904bf68#code`](https://etherscan.io/address/0xa64c2f3f965f055e51482bf0960ebb5f2904bf68#code) is a more recent version than that of the previous contest review. There is no change in the storage layout between this deployed version against the one being reviewed.  The ordering of state variables is determined by the C3-linearized order of contracts, so there does not seem to have been any storage collision with the change from `OwnableUpgradeable` to `PausableUpgradeable`. It also appears that the public variables are returning expected values.  ## Recommended Mitigation Steps  Upgrading implementations are a tricky affair. It is highly recommended to use tools like OpenZeppelin’s upgrade plugins that validate that the new implementation is upgrade safe and is compatible with the previous one.  
# Handle  GreyArt   # Vulnerability details  ## Impact  `xTokensMinted` is assigned in `provideInventory721()` and `provideInventory1155()`, but is unused.  ## Recommended Mitigation Steps  Remove the local variable `xTokensMinted`.  
# Handle  Dravee   # Vulnerability details  ## Impact Since the defined constants are unneeded elsewhere, it can be defined to be internal or private to save gas.  ## Proof of Concept ``` https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L28-L30 ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change the visibility from public to private or internal  
# Handle  pauliax   # Vulnerability details  ## Impact 'unchecked' directive can be used where an underflow/overflow cannot happen, e.g. here: ```solidity   if (amountEth < msg.value) {     WETH.withdraw(msg.value-amountEth);     payable(to).call{value: msg.value-amountEth};   } ``` Also, to reduce gas usage, ```msg.value-amountEth``` should be cached and not re-calculated several times.  
# Handle  Dravee   # Vulnerability details  ## Impact Explicit initialization with zero is not required for variable declaration because uints are 0 by default. Removing this will reduce contract size and save a bit of gas.  ## Proof of Concept Instances include: ``` ./NFTXEligibilityManager.sol:85:        for (uint256 i = 0; i < modulesCopy.length; i++) { ./NFTXLPStaking.sol:81:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXLPStaking.sol:206:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXMarketplaceZap.sol:263:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:297:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:379:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:399:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:414:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:437:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXSimpleFeeDistributor.sol:62:    for (uint256 i = 0; i < length; i++) {  { ./NFTXVaultUpgradeable.sol:364:        for (uint256 i = 0; i < len; i++) { ./NFTXVaultUpgradeable.sol:406:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:419:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:442:        for (uint256 i = 0; i < amount; i++) { ```  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove explicit initialization with zero.  
# Handle  PPrieditis   # Vulnerability details  ## Impact NFTXMarketplaceZap.sol function _buyVaultToken() has unused parameter "vault"  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L497  ## Recommended Mitigation Steps Remove parameter "vault" from _buyVaultToken() and update necessary _buyVaultToken() calls.  
# Handle  Dravee   # Vulnerability details  ## Impact `++i` costs less gass compared to `i++` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration)  ## Proof of Concept `i++` increments `i` and returns the initial value of `i`. Which means:  ``` uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ``` uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`  Instances include: ``` ./NFTXEligibilityManager.sol:85:        for (uint256 i = 0; i < modulesCopy.length; i++) { ./NFTXLPStaking.sol:81:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXLPStaking.sol:206:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXMarketplaceZap.sol:263:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:297:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:379:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:399:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:414:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:437:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXSimpleFeeDistributor.sol:62:    for (uint256 i = 0; i < length; i++) { ./NFTXStakingZap.sol:192:    for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXStakingZap.sol:203:    for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXStakingZap.sol:341:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXVaultUpgradeable.sol:267:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:406:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:419:            for (uint256 i = 0; i < tokenIds.length; i++) { ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use `++i` instead of `i++` to increment the value of an uint variable  
# Handle  Dravee   # Vulnerability details  ## Impact In Solidity, a `constant` expression in a variable will compute the expression everytime the variable is called. It's not the result of the expression that is stored, but the expression itself.  As Solidity supports the scientific notation, constants of form `10**X` can be rewritten as `1eX` to save the gas cost from the calculation with the exponentiation operator `**`.  ## Proof of Concept ``` NFTXInventoryStaking.sol:   28:     uint256 public constant BASE = 10**18;  NFTXMarketplaceZap.sol:   158:   uint256 constant BASE = 10**18;  NFTXStakingZap.sol:   163:   uint256 constant BASE = 10**18;  NFTXVaultUpgradeable.sol:   33:     uint256 constant base = 10**18; ```  ## Tools Used Vs Code  ## Recommended Mitigation Steps Replace `10**18` with `1e18`  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `vaultFactory` in `NFTXVaultUpgradeable#_chargeAndDistributeFees()`      https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L470-L484      ```solidity=470     function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {         // Do not charge fees if the zap contract is calling         // Added in v1.0.3. Changed to mapping in v1.0.5.         if (vaultFactory.excludedFromFees(msg.sender)) {             return;         }                  // Mint fees directly to the distributor and distribute.         if (amount > 0) {             address feeDistributor = vaultFactory.feeDistributor();             // Changed to a _transfer() in v1.0.3.             _transfer(user, feeDistributor, amount);             INFTXFeeDistributor(feeDistributor).distribute(vaultId);         }     }     ```  
# Handle  gzeon   # Vulnerability details  ## Impact Calculation of `xTokenAddr` can further save gas by caching the creation hash as a immutable state.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L136 ``` address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode)); ```  ## Recommended Mitigation Steps ```     bytes32 internal immutable beaconhash = keccak256(type(Create2BeaconProxy).creationCode);     function xTokenAddr(address baseToken) public view virtual override returns (address) {         bytes32 salt = keccak256(abi.encodePacked(baseToken));         address tokenAddr = Create2.computeAddress(salt, beaconhash);         return tokenAddr;     } ```  
# Handle  0x1f8b   # Vulnerability details  ## Impact Unsafe approve was done.  ## Proof of Concept In the method `NFTXSimpleFeeDistributor._sendForReceiver` it's made a approve without checking the boolean result, ERC20 standard specify that the token can return false if the approve was not made, so it's mandatory to check the result of approve methods.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use safe approve or check the boolean result  
# Handle  hyh   # Vulnerability details  ## Impact  `transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`. It transfers to `address(this)` instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is `to`).  ## Proof of Concept  NFTXStakingZap: transferFromERC721 https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L416  NFTXMarketplaceZap: transferFromERC721 https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L556  Both functions are called by user facing Marketplace buy/sell and Staking addLiquidity/provideInventory functions.  ## Recommended Mitigation Steps  Fix the address:  Now: ``` // Cryptokitties. data = abi.encodeWithSignature("transferFrom(address,address,uint256)", msg.sender, address(this), tokenId); ```  To be: ``` // Cryptokitties. data = abi.encodeWithSignature("transferFrom(address,address,uint256)", msg.sender, to, tokenId); ```   
# Handle  gzeon   # Vulnerability details  ## Impact `changeReceiverAlloc` did not check if the idx exists unlike other functions in the same contract  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L93 ```   function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {     FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];     allocTotal -= feeReceiver.allocPoint;     feeReceiver.allocPoint = _allocPoint;     allocTotal += _allocPoint;     emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);   } ```  ## Recommended Mitigation Steps ```require(_receiverIdx < feeReceivers.length, "FeeDistributor: Out of bounds");```  
# Handle  gzeon   # Vulnerability details  ## Impact The default value of `inventoryLockTime` in `NFTXStakingZap` is `7 days` while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock value are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in `XTokenUpgradeable`.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L74 ```     function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {         uint256 timelockFinish = block.timestamp + timelockLength;         timelock[account] = timelockFinish;         emit Timelocked(account, timelockFinish);         _mint(account, amount);     } ```  The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling `deposit` in `NFTXInventoryStaking`  ## Proof of Concept https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L160 https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L30  ## Recommended Mitigation Steps ```     function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {         uint256 timelockFinish = block.timestamp + timelockLength;         if(timelockFinish > timelock[account]){             timelock[account] = timelockFinish;             emit Timelocked(account, timelockFinish);         }         _mint(account, amount);     } ```  
# Handle  hyh   # Vulnerability details  ## Impact  `NFTXVaultFactory` contract holds information regarding vaults, assets and permissions (vaults, _vaultsForAsset and excludedFromFees mappings). As there is no mechanics present that transfers this information to another implementation, the switch of nftxVaultFactory to another address performed while in production will break the system.  ## Proof of Concept  `setNFTXVaultFactory` function allows an owner to reset `nftxVaultFactory` without restrictions in the following contracts:  NFTXLPStaking https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L59  NFTXInventoryStaking https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L51  NFTXSimpleFeeDistributor https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L135  ## Recommended Mitigation Steps  Either restrict the ability to change the factory implementation to pre-production stages or make `nftxVaultFactory` immutable by allowing changing it only once:  Now: ``` function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {   require(newFactory != address(0));   nftxVaultFactory = INFTXVaultFactory(newFactory); } ```  To be: ``` function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {   require(nftxVaultFactory == address(0), "nftxVaultFactory is immutable");   nftxVaultFactory = INFTXVaultFactory(newFactory); } ```  If the implementation upgrades in production is desired, the factory data migration logic should be implemented and then used atomically together with the implementation switch in all affected contracts.   
# Handle  pauliax   # Vulnerability details  ## Impact When emitting Sell event, it assumes that the path is always of length 2, as amounts[1] is used for the ethReceived parameter. However, the path does not have any restrictions on its length, so it is completely possible, that this is not the final amount. Events are used to inform the outside world and this may trick the consumers.  ## Recommended Mitigation Steps amounts[1] should be replaced with amounts[amounts.length - 1]  
# Handle  pauliax   # Vulnerability details  ## Impact Consider introducing a reasonable global upper limit for timelockLength in XTokenUpgradeable and TimelockRewardDistributionTokenImpl, so the users can't be locked out of their tokens forever.  ## Recommended Mitigation Steps XTokenUpgradeable and TimelockRewardDistributionTokenImpl should not trust the external input but have explicitly declared boundaries for values like timelock length to reduce possibilities of unexpected outcomes.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L247-L248  ```solidity=247 uint256 remaining = WETH.balanceOf(address(this)); WETH.transfer(to, remaining); ```  Since `WETH.balanceOf(address(this))` can to be `0`. Checking `if (remaining > 0)` before the transfer can potentially save an external call and the unnecessary gas cost of a 0 token transfer.  
# Handle  WatchPug   # Vulnerability details  Unused function parameters increase contract size and gas usage at deployment.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L496-L511  ```solidity=496   function _buyVaultToken(     address vault,      uint256 minTokenOut,      uint256 maxWethIn,      address[] calldata path   ) internal returns (uint256[] memory) {     uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(       minTokenOut,       maxWethIn,       path,        address(this),       block.timestamp     );      return amounts;   } ```  `vault` is unused.  
# Handle  WatchPug   # Vulnerability details  Unused local variables in contracts increase contract size and gas usage at deployment.  Instances include:  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L187-L187  ```solidity=187 uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime); ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L207-L207  ```solidity=207 uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime); ```  
# Handle  WatchPug   # Vulnerability details  Unused events increase contract size and gas usage at deployment.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/eligibility/NFTXMintRequestEligibility.sol#L62-L62  ```solidity event Reject(uint256[] nftIds); ```  `Reject` is unused.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L285-L290  ```solidity=285     function _deposit(StakingPool memory pool, uint256 amount) internal {         require(pool.stakingToken != address(0), "LPStaking: Nonexistent pool");         IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);         // Timelock for 2 seconds to prevent flash loans.         _rewardDistributionTokenAddr(pool).timelockMint(msg.sender, amount, 2);     } ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L124-L130  ```solidity=124     function deposit(uint256 vaultId, uint256 amount) external {         onlyOwnerIfPaused(10);         // Check the pool in case its been updated.         updatePoolForVault(vaultId);         StakingPool memory pool = vaultStakingInfo[vaultId];         _deposit(pool, amount);     } ```   `_deposit()` is unnecessary as it's being used only once. Therefore it can be inlined in `deposit()` to make the code simpler and save gas.  ## Recommendation  Change to:  ```solidity=124     function deposit(uint256 vaultId, uint256 amount) external {         onlyOwnerIfPaused(10);         // Check the pool in case its been updated.         updatePoolForVault(vaultId);         StakingPool memory pool = vaultStakingInfo[vaultId];          require(pool.stakingToken != address(0), "LPStaking: Nonexistent pool");         IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);         // Timelock for 2 seconds to prevent flash loans.         _rewardDistributionTokenAddr(pool).timelockMint(msg.sender, amount, 2);     } ```  Other examples include:  -   `NFTXFlashSwipe.sol#flashRedeem()`, `NFTXFlashSwipe.sol#flashMint()` can be inlined in `NFTXFlashSwipe.sol#onFlashLoan()` -   `UniswapV3SparkleEligibility.sol#isRare()` can be inlined in `UniswapV3SparkleEligibility.sol#_checkIfEligible()`   
# Handle  cmichel   # Vulnerability details  The comment in `TimelockRewardDistributionTokenImpl.burnFrom` says: > the caller must have allowance for ``accounts``'s tokens of at least `amount`.  This was the case in a previous version but not anymore. The owner does not need to be approved to burn tokens anymore.  ## Recommended Mitigation Steps Update the comment to clarify the behavior.   
# Handle  cmichel   # Vulnerability details  The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded.  ## Impact If the call fails, the refunds did not succeed and the caller will lose all refunds of `msg.value - amountEth`.  ## Recommended Mitigation Steps Revert the entire transaction if the refund call fails by checking that the `success` return value of the `payable(to).call(...)` returns `true`.  
# Handle  cmichel   # Vulnerability details  The `NFTXInventoryStaking` contract distributes new rewards to all previous stakers when the owner calls the `receiveRewards` function. This allows an attacker to frontrun this `receiveRewards` transaction when they see it in the mem pool with a `deposit` function. The attacker will receive the rewards pro-rata to their deposits. The deposit will be locked for 2 seconds only (`DEFAULT_LOCKTIME`) after which the depositor can withdraw their initial deposit & the rewards again for a profit.  The rewards can be gamed this way and one does not actually have to _stake_, only be in the staking contract at the time of reward distribution for 2 seconds. The rest of the time they can be used for other purposes.  ## Recommended Mitigation Steps Distribute the rewards equally over time to the stakers instead of in a single chunk on each `receiveRewards` call. This is more of a "streaming rewards" approach.   
# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) {   uint length = arr.length;   for (uint i = 0; i < arr.length; i++) {       sum += arr[i];   } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) {   uint length = arr.length;   for (uint i = 0; i < arr.length; i++) {       sum += arr[i];   } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L297`  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  Multiple internal functions do not have a name that starts with an underscore. The lack of clarity over the functions visibility could lead to misuse of these functions.  ## Proof of Concept Both the NFTXMarketplaceZap.sol and NFTXStakingZap.sol contracts have three internal functions names without underscores: approveERC721 in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L574 approveERC721 in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L434 pairFor in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L593 pairFor in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L453 sortTokens in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L604 sortTokens in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L464  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Rename internal functions following best practices to clarify function visibility  
# Handle  sirhashalot   # Vulnerability details  ## Impact  If two variables with the same name exist in a function, but one is imported from another contract while the other is created locally, it is unclear which value is being used or should be used. Avoiding variable name collisions avoids confusion and the risks of using the wrong variable.  https://swcregistry.io/docs/SWC-119  ## Proof of Concept  Several instance of this issue exist. 1. mintAndSell1155() function in NFTXMarketplaceZap.sol has `uint256[] memory amounts` as an input parameter and later it is redeclared in the function https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L368,L376 2. pauseFeeDistribution() function in NFTXSimpleFeeDistributor.sol uses a pause return bool which shadows PausableUpgradeable.pause https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L140 3. transferFromERC721() function in NFTXStakingZap.sol declares an `address owner` which shadows Ownable.owner(): https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L422 4. transferFromERC721() function in NFTXMarketplaceZap.sol declares an `address owner` which shadows Ownable.owner(): https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L562  ## Tools Used  Slither, shadowing-local detector: https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing  ## Recommended Mitigation Steps  Rename local variables to avoid shadowing. For instance, add an underscore in front of the name of local variables.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_sendForReceiver()` function only sets a return function in the "if" code block, not the "else" case. If the "else" case is true, no value is returned. The result of this oversight is that the `_sendForReceiver()` function called from the `distribute()` function could sucessfully enter its `else` block if a receiver has `isContract` set to False and successfully transfer the `amountToSend` value. The `ditribute()` function will then have `leftover > 0` and send `currentTokenBalance` to the treasury. This issue is partially due to [Solidity using implicit returns](https://github.com/ethereum/solidity/issues/2951), so if no bool value is explicitly returned, the default bool value of False will be returned.  This problem currently occurs for any receiver with `isContract` set to False. The `_addReceiver` function allows for `isContract` to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.  ## Proof of Concept  The `else` block is missing a return value https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L167-L169  ## Tools Used  VS Code "Solidity Visual Developer" extension  ## Recommended Mitigation Steps  Verify that functions with a return value do actually return a value in all cases. Adding the line `return true;` can be added to the end of the `else` block as one way to resolve this.  Alternatively, if `isContract` should never be set to False, the code should be designed to prevent a receiver from being added with this value.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `provideInventory1155()` function in contracts/solidity/NFTXStakingZap.sol contains a for loop that uses tokenIds.length to loop through the amounts array. However, if these two arrays are not the same length, the loop with trigger an error. The error could be triggered after many operations already occur, so checking that these two lengths are equal first could save gas.  ## Proof of Concept  The `provideInventory1155()` function contracts/solidity/NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L201  ## Recommended Mitigation Steps  There are two main options to reducing the gas spend in an error condition: 1. Add the following line as the first line of the `provideInventory1155()` function: `require(tokenIds.length == amounts.length)` 2. In the for loop within the `provideInventory1155()` function, replace `i < tokenIds.length` with `i < amounts.length;`  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The file contracts/solidity/testing/NFTXFeeDistributor2.sol references the old NFTXFeeDistributor.sol and instead should reference the new NFTXSimpleFeeDistributor.sol  ## Proof of Concept  The import and contract inheritance of contracts/solidity/testing/NFTXFeeDistributor2.sol  ## Tools Used  `npx hardhat test` fails due to this issue because the ../NFTXFeeDistributor.sol imported file is not found  ## Recommended Mitigation Steps  Reference the new NFTXSimpleFeeDistributor.sol and not NFTXFeeDistributor.sol in the import and contract inheritance  
# Handle  hyh   # Vulnerability details  ## Impact  deployXTokenForVault call will not revert on deploy failure.  ## Proof of Concept  NFTXInventoryStaking._deployXToken is called by deployXTokenForVault: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L64  _deployXToken uses deploy generated address without check: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L160  ## Recommended Mitigation Steps  Require non zero deployedXToken address before calling __XToken_init.  
# Handle  hyh   # Vulnerability details  # Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. mintTo and swapTo outcome will not be as expected by a caller.  ## Proof of Concept  The arrays are used whenever Vault is ERC1155, i.e. when is1155 is true.  swap -> swapTo uses the arrays as given: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L258  mint -> mintTo, arrays are passed on without checks to receiveNFTs: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L190  receiveNFTs uses the arrays in a loop, assuming equal lengths without a check: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L389  ## Recommended Mitigation Steps  Add `require(tokenIds.length == amounts.length, "tokenIds and amounts length should match")` check in the beginning of public mintTo and swapTo endpoints.   
# Handle  p4st13r4   # Vulnerability details  ## Impact  `XTokenUpgradeable.sol` contains many comments regarding SushiBar. It looks like the comments have been copy-pasted from another contract, and may be deceiving for a reader  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L14](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L14)  ## Tools Used  ## Recommended Mitigation Steps  Remove said comments  
# Handle  p4st13r4   # Vulnerability details  ## Impact  Detailed description of the impact of this finding.  Fee distribution algorithm in `NFTXSimpleFeeDistributor.sol` can led to unfair distribution of fees among receivers. The `_sendForReceiver` function returns `success = true` only when the call to receiver' `receiveRewards` is successful and the whole amount is transfered to the receiver. Otherwise, the entire fee is moved up to the next receiver, and finally to the treasury.  If a badly implemented receiver leaves a part of the fee (even 1 wei) to the fee distributor, the operation is considered unsuccessful and the entire amount of the fee is moved up to the next receiver. This could lead to the situation where one of the late receivers is unable to receive any fee at all, since some previous receiver has received more than it should have.  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L166](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L166)  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L69](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L69)  ## Tools Used  Editor  ## Recommended Mitigation Steps  `_sendForReceiver` should return a tuple: `(bool success, uint256 amountLeft)`. Then `amountLeft` should be used by `distribute` for the `leftover` variable  
# Handle  p4st13r4   # Vulnerability details  ## Impact  Any user that owns a vToken of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone.  Every operation performed by the marketplace, that deals with vToken minting, performs this check:  ```jsx require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), "Did not receive expected balance"); ```  A malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421)  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Remove this logic from the marketplace and staking zap contracts, and add it to the vaults (if necessary)  
# Handle  hyh   # Vulnerability details  # Impact  Double spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones. As `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.  ## Proof of Concept  `distribute` use `_sendForReceiver` to transfer current vault balance across `feeReceivers`: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L67  `_sendForReceiver` returns a boolean that is used to move current distribution amount to the next receiver when last transfer failed. When `_receiver.isContract` is `false` nothing is returned, while `safeTransfer` is done: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L168  This way `_sendForReceiver` will indicate that transfer is failed and leftover amount to be added to the next transfer, i.e. the `amountToSend` will be spent twice: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L64  ## Recommended Mitigation Steps  Now: ``` function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {  if (_receiver.isContract) {  ...  } else {   IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);  } } ```  To be: ``` function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {  if (_receiver.isContract) {  ...  } else {   IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);   return true;  } } ```  
# Handle  WatchPug   # Vulnerability details  Since the introduction of `transfer()`, it has typically been recommended by the security community because it helps guard against reentrancy attacks. This guidance made sense under the assumption that gas costs wouldn’t change. It's now recommended that transfer() and send() be avoided, as gas costs can and will change and reentrancy guard is more commonly used.  Any smart contract that uses `transfer()` is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.  It's recommended to stop using `transfer()` and switch to using `call()` instead.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXV1Buyout.sol#L44-L44  ```solidity payable(msg.sender).transfer(amount); ```  Can be changed to:  ```solidity (bool success, ) = msg.sender.call{value: amount}(""); require(success, "ETH transfer failed"); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L15-L15  ```solidity=15 contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable { ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L41-L47  ```solidity=41   function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {     __Pausable_init();     setTreasuryAddress(_treasury);     setLPStakingAddress(_lpStaking);      _addReceiver(0.8 ether, lpStaking, true);   } ```  For the upgradeable variants of OpenZipplin contracts, they should be initialized by calling the `__***_init()` function in the initializer function.  Therefore, `__SimpleFeeDistributor__init__()` should call `__ReentrancyGuard_init()` at L42.  
# Handle  WatchPug   # Vulnerability details  There are many functions across the codebase that will perform an ERC20.approve() call but does not check the success return value. Some tokens do not revert if the approval failed but return false instead.  Instances include:  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L167-L167  ```solidity=167 IERC20Upgradeable(address(_pairedToken)).approve(_sushiRouter, type(uint256).max); ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L313  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L299  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L519  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L538  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L159  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L398  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L171  It is usually good to add a require-statement that checks the return value or to use something like `safeApprove`; unless one is sure the given token reverts in case of a failure.  
# Handle  leastwood   # Vulnerability details  ## Impact  `TimelockRewardDistributionTokenImpl` calculates the accumulative reward according to the following function: ``` function accumulativeRewardOf(address _owner) public view returns(uint256) {   return magnifiedRewardPerShare.mul(balanceOf(_owner)).toInt256()     .add(magnifiedRewardCorrections[_owner]).toUint256Safe() / magnitude; } ```  The calculation takes into consideration the LP token balance of token holders. Hence, if the token holder has called `emergencyExit` or `withdraw` in `NFTXLPStaking`, the LP tokens are removed from the staking contract without claiming rewards prior to this action. Therefore, in order for users to claim their fair share of rewards they must restake LP tokens and call `claimRewards`.   Similarly, `_transfer` in `TimelockRewardDistributionTokenImpl` also does not force the `from` account to claim rewards first.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L195-L198 ``` function withdraw(uint256 vaultId, uint256 amount) external {     StakingPool memory pool = vaultStakingInfo[vaultId];     _withdraw(pool, amount, msg.sender); } ```  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L157-L162 ``` function emergencyExit(address _stakingToken, address _rewardToken) external {     StakingPool memory pool = StakingPool(_stakingToken, _rewardToken);     TimelockRewardDistributionTokenImpl dist = _rewardDistributionTokenAddr(pool);     require(isContract(address(dist)), "Not a pool");     _withdraw(pool, dist.balanceOf(msg.sender), msg.sender); } ```  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/TimelockRewardDistributionTokenImpl.sol#L199-L206 ``` function _transfer(address from, address to, uint256 value) internal override {   require(block.timestamp > timelock[from], "User locked");   super._transfer(from, to, value);    int256 _magCorrection = magnifiedRewardPerShare.mul(value).toInt256();   magnifiedRewardCorrections[from] = magnifiedRewardCorrections[from].add(_magCorrection);   magnifiedRewardCorrections[to] = magnifiedRewardCorrections[to].sub(_magCorrection); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing functions in `NFTXLPStaking` that do not claim token rewards before unstaking LP tokens or alternatively add code to the affected functions such that rewards are claimed before withdrawing LP tokens.  
# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the _sendForReceiver function to distribute the fee  ```   function distribute(uint256 vaultId) external override virtual nonReentrant {     require(nftxVaultFactory != address(0));     address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);      uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));      if (distributionPaused || allocTotal == 0) {       IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);       return;     }      uint256 length = feeReceivers.length;     uint256 leftover;     for (uint256 i = 0; i <length; i++) {       FeeReceiver memory _feeReceiver = feeReceivers[i];       uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);       uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));       amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;       bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);       if (!complete) {         leftover = amountToSend;       } else {         leftover = 0;       }     } ```  In the _sendForReceiver function, when the _receiver is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success,) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ```  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L166  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  The contract can store the fee sent to the receiver in a state variable, and then the receiver can take it out by calling a function.  
# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXSimpleFeeDistributor.sol contract, the distribute function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the _sendForReceiver function.  ```   function distribute(uint256 vaultId) external override virtual nonReentrant {     require(nftxVaultFactory != address(0));     address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);      uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));      if (distributionPaused || allocTotal == 0) {       IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);       return;     }      uint256 length = feeReceivers.length;     uint256 leftover;     for (uint256 i = 0; i <length; i++) {       FeeReceiver memory _feeReceiver = feeReceivers[i];       uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);       uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));       amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;       bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);       if (!complete) {         leftover = amountToSend;       } else {         leftover = 0;       }     } ```  In the _sendForReceiver function, when _receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success,) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ``` ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L168  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L49-L67  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success, ) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       - IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);       + return IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ```  
# Handle  leastwood   # Vulnerability details  ## Impact  `assignDefaultFeatures` is intended to be called by the `dev` account, however, the function itself does not take in any arguments and instead sets the `enableRandomSwap` and `enableTargetSwap` state variables to itself.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L111-L117 ``` function assignDefaultFeatures() external {     require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, "Not dev");     enableRandomSwap = enableRandomRedeem;     enableTargetSwap = enableTargetRedeem;     emit EnableRandomSwapUpdated(enableRandomSwap);     emit EnableTargetSwapUpdated(enableTargetSwap); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing this function altogether or adding the necessary arguments such that the `dev` account can actually set the proper state variables.  
# Handle  ych18   # Vulnerability details  In If the Vault owner decides to set factoryMintFee and factoryRandomRedeemFee to zero, any user could call the function NFTXVaultFactoryUpgradeable.assignFees() and hence all the fees are updated.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping `ERC1155` tokens within a single transaction. The function expects to transfer `WETH` tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in `buyAndSwap1155WETH` actually uses `msg.value` and not `maxWethIn`. As a result, the function will not work unless the user supplies both `WETH` and native `ETH` amounts, equivalent to the `maxWethIn` amount.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L284-L314 ``` function buyAndSwap1155WETH(   uint256 vaultId,    uint256[] memory idsIn,    uint256[] memory amounts,    uint256[] memory specificIds,    uint256 maxWethIn,    address[] calldata path,   address to ) public payable nonReentrant {   require(to != address(0));   require(idsIn.length != 0);   IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);   uint256 count;   for (uint256 i = 0; i < idsIn.length; i++) {       uint256 amount = amounts[i];       require(amount > 0, "Transferring < 1");       count += amount;   }   INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));   uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (       vault.randomSwapFee() * (count - specificIds.length)   );   uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);   _swap1155(vaultId, idsIn, amounts, specificIds, to);    emit Swap(count, swapAmounts[0], to);    // Return extras.   uint256 remaining = WETH.balanceOf(address(this));   WETH.transfer(to, remaining); } ```  ## Tools Used  Manual code review. Discussions with Kiwi.  ## Recommended Mitigation Steps  Consider updating the `buyAndSwap1155WETH` function such that the following line of code is used instead of [this](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L306).  ``` uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path); ```  
# Handle  robee   # Vulnerability details  Need to use safeTransfer instead of transfer. As there are popular tokens, such as USDT that transfer/trasnferFrom method doesn’t return anything. The transfer return value has to be checked (as there are some other tokens that returns false instead revert), that means you must   1. Check the transfer return value Another popular possibility is to add a whiteList. Those are the appearances (solidity file, line number, actual line):          NFTXStakingZap.sol, 401, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);          NFTXStakingZap.sol, 474, IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));          PalmNFTXStakingZap.sol, 190, pairedToken.transferFrom(msg.sender, address(this), wethIn);          PalmNFTXStakingZap.sol, 195, pairedToken.transfer(to, wethIn-amountEth);          PalmNFTXStakingZap.sol, 219, pairedToken.transferFrom(msg.sender, address(this), wethIn);          PalmNFTXStakingZap.sol, 224, pairedToken.transfer(to, wethIn-amountEth);          PalmNFTXStakingZap.sol, 316, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);          XTokenUpgradeable.sol, 54, baseToken.transfer(who, what);          NFTXFlashSwipe.sol, 51, IERC20Upgradeable(vault).transferFrom(msg.sender, address(this), mintFee + targetRedeemFee);    
# Handle  robee   # Vulnerability details          Deprecated safeApprove in NFTXMarketplaceZap.sol line 518: IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);          Deprecated safeApprove in NFTXMarketplaceZap.sol line 537: IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);          Deprecated safeApprove in NFTXSimpleFeeDistributor.sol line 158: IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);          Deprecated safeApprove in NFTXStakingZap.sol line 170: IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);          Deprecated safeApprove in NFTXStakingZap.sol line 383: IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);          Deprecated safeApprove in NFTXStakingZap.sol line 397: IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);          Deprecated safeApprove in PalmNFTXStakingZap.sol line 166: IERC20Upgradeable(address(_pairedToken)).approve(_sushiRouter, type(uint256).max);          Deprecated safeApprove in PalmNFTXStakingZap.sol line 298: IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);          Deprecated safeApprove in PalmNFTXStakingZap.sol line 312: IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);          Deprecated safeApprove in NFTXFlashSwipe.sol line 56: IERC20Upgradeable(vault).approve(address(vault), allowance + count);   
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           IPrevNftxContract.sol, line 4, import "./IERC165Upgradeable.sol";         NFTXEligibilityManager.sol, line 5, import "./interface/INFTXVaultFactory.sol";         NFTXInventoryStaking.sol, line 6, import "./interface/INFTXFeeDistributor.sol";         NFTXInventoryStaking.sol, line 10, import "./token/IERC721Upgradeable.sol";         NFTXInventoryStaking.sol, line 11, import "./token/IERC1155Upgradeable.sol";         NFTXInventoryStaking.sol, line 16, import "./proxy/Initializable.sol";         NFTXLPStaking.sol, line 5, import "./interface/INFTXFeeDistributor.sol";         NFTXLPStaking.sol, line 12, import "./proxy/Initializable.sol";         NFTXMarketplaceZap.sol, line 8, import "./interface/ITimelockRewardDistributionToken.sol";         NFTXMarketplaceZap.sol, line 10, import "./testing/IERC721.sol";         NFTXMarketplaceZap.sol, line 15, import "./util/OwnableUpgradeable.sol";         NFTXSimpleFeeDistributor.sol, line 10, import "./util/SafeMathUpgradeable.sol";         NFTXStakingZap.sol, line 9, import "./interface/ITimelockRewardDistributionToken.sol";         NFTXStakingZap.sol, line 11, import "./testing/IERC721.sol";         NFTXStakingZap.sol, line 16, import "./util/OwnableUpgradeable.sol";         NFTXVaultFactoryUpgradeable.sol, line 5, import "./interface/INFTXLPStaking.sol";         NFTXVaultFactoryUpgradeable.sol, line 7, import "./proxy/ClonesUpgradeable.sol";         NFTXVaultUpgradeable.sol, line 8, import "./interface/INFTXLPStaking.sol";         NFTXVaultUpgradeable.sol, line 10, import "./interface/IERC165Upgradeable.sol";         PalmNFTXStakingZap.sol, line 15, import "../util/OwnableUpgradeable.sol";         StakingTokenProvider.sol, line 7, import "./token/IERC20Upgradeable.sol";         ERC20FlashMintUpgradeable.sol, line 4, import "../interface/IERC3156Upgradeable.sol";         RewardDistributionTokenUpgradeable.sol, line 5, import "../interface/IRewardDistributionToken.sol";         RewardDistributionTokenUpgradeable.sol, line 11, import "hardhat/console.sol";         TimelockRewardDistributionTokenImpl.sol, line 5, import "../interface/IRewardDistributionToken.sol";         NFTXFlashSwipe.sol, line 4, import "../interface/IERC3156Upgradeable.sol";         PausableUpgradeable.sol, line 5, import "./SafeMathUpgradeable.sol";    
# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXMarketplaceZap.sol contract, the buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the _buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail.  ``` function buyAndSwap1155WETH(   uint256 vaultId,   uint256[] memory idsIn,   uint256[] memory amounts,   uint256[] memory specificIds,   uint256 maxWethIn,   address[] calldata path,   address to ) public payable nonReentrant {   require(to != address(0));   require(idsIn.length != 0);   IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);   uint256 count;   for (uint256 i = 0; i <idsIn.length; i++) {       uint256 amount = amounts[i];       require(amount> 0, "Transferring <1");       count += amount;   }   INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));   uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (       vault.randomSwapFee() * (count-specificIds.length)   );   uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path); ```  In extreme cases, when the user provides both ETH and WETH (the user approves the contract WETH in advance and calls the buyAndSwap1155WETH function instead of the buyAndSwap1155 function by mistake), the _buyVaultToken function will execute successfully, but because the buyAndSwap1155WETH function will not convert ETH to WETH, The user’s ETH will be locked in the contract, causing loss of user assets.  ```    function _buyVaultToken(      address vault,      uint256 minTokenOut,      uint256 maxWethIn,      address[] calldata path    ) internal returns (uint256[] memory) {      uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(        minTokenOut,        maxWethIn,        path,        address(this),        block.timestamp      );       return amounts;    } ```   ## Tools Used  Manual audit  ## Recommended Mitigation Steps   ``` - uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path); + uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path); ```  
