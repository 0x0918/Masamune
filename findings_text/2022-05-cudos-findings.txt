# Lines of code  https://github.com/code-423n4/2022-05-cudos/blob/main/solidity/contracts/Gravity.sol#L175   # Vulnerability details  ## Impact  In case a hack is occuring or an exploit is discovered, the team (or validators in this case) should be able to pause functionality until the necessary changes are made to the system. Additionally, the gravity.sol contract should be manged by proxy so that upgrades can be made by the validators.  Because an attack would probably span a number of blocks, a method for pausing the contract would be able to interrupt any such attack if discovered.  To use a thorchain example again, the team behind thorchain noticed an attack was going to occur well before the system transferred funds to the hacker. However, they were not able to shut the system down fast enough. (According to the incidence report here: https://github.com/HalbornSecurity/PublicReports/blob/master/Incident%20Reports/Thorchain_Incident_Analysis_July_23_2021.pdf)   ## Proof of Concept  https://github.com/code-423n4/2022-05-cudos/blob/main/solidity/contracts/Gravity.sol#L175  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Pause functionality on the contract would have helped secure the funds quickly.   
# Lines of code  https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L595-L630   # Vulnerability details  ## Impact  Smart contracts addresses made using the `create` opcode are deterministic based off the deployer account and the nonce of this account.   An attacker is therefore able to predetermine the address of any smart contracts deployed using `deployERC20()`.  One of the limitations of  OpenZeppelin's `token.safeTransferFrom(from, to, amount)` is that it will succeed if there is no bytecode at the `token` address.  The impact of both of these features is that an attacker may call `sendToCosmos(_tokenContract, _destination, _amount)` for an ERC20 token before it is deployed using `deployERC20()` since the address can be calculated. The attacker may set any arbitrary amount and the `IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);` will succeed. The `SendToCosmosEvent` will be emitted and the relevant transfer will occur on the other side of the bridge.   ## Proof of Concept  `IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);` succeeds if `_tokenContract` does not have any bytecode. So the attacker may call `sendToCosmos()`.  Following this the attacker calls `deployERC20()` to deploy the token contract. Note the token contract was precalculated and used as the `_tokenContract` parameter in `sendToCosmos()`.  The bridge will then process `SendToCosmosEvent` on the Cosmos chain.  ```solidity  function sendToCosmos(   address _tokenContract,   bytes32 _destination,   uint256 _amount  ) public nonReentrant  {   IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);   state_lastEventNonce = state_lastEventNonce.add(1);   emit SendToCosmosEvent(    _tokenContract,    msg.sender,    _destination,    _amount,    state_lastEventNonce   );  }   function deployERC20(   string memory _cosmosDenom,   string memory _name,   string memory _symbol,   uint8 _decimals  ) public {   // Deploy an ERC20 with entire supply granted to Gravity.sol   CosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);    // Fire an event to let the Cosmos module know   state_lastEventNonce = state_lastEventNonce.add(1);   emit ERC20DeployedEvent(    _cosmosDenom,    address(erc20),    _name,    _symbol,    _decimals,    state_lastEventNonce   );  } ```  ## Recommended Mitigation Steps  This issue may be resolved by enforcing `sendToCosmos()` check that `_tokenContract` contains bytecode.  ```solidity  function isContract(address _addr) private returns (bool isContract){      uint32 size;      assembly {          size := extcodesize(_addr)      }       return (size > 0);  }   function sendToCosmos(   address _tokenContract,   bytes32 _destination,   uint256 _amount  ) public nonReentrant  {   require(isContract(_tokenContract, "Invalid contract address"));   IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);                 ...         } ```  
# Lines of code  https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L595-L609   # Vulnerability details  ## Impact  No checks for non-Cudos tokens mean that non-Cudos ERC20 tokens will be lost to the contract, with the user not having any chance of retrieving them.  However, the admin can retrieve them through withdrawERC20.  Impact is that users lose their funds, but admins gain them.  The mistakes could be mitigated on the contract, by checking against a list of supported tokens, so that users don't get the bad experience of losing funds and CUDOS doesn't have to manually refund users  ## Proof of Concept  User sends 100 ETH through sendToCosmos, hoping to retrieve 100 synthetic ETH on Cudos chain but finds that funds never appear.   ```   function sendToCosmos(   address _tokenContract,   bytes32 _destination,   uint256 _amount  ) public nonReentrant  {   IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);   state_lastEventNonce = state_lastEventNonce.add(1);   emit SendToCosmosEvent(    _tokenContract,    msg.sender,    _destination,    _amount,    state_lastEventNonce   );  }  ```  https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L595-L609  Admin can retrieve these funds should they wish, but user never gets them back because the contract does not check whether the token is supported.  ```   function withdrawERC20(   address _tokenAddress)    external {   require(cudosAccessControls.hasAdminRole(msg.sender), "Recipient is not an admin");   uint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));   IERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);  }   ```     https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L632-L638  ## Tools Used Logic and discussion with @germanimp  ## Recommended Mitigation Steps  Add checks in sendToCosmos to check the incoming tokenAddress against a supported token list, so that user funds don't get lost and admin don't need to bother refunding.  
# Lines of code  https://github.com/code-423n4/2022-05-cudos/blob/main/solidity/contracts/Gravity.sol#L175   # Vulnerability details  ## Impact  In case a hack is occuring or an exploit is discovered, the team (or validators in this case) should be able to pause functionality until the necessary changes are made to the system. Additionally, the gravity.sol contract should be manged by proxy so that upgrades can be made by the validators.  Because an attack would probably span a number of blocks, a method for pausing the contract would be able to interrupt any such attack if discovered.  To use a thorchain example again, the team behind thorchain noticed an attack was going to occur well before the system transferred funds to the hacker. However, they were not able to shut the system down fast enough. (According to the incidence report here: https://github.com/HalbornSecurity/PublicReports/blob/master/Incident%20Reports/Thorchain_Incident_Analysis_July_23_2021.pdf)   ## Proof of Concept  https://github.com/code-423n4/2022-05-cudos/blob/main/solidity/contracts/Gravity.sol#L175  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Pause functionality on the contract would have helped secure the funds quickly.   
# Lines of code  https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L595-L630   # Vulnerability details  ## Impact  Smart contracts addresses made using the `create` opcode are deterministic based off the deployer account and the nonce of this account.   An attacker is therefore able to predetermine the address of any smart contracts deployed using `deployERC20()`.  One of the limitations of  OpenZeppelin's `token.safeTransferFrom(from, to, amount)` is that it will succeed if there is no bytecode at the `token` address.  The impact of both of these features is that an attacker may call `sendToCosmos(_tokenContract, _destination, _amount)` for an ERC20 token before it is deployed using `deployERC20()` since the address can be calculated. The attacker may set any arbitrary amount and the `IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);` will succeed. The `SendToCosmosEvent` will be emitted and the relevant transfer will occur on the other side of the bridge.   ## Proof of Concept  `IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);` succeeds if `_tokenContract` does not have any bytecode. So the attacker may call `sendToCosmos()`.  Following this the attacker calls `deployERC20()` to deploy the token contract. Note the token contract was precalculated and used as the `_tokenContract` parameter in `sendToCosmos()`.  The bridge will then process `SendToCosmosEvent` on the Cosmos chain.  ```solidity  function sendToCosmos(   address _tokenContract,   bytes32 _destination,   uint256 _amount  ) public nonReentrant  {   IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);   state_lastEventNonce = state_lastEventNonce.add(1);   emit SendToCosmosEvent(    _tokenContract,    msg.sender,    _destination,    _amount,    state_lastEventNonce   );  }   function deployERC20(   string memory _cosmosDenom,   string memory _name,   string memory _symbol,   uint8 _decimals  ) public {   // Deploy an ERC20 with entire supply granted to Gravity.sol   CosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);    // Fire an event to let the Cosmos module know   state_lastEventNonce = state_lastEventNonce.add(1);   emit ERC20DeployedEvent(    _cosmosDenom,    address(erc20),    _name,    _symbol,    _decimals,    state_lastEventNonce   );  } ```  ## Recommended Mitigation Steps  This issue may be resolved by enforcing `sendToCosmos()` check that `_tokenContract` contains bytecode.  ```solidity  function isContract(address _addr) private returns (bool isContract){      uint32 size;      assembly {          size := extcodesize(_addr)      }       return (size > 0);  }   function sendToCosmos(   address _tokenContract,   bytes32 _destination,   uint256 _amount  ) public nonReentrant  {   require(isContract(_tokenContract, "Invalid contract address"));   IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);                 ...         } ```  
# Lines of code  https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L595-L609   # Vulnerability details  ## Impact  No checks for non-Cudos tokens mean that non-Cudos ERC20 tokens will be lost to the contract, with the user not having any chance of retrieving them.  However, the admin can retrieve them through withdrawERC20.  Impact is that users lose their funds, but admins gain them.  The mistakes could be mitigated on the contract, by checking against a list of supported tokens, so that users don't get the bad experience of losing funds and CUDOS doesn't have to manually refund users  ## Proof of Concept  User sends 100 ETH through sendToCosmos, hoping to retrieve 100 synthetic ETH on Cudos chain but finds that funds never appear.   ```   function sendToCosmos(   address _tokenContract,   bytes32 _destination,   uint256 _amount  ) public nonReentrant  {   IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);   state_lastEventNonce = state_lastEventNonce.add(1);   emit SendToCosmosEvent(    _tokenContract,    msg.sender,    _destination,    _amount,    state_lastEventNonce   );  }  ```  https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L595-L609  Admin can retrieve these funds should they wish, but user never gets them back because the contract does not check whether the token is supported.  ```   function withdrawERC20(   address _tokenAddress)    external {   require(cudosAccessControls.hasAdminRole(msg.sender), "Recipient is not an admin");   uint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));   IERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);  }   ```     https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L632-L638  ## Tools Used Logic and discussion with @germanimp  ## Recommended Mitigation Steps  Add checks in sendToCosmos to check the incoming tokenAddress against a supported token list, so that user funds don't get lost and admin don't need to bother refunding.  
