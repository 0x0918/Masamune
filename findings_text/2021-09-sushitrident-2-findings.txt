# Handle  broccoli   # Vulnerability details  ## Impact  In the `burn` and `swap` functions of `ConcentratedLiquidityPool`, the lower tick is not explicitly checked to be less than the upper tick. Besides, the ticks are not checked to be at least the minimum tick and at most the maximum tick.  ## Proof of Concept  Referenced code: [Ticks.sol#L68-L70](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/Ticks.sol#L68-L70)  ## Recommended Mitigation Steps  Add sanity checks on the lower and upper ticks in critical functions (see the referenced line of code, for example).  
# Handle  broccoli   # Vulnerability details  ## Impact  The `_getAmountsForLiquidity` function of `ConcentratedLiquidityPool` explicitly converts the result of `DyDxMath.getDy` and `DyDxMath.getDx` from type `uint256` to type `uint128`. The explicit casting without checking whether the integer exceeds the maximum number (i.e., `type(uint128).max`) could cause incorrect results being used. Specifically, an attacker could exploit this bug to mint a large amount of liquidity but only pay a little of `token0` or `token1` to the pool and effectively steal other's funds when burning his liquidity.  ## Proof of Concept  1. Suppose that the current price is at the tick `500000`, an attacker calls the `mint` function with the following parameters:  ``` mintParams.lower = 100000 mintParams.upper = 500000 mintParams.amount1Desired = (1 << 128) + 71914955423 # a carefully chosen number mintParams.amount0Desired = 0 ```  2. Since the current price is equal to the upper price, we have  ``` _liquidity = mintParams.amount1Desired * (1 << 96) // (priceUpper - priceLower)            = 4731732988155153573010127840 ```  3. The amounts of `token0` and `token1` that the attacker has to pay is  ``` amount0Actual = 0 amount1Actual = uint128(DyDxMath.getDy(_liquidity, priceLower, priceUpper, true))               = uint128(_liquidity * (priceUpper - priceLower) // (1 << 96)) # round up               = uint128(340282366920938463463374607456141861046)             # exceed the max               = 24373649590                                                  # truncated ```  4. The attacker only pays `24373649590` of `token1` to get `4731732988155153573010127840` of the liquidity, which he could burn to get more `token1`. As a result, the attacker is stealing the funds from the pool and could potentially drain it.  Referenced code: [ConcentratedLiquidityPool.sol#L480](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L480) [concentratedPool/DyDxMath.sol#L15](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/DyDxMath.sol#L15) [concentratedPool/DyDxMath.sol#L30](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/DyDxMath.sol#L30)  ## Recommended Mitigation Steps  Check whether the result of `DyDxMath.getDy` or `DyDxMath.getDx` exceeds `type(uint128).max` or not. If so, then revert the transaction. Or consider using the [`SafeCast` library](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast) from OpenZeppelin instead.  
# Handle  0xsanson   # Vulnerability details  ## Impact When an user subscribes to an incentive using ConcentratedLiquidityPoolManager's `subscribe`, the function checks that `incentiveId` is appropriate: ```js require(incentiveId <= incentiveCount[pool], "NOT_INCENTIVE"); ``` This check is actually incorrect, and it should use a `<` instead of `<=`.  If this was the only requirement, it would be possible to subscribe to the next incentive, causing some problems. Fortunately the next line saves the day: `require(block.timestamp > incentive.startTime && block.timestamp < incentive.endTime, "TIMED_OUT");` this fails for uninitiated incentives.  ## Proof of Concept https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L72  ## Tools Used editor  ## Recommended Mitigation Steps Consider removing this requirement to save gas. The check for existing pool is already considered when looking at `block.timestamp < incentive.endTime`.  
# Handle  0xsanson   # Vulnerability details  ## Impact Function `addIncentive` and `reclaimIncentive` in ConcentratedLiquidityPoolManager can be `external` instead of `public` to save gas.  ## Proof of Concept https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L36 https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L49  ## Tools Used editor  
# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * I think the error message here should be "NOT_EXPIRED":     require(incentive.expiry < block.timestamp, "EXPIRED");  * There are hardcoded magic numbers, e.g.: 5 weeks or 128. It would make code more readable and maintanable if you extract such numbers as constants, e.g.:   uint public constant EXPIRY_BUFFER = 5 weeks;   require(incentive.endTime + EXPIRY_BUFFER < incentive.expiry, "END_PAST_BUFFER");   
# Handle  pauliax   # Vulnerability details  ## Impact contract ConcentratedLiquidityPosition has a state variable 'wETH' but it is not being used in any meaningful way. So you can remove it to save some gas.  ## Recommended Mitigation Steps Remove useless state variables.  
# Handle  pauliax   # Vulnerability details  ## Impact There is an unused import: import "../../interfaces/ITridentRouter.sol"; in ConcentratedLiquidityPosition. It will increase the size of deployment with no real benefit.  ## Recommended Mitigation Steps Consider removing this unused import to save some gas.   
# Handle  WatchPug   # Vulnerability details  Members of structs should be grouped into bunches of 32 bytes for saving gas.  For example:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L15-L23  `ConcentratedLiquidityPoolManager.sol#Incentive` `rewardsUnclaimed` and `secondsClaimed` can be moved to the bottom to optimize for Variable Packing.  
# Handle  WatchPug   # Vulnerability details  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L58  ```solidity function reclaimIncentive(     IConcentratedLiquidityPool pool,     uint256 incentiveId,     uint256 amount,     address receiver,     bool unwrapBento ) public {     Incentive storage incentive = incentives[pool][incentiveId];     require(incentive.owner == msg.sender, "NOT_OWNER");     require(incentive.expiry < block.timestamp, "EXPIRED");     require(incentive.rewardsUnclaimed >= amount, "ALREADY_CLAIMED");     _transfer(incentive.token, address(this), receiver, amount, unwrapBento);     emit ReclaimIncentive(pool, incentiveId); } ```  When the current time is before the `incentive.expiry` time, the error message should be `NOT_EXPIRED` instead of `EXPIRED`.  
# Handle  WatchPug   # Vulnerability details  When a user calls `ConcentratedLiquidityPosition.sol#collect()` to collect their yield, it calcuates the yield based on `position.pool.rangeFeeGrowth()` and `position.feeGrowthInside0, position.feeGrowthInside1`:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L75-L101  When there are enough tokens in `bento.balanceOf`, it will not call `position.pool.collect()` to collect fees from the pool.  This makes the user who `collect()` their yield when there is enough balance to get double yield when they call `burn()` to remove liquidity. Because `burn()` will automatically collect fees on the pool contract.  ## Impact  The yield belongs to other users will be diluted.  ## Recommended Mitigation Steps  Consider making `ConcentratedLiquidityPosition.sol#burn()` call `position.pool.collect()` before `position.pool.burn()`. User will need to call `ConcentratedLiquidityPosition.sol#collect()` to collect unclaimed fees after `burn()`.  Or `ConcentratedLiquidityPosition.sol#collect()` can be changed into a `public` method and `ConcentratedLiquidityPosition.sol#burn()` can call it after `position.pool.burn()`.  
# Handle  WatchPug   # Vulnerability details  When a user calls `ConcentratedLiquidityPosition.sol#burn()` to burn their liquidity, it calls `ConcentratedLiquidityPool.sol#burn()` -> `_updatePosition()`:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L525-L553  The `_updatePosition()` function will return `amount0fees` and `amount1fees` of the whole position with the `lower` and `upper` tick and send them to the `recipient` alongside the burned liquidity amounts.  ## Proof of Concept  1. Alice minted $10000 worth of liquidity with `lower` and `upper` tick set to 99 and 199; 2. Alice accumulated $1000 worth of fee in token0 and token1; 3. The attacker can mint a small amount ($1 worth) of liquidity using the same `lower` and `upper` tick; 4. The attacker calls `ConcentratedLiquidityPosition.sol#burn()` to steal all the unclaimed yield with the ticks of (99, 199) include the $1000 worth of yield from Alice.  ## Recommended Mitigation Steps  Consider making `ConcentratedLiquidityPosition.sol#burn()` always use `address(this)` as `recipient` in:  ```solidity position.pool.burn(abi.encode(position.lower, position.upper, amount, recipient, unwrapBento)); ```  and transfer proper amounts to the user.  
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.burn` function sends out `amount0`/`amount1` tokens but only updates the reserves by decreasing it by the **fees of these amounts**.  ```solidity unchecked {     // @audit decreases by fees only, not by amount0/amount1     reserve0 -= uint128(amount0fees);     reserve1 -= uint128(amount1fees); } ```  This leads to the pool having wrong reserves after any `burn` action. The pool's balance will be much lower than the reserve variables.  ## Impact As the pool's actual balance will be much lower than the reserve variables, `mint`ing and `swap`ing will not work correctly either. This is because of the `amount0Actual + reserve0 <= _balance(token0)` check in `mint` using a much higher `reserve0` amount than the actual balance (already including the transferred assets from the user). An LP provider will have to make up for the missing reserve decrease from `burn` and pay more tokens.  The same holds true for `swap` which performs the same check in `_updateReserves`.  The pool essentially becomes unusable after a `burn` as LPs / traders need to pay more tokens.  ## Recommended Mitigation Steps The reserve should be decreased by what is transferred out. In `burn`'s case this is `amount0` / `amount1`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.burn` function performs an unsafe cast of a `uint128` type to a _signed_ integer.  ```solidity (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount)); ```  Note that `amount` is chosen by the caller and when choosing `amount = 2**128 - 1`, this is interpreted as `0xFFFFFFFFF... = -1` as a signed integer. Thus `-(-1)=1` adds 1 liquidity unit to the position  This allows an attacker to not only mint LP tokens for free but as this is the `burn` function it also redeems token0/1 amounts according to the unmodified `uint128` `amount` which is an extremely large value.  ## POC I created this POC that implements a hardhat test and shows how to steal the pool tokens.  Choosing the correct `amount` of liquidity to burn and `lower, upper` ticks is not straight-forward because of two competing constraints: 1. the `-int128(amount)` must be less than `MAX_TICK_LIQUIDITY` (see `_updatePosition`). This drives the the `amount` up to its max value (as the max `uint128` value is -1 => -(-1)=1 is very low) 2. The redeemed `amount0, amount1` values must be less than the current pool balance as the transfers would otherwise fail. This drives the `amount` down. However, by choosing a smart `lower` and `upper` tick range we can redeem fewer tokens for the same liquidity.  This example shows how to steal 99% of the `token0` pool reserves: https://gist.github.com/MrToph/1731dd6947073343cf6f942985d556a6  ## Impact An attacker can steal the pool tokens.  ## Recommended Mitigation Steps Even though Solidity 0.8.x is used, type casts do not throw an error. A [`SafeCast` library](https://docs.openzeppelin.com/contracts/4.x/api/utils#SafeCast) must be used everywhere a typecast is done.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.addIncentive` performs an unnecessary check:  ```solidity require(current <= incentive.endTime, "ALREADY_ENDED"); ```  As it already checks that `current <= incentive.startTime` and `incentive.startTime < incentive.endTime`, this check is unnecessary and will always be true by transitivity.  ## Recommended Mitigation Steps Remove the check to save on gas.  
# Handle  cmichel   # Vulnerability details  The `TridentNFT.permitAll` function allows the operator (`isApprovedForAll[owner][recoveredAddress]`) to change the operator (and lock themself out). The same functionality without permits does not work as `setApprovalForAll` requires the `owner` authority.  ## Impact `permitAll` should have the same auth checks as `setApprovalForAll` and not allow the `operator` to change the operator.  ## Recommended Mitigation Steps Remove the `|| isApprovedForAll[owner][recoveredAddress]` from the `require` statement.   
# Handle  cmichel   # Vulnerability details  The `TridentNFT.permit` function ignores the `recoveredAddress != 0` check if `isApprovedForAll[owner][recoveredAddress]` is true.  ## Impact If a user accidentally set the zero address as the operator, tokens can be stolen by anyone as a wrong signature yield `recoveredAddress == 0`.  ## Recommended Mitigation Steps Change the `require` logic to `recoveredAddress != address(0) && (recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress])`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.addIncentive` function can add an incentive that already has a non-zero `incentive.secondsClaimed`.  ## Impact Rewards will be wrong.  ## Recommended Mitigation Steps Add a check: `require(incentive.secondsClaimed == 0, "!secondsClaimed")`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.claimReward` requires `stake.initialized` but it is never set. It also performs a strange computation as `128 - incentive.secondsClaimed` which will almost always underflow and revert the transaction.  ## Impact One cannot claim rewards.  ## Recommended Mitigation Steps Rethink how claiming rewards should work.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager` keeps all tokens for all incentives in the same contract. The `reclaimIncentive` function does not reduce the `incentive.rewardsUnclaimed` field and thus one can reclaim tokens several times. This allows anyone to steal all tokens from all incentives by creating an incentive themself, and once it's expired, repeatedly claim the unclaimed rewards until the token balance is empty.  ## POC - Attacker creates an incentive for a non-existent pool using a random address for `pool` (This is done such that no other user can claim rewards as we need a non-zero `rewardsUnclaimed` balance for expiry). They choose the `incentive.token` to be the token they want to steal from other incentives. (for example, `WETH`, `USDC`, or `SUSHI`) They choose the `startTime, endTime, expiry` such that the checks pass, i.e., starting and ending in a few seconds from now, expiring in 5 weeks. Then they choose a non-zero `rewardsUnclaimed` and transfer the `incentive.token` to the PoolManager. - Attacker waits for 5 weeks until the incentive is expired - Attacker can now call `reclaimIncentive(pool, incentiveId, amount=incentive.rewardsUnclaimed, attacker, false)` to withdraw `incentive.rewardsUnclaimed` of `incentive.token` from the pool manager. - As the `incentive.rewardsUnclaimed` variable has not been decreased, they can keep calling `reclaimIncentive` until the pool is drained.  ## Impact An attacker can steal all tokens in the PoolManager.  ## Recommended Mitigation Steps In `reclaimIncentive`, reduce `incentive.rewardsUnclaimed` by the withdrawn `amount`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.mint/burn` functions add/remove `liquidity` when `(priceLower < currentPrice && currentPrice < priceUpper)`. Shouldn't it also be changed if `priceLower == currentPrice`?  ## Impact Pools that mint/burn liquidity at a time where the `currentPrice` is right at the lower price range do not work correctly and will lead to wrong swap amounts.  ## Recommended Mitigation Steps Change the inequalities to `if (priceLower <= currentPrice && currentPrice < priceUpper)`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.constructor` does not check that `_token0 != _token1`. The pool factory does not ensure this either.  ## Impact Pools can be created using the same token. This should be prevented as it does not make sense.  ## Recommended Mitigation Steps Add a `_token0 != _token1` check to the constructor.   
# Handle  cmichel   # Vulnerability details  The `DyDxMath.getLiquidityForAmounts/getDx/getDy` functions perform unchecked computations on `priceUpper - priceLower` but they do not check that `priceUpper >= priceLower`.  ## Impact The values can underflow and return much lower liquidity or much higher token amounts than expected.  The calling functions (`mint` and `burn`) also do not check this. For `mint`, it fails further down the callstack at `Ticks.insert`, but `burn` does not fail.  ## Recommended Mitigation Steps Check that the `lower` and `upper` from the provided parameters for `mint` and `burn` are indeed sorted, i.e., `lower < upper`. It should be checked explicitly at the start of the function.   
# Handle  broccoli   # Vulnerability details  # range fee growth underflow ## Impact The function `RangeFeeGrowth` [ConcentratedLiquidityPool.sol#L601-L633](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L601-L633) would revert the transaction in some cases.  When a pool cross a tick, it only updates either `feeGrowthOutside0` or `feeGrowthOutside1`. [Ticks.sol#L23-L53](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/Ticks.sol#L23-L53)  `RangeFeeGrowth` calculates the fee as follow: ```solidity             feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;             feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1; ```  `feeGrowthBelow + feeGrowthAbove` is not necessary smaller than `_feeGrowthGlobal`. Please see `POC`.   Users can not provide liquidity or burn liquidity. Fund will get stocked in the contract. I consider this is a high-risk issue.  ## Proof of Concept ```python     # This is the wrapper.     # def add_liquidity(pool, amount, lower, upper)     # def swap(pool, buy, amount)      add_liquidity(pool, deposit_amount, -800, 500)     add_liquidity(pool, deposit_amount, 400, 700)     # We cross the tick here to trigger the bug.      swap(pool, False, deposit_amount)     # Only tick 700's feeGrowthOutside1 is updated      swap(pool, True, deposit_amount)     # Only tick 500's feeGrowthOutside0 is updated          # current tick at -800      # this would revert     # feeGrowthBelow1 = feeGrowthGlobal1     # feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1 would revert     # user would not be able to mint/withdraw/cross this tick. The pool is broken     add_liquidity(pool, deposit_amount, 400, 700) ``` ## Tools Used Hardhat  ## Recommended Mitigation Steps  It's either modify the tick's algo or `RangeFeeGrowth`. The quick-fix I come up with is to deal with the fee in `RangeFeeGrowth`. However, I recommend the team to go through tick's logic again.  
# Handle  WatchPug   # Vulnerability details  The reserves should be updated once LP tokens are burned to match the actual total bento shares hold by the pool.  However, the current implementation only updated reserves with the fees subtracted.  Makes the `reserve0` and `reserve1` smaller than the current `balance0` and `balance1`.  ## Impact  As a result, many essential features of the contract will malfunction, includes `swap()` and `mint()`.  ## Recommended Mitigation Steps  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L263-L267  Change:  ```         unchecked {             reserve0 -= uint128(amount0fees);             reserve1 -= uint128(amount1fees);         }  ``` to:  ```         unchecked {             reserve0 -= uint128(amount0);             reserve1 -= uint128(amount1);         } ```  
# Handle  WatchPug   # Vulnerability details  In `ConcentratedLiquidityPosition.collect()`, balances of token0 and token1 in bento will be used to pay the fees.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L103-L116  ```     uint256 balance0 = bento.balanceOf(token0, address(this));     uint256 balance1 = bento.balanceOf(token1, address(this));     if (balance0 < token0amount || balance1 < token1amount) {         (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);          uint256 newBalance0 = amount0fees + balance0;         uint256 newBalance1 = amount1fees + balance1;          /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw         if (token0amount > newBalance0) token0amount = newBalance0;         if (token1amount > newBalance1) token1amount = newBalance1;     }     _transfer(token0, address(this), recipient, token0amount, unwrapBento);     _transfer(token1, address(this), recipient, token1amount, unwrapBento);  ```  In the case of someone add an incentive with `token0` or `token1`, the incentive in the balance of bento will be used to pay fees until the balance is completely consumed.  As a result, when a user calls `claimReward()`, the contract may not have enough balance to pay (it supposed to have it), cause the transaction to fail.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L78-L100 ``` function claimReward(         uint256 positionId,         uint256 incentiveId,         address recipient,         bool unwrapBento     ) public {         require(ownerOf[positionId] == msg.sender, "OWNER");         Position memory position = positions[positionId];         IConcentratedLiquidityPool pool = position.pool;         Incentive storage incentive = incentives[position.pool][positionId];         Stake storage stake = stakes[positionId][incentiveId];         require(stake.initialized, "UNINITIALIZED");         uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;         uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;         uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;         uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);         uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;         incentive.rewardsUnclaimed -= rewards;         incentive.secondsClaimed += uint160(secondsInside);         stake.secondsInsideLast += uint160(secondsPerLiquidityInside);         _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);         emit ClaimReward(positionId, incentiveId, recipient);     } ```  The same issue applies to `reclaimIncentive()` as well.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L49-L62 ``` function reclaimIncentive(     IConcentratedLiquidityPool pool,     uint256 incentiveId,     uint256 amount,     address receiver,     bool unwrapBento ) public {     Incentive storage incentive = incentives[pool][incentiveId];     require(incentive.owner == msg.sender, "NOT_OWNER");     require(incentive.expiry < block.timestamp, "EXPIRED");     require(incentive.rewardsUnclaimed >= amount, "ALREADY_CLAIMED");     _transfer(incentive.token, address(this), receiver, amount, unwrapBento);     emit ReclaimIncentive(pool, incentiveId); } ```  ## Recommendation  Consider making adding `token0` or `token1` as incentives disallowed, or keep a record of total remaining incentive amounts for the incentive tokens and avoid consuming these revered balances when `collect()`.  
# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  `derrived` → `derived`  `owerflow` → `overflow`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Swap fees are taken from the output. Hence, if swapping token0 for token1 (`zeroForOne` is true), then fees are taken in token1. We see this to be the case in the initialization of feeGrowthGlobal in the swap cache   `feeGrowthGlobal = zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0;`  and in `_updateFees()`.  However, looking at `Ticks.cross()`, the logic is the reverse, which causes wrong fee accounting.  ```jsx if (zeroForOne) {  ...  ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0; } else {  ...  ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1; } ```  ### Recommended Mitigation Steps  Switch the `0` and `1` in `Ticks.cross()`.  ```jsx if (zeroForOne) {  ...  // feeGrowthGlobal = feeGrowthGlobal1  ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1; } else {  ...  // feeGrowthGlobal = feeGrowthGlobal0  ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0; } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The fee growth mechanism, and by extension, secondsPerLiquidity mechanism of Uniswap V3 has the ability to underflow. It is therefore a necessity for the math to (ironically) be unsafe / unchecked.   ### Proof of Concept  Assume the following scenario and initial conditions:  - Price at parity (nearestTick is 0) - tickSpacing of 10 - Swaps only increase the price (nearestTick moves up only) - feeGrowthGlobal initializes with 0, increases by 1 for every tick moved for simplicity - Existing positions that provide enough liquidity and enable nearestTick to be set to values in the example - Every tick initialized in the example is ≤ nearestTick, so that its feeGrowthOutside = feeGrowthGlobal  1. When nearestTick is at 40, Alice creates a position for uninitialised ticks [-20, 30]. The ticks are initialized, resulting in their feeGrowthOutside values to be set to 40. 2. nearestTick moves to 50. Bob creates a position with ticks [20, 30] (tick 20 is uninitialised, 30 was initialized from Alice's mint). tick 20 will therefore have a feeGrowthOutside of 50. 3. Let us calculate `rangeFeeGrowth(20,30)`.     - lowerTick = 20, upperTick = 30     - feeGrowthBelow = 50 (lowerTick's feeGrowthOutside) since lowerTick < currentTick     - feeGrowthAbove = 50 - 40 = 10 (feeGrowthGlobal - upperTick's feeGrowthOutside) since upperTick < currentTick     - feeGrowthInside                  = feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove                  = 50 - 50 - 10                  = -10           We therefore have negative feeGrowthInside.  This behaviour is actually acceptable, because the important thing about this mechanism is the relative values to each other, not the absolute values themselves.  ### Recommended Mitigation Steps  `rangeFeeGrowth()` and `rangeSecondsInside()` has to be unchecked. In addition, the subtraction of feeGrowthInside values should also be unchecked in `_updatePosition()` and `ConcentratedLiquidityPosition#collect()`.  The same also applies for the subtraction of `pool.rangeSecondsInside` and `stake.secondsInsideLast` in `claimReward()` and `getReward()` of the `ConcentratedLiquidityPoolManager` contract.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  No check is performed for the initial price. This means that it can be set to be below the `MIN_SQRT_RATIO` or above `MAX_SQRT_RATIO` (Eg. zero value), which will prevent the usability of all other functions (minting, swapping, burning).  For example, `Ticks.insert()` would fail when attempting to calculate `actualNearestTick = TickMath.getTickAtSqrtRatio(currentPrice);`, which means no one will be able to mint positions.  ### Recommended Mitigation Steps  Check the `initialPrice` is within the acceptable range, ie. `MIN_SQRT_RATIO <= initialPrice <= MAX_SQRT_RATIO`  
# Handle  broccoli   # Vulnerability details  ## Impact  In the `burn` and `swap` functions of `ConcentratedLiquidityPool`, the lower tick is not explicitly checked to be less than the upper tick. Besides, the ticks are not checked to be at least the minimum tick and at most the maximum tick.  ## Proof of Concept  Referenced code: [Ticks.sol#L68-L70](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/Ticks.sol#L68-L70)  ## Recommended Mitigation Steps  Add sanity checks on the lower and upper ticks in critical functions (see the referenced line of code, for example).  
# Handle  broccoli   # Vulnerability details  ## Impact  The `_getAmountsForLiquidity` function of `ConcentratedLiquidityPool` explicitly converts the result of `DyDxMath.getDy` and `DyDxMath.getDx` from type `uint256` to type `uint128`. The explicit casting without checking whether the integer exceeds the maximum number (i.e., `type(uint128).max`) could cause incorrect results being used. Specifically, an attacker could exploit this bug to mint a large amount of liquidity but only pay a little of `token0` or `token1` to the pool and effectively steal other's funds when burning his liquidity.  ## Proof of Concept  1. Suppose that the current price is at the tick `500000`, an attacker calls the `mint` function with the following parameters:  ``` mintParams.lower = 100000 mintParams.upper = 500000 mintParams.amount1Desired = (1 << 128) + 71914955423 # a carefully chosen number mintParams.amount0Desired = 0 ```  2. Since the current price is equal to the upper price, we have  ``` _liquidity = mintParams.amount1Desired * (1 << 96) // (priceUpper - priceLower)            = 4731732988155153573010127840 ```  3. The amounts of `token0` and `token1` that the attacker has to pay is  ``` amount0Actual = 0 amount1Actual = uint128(DyDxMath.getDy(_liquidity, priceLower, priceUpper, true))               = uint128(_liquidity * (priceUpper - priceLower) // (1 << 96)) # round up               = uint128(340282366920938463463374607456141861046)             # exceed the max               = 24373649590                                                  # truncated ```  4. The attacker only pays `24373649590` of `token1` to get `4731732988155153573010127840` of the liquidity, which he could burn to get more `token1`. As a result, the attacker is stealing the funds from the pool and could potentially drain it.  Referenced code: [ConcentratedLiquidityPool.sol#L480](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L480) [concentratedPool/DyDxMath.sol#L15](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/DyDxMath.sol#L15) [concentratedPool/DyDxMath.sol#L30](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/DyDxMath.sol#L30)  ## Recommended Mitigation Steps  Check whether the result of `DyDxMath.getDy` or `DyDxMath.getDx` exceeds `type(uint128).max` or not. If so, then revert the transaction. Or consider using the [`SafeCast` library](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast) from OpenZeppelin instead.  
# Handle  0xsanson   # Vulnerability details  ## Impact When an user subscribes to an incentive using ConcentratedLiquidityPoolManager's `subscribe`, the function checks that `incentiveId` is appropriate: ```js require(incentiveId <= incentiveCount[pool], "NOT_INCENTIVE"); ``` This check is actually incorrect, and it should use a `<` instead of `<=`.  If this was the only requirement, it would be possible to subscribe to the next incentive, causing some problems. Fortunately the next line saves the day: `require(block.timestamp > incentive.startTime && block.timestamp < incentive.endTime, "TIMED_OUT");` this fails for uninitiated incentives.  ## Proof of Concept https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L72  ## Tools Used editor  ## Recommended Mitigation Steps Consider removing this requirement to save gas. The check for existing pool is already considered when looking at `block.timestamp < incentive.endTime`.  
# Handle  0xsanson   # Vulnerability details  ## Impact Function `addIncentive` and `reclaimIncentive` in ConcentratedLiquidityPoolManager can be `external` instead of `public` to save gas.  ## Proof of Concept https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L36 https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L49  ## Tools Used editor  
# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * I think the error message here should be "NOT_EXPIRED":     require(incentive.expiry < block.timestamp, "EXPIRED");  * There are hardcoded magic numbers, e.g.: 5 weeks or 128. It would make code more readable and maintanable if you extract such numbers as constants, e.g.:   uint public constant EXPIRY_BUFFER = 5 weeks;   require(incentive.endTime + EXPIRY_BUFFER < incentive.expiry, "END_PAST_BUFFER");   
# Handle  pauliax   # Vulnerability details  ## Impact contract ConcentratedLiquidityPosition has a state variable 'wETH' but it is not being used in any meaningful way. So you can remove it to save some gas.  ## Recommended Mitigation Steps Remove useless state variables.  
# Handle  pauliax   # Vulnerability details  ## Impact There is an unused import: import "../../interfaces/ITridentRouter.sol"; in ConcentratedLiquidityPosition. It will increase the size of deployment with no real benefit.  ## Recommended Mitigation Steps Consider removing this unused import to save some gas.   
# Handle  WatchPug   # Vulnerability details  Members of structs should be grouped into bunches of 32 bytes for saving gas.  For example:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L15-L23  `ConcentratedLiquidityPoolManager.sol#Incentive` `rewardsUnclaimed` and `secondsClaimed` can be moved to the bottom to optimize for Variable Packing.  
# Handle  WatchPug   # Vulnerability details  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L58  ```solidity function reclaimIncentive(     IConcentratedLiquidityPool pool,     uint256 incentiveId,     uint256 amount,     address receiver,     bool unwrapBento ) public {     Incentive storage incentive = incentives[pool][incentiveId];     require(incentive.owner == msg.sender, "NOT_OWNER");     require(incentive.expiry < block.timestamp, "EXPIRED");     require(incentive.rewardsUnclaimed >= amount, "ALREADY_CLAIMED");     _transfer(incentive.token, address(this), receiver, amount, unwrapBento);     emit ReclaimIncentive(pool, incentiveId); } ```  When the current time is before the `incentive.expiry` time, the error message should be `NOT_EXPIRED` instead of `EXPIRED`.  
# Handle  WatchPug   # Vulnerability details  When a user calls `ConcentratedLiquidityPosition.sol#collect()` to collect their yield, it calcuates the yield based on `position.pool.rangeFeeGrowth()` and `position.feeGrowthInside0, position.feeGrowthInside1`:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L75-L101  When there are enough tokens in `bento.balanceOf`, it will not call `position.pool.collect()` to collect fees from the pool.  This makes the user who `collect()` their yield when there is enough balance to get double yield when they call `burn()` to remove liquidity. Because `burn()` will automatically collect fees on the pool contract.  ## Impact  The yield belongs to other users will be diluted.  ## Recommended Mitigation Steps  Consider making `ConcentratedLiquidityPosition.sol#burn()` call `position.pool.collect()` before `position.pool.burn()`. User will need to call `ConcentratedLiquidityPosition.sol#collect()` to collect unclaimed fees after `burn()`.  Or `ConcentratedLiquidityPosition.sol#collect()` can be changed into a `public` method and `ConcentratedLiquidityPosition.sol#burn()` can call it after `position.pool.burn()`.  
# Handle  WatchPug   # Vulnerability details  When a user calls `ConcentratedLiquidityPosition.sol#burn()` to burn their liquidity, it calls `ConcentratedLiquidityPool.sol#burn()` -> `_updatePosition()`:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L525-L553  The `_updatePosition()` function will return `amount0fees` and `amount1fees` of the whole position with the `lower` and `upper` tick and send them to the `recipient` alongside the burned liquidity amounts.  ## Proof of Concept  1. Alice minted $10000 worth of liquidity with `lower` and `upper` tick set to 99 and 199; 2. Alice accumulated $1000 worth of fee in token0 and token1; 3. The attacker can mint a small amount ($1 worth) of liquidity using the same `lower` and `upper` tick; 4. The attacker calls `ConcentratedLiquidityPosition.sol#burn()` to steal all the unclaimed yield with the ticks of (99, 199) include the $1000 worth of yield from Alice.  ## Recommended Mitigation Steps  Consider making `ConcentratedLiquidityPosition.sol#burn()` always use `address(this)` as `recipient` in:  ```solidity position.pool.burn(abi.encode(position.lower, position.upper, amount, recipient, unwrapBento)); ```  and transfer proper amounts to the user.  
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.burn` function sends out `amount0`/`amount1` tokens but only updates the reserves by decreasing it by the **fees of these amounts**.  ```solidity unchecked {     // @audit decreases by fees only, not by amount0/amount1     reserve0 -= uint128(amount0fees);     reserve1 -= uint128(amount1fees); } ```  This leads to the pool having wrong reserves after any `burn` action. The pool's balance will be much lower than the reserve variables.  ## Impact As the pool's actual balance will be much lower than the reserve variables, `mint`ing and `swap`ing will not work correctly either. This is because of the `amount0Actual + reserve0 <= _balance(token0)` check in `mint` using a much higher `reserve0` amount than the actual balance (already including the transferred assets from the user). An LP provider will have to make up for the missing reserve decrease from `burn` and pay more tokens.  The same holds true for `swap` which performs the same check in `_updateReserves`.  The pool essentially becomes unusable after a `burn` as LPs / traders need to pay more tokens.  ## Recommended Mitigation Steps The reserve should be decreased by what is transferred out. In `burn`'s case this is `amount0` / `amount1`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.burn` function performs an unsafe cast of a `uint128` type to a _signed_ integer.  ```solidity (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount)); ```  Note that `amount` is chosen by the caller and when choosing `amount = 2**128 - 1`, this is interpreted as `0xFFFFFFFFF... = -1` as a signed integer. Thus `-(-1)=1` adds 1 liquidity unit to the position  This allows an attacker to not only mint LP tokens for free but as this is the `burn` function it also redeems token0/1 amounts according to the unmodified `uint128` `amount` which is an extremely large value.  ## POC I created this POC that implements a hardhat test and shows how to steal the pool tokens.  Choosing the correct `amount` of liquidity to burn and `lower, upper` ticks is not straight-forward because of two competing constraints: 1. the `-int128(amount)` must be less than `MAX_TICK_LIQUIDITY` (see `_updatePosition`). This drives the the `amount` up to its max value (as the max `uint128` value is -1 => -(-1)=1 is very low) 2. The redeemed `amount0, amount1` values must be less than the current pool balance as the transfers would otherwise fail. This drives the `amount` down. However, by choosing a smart `lower` and `upper` tick range we can redeem fewer tokens for the same liquidity.  This example shows how to steal 99% of the `token0` pool reserves: https://gist.github.com/MrToph/1731dd6947073343cf6f942985d556a6  ## Impact An attacker can steal the pool tokens.  ## Recommended Mitigation Steps Even though Solidity 0.8.x is used, type casts do not throw an error. A [`SafeCast` library](https://docs.openzeppelin.com/contracts/4.x/api/utils#SafeCast) must be used everywhere a typecast is done.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.addIncentive` performs an unnecessary check:  ```solidity require(current <= incentive.endTime, "ALREADY_ENDED"); ```  As it already checks that `current <= incentive.startTime` and `incentive.startTime < incentive.endTime`, this check is unnecessary and will always be true by transitivity.  ## Recommended Mitigation Steps Remove the check to save on gas.  
# Handle  cmichel   # Vulnerability details  The `TridentNFT.permitAll` function allows the operator (`isApprovedForAll[owner][recoveredAddress]`) to change the operator (and lock themself out). The same functionality without permits does not work as `setApprovalForAll` requires the `owner` authority.  ## Impact `permitAll` should have the same auth checks as `setApprovalForAll` and not allow the `operator` to change the operator.  ## Recommended Mitigation Steps Remove the `|| isApprovedForAll[owner][recoveredAddress]` from the `require` statement.   
# Handle  cmichel   # Vulnerability details  The `TridentNFT.permit` function ignores the `recoveredAddress != 0` check if `isApprovedForAll[owner][recoveredAddress]` is true.  ## Impact If a user accidentally set the zero address as the operator, tokens can be stolen by anyone as a wrong signature yield `recoveredAddress == 0`.  ## Recommended Mitigation Steps Change the `require` logic to `recoveredAddress != address(0) && (recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress])`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.addIncentive` function can add an incentive that already has a non-zero `incentive.secondsClaimed`.  ## Impact Rewards will be wrong.  ## Recommended Mitigation Steps Add a check: `require(incentive.secondsClaimed == 0, "!secondsClaimed")`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.claimReward` requires `stake.initialized` but it is never set. It also performs a strange computation as `128 - incentive.secondsClaimed` which will almost always underflow and revert the transaction.  ## Impact One cannot claim rewards.  ## Recommended Mitigation Steps Rethink how claiming rewards should work.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager` keeps all tokens for all incentives in the same contract. The `reclaimIncentive` function does not reduce the `incentive.rewardsUnclaimed` field and thus one can reclaim tokens several times. This allows anyone to steal all tokens from all incentives by creating an incentive themself, and once it's expired, repeatedly claim the unclaimed rewards until the token balance is empty.  ## POC - Attacker creates an incentive for a non-existent pool using a random address for `pool` (This is done such that no other user can claim rewards as we need a non-zero `rewardsUnclaimed` balance for expiry). They choose the `incentive.token` to be the token they want to steal from other incentives. (for example, `WETH`, `USDC`, or `SUSHI`) They choose the `startTime, endTime, expiry` such that the checks pass, i.e., starting and ending in a few seconds from now, expiring in 5 weeks. Then they choose a non-zero `rewardsUnclaimed` and transfer the `incentive.token` to the PoolManager. - Attacker waits for 5 weeks until the incentive is expired - Attacker can now call `reclaimIncentive(pool, incentiveId, amount=incentive.rewardsUnclaimed, attacker, false)` to withdraw `incentive.rewardsUnclaimed` of `incentive.token` from the pool manager. - As the `incentive.rewardsUnclaimed` variable has not been decreased, they can keep calling `reclaimIncentive` until the pool is drained.  ## Impact An attacker can steal all tokens in the PoolManager.  ## Recommended Mitigation Steps In `reclaimIncentive`, reduce `incentive.rewardsUnclaimed` by the withdrawn `amount`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.mint/burn` functions add/remove `liquidity` when `(priceLower < currentPrice && currentPrice < priceUpper)`. Shouldn't it also be changed if `priceLower == currentPrice`?  ## Impact Pools that mint/burn liquidity at a time where the `currentPrice` is right at the lower price range do not work correctly and will lead to wrong swap amounts.  ## Recommended Mitigation Steps Change the inequalities to `if (priceLower <= currentPrice && currentPrice < priceUpper)`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.constructor` does not check that `_token0 != _token1`. The pool factory does not ensure this either.  ## Impact Pools can be created using the same token. This should be prevented as it does not make sense.  ## Recommended Mitigation Steps Add a `_token0 != _token1` check to the constructor.   
# Handle  cmichel   # Vulnerability details  The `DyDxMath.getLiquidityForAmounts/getDx/getDy` functions perform unchecked computations on `priceUpper - priceLower` but they do not check that `priceUpper >= priceLower`.  ## Impact The values can underflow and return much lower liquidity or much higher token amounts than expected.  The calling functions (`mint` and `burn`) also do not check this. For `mint`, it fails further down the callstack at `Ticks.insert`, but `burn` does not fail.  ## Recommended Mitigation Steps Check that the `lower` and `upper` from the provided parameters for `mint` and `burn` are indeed sorted, i.e., `lower < upper`. It should be checked explicitly at the start of the function.   
# Handle  broccoli   # Vulnerability details  # range fee growth underflow ## Impact The function `RangeFeeGrowth` [ConcentratedLiquidityPool.sol#L601-L633](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L601-L633) would revert the transaction in some cases.  When a pool cross a tick, it only updates either `feeGrowthOutside0` or `feeGrowthOutside1`. [Ticks.sol#L23-L53](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/Ticks.sol#L23-L53)  `RangeFeeGrowth` calculates the fee as follow: ```solidity             feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;             feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1; ```  `feeGrowthBelow + feeGrowthAbove` is not necessary smaller than `_feeGrowthGlobal`. Please see `POC`.   Users can not provide liquidity or burn liquidity. Fund will get stocked in the contract. I consider this is a high-risk issue.  ## Proof of Concept ```python     # This is the wrapper.     # def add_liquidity(pool, amount, lower, upper)     # def swap(pool, buy, amount)      add_liquidity(pool, deposit_amount, -800, 500)     add_liquidity(pool, deposit_amount, 400, 700)     # We cross the tick here to trigger the bug.      swap(pool, False, deposit_amount)     # Only tick 700's feeGrowthOutside1 is updated      swap(pool, True, deposit_amount)     # Only tick 500's feeGrowthOutside0 is updated          # current tick at -800      # this would revert     # feeGrowthBelow1 = feeGrowthGlobal1     # feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1 would revert     # user would not be able to mint/withdraw/cross this tick. The pool is broken     add_liquidity(pool, deposit_amount, 400, 700) ``` ## Tools Used Hardhat  ## Recommended Mitigation Steps  It's either modify the tick's algo or `RangeFeeGrowth`. The quick-fix I come up with is to deal with the fee in `RangeFeeGrowth`. However, I recommend the team to go through tick's logic again.  
# Handle  WatchPug   # Vulnerability details  The reserves should be updated once LP tokens are burned to match the actual total bento shares hold by the pool.  However, the current implementation only updated reserves with the fees subtracted.  Makes the `reserve0` and `reserve1` smaller than the current `balance0` and `balance1`.  ## Impact  As a result, many essential features of the contract will malfunction, includes `swap()` and `mint()`.  ## Recommended Mitigation Steps  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L263-L267  Change:  ```         unchecked {             reserve0 -= uint128(amount0fees);             reserve1 -= uint128(amount1fees);         }  ``` to:  ```         unchecked {             reserve0 -= uint128(amount0);             reserve1 -= uint128(amount1);         } ```  
# Handle  WatchPug   # Vulnerability details  In `ConcentratedLiquidityPosition.collect()`, balances of token0 and token1 in bento will be used to pay the fees.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L103-L116  ```     uint256 balance0 = bento.balanceOf(token0, address(this));     uint256 balance1 = bento.balanceOf(token1, address(this));     if (balance0 < token0amount || balance1 < token1amount) {         (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);          uint256 newBalance0 = amount0fees + balance0;         uint256 newBalance1 = amount1fees + balance1;          /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw         if (token0amount > newBalance0) token0amount = newBalance0;         if (token1amount > newBalance1) token1amount = newBalance1;     }     _transfer(token0, address(this), recipient, token0amount, unwrapBento);     _transfer(token1, address(this), recipient, token1amount, unwrapBento);  ```  In the case of someone add an incentive with `token0` or `token1`, the incentive in the balance of bento will be used to pay fees until the balance is completely consumed.  As a result, when a user calls `claimReward()`, the contract may not have enough balance to pay (it supposed to have it), cause the transaction to fail.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L78-L100 ``` function claimReward(         uint256 positionId,         uint256 incentiveId,         address recipient,         bool unwrapBento     ) public {         require(ownerOf[positionId] == msg.sender, "OWNER");         Position memory position = positions[positionId];         IConcentratedLiquidityPool pool = position.pool;         Incentive storage incentive = incentives[position.pool][positionId];         Stake storage stake = stakes[positionId][incentiveId];         require(stake.initialized, "UNINITIALIZED");         uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;         uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;         uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;         uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);         uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;         incentive.rewardsUnclaimed -= rewards;         incentive.secondsClaimed += uint160(secondsInside);         stake.secondsInsideLast += uint160(secondsPerLiquidityInside);         _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);         emit ClaimReward(positionId, incentiveId, recipient);     } ```  The same issue applies to `reclaimIncentive()` as well.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L49-L62 ``` function reclaimIncentive(     IConcentratedLiquidityPool pool,     uint256 incentiveId,     uint256 amount,     address receiver,     bool unwrapBento ) public {     Incentive storage incentive = incentives[pool][incentiveId];     require(incentive.owner == msg.sender, "NOT_OWNER");     require(incentive.expiry < block.timestamp, "EXPIRED");     require(incentive.rewardsUnclaimed >= amount, "ALREADY_CLAIMED");     _transfer(incentive.token, address(this), receiver, amount, unwrapBento);     emit ReclaimIncentive(pool, incentiveId); } ```  ## Recommendation  Consider making adding `token0` or `token1` as incentives disallowed, or keep a record of total remaining incentive amounts for the incentive tokens and avoid consuming these revered balances when `collect()`.  
# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  `derrived` → `derived`  `owerflow` → `overflow`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Swap fees are taken from the output. Hence, if swapping token0 for token1 (`zeroForOne` is true), then fees are taken in token1. We see this to be the case in the initialization of feeGrowthGlobal in the swap cache   `feeGrowthGlobal = zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0;`  and in `_updateFees()`.  However, looking at `Ticks.cross()`, the logic is the reverse, which causes wrong fee accounting.  ```jsx if (zeroForOne) {  ...  ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0; } else {  ...  ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1; } ```  ### Recommended Mitigation Steps  Switch the `0` and `1` in `Ticks.cross()`.  ```jsx if (zeroForOne) {  ...  // feeGrowthGlobal = feeGrowthGlobal1  ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1; } else {  ...  // feeGrowthGlobal = feeGrowthGlobal0  ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0; } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The fee growth mechanism, and by extension, secondsPerLiquidity mechanism of Uniswap V3 has the ability to underflow. It is therefore a necessity for the math to (ironically) be unsafe / unchecked.   ### Proof of Concept  Assume the following scenario and initial conditions:  - Price at parity (nearestTick is 0) - tickSpacing of 10 - Swaps only increase the price (nearestTick moves up only) - feeGrowthGlobal initializes with 0, increases by 1 for every tick moved for simplicity - Existing positions that provide enough liquidity and enable nearestTick to be set to values in the example - Every tick initialized in the example is ≤ nearestTick, so that its feeGrowthOutside = feeGrowthGlobal  1. When nearestTick is at 40, Alice creates a position for uninitialised ticks [-20, 30]. The ticks are initialized, resulting in their feeGrowthOutside values to be set to 40. 2. nearestTick moves to 50. Bob creates a position with ticks [20, 30] (tick 20 is uninitialised, 30 was initialized from Alice's mint). tick 20 will therefore have a feeGrowthOutside of 50. 3. Let us calculate `rangeFeeGrowth(20,30)`.     - lowerTick = 20, upperTick = 30     - feeGrowthBelow = 50 (lowerTick's feeGrowthOutside) since lowerTick < currentTick     - feeGrowthAbove = 50 - 40 = 10 (feeGrowthGlobal - upperTick's feeGrowthOutside) since upperTick < currentTick     - feeGrowthInside                  = feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove                  = 50 - 50 - 10                  = -10           We therefore have negative feeGrowthInside.  This behaviour is actually acceptable, because the important thing about this mechanism is the relative values to each other, not the absolute values themselves.  ### Recommended Mitigation Steps  `rangeFeeGrowth()` and `rangeSecondsInside()` has to be unchecked. In addition, the subtraction of feeGrowthInside values should also be unchecked in `_updatePosition()` and `ConcentratedLiquidityPosition#collect()`.  The same also applies for the subtraction of `pool.rangeSecondsInside` and `stake.secondsInsideLast` in `claimReward()` and `getReward()` of the `ConcentratedLiquidityPoolManager` contract.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  No check is performed for the initial price. This means that it can be set to be below the `MIN_SQRT_RATIO` or above `MAX_SQRT_RATIO` (Eg. zero value), which will prevent the usability of all other functions (minting, swapping, burning).  For example, `Ticks.insert()` would fail when attempting to calculate `actualNearestTick = TickMath.getTickAtSqrtRatio(currentPrice);`, which means no one will be able to mint positions.  ### Recommended Mitigation Steps  Check the `initialPrice` is within the acceptable range, ie. `MIN_SQRT_RATIO <= initialPrice <= MAX_SQRT_RATIO`  
# Handle  broccoli   # Vulnerability details  ## Impact  In the `burn` and `swap` functions of `ConcentratedLiquidityPool`, the lower tick is not explicitly checked to be less than the upper tick. Besides, the ticks are not checked to be at least the minimum tick and at most the maximum tick.  ## Proof of Concept  Referenced code: [Ticks.sol#L68-L70](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/Ticks.sol#L68-L70)  ## Recommended Mitigation Steps  Add sanity checks on the lower and upper ticks in critical functions (see the referenced line of code, for example).  
# Handle  broccoli   # Vulnerability details  ## Impact  The `_getAmountsForLiquidity` function of `ConcentratedLiquidityPool` explicitly converts the result of `DyDxMath.getDy` and `DyDxMath.getDx` from type `uint256` to type `uint128`. The explicit casting without checking whether the integer exceeds the maximum number (i.e., `type(uint128).max`) could cause incorrect results being used. Specifically, an attacker could exploit this bug to mint a large amount of liquidity but only pay a little of `token0` or `token1` to the pool and effectively steal other's funds when burning his liquidity.  ## Proof of Concept  1. Suppose that the current price is at the tick `500000`, an attacker calls the `mint` function with the following parameters:  ``` mintParams.lower = 100000 mintParams.upper = 500000 mintParams.amount1Desired = (1 << 128) + 71914955423 # a carefully chosen number mintParams.amount0Desired = 0 ```  2. Since the current price is equal to the upper price, we have  ``` _liquidity = mintParams.amount1Desired * (1 << 96) // (priceUpper - priceLower)            = 4731732988155153573010127840 ```  3. The amounts of `token0` and `token1` that the attacker has to pay is  ``` amount0Actual = 0 amount1Actual = uint128(DyDxMath.getDy(_liquidity, priceLower, priceUpper, true))               = uint128(_liquidity * (priceUpper - priceLower) // (1 << 96)) # round up               = uint128(340282366920938463463374607456141861046)             # exceed the max               = 24373649590                                                  # truncated ```  4. The attacker only pays `24373649590` of `token1` to get `4731732988155153573010127840` of the liquidity, which he could burn to get more `token1`. As a result, the attacker is stealing the funds from the pool and could potentially drain it.  Referenced code: [ConcentratedLiquidityPool.sol#L480](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L480) [concentratedPool/DyDxMath.sol#L15](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/DyDxMath.sol#L15) [concentratedPool/DyDxMath.sol#L30](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/DyDxMath.sol#L30)  ## Recommended Mitigation Steps  Check whether the result of `DyDxMath.getDy` or `DyDxMath.getDx` exceeds `type(uint128).max` or not. If so, then revert the transaction. Or consider using the [`SafeCast` library](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast) from OpenZeppelin instead.  
# Handle  0xsanson   # Vulnerability details  ## Impact When an user subscribes to an incentive using ConcentratedLiquidityPoolManager's `subscribe`, the function checks that `incentiveId` is appropriate: ```js require(incentiveId <= incentiveCount[pool], "NOT_INCENTIVE"); ``` This check is actually incorrect, and it should use a `<` instead of `<=`.  If this was the only requirement, it would be possible to subscribe to the next incentive, causing some problems. Fortunately the next line saves the day: `require(block.timestamp > incentive.startTime && block.timestamp < incentive.endTime, "TIMED_OUT");` this fails for uninitiated incentives.  ## Proof of Concept https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L72  ## Tools Used editor  ## Recommended Mitigation Steps Consider removing this requirement to save gas. The check for existing pool is already considered when looking at `block.timestamp < incentive.endTime`.  
# Handle  0xsanson   # Vulnerability details  ## Impact Function `addIncentive` and `reclaimIncentive` in ConcentratedLiquidityPoolManager can be `external` instead of `public` to save gas.  ## Proof of Concept https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L36 https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L49  ## Tools Used editor  
# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * I think the error message here should be "NOT_EXPIRED":     require(incentive.expiry < block.timestamp, "EXPIRED");  * There are hardcoded magic numbers, e.g.: 5 weeks or 128. It would make code more readable and maintanable if you extract such numbers as constants, e.g.:   uint public constant EXPIRY_BUFFER = 5 weeks;   require(incentive.endTime + EXPIRY_BUFFER < incentive.expiry, "END_PAST_BUFFER");   
# Handle  pauliax   # Vulnerability details  ## Impact contract ConcentratedLiquidityPosition has a state variable 'wETH' but it is not being used in any meaningful way. So you can remove it to save some gas.  ## Recommended Mitigation Steps Remove useless state variables.  
# Handle  pauliax   # Vulnerability details  ## Impact There is an unused import: import "../../interfaces/ITridentRouter.sol"; in ConcentratedLiquidityPosition. It will increase the size of deployment with no real benefit.  ## Recommended Mitigation Steps Consider removing this unused import to save some gas.   
# Handle  WatchPug   # Vulnerability details  Members of structs should be grouped into bunches of 32 bytes for saving gas.  For example:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L15-L23  `ConcentratedLiquidityPoolManager.sol#Incentive` `rewardsUnclaimed` and `secondsClaimed` can be moved to the bottom to optimize for Variable Packing.  
# Handle  WatchPug   # Vulnerability details  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L58  ```solidity function reclaimIncentive(     IConcentratedLiquidityPool pool,     uint256 incentiveId,     uint256 amount,     address receiver,     bool unwrapBento ) public {     Incentive storage incentive = incentives[pool][incentiveId];     require(incentive.owner == msg.sender, "NOT_OWNER");     require(incentive.expiry < block.timestamp, "EXPIRED");     require(incentive.rewardsUnclaimed >= amount, "ALREADY_CLAIMED");     _transfer(incentive.token, address(this), receiver, amount, unwrapBento);     emit ReclaimIncentive(pool, incentiveId); } ```  When the current time is before the `incentive.expiry` time, the error message should be `NOT_EXPIRED` instead of `EXPIRED`.  
# Handle  WatchPug   # Vulnerability details  When a user calls `ConcentratedLiquidityPosition.sol#collect()` to collect their yield, it calcuates the yield based on `position.pool.rangeFeeGrowth()` and `position.feeGrowthInside0, position.feeGrowthInside1`:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L75-L101  When there are enough tokens in `bento.balanceOf`, it will not call `position.pool.collect()` to collect fees from the pool.  This makes the user who `collect()` their yield when there is enough balance to get double yield when they call `burn()` to remove liquidity. Because `burn()` will automatically collect fees on the pool contract.  ## Impact  The yield belongs to other users will be diluted.  ## Recommended Mitigation Steps  Consider making `ConcentratedLiquidityPosition.sol#burn()` call `position.pool.collect()` before `position.pool.burn()`. User will need to call `ConcentratedLiquidityPosition.sol#collect()` to collect unclaimed fees after `burn()`.  Or `ConcentratedLiquidityPosition.sol#collect()` can be changed into a `public` method and `ConcentratedLiquidityPosition.sol#burn()` can call it after `position.pool.burn()`.  
# Handle  WatchPug   # Vulnerability details  When a user calls `ConcentratedLiquidityPosition.sol#burn()` to burn their liquidity, it calls `ConcentratedLiquidityPool.sol#burn()` -> `_updatePosition()`:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L525-L553  The `_updatePosition()` function will return `amount0fees` and `amount1fees` of the whole position with the `lower` and `upper` tick and send them to the `recipient` alongside the burned liquidity amounts.  ## Proof of Concept  1. Alice minted $10000 worth of liquidity with `lower` and `upper` tick set to 99 and 199; 2. Alice accumulated $1000 worth of fee in token0 and token1; 3. The attacker can mint a small amount ($1 worth) of liquidity using the same `lower` and `upper` tick; 4. The attacker calls `ConcentratedLiquidityPosition.sol#burn()` to steal all the unclaimed yield with the ticks of (99, 199) include the $1000 worth of yield from Alice.  ## Recommended Mitigation Steps  Consider making `ConcentratedLiquidityPosition.sol#burn()` always use `address(this)` as `recipient` in:  ```solidity position.pool.burn(abi.encode(position.lower, position.upper, amount, recipient, unwrapBento)); ```  and transfer proper amounts to the user.  
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.burn` function sends out `amount0`/`amount1` tokens but only updates the reserves by decreasing it by the **fees of these amounts**.  ```solidity unchecked {     // @audit decreases by fees only, not by amount0/amount1     reserve0 -= uint128(amount0fees);     reserve1 -= uint128(amount1fees); } ```  This leads to the pool having wrong reserves after any `burn` action. The pool's balance will be much lower than the reserve variables.  ## Impact As the pool's actual balance will be much lower than the reserve variables, `mint`ing and `swap`ing will not work correctly either. This is because of the `amount0Actual + reserve0 <= _balance(token0)` check in `mint` using a much higher `reserve0` amount than the actual balance (already including the transferred assets from the user). An LP provider will have to make up for the missing reserve decrease from `burn` and pay more tokens.  The same holds true for `swap` which performs the same check in `_updateReserves`.  The pool essentially becomes unusable after a `burn` as LPs / traders need to pay more tokens.  ## Recommended Mitigation Steps The reserve should be decreased by what is transferred out. In `burn`'s case this is `amount0` / `amount1`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.burn` function performs an unsafe cast of a `uint128` type to a _signed_ integer.  ```solidity (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount)); ```  Note that `amount` is chosen by the caller and when choosing `amount = 2**128 - 1`, this is interpreted as `0xFFFFFFFFF... = -1` as a signed integer. Thus `-(-1)=1` adds 1 liquidity unit to the position  This allows an attacker to not only mint LP tokens for free but as this is the `burn` function it also redeems token0/1 amounts according to the unmodified `uint128` `amount` which is an extremely large value.  ## POC I created this POC that implements a hardhat test and shows how to steal the pool tokens.  Choosing the correct `amount` of liquidity to burn and `lower, upper` ticks is not straight-forward because of two competing constraints: 1. the `-int128(amount)` must be less than `MAX_TICK_LIQUIDITY` (see `_updatePosition`). This drives the the `amount` up to its max value (as the max `uint128` value is -1 => -(-1)=1 is very low) 2. The redeemed `amount0, amount1` values must be less than the current pool balance as the transfers would otherwise fail. This drives the `amount` down. However, by choosing a smart `lower` and `upper` tick range we can redeem fewer tokens for the same liquidity.  This example shows how to steal 99% of the `token0` pool reserves: https://gist.github.com/MrToph/1731dd6947073343cf6f942985d556a6  ## Impact An attacker can steal the pool tokens.  ## Recommended Mitigation Steps Even though Solidity 0.8.x is used, type casts do not throw an error. A [`SafeCast` library](https://docs.openzeppelin.com/contracts/4.x/api/utils#SafeCast) must be used everywhere a typecast is done.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.addIncentive` performs an unnecessary check:  ```solidity require(current <= incentive.endTime, "ALREADY_ENDED"); ```  As it already checks that `current <= incentive.startTime` and `incentive.startTime < incentive.endTime`, this check is unnecessary and will always be true by transitivity.  ## Recommended Mitigation Steps Remove the check to save on gas.  
# Handle  cmichel   # Vulnerability details  The `TridentNFT.permitAll` function allows the operator (`isApprovedForAll[owner][recoveredAddress]`) to change the operator (and lock themself out). The same functionality without permits does not work as `setApprovalForAll` requires the `owner` authority.  ## Impact `permitAll` should have the same auth checks as `setApprovalForAll` and not allow the `operator` to change the operator.  ## Recommended Mitigation Steps Remove the `|| isApprovedForAll[owner][recoveredAddress]` from the `require` statement.   
# Handle  cmichel   # Vulnerability details  The `TridentNFT.permit` function ignores the `recoveredAddress != 0` check if `isApprovedForAll[owner][recoveredAddress]` is true.  ## Impact If a user accidentally set the zero address as the operator, tokens can be stolen by anyone as a wrong signature yield `recoveredAddress == 0`.  ## Recommended Mitigation Steps Change the `require` logic to `recoveredAddress != address(0) && (recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress])`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.addIncentive` function can add an incentive that already has a non-zero `incentive.secondsClaimed`.  ## Impact Rewards will be wrong.  ## Recommended Mitigation Steps Add a check: `require(incentive.secondsClaimed == 0, "!secondsClaimed")`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.claimReward` requires `stake.initialized` but it is never set. It also performs a strange computation as `128 - incentive.secondsClaimed` which will almost always underflow and revert the transaction.  ## Impact One cannot claim rewards.  ## Recommended Mitigation Steps Rethink how claiming rewards should work.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager` keeps all tokens for all incentives in the same contract. The `reclaimIncentive` function does not reduce the `incentive.rewardsUnclaimed` field and thus one can reclaim tokens several times. This allows anyone to steal all tokens from all incentives by creating an incentive themself, and once it's expired, repeatedly claim the unclaimed rewards until the token balance is empty.  ## POC - Attacker creates an incentive for a non-existent pool using a random address for `pool` (This is done such that no other user can claim rewards as we need a non-zero `rewardsUnclaimed` balance for expiry). They choose the `incentive.token` to be the token they want to steal from other incentives. (for example, `WETH`, `USDC`, or `SUSHI`) They choose the `startTime, endTime, expiry` such that the checks pass, i.e., starting and ending in a few seconds from now, expiring in 5 weeks. Then they choose a non-zero `rewardsUnclaimed` and transfer the `incentive.token` to the PoolManager. - Attacker waits for 5 weeks until the incentive is expired - Attacker can now call `reclaimIncentive(pool, incentiveId, amount=incentive.rewardsUnclaimed, attacker, false)` to withdraw `incentive.rewardsUnclaimed` of `incentive.token` from the pool manager. - As the `incentive.rewardsUnclaimed` variable has not been decreased, they can keep calling `reclaimIncentive` until the pool is drained.  ## Impact An attacker can steal all tokens in the PoolManager.  ## Recommended Mitigation Steps In `reclaimIncentive`, reduce `incentive.rewardsUnclaimed` by the withdrawn `amount`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.mint/burn` functions add/remove `liquidity` when `(priceLower < currentPrice && currentPrice < priceUpper)`. Shouldn't it also be changed if `priceLower == currentPrice`?  ## Impact Pools that mint/burn liquidity at a time where the `currentPrice` is right at the lower price range do not work correctly and will lead to wrong swap amounts.  ## Recommended Mitigation Steps Change the inequalities to `if (priceLower <= currentPrice && currentPrice < priceUpper)`.   
# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.constructor` does not check that `_token0 != _token1`. The pool factory does not ensure this either.  ## Impact Pools can be created using the same token. This should be prevented as it does not make sense.  ## Recommended Mitigation Steps Add a `_token0 != _token1` check to the constructor.   
# Handle  cmichel   # Vulnerability details  The `DyDxMath.getLiquidityForAmounts/getDx/getDy` functions perform unchecked computations on `priceUpper - priceLower` but they do not check that `priceUpper >= priceLower`.  ## Impact The values can underflow and return much lower liquidity or much higher token amounts than expected.  The calling functions (`mint` and `burn`) also do not check this. For `mint`, it fails further down the callstack at `Ticks.insert`, but `burn` does not fail.  ## Recommended Mitigation Steps Check that the `lower` and `upper` from the provided parameters for `mint` and `burn` are indeed sorted, i.e., `lower < upper`. It should be checked explicitly at the start of the function.   
# Handle  broccoli   # Vulnerability details  # range fee growth underflow ## Impact The function `RangeFeeGrowth` [ConcentratedLiquidityPool.sol#L601-L633](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L601-L633) would revert the transaction in some cases.  When a pool cross a tick, it only updates either `feeGrowthOutside0` or `feeGrowthOutside1`. [Ticks.sol#L23-L53](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/Ticks.sol#L23-L53)  `RangeFeeGrowth` calculates the fee as follow: ```solidity             feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;             feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1; ```  `feeGrowthBelow + feeGrowthAbove` is not necessary smaller than `_feeGrowthGlobal`. Please see `POC`.   Users can not provide liquidity or burn liquidity. Fund will get stocked in the contract. I consider this is a high-risk issue.  ## Proof of Concept ```python     # This is the wrapper.     # def add_liquidity(pool, amount, lower, upper)     # def swap(pool, buy, amount)      add_liquidity(pool, deposit_amount, -800, 500)     add_liquidity(pool, deposit_amount, 400, 700)     # We cross the tick here to trigger the bug.      swap(pool, False, deposit_amount)     # Only tick 700's feeGrowthOutside1 is updated      swap(pool, True, deposit_amount)     # Only tick 500's feeGrowthOutside0 is updated          # current tick at -800      # this would revert     # feeGrowthBelow1 = feeGrowthGlobal1     # feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1 would revert     # user would not be able to mint/withdraw/cross this tick. The pool is broken     add_liquidity(pool, deposit_amount, 400, 700) ``` ## Tools Used Hardhat  ## Recommended Mitigation Steps  It's either modify the tick's algo or `RangeFeeGrowth`. The quick-fix I come up with is to deal with the fee in `RangeFeeGrowth`. However, I recommend the team to go through tick's logic again.  
# Handle  WatchPug   # Vulnerability details  The reserves should be updated once LP tokens are burned to match the actual total bento shares hold by the pool.  However, the current implementation only updated reserves with the fees subtracted.  Makes the `reserve0` and `reserve1` smaller than the current `balance0` and `balance1`.  ## Impact  As a result, many essential features of the contract will malfunction, includes `swap()` and `mint()`.  ## Recommended Mitigation Steps  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L263-L267  Change:  ```         unchecked {             reserve0 -= uint128(amount0fees);             reserve1 -= uint128(amount1fees);         }  ``` to:  ```         unchecked {             reserve0 -= uint128(amount0);             reserve1 -= uint128(amount1);         } ```  
# Handle  WatchPug   # Vulnerability details  In `ConcentratedLiquidityPosition.collect()`, balances of token0 and token1 in bento will be used to pay the fees.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L103-L116  ```     uint256 balance0 = bento.balanceOf(token0, address(this));     uint256 balance1 = bento.balanceOf(token1, address(this));     if (balance0 < token0amount || balance1 < token1amount) {         (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);          uint256 newBalance0 = amount0fees + balance0;         uint256 newBalance1 = amount1fees + balance1;          /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw         if (token0amount > newBalance0) token0amount = newBalance0;         if (token1amount > newBalance1) token1amount = newBalance1;     }     _transfer(token0, address(this), recipient, token0amount, unwrapBento);     _transfer(token1, address(this), recipient, token1amount, unwrapBento);  ```  In the case of someone add an incentive with `token0` or `token1`, the incentive in the balance of bento will be used to pay fees until the balance is completely consumed.  As a result, when a user calls `claimReward()`, the contract may not have enough balance to pay (it supposed to have it), cause the transaction to fail.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L78-L100 ``` function claimReward(         uint256 positionId,         uint256 incentiveId,         address recipient,         bool unwrapBento     ) public {         require(ownerOf[positionId] == msg.sender, "OWNER");         Position memory position = positions[positionId];         IConcentratedLiquidityPool pool = position.pool;         Incentive storage incentive = incentives[position.pool][positionId];         Stake storage stake = stakes[positionId][incentiveId];         require(stake.initialized, "UNINITIALIZED");         uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;         uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;         uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;         uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);         uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;         incentive.rewardsUnclaimed -= rewards;         incentive.secondsClaimed += uint160(secondsInside);         stake.secondsInsideLast += uint160(secondsPerLiquidityInside);         _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);         emit ClaimReward(positionId, incentiveId, recipient);     } ```  The same issue applies to `reclaimIncentive()` as well.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L49-L62 ``` function reclaimIncentive(     IConcentratedLiquidityPool pool,     uint256 incentiveId,     uint256 amount,     address receiver,     bool unwrapBento ) public {     Incentive storage incentive = incentives[pool][incentiveId];     require(incentive.owner == msg.sender, "NOT_OWNER");     require(incentive.expiry < block.timestamp, "EXPIRED");     require(incentive.rewardsUnclaimed >= amount, "ALREADY_CLAIMED");     _transfer(incentive.token, address(this), receiver, amount, unwrapBento);     emit ReclaimIncentive(pool, incentiveId); } ```  ## Recommendation  Consider making adding `token0` or `token1` as incentives disallowed, or keep a record of total remaining incentive amounts for the incentive tokens and avoid consuming these revered balances when `collect()`.  
# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  `derrived` → `derived`  `owerflow` → `overflow`  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Swap fees are taken from the output. Hence, if swapping token0 for token1 (`zeroForOne` is true), then fees are taken in token1. We see this to be the case in the initialization of feeGrowthGlobal in the swap cache   `feeGrowthGlobal = zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0;`  and in `_updateFees()`.  However, looking at `Ticks.cross()`, the logic is the reverse, which causes wrong fee accounting.  ```jsx if (zeroForOne) {  ...  ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0; } else {  ...  ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1; } ```  ### Recommended Mitigation Steps  Switch the `0` and `1` in `Ticks.cross()`.  ```jsx if (zeroForOne) {  ...  // feeGrowthGlobal = feeGrowthGlobal1  ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1; } else {  ...  // feeGrowthGlobal = feeGrowthGlobal0  ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0; } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The fee growth mechanism, and by extension, secondsPerLiquidity mechanism of Uniswap V3 has the ability to underflow. It is therefore a necessity for the math to (ironically) be unsafe / unchecked.   ### Proof of Concept  Assume the following scenario and initial conditions:  - Price at parity (nearestTick is 0) - tickSpacing of 10 - Swaps only increase the price (nearestTick moves up only) - feeGrowthGlobal initializes with 0, increases by 1 for every tick moved for simplicity - Existing positions that provide enough liquidity and enable nearestTick to be set to values in the example - Every tick initialized in the example is ≤ nearestTick, so that its feeGrowthOutside = feeGrowthGlobal  1. When nearestTick is at 40, Alice creates a position for uninitialised ticks [-20, 30]. The ticks are initialized, resulting in their feeGrowthOutside values to be set to 40. 2. nearestTick moves to 50. Bob creates a position with ticks [20, 30] (tick 20 is uninitialised, 30 was initialized from Alice's mint). tick 20 will therefore have a feeGrowthOutside of 50. 3. Let us calculate `rangeFeeGrowth(20,30)`.     - lowerTick = 20, upperTick = 30     - feeGrowthBelow = 50 (lowerTick's feeGrowthOutside) since lowerTick < currentTick     - feeGrowthAbove = 50 - 40 = 10 (feeGrowthGlobal - upperTick's feeGrowthOutside) since upperTick < currentTick     - feeGrowthInside                  = feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove                  = 50 - 50 - 10                  = -10           We therefore have negative feeGrowthInside.  This behaviour is actually acceptable, because the important thing about this mechanism is the relative values to each other, not the absolute values themselves.  ### Recommended Mitigation Steps  `rangeFeeGrowth()` and `rangeSecondsInside()` has to be unchecked. In addition, the subtraction of feeGrowthInside values should also be unchecked in `_updatePosition()` and `ConcentratedLiquidityPosition#collect()`.  The same also applies for the subtraction of `pool.rangeSecondsInside` and `stake.secondsInsideLast` in `claimReward()` and `getReward()` of the `ConcentratedLiquidityPoolManager` contract.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  No check is performed for the initial price. This means that it can be set to be below the `MIN_SQRT_RATIO` or above `MAX_SQRT_RATIO` (Eg. zero value), which will prevent the usability of all other functions (minting, swapping, burning).  For example, `Ticks.insert()` would fail when attempting to calculate `actualNearestTick = TickMath.getTickAtSqrtRatio(currentPrice);`, which means no one will be able to mint positions.  ### Recommended Mitigation Steps  Check the `initialPrice` is within the acceptable range, ie. `MIN_SQRT_RATIO <= initialPrice <= MAX_SQRT_RATIO`  
