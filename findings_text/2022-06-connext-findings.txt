**Overview**  Risk Rating | Number of issues --- | --- Gas Issues | 16  **Table of Contents:**  - [1. Avoid unnecessary calculation when `_args.amount == 0`](#1-avoid-unnecessary-calculation-when-_argsamount--0) - [2. Cheap Contract Deployment Through Clones](#2-cheap-contract-deployment-through-clones) - [3. Avoid emitting a storage variable when a memory value is available](#3-avoid-emitting-a-storage-variable-when-a-memory-value-is-available) - [4. Reduce the size of error messages (Long revert Strings)](#4-reduce-the-size-of-error-messages-long-revert-strings) - [5. SafeMath is not needed when using Solidity version 0.8+](#5-safemath-is-not-needed-when-using-solidity-version-08) - [6. `>=` is cheaper than `>` (and `<=` cheaper than `<`)](#6--is-cheaper-than--and--cheaper-than-) - [7. Splitting `require()` statements that use `&&` saves gas](#7-splitting-require-statements-that-use--saves-gas) - [8. Using private rather than public for constants saves gas](#8-using-private-rather-than-public-for-constants-saves-gas) - [9. `<array>.length` should not be looked up in every loop of a `for-loop`](#9-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop) - [10. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)](#10-i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1) - [11. Increments/decrements can be unchecked in for-loops](#11-incrementsdecrements-can-be-unchecked-in-for-loops) - [12. It costs more gas to initialize variables with their default value than letting the default value be applied](#12-it-costs-more-gas-to-initialize-variables-with-their-default-value-than-letting-the-default-value-be-applied) - [13. A variable should be immutable](#13-a-variable-should-be-immutable) - [14. Use Custom Errors instead of Revert Strings to save Gas](#14-use-custom-errors-instead-of-revert-strings-to-save-gas) - [15. Functions guaranteed to revert when called by normal users can be marked `payable`](#15-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable) - [16. Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)](#16-use-scientific-notation-eg-1e18-rather-than-exponentiation-eg-1018)  ## 1. Avoid unnecessary calculation when `_args.amount == 0`  [Here](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L762), if `_args.amount == 0` (which is possible), there should be a return statement to avoid unnecessary gas consumption:  ```solidity File: BridgeFacet.sol 762:     uint256 toSwap = _args.amount; // @audit-info [INFO] amount can be 0 meaning that this should return to avoid unnecessary gas consumption. Recommendation: add a if (_args.amount == 0) return; ```  ## 2. Cheap Contract Deployment Through Clones  ```solidity core/connext/facets/upgrade-initializers/DiamondInit.sol:73:      s.executor = new Executor(address(this)); ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  Consider applying a similar pattern.  ## 3. Avoid emitting a storage variable when a memory value is available  When they are the same, consider emitting the memory value instead of the storage value:  ```solidity contracts/contracts/core/connext/helpers/ProposedOwnableUpgradeable.sol:   320    function _setProposed(address newlyProposed) private {   321      _proposedOwnershipTimestamp = block.timestamp;   322      _proposed = newlyProposed;   323:     emit OwnershipProposed(_proposed); //@audit should emit newlyProposed  contracts/contracts/core/shared/ProposedOwnable.sol:   169    function _setProposed(address newlyProposed) private {   170      _proposedOwnershipTimestamp = block.timestamp;   171      _proposed = newlyProposed;   172:     emit OwnershipProposed(_proposed);//@audit should emit newlyProposed   173    } ```  ## 4. Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity core/connext/helpers/OZERC20.sol:185:    require(_sender != address(0), "ERC20: transfer from the zero address"); core/connext/helpers/OZERC20.sol:186:    require(_recipient != address(0), "ERC20: transfer to the zero address"); core/connext/helpers/OZERC20.sol:190:    balances[_sender] = balances[_sender].sub(amount, "ERC20: transfer amount exceeds balance"); core/connext/helpers/OZERC20.sol:226:    require(_account != address(0), "ERC20: burn from the zero address"); core/connext/helpers/OZERC20.sol:230:    balances[_account] = balances[_account].sub(_amount, "ERC20: burn amount exceeds balance"); core/connext/helpers/OZERC20.sol:253:    require(_owner != address(0), "ERC20: approve from the zero address"); core/connext/helpers/OZERC20.sol:254:    require(_spender != address(0), "ERC20: approve to the zero address"); core/connext/libraries/LibDiamond.sol:66:    require(msg.sender == diamondStorage().contractOwner, "LibDiamond: Must be contract owner"); core/connext/libraries/LibDiamond.sol:113:        revert("LibDiamondCut: Incorrect FacetCutAction"); core/connext/libraries/LibDiamond.sol:121:    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut"); core/connext/libraries/LibDiamond.sol:123:    require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)"); core/connext/libraries/LibDiamond.sol:132:      require(oldFacetAddress == address(0), "LibDiamondCut: Can't add function that already exists"); core/connext/libraries/LibDiamond.sol:139:    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut"); core/connext/libraries/LibDiamond.sol:141:    require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)"); core/connext/libraries/LibDiamond.sol:150:      require(oldFacetAddress != _facetAddress, "LibDiamondCut: Can't replace function with same function"); core/connext/libraries/LibDiamond.sol:158:    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut"); core/connext/libraries/LibDiamond.sol:161:    require(_facetAddress == address(0), "LibDiamondCut: Remove facet address must be address(0)"); core/connext/libraries/LibDiamond.sol:170:    enforceHasContractCode(_facetAddress, "LibDiamondCut: New facet has no code"); core/connext/libraries/LibDiamond.sol:191:    require(_facetAddress != address(0), "LibDiamondCut: Can't remove function that doesn't exist"); core/connext/libraries/LibDiamond.sol:193:    require(_facetAddress != address(this), "LibDiamondCut: Can't remove immutable function"); core/connext/libraries/LibDiamond.sol:224:      require(_calldata.length == 0, "LibDiamondCut: _init is address(0) but_calldata is not empty"); core/connext/libraries/LibDiamond.sol:226:      require(_calldata.length > 0, "LibDiamondCut: _calldata is empty but _init is not address(0)"); core/connext/libraries/LibDiamond.sol:228:        enforceHasContractCode(_init, "LibDiamondCut: _init address has no code"); core/connext/libraries/LibDiamond.sol:236:          revert("LibDiamondCut: _init function reverted"); core/connext/libraries/SwapUtils.sol:595:        balances[i] = balances[i].sub(amounts[i], "Cannot withdraw more than available"); core/connext/libraries/SwapUtils.sol:697:    require(dy <= self.balances[tokenIndexTo], "Cannot get more than pool balance"); core/connext/libraries/SwapUtils.sol:784:    require(dy <= self.balances[tokenIndexTo], "Cannot get more than pool balance"); core/connext/libraries/SwapUtils.sol:1015:        balances1[i] = v.balances[i].sub(amounts[i], "Cannot withdraw more than available"); ```  Consider shortening the revert strings to fit in 32 bytes.  ## 5. SafeMath is not needed when using Solidity version 0.8+  Solidity version 0.8+ already implements overflow and underflow checks by default. Using the SafeMath library from OpenZeppelin (which is more gas expensive than the 0.8+ overflow checks) is therefore redundant.  Consider using the built-in checks instead of SafeMath and remove SafeMath here:  ```solidity core/connext/helpers/ConnextPriceOracle.sol:2:pragma solidity 0.8.14; core/connext/helpers/ConnextPriceOracle.sol:4:import {SafeMath} from "@openzeppelin/contracts/utils/math/SafeMath.sol"; core/connext/helpers/ConnextPriceOracle.sol:45:  using SafeMath for uint256;  core/connext/helpers/OZERC20.sol:2:pragma solidity 0.8.14; core/connext/helpers/OZERC20.sol:10:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; core/connext/helpers/OZERC20.sol:37:  using SafeMath for uint256;  core/connext/libraries/AmplificationUtils.sol:2:pragma solidity 0.8.14; core/connext/libraries/AmplificationUtils.sol:5:import {SafeMath} from "@openzeppelin/contracts/utils/math/SafeMath.sol"; core/connext/libraries/AmplificationUtils.sol:15:  using SafeMath for uint256;  core/connext/libraries/SwapUtils.sol:2:pragma solidity 0.8.14; core/connext/libraries/SwapUtils.sol:4:import {SafeMath} from "@openzeppelin/contracts/utils/math/SafeMath.sol"; core/connext/libraries/SwapUtils.sol:20:  using SafeMath for uint256; ```  ## 6. `>=` is cheaper than `>` (and `<=` cheaper than `<`)  Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas). This also holds true between `<=` and `<`.    Consider replacing strict inequalities with non-strict ones to save some gas here:  ```solidity core/connext/helpers/SponsorVault.sol:214:      sponsoredFee = balance < _liquidityFee ? balance : _liquidityFee; core/connext/helpers/SponsorVault.sol:258:      sponsoredFee = sponsoredFee > address(this).balance ? address(this).balance : sponsoredFee; ```  ## 7. Splitting `require()` statements that use `&&` saves gas  If you're using the Optimizer at 200, instead of using the `&&` operator in a single require statement to check multiple conditions, Consider using multiple require statements with 1 condition per require statement:  ```solidity core/connext/helpers/StableSwap.sol:85:          tokenIndexes[address(_pooledTokens[i])] == 0 && _pooledTokens[0] != _pooledTokens[i], core/connext/libraries/AmplificationUtils.sol:86:    require(futureA_ > 0 && futureA_ < MAX_A, "futureA_ must be > 0 and < MAX_A"); core/connext/libraries/SwapUtils.sol:397:    require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, "Tokens must be in pool"); core/connext/libraries/SwapUtils.sol:493:    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, "Token index out of range"); core/connext/libraries/SwapUtils.sol:524:    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, "Token index out of range"); core/connext/libraries/SwapUtils.sol:1007:    require(maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, ">LP.balanceOf"); ```  Please, note that this might not hold true at a higher number of runs for the Optimizer (10k). However, it indeed is true at 200.  ## 8. Using private rather than public for constants saves gas  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  ```solidity core/connext/facets/BridgeFacet.sol:68:  uint16 public constant AAVE_REFERRAL_CODE = 0; core/connext/helpers/PriceOracle.sol:6:  bool public constant isPriceOracle = true; core/connext/libraries/AmplificationUtils.sol:21:  uint256 public constant A_PRECISION = 100; core/connext/libraries/AmplificationUtils.sol:22:  uint256 public constant MAX_A = 10**6; core/connext/libraries/LibCrossDomainProperty.sol:37:  bytes29 public constant EMPTY = hex"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"; core/connext/libraries/LibCrossDomainProperty.sol:38:  bytes public constant EMPTY_BYTES = hex"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"; core/shared/Version.sol:9:  uint8 public constant VERSION = 0;  ```  ## 9. `<array>.length` should not be looked up in every loop of a `for-loop`  Reading array length at each iteration of the loop consumes more gas than necessary.    In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Here, Consider storing the array's length in a variable before the for-loop, and use this new variable instead:  ```solidity core/connext/facets/RelayerFacet.sol:140:    for (uint256 i; i < _transferIds.length; ) { core/connext/facets/RelayerFacet.sol:164:    for (uint256 i; i < _transferIds.length; ) { core/connext/facets/StableSwapFacet.sol:415:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/helpers/ConnextPriceOracle.sol:176:    for (uint256 i = 0; i < tokenAddresses.length; i++) { core/connext/helpers/Multicall.sol:16:    for (uint256 i = 0; i < calls.length; i++) { core/connext/helpers/StableSwap.sol:81:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/libraries/LibDiamond.sol:104:    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) { core/connext/libraries/LibDiamond.sol:129:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:147:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:162:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/SwapUtils.sol:205:    for (uint256 i = 0; i < xp.length; i++) { core/connext/libraries/SwapUtils.sol:558:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:591:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:844:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:869:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:924:    for (uint256 i = 0; i < amounts.length; i++) { core/connext/libraries/SwapUtils.sol:1014:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1019:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1039:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1055:    for (uint256 i = 0; i < pooledTokens.length; i++) { ```  ## 10. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)  Pre-increments and pre-decrements are cheaper.  For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1` - `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)  **Decrement:**  - `i -= 1` is the most expensive form - `i--` costs 11 gas less than `i -= 1` - `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:  ```solidity uint i = 1;   uint j = 2; require(j == i++, "This will be false as i is incremented after the comparison"); ```    However, pre-increments (or pre-decrements) return the new value:    ```solidity uint i = 1;   uint j = 2; require(j == ++i, "This will be true as i is incremented before the comparison"); ```    In the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.      Affected code:    ```solidity core/connext/facets/BridgeFacet.sol:332:      s.nonce += 1; core/connext/facets/BridgeFacet.sol:613:          i++; core/connext/facets/BridgeFacet.sol:684:          i++; core/connext/facets/BridgeFacet.sol:799:            i++; core/connext/facets/DiamondLoupeFacet.sol:31:    for (uint256 i; i < numFacets; i++) { core/connext/facets/RelayerFacet.sol:144:        i++; core/connext/facets/RelayerFacet.sol:168:        i++; core/connext/facets/StableSwapFacet.sol:415:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/helpers/ConnextPriceOracle.sol:176:    for (uint256 i = 0; i < tokenAddresses.length; i++) { core/connext/helpers/Multicall.sol:16:    for (uint256 i = 0; i < calls.length; i++) { core/connext/helpers/StableSwap.sol:81:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/libraries/Encoding.sol:22:    for (uint8 i = 0; i < 10; i += 1) { core/connext/libraries/Encoding.sol:36:    for (uint8 i = 31; i > 15; i -= 1) { core/connext/libraries/Encoding.sol:45:      for (uint8 i = 15; i < 255; i -= 1) { core/connext/libraries/LibDiamond.sol:104:    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) { core/connext/libraries/LibDiamond.sol:129:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:134:      selectorPosition++; core/connext/libraries/LibDiamond.sol:147:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:153:      selectorPosition++; core/connext/libraries/LibDiamond.sol:162:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/SwapUtils.sol:205:    for (uint256 i = 0; i < xp.length; i++) { core/connext/libraries/SwapUtils.sol:254:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:268:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:289:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:300:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:302:      for (uint256 j = 0; j < numTokens; j++) { core/connext/libraries/SwapUtils.sol:344:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:405:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:425:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:558:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:591:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:844:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:869:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:924:    for (uint256 i = 0; i < amounts.length; i++) { core/connext/libraries/SwapUtils.sol:1014:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1019:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1039:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1055:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/relayer-fee/libraries/RelayerFeeMessage.sol:85:        i++; ```  Consider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).  ## 11. Increments/decrements can be unchecked in for-loops  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Affected code:    ```solidity core/connext/facets/DiamondLoupeFacet.sol:31:    for (uint256 i; i < numFacets; i++) { core/connext/facets/StableSwapFacet.sol:415:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/helpers/ConnextPriceOracle.sol:176:    for (uint256 i = 0; i < tokenAddresses.length; i++) { core/connext/helpers/Multicall.sol:16:    for (uint256 i = 0; i < calls.length; i++) { core/connext/helpers/StableSwap.sol:81:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/libraries/LibDiamond.sol:104:    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) { core/connext/libraries/LibDiamond.sol:129:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:147:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:162:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/SwapUtils.sol:205:    for (uint256 i = 0; i < xp.length; i++) { core/connext/libraries/SwapUtils.sol:254:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:268:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:289:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:300:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:302:      for (uint256 j = 0; j < numTokens; j++) { core/connext/libraries/SwapUtils.sol:344:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:405:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:425:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:558:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:591:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:844:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:869:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:924:    for (uint256 i = 0; i < amounts.length; i++) { core/connext/libraries/SwapUtils.sol:1014:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1019:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1039:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1055:    for (uint256 i = 0; i < pooledTokens.length; i++) { ```  The change would be:      ```diff - for (uint256 i; i < numIterations; i++) { + for (uint256 i; i < numIterations;) {  // ...   +   unchecked { ++i; } }   ```  The same can be applied with decrements (which should use `break` when `i == 0`).  The risk of overflow is non-existant for `uint256` here.  ## 12. It costs more gas to initialize variables with their default value than letting the default value be applied  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Affected code:  ```solidity core/connext/facets/StableSwapFacet.sol:415:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/helpers/ConnextPriceOracle.sol:176:    for (uint256 i = 0; i < tokenAddresses.length; i++) { core/connext/helpers/Multicall.sol:16:    for (uint256 i = 0; i < calls.length; i++) { core/connext/helpers/StableSwap.sol:81:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/libraries/Encoding.sol:22:    for (uint8 i = 0; i < 10; i += 1) { core/connext/libraries/SwapUtils.sol:205:    for (uint256 i = 0; i < xp.length; i++) { core/connext/libraries/SwapUtils.sol:254:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:268:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:289:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:300:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:302:      for (uint256 j = 0; j < numTokens; j++) { core/connext/libraries/SwapUtils.sol:344:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:405:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:425:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:558:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:591:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:844:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:869:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:924:    for (uint256 i = 0; i < amounts.length; i++) { core/connext/libraries/SwapUtils.sol:1014:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1019:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1039:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1055:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/relayer-fee/libraries/RelayerFeeMessage.sol:81:    for (uint256 i = 0; i < length; ) { ```  Consider removing explicit initializations for default values.  ## 13. A variable should be immutable  This variable is only set in the constructor and never edited after that:  ```solidity core/connext/helpers/ConnextPriceOracle.sol:49:  address public wrapped; ```  Consider marking it as immutable, as it would avoid the expensive storage-writing operation (around 20 000 gas)  ## 14. Use Custom Errors instead of Revert Strings to save Gas  Solidity 0.8.4 introduced custom errors. They are more gas efficient than revert strings, when it comes to deploy cost as well as runtime cost when the revert condition is met. Use custom errors instead of revert strings for gas savings.  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Consider replacing all revert strings with custom errors in the solution.  ```solidity core/connext/facets/BaseConnextFacet.sol:38:    require(s._status != _ENTERED, "ReentrancyGuard: reentrant call"); core/connext/facets/BaseConnextFacet.sol:125:    require(_remote != bytes32(0), "!remote"); core/connext/helpers/BridgeToken.sol:94:    require( core/connext/helpers/BridgeToken.sol:130:    require(block.timestamp <= _deadline, "ERC20Permit: expired deadline"); core/connext/helpers/BridgeToken.sol:131:    require(_owner != address(0), "ERC20Permit: owner zero address"); core/connext/helpers/BridgeToken.sol:136:    require(_signer == _owner, "ERC20Permit: invalid signature"); core/connext/helpers/ConnextPriceOracle.sol:72:    require(msg.sender == admin, "caller is not the admin"); core/connext/helpers/ConnextPriceOracle.sol:150:    require(baseTokenPrice > 0, "invalid base token"); core/connext/helpers/Executor.sol:57:    require(msg.sender == connext, "#OC:027"); core/connext/helpers/LPToken.sol:35:    require(amount != 0, "LPToken: cannot mint 0"); core/connext/helpers/LPToken.sol:50:    require(to != address(this), "LPToken: cannot send to itself"); core/connext/helpers/Multicall.sol:18:      require(success); core/connext/helpers/OZERC20.sol:185:    require(_sender != address(0), "ERC20: transfer from the zero address"); core/connext/helpers/OZERC20.sol:186:    require(_recipient != address(0), "ERC20: transfer to the zero address"); core/connext/helpers/OZERC20.sol:205:    require(_account != address(0), "ERC20: mint to the zero address"); core/connext/helpers/OZERC20.sol:226:    require(_account != address(0), "ERC20: burn from the zero address"); core/connext/helpers/OZERC20.sol:253:    require(_owner != address(0), "ERC20: approve from the zero address"); core/connext/helpers/OZERC20.sol:254:    require(_spender != address(0), "ERC20: approve to the zero address"); core/connext/helpers/StableSwap.sol:75:    require(_pooledTokens.length > 1, "_pooledTokens.length <= 1"); core/connext/helpers/StableSwap.sol:76:    require(_pooledTokens.length <= 32, "_pooledTokens.length > 32"); core/connext/helpers/StableSwap.sol:77:    require(_pooledTokens.length == decimals.length, "_pooledTokens decimals mismatch"); core/connext/helpers/StableSwap.sol:84:        require( core/connext/helpers/StableSwap.sol:89:      require(address(_pooledTokens[i]) != address(0), "The 0 address isn't an ERC-20"); core/connext/helpers/StableSwap.sol:90:      require(decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS, "Token decimals exceeds max"); core/connext/helpers/StableSwap.sol:96:    require(_a < AmplificationUtils.MAX_A, "_a exceeds maximum"); core/connext/helpers/StableSwap.sol:97:    require(_fee < SwapUtils.MAX_SWAP_FEE, "_fee exceeds maximum"); core/connext/helpers/StableSwap.sol:98:    require(_adminFee < SwapUtils.MAX_ADMIN_FEE, "_adminFee exceeds maximum"); core/connext/helpers/StableSwap.sol:102:    require(lpToken.initialize(lpTokenName, lpTokenSymbol), "could not init lpToken clone"); core/connext/helpers/StableSwap.sol:125:    require(block.timestamp <= deadline, "Deadline not met"); core/connext/helpers/StableSwap.sol:155:    require(index < swapStorage.pooledTokens.length, "Out of range"); core/connext/helpers/StableSwap.sol:167:    require(address(getToken(index)) == tokenAddress, "Token does not exist"); core/connext/helpers/StableSwap.sol:177:    require(index < swapStorage.pooledTokens.length, "Index out of range"); core/connext/helpers/TokenRegistry.sol:163:    require(_tokenId.domain != 0, "!repr"); core/connext/helpers/TokenRegistry.sol:228:    require(_token != address(0), "!token"); core/connext/libraries/AmplificationUtils.sol:84:    require(block.timestamp >= self.initialATime.add(1 days), "Wait 1 day before starting ramp"); core/connext/libraries/AmplificationUtils.sol:85:    require(futureTime_ >= block.timestamp.add(MIN_RAMP_TIME), "Insufficient ramp time"); core/connext/libraries/AmplificationUtils.sol:86:    require(futureA_ > 0 && futureA_ < MAX_A, "futureA_ must be > 0 and < MAX_A"); core/connext/libraries/AmplificationUtils.sol:92:      require(futureAPrecise.mul(MAX_A_CHANGE) >= initialAPrecise, "futureA_ is too small"); core/connext/libraries/AmplificationUtils.sol:94:      require(futureAPrecise <= initialAPrecise.mul(MAX_A_CHANGE), "futureA_ is too large"); core/connext/libraries/AmplificationUtils.sol:111:    require(self.futureATime > block.timestamp, "Ramp is already stopped"); core/connext/libraries/ConnextMessage.sol:116:    require(isValidAction(_action), "!action"); core/connext/libraries/LibDiamond.sol:66:    require(msg.sender == diamondStorage().contractOwner, "LibDiamond: Must be contract owner"); core/connext/libraries/LibDiamond.sol:100:    require( core/connext/libraries/LibDiamond.sol:121:    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut"); core/connext/libraries/LibDiamond.sol:123:    require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)"); core/connext/libraries/LibDiamond.sol:132:      require(oldFacetAddress == address(0), "LibDiamondCut: Can't add function that already exists"); core/connext/libraries/LibDiamond.sol:139:    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut"); core/connext/libraries/LibDiamond.sol:141:    require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)"); core/connext/libraries/LibDiamond.sol:150:      require(oldFacetAddress != _facetAddress, "LibDiamondCut: Can't replace function with same function"); core/connext/libraries/LibDiamond.sol:158:    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut"); core/connext/libraries/LibDiamond.sol:161:    require(_facetAddress == address(0), "LibDiamondCut: Remove facet address must be address(0)"); core/connext/libraries/LibDiamond.sol:191:    require(_facetAddress != address(0), "LibDiamondCut: Can't remove function that doesn't exist"); core/connext/libraries/LibDiamond.sol:193:    require(_facetAddress != address(this), "LibDiamondCut: Can't remove immutable function"); core/connext/libraries/LibDiamond.sol:224:      require(_calldata.length == 0, "LibDiamondCut: _init is address(0) but_calldata is not empty"); core/connext/libraries/LibDiamond.sol:226:      require(_calldata.length > 0, "LibDiamondCut: _calldata is empty but _init is not address(0)"); core/connext/libraries/LibDiamond.sol:247:    require(contractSize > 0, _errorMessage); core/connext/libraries/SwapUtils.sol:191:    require(tokenIndex < xp.length, "Token index out of range"); core/connext/libraries/SwapUtils.sol:198:    require(tokenAmount <= xp[tokenIndex], "Withdraw exceeds available"); core/connext/libraries/SwapUtils.sol:248:    require(tokenIndex < numTokens, "Token not found"); core/connext/libraries/SwapUtils.sol:342:    require(numTokens == precisionMultipliers.length, "Balances must match multipliers"); core/connext/libraries/SwapUtils.sol:396:    require(tokenIndexFrom != tokenIndexTo, "Can't compare token to itself"); core/connext/libraries/SwapUtils.sol:397:    require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, "Tokens must be in pool"); core/connext/libraries/SwapUtils.sol:493:    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, "Token index out of range"); core/connext/libraries/SwapUtils.sol:524:    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, "Token index out of range"); core/connext/libraries/SwapUtils.sol:554:    require(amount <= totalSupply, "Cannot exceed total supply"); core/connext/libraries/SwapUtils.sol:615:    require(index < self.pooledTokens.length, "Token index out of range"); core/connext/libraries/SwapUtils.sol:649:      require(dx <= tokenFrom.balanceOf(msg.sender), "Cannot swap more than you own"); core/connext/libraries/SwapUtils.sol:662:    require(dy >= minDy, "Swap didn't result in min tokens"); core/connext/libraries/SwapUtils.sol:697:    require(dy <= self.balances[tokenIndexTo], "Cannot get more than pool balance"); core/connext/libraries/SwapUtils.sol:703:    require(dx <= maxDx, "Swap needs more than max tokens"); core/connext/libraries/SwapUtils.sol:717:      require(dx <= tokenFrom.balanceOf(msg.sender), "Cannot swap more than you own"); core/connext/libraries/SwapUtils.sol:723:      require(dx == tokenFrom.balanceOf(address(this)).sub(beforeBalance), "not support fee token"); core/connext/libraries/SwapUtils.sol:750:    require(dx <= tokenFrom.balanceOf(msg.sender), "Cannot swap more than you own"); core/connext/libraries/SwapUtils.sol:756:    require(dy >= minDy, "Swap didn't result in min tokens"); core/connext/libraries/SwapUtils.sol:784:    require(dy <= self.balances[tokenIndexTo], "Cannot get more than pool balance"); core/connext/libraries/SwapUtils.sol:790:    require(dx <= maxDx, "Swap didn't result in min tokens"); core/connext/libraries/SwapUtils.sol:823:    require(amounts.length == pooledTokens.length, "Amounts must match pooled tokens"); core/connext/libraries/SwapUtils.sol:845:      require(v.totalSupply != 0 || amounts[i] > 0, "Must supply all tokens in pool"); core/connext/libraries/SwapUtils.sol:861:    require(v.d1 > v.d0, "D should increase"); core/connext/libraries/SwapUtils.sol:890:    require(toMint >= minToMint, "Couldn't mint min requested"); core/connext/libraries/SwapUtils.sol:916:    require(amount <= lpToken.balanceOf(msg.sender), ">LP.balanceOf"); core/connext/libraries/SwapUtils.sol:917:    require(minAmounts.length == pooledTokens.length, "minAmounts must match poolTokens"); core/connext/libraries/SwapUtils.sol:925:      require(amounts[i] >= minAmounts[i], "amounts[i] < minAmounts[i]"); core/connext/libraries/SwapUtils.sol:954:    require(tokenAmount <= lpToken.balanceOf(msg.sender), ">LP.balanceOf"); core/connext/libraries/SwapUtils.sol:955:    require(tokenIndex < pooledTokens.length, "Token not found"); core/connext/libraries/SwapUtils.sol:961:    require(dy >= minAmount, "dy < minAmount"); core/connext/libraries/SwapUtils.sol:1005:    require(amounts.length == pooledTokens.length, "Amounts should match pool tokens"); core/connext/libraries/SwapUtils.sol:1007:    require(maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, ">LP.balanceOf"); core/connext/libraries/SwapUtils.sol:1032:    require(tokenAmount != 0, "Burnt amount cannot be zero"); core/connext/libraries/SwapUtils.sol:1035:    require(tokenAmount <= maxBurnAmount, "tokenAmount > maxBurnAmount"); core/connext/libraries/SwapUtils.sol:1071:    require(newAdminFee <= MAX_ADMIN_FEE, "Fee is too high"); core/connext/libraries/SwapUtils.sol:1084:    require(newSwapFee <= MAX_SWAP_FEE, "Fee is too high"); core/shared/Router.sol:23:    require(_isRemoteRouter(_origin, _router), "!remote router"); core/shared/Router.sol:64:    require(_remote != bytes32(0), "!remote"); core/shared/XAppConnectionClient.sol:22:    require(_isReplica(msg.sender), "!replica"); ```  ## 15. Functions guaranteed to revert when called by normal users can be marked `payable`  If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.  ```solidity core/connext/facets/AssetFacet.sol:100:  function setWrapper(address _wrapper) external onlyOwner { core/connext/facets/AssetFacet.sol:112:  function setTokenRegistry(address _tokenRegistry) external onlyOwner { core/connext/facets/AssetFacet.sol:162:  function addStableSwapPool(ConnextMessage.TokenId calldata _canonical, address _stableSwapPool) external onlyOwner { core/connext/facets/AssetFacet.sol:171:  function removeAssetId(bytes32 _canonicalId, address _adoptedAssetId) external onlyOwner { core/connext/facets/BridgeFacet.sol:233:  function setPromiseRouter(address payable _promiseRouter) external onlyOwner { core/connext/facets/BridgeFacet.sol:242:  function setExecutor(address _executor) external onlyOwner { core/connext/facets/BridgeFacet.sol:250:  function setSponsorVault(address _sponsorVault) external onlyOwner { core/connext/facets/NomadFacet.sol:25:  function setXAppConnectionManager(address _xAppConnectionManager) external onlyOwner { core/connext/facets/NomadFacet.sol:34:  function enrollRemoteRouter(uint32 _domain, bytes32 _router) external onlyOwner { core/connext/facets/PortalFacet.sol:57:  function setAavePool(address _aavePool) external onlyOwner { core/connext/facets/PortalFacet.sol:65:  function setAavePortalFee(uint256 _aavePortalFeeNumerator) external onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:128:  function proposeRouterOwnershipRenunciation() public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:142:  function renounceRouterOwnership() public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:162:  function proposeAssetOwnershipRenunciation() public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:175:  function renounceAssetOwnership() public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:203:  function proposeNewOwner(address newlyProposed) public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:217:  function renounceOwnership() public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:236:  function acceptProposedOwner() public onlyProposed { core/connext/facets/ProposedOwnableFacet.sol:253:  function pause() public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:258:  function unpause() public onlyOwner { core/connext/facets/RelayerFacet.sol:88:  function setRelayerFeeRouter(address _relayerFeeRouter) external onlyOwner { core/connext/facets/RelayerFacet.sol:101:  function addRelayer(address _relayer) external onlyOwner { core/connext/facets/RelayerFacet.sol:112:  function removeRelayer(address _relayer) external onlyOwner { core/connext/facets/RelayerFacet.sol:161:  function claim(address _recipient, bytes32[] calldata _transferIds) external onlyRelayerFeeRouter { core/connext/facets/RoutersFacet.sol:293:  function removeRouter(address router) external onlyOwner { core/connext/facets/RoutersFacet.sol:331:  function setMaxRoutersPerTransfer(uint256 _newMaxRouters) external onlyOwner { core/connext/facets/RoutersFacet.sol:345:  function setLiquidityFeeNumerator(uint256 _numerator) external onlyOwner { core/connext/facets/RoutersFacet.sol:361:  function approveRouterForPortal(address _router) external onlyOwner { core/connext/facets/RoutersFacet.sol:375:  function unapproveRouterForPortal(address _router) external onlyOwner { core/connext/facets/RoutersFacet.sol:393:  function setRouterRecipient(address router, address recipient) external onlyRouterOwner(router) { core/connext/facets/RoutersFacet.sol:410:  function proposeRouterOwner(address router, address proposed) external onlyRouterOwner(router) { core/connext/facets/RoutersFacet.sol:430:  function acceptProposedRouterOwner(address router) external onlyProposedRouterOwner(router) { core/connext/facets/StableSwapFacet.sol:460:  function withdrawSwapAdminFees(bytes32 canonicalId) external onlyOwner { core/connext/facets/StableSwapFacet.sol:469:  function setSwapAdminFee(bytes32 canonicalId, uint256 newAdminFee) external onlyOwner { core/connext/facets/StableSwapFacet.sol:478:  function setSwapFee(bytes32 canonicalId, uint256 newSwapFee) external onlyOwner { core/connext/facets/StableSwapFacet.sol:502:  function stopRampA(bytes32 canonicalId) external onlyOwner { core/connext/helpers/BridgeToken.sol:54:  function burn(address _from, uint256 _amnt) external override onlyOwner { core/connext/helpers/BridgeToken.sol:66:  function mint(address _to, uint256 _amnt) external override onlyOwner { core/connext/helpers/BridgeToken.sol:73:  function setDetailsHash(bytes32 _detailsHash) external override onlyOwner { core/connext/helpers/BridgeToken.sol:202:  function transferOwnership(address _newOwner) public override(IBridgeToken, OwnableUpgradeable) onlyOwner { core/connext/helpers/ConnextPriceOracle.sol:158:  function setDirectPrice(address _token, uint256 _price) external onlyAdmin { core/connext/helpers/ConnextPriceOracle.sol:163:  function setV1PriceOracle(address _v1PriceOracle) external onlyAdmin { core/connext/helpers/ConnextPriceOracle.sol:168:  function setAdmin(address newAdmin) external onlyAdmin { core/connext/helpers/ConnextPriceOracle.sol:175:  function setAggregators(address[] calldata tokenAddresses, address[] calldata sources) external onlyAdmin { core/connext/helpers/LPToken.sol:34:  function mint(address recipient, uint256 amount) external onlyOwner { core/connext/helpers/OwnerPausableUpgradeable.sol:14:  function __OwnerPausable_init() internal onlyInitializing { core/connext/helpers/OwnerPausableUpgradeable.sol:23:  function pause() external onlyOwner { core/connext/helpers/OwnerPausableUpgradeable.sol:30:  function unpause() external onlyOwner { core/connext/helpers/OZERC20.sol:263:   * WARNING: This function should only be called from the constructor. Most core/connext/helpers/ProposedOwnableUpgradeable.sol:77:  function __ProposedOwnable_init() internal onlyInitializing { core/connext/helpers/ProposedOwnableUpgradeable.sol:81:  function __ProposedOwnable_init_unchained() internal onlyInitializing { core/connext/helpers/ProposedOwnableUpgradeable.sol:155:  function proposeRouterOwnershipRenunciation() public virtual onlyOwner { core/connext/helpers/ProposedOwnableUpgradeable.sol:169:  function renounceRouterOwnership() public virtual onlyOwner { core/connext/helpers/ProposedOwnableUpgradeable.sol:197:  function proposeAssetOwnershipRenunciation() public virtual onlyOwner { core/connext/helpers/ProposedOwnableUpgradeable.sol:211:  function renounceAssetOwnership() public virtual onlyOwner { core/connext/helpers/ProposedOwnableUpgradeable.sol:239:  function proposeNewOwner(address newlyProposed) public virtual onlyOwner { core/connext/helpers/ProposedOwnableUpgradeable.sol:253:  function renounceOwnership() public virtual onlyOwner { core/connext/helpers/ProposedOwnableUpgradeable.sol:272:  function acceptProposedOwner() public virtual onlyProposed { core/connext/helpers/SponsorVault.sol:138:  function setConnext(address _connext) external onlyOwner { core/connext/helpers/SponsorVault.sol:147:  function setRate(uint32 _originDomain, Rate calldata _rate) external onlyOwner { core/connext/helpers/SponsorVault.sol:159:  function setRelayerFeeCap(uint256 _relayerFeeCap) external onlyOwner { core/connext/helpers/SponsorVault.sol:168:  function setGasTokenOracle(address _gasTokenOracle) external onlyOwner { core/connext/helpers/SponsorVault.sol:178:  function setTokenExchange(address _token, address payable _tokenExchange) external onlyOwner { core/connext/helpers/StableSwap.sol:440:  function withdrawAdminFees() external onlyOwner { core/connext/helpers/StableSwap.sol:448:  function setAdminFee(uint256 newAdminFee) external onlyOwner { core/connext/helpers/StableSwap.sol:456:  function setSwapFee(uint256 newSwapFee) external onlyOwner { core/connext/helpers/StableSwap.sol:467:  function rampA(uint256 futureA, uint256 futureTime) external onlyOwner { core/connext/helpers/StableSwap.sol:474:  function stopRampA() external onlyOwner { core/promise/PromiseRouter.sol:155:  function setConnext(address _connext) external onlyOwner { core/relayer-fee/RelayerFeeRouter.sol:89:  function setConnext(address _connext) external onlyOwner { core/shared/ProposedOwnable.sol:109:  function proposeNewOwner(address newlyProposed) public virtual onlyOwner { core/shared/ProposedOwnable.sol:123:  function renounceOwnership() public virtual onlyOwner { core/shared/ProposedOwnable.sol:142:  function acceptProposedOwner() public virtual onlyProposed { core/shared/ProposedOwnable.sol:180:  function __ProposedOwnable_init() internal onlyInitializing { core/shared/ProposedOwnable.sol:184:  function __ProposedOwnable_init_unchained() internal onlyInitializing { core/shared/Router.sol:34:  function enrollRemoteRouter(uint32 _domain, bytes32 _router) external onlyOwner { core/shared/XAppConnectionClient.sol:39:  function setXAppConnectionManager(address _xAppConnectionManager) external onlyOwner { ```  ## 16. Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)  ```solidity core/connext/libraries/SwapUtils.sol:104:  uint256 internal constant FEE_DENOMINATOR = 10**10; core/connext/libraries/SwapUtils.sol:107:  uint256 internal constant MAX_SWAP_FEE = 10**8; core/connext/libraries/SwapUtils.sol:113:  uint256 internal constant MAX_ADMIN_FEE = 10**10; ``` 
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L346 https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L812   # Vulnerability details    Affected  functions(that rely on swapAsset()) are:  [https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L193](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L193)  [https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L159](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L159)  swapAsset() facilitates two swaps, either using the internal or external pool. But if an internal pool exists, a swap will be unsuccessful because the call to  s.swapStorages[_canonicalId].swapInternal() takes two incorrect arguments (due to an incorrect ordering, this seemed to be an oversight, acknowledged by #Layne) :  [https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/AssetLogic.sol#L278-L279](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/AssetLogic.sol#L278-L279)  Based on the above mentioned code , the arguments would be incorrectly changed to :  [https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/SwapUtils.sol#L744-L745](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/SwapUtils.sol#L744-L745)  The condition checked here:  [https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L750](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L750)  will never be true as the msg.sender would never own the quantity of tokens being swapped from since it's the wrong token.  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/DiamondCutFacet.sol#L16-L29 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L94-L118 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L222-L240   # Vulnerability details  ## Impact Diamond is to be upgraded after a certain delay to give time to the community to verify changes made by the developers. If the proposition can be falsified, the contract admins can exploit the contract in any way of their choice.  ## Proof of Concept To determine the id of the proposal, only its facet changes are hashed, skipping two critical pieces of data - the `_init` and `_calldata`. During a diamond upgrade, devs can choose what code will be executed **by the contract using a delegatecall**. Thus, they can make the contract perform **any** actions of their choice.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add `_init` and `_calldata` to the proposition hash.   
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L100-L103 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L71-L79 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L83-L90   # Vulnerability details  ## Impact  Normally, `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` will be set in `LibDiamond.proposeDiamondCut()`. Then in `LibDiamond.diamondCut()`, it checks that `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp`.  However, `LibDiamond.rescindDiamondCut()` will set `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` to 0. Which can easily pass the check in `diamondCut()`. But `rescindDiamondCut` should rescind `_diamondCut`. In conclusion, using `rescindDiamondCut()` can easily bypass the delay time.  Moreover, if `proposeDiamondCut()` has never been called, the check for delay time is always passed.  ## Proof of Concept  `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` will be set in `LibDiamond.proposeDiamondCut()` https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L71-L79 ```   function proposeDiamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     uint256 acceptance = block.timestamp + _delay;     diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = acceptance;     emit DiamondCutProposed(_diamondCut, _init, _calldata, acceptance);   } ```  Then in `LibDiamond.diamondCut()`, it checks that `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp` https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L100-L103 ```   function diamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     require(       diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp,       "LibDiamond: delay not elapsed"     );     …   } ```  However, `LibDiamond.rescindDiamondCut()` will set `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` to 0. Which can easily pass the check in `diamondCut()` https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L83-L90 ```   function rescindDiamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = 0;     emit DiamondCutRescinded(_diamondCut, _init, _calldata);   } ```  ``` diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = 0 < block.timestamp ```   ## Tools Used  None  ## Recommended Mitigation Steps  Add another check in `diamondCut`  ```   function diamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     require(       diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp && diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] != 0,       "LibDiamond: delay not elapsed"     );     …   } ```   
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99-L115   # Vulnerability details  For tokens with decimals larger than 18, many functions across the codebase will revert due to underflow.  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99-L115  ```solidity function getPriceFromDex(address _tokenAddress) public view returns (uint256) {     PriceInfo storage priceInfo = priceRecords[_tokenAddress];     if (priceInfo.active) {       uint256 rawTokenAmount = IERC20Extended(priceInfo.token).balanceOf(priceInfo.lpToken);       uint256 tokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.token).decimals());       uint256 tokenAmount = rawTokenAmount.mul(10**tokenDecimalDelta);       uint256 rawBaseTokenAmount = IERC20Extended(priceInfo.baseToken).balanceOf(priceInfo.lpToken);       uint256 baseTokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.baseToken).decimals());       uint256 baseTokenAmount = rawBaseTokenAmount.mul(10**baseTokenDecimalDelta);       uint256 baseTokenPrice = getTokenPrice(priceInfo.baseToken);       uint256 tokenPrice = baseTokenPrice.mul(baseTokenAmount).div(tokenAmount);        return tokenPrice;     } else {       return 0;     }   } ```  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/StableSwapFacet.sol#L426  ```solidity precisionMultipliers[i] = 10**uint256(SwapUtils.POOL_PRECISION_DECIMALS - decimals[i]); ```  Chainlink feeds' with decimals > 18 are not supported neither:  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L122-L140  ```solidity function getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {     AggregatorV3Interface aggregator = aggregators[_tokenAddress];     if (address(aggregator) != address(0)) {       (, int256 answer, , , ) = aggregator.latestRoundData();        // It's fine for price to be 0. We have two price feeds.       if (answer == 0) {         return 0;       }        // Extend the decimals to 1e18.       uint256 retVal = uint256(answer);       uint256 price = retVal.mul(10**(18 - uint256(aggregator.decimals())));        return price;     }      return 0;   } ```  ### Recommendation  Consider checking if decimals > 18 and normalize the value by div the decimals difference.  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L1053-L1062   # Vulnerability details  ```solidity function withdrawAdminFees(Swap storage self, address to) internal {   IERC20[] memory pooledTokens = self.pooledTokens;   for (uint256 i = 0; i < pooledTokens.length; i++) {     IERC20 token = pooledTokens[i];     uint256 balance = self.adminFees[i];     if (balance != 0) {       token.safeTransfer(to, balance);     }   } } ```  `self.adminFees[i]` should be reset to 0 every time it's withdrawn. Otherwise, the `adminFees` can be withdrawn multiple times.  The admin may just be unaware of this issue and casualty `withdrawAdminFees()` from time to time, and rug all the users slowly.  ### Recommendation  Change to:  ```solidity function withdrawAdminFees(Swap storage self, address to) internal {   IERC20[] memory pooledTokens = self.pooledTokens;   for (uint256 i = 0; i < pooledTokens.length; i++) {     IERC20 token = pooledTokens[i];     uint256 balance = self.adminFees[i];     if (balance != 0) {       self.adminFees[i] = 0;       token.safeTransfer(to, balance);     }   } } ```  
details is used only when !s.tokenRegistry.isLocalOrigin(token) holds:  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L957-L974  ```solidity     bytes32 details = action.detailsHash();      // if the token is of remote origin, mint the tokens. will either     // - be credited to router (fast liquidity)     // - be reserved for execution (slow liquidity)     if (!s.tokenRegistry.isLocalOrigin(token)) {       IBridgeToken(token).mint(address(this), amount);       // Tell the token what its detailsHash is       IBridgeToken(token).setDetailsHash(details);     }     // NOTE: if the token is of local origin, it means it was escrowed     // in this contract at xcall      // mark the transfer as reconciled     s.reconciledTransfers[transferId] = true;      return (amount, token, transferId);   } ```  ## Recommended Mitigation Steps  Move into the `if` scope:  ```     // if the token is of remote origin, mint the tokens. will either     // - be credited to router (fast liquidity)     // - be reserved for execution (slow liquidity)     if (!s.tokenRegistry.isLocalOrigin(token)) {       bytes32 details = action.detailsHash();       IBridgeToken(token).mint(address(this), amount);       // Tell the token what its detailsHash is       IBridgeToken(token).setDetailsHash(details);     } ```
# Chainlink oracle aggregator data is insufficiently validated in `ConnextPriceOracle.sol`  # Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L122-L140   # Vulnerability details  ### Impact  The function `getPriceFromChainlink()` in `ConnextPriceOracle.sol` fetches the `latestRoundData()` from a registered aggregator (Chainlink oracle feed) for a specified token. However, neither round completeness or the quoted timestamp are checked to ensure that the reported price is not stale.  Since Connext is creating bridged representations of tokens from other chains, it is vital for the reported prices of tokens to be accurate. While Connext also consults the DEX reported price of the tokens, some pairs with thin liquidity could also return inaccurate prices.  ### Proof of Concept ```solidity function getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {     AggregatorV3Interface aggregator = aggregators[_tokenAddress];     if (address(aggregator) != address(0)) {       (, int256 answer, , , ) = aggregator.latestRoundData();        // It's fine for price to be 0. We have two price feeds.       if (answer == 0) {         return 0;       }        // Extend the decimals to 1e18.       uint256 retVal = uint256(answer);       uint256 price = retVal.mul(10**(18 - uint256(aggregator.decimals())));        return price;     }      return 0;   } ``` Note that the other returned variables `roundId`, `startedAt`, `updatedAt`, and `answeredInRound` are omitted from the return result of `aggregator.latestRoundData()`.  ### Mitigation steps Add additional validation: ```solidity     ...      (uint80 roundID, int256 price, , uint256 updatedAt, uint80 answeredInRound) = aggregator.latestRoundData();     require(answeredInRound >= roundID, "ChainLink: Stale price");     require(updatedAt != 0, "ChainLink: Round not complete");     ... ```  ### Tools Used Manual review  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L882-L900   # Vulnerability details  _executePortalTransfer can introduce underlying token deficit by accounting for full underlying amount received from Aave unconditionally on what was actually withdrawn from Aave pool. Actual amount withdrawn is returned by `IAavePool(s.aavePool).withdraw()`, but currently is not used.  Setting the severity to medium as this can end up with a situation of partial insolvency, when where are a surplus of atokens, but deficit of underlying tokens in the bridge, so bridge functionality can become unavailable as there will be not enough underlying tokens, which were used up in the previous operations when atokens wasn't converted to underlying fully and underlying tokens from other operations were used up instead without accounting. I.e. the system in this situation supposes that all atokens are in the form of underlying tokens while there will be some atokens left unconverted due to withdrawal being only partial.  ## Proof of Concept  Call sequence here is execute() -> _handleExecuteLiquidity() -> _executePortalTransfer().   BridgeFacet._executePortalTransfer() mints the atokens needed, then withdraws them from Aave pool, always accounting for the full withdrawal:  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L882-L900  ```solidity   /**    * @notice Uses Aave Portals to provide fast liquidity    */   function _executePortalTransfer(     bytes32 _transferId,     uint256 _fastTransferAmount,     address _local,     address _router   ) internal returns (uint256, address) {     // Calculate local to adopted swap output if needed     (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);      IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);      // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer     IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));      // Store principle debt     s.portalDebt[_transferId] = userAmount; ```   Aave pool's withdraw() returns the amount of underlying asset that was actually withdrawn:  https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/pool/Pool.sol#L196-L217  https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/logic/SupplyLogic.sol#L93-L111  If a particular lending pool has liquidity shortage at the moment, say all underlying is lent out, full withdrawal of the requested underlying token amount will not be possible.  ## Recommended Mitigation Steps  Consider adjusting for the amount actually withdrawn. Also the buffer that stores minted but not yet used atoken amount, say aAmountStored, can be introduced.  For example:   ```  +   uint256 amountNeeded = userAmount < aAmountStored ? 0 : userAmount - aAmountStored;  -   IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE); +   if (amountNeeded > 0) { +       IAavePool(s.aavePool).mintUnbacked(adopted, amountNeeded, address(this), AAVE_REFERRAL_CODE); +   }      // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer -   IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this)); +   uint256 amountWithdrawn = IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));      // Store principle debt -   s.portalDebt[_transferId] = userAmount; +   s.portalDebt[_transferId] = amountWithdrawn; // can't exceed userAmount +   aAmountStored = (userAmount < aAmountStored ? aAmountStored : userAmount) - amountWithdrawn; // we used amountWithdrawn  ```  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/StableSwapFacet.sol#L279-L286   # Vulnerability details  ## Impact In `StableSwapFacet.sol`, two swapping functions contain the `whenNotPaused` modifier while `swapExactOut()` and `addSwapLiquidity()` do not. All functions to swap and add liquidity should contain the same modifiers to stop transactions while paused.   ## Proof of Concept ***Example with modifier*** ```   function swapExact(     bytes32 canonicalId,     uint256 amountIn,     address assetIn,     address assetOut,     uint256 minAmountOut,     uint256 deadline   ) external payable nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) { ```  ***Examples without modifier*** ```   function swapExactOut(     bytes32 canonicalId,     uint256 amountOut,     address assetIn,     address assetOut,     uint256 maxAmountIn,     uint256 deadline   ) external payable nonReentrant deadlineCheck(deadline) returns (uint256) { ```  and  ```   function addSwapLiquidity(     bytes32 canonicalId,     uint256[] calldata amounts,     uint256 minToMint,     uint256 deadline   ) external nonReentrant deadlineCheck(deadline) returns (uint256) {     return s.swapStorages[canonicalId].addLiquidity(amounts, minToMint);   } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Add the `whenNotPaused` modifier to all functions that perform swaps or liquidity additions.  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984 https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347   # Vulnerability details  ## Proof-of-Concept  Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. For example Tether (USDT)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.  #### Instance 1 - `BridgeFacet._reconcileProcessPortal`  The following function must be approved by zero first, and then the ` SafeERC20.safeIncreaseAllowance` function can be called. Otherwise, the `_reconcileProcessPortal` function will revert everytime it handles such kind of tokens. Understood from the [comment](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L1025) that after the backUnbacked call there could be a remaining allowance.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984)  ```solidity   function _reconcileProcessPortal(     uint256 _amount,     address _local,     address _router,     bytes32 _transferId   ) private returns (uint256) {    ..SNIP..     SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);      (bool success, ) = s.aavePool.call(       abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)     );    ..SNIP..   } ```  #### Instance 2 - `BridgeFacet_swapAssetOut`  The following fucntion must first be approved by zero, follow by the actual allowance to be approved. Otherwise, the `_swapAssetOut` function will revert everytime it handles such kind of tokens.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347)  ```solidity   function _swapAssetOut(     bytes32 _canonicalId,     address _assetIn,     address _assetOut,     uint256 _amountOut,     uint256 _maxIn   )     internal     returns (       bool,       uint256,       address     )   {     AppStorage storage s = LibConnextStorage.connextStorage();      bool success;     uint256 amountIn;      // Swap the asset to the proper local asset     if (stableSwapPoolExist(_canonicalId)) {       // get internal swap pool       SwapUtils.Swap storage ipool = s.swapStorages[_canonicalId];       // if internal swap pool exists       uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(_canonicalId, _assetIn);       uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(_canonicalId, _assetOut);       // calculate slippage before performing swap       // NOTE: this is less efficient then relying on the `swapInternalOut` revert, but makes it easier       // to handle slippage failures (this can be called during reconcile, so must not fail)       if (_maxIn >= ipool.calculateSwapInv(tokenIndexIn, tokenIndexOut, _amountOut)) {         success = true;         amountIn = ipool.swapInternalOut(tokenIndexIn, tokenIndexOut, _amountOut, _maxIn);       }       // slippage is too high to perform swap: success = false, amountIn = 0     } else {       // Otherwise, swap via stable swap pool       IStableSwap pool = s.adoptedToLocalPools[_canonicalId];       uint256 _amountIn = pool.calculateSwapOutFromAddress(_assetIn, _assetOut, _amountOut);       if (_amountIn <= _maxIn) {         // set the success         success = true;          // perform the swap         SafeERC20.safeApprove(IERC20(_assetIn), address(pool), _amountIn);         amountIn = pool.swapExactOut(_amountOut, _assetIn, _assetOut, _maxIn);       }       // slippage is too high to perform swap: success = false, amountIn = 0     }      return (success, amountIn, _assetOut);   } ```  ## Impact  Both the`_reconcileProcessPortal` and `_swapAssetOut` functions are called during repayment to Aave Portal if the fast-transfer was executed using portal liquidity. Thus, it is core part of the token transfer process within Connext, and failure of any of these functions would disrupt the AAVE repayment process.  Since both functions affect the AAVE repayment process, I'm grouping them as one issue.  ## Recommended Mitigation Steps  As Connext bridges/routers deal with all sort of tokens existed in various domains/chains, the protocol should try to implement measure to ensure that it is compatible with as much tokens as possible for future growth and availability of the protocol.  #### Instance 1 - `BridgeFacet._reconcileProcessPortal`  It is recommended to set the allowance to zero before increasing the allowance  ```solidity SafeERC20.safeApprove(IERC20(_assetIn), address(pool), 0); SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount); ```  #### Instance 2 - `BridgeFacet_swapAssetOut`  It is recommended to set the allowance to zero before each approve call.  ```solidity SafeERC20.safeApprove(IERC20(_assetIn), address(pool), 0); SafeERC20.safeApprove(IERC20(_assetIn), address(pool), _amountIn); ```  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293 https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490 https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212   # Vulnerability details  ## Proof-of-Concept  Assume that Alice's router has large amount of liquidity inside.  Assume that the Connext Admin decided to remove a router owned by Alice. The Connext Admin will call the `RoutersFacet.removeRouter` function, and all information related to Alice's router will be erased (set to 0x0) from the `s.routerPermissionInfo`.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293)  ```solidity   function removeRouter(address router) external onlyOwner {     // Sanity check: not empty     if (router == address(0)) revert RoutersFacet__removeRouter_routerEmpty();      // Sanity check: needs removal     if (!s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__removeRouter_notAdded();      // Update mapping     s.routerPermissionInfo.approvedRouters[router] = false;      // Emit event     emit RouterRemoved(router, msg.sender);      // Remove router owner     address _owner = s.routerPermissionInfo.routerOwners[router];     if (_owner != address(0)) {       emit RouterOwnerAccepted(router, _owner, address(0));       // delete routerOwners[router];       s.routerPermissionInfo.routerOwners[router] = address(0);     }      // Remove router recipient     address _recipient = s.routerPermissionInfo.routerRecipients[router];     if (_recipient != address(0)) {       emit RouterRecipientSet(router, _recipient, address(0));       // delete routerRecipients[router];       s.routerPermissionInfo.routerRecipients[router] = address(0);     }      // Clear any proposed ownership changes     s.routerPermissionInfo.proposedRouterOwners[router] = address(0);     s.routerPermissionInfo.proposedRouterTimestamp[router] = 0;   } ```  Alice is aware that her router has been removed by Connext Admin, so she decided to withdraw the liquidity from her previous router by calling `RoutersFacet.removeRouterLiquidityFor`.  However, when Alice called the `RoutersFacet.removeRouterLiquidityFor` function, it will revert every single time. This is because the condition `msg.sender != getRouterOwner(_router)` will always fail.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490)  ```solidity   /**    * @notice This is used by any router owner to decrease their available liquidity for a given asset.    * @param _amount - The amount of liquidity to remove for the router    * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the    * native asset, routers may use `address(0)` or the wrapped asset    * @param _to The address that will receive the liquidity being removed    * @param _router The address of the router    */   function removeRouterLiquidityFor(     uint256 _amount,     address _local,     address payable _to,     address _router   ) external nonReentrant whenNotPaused {     // Caller must be the router owner     if (msg.sender != getRouterOwner(_router)) revert RoutersFacet__removeRouterLiquidityFor_notOwner();      // Remove liquidity     _removeLiquidityForRouter(_amount, _local, _to, _router);   } ```  Since the `RoutersFacet.removeRouter` function has earlier erased all information related to Alice's router within `s.routerPermissionInfo`, the `getRouterOwner` function will always return the router address.  In this case, the router address will not match against `msg.sender` address/Alice address, thus Alice attempts to call `removeRouterLiquidityFor` will always revert.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212)  ```solidity   function getRouterOwner(address _router) public view returns (address) {     address _owner = s.routerPermissionInfo.routerOwners[_router];     return _owner == address(0) ? _router : _owner;   } ```  ## Impact  Router owner who provides liquidity could be rugged by Connext admin. When this happen, the router owner funds will be struck  within the `RoutersFacet` contract, and there is no way for the router owner to retrieve their liquidity.  In the worst case scenario, a compromised Connext admin could remove all routers, and cause all liquidity to be struck within `RoutersFacet` and no router owner could withdraw their liquidity from the contract. Next, the `RouterFacet` contract could be upgraded to include additional function to withdraw all liquidity from the contract to an arbitrary wallet address.  ## Recommended Mitigation Steps  The router owner is still entitled to their own liquidity even though their router has been removed by Connext Admin. Thus, they should be given the right to take back their liquidity when such an event happens. The contract should update its implementation to support this. This will give more assurance to the router owner.  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819   # Vulnerability details  ## Proof-of-Concept  A third party sponsor would need to implement a `SponsorVault` contract that is aligned with the `ISponsorVault` interface.  Assume that a `SponsorVault` contract has been defined on Optimism chain. All cross-chain communications are required to call the `BridgeFacet.execute`, which in turn will trigger the `BridgeFacet._handleExecuteTransaction` internal function.   However, if there is an error within `SponsorVault` contract in Optimism causing a revert when `s.sponsorVault.reimburseLiquidityFees` or `s.sponsorVault.reimburseRelayerFees` is called, the entire `execute` transaction will revert. Since `execute` transaction always revert, any cross-chain communication between Optimism and other domains will fail.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819)  ```solidity   /**    * @notice Process the transfer, and calldata if needed, when calling `execute`    * @dev Need this to prevent stack too deep    */   function _handleExecuteTransaction(     ExecuteArgs calldata _args,     uint256 _amount,     address _asset, // adopted (or local if specified)     bytes32 _transferId,     bool _reconciled   ) private returns (uint256) {     // If the domain if sponsored     if (address(s.sponsorVault) != address(0)) {       // fast liquidity path       if (!_reconciled) {         // Vault will return the amount of the fee they sponsored in the native fee         // NOTE: some considerations here around fee on transfer tokens and ensuring         // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a         // balance read about it          uint256 starting = IERC20(_asset).balanceOf(address(this));         uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);          // Validate correct amounts are transferred         if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {           revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();         }          _amount = _amount + sponsored;       }        // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee       // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),       // then the vault should just pay out the configured constant       s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);     }     ..SNIP.. ```  ## Impact  It will result in denial of service. The `SponsorVault` contract, which belongs to a third-party, is a single point of failure for a domain.  ## Recommended Mitigation Steps  This is a problem commonly encountered whenever a method of a smart contract calls another contract – we cannot rely on the other contract to work 100% of the time, and it is dangerous to assume that the external call will always be successful. Additionally, external smart contract might be vulnerable and compromised by an attacker. Even if the team has audited or review the SponsorVault before whitelisting them, some risk might still exist.  Therefore, it is recommended to implement a fail-safe design where failure of an external call to SponsorVault will not disrupt the cross-chain communication. Consider implementing a try-catch block as shown below. If there is any issue with the external `SponsorVault ` contract, no funds are reimbursed to the users in the worst case scenario, but the issue will not cause any impact to the cross-chain communication.  ```diff function _handleExecuteTransaction(  ExecuteArgs calldata _args,  uint256 _amount,  address _asset, // adopted (or local if specified)  bytes32 _transferId,  bool _reconciled ) private returns (uint256) {  // If the domain if sponsored  if (address(s.sponsorVault) != address(0)) {    // fast liquidity path    if (!_reconciled) {   // Vault will return the amount of the fee they sponsored in the native fee   // NOTE: some considerations here around fee on transfer tokens and ensuring   // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a   // balance read about it    uint256 starting = IERC20(_asset).balanceOf(address(this)); +  try s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to) returns (uint256 sponsored) { +   // Validate correct amounts are transferred +   if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) { +     revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount(); +   } + +   _amount = _amount + sponsored; +  } catch {}    }     // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee    // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),    // then the vault should just pay out the configured constant +   try s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee) {} catch {}  ..SNIP.. ```  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411   # Vulnerability details  ## Proof-of-Concept  > This issue is only applicable for fast-transfer. Slow transfer would not have this issue because of the built-in fraud-proof mechanism in Nomad.  First, the attacker will attempt to use Connext to send `1000 USDC` from Ethereum domain to Optimism domain.  Assume that the attacker happens to be a relayer on the relayer network utilised by Connext, and the attacker's relayer happens to be tasked to relay the above execute calldata to the Optimism's Connext [`BridgeFacet.execute`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411) function.  Optimism's Connext `BridgeFacet.execute` received the execute calldata and observed within the calldata that it is a fast-transfer and Router A is responsible for providing the liquidity. It will then check that the router signature is valid, and proceed to transfer `1000 oUSDC` to attacker wallet (0x123456) in Optimism.  Next, attacker will update the `ExecuteArgs.local` within the execute calldata to a valid local representation of canonical token (USDC) used within Polygon. Attacker will then send the modified execute calldata to Polygon's Connext `BridgeFacet.execute` function. Assume that the same Router A is also providing liquidity in Polygon. The `BridgeFacet.execute` function checks that the router signature is valid, and proceed to transfer `1000 POS-USDC` to atttack wallet (0x123456) in Polygon.   At this point, the attacker has `1000 oUSDC` and `1000 POS-USDC` in his wallets. When the nomad message arrives at Optimism, Router A can claim the `1000 oUSDC` back from Connext. However, Router A is not able to claim back any fund in Polygon.  Note that same wallet address exists on different chains. For instance, the wallet address on Etherum and Polygon is the same.  ### Why changing the `ExecuteArgs.local` does not affect the router signature verification?  This is because the router signature is generated from the `transferId` + `pathLength` only, and these data are stored within the `CallParams params` within the `ExecuteArgs` struct.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L77](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L77)  ```solidity struct ExecuteArgs {   CallParams params;   address local; // local representation of canonical token   address[] routers;   bytes[] routerSignatures;   uint256 amount;   uint256 nonce;   address originSender; } ```  Within the [`BridgeFacet._executeSanityChecks`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411) function, it will attempt to rebuild to `transferId` by calling the following code:  ```solidity // Derive transfer ID based on given arguments. bytes32 transferId = _getTransferId(_args); ```  Within the [`BridgeFacet._getTransferId`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719) function, we can see that the `s.tokenRegistry.getTokenId(_args.local)` will always return the canonical `tokenDomain` and `tokenId`. In our example, it will be `Ethereum` and  `USDC`. Therefore, as long as the attacker specify a valid local representation of canonical token on a chain, the `transferId` returned by `s.tokenRegistry.getTokenId(_args.local)` will always be the same across all domains. Thus, this allows the attacker to modify the `ExecuteArgs.local` and yet he could pass the router signature check.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719)  ```solidity   function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {     (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);     return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);   } ```  ## Impact   Router liquidity would be drained by attacker, and affected router owner could not claim back their liquidity.  ## Recommended Mitigation Steps  The security of the current Connext design depends on how secure or reliable the relayer is. If the relayer turns rouge or act against Connext, many serious consequences can happen.  The root cause is that the current design places enormous trust on the relayers to accurately and reliably to deliver calldata to the bridge in various domains. For instance, delivering of execute call data to `execute` function. There is an attempt to prevent message replay on a single domain, however, it does not prevent message replay across multiple domains. Most importantly, the Connext's bridge appears to have full trust on the calldata delivered by the relayer. However, the fact is that the calldata can always be altered by the relayer.  Consider a classic 0x off-chain ordering book protocol. A user will sign his order with his private key, and attach the signature to the order, and send the order (with signature) to the relayer network. If the relayer attempts to tamper the order message or signature, the decoded address will be different from the signer's address and this will be detected by 0x's Smart contract on-chain when processing the order. This ensures that the integrity of the message and signer can be enforced.  Per good security practice, relayer network should always be considered as a hostile environment/network. Therefore, it is recommended that similar approach could be taken with regards to passing execute calldata across domains/chains.  For instance, at a high level, the sequencer should sign the execute calldata with its private key, and attach the signature to the execute calldata. Then, submit the execute calldata (with signature) to the relayer network. When the bridge receives the execute calldata (with signature), it can verify if the decoded address matches the sequencer address to ensure that the calldata has not been altered. This will ensure the intergrity of the execute calldata and prevent any issue that arise due to unauthorised modification of calldata.  Additionally, the execute calldata should also have a field that correspond to the destination domain. The bridge that receives the execute calldata must verify that the execute calldata is intended for its domain, otherwise reject the calldata if it belongs to other domains. This also helps to prevent the attack mentioned earlier where same execute calldata can be accepted in different domains.  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80    # Vulnerability details  ## Impact  When repaying the AAVE Portal in [`repayAavePortal()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80) the `_local` asset is used to repay the loan in `_backLoan()` rather than the `adopted` asset. This is likely to cause issues in production when actually repaying loans if the asset/token being repayed to AAVE is not the same as the asset/token that was borrowed.  ## Proof of Concept The comment on [`L93`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L93) of [`PortalFacet.sol`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol) states;  ``` // Need to swap into adopted asset or asset that was backing the loan // The router will always be holding collateral in the local asset while the loaned asset // is the adopted asset ```  The swap is executed on [`L98`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L98) in the call to `AssetLogic.swapFromLocalAssetIfNeededForExactOut()` however the return value `adopted` is never used (it's an unused local variable). The full function is shown below;  ``` // Swap for exact `totalRepayAmount` of adopted asset to repay aave (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(   _local,   totalAmount,   _maxIn );  if (!success) revert PortalFacet__repayAavePortal_swapFailed();  // decrement router balances unchecked {   s.routerBalances[msg.sender][_local] -= amountIn; }  // back loan _backLoan(_local, _backingAmount, _feeAmount, _transferId); ``` The balance of the `_local` token is reduced but instead of the `adopted` token being passed to [`_backLoan()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L112) in L112 the `_local` token is used. ## Tools Used Vim  ## Recommended Mitigation Steps To be consistent with the comments in the [`repayAavePortal()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80) function `adopted` should be passed to `_backLoan` so that the loan is repayed in the appropriate token.  Remove the reference to `_local` in the [`_backLoan()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L112) function and replace it with `adopted` so it reads;  `_backLoan(adopted, _backingAmount, _feeAmount, _transferId);`  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/AssetFacet.sol#L100   # Vulnerability details  ## Issue  1. Admin can call setWrapper function to setup a new wrapper Y instead of old wrapper X  2. This becomes a problem for any old asset which was setup during setupAsset call where s.canonicalToAdopted[_canonical.id]  will still point to old wrapper X instead of Y  ## Recommendation If wrapper is changed then all variables storing this wrapper should also update  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80-L113   # Vulnerability details  ## Impact The caller of `repayAavePortal()` can trigger an underflow to arbitrarily increase the caller's balance through an underflow.  ## Proof of Concept ```sol // Relevant code sections:  // PortalFacet.sol   function repayAavePortal(     address _local,     uint256 _backingAmount,     uint256 _feeAmount,     uint256 _maxIn,     bytes32 _transferId   ) external {     uint256 totalAmount = _backingAmount + _feeAmount; // in adopted     uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local      // Sanity check: has that much to spend     if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();      // Need to swap into adopted asset or asset that was backing the loan     // The router will always be holding collateral in the local asset while the loaned asset     // is the adopted asset      // Swap for exact `totalRepayAmount` of adopted asset to repay aave     (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(       _local,       totalAmount,       _maxIn     );      if (!success) revert PortalFacet__repayAavePortal_swapFailed();      // decrement router balances     unchecked {       s.routerBalances[msg.sender][_local] -= amountIn;     }      // back loan     _backLoan(_local, _backingAmount, _feeAmount, _transferId);   }  // AssetLogic.sol   function swapFromLocalAssetIfNeededForExactOut(     address _asset,     uint256 _amount,     uint256 _maxIn   )     internal     returns (       bool,       uint256,       address     )   {     AppStorage storage s = LibConnextStorage.connextStorage();      // Get the token id     (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);      // If the adopted asset is the local asset, no need to swap     address adopted = s.canonicalToAdopted[id];     if (adopted == _asset) {       return (true, _amount, _asset);     }      return _swapAssetOut(id, _asset, adopted, _amount, _maxIn);   } ``` First, call `repayAavePortal()` where `_backingAmount + _feeAmount > s.routerBalances[msg.sender][_local] && _maxIn > s.routerBalances[msg.sender][_local]`. That will trigger the call to the AssetLogic contract: ```sol     (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(       _local,       totalAmount,       _maxIn     ); ``` By setting `_local` to the same value as the adopted asset, you trigger the following edge case: ```sol     address adopted = s.canonicalToAdopted[id];     if (adopted == _asset) {       return (true, _amount, _asset);     } ``` So the `amountIn` value returned by `swapFromLocalAssetIfNeededForExactOut()` is the `totalAmount` value that was passed to it. And `totalAmount == _backingAmount + _feeAmount`.  Meaning the `amountIn` value is user-specified for this edge case. Finally, we reach the following line: ```sol     unchecked {       s.routerBalances[msg.sender][_local] -= amountIn;     } ``` `amountIn` (user-specified) is subtracted from the `routerBalances` in an `unchecked` block. Thus, the attacker is able to trigger an underflow and increase their balance arbitrarily high. The `repayAavePortal()` function only verifies that `routerBalance < _maxIn`.  Here's a test as PoC: ```sol // PortalFacet.t.sol    function test_PortalFacet_underflow() public {     s.routerPermissionInfo.approvedForPortalRouters[router] = true;      uint backing = 2 ether;     uint fee = 10000;     uint init = 1 ether;      s.routerBalances[router][_local] = init;     s.portalDebt[_id] = backing;     s.portalFeeDebt[_id] = fee;      vm.mockCall(s.aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector), abi.encode(true));     vm.prank(router);     this.repayAavePortal(_local, backing, fee, init - 0.5 ether, _id);      // balance > init => underflow     require(s.routerBalances[router][_local] > init);   } ``` ## Tools Used none  ## Recommended Mitigation Steps After the call to `swapFromLocalAssetIfNeededForExactOut()` you should add the following check: ```sol if (_local == adopted) {   require(routerBalance >= amountIn); } ```  
# Equality check with different uint sizes can cause failures   # Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/BridgeFacet.sol#L283 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L146 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L41   # Vulnerability details  ## Impact In `BridgeFacet.sol` the `xcall()` function checks if `_args.params.originDomain != s.domain` and it will revert if these are not equal. The problem is that the `originDomain` is a `uint32` and the `s.domain` is a `uint256`.  This means that if the `s.domain` number is ever larger than the max value for a uint32 value,  this function will fail every time because the `originDomain` could never reach a large enough number.   ## Proof of Concept https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/BridgeFacet.sol#L283  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L146  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L41  ## Tools Used Manual code review   ## Recommended Mitigation Steps The `_args.params.originDomain` and the `s.domain` should both be the same uint type.  They both should be either a uint32 or uint256 to avoid any possible failures due to numbers not being large enough.   
# Oracle price from DEX can be manipulated  # Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99   # Vulnerability details  ## Impact The [`ConnextPriceOracle.getPriceFromDex`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99) function divides the balances of the two token pairs to compute the price. There are several issues with it:  1. This only returns the *spot price* which can easily be manipulated through flash loans. This is okay if the price oracle contract is only used off-chain 2. It only works with specific AMMs like Uniswap that keep both balances in the contract. Also, any fees that are in the contract are used as part of the price computation but they should not. 3. It uses the balance instead of the `reserve` data. For many Uniswap-like AMMs, the balance can be manipulated by sending tokens directly to the contract, and then reclaimed later through a `skim`. The reserve should be used instead.  #### POC - Attacker sends a large amount of base tokens to a Uniswap V2 pool. - The `getPriceFromDex` computes the `token` price as `baseBalance` denominated in `token` / `tokenBalance`. As the `baseBalance` is increased, the `tokenPrice` is increased as well. - Attacker calls `skim` on the pool to get back their balance.  ## Recommended Mitigation Steps The price from DEX function is not suited for any on-chain queries. For off-chain queries it can also be manipulated as it uses `balance` instead of reserves - which can be claimed back at a future block although this comes with risk.  
# Double Initialize on Diamond Init  # Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/upgrade-initializers/DiamondInit.sol#L36   # Vulnerability details  ## Impact An attacker could Double Initialize the Diamond Init contract due to unsafe checks.  ## Proof of Concept 1. Clone the Contest Repo. 2. Start Remixd and go to Remix website and connect with local host 3. Open DiamondInit contract. 4. Compile it and call the init function multiple times with different arguments and accounts.  ## Tools Used Remixd and Remix  ## Root Cause  There is no Standard Initializer modifier on init function. It seems the contract sets the `s.initalized = true` but this cannot be a valid check because I was able to call it multiple times on testing.  ## Recommended Mitigation Steps Use Initializer modifier on Openzepplin library.  
**Overview**  Risk Rating | Number of issues --- | --- Gas Issues | 16  **Table of Contents:**  - [1. Avoid unnecessary calculation when `_args.amount == 0`](#1-avoid-unnecessary-calculation-when-_argsamount--0) - [2. Cheap Contract Deployment Through Clones](#2-cheap-contract-deployment-through-clones) - [3. Avoid emitting a storage variable when a memory value is available](#3-avoid-emitting-a-storage-variable-when-a-memory-value-is-available) - [4. Reduce the size of error messages (Long revert Strings)](#4-reduce-the-size-of-error-messages-long-revert-strings) - [5. SafeMath is not needed when using Solidity version 0.8+](#5-safemath-is-not-needed-when-using-solidity-version-08) - [6. `>=` is cheaper than `>` (and `<=` cheaper than `<`)](#6--is-cheaper-than--and--cheaper-than-) - [7. Splitting `require()` statements that use `&&` saves gas](#7-splitting-require-statements-that-use--saves-gas) - [8. Using private rather than public for constants saves gas](#8-using-private-rather-than-public-for-constants-saves-gas) - [9. `<array>.length` should not be looked up in every loop of a `for-loop`](#9-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop) - [10. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)](#10-i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1) - [11. Increments/decrements can be unchecked in for-loops](#11-incrementsdecrements-can-be-unchecked-in-for-loops) - [12. It costs more gas to initialize variables with their default value than letting the default value be applied](#12-it-costs-more-gas-to-initialize-variables-with-their-default-value-than-letting-the-default-value-be-applied) - [13. A variable should be immutable](#13-a-variable-should-be-immutable) - [14. Use Custom Errors instead of Revert Strings to save Gas](#14-use-custom-errors-instead-of-revert-strings-to-save-gas) - [15. Functions guaranteed to revert when called by normal users can be marked `payable`](#15-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable) - [16. Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)](#16-use-scientific-notation-eg-1e18-rather-than-exponentiation-eg-1018)  ## 1. Avoid unnecessary calculation when `_args.amount == 0`  [Here](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L762), if `_args.amount == 0` (which is possible), there should be a return statement to avoid unnecessary gas consumption:  ```solidity File: BridgeFacet.sol 762:     uint256 toSwap = _args.amount; // @audit-info [INFO] amount can be 0 meaning that this should return to avoid unnecessary gas consumption. Recommendation: add a if (_args.amount == 0) return; ```  ## 2. Cheap Contract Deployment Through Clones  ```solidity core/connext/facets/upgrade-initializers/DiamondInit.sol:73:      s.executor = new Executor(address(this)); ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  Consider applying a similar pattern.  ## 3. Avoid emitting a storage variable when a memory value is available  When they are the same, consider emitting the memory value instead of the storage value:  ```solidity contracts/contracts/core/connext/helpers/ProposedOwnableUpgradeable.sol:   320    function _setProposed(address newlyProposed) private {   321      _proposedOwnershipTimestamp = block.timestamp;   322      _proposed = newlyProposed;   323:     emit OwnershipProposed(_proposed); //@audit should emit newlyProposed  contracts/contracts/core/shared/ProposedOwnable.sol:   169    function _setProposed(address newlyProposed) private {   170      _proposedOwnershipTimestamp = block.timestamp;   171      _proposed = newlyProposed;   172:     emit OwnershipProposed(_proposed);//@audit should emit newlyProposed   173    } ```  ## 4. Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity core/connext/helpers/OZERC20.sol:185:    require(_sender != address(0), "ERC20: transfer from the zero address"); core/connext/helpers/OZERC20.sol:186:    require(_recipient != address(0), "ERC20: transfer to the zero address"); core/connext/helpers/OZERC20.sol:190:    balances[_sender] = balances[_sender].sub(amount, "ERC20: transfer amount exceeds balance"); core/connext/helpers/OZERC20.sol:226:    require(_account != address(0), "ERC20: burn from the zero address"); core/connext/helpers/OZERC20.sol:230:    balances[_account] = balances[_account].sub(_amount, "ERC20: burn amount exceeds balance"); core/connext/helpers/OZERC20.sol:253:    require(_owner != address(0), "ERC20: approve from the zero address"); core/connext/helpers/OZERC20.sol:254:    require(_spender != address(0), "ERC20: approve to the zero address"); core/connext/libraries/LibDiamond.sol:66:    require(msg.sender == diamondStorage().contractOwner, "LibDiamond: Must be contract owner"); core/connext/libraries/LibDiamond.sol:113:        revert("LibDiamondCut: Incorrect FacetCutAction"); core/connext/libraries/LibDiamond.sol:121:    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut"); core/connext/libraries/LibDiamond.sol:123:    require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)"); core/connext/libraries/LibDiamond.sol:132:      require(oldFacetAddress == address(0), "LibDiamondCut: Can't add function that already exists"); core/connext/libraries/LibDiamond.sol:139:    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut"); core/connext/libraries/LibDiamond.sol:141:    require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)"); core/connext/libraries/LibDiamond.sol:150:      require(oldFacetAddress != _facetAddress, "LibDiamondCut: Can't replace function with same function"); core/connext/libraries/LibDiamond.sol:158:    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut"); core/connext/libraries/LibDiamond.sol:161:    require(_facetAddress == address(0), "LibDiamondCut: Remove facet address must be address(0)"); core/connext/libraries/LibDiamond.sol:170:    enforceHasContractCode(_facetAddress, "LibDiamondCut: New facet has no code"); core/connext/libraries/LibDiamond.sol:191:    require(_facetAddress != address(0), "LibDiamondCut: Can't remove function that doesn't exist"); core/connext/libraries/LibDiamond.sol:193:    require(_facetAddress != address(this), "LibDiamondCut: Can't remove immutable function"); core/connext/libraries/LibDiamond.sol:224:      require(_calldata.length == 0, "LibDiamondCut: _init is address(0) but_calldata is not empty"); core/connext/libraries/LibDiamond.sol:226:      require(_calldata.length > 0, "LibDiamondCut: _calldata is empty but _init is not address(0)"); core/connext/libraries/LibDiamond.sol:228:        enforceHasContractCode(_init, "LibDiamondCut: _init address has no code"); core/connext/libraries/LibDiamond.sol:236:          revert("LibDiamondCut: _init function reverted"); core/connext/libraries/SwapUtils.sol:595:        balances[i] = balances[i].sub(amounts[i], "Cannot withdraw more than available"); core/connext/libraries/SwapUtils.sol:697:    require(dy <= self.balances[tokenIndexTo], "Cannot get more than pool balance"); core/connext/libraries/SwapUtils.sol:784:    require(dy <= self.balances[tokenIndexTo], "Cannot get more than pool balance"); core/connext/libraries/SwapUtils.sol:1015:        balances1[i] = v.balances[i].sub(amounts[i], "Cannot withdraw more than available"); ```  Consider shortening the revert strings to fit in 32 bytes.  ## 5. SafeMath is not needed when using Solidity version 0.8+  Solidity version 0.8+ already implements overflow and underflow checks by default. Using the SafeMath library from OpenZeppelin (which is more gas expensive than the 0.8+ overflow checks) is therefore redundant.  Consider using the built-in checks instead of SafeMath and remove SafeMath here:  ```solidity core/connext/helpers/ConnextPriceOracle.sol:2:pragma solidity 0.8.14; core/connext/helpers/ConnextPriceOracle.sol:4:import {SafeMath} from "@openzeppelin/contracts/utils/math/SafeMath.sol"; core/connext/helpers/ConnextPriceOracle.sol:45:  using SafeMath for uint256;  core/connext/helpers/OZERC20.sol:2:pragma solidity 0.8.14; core/connext/helpers/OZERC20.sol:10:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; core/connext/helpers/OZERC20.sol:37:  using SafeMath for uint256;  core/connext/libraries/AmplificationUtils.sol:2:pragma solidity 0.8.14; core/connext/libraries/AmplificationUtils.sol:5:import {SafeMath} from "@openzeppelin/contracts/utils/math/SafeMath.sol"; core/connext/libraries/AmplificationUtils.sol:15:  using SafeMath for uint256;  core/connext/libraries/SwapUtils.sol:2:pragma solidity 0.8.14; core/connext/libraries/SwapUtils.sol:4:import {SafeMath} from "@openzeppelin/contracts/utils/math/SafeMath.sol"; core/connext/libraries/SwapUtils.sol:20:  using SafeMath for uint256; ```  ## 6. `>=` is cheaper than `>` (and `<=` cheaper than `<`)  Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas). This also holds true between `<=` and `<`.    Consider replacing strict inequalities with non-strict ones to save some gas here:  ```solidity core/connext/helpers/SponsorVault.sol:214:      sponsoredFee = balance < _liquidityFee ? balance : _liquidityFee; core/connext/helpers/SponsorVault.sol:258:      sponsoredFee = sponsoredFee > address(this).balance ? address(this).balance : sponsoredFee; ```  ## 7. Splitting `require()` statements that use `&&` saves gas  If you're using the Optimizer at 200, instead of using the `&&` operator in a single require statement to check multiple conditions, Consider using multiple require statements with 1 condition per require statement:  ```solidity core/connext/helpers/StableSwap.sol:85:          tokenIndexes[address(_pooledTokens[i])] == 0 && _pooledTokens[0] != _pooledTokens[i], core/connext/libraries/AmplificationUtils.sol:86:    require(futureA_ > 0 && futureA_ < MAX_A, "futureA_ must be > 0 and < MAX_A"); core/connext/libraries/SwapUtils.sol:397:    require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, "Tokens must be in pool"); core/connext/libraries/SwapUtils.sol:493:    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, "Token index out of range"); core/connext/libraries/SwapUtils.sol:524:    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, "Token index out of range"); core/connext/libraries/SwapUtils.sol:1007:    require(maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, ">LP.balanceOf"); ```  Please, note that this might not hold true at a higher number of runs for the Optimizer (10k). However, it indeed is true at 200.  ## 8. Using private rather than public for constants saves gas  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  ```solidity core/connext/facets/BridgeFacet.sol:68:  uint16 public constant AAVE_REFERRAL_CODE = 0; core/connext/helpers/PriceOracle.sol:6:  bool public constant isPriceOracle = true; core/connext/libraries/AmplificationUtils.sol:21:  uint256 public constant A_PRECISION = 100; core/connext/libraries/AmplificationUtils.sol:22:  uint256 public constant MAX_A = 10**6; core/connext/libraries/LibCrossDomainProperty.sol:37:  bytes29 public constant EMPTY = hex"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"; core/connext/libraries/LibCrossDomainProperty.sol:38:  bytes public constant EMPTY_BYTES = hex"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"; core/shared/Version.sol:9:  uint8 public constant VERSION = 0;  ```  ## 9. `<array>.length` should not be looked up in every loop of a `for-loop`  Reading array length at each iteration of the loop consumes more gas than necessary.    In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Here, Consider storing the array's length in a variable before the for-loop, and use this new variable instead:  ```solidity core/connext/facets/RelayerFacet.sol:140:    for (uint256 i; i < _transferIds.length; ) { core/connext/facets/RelayerFacet.sol:164:    for (uint256 i; i < _transferIds.length; ) { core/connext/facets/StableSwapFacet.sol:415:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/helpers/ConnextPriceOracle.sol:176:    for (uint256 i = 0; i < tokenAddresses.length; i++) { core/connext/helpers/Multicall.sol:16:    for (uint256 i = 0; i < calls.length; i++) { core/connext/helpers/StableSwap.sol:81:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/libraries/LibDiamond.sol:104:    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) { core/connext/libraries/LibDiamond.sol:129:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:147:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:162:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/SwapUtils.sol:205:    for (uint256 i = 0; i < xp.length; i++) { core/connext/libraries/SwapUtils.sol:558:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:591:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:844:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:869:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:924:    for (uint256 i = 0; i < amounts.length; i++) { core/connext/libraries/SwapUtils.sol:1014:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1019:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1039:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1055:    for (uint256 i = 0; i < pooledTokens.length; i++) { ```  ## 10. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)  Pre-increments and pre-decrements are cheaper.  For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1` - `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)  **Decrement:**  - `i -= 1` is the most expensive form - `i--` costs 11 gas less than `i -= 1` - `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:  ```solidity uint i = 1;   uint j = 2; require(j == i++, "This will be false as i is incremented after the comparison"); ```    However, pre-increments (or pre-decrements) return the new value:    ```solidity uint i = 1;   uint j = 2; require(j == ++i, "This will be true as i is incremented before the comparison"); ```    In the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.      Affected code:    ```solidity core/connext/facets/BridgeFacet.sol:332:      s.nonce += 1; core/connext/facets/BridgeFacet.sol:613:          i++; core/connext/facets/BridgeFacet.sol:684:          i++; core/connext/facets/BridgeFacet.sol:799:            i++; core/connext/facets/DiamondLoupeFacet.sol:31:    for (uint256 i; i < numFacets; i++) { core/connext/facets/RelayerFacet.sol:144:        i++; core/connext/facets/RelayerFacet.sol:168:        i++; core/connext/facets/StableSwapFacet.sol:415:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/helpers/ConnextPriceOracle.sol:176:    for (uint256 i = 0; i < tokenAddresses.length; i++) { core/connext/helpers/Multicall.sol:16:    for (uint256 i = 0; i < calls.length; i++) { core/connext/helpers/StableSwap.sol:81:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/libraries/Encoding.sol:22:    for (uint8 i = 0; i < 10; i += 1) { core/connext/libraries/Encoding.sol:36:    for (uint8 i = 31; i > 15; i -= 1) { core/connext/libraries/Encoding.sol:45:      for (uint8 i = 15; i < 255; i -= 1) { core/connext/libraries/LibDiamond.sol:104:    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) { core/connext/libraries/LibDiamond.sol:129:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:134:      selectorPosition++; core/connext/libraries/LibDiamond.sol:147:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:153:      selectorPosition++; core/connext/libraries/LibDiamond.sol:162:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/SwapUtils.sol:205:    for (uint256 i = 0; i < xp.length; i++) { core/connext/libraries/SwapUtils.sol:254:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:268:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:289:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:300:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:302:      for (uint256 j = 0; j < numTokens; j++) { core/connext/libraries/SwapUtils.sol:344:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:405:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:425:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:558:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:591:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:844:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:869:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:924:    for (uint256 i = 0; i < amounts.length; i++) { core/connext/libraries/SwapUtils.sol:1014:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1019:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1039:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1055:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/relayer-fee/libraries/RelayerFeeMessage.sol:85:        i++; ```  Consider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).  ## 11. Increments/decrements can be unchecked in for-loops  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Affected code:    ```solidity core/connext/facets/DiamondLoupeFacet.sol:31:    for (uint256 i; i < numFacets; i++) { core/connext/facets/StableSwapFacet.sol:415:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/helpers/ConnextPriceOracle.sol:176:    for (uint256 i = 0; i < tokenAddresses.length; i++) { core/connext/helpers/Multicall.sol:16:    for (uint256 i = 0; i < calls.length; i++) { core/connext/helpers/StableSwap.sol:81:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/libraries/LibDiamond.sol:104:    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) { core/connext/libraries/LibDiamond.sol:129:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:147:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:162:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/SwapUtils.sol:205:    for (uint256 i = 0; i < xp.length; i++) { core/connext/libraries/SwapUtils.sol:254:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:268:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:289:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:300:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:302:      for (uint256 j = 0; j < numTokens; j++) { core/connext/libraries/SwapUtils.sol:344:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:405:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:425:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:558:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:591:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:844:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:869:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:924:    for (uint256 i = 0; i < amounts.length; i++) { core/connext/libraries/SwapUtils.sol:1014:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1019:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1039:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1055:    for (uint256 i = 0; i < pooledTokens.length; i++) { ```  The change would be:      ```diff - for (uint256 i; i < numIterations; i++) { + for (uint256 i; i < numIterations;) {  // ...   +   unchecked { ++i; } }   ```  The same can be applied with decrements (which should use `break` when `i == 0`).  The risk of overflow is non-existant for `uint256` here.  ## 12. It costs more gas to initialize variables with their default value than letting the default value be applied  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Affected code:  ```solidity core/connext/facets/StableSwapFacet.sol:415:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/helpers/ConnextPriceOracle.sol:176:    for (uint256 i = 0; i < tokenAddresses.length; i++) { core/connext/helpers/Multicall.sol:16:    for (uint256 i = 0; i < calls.length; i++) { core/connext/helpers/StableSwap.sol:81:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/libraries/Encoding.sol:22:    for (uint8 i = 0; i < 10; i += 1) { core/connext/libraries/SwapUtils.sol:205:    for (uint256 i = 0; i < xp.length; i++) { core/connext/libraries/SwapUtils.sol:254:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:268:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:289:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:300:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:302:      for (uint256 j = 0; j < numTokens; j++) { core/connext/libraries/SwapUtils.sol:344:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:405:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:425:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:558:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:591:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:844:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:869:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:924:    for (uint256 i = 0; i < amounts.length; i++) { core/connext/libraries/SwapUtils.sol:1014:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1019:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1039:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1055:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/relayer-fee/libraries/RelayerFeeMessage.sol:81:    for (uint256 i = 0; i < length; ) { ```  Consider removing explicit initializations for default values.  ## 13. A variable should be immutable  This variable is only set in the constructor and never edited after that:  ```solidity core/connext/helpers/ConnextPriceOracle.sol:49:  address public wrapped; ```  Consider marking it as immutable, as it would avoid the expensive storage-writing operation (around 20 000 gas)  ## 14. Use Custom Errors instead of Revert Strings to save Gas  Solidity 0.8.4 introduced custom errors. They are more gas efficient than revert strings, when it comes to deploy cost as well as runtime cost when the revert condition is met. Use custom errors instead of revert strings for gas savings.  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Consider replacing all revert strings with custom errors in the solution.  ```solidity core/connext/facets/BaseConnextFacet.sol:38:    require(s._status != _ENTERED, "ReentrancyGuard: reentrant call"); core/connext/facets/BaseConnextFacet.sol:125:    require(_remote != bytes32(0), "!remote"); core/connext/helpers/BridgeToken.sol:94:    require( core/connext/helpers/BridgeToken.sol:130:    require(block.timestamp <= _deadline, "ERC20Permit: expired deadline"); core/connext/helpers/BridgeToken.sol:131:    require(_owner != address(0), "ERC20Permit: owner zero address"); core/connext/helpers/BridgeToken.sol:136:    require(_signer == _owner, "ERC20Permit: invalid signature"); core/connext/helpers/ConnextPriceOracle.sol:72:    require(msg.sender == admin, "caller is not the admin"); core/connext/helpers/ConnextPriceOracle.sol:150:    require(baseTokenPrice > 0, "invalid base token"); core/connext/helpers/Executor.sol:57:    require(msg.sender == connext, "#OC:027"); core/connext/helpers/LPToken.sol:35:    require(amount != 0, "LPToken: cannot mint 0"); core/connext/helpers/LPToken.sol:50:    require(to != address(this), "LPToken: cannot send to itself"); core/connext/helpers/Multicall.sol:18:      require(success); core/connext/helpers/OZERC20.sol:185:    require(_sender != address(0), "ERC20: transfer from the zero address"); core/connext/helpers/OZERC20.sol:186:    require(_recipient != address(0), "ERC20: transfer to the zero address"); core/connext/helpers/OZERC20.sol:205:    require(_account != address(0), "ERC20: mint to the zero address"); core/connext/helpers/OZERC20.sol:226:    require(_account != address(0), "ERC20: burn from the zero address"); core/connext/helpers/OZERC20.sol:253:    require(_owner != address(0), "ERC20: approve from the zero address"); core/connext/helpers/OZERC20.sol:254:    require(_spender != address(0), "ERC20: approve to the zero address"); core/connext/helpers/StableSwap.sol:75:    require(_pooledTokens.length > 1, "_pooledTokens.length <= 1"); core/connext/helpers/StableSwap.sol:76:    require(_pooledTokens.length <= 32, "_pooledTokens.length > 32"); core/connext/helpers/StableSwap.sol:77:    require(_pooledTokens.length == decimals.length, "_pooledTokens decimals mismatch"); core/connext/helpers/StableSwap.sol:84:        require( core/connext/helpers/StableSwap.sol:89:      require(address(_pooledTokens[i]) != address(0), "The 0 address isn't an ERC-20"); core/connext/helpers/StableSwap.sol:90:      require(decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS, "Token decimals exceeds max"); core/connext/helpers/StableSwap.sol:96:    require(_a < AmplificationUtils.MAX_A, "_a exceeds maximum"); core/connext/helpers/StableSwap.sol:97:    require(_fee < SwapUtils.MAX_SWAP_FEE, "_fee exceeds maximum"); core/connext/helpers/StableSwap.sol:98:    require(_adminFee < SwapUtils.MAX_ADMIN_FEE, "_adminFee exceeds maximum"); core/connext/helpers/StableSwap.sol:102:    require(lpToken.initialize(lpTokenName, lpTokenSymbol), "could not init lpToken clone"); core/connext/helpers/StableSwap.sol:125:    require(block.timestamp <= deadline, "Deadline not met"); core/connext/helpers/StableSwap.sol:155:    require(index < swapStorage.pooledTokens.length, "Out of range"); core/connext/helpers/StableSwap.sol:167:    require(address(getToken(index)) == tokenAddress, "Token does not exist"); core/connext/helpers/StableSwap.sol:177:    require(index < swapStorage.pooledTokens.length, "Index out of range"); core/connext/helpers/TokenRegistry.sol:163:    require(_tokenId.domain != 0, "!repr"); core/connext/helpers/TokenRegistry.sol:228:    require(_token != address(0), "!token"); core/connext/libraries/AmplificationUtils.sol:84:    require(block.timestamp >= self.initialATime.add(1 days), "Wait 1 day before starting ramp"); core/connext/libraries/AmplificationUtils.sol:85:    require(futureTime_ >= block.timestamp.add(MIN_RAMP_TIME), "Insufficient ramp time"); core/connext/libraries/AmplificationUtils.sol:86:    require(futureA_ > 0 && futureA_ < MAX_A, "futureA_ must be > 0 and < MAX_A"); core/connext/libraries/AmplificationUtils.sol:92:      require(futureAPrecise.mul(MAX_A_CHANGE) >= initialAPrecise, "futureA_ is too small"); core/connext/libraries/AmplificationUtils.sol:94:      require(futureAPrecise <= initialAPrecise.mul(MAX_A_CHANGE), "futureA_ is too large"); core/connext/libraries/AmplificationUtils.sol:111:    require(self.futureATime > block.timestamp, "Ramp is already stopped"); core/connext/libraries/ConnextMessage.sol:116:    require(isValidAction(_action), "!action"); core/connext/libraries/LibDiamond.sol:66:    require(msg.sender == diamondStorage().contractOwner, "LibDiamond: Must be contract owner"); core/connext/libraries/LibDiamond.sol:100:    require( core/connext/libraries/LibDiamond.sol:121:    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut"); core/connext/libraries/LibDiamond.sol:123:    require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)"); core/connext/libraries/LibDiamond.sol:132:      require(oldFacetAddress == address(0), "LibDiamondCut: Can't add function that already exists"); core/connext/libraries/LibDiamond.sol:139:    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut"); core/connext/libraries/LibDiamond.sol:141:    require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)"); core/connext/libraries/LibDiamond.sol:150:      require(oldFacetAddress != _facetAddress, "LibDiamondCut: Can't replace function with same function"); core/connext/libraries/LibDiamond.sol:158:    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut"); core/connext/libraries/LibDiamond.sol:161:    require(_facetAddress == address(0), "LibDiamondCut: Remove facet address must be address(0)"); core/connext/libraries/LibDiamond.sol:191:    require(_facetAddress != address(0), "LibDiamondCut: Can't remove function that doesn't exist"); core/connext/libraries/LibDiamond.sol:193:    require(_facetAddress != address(this), "LibDiamondCut: Can't remove immutable function"); core/connext/libraries/LibDiamond.sol:224:      require(_calldata.length == 0, "LibDiamondCut: _init is address(0) but_calldata is not empty"); core/connext/libraries/LibDiamond.sol:226:      require(_calldata.length > 0, "LibDiamondCut: _calldata is empty but _init is not address(0)"); core/connext/libraries/LibDiamond.sol:247:    require(contractSize > 0, _errorMessage); core/connext/libraries/SwapUtils.sol:191:    require(tokenIndex < xp.length, "Token index out of range"); core/connext/libraries/SwapUtils.sol:198:    require(tokenAmount <= xp[tokenIndex], "Withdraw exceeds available"); core/connext/libraries/SwapUtils.sol:248:    require(tokenIndex < numTokens, "Token not found"); core/connext/libraries/SwapUtils.sol:342:    require(numTokens == precisionMultipliers.length, "Balances must match multipliers"); core/connext/libraries/SwapUtils.sol:396:    require(tokenIndexFrom != tokenIndexTo, "Can't compare token to itself"); core/connext/libraries/SwapUtils.sol:397:    require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, "Tokens must be in pool"); core/connext/libraries/SwapUtils.sol:493:    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, "Token index out of range"); core/connext/libraries/SwapUtils.sol:524:    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, "Token index out of range"); core/connext/libraries/SwapUtils.sol:554:    require(amount <= totalSupply, "Cannot exceed total supply"); core/connext/libraries/SwapUtils.sol:615:    require(index < self.pooledTokens.length, "Token index out of range"); core/connext/libraries/SwapUtils.sol:649:      require(dx <= tokenFrom.balanceOf(msg.sender), "Cannot swap more than you own"); core/connext/libraries/SwapUtils.sol:662:    require(dy >= minDy, "Swap didn't result in min tokens"); core/connext/libraries/SwapUtils.sol:697:    require(dy <= self.balances[tokenIndexTo], "Cannot get more than pool balance"); core/connext/libraries/SwapUtils.sol:703:    require(dx <= maxDx, "Swap needs more than max tokens"); core/connext/libraries/SwapUtils.sol:717:      require(dx <= tokenFrom.balanceOf(msg.sender), "Cannot swap more than you own"); core/connext/libraries/SwapUtils.sol:723:      require(dx == tokenFrom.balanceOf(address(this)).sub(beforeBalance), "not support fee token"); core/connext/libraries/SwapUtils.sol:750:    require(dx <= tokenFrom.balanceOf(msg.sender), "Cannot swap more than you own"); core/connext/libraries/SwapUtils.sol:756:    require(dy >= minDy, "Swap didn't result in min tokens"); core/connext/libraries/SwapUtils.sol:784:    require(dy <= self.balances[tokenIndexTo], "Cannot get more than pool balance"); core/connext/libraries/SwapUtils.sol:790:    require(dx <= maxDx, "Swap didn't result in min tokens"); core/connext/libraries/SwapUtils.sol:823:    require(amounts.length == pooledTokens.length, "Amounts must match pooled tokens"); core/connext/libraries/SwapUtils.sol:845:      require(v.totalSupply != 0 || amounts[i] > 0, "Must supply all tokens in pool"); core/connext/libraries/SwapUtils.sol:861:    require(v.d1 > v.d0, "D should increase"); core/connext/libraries/SwapUtils.sol:890:    require(toMint >= minToMint, "Couldn't mint min requested"); core/connext/libraries/SwapUtils.sol:916:    require(amount <= lpToken.balanceOf(msg.sender), ">LP.balanceOf"); core/connext/libraries/SwapUtils.sol:917:    require(minAmounts.length == pooledTokens.length, "minAmounts must match poolTokens"); core/connext/libraries/SwapUtils.sol:925:      require(amounts[i] >= minAmounts[i], "amounts[i] < minAmounts[i]"); core/connext/libraries/SwapUtils.sol:954:    require(tokenAmount <= lpToken.balanceOf(msg.sender), ">LP.balanceOf"); core/connext/libraries/SwapUtils.sol:955:    require(tokenIndex < pooledTokens.length, "Token not found"); core/connext/libraries/SwapUtils.sol:961:    require(dy >= minAmount, "dy < minAmount"); core/connext/libraries/SwapUtils.sol:1005:    require(amounts.length == pooledTokens.length, "Amounts should match pool tokens"); core/connext/libraries/SwapUtils.sol:1007:    require(maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, ">LP.balanceOf"); core/connext/libraries/SwapUtils.sol:1032:    require(tokenAmount != 0, "Burnt amount cannot be zero"); core/connext/libraries/SwapUtils.sol:1035:    require(tokenAmount <= maxBurnAmount, "tokenAmount > maxBurnAmount"); core/connext/libraries/SwapUtils.sol:1071:    require(newAdminFee <= MAX_ADMIN_FEE, "Fee is too high"); core/connext/libraries/SwapUtils.sol:1084:    require(newSwapFee <= MAX_SWAP_FEE, "Fee is too high"); core/shared/Router.sol:23:    require(_isRemoteRouter(_origin, _router), "!remote router"); core/shared/Router.sol:64:    require(_remote != bytes32(0), "!remote"); core/shared/XAppConnectionClient.sol:22:    require(_isReplica(msg.sender), "!replica"); ```  ## 15. Functions guaranteed to revert when called by normal users can be marked `payable`  If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.  ```solidity core/connext/facets/AssetFacet.sol:100:  function setWrapper(address _wrapper) external onlyOwner { core/connext/facets/AssetFacet.sol:112:  function setTokenRegistry(address _tokenRegistry) external onlyOwner { core/connext/facets/AssetFacet.sol:162:  function addStableSwapPool(ConnextMessage.TokenId calldata _canonical, address _stableSwapPool) external onlyOwner { core/connext/facets/AssetFacet.sol:171:  function removeAssetId(bytes32 _canonicalId, address _adoptedAssetId) external onlyOwner { core/connext/facets/BridgeFacet.sol:233:  function setPromiseRouter(address payable _promiseRouter) external onlyOwner { core/connext/facets/BridgeFacet.sol:242:  function setExecutor(address _executor) external onlyOwner { core/connext/facets/BridgeFacet.sol:250:  function setSponsorVault(address _sponsorVault) external onlyOwner { core/connext/facets/NomadFacet.sol:25:  function setXAppConnectionManager(address _xAppConnectionManager) external onlyOwner { core/connext/facets/NomadFacet.sol:34:  function enrollRemoteRouter(uint32 _domain, bytes32 _router) external onlyOwner { core/connext/facets/PortalFacet.sol:57:  function setAavePool(address _aavePool) external onlyOwner { core/connext/facets/PortalFacet.sol:65:  function setAavePortalFee(uint256 _aavePortalFeeNumerator) external onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:128:  function proposeRouterOwnershipRenunciation() public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:142:  function renounceRouterOwnership() public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:162:  function proposeAssetOwnershipRenunciation() public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:175:  function renounceAssetOwnership() public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:203:  function proposeNewOwner(address newlyProposed) public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:217:  function renounceOwnership() public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:236:  function acceptProposedOwner() public onlyProposed { core/connext/facets/ProposedOwnableFacet.sol:253:  function pause() public onlyOwner { core/connext/facets/ProposedOwnableFacet.sol:258:  function unpause() public onlyOwner { core/connext/facets/RelayerFacet.sol:88:  function setRelayerFeeRouter(address _relayerFeeRouter) external onlyOwner { core/connext/facets/RelayerFacet.sol:101:  function addRelayer(address _relayer) external onlyOwner { core/connext/facets/RelayerFacet.sol:112:  function removeRelayer(address _relayer) external onlyOwner { core/connext/facets/RelayerFacet.sol:161:  function claim(address _recipient, bytes32[] calldata _transferIds) external onlyRelayerFeeRouter { core/connext/facets/RoutersFacet.sol:293:  function removeRouter(address router) external onlyOwner { core/connext/facets/RoutersFacet.sol:331:  function setMaxRoutersPerTransfer(uint256 _newMaxRouters) external onlyOwner { core/connext/facets/RoutersFacet.sol:345:  function setLiquidityFeeNumerator(uint256 _numerator) external onlyOwner { core/connext/facets/RoutersFacet.sol:361:  function approveRouterForPortal(address _router) external onlyOwner { core/connext/facets/RoutersFacet.sol:375:  function unapproveRouterForPortal(address _router) external onlyOwner { core/connext/facets/RoutersFacet.sol:393:  function setRouterRecipient(address router, address recipient) external onlyRouterOwner(router) { core/connext/facets/RoutersFacet.sol:410:  function proposeRouterOwner(address router, address proposed) external onlyRouterOwner(router) { core/connext/facets/RoutersFacet.sol:430:  function acceptProposedRouterOwner(address router) external onlyProposedRouterOwner(router) { core/connext/facets/StableSwapFacet.sol:460:  function withdrawSwapAdminFees(bytes32 canonicalId) external onlyOwner { core/connext/facets/StableSwapFacet.sol:469:  function setSwapAdminFee(bytes32 canonicalId, uint256 newAdminFee) external onlyOwner { core/connext/facets/StableSwapFacet.sol:478:  function setSwapFee(bytes32 canonicalId, uint256 newSwapFee) external onlyOwner { core/connext/facets/StableSwapFacet.sol:502:  function stopRampA(bytes32 canonicalId) external onlyOwner { core/connext/helpers/BridgeToken.sol:54:  function burn(address _from, uint256 _amnt) external override onlyOwner { core/connext/helpers/BridgeToken.sol:66:  function mint(address _to, uint256 _amnt) external override onlyOwner { core/connext/helpers/BridgeToken.sol:73:  function setDetailsHash(bytes32 _detailsHash) external override onlyOwner { core/connext/helpers/BridgeToken.sol:202:  function transferOwnership(address _newOwner) public override(IBridgeToken, OwnableUpgradeable) onlyOwner { core/connext/helpers/ConnextPriceOracle.sol:158:  function setDirectPrice(address _token, uint256 _price) external onlyAdmin { core/connext/helpers/ConnextPriceOracle.sol:163:  function setV1PriceOracle(address _v1PriceOracle) external onlyAdmin { core/connext/helpers/ConnextPriceOracle.sol:168:  function setAdmin(address newAdmin) external onlyAdmin { core/connext/helpers/ConnextPriceOracle.sol:175:  function setAggregators(address[] calldata tokenAddresses, address[] calldata sources) external onlyAdmin { core/connext/helpers/LPToken.sol:34:  function mint(address recipient, uint256 amount) external onlyOwner { core/connext/helpers/OwnerPausableUpgradeable.sol:14:  function __OwnerPausable_init() internal onlyInitializing { core/connext/helpers/OwnerPausableUpgradeable.sol:23:  function pause() external onlyOwner { core/connext/helpers/OwnerPausableUpgradeable.sol:30:  function unpause() external onlyOwner { core/connext/helpers/OZERC20.sol:263:   * WARNING: This function should only be called from the constructor. Most core/connext/helpers/ProposedOwnableUpgradeable.sol:77:  function __ProposedOwnable_init() internal onlyInitializing { core/connext/helpers/ProposedOwnableUpgradeable.sol:81:  function __ProposedOwnable_init_unchained() internal onlyInitializing { core/connext/helpers/ProposedOwnableUpgradeable.sol:155:  function proposeRouterOwnershipRenunciation() public virtual onlyOwner { core/connext/helpers/ProposedOwnableUpgradeable.sol:169:  function renounceRouterOwnership() public virtual onlyOwner { core/connext/helpers/ProposedOwnableUpgradeable.sol:197:  function proposeAssetOwnershipRenunciation() public virtual onlyOwner { core/connext/helpers/ProposedOwnableUpgradeable.sol:211:  function renounceAssetOwnership() public virtual onlyOwner { core/connext/helpers/ProposedOwnableUpgradeable.sol:239:  function proposeNewOwner(address newlyProposed) public virtual onlyOwner { core/connext/helpers/ProposedOwnableUpgradeable.sol:253:  function renounceOwnership() public virtual onlyOwner { core/connext/helpers/ProposedOwnableUpgradeable.sol:272:  function acceptProposedOwner() public virtual onlyProposed { core/connext/helpers/SponsorVault.sol:138:  function setConnext(address _connext) external onlyOwner { core/connext/helpers/SponsorVault.sol:147:  function setRate(uint32 _originDomain, Rate calldata _rate) external onlyOwner { core/connext/helpers/SponsorVault.sol:159:  function setRelayerFeeCap(uint256 _relayerFeeCap) external onlyOwner { core/connext/helpers/SponsorVault.sol:168:  function setGasTokenOracle(address _gasTokenOracle) external onlyOwner { core/connext/helpers/SponsorVault.sol:178:  function setTokenExchange(address _token, address payable _tokenExchange) external onlyOwner { core/connext/helpers/StableSwap.sol:440:  function withdrawAdminFees() external onlyOwner { core/connext/helpers/StableSwap.sol:448:  function setAdminFee(uint256 newAdminFee) external onlyOwner { core/connext/helpers/StableSwap.sol:456:  function setSwapFee(uint256 newSwapFee) external onlyOwner { core/connext/helpers/StableSwap.sol:467:  function rampA(uint256 futureA, uint256 futureTime) external onlyOwner { core/connext/helpers/StableSwap.sol:474:  function stopRampA() external onlyOwner { core/promise/PromiseRouter.sol:155:  function setConnext(address _connext) external onlyOwner { core/relayer-fee/RelayerFeeRouter.sol:89:  function setConnext(address _connext) external onlyOwner { core/shared/ProposedOwnable.sol:109:  function proposeNewOwner(address newlyProposed) public virtual onlyOwner { core/shared/ProposedOwnable.sol:123:  function renounceOwnership() public virtual onlyOwner { core/shared/ProposedOwnable.sol:142:  function acceptProposedOwner() public virtual onlyProposed { core/shared/ProposedOwnable.sol:180:  function __ProposedOwnable_init() internal onlyInitializing { core/shared/ProposedOwnable.sol:184:  function __ProposedOwnable_init_unchained() internal onlyInitializing { core/shared/Router.sol:34:  function enrollRemoteRouter(uint32 _domain, bytes32 _router) external onlyOwner { core/shared/XAppConnectionClient.sol:39:  function setXAppConnectionManager(address _xAppConnectionManager) external onlyOwner { ```  ## 16. Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)  ```solidity core/connext/libraries/SwapUtils.sol:104:  uint256 internal constant FEE_DENOMINATOR = 10**10; core/connext/libraries/SwapUtils.sol:107:  uint256 internal constant MAX_SWAP_FEE = 10**8; core/connext/libraries/SwapUtils.sol:113:  uint256 internal constant MAX_ADMIN_FEE = 10**10; ``` 
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L346 https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L812   # Vulnerability details    Affected  functions(that rely on swapAsset()) are:  [https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L193](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L193)  [https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L159](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L159)  swapAsset() facilitates two swaps, either using the internal or external pool. But if an internal pool exists, a swap will be unsuccessful because the call to  s.swapStorages[_canonicalId].swapInternal() takes two incorrect arguments (due to an incorrect ordering, this seemed to be an oversight, acknowledged by #Layne) :  [https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/AssetLogic.sol#L278-L279](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/AssetLogic.sol#L278-L279)  Based on the above mentioned code , the arguments would be incorrectly changed to :  [https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/SwapUtils.sol#L744-L745](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/SwapUtils.sol#L744-L745)  The condition checked here:  [https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L750](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L750)  will never be true as the msg.sender would never own the quantity of tokens being swapped from since it's the wrong token.  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/DiamondCutFacet.sol#L16-L29 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L94-L118 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L222-L240   # Vulnerability details  ## Impact Diamond is to be upgraded after a certain delay to give time to the community to verify changes made by the developers. If the proposition can be falsified, the contract admins can exploit the contract in any way of their choice.  ## Proof of Concept To determine the id of the proposal, only its facet changes are hashed, skipping two critical pieces of data - the `_init` and `_calldata`. During a diamond upgrade, devs can choose what code will be executed **by the contract using a delegatecall**. Thus, they can make the contract perform **any** actions of their choice.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add `_init` and `_calldata` to the proposition hash.   
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L100-L103 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L71-L79 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L83-L90   # Vulnerability details  ## Impact  Normally, `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` will be set in `LibDiamond.proposeDiamondCut()`. Then in `LibDiamond.diamondCut()`, it checks that `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp`.  However, `LibDiamond.rescindDiamondCut()` will set `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` to 0. Which can easily pass the check in `diamondCut()`. But `rescindDiamondCut` should rescind `_diamondCut`. In conclusion, using `rescindDiamondCut()` can easily bypass the delay time.  Moreover, if `proposeDiamondCut()` has never been called, the check for delay time is always passed.  ## Proof of Concept  `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` will be set in `LibDiamond.proposeDiamondCut()` https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L71-L79 ```   function proposeDiamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     uint256 acceptance = block.timestamp + _delay;     diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = acceptance;     emit DiamondCutProposed(_diamondCut, _init, _calldata, acceptance);   } ```  Then in `LibDiamond.diamondCut()`, it checks that `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp` https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L100-L103 ```   function diamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     require(       diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp,       "LibDiamond: delay not elapsed"     );     …   } ```  However, `LibDiamond.rescindDiamondCut()` will set `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` to 0. Which can easily pass the check in `diamondCut()` https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L83-L90 ```   function rescindDiamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = 0;     emit DiamondCutRescinded(_diamondCut, _init, _calldata);   } ```  ``` diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = 0 < block.timestamp ```   ## Tools Used  None  ## Recommended Mitigation Steps  Add another check in `diamondCut`  ```   function diamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     require(       diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp && diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] != 0,       "LibDiamond: delay not elapsed"     );     …   } ```   
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99-L115   # Vulnerability details  For tokens with decimals larger than 18, many functions across the codebase will revert due to underflow.  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99-L115  ```solidity function getPriceFromDex(address _tokenAddress) public view returns (uint256) {     PriceInfo storage priceInfo = priceRecords[_tokenAddress];     if (priceInfo.active) {       uint256 rawTokenAmount = IERC20Extended(priceInfo.token).balanceOf(priceInfo.lpToken);       uint256 tokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.token).decimals());       uint256 tokenAmount = rawTokenAmount.mul(10**tokenDecimalDelta);       uint256 rawBaseTokenAmount = IERC20Extended(priceInfo.baseToken).balanceOf(priceInfo.lpToken);       uint256 baseTokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.baseToken).decimals());       uint256 baseTokenAmount = rawBaseTokenAmount.mul(10**baseTokenDecimalDelta);       uint256 baseTokenPrice = getTokenPrice(priceInfo.baseToken);       uint256 tokenPrice = baseTokenPrice.mul(baseTokenAmount).div(tokenAmount);        return tokenPrice;     } else {       return 0;     }   } ```  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/StableSwapFacet.sol#L426  ```solidity precisionMultipliers[i] = 10**uint256(SwapUtils.POOL_PRECISION_DECIMALS - decimals[i]); ```  Chainlink feeds' with decimals > 18 are not supported neither:  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L122-L140  ```solidity function getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {     AggregatorV3Interface aggregator = aggregators[_tokenAddress];     if (address(aggregator) != address(0)) {       (, int256 answer, , , ) = aggregator.latestRoundData();        // It's fine for price to be 0. We have two price feeds.       if (answer == 0) {         return 0;       }        // Extend the decimals to 1e18.       uint256 retVal = uint256(answer);       uint256 price = retVal.mul(10**(18 - uint256(aggregator.decimals())));        return price;     }      return 0;   } ```  ### Recommendation  Consider checking if decimals > 18 and normalize the value by div the decimals difference.  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L1053-L1062   # Vulnerability details  ```solidity function withdrawAdminFees(Swap storage self, address to) internal {   IERC20[] memory pooledTokens = self.pooledTokens;   for (uint256 i = 0; i < pooledTokens.length; i++) {     IERC20 token = pooledTokens[i];     uint256 balance = self.adminFees[i];     if (balance != 0) {       token.safeTransfer(to, balance);     }   } } ```  `self.adminFees[i]` should be reset to 0 every time it's withdrawn. Otherwise, the `adminFees` can be withdrawn multiple times.  The admin may just be unaware of this issue and casualty `withdrawAdminFees()` from time to time, and rug all the users slowly.  ### Recommendation  Change to:  ```solidity function withdrawAdminFees(Swap storage self, address to) internal {   IERC20[] memory pooledTokens = self.pooledTokens;   for (uint256 i = 0; i < pooledTokens.length; i++) {     IERC20 token = pooledTokens[i];     uint256 balance = self.adminFees[i];     if (balance != 0) {       self.adminFees[i] = 0;       token.safeTransfer(to, balance);     }   } } ```  
details is used only when !s.tokenRegistry.isLocalOrigin(token) holds:  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L957-L974  ```solidity     bytes32 details = action.detailsHash();      // if the token is of remote origin, mint the tokens. will either     // - be credited to router (fast liquidity)     // - be reserved for execution (slow liquidity)     if (!s.tokenRegistry.isLocalOrigin(token)) {       IBridgeToken(token).mint(address(this), amount);       // Tell the token what its detailsHash is       IBridgeToken(token).setDetailsHash(details);     }     // NOTE: if the token is of local origin, it means it was escrowed     // in this contract at xcall      // mark the transfer as reconciled     s.reconciledTransfers[transferId] = true;      return (amount, token, transferId);   } ```  ## Recommended Mitigation Steps  Move into the `if` scope:  ```     // if the token is of remote origin, mint the tokens. will either     // - be credited to router (fast liquidity)     // - be reserved for execution (slow liquidity)     if (!s.tokenRegistry.isLocalOrigin(token)) {       bytes32 details = action.detailsHash();       IBridgeToken(token).mint(address(this), amount);       // Tell the token what its detailsHash is       IBridgeToken(token).setDetailsHash(details);     } ```
# Chainlink oracle aggregator data is insufficiently validated in `ConnextPriceOracle.sol`  # Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L122-L140   # Vulnerability details  ### Impact  The function `getPriceFromChainlink()` in `ConnextPriceOracle.sol` fetches the `latestRoundData()` from a registered aggregator (Chainlink oracle feed) for a specified token. However, neither round completeness or the quoted timestamp are checked to ensure that the reported price is not stale.  Since Connext is creating bridged representations of tokens from other chains, it is vital for the reported prices of tokens to be accurate. While Connext also consults the DEX reported price of the tokens, some pairs with thin liquidity could also return inaccurate prices.  ### Proof of Concept ```solidity function getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {     AggregatorV3Interface aggregator = aggregators[_tokenAddress];     if (address(aggregator) != address(0)) {       (, int256 answer, , , ) = aggregator.latestRoundData();        // It's fine for price to be 0. We have two price feeds.       if (answer == 0) {         return 0;       }        // Extend the decimals to 1e18.       uint256 retVal = uint256(answer);       uint256 price = retVal.mul(10**(18 - uint256(aggregator.decimals())));        return price;     }      return 0;   } ``` Note that the other returned variables `roundId`, `startedAt`, `updatedAt`, and `answeredInRound` are omitted from the return result of `aggregator.latestRoundData()`.  ### Mitigation steps Add additional validation: ```solidity     ...      (uint80 roundID, int256 price, , uint256 updatedAt, uint80 answeredInRound) = aggregator.latestRoundData();     require(answeredInRound >= roundID, "ChainLink: Stale price");     require(updatedAt != 0, "ChainLink: Round not complete");     ... ```  ### Tools Used Manual review  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L882-L900   # Vulnerability details  _executePortalTransfer can introduce underlying token deficit by accounting for full underlying amount received from Aave unconditionally on what was actually withdrawn from Aave pool. Actual amount withdrawn is returned by `IAavePool(s.aavePool).withdraw()`, but currently is not used.  Setting the severity to medium as this can end up with a situation of partial insolvency, when where are a surplus of atokens, but deficit of underlying tokens in the bridge, so bridge functionality can become unavailable as there will be not enough underlying tokens, which were used up in the previous operations when atokens wasn't converted to underlying fully and underlying tokens from other operations were used up instead without accounting. I.e. the system in this situation supposes that all atokens are in the form of underlying tokens while there will be some atokens left unconverted due to withdrawal being only partial.  ## Proof of Concept  Call sequence here is execute() -> _handleExecuteLiquidity() -> _executePortalTransfer().   BridgeFacet._executePortalTransfer() mints the atokens needed, then withdraws them from Aave pool, always accounting for the full withdrawal:  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L882-L900  ```solidity   /**    * @notice Uses Aave Portals to provide fast liquidity    */   function _executePortalTransfer(     bytes32 _transferId,     uint256 _fastTransferAmount,     address _local,     address _router   ) internal returns (uint256, address) {     // Calculate local to adopted swap output if needed     (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);      IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);      // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer     IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));      // Store principle debt     s.portalDebt[_transferId] = userAmount; ```   Aave pool's withdraw() returns the amount of underlying asset that was actually withdrawn:  https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/pool/Pool.sol#L196-L217  https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/logic/SupplyLogic.sol#L93-L111  If a particular lending pool has liquidity shortage at the moment, say all underlying is lent out, full withdrawal of the requested underlying token amount will not be possible.  ## Recommended Mitigation Steps  Consider adjusting for the amount actually withdrawn. Also the buffer that stores minted but not yet used atoken amount, say aAmountStored, can be introduced.  For example:   ```  +   uint256 amountNeeded = userAmount < aAmountStored ? 0 : userAmount - aAmountStored;  -   IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE); +   if (amountNeeded > 0) { +       IAavePool(s.aavePool).mintUnbacked(adopted, amountNeeded, address(this), AAVE_REFERRAL_CODE); +   }      // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer -   IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this)); +   uint256 amountWithdrawn = IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));      // Store principle debt -   s.portalDebt[_transferId] = userAmount; +   s.portalDebt[_transferId] = amountWithdrawn; // can't exceed userAmount +   aAmountStored = (userAmount < aAmountStored ? aAmountStored : userAmount) - amountWithdrawn; // we used amountWithdrawn  ```  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/StableSwapFacet.sol#L279-L286   # Vulnerability details  ## Impact In `StableSwapFacet.sol`, two swapping functions contain the `whenNotPaused` modifier while `swapExactOut()` and `addSwapLiquidity()` do not. All functions to swap and add liquidity should contain the same modifiers to stop transactions while paused.   ## Proof of Concept ***Example with modifier*** ```   function swapExact(     bytes32 canonicalId,     uint256 amountIn,     address assetIn,     address assetOut,     uint256 minAmountOut,     uint256 deadline   ) external payable nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) { ```  ***Examples without modifier*** ```   function swapExactOut(     bytes32 canonicalId,     uint256 amountOut,     address assetIn,     address assetOut,     uint256 maxAmountIn,     uint256 deadline   ) external payable nonReentrant deadlineCheck(deadline) returns (uint256) { ```  and  ```   function addSwapLiquidity(     bytes32 canonicalId,     uint256[] calldata amounts,     uint256 minToMint,     uint256 deadline   ) external nonReentrant deadlineCheck(deadline) returns (uint256) {     return s.swapStorages[canonicalId].addLiquidity(amounts, minToMint);   } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Add the `whenNotPaused` modifier to all functions that perform swaps or liquidity additions.  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984 https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347   # Vulnerability details  ## Proof-of-Concept  Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. For example Tether (USDT)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.  #### Instance 1 - `BridgeFacet._reconcileProcessPortal`  The following function must be approved by zero first, and then the ` SafeERC20.safeIncreaseAllowance` function can be called. Otherwise, the `_reconcileProcessPortal` function will revert everytime it handles such kind of tokens. Understood from the [comment](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L1025) that after the backUnbacked call there could be a remaining allowance.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984)  ```solidity   function _reconcileProcessPortal(     uint256 _amount,     address _local,     address _router,     bytes32 _transferId   ) private returns (uint256) {    ..SNIP..     SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);      (bool success, ) = s.aavePool.call(       abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)     );    ..SNIP..   } ```  #### Instance 2 - `BridgeFacet_swapAssetOut`  The following fucntion must first be approved by zero, follow by the actual allowance to be approved. Otherwise, the `_swapAssetOut` function will revert everytime it handles such kind of tokens.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347)  ```solidity   function _swapAssetOut(     bytes32 _canonicalId,     address _assetIn,     address _assetOut,     uint256 _amountOut,     uint256 _maxIn   )     internal     returns (       bool,       uint256,       address     )   {     AppStorage storage s = LibConnextStorage.connextStorage();      bool success;     uint256 amountIn;      // Swap the asset to the proper local asset     if (stableSwapPoolExist(_canonicalId)) {       // get internal swap pool       SwapUtils.Swap storage ipool = s.swapStorages[_canonicalId];       // if internal swap pool exists       uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(_canonicalId, _assetIn);       uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(_canonicalId, _assetOut);       // calculate slippage before performing swap       // NOTE: this is less efficient then relying on the `swapInternalOut` revert, but makes it easier       // to handle slippage failures (this can be called during reconcile, so must not fail)       if (_maxIn >= ipool.calculateSwapInv(tokenIndexIn, tokenIndexOut, _amountOut)) {         success = true;         amountIn = ipool.swapInternalOut(tokenIndexIn, tokenIndexOut, _amountOut, _maxIn);       }       // slippage is too high to perform swap: success = false, amountIn = 0     } else {       // Otherwise, swap via stable swap pool       IStableSwap pool = s.adoptedToLocalPools[_canonicalId];       uint256 _amountIn = pool.calculateSwapOutFromAddress(_assetIn, _assetOut, _amountOut);       if (_amountIn <= _maxIn) {         // set the success         success = true;          // perform the swap         SafeERC20.safeApprove(IERC20(_assetIn), address(pool), _amountIn);         amountIn = pool.swapExactOut(_amountOut, _assetIn, _assetOut, _maxIn);       }       // slippage is too high to perform swap: success = false, amountIn = 0     }      return (success, amountIn, _assetOut);   } ```  ## Impact  Both the`_reconcileProcessPortal` and `_swapAssetOut` functions are called during repayment to Aave Portal if the fast-transfer was executed using portal liquidity. Thus, it is core part of the token transfer process within Connext, and failure of any of these functions would disrupt the AAVE repayment process.  Since both functions affect the AAVE repayment process, I'm grouping them as one issue.  ## Recommended Mitigation Steps  As Connext bridges/routers deal with all sort of tokens existed in various domains/chains, the protocol should try to implement measure to ensure that it is compatible with as much tokens as possible for future growth and availability of the protocol.  #### Instance 1 - `BridgeFacet._reconcileProcessPortal`  It is recommended to set the allowance to zero before increasing the allowance  ```solidity SafeERC20.safeApprove(IERC20(_assetIn), address(pool), 0); SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount); ```  #### Instance 2 - `BridgeFacet_swapAssetOut`  It is recommended to set the allowance to zero before each approve call.  ```solidity SafeERC20.safeApprove(IERC20(_assetIn), address(pool), 0); SafeERC20.safeApprove(IERC20(_assetIn), address(pool), _amountIn); ```  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293 https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490 https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212   # Vulnerability details  ## Proof-of-Concept  Assume that Alice's router has large amount of liquidity inside.  Assume that the Connext Admin decided to remove a router owned by Alice. The Connext Admin will call the `RoutersFacet.removeRouter` function, and all information related to Alice's router will be erased (set to 0x0) from the `s.routerPermissionInfo`.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293)  ```solidity   function removeRouter(address router) external onlyOwner {     // Sanity check: not empty     if (router == address(0)) revert RoutersFacet__removeRouter_routerEmpty();      // Sanity check: needs removal     if (!s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__removeRouter_notAdded();      // Update mapping     s.routerPermissionInfo.approvedRouters[router] = false;      // Emit event     emit RouterRemoved(router, msg.sender);      // Remove router owner     address _owner = s.routerPermissionInfo.routerOwners[router];     if (_owner != address(0)) {       emit RouterOwnerAccepted(router, _owner, address(0));       // delete routerOwners[router];       s.routerPermissionInfo.routerOwners[router] = address(0);     }      // Remove router recipient     address _recipient = s.routerPermissionInfo.routerRecipients[router];     if (_recipient != address(0)) {       emit RouterRecipientSet(router, _recipient, address(0));       // delete routerRecipients[router];       s.routerPermissionInfo.routerRecipients[router] = address(0);     }      // Clear any proposed ownership changes     s.routerPermissionInfo.proposedRouterOwners[router] = address(0);     s.routerPermissionInfo.proposedRouterTimestamp[router] = 0;   } ```  Alice is aware that her router has been removed by Connext Admin, so she decided to withdraw the liquidity from her previous router by calling `RoutersFacet.removeRouterLiquidityFor`.  However, when Alice called the `RoutersFacet.removeRouterLiquidityFor` function, it will revert every single time. This is because the condition `msg.sender != getRouterOwner(_router)` will always fail.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490)  ```solidity   /**    * @notice This is used by any router owner to decrease their available liquidity for a given asset.    * @param _amount - The amount of liquidity to remove for the router    * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the    * native asset, routers may use `address(0)` or the wrapped asset    * @param _to The address that will receive the liquidity being removed    * @param _router The address of the router    */   function removeRouterLiquidityFor(     uint256 _amount,     address _local,     address payable _to,     address _router   ) external nonReentrant whenNotPaused {     // Caller must be the router owner     if (msg.sender != getRouterOwner(_router)) revert RoutersFacet__removeRouterLiquidityFor_notOwner();      // Remove liquidity     _removeLiquidityForRouter(_amount, _local, _to, _router);   } ```  Since the `RoutersFacet.removeRouter` function has earlier erased all information related to Alice's router within `s.routerPermissionInfo`, the `getRouterOwner` function will always return the router address.  In this case, the router address will not match against `msg.sender` address/Alice address, thus Alice attempts to call `removeRouterLiquidityFor` will always revert.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212)  ```solidity   function getRouterOwner(address _router) public view returns (address) {     address _owner = s.routerPermissionInfo.routerOwners[_router];     return _owner == address(0) ? _router : _owner;   } ```  ## Impact  Router owner who provides liquidity could be rugged by Connext admin. When this happen, the router owner funds will be struck  within the `RoutersFacet` contract, and there is no way for the router owner to retrieve their liquidity.  In the worst case scenario, a compromised Connext admin could remove all routers, and cause all liquidity to be struck within `RoutersFacet` and no router owner could withdraw their liquidity from the contract. Next, the `RouterFacet` contract could be upgraded to include additional function to withdraw all liquidity from the contract to an arbitrary wallet address.  ## Recommended Mitigation Steps  The router owner is still entitled to their own liquidity even though their router has been removed by Connext Admin. Thus, they should be given the right to take back their liquidity when such an event happens. The contract should update its implementation to support this. This will give more assurance to the router owner.  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819   # Vulnerability details  ## Proof-of-Concept  A third party sponsor would need to implement a `SponsorVault` contract that is aligned with the `ISponsorVault` interface.  Assume that a `SponsorVault` contract has been defined on Optimism chain. All cross-chain communications are required to call the `BridgeFacet.execute`, which in turn will trigger the `BridgeFacet._handleExecuteTransaction` internal function.   However, if there is an error within `SponsorVault` contract in Optimism causing a revert when `s.sponsorVault.reimburseLiquidityFees` or `s.sponsorVault.reimburseRelayerFees` is called, the entire `execute` transaction will revert. Since `execute` transaction always revert, any cross-chain communication between Optimism and other domains will fail.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819)  ```solidity   /**    * @notice Process the transfer, and calldata if needed, when calling `execute`    * @dev Need this to prevent stack too deep    */   function _handleExecuteTransaction(     ExecuteArgs calldata _args,     uint256 _amount,     address _asset, // adopted (or local if specified)     bytes32 _transferId,     bool _reconciled   ) private returns (uint256) {     // If the domain if sponsored     if (address(s.sponsorVault) != address(0)) {       // fast liquidity path       if (!_reconciled) {         // Vault will return the amount of the fee they sponsored in the native fee         // NOTE: some considerations here around fee on transfer tokens and ensuring         // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a         // balance read about it          uint256 starting = IERC20(_asset).balanceOf(address(this));         uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);          // Validate correct amounts are transferred         if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {           revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();         }          _amount = _amount + sponsored;       }        // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee       // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),       // then the vault should just pay out the configured constant       s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);     }     ..SNIP.. ```  ## Impact  It will result in denial of service. The `SponsorVault` contract, which belongs to a third-party, is a single point of failure for a domain.  ## Recommended Mitigation Steps  This is a problem commonly encountered whenever a method of a smart contract calls another contract – we cannot rely on the other contract to work 100% of the time, and it is dangerous to assume that the external call will always be successful. Additionally, external smart contract might be vulnerable and compromised by an attacker. Even if the team has audited or review the SponsorVault before whitelisting them, some risk might still exist.  Therefore, it is recommended to implement a fail-safe design where failure of an external call to SponsorVault will not disrupt the cross-chain communication. Consider implementing a try-catch block as shown below. If there is any issue with the external `SponsorVault ` contract, no funds are reimbursed to the users in the worst case scenario, but the issue will not cause any impact to the cross-chain communication.  ```diff function _handleExecuteTransaction(  ExecuteArgs calldata _args,  uint256 _amount,  address _asset, // adopted (or local if specified)  bytes32 _transferId,  bool _reconciled ) private returns (uint256) {  // If the domain if sponsored  if (address(s.sponsorVault) != address(0)) {    // fast liquidity path    if (!_reconciled) {   // Vault will return the amount of the fee they sponsored in the native fee   // NOTE: some considerations here around fee on transfer tokens and ensuring   // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a   // balance read about it    uint256 starting = IERC20(_asset).balanceOf(address(this)); +  try s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to) returns (uint256 sponsored) { +   // Validate correct amounts are transferred +   if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) { +     revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount(); +   } + +   _amount = _amount + sponsored; +  } catch {}    }     // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee    // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),    // then the vault should just pay out the configured constant +   try s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee) {} catch {}  ..SNIP.. ```  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411   # Vulnerability details  ## Proof-of-Concept  > This issue is only applicable for fast-transfer. Slow transfer would not have this issue because of the built-in fraud-proof mechanism in Nomad.  First, the attacker will attempt to use Connext to send `1000 USDC` from Ethereum domain to Optimism domain.  Assume that the attacker happens to be a relayer on the relayer network utilised by Connext, and the attacker's relayer happens to be tasked to relay the above execute calldata to the Optimism's Connext [`BridgeFacet.execute`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411) function.  Optimism's Connext `BridgeFacet.execute` received the execute calldata and observed within the calldata that it is a fast-transfer and Router A is responsible for providing the liquidity. It will then check that the router signature is valid, and proceed to transfer `1000 oUSDC` to attacker wallet (0x123456) in Optimism.  Next, attacker will update the `ExecuteArgs.local` within the execute calldata to a valid local representation of canonical token (USDC) used within Polygon. Attacker will then send the modified execute calldata to Polygon's Connext `BridgeFacet.execute` function. Assume that the same Router A is also providing liquidity in Polygon. The `BridgeFacet.execute` function checks that the router signature is valid, and proceed to transfer `1000 POS-USDC` to atttack wallet (0x123456) in Polygon.   At this point, the attacker has `1000 oUSDC` and `1000 POS-USDC` in his wallets. When the nomad message arrives at Optimism, Router A can claim the `1000 oUSDC` back from Connext. However, Router A is not able to claim back any fund in Polygon.  Note that same wallet address exists on different chains. For instance, the wallet address on Etherum and Polygon is the same.  ### Why changing the `ExecuteArgs.local` does not affect the router signature verification?  This is because the router signature is generated from the `transferId` + `pathLength` only, and these data are stored within the `CallParams params` within the `ExecuteArgs` struct.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L77](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L77)  ```solidity struct ExecuteArgs {   CallParams params;   address local; // local representation of canonical token   address[] routers;   bytes[] routerSignatures;   uint256 amount;   uint256 nonce;   address originSender; } ```  Within the [`BridgeFacet._executeSanityChecks`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411) function, it will attempt to rebuild to `transferId` by calling the following code:  ```solidity // Derive transfer ID based on given arguments. bytes32 transferId = _getTransferId(_args); ```  Within the [`BridgeFacet._getTransferId`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719) function, we can see that the `s.tokenRegistry.getTokenId(_args.local)` will always return the canonical `tokenDomain` and `tokenId`. In our example, it will be `Ethereum` and  `USDC`. Therefore, as long as the attacker specify a valid local representation of canonical token on a chain, the `transferId` returned by `s.tokenRegistry.getTokenId(_args.local)` will always be the same across all domains. Thus, this allows the attacker to modify the `ExecuteArgs.local` and yet he could pass the router signature check.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719)  ```solidity   function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {     (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);     return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);   } ```  ## Impact   Router liquidity would be drained by attacker, and affected router owner could not claim back their liquidity.  ## Recommended Mitigation Steps  The security of the current Connext design depends on how secure or reliable the relayer is. If the relayer turns rouge or act against Connext, many serious consequences can happen.  The root cause is that the current design places enormous trust on the relayers to accurately and reliably to deliver calldata to the bridge in various domains. For instance, delivering of execute call data to `execute` function. There is an attempt to prevent message replay on a single domain, however, it does not prevent message replay across multiple domains. Most importantly, the Connext's bridge appears to have full trust on the calldata delivered by the relayer. However, the fact is that the calldata can always be altered by the relayer.  Consider a classic 0x off-chain ordering book protocol. A user will sign his order with his private key, and attach the signature to the order, and send the order (with signature) to the relayer network. If the relayer attempts to tamper the order message or signature, the decoded address will be different from the signer's address and this will be detected by 0x's Smart contract on-chain when processing the order. This ensures that the integrity of the message and signer can be enforced.  Per good security practice, relayer network should always be considered as a hostile environment/network. Therefore, it is recommended that similar approach could be taken with regards to passing execute calldata across domains/chains.  For instance, at a high level, the sequencer should sign the execute calldata with its private key, and attach the signature to the execute calldata. Then, submit the execute calldata (with signature) to the relayer network. When the bridge receives the execute calldata (with signature), it can verify if the decoded address matches the sequencer address to ensure that the calldata has not been altered. This will ensure the intergrity of the execute calldata and prevent any issue that arise due to unauthorised modification of calldata.  Additionally, the execute calldata should also have a field that correspond to the destination domain. The bridge that receives the execute calldata must verify that the execute calldata is intended for its domain, otherwise reject the calldata if it belongs to other domains. This also helps to prevent the attack mentioned earlier where same execute calldata can be accepted in different domains.  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80    # Vulnerability details  ## Impact  When repaying the AAVE Portal in [`repayAavePortal()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80) the `_local` asset is used to repay the loan in `_backLoan()` rather than the `adopted` asset. This is likely to cause issues in production when actually repaying loans if the asset/token being repayed to AAVE is not the same as the asset/token that was borrowed.  ## Proof of Concept The comment on [`L93`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L93) of [`PortalFacet.sol`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol) states;  ``` // Need to swap into adopted asset or asset that was backing the loan // The router will always be holding collateral in the local asset while the loaned asset // is the adopted asset ```  The swap is executed on [`L98`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L98) in the call to `AssetLogic.swapFromLocalAssetIfNeededForExactOut()` however the return value `adopted` is never used (it's an unused local variable). The full function is shown below;  ``` // Swap for exact `totalRepayAmount` of adopted asset to repay aave (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(   _local,   totalAmount,   _maxIn );  if (!success) revert PortalFacet__repayAavePortal_swapFailed();  // decrement router balances unchecked {   s.routerBalances[msg.sender][_local] -= amountIn; }  // back loan _backLoan(_local, _backingAmount, _feeAmount, _transferId); ``` The balance of the `_local` token is reduced but instead of the `adopted` token being passed to [`_backLoan()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L112) in L112 the `_local` token is used. ## Tools Used Vim  ## Recommended Mitigation Steps To be consistent with the comments in the [`repayAavePortal()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80) function `adopted` should be passed to `_backLoan` so that the loan is repayed in the appropriate token.  Remove the reference to `_local` in the [`_backLoan()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L112) function and replace it with `adopted` so it reads;  `_backLoan(adopted, _backingAmount, _feeAmount, _transferId);`  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/AssetFacet.sol#L100   # Vulnerability details  ## Issue  1. Admin can call setWrapper function to setup a new wrapper Y instead of old wrapper X  2. This becomes a problem for any old asset which was setup during setupAsset call where s.canonicalToAdopted[_canonical.id]  will still point to old wrapper X instead of Y  ## Recommendation If wrapper is changed then all variables storing this wrapper should also update  
# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80-L113   # Vulnerability details  ## Impact The caller of `repayAavePortal()` can trigger an underflow to arbitrarily increase the caller's balance through an underflow.  ## Proof of Concept ```sol // Relevant code sections:  // PortalFacet.sol   function repayAavePortal(     address _local,     uint256 _backingAmount,     uint256 _feeAmount,     uint256 _maxIn,     bytes32 _transferId   ) external {     uint256 totalAmount = _backingAmount + _feeAmount; // in adopted     uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local      // Sanity check: has that much to spend     if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();      // Need to swap into adopted asset or asset that was backing the loan     // The router will always be holding collateral in the local asset while the loaned asset     // is the adopted asset      // Swap for exact `totalRepayAmount` of adopted asset to repay aave     (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(       _local,       totalAmount,       _maxIn     );      if (!success) revert PortalFacet__repayAavePortal_swapFailed();      // decrement router balances     unchecked {       s.routerBalances[msg.sender][_local] -= amountIn;     }      // back loan     _backLoan(_local, _backingAmount, _feeAmount, _transferId);   }  // AssetLogic.sol   function swapFromLocalAssetIfNeededForExactOut(     address _asset,     uint256 _amount,     uint256 _maxIn   )     internal     returns (       bool,       uint256,       address     )   {     AppStorage storage s = LibConnextStorage.connextStorage();      // Get the token id     (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);      // If the adopted asset is the local asset, no need to swap     address adopted = s.canonicalToAdopted[id];     if (adopted == _asset) {       return (true, _amount, _asset);     }      return _swapAssetOut(id, _asset, adopted, _amount, _maxIn);   } ``` First, call `repayAavePortal()` where `_backingAmount + _feeAmount > s.routerBalances[msg.sender][_local] && _maxIn > s.routerBalances[msg.sender][_local]`. That will trigger the call to the AssetLogic contract: ```sol     (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(       _local,       totalAmount,       _maxIn     ); ``` By setting `_local` to the same value as the adopted asset, you trigger the following edge case: ```sol     address adopted = s.canonicalToAdopted[id];     if (adopted == _asset) {       return (true, _amount, _asset);     } ``` So the `amountIn` value returned by `swapFromLocalAssetIfNeededForExactOut()` is the `totalAmount` value that was passed to it. And `totalAmount == _backingAmount + _feeAmount`.  Meaning the `amountIn` value is user-specified for this edge case. Finally, we reach the following line: ```sol     unchecked {       s.routerBalances[msg.sender][_local] -= amountIn;     } ``` `amountIn` (user-specified) is subtracted from the `routerBalances` in an `unchecked` block. Thus, the attacker is able to trigger an underflow and increase their balance arbitrarily high. The `repayAavePortal()` function only verifies that `routerBalance < _maxIn`.  Here's a test as PoC: ```sol // PortalFacet.t.sol    function test_PortalFacet_underflow() public {     s.routerPermissionInfo.approvedForPortalRouters[router] = true;      uint backing = 2 ether;     uint fee = 10000;     uint init = 1 ether;      s.routerBalances[router][_local] = init;     s.portalDebt[_id] = backing;     s.portalFeeDebt[_id] = fee;      vm.mockCall(s.aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector), abi.encode(true));     vm.prank(router);     this.repayAavePortal(_local, backing, fee, init - 0.5 ether, _id);      // balance > init => underflow     require(s.routerBalances[router][_local] > init);   } ``` ## Tools Used none  ## Recommended Mitigation Steps After the call to `swapFromLocalAssetIfNeededForExactOut()` you should add the following check: ```sol if (_local == adopted) {   require(routerBalance >= amountIn); } ```  
# Equality check with different uint sizes can cause failures   # Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/BridgeFacet.sol#L283 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L146 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L41   # Vulnerability details  ## Impact In `BridgeFacet.sol` the `xcall()` function checks if `_args.params.originDomain != s.domain` and it will revert if these are not equal. The problem is that the `originDomain` is a `uint32` and the `s.domain` is a `uint256`.  This means that if the `s.domain` number is ever larger than the max value for a uint32 value,  this function will fail every time because the `originDomain` could never reach a large enough number.   ## Proof of Concept https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/BridgeFacet.sol#L283  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L146  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L41  ## Tools Used Manual code review   ## Recommended Mitigation Steps The `_args.params.originDomain` and the `s.domain` should both be the same uint type.  They both should be either a uint32 or uint256 to avoid any possible failures due to numbers not being large enough.   
# Oracle price from DEX can be manipulated  # Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99   # Vulnerability details  ## Impact The [`ConnextPriceOracle.getPriceFromDex`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99) function divides the balances of the two token pairs to compute the price. There are several issues with it:  1. This only returns the *spot price* which can easily be manipulated through flash loans. This is okay if the price oracle contract is only used off-chain 2. It only works with specific AMMs like Uniswap that keep both balances in the contract. Also, any fees that are in the contract are used as part of the price computation but they should not. 3. It uses the balance instead of the `reserve` data. For many Uniswap-like AMMs, the balance can be manipulated by sending tokens directly to the contract, and then reclaimed later through a `skim`. The reserve should be used instead.  #### POC - Attacker sends a large amount of base tokens to a Uniswap V2 pool. - The `getPriceFromDex` computes the `token` price as `baseBalance` denominated in `token` / `tokenBalance`. As the `baseBalance` is increased, the `tokenPrice` is increased as well. - Attacker calls `skim` on the pool to get back their balance.  ## Recommended Mitigation Steps The price from DEX function is not suited for any on-chain queries. For off-chain queries it can also be manipulated as it uses `balance` instead of reserves - which can be claimed back at a future block although this comes with risk.  
# Double Initialize on Diamond Init  # Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/upgrade-initializers/DiamondInit.sol#L36   # Vulnerability details  ## Impact An attacker could Double Initialize the Diamond Init contract due to unsafe checks.  ## Proof of Concept 1. Clone the Contest Repo. 2. Start Remixd and go to Remix website and connect with local host 3. Open DiamondInit contract. 4. Compile it and call the init function multiple times with different arguments and accounts.  ## Tools Used Remixd and Remix  ## Root Cause  There is no Standard Initializer modifier on init function. It seems the contract sets the `s.initalized = true` but this cannot be a valid check because I was able to call it multiple times on testing.  ## Recommended Mitigation Steps Use Initializer modifier on Openzepplin library.  
