# Handle  pauliax   # Vulnerability details  ## Impact function transferTo allows transferring amount from beneficiary to any address. However, 'to' is considered valid when it does not have an amount locked yet: ```solidity  function transferTo(address to, uint amount) external  ...    require(releaseVars[to].amount == 0, 'to is exist');  ``` It locks this amount for releaseVars[beneficiary].endTime. Because the blockchain is public, a malicious actor could monitor the mempool, and crash any attempt of transferTo by frontrunning it and calling transferTo with the smallest fraction (dust) from his own address to the 'to' address, making it unavailable to receive new locks for some time (even 4 years is possible?).  ## Recommended Mitigation Steps A few possible solutions would be to introduce a reasonable minimum amount to transfer or add a 2-step approval, where 'to' first have to approve the beneficiary.  
# Handle  gzeon   # Vulnerability details  ## Impact `transfer()` only forward 2300 gas which may break when gas cost change in a future ETH upgrade see: https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253 ```             payable(to).transfer(amount); ```  ## Recommended Mitigation Steps use call() instead  
# Handle  csanuragjain   # Vulnerability details  ## Impact User funds can be lost if Admin sets startTimes[i] to 0  ## Proof of Concept  1. Navigate to contract https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol  2. Check the initDistributions function  ``` function initDistributions(address[] memory stakeTokens, uint64[] memory startTimes, uint64[] memory durations) external onlyAdmin {         for (uint256 i = 0; i < stakeTokens.length; i++) {             require(distributions[stakeTokens[i]].starttime == 0, 'Init once');             distributions[stakeTokens[i]] = Distribution(durations[i], startTimes[i], 0, 0, 0, 0, 0);         }     } ```  3. Assume Admin calls this for token X with startTimes[i] as 0. This creates a new distribution with start time as 0 for token X  4. User Y stakes amount 500 for this token X  5. Admin calls initDistributions again with token X and startTimes[i] as 1000. This overwrites and reinitializes distributions[X] which means totalStaked becomes 0 and contract has lost all track of user funds now  ## Recommended Mitigation Steps Add a check to see startTimes[i]!=0 in initDistributions function  
# Handle  WatchPug   # Vulnerability details  The library `ReentrancyGuard` is imported and inherited, but the modifier `nonReentrant` is unused.  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/liquidity/LPoolDepositor.sol#L14-L14  ```solidity contract LPoolDepositor is ReentrancyGuard { ```  ### Recommendation  Remove the import and change to:  ```solidity contract LPoolDepositor { ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L31-L56  ```solidity function uniClassSell(DexInfo memory dexInfo,     address buyToken,     address sellToken,     uint sellAmount,     uint minBuyAmount,     address payer,     address payee ) internal returns (uint buyAmount){     address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);     IUniswapV2Pair(pair).sync();     (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();     sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);     uint balanceBefore = IERC20(buyToken).balanceOf(payee);     dexInfo.fees = getPairFees(dexInfo, pair);     if (buyToken < sellToken) {         buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(buyAmount, 0, payee, "");     } else {         buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(0, buyAmount, payee, "");     }      require(buyAmount >= minBuyAmount, 'buy amount less than min');     uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);     return bought; } ```  While `uniClassBuy()` correctly checks the actually received amount by comparing the before and after the balance of the receiver, `uniClassSell()` trusted the result given by `getAmountOut()`. This makes `uniClassSell()` can result in an output amount fewer than `minBuyAmount`.  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L101-L102  ### Recommendation  Change to:  ```solidity function uniClassSell(DexInfo memory dexInfo,     address buyToken,     address sellToken,     uint sellAmount,     uint minBuyAmount,     address payer,     address payee ) internal returns (uint bought){     address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);     IUniswapV2Pair(pair).sync();     (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();     sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);     uint balanceBefore = IERC20(buyToken).balanceOf(payee);     dexInfo.fees = getPairFees(dexInfo, pair);     if (buyToken < sellToken) {         buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(buyAmount, 0, payee, "");     } else {         buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(0, buyAmount, payee, "");     }     uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);     require(bought >= minBuyAmount, 'buy amount less than min'); } ```  
# Handle  samruna   # Vulnerability details  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OLETokenLock.sol#L66  In the above code, there is no check to see if endTime is before startTime. Due to this past beneficiaries can be transferred additional tokens  Action: check if endTime if always in future.  
# Handle  Dravee   # Vulnerability details  ## Impact   Increased gas cost, as a variable of type `uint` will always be `>= 0`, therefore the check isn't necessary.    ## Proof of Concept   ``` contracts\XOLE.sol:327:        require(_locked.amount >= 0, "Nothing to withdraw"); ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Delete the `>= 0` check  
# Handle  hyh   # Vulnerability details  ## Impact  The amount that OpenLevV1 will receive can be less than V3 DEX indicated as a swap result, while it is used as given for position debt repayment accounting.  This way actual funds received can be less than accounted, leaving to system funds deficit, which can be exploited by a malicious user, draining contract funds with multiple open/close with a taxed token.  In the `trade.depositToken != longToken` case when `flashSell` is used this can imply inability to send remainder funds to a user and the failure of the whole closeTrade function, the end result is a freezing of user's funds within the system.  ## Proof of Concept  `trade.depositToken != longToken` case, can be wrong repayment accounting, which will lead to a deficit if the received funds are less than DEX returned `closeTradeVars.receiveAmount`.  As a side effect, `doTransferOut` is done without balance check, so the whole position close can revert, leading to inability to close the position and freeze of user's funds this way:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L197-204   I.e. if there is enough funds in the system they will be drained, if there is not enough funds, user's position close will fail.   V3 sell function doesn't check for balance change, using DEX returned amount as is:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/eth/UniV3Dex.sol#L61-70  ## Recommended Mitigation Steps  If fee on tranfer tokens are fully in scope, do control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic as well.  
# Handle  GeekyLumberjack   # Vulnerability details  ## Impact [transferTokens()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L95-L135) will not fail when calling [transferAllowed()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/ControllerV1.sol#L88-L91) both [transfer()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L141) and [transferFrom()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L150) rely on transferTokens(). Both the name of the function transferAllowed() and the [comments](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L99) above the call show there should be some cases that cause these functions to fail in transferAllowed.   ## Tools Used Manual review  ## Recommended Mitigation Steps Update transfer allowed to include required failures. If there are none, update the comments and the name of the function.  
# Handle  hyh   # Vulnerability details   ## Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. System then will fail with low level array access message  ## Proof of Concept  notifyRewardAmounts:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol#L163   initDistributions:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol#L131  ## Recommended Mitigation Steps  Require that (stakeTokens, reward) and (stakeTokens, startTimes, durations) arrays' lengths match within each set   
# Handle  hyh   # Vulnerability details  ## Impact  When OpenLev operations use a wrapped native token, the whole user withdraw is being handled with a `payable.transfer()` call.  This is unsafe as `transfer` has hard coded gas budget and can fail when the user is a smart contract. This way any programmatical usage of OpenLevV1 and LPool is at risk.  Whenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time.  As OpenLevV1 `closeTrade` is affected this includes user's principal funds freeze scenario, so marking the issue as a high severity one.  ## Proof of Concept  OpenLevV1Lib and LPool have `doTransferOut` function that calls native token payable.transfer:  OpenLevV1Lib.doTransferOut  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253   LPool.doTransferOut  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L297   LPool.doTransferOut is used in LPool redeem and borrow, while OpenLevV1Lib.doTransferOut is used in OpenLevV1 trade manipulation logic:  closeTrade  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L204  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L215   liquidate  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L263  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L295  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L304   ## References  The issues with `transfer()` are outlined here:  https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/   ## Recommended Mitigation Steps  OpenLevV1's `closeTrade` and `liquidate` as well as LPool's `redeem`, `redeemUnderlying`, `borrowBehalf`, `repayBorrowBehalf`, `repayBorrowEndByOpenLev` are all `nonReentrant`, so reentrancy isn't an issue and `transfer()` can be just replaced.  Using low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60  
# Handle  rfa   # Vulnerability details  ## Impact expensive gas ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/bsc/BscDexAggregatorV1.sol#L47   ## Recommended Mitigation Steps replace the 2 lines of code by just 1 line: ``` dexInfo[dexName[i]] = DexInfo(factoryAddr[i], fees[i]); ```  
# Handle  cccz   # Vulnerability details  ## Impact The current ownership transfer process involves the current owner calling transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner’s address into the owner’s state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier.  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/Airdrop.sol#L9  ## Tools Used  None  ## Recommended Mitigation Steps  Implement zero address check and consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.   
# Handle  robee   # Vulnerability details  The following functions are not payable but uses msg.value - therefore the function must be payable. This can lead to undesired behavior.          LPool.sol, addReserves should be payable since using msg.value   
# Handle  jayjonah8   # Vulnerability details  ## Impact In ControllerV1.sol in the updatePriceAllowed() function tx.origin is used.  tx.origin is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable could make a contract vulnerable if an authorized account calls into a malicious contract.  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/ControllerV1.sol#L163  https://swcregistry.io/docs/SWC-115  ## Tools Used Manual code review   ## Recommended Mitigation Steps Its recommended to use msg.sender instead  
# Handle  jayjonah8   # Vulnerability details  ## Impact In OLETokenLock.sol,  the release() function distributes all the allotted tokens to the beneficiaries but it can be called by anyone.  This should be an admin protected function as it's very important and deals with the transfer of tokens to beneficiaries which should not be accessed by simply anyone.   ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OLETokenLock.sol#L39  ## Tools Used Manual code review   ## Recommended Mitigation Steps OLETokenLock.sol should inherit the Adminable.sol contract and add require(msg.sender = admin, "Not Authorized"); to the release() function.   
# Handle  mics   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          FarmingPools.sol : reachable assert in line 77         XOLE.sol : reachable assert in line 303   
# Handle  pauliax   # Vulnerability details  ## Impact function transferTo allows transferring amount from beneficiary to any address. However, 'to' is considered valid when it does not have an amount locked yet: ```solidity  function transferTo(address to, uint amount) external  ...    require(releaseVars[to].amount == 0, 'to is exist');  ``` It locks this amount for releaseVars[beneficiary].endTime. Because the blockchain is public, a malicious actor could monitor the mempool, and crash any attempt of transferTo by frontrunning it and calling transferTo with the smallest fraction (dust) from his own address to the 'to' address, making it unavailable to receive new locks for some time (even 4 years is possible?).  ## Recommended Mitigation Steps A few possible solutions would be to introduce a reasonable minimum amount to transfer or add a 2-step approval, where 'to' first have to approve the beneficiary.  
# Handle  gzeon   # Vulnerability details  ## Impact `transfer()` only forward 2300 gas which may break when gas cost change in a future ETH upgrade see: https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253 ```             payable(to).transfer(amount); ```  ## Recommended Mitigation Steps use call() instead  
# Handle  csanuragjain   # Vulnerability details  ## Impact User funds can be lost if Admin sets startTimes[i] to 0  ## Proof of Concept  1. Navigate to contract https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol  2. Check the initDistributions function  ``` function initDistributions(address[] memory stakeTokens, uint64[] memory startTimes, uint64[] memory durations) external onlyAdmin {         for (uint256 i = 0; i < stakeTokens.length; i++) {             require(distributions[stakeTokens[i]].starttime == 0, 'Init once');             distributions[stakeTokens[i]] = Distribution(durations[i], startTimes[i], 0, 0, 0, 0, 0);         }     } ```  3. Assume Admin calls this for token X with startTimes[i] as 0. This creates a new distribution with start time as 0 for token X  4. User Y stakes amount 500 for this token X  5. Admin calls initDistributions again with token X and startTimes[i] as 1000. This overwrites and reinitializes distributions[X] which means totalStaked becomes 0 and contract has lost all track of user funds now  ## Recommended Mitigation Steps Add a check to see startTimes[i]!=0 in initDistributions function  
# Handle  WatchPug   # Vulnerability details  The library `ReentrancyGuard` is imported and inherited, but the modifier `nonReentrant` is unused.  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/liquidity/LPoolDepositor.sol#L14-L14  ```solidity contract LPoolDepositor is ReentrancyGuard { ```  ### Recommendation  Remove the import and change to:  ```solidity contract LPoolDepositor { ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L31-L56  ```solidity function uniClassSell(DexInfo memory dexInfo,     address buyToken,     address sellToken,     uint sellAmount,     uint minBuyAmount,     address payer,     address payee ) internal returns (uint buyAmount){     address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);     IUniswapV2Pair(pair).sync();     (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();     sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);     uint balanceBefore = IERC20(buyToken).balanceOf(payee);     dexInfo.fees = getPairFees(dexInfo, pair);     if (buyToken < sellToken) {         buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(buyAmount, 0, payee, "");     } else {         buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(0, buyAmount, payee, "");     }      require(buyAmount >= minBuyAmount, 'buy amount less than min');     uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);     return bought; } ```  While `uniClassBuy()` correctly checks the actually received amount by comparing the before and after the balance of the receiver, `uniClassSell()` trusted the result given by `getAmountOut()`. This makes `uniClassSell()` can result in an output amount fewer than `minBuyAmount`.  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L101-L102  ### Recommendation  Change to:  ```solidity function uniClassSell(DexInfo memory dexInfo,     address buyToken,     address sellToken,     uint sellAmount,     uint minBuyAmount,     address payer,     address payee ) internal returns (uint bought){     address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);     IUniswapV2Pair(pair).sync();     (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();     sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);     uint balanceBefore = IERC20(buyToken).balanceOf(payee);     dexInfo.fees = getPairFees(dexInfo, pair);     if (buyToken < sellToken) {         buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(buyAmount, 0, payee, "");     } else {         buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(0, buyAmount, payee, "");     }     uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);     require(bought >= minBuyAmount, 'buy amount less than min'); } ```  
# Handle  samruna   # Vulnerability details  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OLETokenLock.sol#L66  In the above code, there is no check to see if endTime is before startTime. Due to this past beneficiaries can be transferred additional tokens  Action: check if endTime if always in future.  
# Handle  Dravee   # Vulnerability details  ## Impact   Increased gas cost, as a variable of type `uint` will always be `>= 0`, therefore the check isn't necessary.    ## Proof of Concept   ``` contracts\XOLE.sol:327:        require(_locked.amount >= 0, "Nothing to withdraw"); ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Delete the `>= 0` check  
# Handle  hyh   # Vulnerability details  ## Impact  The amount that OpenLevV1 will receive can be less than V3 DEX indicated as a swap result, while it is used as given for position debt repayment accounting.  This way actual funds received can be less than accounted, leaving to system funds deficit, which can be exploited by a malicious user, draining contract funds with multiple open/close with a taxed token.  In the `trade.depositToken != longToken` case when `flashSell` is used this can imply inability to send remainder funds to a user and the failure of the whole closeTrade function, the end result is a freezing of user's funds within the system.  ## Proof of Concept  `trade.depositToken != longToken` case, can be wrong repayment accounting, which will lead to a deficit if the received funds are less than DEX returned `closeTradeVars.receiveAmount`.  As a side effect, `doTransferOut` is done without balance check, so the whole position close can revert, leading to inability to close the position and freeze of user's funds this way:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L197-204   I.e. if there is enough funds in the system they will be drained, if there is not enough funds, user's position close will fail.   V3 sell function doesn't check for balance change, using DEX returned amount as is:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/eth/UniV3Dex.sol#L61-70  ## Recommended Mitigation Steps  If fee on tranfer tokens are fully in scope, do control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic as well.  
# Handle  GeekyLumberjack   # Vulnerability details  ## Impact [transferTokens()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L95-L135) will not fail when calling [transferAllowed()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/ControllerV1.sol#L88-L91) both [transfer()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L141) and [transferFrom()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L150) rely on transferTokens(). Both the name of the function transferAllowed() and the [comments](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L99) above the call show there should be some cases that cause these functions to fail in transferAllowed.   ## Tools Used Manual review  ## Recommended Mitigation Steps Update transfer allowed to include required failures. If there are none, update the comments and the name of the function.  
# Handle  hyh   # Vulnerability details   ## Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. System then will fail with low level array access message  ## Proof of Concept  notifyRewardAmounts:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol#L163   initDistributions:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol#L131  ## Recommended Mitigation Steps  Require that (stakeTokens, reward) and (stakeTokens, startTimes, durations) arrays' lengths match within each set   
# Handle  hyh   # Vulnerability details  ## Impact  When OpenLev operations use a wrapped native token, the whole user withdraw is being handled with a `payable.transfer()` call.  This is unsafe as `transfer` has hard coded gas budget and can fail when the user is a smart contract. This way any programmatical usage of OpenLevV1 and LPool is at risk.  Whenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time.  As OpenLevV1 `closeTrade` is affected this includes user's principal funds freeze scenario, so marking the issue as a high severity one.  ## Proof of Concept  OpenLevV1Lib and LPool have `doTransferOut` function that calls native token payable.transfer:  OpenLevV1Lib.doTransferOut  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253   LPool.doTransferOut  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L297   LPool.doTransferOut is used in LPool redeem and borrow, while OpenLevV1Lib.doTransferOut is used in OpenLevV1 trade manipulation logic:  closeTrade  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L204  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L215   liquidate  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L263  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L295  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L304   ## References  The issues with `transfer()` are outlined here:  https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/   ## Recommended Mitigation Steps  OpenLevV1's `closeTrade` and `liquidate` as well as LPool's `redeem`, `redeemUnderlying`, `borrowBehalf`, `repayBorrowBehalf`, `repayBorrowEndByOpenLev` are all `nonReentrant`, so reentrancy isn't an issue and `transfer()` can be just replaced.  Using low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60  
# Handle  rfa   # Vulnerability details  ## Impact expensive gas ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/bsc/BscDexAggregatorV1.sol#L47   ## Recommended Mitigation Steps replace the 2 lines of code by just 1 line: ``` dexInfo[dexName[i]] = DexInfo(factoryAddr[i], fees[i]); ```  
# Handle  cccz   # Vulnerability details  ## Impact The current ownership transfer process involves the current owner calling transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner’s address into the owner’s state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier.  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/Airdrop.sol#L9  ## Tools Used  None  ## Recommended Mitigation Steps  Implement zero address check and consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.   
# Handle  robee   # Vulnerability details  The following functions are not payable but uses msg.value - therefore the function must be payable. This can lead to undesired behavior.          LPool.sol, addReserves should be payable since using msg.value   
# Handle  jayjonah8   # Vulnerability details  ## Impact In ControllerV1.sol in the updatePriceAllowed() function tx.origin is used.  tx.origin is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable could make a contract vulnerable if an authorized account calls into a malicious contract.  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/ControllerV1.sol#L163  https://swcregistry.io/docs/SWC-115  ## Tools Used Manual code review   ## Recommended Mitigation Steps Its recommended to use msg.sender instead  
# Handle  jayjonah8   # Vulnerability details  ## Impact In OLETokenLock.sol,  the release() function distributes all the allotted tokens to the beneficiaries but it can be called by anyone.  This should be an admin protected function as it's very important and deals with the transfer of tokens to beneficiaries which should not be accessed by simply anyone.   ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OLETokenLock.sol#L39  ## Tools Used Manual code review   ## Recommended Mitigation Steps OLETokenLock.sol should inherit the Adminable.sol contract and add require(msg.sender = admin, "Not Authorized"); to the release() function.   
# Handle  mics   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          FarmingPools.sol : reachable assert in line 77         XOLE.sol : reachable assert in line 303   
# Handle  pauliax   # Vulnerability details  ## Impact function transferTo allows transferring amount from beneficiary to any address. However, 'to' is considered valid when it does not have an amount locked yet: ```solidity  function transferTo(address to, uint amount) external  ...    require(releaseVars[to].amount == 0, 'to is exist');  ``` It locks this amount for releaseVars[beneficiary].endTime. Because the blockchain is public, a malicious actor could monitor the mempool, and crash any attempt of transferTo by frontrunning it and calling transferTo with the smallest fraction (dust) from his own address to the 'to' address, making it unavailable to receive new locks for some time (even 4 years is possible?).  ## Recommended Mitigation Steps A few possible solutions would be to introduce a reasonable minimum amount to transfer or add a 2-step approval, where 'to' first have to approve the beneficiary.  
# Handle  gzeon   # Vulnerability details  ## Impact `transfer()` only forward 2300 gas which may break when gas cost change in a future ETH upgrade see: https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253 ```             payable(to).transfer(amount); ```  ## Recommended Mitigation Steps use call() instead  
# Handle  csanuragjain   # Vulnerability details  ## Impact User funds can be lost if Admin sets startTimes[i] to 0  ## Proof of Concept  1. Navigate to contract https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol  2. Check the initDistributions function  ``` function initDistributions(address[] memory stakeTokens, uint64[] memory startTimes, uint64[] memory durations) external onlyAdmin {         for (uint256 i = 0; i < stakeTokens.length; i++) {             require(distributions[stakeTokens[i]].starttime == 0, 'Init once');             distributions[stakeTokens[i]] = Distribution(durations[i], startTimes[i], 0, 0, 0, 0, 0);         }     } ```  3. Assume Admin calls this for token X with startTimes[i] as 0. This creates a new distribution with start time as 0 for token X  4. User Y stakes amount 500 for this token X  5. Admin calls initDistributions again with token X and startTimes[i] as 1000. This overwrites and reinitializes distributions[X] which means totalStaked becomes 0 and contract has lost all track of user funds now  ## Recommended Mitigation Steps Add a check to see startTimes[i]!=0 in initDistributions function  
# Handle  WatchPug   # Vulnerability details  The library `ReentrancyGuard` is imported and inherited, but the modifier `nonReentrant` is unused.  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/liquidity/LPoolDepositor.sol#L14-L14  ```solidity contract LPoolDepositor is ReentrancyGuard { ```  ### Recommendation  Remove the import and change to:  ```solidity contract LPoolDepositor { ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L31-L56  ```solidity function uniClassSell(DexInfo memory dexInfo,     address buyToken,     address sellToken,     uint sellAmount,     uint minBuyAmount,     address payer,     address payee ) internal returns (uint buyAmount){     address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);     IUniswapV2Pair(pair).sync();     (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();     sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);     uint balanceBefore = IERC20(buyToken).balanceOf(payee);     dexInfo.fees = getPairFees(dexInfo, pair);     if (buyToken < sellToken) {         buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(buyAmount, 0, payee, "");     } else {         buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(0, buyAmount, payee, "");     }      require(buyAmount >= minBuyAmount, 'buy amount less than min');     uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);     return bought; } ```  While `uniClassBuy()` correctly checks the actually received amount by comparing the before and after the balance of the receiver, `uniClassSell()` trusted the result given by `getAmountOut()`. This makes `uniClassSell()` can result in an output amount fewer than `minBuyAmount`.  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L101-L102  ### Recommendation  Change to:  ```solidity function uniClassSell(DexInfo memory dexInfo,     address buyToken,     address sellToken,     uint sellAmount,     uint minBuyAmount,     address payer,     address payee ) internal returns (uint bought){     address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);     IUniswapV2Pair(pair).sync();     (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();     sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);     uint balanceBefore = IERC20(buyToken).balanceOf(payee);     dexInfo.fees = getPairFees(dexInfo, pair);     if (buyToken < sellToken) {         buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(buyAmount, 0, payee, "");     } else {         buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(0, buyAmount, payee, "");     }     uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);     require(bought >= minBuyAmount, 'buy amount less than min'); } ```  
# Handle  samruna   # Vulnerability details  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OLETokenLock.sol#L66  In the above code, there is no check to see if endTime is before startTime. Due to this past beneficiaries can be transferred additional tokens  Action: check if endTime if always in future.  
# Handle  Dravee   # Vulnerability details  ## Impact   Increased gas cost, as a variable of type `uint` will always be `>= 0`, therefore the check isn't necessary.    ## Proof of Concept   ``` contracts\XOLE.sol:327:        require(_locked.amount >= 0, "Nothing to withdraw"); ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Delete the `>= 0` check  
# Handle  hyh   # Vulnerability details  ## Impact  The amount that OpenLevV1 will receive can be less than V3 DEX indicated as a swap result, while it is used as given for position debt repayment accounting.  This way actual funds received can be less than accounted, leaving to system funds deficit, which can be exploited by a malicious user, draining contract funds with multiple open/close with a taxed token.  In the `trade.depositToken != longToken` case when `flashSell` is used this can imply inability to send remainder funds to a user and the failure of the whole closeTrade function, the end result is a freezing of user's funds within the system.  ## Proof of Concept  `trade.depositToken != longToken` case, can be wrong repayment accounting, which will lead to a deficit if the received funds are less than DEX returned `closeTradeVars.receiveAmount`.  As a side effect, `doTransferOut` is done without balance check, so the whole position close can revert, leading to inability to close the position and freeze of user's funds this way:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L197-204   I.e. if there is enough funds in the system they will be drained, if there is not enough funds, user's position close will fail.   V3 sell function doesn't check for balance change, using DEX returned amount as is:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/eth/UniV3Dex.sol#L61-70  ## Recommended Mitigation Steps  If fee on tranfer tokens are fully in scope, do control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic as well.  
# Handle  GeekyLumberjack   # Vulnerability details  ## Impact [transferTokens()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L95-L135) will not fail when calling [transferAllowed()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/ControllerV1.sol#L88-L91) both [transfer()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L141) and [transferFrom()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L150) rely on transferTokens(). Both the name of the function transferAllowed() and the [comments](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L99) above the call show there should be some cases that cause these functions to fail in transferAllowed.   ## Tools Used Manual review  ## Recommended Mitigation Steps Update transfer allowed to include required failures. If there are none, update the comments and the name of the function.  
# Handle  hyh   # Vulnerability details   ## Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. System then will fail with low level array access message  ## Proof of Concept  notifyRewardAmounts:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol#L163   initDistributions:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol#L131  ## Recommended Mitigation Steps  Require that (stakeTokens, reward) and (stakeTokens, startTimes, durations) arrays' lengths match within each set   
# Handle  hyh   # Vulnerability details  ## Impact  When OpenLev operations use a wrapped native token, the whole user withdraw is being handled with a `payable.transfer()` call.  This is unsafe as `transfer` has hard coded gas budget and can fail when the user is a smart contract. This way any programmatical usage of OpenLevV1 and LPool is at risk.  Whenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time.  As OpenLevV1 `closeTrade` is affected this includes user's principal funds freeze scenario, so marking the issue as a high severity one.  ## Proof of Concept  OpenLevV1Lib and LPool have `doTransferOut` function that calls native token payable.transfer:  OpenLevV1Lib.doTransferOut  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253   LPool.doTransferOut  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L297   LPool.doTransferOut is used in LPool redeem and borrow, while OpenLevV1Lib.doTransferOut is used in OpenLevV1 trade manipulation logic:  closeTrade  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L204  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L215   liquidate  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L263  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L295  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L304   ## References  The issues with `transfer()` are outlined here:  https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/   ## Recommended Mitigation Steps  OpenLevV1's `closeTrade` and `liquidate` as well as LPool's `redeem`, `redeemUnderlying`, `borrowBehalf`, `repayBorrowBehalf`, `repayBorrowEndByOpenLev` are all `nonReentrant`, so reentrancy isn't an issue and `transfer()` can be just replaced.  Using low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60  
# Handle  rfa   # Vulnerability details  ## Impact expensive gas ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/bsc/BscDexAggregatorV1.sol#L47   ## Recommended Mitigation Steps replace the 2 lines of code by just 1 line: ``` dexInfo[dexName[i]] = DexInfo(factoryAddr[i], fees[i]); ```  
# Handle  cccz   # Vulnerability details  ## Impact The current ownership transfer process involves the current owner calling transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner’s address into the owner’s state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier.  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/Airdrop.sol#L9  ## Tools Used  None  ## Recommended Mitigation Steps  Implement zero address check and consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.   
# Handle  robee   # Vulnerability details  The following functions are not payable but uses msg.value - therefore the function must be payable. This can lead to undesired behavior.          LPool.sol, addReserves should be payable since using msg.value   
# Handle  jayjonah8   # Vulnerability details  ## Impact In ControllerV1.sol in the updatePriceAllowed() function tx.origin is used.  tx.origin is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable could make a contract vulnerable if an authorized account calls into a malicious contract.  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/ControllerV1.sol#L163  https://swcregistry.io/docs/SWC-115  ## Tools Used Manual code review   ## Recommended Mitigation Steps Its recommended to use msg.sender instead  
# Handle  jayjonah8   # Vulnerability details  ## Impact In OLETokenLock.sol,  the release() function distributes all the allotted tokens to the beneficiaries but it can be called by anyone.  This should be an admin protected function as it's very important and deals with the transfer of tokens to beneficiaries which should not be accessed by simply anyone.   ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OLETokenLock.sol#L39  ## Tools Used Manual code review   ## Recommended Mitigation Steps OLETokenLock.sol should inherit the Adminable.sol contract and add require(msg.sender = admin, "Not Authorized"); to the release() function.   
# Handle  mics   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          FarmingPools.sol : reachable assert in line 77         XOLE.sol : reachable assert in line 303   
