See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-forgeries-findings/blob/main/data/indijanc-G.md).
# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L33   # Vulnerability details  ## Description  In VRFNFtRandomDraw.sol initialize(), the MONTH_IN_SECONDS variable is used to validate two values: - configured time between redraws is under 1 month - recoverTimelock (when NFT can be returned to owner) is less than 1 year in the future  ``` if (_settings.drawBufferTime > MONTH_IN_SECONDS) {     revert REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH(); } ... if (     _settings.recoverTimelock >     block.timestamp + (MONTH_IN_SECONDS * 12) ) {     revert RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR(); } ```  The issue is that MONTH_IN_SECONDS is calculated incorrectly: ``` /// @dev 60 seconds in a min, 60 mins in an hour uint256 immutable HOUR_IN_SECONDS = 60 * 60; /// @dev 24 hours in a day 7 days in a week uint256 immutable WEEK_IN_SECONDS = (3600 * 24 * 7); // @dev about 30 days in a month uint256 immutable MONTH_IN_SECONDS = (3600 * 24 * 7) * 30; ```  MONTH_IN_SECONDS multiplies by 7 incorrectly, as it was copied from WEEK_IN_SECONDS. Therefore, actual seconds calculated is equivalent of 7 months. Therefore, recoverTimelock can be up to a non-sensible value of 7 years, and re-draws every up to 7 months.   ## Impact  Protocol safeguards for time durations are skewed by a factor of 7. Protocol may potentially lock NFT for period of 7 years.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Fix MONTH_IN_SECONDS calculation: `uint256 immutable MONTH_IN_SECONDS = (3600 * 24) * 30;`
# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L83   # Vulnerability details  ## Description  In RandomDraw, the host initiates a draw using startDraw() or redraw() if the redraw draw expiry has passed. Actual use of Chainlink oracle is done in \_requestRoll: ``` request.currentChainlinkRequestId = coordinator.requestRandomWords({     keyHash: settings.keyHash,     subId: settings.subscriptionId,     minimumRequestConfirmations: minimumRequestConfirmations,     callbackGasLimit: callbackGasLimit,     numWords: wordsRequested }); ```  Use of subscription API is explained well [here](https://docs.chain.link/vrf/v2/subscription). Chainlink VRFCoordinatorV2 is called with requestRandomWords() and emits a random request. After `minimumRequestConfirmations` blocks, an oracle VRF node replies to the coordinator with a provable random, which supplies the random to the requesting contract via `fulfillRandomWords()`  call. It is important to note the role of subscription ID. This ID maps to the subscription charged for the request, in LINK tokens. In our contract, the raffle host supplies their subscription ID as a parameter. Sufficient balance check of the request ID is not [checked](https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L370) at request-time, but rather checked in Chainlink [node](https://github.com/smartcontractkit/chainlink/blob/806ee17236ba70926a1f07d1141808b634db48b6/core/services/vrf/listener_v2.go#L346) code as well as on-chain by [VRFCoordinator](https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L594) when the request is satisfied. In the scenario where the subscriptionID lacks funds, there will be a period of 24 hours when user can top up the account and random response will be [sent](https://docs.chain.link/vrf/v2/subscription):  "Each subscription must maintain a minimum balance to fund requests from consuming contracts. If your balance is below that minimum, your requests remain pending for up to 24 hours before they expire. After you add sufficient LINK to a subscription, pending requests automatically process as long as they have not expired."  The reason this is extremely interesting is because as soon as redraws are possible, the random response can no longer be treated as fair. Indeed, Draw host can wait until redraw cooldown passed (e.g. 1 hour), and only then fund the subscriptionID. At this point, Chainlink node will send a TX with the random response. If host likes the response (i.e. the draw winner), they will not interfere. If they don't like the response, they can simply frontrun the Chainlink TX with a redraw() call. A redraw will create a new random request and discard the old requestId so the previous request will never be accepted. ``` function fulfillRandomWords(     uint256 _requestId,     uint256[] memory _randomWords ) internal override {     // Validate request ID    // <---------------- swap currentChainlinkRequestId --->     if (_requestId != request.currentChainlinkRequestId) {         revert REQUEST_DOES_NOT_MATCH_CURRENT_ID();     }  ... } ```  ``` //<------ redraw swaps currentChainlinkRequestId ---> request.currentChainlinkRequestId = coordinator.requestRandomWords({     keyHash: settings.keyHash,     subId: settings.subscriptionId,     minimumRequestConfirmations: minimumRequestConfirmations,     callbackGasLimit: callbackGasLimit,     numWords: wordsRequested }); ```  Chainlink docs [warn](https://docs.chain.link/vrf/v2/security) against this usage pattern of the VRF -"Don’t accept bids/bets/inputs after you have made a randomness request". In this instance, a low subscription balance allows the host to invalidate the assumption that 1 hour redraw cooldown is enough to guarantee Chainlink answer has been received.  ## Impact  Draw organizer can rig the draw to favor certain participants such as their own account.  ## Proof of Concept  Owner offers a BAYC NFT for holders of their NFT collection X. Out of 10,000 tokenIDs, owner has 5,000 Xs. Rest belong to retail users.  1. owner subscriptionID is left with 0 LINK balance in coordinator 2. redraw time is set to 2 hours 3. owner calls startDraw() which will initiate a Chainlink request 4. owner waits for 2 hours and then tops up their subscriptionID with sufficient LINK 5. owner scans the mempool for fulfillRandomWords() 6. If the raffle winner is tokenID < 5000, it is owner's token  1. Let fulfill execute and pick up the reward 7. If tokenID >= 5000  1. Call redraw()  2. fulfill will revert because of requestId mismatch 8. Owner has 75% of claiming the NFT instead of 50%  Note that Forgeries draws are presumably intended as incentives for speculators to buy NFTs from specific collections. Without having a fair shot at receiving rewards from raffles, these NFTs user buys could be worthless. Another way to look at it is that the impact is theft of yield, as host can freely decrease the probability that a token will be chosen for rewards with this method.  Also, I did not categorize it as centralization risk as the counterparty is not Forgeries but rather some unknown third-party host which offers an NFT incentive program. It is a similar situation to the distinction made between 1st party and 3rd party projects [here](https://github.com/code-423n4/2022-10-juicebox-findings/issues/191)  ## Tools Used  Manual audit [Chainlink docs](https://docs.chain.link/vrf/v2/subscription) [Chainlink co-ordinator code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFCoordinatorV2.sol)  ## Recommended Mitigation Steps  The root cause is that Chainlink response can arrive up to 24 hours from the most request is dispatched, while redraw cooldown can be 1 hour+. The best fix would be to enforce minimum cooldown of 24 hours.
# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L304-L320   # Vulnerability details  On contest page: `"If no users ultimately claim the NFT, the admin specifies a timelock period after which they can retrieve the raffled NFT."`  Let's assume a recoverTimelock of 1 week.  The specification suggests that 1 week from the winner not having claimed the NFT. Meaning that the admin should only be able to call `lastResortTimelockOwnerClaimNFT()` only after `<block.timestamp at fulfillRandomWords()> + request.drawTimelock + 1 weeks`.   Specification: ```          drawTimelock                recoverTimelock              │                              │              ▼                              ▼         ┌────┬──────────────────────────────┐         │    │           1 week             │         └────┴──────────────────────────────┘         ▲         │ fulfillRandomWords() ``` - The winner should have up to `drawTimelock` to claim before an admin can call `redraw()` and pick a new winner. - The winner should have up to `recoverTimelock` to claim before an admin can call `lastResortTimelockOwnerClaimNFT()` to cancel the raffle.  But this is not the case.   **recoverTimelock** is set in the `initialize(...)` function and not anywhere else. That means 1 week from initialization, the admin can call `lastResortTimelockOwnerClaimNFT()`. `redraw()` also does not update `recoverTimelock`.  In fact, `startDraw()` does not have to be called at the same time as `initialize(...)`. That means that if the draw was started after having been initialized for 1 week, the admin can withdraw at any time after that.  ### Impact Protocol does not work as intended.  ### Recommendations Just like for `drawTimelock`, `recoverTimelock` should also be updated for each dice roll. `<block.timestamp at fulfillRandomWords()> + request.drawTimelock + <recoverBufferTime>`.  where `<recoverBufferTime>` is essentially the `drawBufferTime` currently used, but for `recoverTimelock`.  **Note:** currently, `drawTimelock` is updated in the `_requestRoll()` function. This is "technically less correct" as chainlink will take some time before `fulfillRandomWords(...)` callback. So the timelock is actually set before the winner has been chosen.  This should be insignificant under normal network conditions (Chainlink VRF shouldn't take > 1min) but both timelocks should be updated in the same function - either `_requestRoll()` or `fulfillRandomWords(...)`.
# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173 https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L162-L168   # Vulnerability details  ## Impact The admin/owner of `VRFNFTRandomDraw` can `startDraw()` a raffle, including emitting the `SetupDraw` event, but in a way that ensures `fulfillRandomWords()` is never called. For example: - `keyHash` is not validated within `coordinator.requestRandomWords()`. Providing an invalid `keyHash` will allow the raffle to start but prevent the oracle from actually supplying a random value to determine the raffle result.     - https://github.com/smartcontractkit/chainlink/blob/00f9c6e41f843f96108cdaa118a6ca740b11df35/contracts/src/v0.8/VRFCoordinatorV2.sol#L407-L409     - https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L163 - The admin/owner could alternatively ensure that the owner-provided chain.link VRF subscription does not have sufficient funds to pay at the time the oracle attempts to supply random values in `fulfillRandomWords()`.     - https://github.com/smartcontractkit/chainlink/blob/00f9c6e41f843f96108cdaa118a6ca740b11df35/contracts/src/v0.8/VRFCoordinatorV2.sol#L594-L596  In addition, the owner/admin could simply avoid ever calling `startDraw()` in the first place.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps Depending on the desired functionality with respect to the raffle owner, a successful callback to `fulfillRandomWords()` could be a precondition of the admin/owner reclaiming the reward NFT. This would help ensure the owner does not create raffles that they intend will never pay out a reward.
# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173 https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L304 https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L127   # Vulnerability details  ## Impact The raffle creator is not required to actually give the NFT away. The NFT that is used for the raffle is transferred to the contract when `startDraw` is executed. Before that, the NFT is in the hands of the creator. This means that he might create a raffle to make users buy NFTs required to participate and then refuse to draw a winner and keep the NFT to himself. Furthermore, he might not even be the owner of NFT in the first place, which he can achieve by flash loaning the NFT in order to pass the `ownerOf` check in `initialize` function.  ## Proof of Concept ### Example 1 1. User U creates an NFT collection C 2. He buys a BAYC NFT 3. He creates a raffle with it, and requires `drawingToken` to be from collection C 4. Users buy tokens from his collection C 5. He then refuses to execute `startDraw` function and rather sells the BAYC NFT  ### Example 2 1. User U creates an NFT collection C 2. User U uses an NFT flash loan to borrow a very expensive NFT 3. In the same transaction he creates a raffle with this NFT, and requires `drawingToken` to be from collection C 4. The check that he is the owner will pass, because for the duration of the transaction he in fact is 5. Users see that there is a raffle for a very expensive NFT, so they buy tokens C 6. The winner is never drawn, because the creator does not even own the NFT  ### Example 3 1. User U has an NFT X 2. He puts X on a sale on some NFT marketplace (which does not require him to lock it in contract) 3. He forgets about it and creates a raffle with it 4. Users buy the tokens necessary for the raffle 5. User U wants to execute the `startDraw` function, but just before it the NFT X is bought from him through the marketplace 6. The winner cannot be drawn  ## Recommended Mitigation Steps Transfer the NFT to the contract at the time of creation of the raffle.  You can do that by approving the factory contract to transfer the token and do the transfer in [`makeNewDraw`](https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDrawFactory.sol#L43) function between cloning and `initialization`. ``` address newDrawing = ClonesUpgradeable.clone(implementation); IERC721(settings.token).transferFrom(msg.sender, newDrawing, settings.tokenId);         // Setup the new drawing IVRFNFTRandomDraw(newDrawing).initialize(admin, settings); ```  Remember to remove token transfer from `startDraw` function.  Notice that the creator can still claim NFT after a week, without drawing, by executing `lastResortTimelockOwnerClaimNFT`. To prevent that, I would recommend adding a check in [`lastResortTimelockOwnerClaimNFT`](https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L304), if a winner was drawn. ```  if (!request.hasChosenRandomNumber) {             revert NEEDS_TO_HAVE_CHOSEN_A_NUMBER(); } ``` So now a user can trust that the NFT is locked in the contract, and it will be claimable only by a winner (or creator if the winner does not claim it). However, there is still no guarantee that the winner will actually be drawn, because the creator has to manually execute `startDraw` function. To fix this, I would recommend allowing anyone to execute `startDraw` function, so there is no need to rely on the creator. But we would need to limit the time window of when [`startDraw`](https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173) can be executed, so users have the time to get tokens before the drawing. That can be done by introducing a new state variable `firstDrawTime`, that acts as a timestamp after which drawing can happen. ``` if(block.timestamp < firstDrawTime) revert CANNOT_DRAW_YET(); ``` Notice that now NFT can only be claimed after winner has been drawn. This means that we are depending on ChainLink VRF to be successful. For that reason I would recommend adding a role that has the power to change the VRF subscription or restore the NFT in case where winner is not picked in reasonable time. This role would be given to protocol owner (owner of the factory) / DAO / someone who would be considered as most reliable. 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-forgeries-findings/blob/main/data/indijanc-G.md).
# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L33   # Vulnerability details  ## Description  In VRFNFtRandomDraw.sol initialize(), the MONTH_IN_SECONDS variable is used to validate two values: - configured time between redraws is under 1 month - recoverTimelock (when NFT can be returned to owner) is less than 1 year in the future  ``` if (_settings.drawBufferTime > MONTH_IN_SECONDS) {     revert REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH(); } ... if (     _settings.recoverTimelock >     block.timestamp + (MONTH_IN_SECONDS * 12) ) {     revert RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR(); } ```  The issue is that MONTH_IN_SECONDS is calculated incorrectly: ``` /// @dev 60 seconds in a min, 60 mins in an hour uint256 immutable HOUR_IN_SECONDS = 60 * 60; /// @dev 24 hours in a day 7 days in a week uint256 immutable WEEK_IN_SECONDS = (3600 * 24 * 7); // @dev about 30 days in a month uint256 immutable MONTH_IN_SECONDS = (3600 * 24 * 7) * 30; ```  MONTH_IN_SECONDS multiplies by 7 incorrectly, as it was copied from WEEK_IN_SECONDS. Therefore, actual seconds calculated is equivalent of 7 months. Therefore, recoverTimelock can be up to a non-sensible value of 7 years, and re-draws every up to 7 months.   ## Impact  Protocol safeguards for time durations are skewed by a factor of 7. Protocol may potentially lock NFT for period of 7 years.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Fix MONTH_IN_SECONDS calculation: `uint256 immutable MONTH_IN_SECONDS = (3600 * 24) * 30;`
# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L83   # Vulnerability details  ## Description  In RandomDraw, the host initiates a draw using startDraw() or redraw() if the redraw draw expiry has passed. Actual use of Chainlink oracle is done in \_requestRoll: ``` request.currentChainlinkRequestId = coordinator.requestRandomWords({     keyHash: settings.keyHash,     subId: settings.subscriptionId,     minimumRequestConfirmations: minimumRequestConfirmations,     callbackGasLimit: callbackGasLimit,     numWords: wordsRequested }); ```  Use of subscription API is explained well [here](https://docs.chain.link/vrf/v2/subscription). Chainlink VRFCoordinatorV2 is called with requestRandomWords() and emits a random request. After `minimumRequestConfirmations` blocks, an oracle VRF node replies to the coordinator with a provable random, which supplies the random to the requesting contract via `fulfillRandomWords()`  call. It is important to note the role of subscription ID. This ID maps to the subscription charged for the request, in LINK tokens. In our contract, the raffle host supplies their subscription ID as a parameter. Sufficient balance check of the request ID is not [checked](https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L370) at request-time, but rather checked in Chainlink [node](https://github.com/smartcontractkit/chainlink/blob/806ee17236ba70926a1f07d1141808b634db48b6/core/services/vrf/listener_v2.go#L346) code as well as on-chain by [VRFCoordinator](https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L594) when the request is satisfied. In the scenario where the subscriptionID lacks funds, there will be a period of 24 hours when user can top up the account and random response will be [sent](https://docs.chain.link/vrf/v2/subscription):  "Each subscription must maintain a minimum balance to fund requests from consuming contracts. If your balance is below that minimum, your requests remain pending for up to 24 hours before they expire. After you add sufficient LINK to a subscription, pending requests automatically process as long as they have not expired."  The reason this is extremely interesting is because as soon as redraws are possible, the random response can no longer be treated as fair. Indeed, Draw host can wait until redraw cooldown passed (e.g. 1 hour), and only then fund the subscriptionID. At this point, Chainlink node will send a TX with the random response. If host likes the response (i.e. the draw winner), they will not interfere. If they don't like the response, they can simply frontrun the Chainlink TX with a redraw() call. A redraw will create a new random request and discard the old requestId so the previous request will never be accepted. ``` function fulfillRandomWords(     uint256 _requestId,     uint256[] memory _randomWords ) internal override {     // Validate request ID    // <---------------- swap currentChainlinkRequestId --->     if (_requestId != request.currentChainlinkRequestId) {         revert REQUEST_DOES_NOT_MATCH_CURRENT_ID();     }  ... } ```  ``` //<------ redraw swaps currentChainlinkRequestId ---> request.currentChainlinkRequestId = coordinator.requestRandomWords({     keyHash: settings.keyHash,     subId: settings.subscriptionId,     minimumRequestConfirmations: minimumRequestConfirmations,     callbackGasLimit: callbackGasLimit,     numWords: wordsRequested }); ```  Chainlink docs [warn](https://docs.chain.link/vrf/v2/security) against this usage pattern of the VRF -"Don’t accept bids/bets/inputs after you have made a randomness request". In this instance, a low subscription balance allows the host to invalidate the assumption that 1 hour redraw cooldown is enough to guarantee Chainlink answer has been received.  ## Impact  Draw organizer can rig the draw to favor certain participants such as their own account.  ## Proof of Concept  Owner offers a BAYC NFT for holders of their NFT collection X. Out of 10,000 tokenIDs, owner has 5,000 Xs. Rest belong to retail users.  1. owner subscriptionID is left with 0 LINK balance in coordinator 2. redraw time is set to 2 hours 3. owner calls startDraw() which will initiate a Chainlink request 4. owner waits for 2 hours and then tops up their subscriptionID with sufficient LINK 5. owner scans the mempool for fulfillRandomWords() 6. If the raffle winner is tokenID < 5000, it is owner's token  1. Let fulfill execute and pick up the reward 7. If tokenID >= 5000  1. Call redraw()  2. fulfill will revert because of requestId mismatch 8. Owner has 75% of claiming the NFT instead of 50%  Note that Forgeries draws are presumably intended as incentives for speculators to buy NFTs from specific collections. Without having a fair shot at receiving rewards from raffles, these NFTs user buys could be worthless. Another way to look at it is that the impact is theft of yield, as host can freely decrease the probability that a token will be chosen for rewards with this method.  Also, I did not categorize it as centralization risk as the counterparty is not Forgeries but rather some unknown third-party host which offers an NFT incentive program. It is a similar situation to the distinction made between 1st party and 3rd party projects [here](https://github.com/code-423n4/2022-10-juicebox-findings/issues/191)  ## Tools Used  Manual audit [Chainlink docs](https://docs.chain.link/vrf/v2/subscription) [Chainlink co-ordinator code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFCoordinatorV2.sol)  ## Recommended Mitigation Steps  The root cause is that Chainlink response can arrive up to 24 hours from the most request is dispatched, while redraw cooldown can be 1 hour+. The best fix would be to enforce minimum cooldown of 24 hours.
# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L304-L320   # Vulnerability details  On contest page: `"If no users ultimately claim the NFT, the admin specifies a timelock period after which they can retrieve the raffled NFT."`  Let's assume a recoverTimelock of 1 week.  The specification suggests that 1 week from the winner not having claimed the NFT. Meaning that the admin should only be able to call `lastResortTimelockOwnerClaimNFT()` only after `<block.timestamp at fulfillRandomWords()> + request.drawTimelock + 1 weeks`.   Specification: ```          drawTimelock                recoverTimelock              │                              │              ▼                              ▼         ┌────┬──────────────────────────────┐         │    │           1 week             │         └────┴──────────────────────────────┘         ▲         │ fulfillRandomWords() ``` - The winner should have up to `drawTimelock` to claim before an admin can call `redraw()` and pick a new winner. - The winner should have up to `recoverTimelock` to claim before an admin can call `lastResortTimelockOwnerClaimNFT()` to cancel the raffle.  But this is not the case.   **recoverTimelock** is set in the `initialize(...)` function and not anywhere else. That means 1 week from initialization, the admin can call `lastResortTimelockOwnerClaimNFT()`. `redraw()` also does not update `recoverTimelock`.  In fact, `startDraw()` does not have to be called at the same time as `initialize(...)`. That means that if the draw was started after having been initialized for 1 week, the admin can withdraw at any time after that.  ### Impact Protocol does not work as intended.  ### Recommendations Just like for `drawTimelock`, `recoverTimelock` should also be updated for each dice roll. `<block.timestamp at fulfillRandomWords()> + request.drawTimelock + <recoverBufferTime>`.  where `<recoverBufferTime>` is essentially the `drawBufferTime` currently used, but for `recoverTimelock`.  **Note:** currently, `drawTimelock` is updated in the `_requestRoll()` function. This is "technically less correct" as chainlink will take some time before `fulfillRandomWords(...)` callback. So the timelock is actually set before the winner has been chosen.  This should be insignificant under normal network conditions (Chainlink VRF shouldn't take > 1min) but both timelocks should be updated in the same function - either `_requestRoll()` or `fulfillRandomWords(...)`.
# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173 https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L162-L168   # Vulnerability details  ## Impact The admin/owner of `VRFNFTRandomDraw` can `startDraw()` a raffle, including emitting the `SetupDraw` event, but in a way that ensures `fulfillRandomWords()` is never called. For example: - `keyHash` is not validated within `coordinator.requestRandomWords()`. Providing an invalid `keyHash` will allow the raffle to start but prevent the oracle from actually supplying a random value to determine the raffle result.     - https://github.com/smartcontractkit/chainlink/blob/00f9c6e41f843f96108cdaa118a6ca740b11df35/contracts/src/v0.8/VRFCoordinatorV2.sol#L407-L409     - https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L163 - The admin/owner could alternatively ensure that the owner-provided chain.link VRF subscription does not have sufficient funds to pay at the time the oracle attempts to supply random values in `fulfillRandomWords()`.     - https://github.com/smartcontractkit/chainlink/blob/00f9c6e41f843f96108cdaa118a6ca740b11df35/contracts/src/v0.8/VRFCoordinatorV2.sol#L594-L596  In addition, the owner/admin could simply avoid ever calling `startDraw()` in the first place.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps Depending on the desired functionality with respect to the raffle owner, a successful callback to `fulfillRandomWords()` could be a precondition of the admin/owner reclaiming the reward NFT. This would help ensure the owner does not create raffles that they intend will never pay out a reward.
# Lines of code  https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173 https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L304 https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L127   # Vulnerability details  ## Impact The raffle creator is not required to actually give the NFT away. The NFT that is used for the raffle is transferred to the contract when `startDraw` is executed. Before that, the NFT is in the hands of the creator. This means that he might create a raffle to make users buy NFTs required to participate and then refuse to draw a winner and keep the NFT to himself. Furthermore, he might not even be the owner of NFT in the first place, which he can achieve by flash loaning the NFT in order to pass the `ownerOf` check in `initialize` function.  ## Proof of Concept ### Example 1 1. User U creates an NFT collection C 2. He buys a BAYC NFT 3. He creates a raffle with it, and requires `drawingToken` to be from collection C 4. Users buy tokens from his collection C 5. He then refuses to execute `startDraw` function and rather sells the BAYC NFT  ### Example 2 1. User U creates an NFT collection C 2. User U uses an NFT flash loan to borrow a very expensive NFT 3. In the same transaction he creates a raffle with this NFT, and requires `drawingToken` to be from collection C 4. The check that he is the owner will pass, because for the duration of the transaction he in fact is 5. Users see that there is a raffle for a very expensive NFT, so they buy tokens C 6. The winner is never drawn, because the creator does not even own the NFT  ### Example 3 1. User U has an NFT X 2. He puts X on a sale on some NFT marketplace (which does not require him to lock it in contract) 3. He forgets about it and creates a raffle with it 4. Users buy the tokens necessary for the raffle 5. User U wants to execute the `startDraw` function, but just before it the NFT X is bought from him through the marketplace 6. The winner cannot be drawn  ## Recommended Mitigation Steps Transfer the NFT to the contract at the time of creation of the raffle.  You can do that by approving the factory contract to transfer the token and do the transfer in [`makeNewDraw`](https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDrawFactory.sol#L43) function between cloning and `initialization`. ``` address newDrawing = ClonesUpgradeable.clone(implementation); IERC721(settings.token).transferFrom(msg.sender, newDrawing, settings.tokenId);         // Setup the new drawing IVRFNFTRandomDraw(newDrawing).initialize(admin, settings); ```  Remember to remove token transfer from `startDraw` function.  Notice that the creator can still claim NFT after a week, without drawing, by executing `lastResortTimelockOwnerClaimNFT`. To prevent that, I would recommend adding a check in [`lastResortTimelockOwnerClaimNFT`](https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L304), if a winner was drawn. ```  if (!request.hasChosenRandomNumber) {             revert NEEDS_TO_HAVE_CHOSEN_A_NUMBER(); } ``` So now a user can trust that the NFT is locked in the contract, and it will be claimable only by a winner (or creator if the winner does not claim it). However, there is still no guarantee that the winner will actually be drawn, because the creator has to manually execute `startDraw` function. To fix this, I would recommend allowing anyone to execute `startDraw` function, so there is no need to rely on the creator. But we would need to limit the time window of when [`startDraw`](https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173) can be executed, so users have the time to get tokens before the drawing. That can be done by introducing a new state variable `firstDrawTime`, that acts as a timestamp after which drawing can happen. ``` if(block.timestamp < firstDrawTime) revert CANNOT_DRAW_YET(); ``` Notice that now NFT can only be claimed after winner has been drawn. This means that we are depending on ChainLink VRF to be successful. For that reason I would recommend adding a role that has the power to change the VRF subscription or restore the NFT in case where winner is not picked in reasonable time. This role would be given to protocol owner (owner of the factory) / DAO / someone who would be considered as most reliable. 
