## Summary  ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | 1 | Buyouts that occur during the timestamp wrap will have valuation errors | 1 | | 2 | `ecrecover()` not checked for signer address of zero | 1 | | 3 | Return values of `transfer()`/`transferFrom()` not checked | 4 | | 4 | Input array lengths may differ | 4 | | 5 | `_safeMint()` should be used rather than `_mint()` wherever possible | 1 | | 6 | Missing checks for `address(0x0)` when assigning values to `address` state variables | 6 | | 7 | Vulnerable to cross-chain replay attacks due to static `DOMAIN_SEPARATOR`/`domainSeparator` | 1 | | 8 | Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions | 1 | | 9 | Incorrect comments | 3 |  Total: 22 instances over 9 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | 1 | Consider addings checks for signature malleability | 1 | | 2 | Misleading variable name | 1 | | 3 | Inconsistent version of English being used | 2 | | 4 | Missing `initializer` modifier on constructor | 1 | | 5 | Contract implements interface without extending the interface | 1 | | 6 | `require()`/`revert()` statements should have descriptive reason strings | 1 | | 7 | `public` functions not called by the contract should be declared `external` instead | 3 | | 8 | Non-assembly method available | 1 | | 9 | `2**<n> - 1` should be re-written as `type(uint<n>).max` | 4 | | 10 | `constant`s should be defined rather than using magic numbers | 10 | | 11 | Cast is more restrictive than the type of the variable being assigned | 1 | | 12 | Missing event and or timelock for critical parameter change | 4 | | 13 | Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant` | 5 | | 14 | Inconsistent spacing in comments | 27 | | 15 | Lines are too long | 14 | | 16 | Non-library/interface files should use fixed compiler versions, not floating ones | 1 | | 17 | Typos | 14 | | 18 | File is missing NatSpec | 1 | | 19 | NatSpec is incomplete | 12 | | 20 | Event is missing `indexed` fields | 5 |  Total: 109 instances over 20 issues   ## Low Risk Issues  ### 1. Buyouts that occur during the timestamp wrap will have valuation errors The `_blockTimestamp` has a modulo applied, so at some point, there will be a timestamp with a value close to 2^32, followed by a timestamp close to zero. The `_updateTWAV` function does an unchecked subtraction of the two timestamps, so this will lead to an underflow, making the valuation based on a long time period rather than the actual one. Until more TWAV entries are added, valuations will be wrong  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  303              uint32 _blockTimestamp = uint32(block.timestamp % 2**32); 304              if (_blockTimestamp != lastBlockTimeStamp) { 305:                 _updateTWAV(getCurrentValuation(), _blockTimestamp);    ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303-L305  ### 2. `ecrecover()` not checked for signer address of zero The `ecrecover()` function returns an address of zero when the signature does not match. This can cause problems if address zero is ever the owner of assets, and someone uses the permit function on address zero. If that happens, any invalid signature will pass the checks, and the assets will be stealable. In this case, the asset of concern is the vault's ERC20 token, and fortunately OpenZeppelin's implementation does a good job of making sure that address zero is never able to have a positive balance. If this contract ever changes to another ERC20 implementation that is laxer in its checks in favor of saving gas, this code may become a problem.  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563  ### 3. Return values of `transfer()`/`transferFrom()` not checked Not all `IERC20` implementations `revert()` when there's a failure in `transfer()`/`transferFrom()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually making a payment  *There are 4 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  87:           IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87  ```solidity File: contracts/Basket.sol   #2  94:               IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94  ```solidity File: contracts/NibblVault.sol   #3  517:          IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517  ```solidity File: contracts/NibblVault.sol   #4  526:              IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526  ### 4. Input array lengths may differ If the caller makes a copy-paste error, the lengths may be mismatchd and an operation believed to have been completed may not in fact have been completed  *There are 4 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  41:      function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41  ```solidity File: contracts/Basket.sol   #2  68:      function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68  ```solidity File: contracts/NibblVault.sol   #3  545:     function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545  ```solidity File: contracts/NibblVault.sol   #4  504:     function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504  ### 5. `_safeMint()` should be used rather than `_mint()` wherever possible `_mint()` is [discouraged](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271) in favor of `_safeMint()` which ensures that the recipient is either an EOA or implements `IERC721Receiver`. Both [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L238-L250) and [solmate](https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L180) have versions of this function  *There is 1 instance of this issue:* ```solidity File: contracts/Basket.sol   #1  24:           _mint(_curator, 0); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L24  ### 6. Missing checks for `address(0x0)` when assigning values to `address` state variables  *There are 6 instances of this issue:* ```solidity File: contracts/NibblVault.sol  191:          assetAddress = _assetAddress;  193:          curator = _curator;  487:          curator = _newCurator; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L191  ```solidity File: contracts/NibblVaultFactory.sol  100:         pendingBasketImplementation = _newBasketImplementation;  124:         pendingFeeTo = _newFeeAddress;  159:         pendingVaultImplementation = _newVaultImplementation; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100  ### 7. Vulnerable to cross-chain replay attacks due to static `DOMAIN_SEPARATOR`/`domainSeparator` See [this](https://github.com/code-423n4/2021-04-maple-findings/issues/2) issue from a prior contest for details  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol   #1  15       function INIT_EIP712(string memory name, string memory version) internal { 16           domainSeperator = keccak256( 17               abi.encode( 18                   EIP712_DOMAIN_TYPEHASH, 19                   keccak256(bytes(name)), 20                   keccak256(bytes(version)), 21                   getChainID(), 22                   address(this) 23               ) 24           ); 25:      } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15-L25  ### 8. Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20  ### 9. Incorrect comments  *There are 3 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  /// @audit ERC1155, not ERC721 58:      /// @notice withdraw an ERC721 token from this contract into your wallet ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L58  ```solidity File: contracts/Twav/Twav.sol   #2  /// @audit or zero if there have been fewer than four blocks 34:      /// @return _twav TWAV of the last 4 blocks ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L34  ```solidity File: contracts/Twav/Twav.sol   #3  /// @audit of the last four updates, not necessarily of the last four blocks (i.e. may be blocked that were skipped) 34:      /// @return _twav TWAV of the last 4 blocks ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L34  ## Non-critical Issues  ### 1. Consider addings checks for signature malleability Use OpenZeppelin's `ECDSA` contract rather than calling `ecrecover()` directly  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563  ### 2. Misleading variable name `_twavObservationPrev` is not the previous observation - it's more like the trailing, or next-to-expire TWAV observation`  *There is 1 instance of this issue:* ```solidity File: contracts/Twav/Twav.sol   #1  39:              TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39  ### 3. Inconsistent version of English being used Some functions use American English, whereas others use British English. A single project should use only one of the two  *There are 2 instances of this issue:* ```solidity File: contracts/NibblVault.sol   #1  173:     function initialize( ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L173  ```solidity File: contracts/Interfaces/IBasket.sol   #2  10:      function initialise(address _curator) external; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Interfaces/IBasket.sol#L10  ### 4. Missing `initializer` modifier on constructor OpenZeppelin [recommends](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5) that the `initializer` modifier be applied to constructors in order to avoid potential griefs, [social engineering](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/4), or exploits. Ensure that the modifier is applied to the implementation contract. If the default constructor is currently being used, it should be changed to be an explicit one with the modifier applied.  *There is 1 instance of this issue:* ```solidity File: contracts/Basket.sol   #1  13:   contract Basket is IBasket, ERC721("NFT Basket", "NFTB"), Initializable { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13  ### 5. Contract implements interface without extending the interface Not extending the interface may lead to the wrong function signature being used, leading to unexpected behavior. If the interface is in fact being implemented, use the `override` keyword to indicate that fact  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  /// @audit onERC721Received(), onERC1155Received() 20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20  ### 6. `require()`/`revert()` statements should have descriptive reason strings  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  114:          require(_success); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L114  ### 7. `public` functions not called by the contract should be declared `external` instead Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.  *There are 3 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  64        function getVaultAddress( 65            address _curator, 66            address _assetAddress, 67            uint256 _assetTokenID, 68            uint256 _initialSupply, 69:           uint256 _initialTokenPrice) public view returns(address _vault) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L64-L69  ```solidity File: contracts/NibblVaultFactory.sol   #2  76:       function getVaults() public view returns(ProxyVault[] memory ) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76  ```solidity File: contracts/Twav/Twav.sol   #3  44:       function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44  ### 8. Non-assembly method available  `assembly{ id := chainid() }` => `uint256 id = block.chainid`, `assembly { size := extcodesize() }` => `uint256 size = address().code.length`  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol   #1  29:               id := chainid() ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L29  ### 9. `2**<n> - 1` should be re-written as `type(uint<n>).max` Earlier versions of solidity can use `uint<n>(-1)` instead. Expressions not including the `- 1` can often be re-written to accomodate the change (e.g. by using a `>` rather than a `>=`, which will also save some gas)  *There are 4 instances of this issue:* ```solidity File: contracts/NibblVault.sol   #1  303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303  ```solidity File: contracts/NibblVault.sol   #2  365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L365  ```solidity File: contracts/NibblVault.sol   #3  413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32)); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L413  ```solidity File: contracts/NibblVault.sol   #4  445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L445  ### 10. `constant`s should be defined rather than using magic numbers Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals  *There are 10 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol  /// @audit 0xff 72:           bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));  /// @audit 0xff 91:           bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L72  ```solidity File: contracts/NibblVault.sol  /// @audit 1e18 183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));  /// @audit 1e18 195:          uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);  /// @audit 1e18 226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade   /// @audit 1e18 253:              return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));  /// @audit 32 303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  /// @audit 32 365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  /// @audit 32 413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));  /// @audit 32 445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L183  ### 11. Cast is more restrictive than the type of the variable being assigned If `address foo` is being used in an expression such as `IERC20 token = FooToken(foo)`, then the more specific cast to `FooToken` is a waste because the only thing the compiler will check for is that `FooToken` extends `IERC20` - it won't check any of the function signatures. Therefore, it makes more sense to do `IERC20 token = IERC20(token)` or better yet `FooToken token = FooToken(foo)`. The former may allow the file in which it's used to remove the import for `FooToken`  *There is 1 instance of this issue:* ```solidity File: contracts/Proxy/ProxyBasket.sol   #1  /// @audit payable vs address 20:           implementation = payable(_implementation); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L20  ### 12. Missing event and or timelock for critical parameter change Events help non-contract tools to track changes, and events prevent users from being surprised by changes  *There are 4 instances of this issue:* ```solidity File: contracts/NibblVault.sol   #1  485       function updateCurator(address _newCurator) external override { 486           require(msg.sender == curator,"NibblVault: Only Curator"); 487           curator = _newCurator; 488:      } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L488  ```solidity File: contracts/NibblVaultFactory.sol   #2  100:         pendingBasketImplementation = _newBasketImplementation; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100  ```solidity File: contracts/NibblVaultFactory.sol   #3  124:         pendingFeeTo = _newFeeAddress; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L124  ```solidity File: contracts/NibblVaultFactory.sol   #4  159:         pendingVaultImplementation = _newVaultImplementation; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L159  ### 13. Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`  *There are 5 instances of this issue:* ```solidity File: contracts/NibblVault.sol  51:       bytes32 private constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L51  ```solidity File: contracts/Utilities/AccessControlMechanism.sol  12:       bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE");  13:       bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");  14:       bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12  ```solidity File: contracts/Utilities/EIP712Base.sol  7         bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256( 8             bytes( 9                 "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)" 10            ) 11:       ); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L7-L11  ### 14. Inconsistent spacing in comments Some lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file  *There are 27 instances of this issue:* ```solidity File: contracts/NibblVault.sol  28:       uint32 private constant primaryReserveRatio = 200_000; //20%  34:       uint256 private constant REJECTION_PREMIUM = 150_000; //15%  46:       uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%  122:      ///@notice current status of vault  125:      ///@notice reenterancy guard  200:          //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  220:          //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault  221:          //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance  226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade   228:              safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract  244:              safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract  301:          //Make update on the first tx of the block  318:                  //Gas Optimization  363:          //Make update on the first tx of the block  368:                  _rejectBuyout(); //For the case when TWAV goes up when updated on sell  377:                  //Gas Optimization  389:          safeTransferETH(_to, _saleReturn); //send _saleReturn to _to  402:          //_buyoutBid: Bid User has made  448:              _rejectBuyout(); //For the case when TWAV goes up when updated externally  500:      ///@notice withdraw multiple ERC721s ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28  ```solidity File: contracts/Proxy/ProxyBasket.sol  28:       //solhint-disable-next-line no-complex-fallback  31:           //solhint-disable-next-line no-inline-assembly ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L28  ```solidity File: contracts/Proxy/ProxyVault.sol  28:       //solhint-disable-next-line no-complex-fallback  31:           //solhint-disable-next-line no-inline-assembly ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L28  ```solidity File: contracts/Twav/Twav.sol  12:       uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks   28:           twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L12  ### 15. Lines are too long Usually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length  *There are 14 instances of this issue:* ```solidity File: contracts/Basket.sol  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L109  ```solidity File: contracts/NibblVaultFactory.sol  50:           _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this)))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L50  ```solidity File: contracts/NibblVault.sol  19:   /// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.  79:       /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply   201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  224:          _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance  226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade   263:      /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance  266:              return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);  297:      /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both  358:      /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both  395:      /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L19  ```solidity File: contracts/Twav/Twav.sol  28:           twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative  40:               _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L28  ### 16. Non-library/interface files should use fixed compiler versions, not floating ones  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  4:    pragma solidity ^0.8.0; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4  ### 17. Typos  *There are 14 instances of this issue:* ```solidity File: contracts/NibblVault.sol  /// @audit reenterancy 125:      ///@notice reenterancy guard  /// @audit pausablity 152:      /// @dev pausablity implemented in factory  /// @audit primaryReseveRatio 200:          //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  /// @audit primaryReseveRatio 201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  /// @audit continous 250:      /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply  /// @audit seconday 263:      /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance  /// @audit continous 270:      /// @param _amount amount of reserve tokens to buy continous tokens  /// @audit continous 282:      /// @param _amount amount of reserve tokens to buy continous tokens  /// @audit Continous 359:      /// @param _amtIn Continous Tokens to be sold  /// @audit recieve 361:      /// @param _to Address to recieve the reserve token to  /// @audit airdops 512:      /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops   /// @audit airdops 531:      /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops  ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L125  ```solidity File: contracts/Proxy/ProxyBasket.sol  /// @audit internall 26:        * This function does not return to its internall call site, it will return directly to the external caller. ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L26  ```solidity File: contracts/Proxy/ProxyVault.sol  /// @audit internall 26:        * This function does not return to its internall call site, it will return directly to the external caller. ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L26  ### 18. File is missing NatSpec  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol (various lines)   #1  ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol  ### 19. NatSpec is incomplete  *There are 12 instances of this issue:* ```solidity File: contracts/Basket.sol  /// @audit Missing: '@param _to' 32        /// @notice withdraw an ERC721 token from this contract into your wallet 33        /// @param _token the address of the NFT you are withdrawing 34        /// @param _tokenId the ID of the NFT you are withdrawing 35:       function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {  /// @audit Missing: '@param _to' 49        /// @notice withdraw an ERC721 token from this contract into your wallet 50        /// @param _token the address of the NFT you are withdrawing 51        /// @param _tokenId the ID of the NFT you are withdrawing 52:       function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {  /// @audit Missing: '@param _to' 58        /// @notice withdraw an ERC721 token from this contract into your wallet 59        /// @param _token the address of the NFT you are withdrawing 60        /// @param _tokenId the ID of the NFT you are withdrawing 61:       function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L32-L35  ```solidity File: contracts/NibblVaultFactory.sol  /// @audit Missing: '@return' 36        /// @param _initialTokenPrice desired initial token price 37        /// @param _minBuyoutTime minimum time after which buyout can be triggered 38        function createVault( 39            address _assetAddress, 40            address _curator, 41            string memory _name, 42            string memory _symbol, 43            uint256 _assetTokenID, 44            uint256 _initialSupply, 45            uint256 _initialTokenPrice, 46            uint256 _minBuyoutTime 47:           ) external payable override whenNotPaused returns(address payable _proxyVault) {  /// @audit Missing: '@return' 62        /// @param _initialSupply desired initial token supply 63        /// @param _initialTokenPrice desired initial token price     64        function getVaultAddress( 65            address _curator, 66            address _assetAddress, 67            uint256 _assetTokenID, 68            uint256 _initialSupply, 69:           uint256 _initialTokenPrice) public view returns(address _vault) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L36-L47  ```solidity File: contracts/NibblVault.sol  /// @audit Missing: '@param _totalSupply' 269       /// @notice function to buy tokens on the primary curve 270       /// @param _amount amount of reserve tokens to buy continous tokens 271       /// @dev This is executed when current supply >= initial supply 272       /// @dev _amount is charged with fee 273       /// @dev _purchaseReturn is minted to _to 274       /// @return _purchaseReturn Purchase return 275:      function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {  /// @audit Missing: '@param _totalSupply' 281       /// @notice function to buy tokens on secondary curve 282       /// @param _amount amount of reserve tokens to buy continous tokens 283       /// @dev This is executed when current supply < initial supply 284       /// @dev only admin and curator fee is charged in secondary curve 285       /// @dev _purchaseReturn is minted to _to 286       /// @return _purchaseReturn Purchase return 287:      function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {  /// @audit Missing: '@return' 298       /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails. 299       /// @param _to Address to mint the purchase return to 300:      function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {  /// @audit Missing: '@param _totalSupply' 330       /// @notice The function to sell fractional tokens on primary curve 331       /// @dev Executed when currentSupply > initialSupply 332       /// @dev _amount is charged with fee 333       /// @param _amount Amount of tokens to be sold on primary curve 334       /// @return _saleReturn Sale Return 335:      function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {  /// @audit Missing: '@param _totalSupply' 342       /// @notice The function to sell fractional tokens on secondary curve 343       /// @dev Executed when current supply <= initial supply 344       /// @dev only admin and curator fee is charged in secondary curve 345       /// @param _amount Amount of tokens to be sold on SecondaryCurve 346       ///  @return _saleReturn Sale Return 347:      function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){  /// @audit Missing: '@return' 360       /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails. 361       /// @param _to Address to recieve the reserve token to 362:      function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {  /// @audit Missing: '@return' 472       /// @param _to the address where curator fee will be sent 473       /// @dev can only be called by curator 474:      function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L269-L275  ### 20. Event is missing `indexed` fields Each `event` should use three `indexed` fields if there are three or more fields  *There are 5 instances of this issue:* ```solidity File: contracts/Basket.sol  15:       event DepositERC721(address indexed token, uint256 tokenId, address indexed from);  16:       event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);  17:       event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);  18:       event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);  19:       event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L15  
