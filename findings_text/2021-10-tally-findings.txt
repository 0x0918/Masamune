# Handle  leastwood   # Vulnerability details  ## Impact  `Swap.sol` inherits OpenZeppelin's `Ownable` contract which enables the `onlyOwner` role to transfer ownership to another address. It's possible that the `onlyOwner` role mistakenly transfers ownership to the wrong address, resulting in a loss of the `onlyOwner` role.  ## Proof of Concept  https://github.com/code-423n4/2021-10-tally/blob/main/contracts/governance/EmergencyGovernable.sol https://github.com/code-423n4/2021-10-tally/blob/main/contracts/swap/Swap.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider overriding the `transferOwnership()` function to first nominate an address as the pending owner and implementing an `acceptOwnership()` function which is called by the pending owner to confirm the transfer. Alternatively, as the `onlyOwner` role is not used throughout the contract, it may be useful to remove this contract entirely from the `EmergencyGovernable.sol` contract.  
# Handle  pants   # Vulnerability details  This line in `Swap.setSwapFee()` perfoms an `SLOAD` operation for a value that is already stored in a local variable: ``` emit NewSwapFee(swapFee); ```  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Use the already existing local variable instead of loading this value from storage: ``` emit NewSwapFee(swapFee_); ```  
# Handle  cmichel   # Vulnerability details  The `Math` library uses Solidity version 0.8 which comes with built-in overflow checks which cost gas.  The code already checks for underflows (`a > b` before doing the division), and therefore the built-in checks can be disabled everywhere for improved gas cost.  ```solidity pragma solidity ^0.8.0;  library Math {     function subOrZero(uint256 a, uint256 b) internal pure returns (uint256) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint128 a, uint128 b) internal pure returns (uint128) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint64 a, uint64 b) internal pure returns (uint64) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint32 a, uint32 b) internal pure returns (uint32) {       unchecked {         return a > b ? a - b : 0;       }     } } ```  
# Handle  cmichel   # Vulnerability details  The `Swap` contract uses Solidity version 0.8 which already implements overflow checks by default. At the same time, it uses the `SafeMath` library which is more gas expensive than the 0.8 overflow checks.  It should just use the built-in checks and remove `SafeMath` from the dependencies:  ```solidity // @audit can just normal arithmetic here uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);  // uint256 toTransfer = (SWAP_FEE_DIVISOR - swapFee) * boughtERC20Amount / SWAP_FEE_DIVISOR;  // same with many other computations ```  
# Handle  cmichel   # Vulnerability details  The `minimumAmountReceived` check in `Swap.swapByQuote` is implemented like this:  ```solidity require(     (         !signifiesETHOrZero(zrxBuyTokenAddress) &&         boughtERC20Amount >= minimumAmountReceived     ) ||     (         signifiesETHOrZero(zrxBuyTokenAddress) &&         boughtETHAmount >= minimumAmountReceived     ),     "Swap::swapByQuote: Minimum swap proceeds requirement not met" ); ```  It can be simplified to this which performs less calls to `signifiesETHOrZero` and less logical operators:  ```solidity require( (signifiesETHOrZero(zrxBuyTokenAddress) ? boughtETHAmount : boughtERC20Amount) >= minimumAmountReceived, "..."); ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L212  ```solidity function fillZrxQuote(     IERC20 zrxBuyTokenAddress,     address payable zrxTo,     bytes calldata zrxData,     uint256 ethAmount ) internal returns (uint256, uint256) {     uint256 originalERC20Balance = 0;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));     }     uint256 originalETHBalance = address(this).balance;      (bool success,) = zrxTo.call{value: ethAmount}(zrxData); ```  A call to an arbitrary contract with custom calldata is made in `fillZrxQuote()`, which means the contract can be an ERC20 token, and the calldata can be `transferFrom` a previously approved user.  ### Impact  The wallet balances (for the amount up to the allowance limit) of the tokens that users approved to the contract can be stolen.  ### PoC  Given:  - Alice has approved 1000 WETH to `Swap.sol`;  The attacker can:  ``` TallySwap.swapByQuote(     address(WETH),     0,     address(WETH),     0,     address(0),     address(WETH),     abi.encodeWithSignature(         "transferFrom(address,address,uint256)",         address(Alice),         address(this),         1000 ether     ) ) ```  As a result, 1000 WETH will be stolen from Alice and sent to the attacker.  This PoC has been tested on a forking network.  ### Recommendation  Consider adding a whitelist for `zrxTo` addresses.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L225  ```solidity function fillZrxQuote(     IERC20 zrxBuyTokenAddress,     address payable zrxTo,     bytes calldata zrxData,     uint256 ethAmount ) internal returns (uint256, uint256) {     uint256 originalERC20Balance = 0;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));     }     uint256 originalETHBalance = address(this).balance;      (bool success,) = zrxTo.call{value: ethAmount}(zrxData);     require(success, "Swap::fillZrxQuote: Failed to fill quote");      uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);     uint256 erc20Delta;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);         require(erc20Delta > 0, "Swap::fillZrxQuote: Didn't receive bought token");     } else {         require(ethDelta > 0, "Swap::fillZrxQuote: Didn't receive bought ETH");     }      return (erc20Delta, ethDelta); } ```  When a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215, `ethDelta` will always be `0`.   That's because `originalETHBalance` already includes the `msg.value` sent by the caller.  Let's say the ETH balance of the contract is `1 ETH` before the swap.  - A user swaps `10 ETH` to USDC; - `originalETHBalance` will be `11 ETH`; - If there is `1 ETH` of refund; - `ethDelta` will be `0` as the new balance is `2 ETH` and `subOrZero(2, 11)` is `0`.  Similarly, `erc20Delta` is also computed wrong.  Consider a special case of a user trying to arbitrage from `WBTC` to `WBTC`, the `originalERC20Balance` already includes the input amount, `erc20Delta` will always be much lower than the actual delta amount.  For example, for an arb swap from `1 WBTC` to `1.1 WBTC`, the `ethDelta` will be `0.1 WBTC` while it should be `1.1 WBTC`.  ### Impact  - User can not get ETH refund for swaps from ETH to ERC20 tokens; - Arb swap with the same input and output token will suffer the loss of almost all of their input amount unexpectedly.  ### Recommendation  Consider subtracting the input amount from the originalBalance.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L174-L180  ```solidity emit SwappedTokens(     zrxSellTokenAddress,     zrxBuyTokenAddress,     amountToSell,     boughtETHAmount,     boughtETHAmount.sub(toTransfer) ); ```  `amountToSell` will be 0 according to the comment: `If selling unwrapped ETH via msg.value, this should be 0.`, therefore, `msg.value` should be used instead.  ### Recommendation  Change to:  ```solidity emit SwappedTokens(     zrxSellTokenAddress,     zrxBuyTokenAddress,     msg.value,     boughtETHAmount,     boughtETHAmount.sub(toTransfer) ); ```  
# Handle  WatchPug   # Vulnerability details  `Swap.sol#constructor()` validates `owner_` but does not validate `swapFee_`. While in `setSwapFee()`, it does validates the input to make sure `swapFee_ < SWAP_FEE_DIVISOR`.  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L51-L58  ```solidity constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {         require(owner_ != address(0), "Swap::constructor: Owner must not be 0");         transferOwnership(owner_);         feeRecipient = feeRecipient_;         emit NewFeeRecipient(feeRecipient);         swapFee = swapFee_;         emit NewSwapFee(swapFee);     } ```  ### Recommendation  Change to:  ```solidity constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {     require(owner_ != address(0), "Swap::constructor: Owner must not be 0");     require(swapFee_ < SWAP_FEE_DIVISOR, "Swap::constructor: Swap fee must not exceed 100%");     transferOwnership(owner_);     feeRecipient = feeRecipient_;     emit NewFeeRecipient(feeRecipient);     swapFee = swapFee_;     emit NewSwapFee(swapFee); } ```  
# Handle  harleythedog   # Vulnerability details  ## Impact In the sweepFees function, address(this).balance is being used as the "amount" in the SweepFees event immediately after a transfer. So, the amount in the event on line 258 will always be 0, but it should be what address(this).balance was before the transfer. This has implications on overall functionality, tools that are monitoring this event will receive incorrect information. A fix is to store the value before calling the transfer.  ## Proof of Concept referenced lines in sweepFees function: https://github.com/code-423n4/2021-10-tally/blob/main/contracts/swap/Swap.sol#:~:text=feeRecipient.transfer(address,this).balance%2C%20feeRecipient)%3B  A more correct implementation would be:  uint256 amount = address(this).balance; feeRecipient.transfer(address(this).balance); emit FeesSwept(address(0), amount, feeRecipient);  ## Tools Used Manual inspection  ## Recommended Mitigation Steps Store balance before calling transfer, as above.  
# Handle  leastwood   # Vulnerability details  ## Impact  `Swap.sol` inherits OpenZeppelin's `Ownable` contract which enables the `onlyOwner` role to transfer ownership to another address. It's possible that the `onlyOwner` role mistakenly transfers ownership to the wrong address, resulting in a loss of the `onlyOwner` role.  ## Proof of Concept  https://github.com/code-423n4/2021-10-tally/blob/main/contracts/governance/EmergencyGovernable.sol https://github.com/code-423n4/2021-10-tally/blob/main/contracts/swap/Swap.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider overriding the `transferOwnership()` function to first nominate an address as the pending owner and implementing an `acceptOwnership()` function which is called by the pending owner to confirm the transfer. Alternatively, as the `onlyOwner` role is not used throughout the contract, it may be useful to remove this contract entirely from the `EmergencyGovernable.sol` contract.  
# Handle  pants   # Vulnerability details  This line in `Swap.setSwapFee()` perfoms an `SLOAD` operation for a value that is already stored in a local variable: ``` emit NewSwapFee(swapFee); ```  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Use the already existing local variable instead of loading this value from storage: ``` emit NewSwapFee(swapFee_); ```  
# Handle  cmichel   # Vulnerability details  The `Math` library uses Solidity version 0.8 which comes with built-in overflow checks which cost gas.  The code already checks for underflows (`a > b` before doing the division), and therefore the built-in checks can be disabled everywhere for improved gas cost.  ```solidity pragma solidity ^0.8.0;  library Math {     function subOrZero(uint256 a, uint256 b) internal pure returns (uint256) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint128 a, uint128 b) internal pure returns (uint128) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint64 a, uint64 b) internal pure returns (uint64) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint32 a, uint32 b) internal pure returns (uint32) {       unchecked {         return a > b ? a - b : 0;       }     } } ```  
# Handle  cmichel   # Vulnerability details  The `Swap` contract uses Solidity version 0.8 which already implements overflow checks by default. At the same time, it uses the `SafeMath` library which is more gas expensive than the 0.8 overflow checks.  It should just use the built-in checks and remove `SafeMath` from the dependencies:  ```solidity // @audit can just normal arithmetic here uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);  // uint256 toTransfer = (SWAP_FEE_DIVISOR - swapFee) * boughtERC20Amount / SWAP_FEE_DIVISOR;  // same with many other computations ```  
# Handle  cmichel   # Vulnerability details  The `minimumAmountReceived` check in `Swap.swapByQuote` is implemented like this:  ```solidity require(     (         !signifiesETHOrZero(zrxBuyTokenAddress) &&         boughtERC20Amount >= minimumAmountReceived     ) ||     (         signifiesETHOrZero(zrxBuyTokenAddress) &&         boughtETHAmount >= minimumAmountReceived     ),     "Swap::swapByQuote: Minimum swap proceeds requirement not met" ); ```  It can be simplified to this which performs less calls to `signifiesETHOrZero` and less logical operators:  ```solidity require( (signifiesETHOrZero(zrxBuyTokenAddress) ? boughtETHAmount : boughtERC20Amount) >= minimumAmountReceived, "..."); ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L212  ```solidity function fillZrxQuote(     IERC20 zrxBuyTokenAddress,     address payable zrxTo,     bytes calldata zrxData,     uint256 ethAmount ) internal returns (uint256, uint256) {     uint256 originalERC20Balance = 0;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));     }     uint256 originalETHBalance = address(this).balance;      (bool success,) = zrxTo.call{value: ethAmount}(zrxData); ```  A call to an arbitrary contract with custom calldata is made in `fillZrxQuote()`, which means the contract can be an ERC20 token, and the calldata can be `transferFrom` a previously approved user.  ### Impact  The wallet balances (for the amount up to the allowance limit) of the tokens that users approved to the contract can be stolen.  ### PoC  Given:  - Alice has approved 1000 WETH to `Swap.sol`;  The attacker can:  ``` TallySwap.swapByQuote(     address(WETH),     0,     address(WETH),     0,     address(0),     address(WETH),     abi.encodeWithSignature(         "transferFrom(address,address,uint256)",         address(Alice),         address(this),         1000 ether     ) ) ```  As a result, 1000 WETH will be stolen from Alice and sent to the attacker.  This PoC has been tested on a forking network.  ### Recommendation  Consider adding a whitelist for `zrxTo` addresses.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L225  ```solidity function fillZrxQuote(     IERC20 zrxBuyTokenAddress,     address payable zrxTo,     bytes calldata zrxData,     uint256 ethAmount ) internal returns (uint256, uint256) {     uint256 originalERC20Balance = 0;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));     }     uint256 originalETHBalance = address(this).balance;      (bool success,) = zrxTo.call{value: ethAmount}(zrxData);     require(success, "Swap::fillZrxQuote: Failed to fill quote");      uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);     uint256 erc20Delta;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);         require(erc20Delta > 0, "Swap::fillZrxQuote: Didn't receive bought token");     } else {         require(ethDelta > 0, "Swap::fillZrxQuote: Didn't receive bought ETH");     }      return (erc20Delta, ethDelta); } ```  When a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215, `ethDelta` will always be `0`.   That's because `originalETHBalance` already includes the `msg.value` sent by the caller.  Let's say the ETH balance of the contract is `1 ETH` before the swap.  - A user swaps `10 ETH` to USDC; - `originalETHBalance` will be `11 ETH`; - If there is `1 ETH` of refund; - `ethDelta` will be `0` as the new balance is `2 ETH` and `subOrZero(2, 11)` is `0`.  Similarly, `erc20Delta` is also computed wrong.  Consider a special case of a user trying to arbitrage from `WBTC` to `WBTC`, the `originalERC20Balance` already includes the input amount, `erc20Delta` will always be much lower than the actual delta amount.  For example, for an arb swap from `1 WBTC` to `1.1 WBTC`, the `ethDelta` will be `0.1 WBTC` while it should be `1.1 WBTC`.  ### Impact  - User can not get ETH refund for swaps from ETH to ERC20 tokens; - Arb swap with the same input and output token will suffer the loss of almost all of their input amount unexpectedly.  ### Recommendation  Consider subtracting the input amount from the originalBalance.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L174-L180  ```solidity emit SwappedTokens(     zrxSellTokenAddress,     zrxBuyTokenAddress,     amountToSell,     boughtETHAmount,     boughtETHAmount.sub(toTransfer) ); ```  `amountToSell` will be 0 according to the comment: `If selling unwrapped ETH via msg.value, this should be 0.`, therefore, `msg.value` should be used instead.  ### Recommendation  Change to:  ```solidity emit SwappedTokens(     zrxSellTokenAddress,     zrxBuyTokenAddress,     msg.value,     boughtETHAmount,     boughtETHAmount.sub(toTransfer) ); ```  
# Handle  WatchPug   # Vulnerability details  `Swap.sol#constructor()` validates `owner_` but does not validate `swapFee_`. While in `setSwapFee()`, it does validates the input to make sure `swapFee_ < SWAP_FEE_DIVISOR`.  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L51-L58  ```solidity constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {         require(owner_ != address(0), "Swap::constructor: Owner must not be 0");         transferOwnership(owner_);         feeRecipient = feeRecipient_;         emit NewFeeRecipient(feeRecipient);         swapFee = swapFee_;         emit NewSwapFee(swapFee);     } ```  ### Recommendation  Change to:  ```solidity constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {     require(owner_ != address(0), "Swap::constructor: Owner must not be 0");     require(swapFee_ < SWAP_FEE_DIVISOR, "Swap::constructor: Swap fee must not exceed 100%");     transferOwnership(owner_);     feeRecipient = feeRecipient_;     emit NewFeeRecipient(feeRecipient);     swapFee = swapFee_;     emit NewSwapFee(swapFee); } ```  
# Handle  harleythedog   # Vulnerability details  ## Impact In the sweepFees function, address(this).balance is being used as the "amount" in the SweepFees event immediately after a transfer. So, the amount in the event on line 258 will always be 0, but it should be what address(this).balance was before the transfer. This has implications on overall functionality, tools that are monitoring this event will receive incorrect information. A fix is to store the value before calling the transfer.  ## Proof of Concept referenced lines in sweepFees function: https://github.com/code-423n4/2021-10-tally/blob/main/contracts/swap/Swap.sol#:~:text=feeRecipient.transfer(address,this).balance%2C%20feeRecipient)%3B  A more correct implementation would be:  uint256 amount = address(this).balance; feeRecipient.transfer(address(this).balance); emit FeesSwept(address(0), amount, feeRecipient);  ## Tools Used Manual inspection  ## Recommended Mitigation Steps Store balance before calling transfer, as above.  
# Handle  leastwood   # Vulnerability details  ## Impact  `Swap.sol` inherits OpenZeppelin's `Ownable` contract which enables the `onlyOwner` role to transfer ownership to another address. It's possible that the `onlyOwner` role mistakenly transfers ownership to the wrong address, resulting in a loss of the `onlyOwner` role.  ## Proof of Concept  https://github.com/code-423n4/2021-10-tally/blob/main/contracts/governance/EmergencyGovernable.sol https://github.com/code-423n4/2021-10-tally/blob/main/contracts/swap/Swap.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider overriding the `transferOwnership()` function to first nominate an address as the pending owner and implementing an `acceptOwnership()` function which is called by the pending owner to confirm the transfer. Alternatively, as the `onlyOwner` role is not used throughout the contract, it may be useful to remove this contract entirely from the `EmergencyGovernable.sol` contract.  
# Handle  pants   # Vulnerability details  This line in `Swap.setSwapFee()` perfoms an `SLOAD` operation for a value that is already stored in a local variable: ``` emit NewSwapFee(swapFee); ```  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Use the already existing local variable instead of loading this value from storage: ``` emit NewSwapFee(swapFee_); ```  
# Handle  cmichel   # Vulnerability details  The `Math` library uses Solidity version 0.8 which comes with built-in overflow checks which cost gas.  The code already checks for underflows (`a > b` before doing the division), and therefore the built-in checks can be disabled everywhere for improved gas cost.  ```solidity pragma solidity ^0.8.0;  library Math {     function subOrZero(uint256 a, uint256 b) internal pure returns (uint256) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint128 a, uint128 b) internal pure returns (uint128) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint64 a, uint64 b) internal pure returns (uint64) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint32 a, uint32 b) internal pure returns (uint32) {       unchecked {         return a > b ? a - b : 0;       }     } } ```  
# Handle  cmichel   # Vulnerability details  The `Swap` contract uses Solidity version 0.8 which already implements overflow checks by default. At the same time, it uses the `SafeMath` library which is more gas expensive than the 0.8 overflow checks.  It should just use the built-in checks and remove `SafeMath` from the dependencies:  ```solidity // @audit can just normal arithmetic here uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);  // uint256 toTransfer = (SWAP_FEE_DIVISOR - swapFee) * boughtERC20Amount / SWAP_FEE_DIVISOR;  // same with many other computations ```  
# Handle  cmichel   # Vulnerability details  The `minimumAmountReceived` check in `Swap.swapByQuote` is implemented like this:  ```solidity require(     (         !signifiesETHOrZero(zrxBuyTokenAddress) &&         boughtERC20Amount >= minimumAmountReceived     ) ||     (         signifiesETHOrZero(zrxBuyTokenAddress) &&         boughtETHAmount >= minimumAmountReceived     ),     "Swap::swapByQuote: Minimum swap proceeds requirement not met" ); ```  It can be simplified to this which performs less calls to `signifiesETHOrZero` and less logical operators:  ```solidity require( (signifiesETHOrZero(zrxBuyTokenAddress) ? boughtETHAmount : boughtERC20Amount) >= minimumAmountReceived, "..."); ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L212  ```solidity function fillZrxQuote(     IERC20 zrxBuyTokenAddress,     address payable zrxTo,     bytes calldata zrxData,     uint256 ethAmount ) internal returns (uint256, uint256) {     uint256 originalERC20Balance = 0;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));     }     uint256 originalETHBalance = address(this).balance;      (bool success,) = zrxTo.call{value: ethAmount}(zrxData); ```  A call to an arbitrary contract with custom calldata is made in `fillZrxQuote()`, which means the contract can be an ERC20 token, and the calldata can be `transferFrom` a previously approved user.  ### Impact  The wallet balances (for the amount up to the allowance limit) of the tokens that users approved to the contract can be stolen.  ### PoC  Given:  - Alice has approved 1000 WETH to `Swap.sol`;  The attacker can:  ``` TallySwap.swapByQuote(     address(WETH),     0,     address(WETH),     0,     address(0),     address(WETH),     abi.encodeWithSignature(         "transferFrom(address,address,uint256)",         address(Alice),         address(this),         1000 ether     ) ) ```  As a result, 1000 WETH will be stolen from Alice and sent to the attacker.  This PoC has been tested on a forking network.  ### Recommendation  Consider adding a whitelist for `zrxTo` addresses.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L225  ```solidity function fillZrxQuote(     IERC20 zrxBuyTokenAddress,     address payable zrxTo,     bytes calldata zrxData,     uint256 ethAmount ) internal returns (uint256, uint256) {     uint256 originalERC20Balance = 0;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));     }     uint256 originalETHBalance = address(this).balance;      (bool success,) = zrxTo.call{value: ethAmount}(zrxData);     require(success, "Swap::fillZrxQuote: Failed to fill quote");      uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);     uint256 erc20Delta;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);         require(erc20Delta > 0, "Swap::fillZrxQuote: Didn't receive bought token");     } else {         require(ethDelta > 0, "Swap::fillZrxQuote: Didn't receive bought ETH");     }      return (erc20Delta, ethDelta); } ```  When a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215, `ethDelta` will always be `0`.   That's because `originalETHBalance` already includes the `msg.value` sent by the caller.  Let's say the ETH balance of the contract is `1 ETH` before the swap.  - A user swaps `10 ETH` to USDC; - `originalETHBalance` will be `11 ETH`; - If there is `1 ETH` of refund; - `ethDelta` will be `0` as the new balance is `2 ETH` and `subOrZero(2, 11)` is `0`.  Similarly, `erc20Delta` is also computed wrong.  Consider a special case of a user trying to arbitrage from `WBTC` to `WBTC`, the `originalERC20Balance` already includes the input amount, `erc20Delta` will always be much lower than the actual delta amount.  For example, for an arb swap from `1 WBTC` to `1.1 WBTC`, the `ethDelta` will be `0.1 WBTC` while it should be `1.1 WBTC`.  ### Impact  - User can not get ETH refund for swaps from ETH to ERC20 tokens; - Arb swap with the same input and output token will suffer the loss of almost all of their input amount unexpectedly.  ### Recommendation  Consider subtracting the input amount from the originalBalance.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L174-L180  ```solidity emit SwappedTokens(     zrxSellTokenAddress,     zrxBuyTokenAddress,     amountToSell,     boughtETHAmount,     boughtETHAmount.sub(toTransfer) ); ```  `amountToSell` will be 0 according to the comment: `If selling unwrapped ETH via msg.value, this should be 0.`, therefore, `msg.value` should be used instead.  ### Recommendation  Change to:  ```solidity emit SwappedTokens(     zrxSellTokenAddress,     zrxBuyTokenAddress,     msg.value,     boughtETHAmount,     boughtETHAmount.sub(toTransfer) ); ```  
# Handle  WatchPug   # Vulnerability details  `Swap.sol#constructor()` validates `owner_` but does not validate `swapFee_`. While in `setSwapFee()`, it does validates the input to make sure `swapFee_ < SWAP_FEE_DIVISOR`.  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L51-L58  ```solidity constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {         require(owner_ != address(0), "Swap::constructor: Owner must not be 0");         transferOwnership(owner_);         feeRecipient = feeRecipient_;         emit NewFeeRecipient(feeRecipient);         swapFee = swapFee_;         emit NewSwapFee(swapFee);     } ```  ### Recommendation  Change to:  ```solidity constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {     require(owner_ != address(0), "Swap::constructor: Owner must not be 0");     require(swapFee_ < SWAP_FEE_DIVISOR, "Swap::constructor: Swap fee must not exceed 100%");     transferOwnership(owner_);     feeRecipient = feeRecipient_;     emit NewFeeRecipient(feeRecipient);     swapFee = swapFee_;     emit NewSwapFee(swapFee); } ```  
# Handle  harleythedog   # Vulnerability details  ## Impact In the sweepFees function, address(this).balance is being used as the "amount" in the SweepFees event immediately after a transfer. So, the amount in the event on line 258 will always be 0, but it should be what address(this).balance was before the transfer. This has implications on overall functionality, tools that are monitoring this event will receive incorrect information. A fix is to store the value before calling the transfer.  ## Proof of Concept referenced lines in sweepFees function: https://github.com/code-423n4/2021-10-tally/blob/main/contracts/swap/Swap.sol#:~:text=feeRecipient.transfer(address,this).balance%2C%20feeRecipient)%3B  A more correct implementation would be:  uint256 amount = address(this).balance; feeRecipient.transfer(address(this).balance); emit FeesSwept(address(0), amount, feeRecipient);  ## Tools Used Manual inspection  ## Recommended Mitigation Steps Store balance before calling transfer, as above.  
