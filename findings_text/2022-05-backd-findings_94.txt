# QA  ## Use unchecked lib  ### `PoolMigrationZap.sol`  #### Enforce pattern on loops You can add the unchecked math lib like you do on the others contracts to safely increment the `i` var, saving gas and make contract consistent with the others by enforcing the same style.  On [`PoolMigrationZap.sol#L39-L44`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L39-L44) you are doing a unchecked increment in the loop, but in the rest of the code you a different pattern. Add the unchecked math lib and change: ```solidity         for (uint256 i; i < oldPoolAddresses_.length; ) {             migrate(oldPoolAddresses_[i]);             unchecked {                 ++i;             }         } ``` To; ```solidity         for (uint256 i; i < oldPoolAddresses_.length; i = i.uncheckedInc()) {             migrate(oldPoolAddresses_[i]);         } ```  #### `_underlyingNewPools` can end with a wrong data  If `underlying_` is `address(0)` then `_underlyingNewPools[address(0)]` will be fill...  Consider change lines [`PoolMigrationZap.sol#L26-L27`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L26-L27) from: ```solidity             _underlyingNewPools[underlying_] = newPool_;             if (underlying_ == address(0)) continue; ``` To: ```solidity             if (underlying_ == address(0)) continue;             _underlyingNewPools[underlying_] = newPool_; ```  ## `ConvexStrategyBase.sol`  ### Change var name to avoid shadow  On line [L287](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/strategies/ConvexStrategyBase.sol#L287) you are declaring variable with the same name, i understang that is for caching, but i recommend to change the variable name, consider changing this; ```solidity         address _swapperRouter = address(_swapperRouter);         IERC20(token_).safeApprove(_swapperRouter, 0);         IERC20(token_).safeApprove(_swapperRouter, type(uint256).max); ``` To this; ```solidity         address swapperRouter_ = address(_swapperRouter);         IERC20(token_).safeApprove(swapperRouter_, 0);         IERC20(token_).safeApprove(swapperRouter_, type(uint256).max); ```  ## `LiquidityPool.sol`  ### Add check before calling `safeApprove`  In think you will need a check before doing the safeApprove call on [LiquidityPool.sol#L700](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/pool/LiquidityPool.sol#L700) Just replace; ```solidity  IERC20(lpToken_).safeApprove(staker_, type(uint256).max); ``` With  ```solidity if (IERC20(lpToken_).allowance(staker_, spender) > 0) return; IERC20(lpToken_).safeApprove(staker_, type(uint256).max); ```  _keeperGauge  ## Missing event emission  Critical function dont emit events; [`InflationManager.sol#L58-L63:setMinter`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L58-L63) [InflationManager.sol#L89:deactivateWeightBasedKeeperDistribution](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L89)  
