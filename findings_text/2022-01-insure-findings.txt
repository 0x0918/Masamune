# Handle  Dravee   # Vulnerability details  ## Impact Checking if the value is 0 before returning 0 is less expensive than returning a calculation that's equal to 0  ## Proof of Concept In `PoolTemplate.sol:rate()`, the code is as follows: ``` File: PoolTemplate.sol 744:     function rate() external view returns (uint256) { 745:         if (totalSupply() > 0) { 746:             return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); 747:         } else { 748:             return 0; 749:         } 750:     }  ``` It can be optimized as such: ``` 744:     function rate() external view returns (uint256) { 745:         uint256 originalLiquidity = originalLiquidity(); 746:         if (originalLiquidity != 0 && totalSupply() > 0) { 747:             return (originalLiquidity * MAGIC_SCALE_1E6) / totalSupply(); 748:         } else { 749:             return 0; 750:         } 751:     }  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable and make the 0 checks to avoid unnecessary calculations if `originalLiquidity() == 0`  
# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `PoolTemplate.sol:worth()`, the code is as follows: ``` 799:     function worth(uint256 _value) public view returns (uint256 _amount) { 800:         uint256 _supply = totalSupply(); 801:         uint256 _originalLiquidity = originalLiquidity(); 802:         if (_supply > 0 && _originalLiquidity > 0) { 803:             _amount = (_value * _supply) / _originalLiquidity; 804:         } else if (_supply > 0 && _originalLiquidity == 0) { 805:             _amount = _value * _supply; 806:         } else { 807:             _amount = _value; 808:         } 809:     } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for further information): ```     function worth(uint256 _value) public view returns (uint256 _amount) {         uint256 _supply = totalSupply();         uint256 _originalLiquidity = originalLiquidity();         if (_supply == 0) {             _amount = _value;         } else if (_originalLiquidity == 0) {             _amount = _value * _supply;         } else {             _amount = (_value * _supply) / _originalLiquidity;         }     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements   
# Handle  pauliax   # Vulnerability details  ## Impact In IndexTemplate, function compensate, When _amount > _value, and <= totalLiquidity(), the value of _compensated is not set, so it gets a default value of 0: ```solidity if (_value >= _amount) {     ...     _compensated = _amount; } else {     ...     if (totalLiquidity() < _amount) {         ...         _compensated = _value + _cds;     }     vault.offsetDebt(_compensated, msg.sender); } ```  But nevertheless, in both cases, it calls vault.offsetDebt, even when the _compensated is 0 (no else block).  ## Recommended Mitigation Steps I think, in this case, it should try to redeem the premium (withdrawCredit?) to cover the whole amount, but I am not sure about the intentions as I didn't have enough time to understand this protocol in depth.  
# Handle  Dravee   # Vulnerability details  ## Impact The transactions could fail if the array get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L703  ## Tools Used VS Code  ## Recommended Mitigation Steps Keep the array size small.  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 MSTORE and 1 MLOAD)  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L553 There's no readability or gas gain from copying `incident.payoutDenominator` to a variable as it's used only once in the method.  ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 MSTORE and 1 MLOAD)  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L552 There's no readability or gas gain from copying `incident.payoutNumerator` to a variable as it's used only once in the method.  ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable  
# Handle  Dravee   # Vulnerability details  ## Impact Checking if the value is 0 before returning 0 is less expensive than returning a calculation that's equal to 0  ## Proof of Concept In `Vault.sol:underlyingValue()`, the code is as follows: ``` Vault.sol 400:     function underlyingValue(address _target) 401:         public 402:         view 403:         override 404:         returns (uint256) 405:     { 406:         if (attributions[_target] > 0) { 407:             return (valueAll() * attributions[_target]) / totalAttributions; 408:         } else { 409:             return 0; 410:         } 411:     } ``` It can be optimized as such:  ``` 406:         uint256 valueAll = valueAll(); 407:         if (valueAll != 0 && attributions[_target] > 0) { 408:             return (valueAll * attributions[_target]) / totalAttributions; 409:         } else { 410:             return 0; 411:         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable and make the 0 checks to avoid unnecessary calculations if `valueAll() == 0`  
# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `attributions[_target]` can be loaded twice from storage: ``` Vault.sol 400:     function underlyingValue(address _target) 401:         public 402:         view 403:         override 404:         returns (uint256) 405:     { 406:         if (attributions[_target] > 0) { 407:             return (valueAll() * attributions[_target]) / totalAttributions; 408:         } else { 409:             return 0; 410:         } 411:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable  
# Handle  pauliax   # Vulnerability details  ## Impact There are some issues with comments/documentation, e.g.: Misleading comment: ```solidity    * @return true if the id within the market already exists   function getCDS(address _address) external view override returns (address) ``` No such function (present in documentation): ```solidity   function getInsuranceCount(address _user) ``` "getInsuranceCount returns how many insurance policies the specified user has."  ## Recommended Mitigation Steps Consider revisiting and updating discrepancies between the documentation and comments.  
# Handle  Kumpirmafyas   # Vulnerability details  ## Impact The order of the "struct Template" in the Factory.sol contract is as follows: 1-bool isOpen 2-bool approval 3-bool allowDuplicate https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L44-L48   The struct above is used in functions as value, in the "key=>value" part in this mapping. https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L49  When using "template" mapping in this function, it is not done in the defined order, Detail: - isOpen bool , defined in Struct in the 1st row, -isOpen bool ,defined in the 1st position in Mapping, naturally -isOpen bool is defined in the 2nd row in the "approveTemplate" function below. -The same applies to the approvel bool struct.  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L101-L103   The problem here is; The order in which Structs are used in a Function is not. Problem ; The order of the structs in the "key => value" mapping definition affects the function. Sequencing is important in struct definition in mappings.   ## Recommended Mitigation Steps The order in the struct = the order in the mapping = the order in the function must be the same.  Here ; Sorting in Mapping with Struct is a mandatory condition, while sorting in a function is within the scope of clean code.  
# Handle  pauliax   # Vulnerability details  ## Impact Statements should be ordered in a way that it costs less gas, that is, less operations are performed when the validating conditions are wrong. e.g. this can be reordered: ```solidity   //Distribute premium and fee   uint256 _endTime = _span + block.timestamp;   uint256 _premium = getPremium(_amount, _span);   uint256 _fee = parameters.getFeeRate(msg.sender);    require(       _amount <= availableBalance(),       "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"   );   require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");   require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");   require(       parameters.getMinDate(msg.sender) <= _span,       "ERROR: INSURE_SPAN_BELOW_MIN"   );    require(       marketStatus == MarketStatus.Trading,       "ERROR: INSURE_MARKET_PENDING"   );   require(paused == false, "ERROR: INSURE_MARKET_PAUSED"); ``` to something like this: ```solidity   require(paused == false, "ERROR: INSURE_MARKET_PAUSED");   require(       marketStatus == MarketStatus.Trading,       "ERROR: INSURE_MARKET_PENDING"   );    require(       _amount <= availableBalance(),       "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"   );    require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");   require(       parameters.getMinDate(msg.sender) <= _span,       "ERROR: INSURE_SPAN_BELOW_MIN"   );    //Distribute premium and fee   uint256 _premium = getPremium(_amount, _span);   require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");    uint256 _endTime = _span + block.timestamp;   uint256 _fee = parameters.getFeeRate(msg.sender); ```  
# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `_fee[_target]` can be loaded twice from storage: ``` 271:     function getFeeRate(address _target) 272:         external 273:         view 274:         override 275:         returns (uint256) 276:     { 277:         if (_fee[_target] == 0) { 278:             return _fee[address(0)]; 279:         } else { 280:             return _fee[_target]; 281:         } 282:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the storage reading in a memory variable  
# Handle  gzeon   # Vulnerability details  ## Impact Use unchecked for safe math to save gas, for example: https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PremiumModels/BondingPremium.sol#L176 ```         premiumRate = premiumRate / T_1 / (u1 - u2) / BASE; ``` Since we have 1) T_1 != 0 (L229) 2) (u1 - u2) != 0 (L126-132) 3) BASE != 0 (L28) we can safely wrap this line in an unchecked block  
# Handle  pauliax   # Vulnerability details  ## Impact _withdrawAttribution should validate that _to is not an empty address 0x0 to prevent accidental burns. Similarly, transferValue _destination param and withdrawValue _to param should also be checked against an empty address unless this is the intended functionality in some cases.  ## Recommended Mitigation Steps require _to != address(0)  
# Handle  Dravee   # Vulnerability details  ## Impact  Division by 0 or functionally incorrect `targetLev`  ## POC A division by `targetLev` is made here : https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L306 and `targetLev` can be set to 0 : https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L575  ## Tools Used VS Code  ## Recommended Mitigation Steps Either make a check on `targetLev` before setting it here: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L575 or make a check before the division here: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L306   
# Handle  pauliax   # Vulnerability details  ## Impact Can be refactored, from this: ```solidity   require(       request.timestamp +           parameters.getLockup(msg.sender) <           block.timestamp,       "ERROR: WITHDRAWAL_QUEUE"   );   require(       request.timestamp +           parameters.getLockup(msg.sender) +           parameters.getWithdrawable(msg.sender) >           block.timestamp,       "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"   ); ``` to this: ```solidity   uint256 unlocksAt = request.timestamp + parameters.getLockup(msg.sender);   require(       unlocksAt < block.timestamp,       "ERROR: WITHDRAWAL_QUEUE"   );   require(       unlocksAt + parameters.getWithdrawable(msg.sender) > block.timestamp,       "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"   ); ```  There are more places where this optimization could be applied besides the provided example, but the basic idea is to cache the result of repeated math operation when the value does not change.  
# Handle  pauliax   # Vulnerability details  ## Impact function repayDebt could be refactored to reduce deployment and operational costs from this: ```solidity   uint256 _debt = debts[_target];   if (_debt >= _amount) {       debts[_target] -= _amount;       totalDebt -= _amount;       IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);   } else {       debts[_target] = 0;       totalDebt -= _debt;       IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);   } ``` to this: ```solidity   uint256 _debt = debts[_target];   if (_debt > _amount) {       debts[_target] = _debt - _amount;   } else {       debts[_target] = 0;       _amount = _debt;   }   totalDebt -= _amount;   IERC20(token).safeTransferFrom(msg.sender, address(this), _amount); ```  
# Handle  pauliax   # Vulnerability details  ## Impact Repeated storage read should be cached, e.g. attributions[_target] is read from storage twice: ```solidity         if (attributions[_target] > 0) {             return (valueAll() * attributions[_target]) / totalAttributions; ``` totalAttributions read twice: ```solidity         if (totalAttributions > 0 && _attribution > 0) {             return (_attribution * valueAll()) / totalAttributions; ``` available() called twice: ```solidity         if (available() < _retVal) {             uint256 _shortage = _retVal - available(); ``` would be cheaper to use _token from memory here: ```solidity     IERC20(token).safeTransfer(_to, _redundant); ```  There are more places where this optimization could be applied besides the provided examples, but the basic idea is to cache storage variables if you need to access them multiple times when the value does not change.  
# Handle  pauliax   # Vulnerability details  ## Impact Avoid repeated external calls, e.g. here token balanceOf is queried 4 times: ```solidity if (     ...     balance < IERC20(token).balanceOf(address(this)) ) {     uint256 _redundant = IERC20(token).balanceOf(address(this)) - balance;     ... } else if (IERC20(_token).balanceOf(address(this)) > 0) {     IERC20(_token).safeTransfer(         _to,         IERC20(_token).balanceOf(address(this))     ); } ``` You should query it only once and then use the cached value as it doesn't change between the statements.  
# Handle  pauliax   # Vulnerability details  ## Impact You dont need this else block, code can be refactored from this: ```solidity   if (address(controller) != address(0)) {       controller.migrate(address(_controller));       controller = IController(_controller);   } else {       controller = IController(_controller);   } ``` to this: ```solidity   if (address(controller) != address(0)) {       controller.migrate(address(_controller));   }   controller = IController(_controller); ```  
# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `totalLiquidity()` is loaded twice from storage ``` 491:     function leverage() public view returns (uint256 _rate) { 492:         //check current leverage rate 493:         if (totalLiquidity() > 0) { 494:             return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); 495:         } else { 496:             return 0; 497:         } 498:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `totalLiquidity()` in a variable  
# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `IndexTemplate.sol:deposit()`, the code is as follows: ``` 172:         if (_supply > 0 && _totalLiquidity > 0) {   173:             _mintAmount = (_amount * _supply) / _totalLiquidity; 174:         } else if (_supply > 0 && _totalLiquidity == 0) { 175:             //when 176:             _mintAmount = _amount * _supply; 177:         } else { 178:             _mintAmount = _amount; 179:         } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for further information): ```       if (_supply == 0) {           _mintAmount = _amount;       } else if (_totalLiquidity == 0) { // @audit-info : implicit _supply > 0 as above condition is false           _mintAmount = _amount * _supply;       } else { // @audit-info : implicit _supply > 0 and _totalLiquidity > 0 as both the previous conditions are false           _mintAmount = (_amount * _supply) / _totalLiquidity;       } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements   
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost as SSTOREs are very expensive  ## Proof of Concept The code is as follows : ``` 094:     function approveTemplate( 095:         IUniversalMarket _template, 096:         bool _approval, 097:         bool _isOpen, 098:         bool _duplicate 099:     ) external override onlyOwner { 100:         require(address(_template) != address(0)); 101:         templates[address(_template)].approval = _approval; //@audit-info SSTORE 102:         templates[address(_template)].isOpen = _isOpen; //@audit-info SSTORE 103:         templates[address(_template)].allowDuplicate = _duplicate; //@audit-info SSTORE 104:         emit TemplateApproval(_template, _approval, _isOpen, _duplicate); 105:     } ``` As we can see, it's making 3 SSTORE operations, one for each boolean. The code could be optimized as follows to save gas : ```     function approveTemplate(         IUniversalMarket _template,         bool _approval,         bool _isOpen,         bool _duplicate     ) external override onlyOwner {         require(address(_template) != address(0));         Template memory approvedTemplate = new Template(_isOpen, _approval, _duplicate);         templates[address(_template)] = approvedTemplate; //@audit-info only one SSTORE         emit TemplateApproval(_template, _approval, _isOpen, _duplicate);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use a memory `Template ` struct and write in storage only once  
# Handle  Dravee   # Vulnerability details  The spec says the function should be called `approveCondition()` instead of `setCondition`: https://insuredao.gitbook.io/developers/market/factory#approvecondition  While this might still be understood nonetheless as `setCondition` is also mentioned, the spec says that the parameter `_slot` is the `index of the reference array`, whereas the code comment says it's the `index within condition array`: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L133  ## Tools Used VS Code  ## Recommended Mitigation Steps My guess is that the spec should be corrected  
# Handle  Dravee   # Vulnerability details  The spec doesn't match with the comments in the code here:   Code: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L90-L91 Spec: https://insuredao.gitbook.io/developers/market/factory#approvetemplate  Here, the spec doesn't mention `_isOpen` and seem to confuse the `_approval` description with what `_isOpen` should be.  ## Tools Used VS Code  ## Recommended Mitigation Steps My guess is that the spec should be corrected  
# Handle  Dravee   # Vulnerability details  ## Impact A division by 0 could occur  ## Proof of Concept While at some places, a check is made to make sure that `totalSupply() > 0`, it's not consistently the case, such as in the following places:  ``` contracts\CDSTemplate.sol:235:        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply(); contracts\CDSTemplate.sol:318:                _balance * vault.attributionValue(crowdPool) / totalSupply(); contracts\IndexTemplate.sol:216:        _retVal = (_liquidty * _amount) / totalSupply(); contracts\IndexTemplate.sol:530:            return (_balance * totalLiquidity()) / totalSupply(); contracts\PoolTemplate.sol:768:            return (_balance * originalLiquidity()) / totalSupply(); ```  At the following places, the check is indeed made: ``` contracts\IndexTemplate.sol:514:            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); contracts\PoolTemplate.sol:747:            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps If this check is at least made at some places, this means that `totalSupply()` can indeed take a value of 0. Therefore, a check should always be made to prevent the div by 0  
# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `CDSTemplate.sol:deposit()`, the code is as follows: ``` 140:         if (_supply > 0 && _liquidity > 0) {  141:             _mintAmount = (_amount * _supply) / _liquidity; 142:         } else if (_supply > 0 && _liquidity == 0) { 143:             //when vault lose all underwritten asset =  144:             _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again. 145:         } else { 146:             //when _supply == 0, 147:             _mintAmount = _amount; 148:         } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for futher information): ```         if (_supply == 0) {              _mintAmount = _amount;         } else if (_liquidity == 0) { // @audit-info : implicit _supply > 0 as above condition is false             //when vault lose all underwritten asset =              _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.         } else { // @audit-info : implicit _supply > 0 and _liquidity > 0 as both the previous conditions are false             _mintAmount = (_amount * _supply) / _liquidity;         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements  
# Handle  Fitraldys   # Vulnerability details  ## Impact In the https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L157 it is the descriptionof the depoist function, and not the correct description for the fund function.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L156-L173    
# Handle  WatchPug   # Vulnerability details  ## Root Cause  Wrong arithmetic.  ---  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L700-L717  ```solidity uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /             totalLiquidity();     uint256 _actualDeduction;     for (uint256 i = 0; i < indexList.length; i++) {         address _index = indexList[i];         uint256 _credit = indicies[_index].credit;         if (_credit > 0) {             uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /                 _totalCredit;             uint256 _redeemAmount = _divCeil(                 _deductionFromIndex,                 _shareOfIndex             );             _actualDeduction += IIndexTemplate(_index).compensate(                 _redeemAmount             );         }     } ```   ### PoC  - totalLiquidity = 200,000* 10**18; - totalCredit = 100,000 * 10**18; - debt = 10,000 * 10**18;  - [Index Pool 1] Credit = 20,000 * 10**18; - [Index Pool 2] Credit = 30,000 * 10**18;  ``` uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /             totalLiquidity(); // _deductionFromIndex = 10,000 * 10**6 * 10**18;  ```  [Index Pool 1]:  ``` uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;   //  _shareOfIndex = 200000  uint256 _redeemAmount = _divCeil(     _deductionFromIndex,     _shareOfIndex );  // _redeemAmount = 25,000 * 10**18; ```  [Index Pool 2]:  ``` uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;   //  _shareOfIndex = 300000  uint256 _redeemAmount = _divCeil(     _deductionFromIndex,     _shareOfIndex );  // _redeemAmount = 16666666666666666666667 (~ 16,666 * 10**18) ```  In most cases, the transaction will revet on underflow at: ``` uint256 _shortage = _deductionFromIndex /             MAGIC_SCALE_1E6 -             _actualDeduction; ```  In some cases, specific pools will be liable for unfair compensation:  If the CSD is empty, `Index Pool 1` only have `6,000 * 10**18` and `Index Pool 2` only have `4,000 * 10**18`, the `_actualDeduction` will be `10,000 * 10**18`, `_deductionFromPool` will be `0`.   `Index Pool 1` should only pay `1,000 * 10**18`, but actually paid `6,000 * 10**18`, the LPs of `Index Pool 1` now suffer funds loss.  ### Recommendation  Change to:  ```solidity uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) / totalLiquidity(); uint256 _actualDeduction; for (uint256 i = 0; i < indexList.length; i++) {     address _index = indexList[i];     uint256 _credit = indicies[_index].credit;     if (_credit > 0) {         uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /             _totalCredit;         uint256 _redeemAmount = _divCeil(             _deductionFromIndex * _shareOfIndex,             MAGIC_SCALE_1E6 * MAGIC_SCALE_1E6         );         _actualDeduction += IIndexTemplate(_index).compensate(             _redeemAmount         );     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L146-L146  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L95-L95  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L55-L55  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L38-L38  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```  For the constants that should not be `public`, changing them to `private` / `internal` can save some gas. To avoid unnecessary getter functions.  
# Handle  WatchPug   # Vulnerability details  In the current implementation, when an incident is reported for a certain pool, the index pool can still `withdrawCredit()` from the pool, which in the best interest of an index pool, the admin of the index pool is preferred to do so.  This allows the index pool to escape from the responsibility for the risks of invested pools.  Making the LPs of the pool take an unfair share of the responsibility.  ### PoC  - Pool A `totalCredit` = 10,000 - Pool A `rewardPerCredit` = 1  1. [Index Pool 1] allocates 1,000 credits to Pool `A`:  - `totalCredit` = 11,000 - indicies[Index Pool 1] = 1,000  2. After a while, Pool A `rewardPerCredit` has grown to `1.1`, and `applyCover()` has been called, [Index Pool 1] call `withdrawCredit()` get 100 premium  - `totalCredit` = 10,000 - indicies[Index Pool 1] = 0  3. After `pendingEnd`, the pool `resume()`,[ Index Pool 1] will not be paying for the compensation since `credit` is 0.  In our case, [Index Pool 1] earned premium without paying for a part of the compensation.  ### Recommendation  Change to:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L416-L421  ```solidity     function withdrawCredit(uint256 _credit)         external         override         returns (uint256 _pending)     {         require(             marketStatus == MarketStatus.Trading,             "ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS"         );         IndexInfo storage _index = indicies[msg.sender]; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L429-L434  ```solidity function _unutilize(uint256 _amount) internal {     require(address(controller) != address(0), "ERROR_CONTROLLER_NOT_SET");      controller.withdraw(address(this), _amount);     balance += _amount; } ```  ### Recommendation  Can be changed to:  ```solidity function _unutilize(uint256 _amount) internal {     require(address(controller) != address(0), "ERROR_CONTROLLER_NOT_SET");      uint256 beforeBalance = IERC20(token).balanceOf(address(this));     controller.withdraw(address(this), _amount);     uint256 received = IERC20(token).balanceOf(address(this)) - beforeBalance;     require(received >= _amount, "...");     balance += received; } ```   
# Handle  WatchPug   # Vulnerability details  ## Root Cause  Precision loss while converting between `the amount of shares` and `the amount of underlying tokens` back and forth is not handled properly.  ---  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L438-L447  ```solidity uint256 _shortage; if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = _value + _cds; } vault.offsetDebt(_compensated, msg.sender); ```  In the current implementation, when someone tries to resume the market after a pending period ends by calling `PoolTemplate.sol#resume()`, `IndexTemplate.sol#compensate()` will be called internally to make a payout. If the index pool is unable to cover the compensation, the CDS pool will then be used to cover the shortage.  However, while `CDSTemplate.sol#compensate()` takes a parameter for the amount of underlying tokens, it uses `vault.transferValue()` to transfer corresponding `_attributions` (shares) instead of underlying tokens.  Due to precision loss, the `_attributions` transferred in the terms of underlying tokens will most certainly be less than the shortage.  At L444, the contract believes that it's been compensated for `_value + _cds`, which is lower than the actual value, due to precision loss.  At L446, when it calls `vault.offsetDebt(_compensated, msg.sender)`, the tx will revert at `require(underlyingValue(msg.sender) >= _amount)`.  As a result, `resume()` can not be done, and the debt can't be repaid.  ### PoC   Given:  - vault.underlyingValue = 10,000 - vault.valueAll = 30,000 - totalAttributions = 2,000,000 - _amount = 1,010,000  0. _shortage = _amount - vault.underlyingValue = 1,000,000 1. _attributions = (_amount * totalAttributions) / valueAll = 67,333,333 2. actualValueTransfered = (valueAll * _attributions) / totalAttributions = 1009999  **Expected results**: actualValueTransfered = _shortage;  **Actual results**: actualValueTransfered < _shortage.  ## Impact  The precision loss isn't just happening on special numbers, but will most certainly always revert the txs.  This will malfunction the contract as the index pool can not `compensate()`, therefore the pool can not `resume()`. Causing the funds of the LPs of the pool and the index pool to be frozen, and other stakeholders of the same vault will suffer fund loss from an unfair share of the funds compensated before.  ## Recommendation  Change to:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L439-L446  ```solidity if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = vault.underlyingValue(address(this)); } vault.offsetDebt(_compensated, msg.sender); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L485-L496  ```solidity function setController(address _controller) public override onlyOwner {     require(_controller != address(0), "ERROR_ZERO_ADDRESS");      if (address(controller) != address(0)) {         controller.migrate(address(_controller));         controller = IController(_controller);     } else {         controller = IController(_controller);     }      emit ControllerSet(_controller); } ```  `controller.migrate()` is a critical operation, we recommend adding validation for the amount of migrated funds.  ### Recommendation  Can be changed to:  ```solidity function setController(address _controller) public override onlyOwner {     require(_controller != address(0), "ERROR_ZERO_ADDRESS");      if (address(controller) != address(0)) {         uint256 beforeUnderlying = controller.valueAll();         controller.migrate(address(_controller));         require(IController(_controller).valueAll() >= beforeUnderlying, "...");         controller = IController(_controller);     } else {         controller = IController(_controller);     }      emit ControllerSet(_controller); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Ownership.sol#L17-L20  ```solidity constructor() {     _owner = msg.sender;     emit AcceptNewOwnership(_owner); } ```  At L19, the parameter of `AcceptNewOwnership` can use `msg.sender` directly to avoid unnecessary storage read of `_owner` to save some gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Ownership.sol#L65-L71  ```solidity function acceptTransferOwnership() external override onlyFutureOwner {     /***         *@notice Accept a transfer of ownership         */     _owner = _futureOwner;     emit AcceptNewOwnership(_owner); } ```  At L69, `_futureOwner` can use `msg.sender` directly to avoid unnecessary storage read of `_futureOwner` to save some gas.  As `onlyFutureOwner()` ensures that `require(_futureOwner == msg.sender, "...");`.  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L153-L158  ```solidity require(     attributions[msg.sender] > 0 &&         underlyingValue(msg.sender) >= _amount,     "ERROR_WITHDRAW-VALUE_BADCONDITOONS" ); _attributions = (totalAttributions * _amount) / valueAll(); ```  In `Vault#withdrawValue()`, `controller.valueAll()` is called twice:  1. L155 `underlyingValue(msg.sender)` -> `valueAll()` -> `controller.valueAll()`; 1. L158 `valueAll()` ->  `controller.valueAll()`.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L400-L411  ```solidity function underlyingValue(address _target)     public     view     override     returns (uint256) {     if (attributions[_target] > 0) {         return (valueAll() * attributions[_target]) / totalAttributions;     } else {         return 0;     } } ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L417-L423  ```solidity function valueAll() public view returns (uint256) {     if (address(controller) != address(0)) {         return balance + controller.valueAll();     } else {         return balance;     } } ```  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on the function call  ## Proof of Concept  availableBalance calls totalLiquidity() twice:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L835  ## Recommended Mitigation Steps  Save the call result to memory and use it  
# Handle  hyh   # Vulnerability details    ## Impact  `setKeeper` / `utilize` descriptions state that it is controller who is set / can run utilize, while keeper and controller are two separate roles, which don't have to coincide.  I.e. the descriptions now mix up the roles and are confusing this way.  ## Proof of Concept  setKeeper:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L499   utilize:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L339   ## Recommended Mitigation Steps  Update the descriptions to relate to the `keeper` role.   
# Handle  Jujic   # Vulnerability details  ## Impact Insurance struct in `PoolTemplate .sol` can be optimized to reduce 2 storage slot  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L127-L128 ``` struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     } ``` `startTime` and `endTime `store block numbers, and 2^48 is being enough for a very long time. ## Tools Used https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html?highlight=Structs#layout-of-state-variables-in-storage   ## Recommended Mitigation Steps The struct can be changed into: ``` struct Insurance {         uint256 id; //each insuance has their own id         uint48 startTime; //timestamp of starttime         uint48 endTime; //timestamp of endtime         address insured; //the address holds the right to get insured         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         bool status; //true if insurance is not expired or redeemed     } ```   
# Handle  cmichel   # Vulnerability details  The `Vault.withdrawRedundant` has wrong logic that allows the admins to steal the underlying vault token.  ```solidity function withdrawRedundant(address _token, address _to)      external      override      onlyOwner {      if (           _token == address(token) &&           balance < IERC20(token).balanceOf(address(this))      ) {           uint256 _redundant = IERC20(token).balanceOf(address(this)) -                balance;           IERC20(token).safeTransfer(_to, _redundant);      } else if (IERC20(_token).balanceOf(address(this)) > 0) {           // @audit they can rug users. let's say balance == IERC20(token).balanceOf(address(this)) => first if false => transfers out everything           IERC20(_token).safeTransfer(                _to,                IERC20(_token).balanceOf(address(this))           );      } } ```  #### POC - Vault deposits increase as `Vault.addValue` is called and the `balance` increases by `_amount` as well as the actual `IERC20(token).balanceOf(this)`. Note that `balance == IERC20(token).balanceOf(this)` - Admins call `vault.withdrawRedundant(vault.token(), attacker)` which goes into the `else if` branch due to the balance inequality condition being `false`. It will transfer out all `vault.token()` amounts to the attacker.  ## Impact There's a backdoor in the `withdrawRedundant` that allows admins to steal all user deposits.  ## Recommended Mitigation Steps I think the devs wanted this logic from the code instead:  ```solidity function withdrawRedundant(address _token, address _to)      external      override      onlyOwner {      if (           _token == address(token)      ) {           if (balance < IERC20(token).balanceOf(address(this))) {                uint256 _redundant = IERC20(token).balanceOf(address(this)) -                     balance;                IERC20(token).safeTransfer(_to, _redundant);           }      } else if (IERC20(_token).balanceOf(address(this)) > 0) {           IERC20(_token).safeTransfer(                _to,                IERC20(_token).balanceOf(address(this))           );      } } ```   
# Handle  cmichel   # Vulnerability details  Note that the `PoolTemplate.initialize` function, called when creating a market with `Factory.createMarket`, calls a vault function to transfer an initial deposit amount (`conditions[1]`) _from_ the initial depositor (`_references[4]`):  ```solidity // PoolTemplate function initialize(      string calldata _metaData,      uint256[] calldata _conditions,      address[] calldata _references ) external override {      // ...       if (_conditions[1] > 0) {           // @audit vault calls asset.transferFrom(_references[4], vault, _conditions[1])           _depositFrom(_conditions[1], _references[4]);      } }  function _depositFrom(uint256 _amount, address _from)      internal      returns (uint256 _mintAmount) {      require(           marketStatus == MarketStatus.Trading && paused == false,           "ERROR: DEPOSIT_DISABLED"      );      require(_amount > 0, "ERROR: DEPOSIT_ZERO");       _mintAmount = worth(_amount);      // @audit vault calls asset.transferFrom(_from, vault, _amount)      vault.addValue(_amount, _from, address(this));       emit Deposit(_from, _amount, _mintAmount);       //mint iToken      _mint(_from, _mintAmount); } ```  The initial depositor needs to first approve the vault contract for the `transferFrom` to succeed.  An attacker can then frontrun the `Factory.createMarket` transaction with their own market creation (it does not have access restrictions) and create a market _with different parameters_ but still passing in `_conditions[1]=amount` and `_references[4]=victim`.  A market with parameters that the initial depositor did not want (different underlying, old whitelisted registry/parameter contract, etc.) can be created with their tokens and these tokens are essentially lost.  ## Recommended Mitigation Steps Can the initial depositor be set to `Factory.createMarket`'s `msg.sender`, instead of being able to pick a whitelisted one as `_references[4]`?   
# Handle  cmichel   # Vulnerability details  The `Parameters.setLowerSlack/setUpperSlack` functions do not check that the new value does still satisfy the `_lowerSlack <= _upperSlack` condition.  ## Recommended Mitigation Steps Check that `_lowerSlack <= _upperSlack`  is still satisfied in these functions.   
# Handle  cmichel   # Vulnerability details  The `Ownership.acceptTransferOwnership` function does not reset `_futureOwner` to zero.  ## Impact The future owner can repeatedly accept the governance, emitting an `AcceptNewOwnership` event each time, bloating listeners for this event with unnecessary data.  ## Recommended Mitigation Steps Reset `_futureOwner` to zero in `acceptTransferOwnership`.   
# Handle  hubble   # Vulnerability details  Feel free to lower the severity of the issue to Non-critical.  ## Impact Correctness of variable name  ## Proof of Concept File : Parameters.sol    line 39 :    mapping(address => uint256) private _withdawable;   line 153 :         _withdawable[_address] = _target;   line 349-352 :         if (_withdawable[_target] == 0) {             return _withdawable[address(0)];         } else {             return _withdawable[_target];  ## Tools Used Manual review  ## Recommended Mitigation Steps Change typo to _withdrawable   
# Handle  hubble   # Vulnerability details   ## Impact Input validation required for few important parameters as mentioned in the below functions.  ## Proof of Concept File : Parameters.sol    line 120 :     function setUpperSlack(address _address, uint256 _target)           Need to check that the _target value should be less than or equal to 100% (1000)     line 134 :     function setLowerSlack(address _address, uint256 _target)          Need to check that the _target value should be less than or equal to corresponding UpperSlack Value     line 177 :     function setFeeRate(address _address, uint256 _target)           Need to check that the _target value should be less than or equal to 1e6 (1000000)     line 191 :     function setMaxList(address _address, uint256 _target)           Need to check that the _target value should be greater than 1  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require statements with proper value and comments for the respective input fields as given above   
# Handle  hubble   # Vulnerability details   ## Impact Inconsistency in pragma solidity versions in different solidity files.  ## Proof of Concept File : InsureDAOERC20.sol        pragma solidity ^0.8.0;  All other solidity files in the project        pragma solidity 0.8.7;  ## Tools Used Manual review  ## Recommended Mitigation Steps Set the version to 0.8.7 in the InsureDAOERC20.sol file  
# Handle  Jujic   # Vulnerability details  ## Impact The constructor is empty. You should remove constructor to save some gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L21 ``` constructor() {} ```  ## Tools Used  ## Recommended Mitigation Steps Remove unused constructor   
# Handle  WatchPug   # Vulnerability details  Check `marketStatus` before for loops can save gas from unnecessary repeated checks.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L342-L365  ```solidity function unlockBatch(uint256[] calldata _ids) external {     for (uint256 i = 0; i < _ids.length; i++) {         unlock(_ids[i]);     } }  function unlock(uint256 _id) public {     require(         insurances[_id].status == true &&             marketStatus == MarketStatus.Trading &&             insurances[_id].endTime + parameters.getGrace(msg.sender) <             block.timestamp,         "ERROR: UNLOCK_BAD_COINDITIONS"     );     insurances[_id].status == false;      lockedAmount = lockedAmount - insurances[_id].amount;      emit Unlocked(_id, insurances[_id].amount); } ```  ### Recomandation  Change to:  ```solidity function unlockBatch(uint256[] calldata _ids) external {     require(marketStatus == MarketStatus.Trading, "ERROR: UNLOCK_BAD_COINDITIONS")     for (uint256 i = 0; i < _ids.length; i++) {         _unlock(_ids[i]);     } }  function unlock(uint256 _id) external {     require(marketStatus == MarketStatus.Trading, "ERROR: UNLOCK_BAD_COINDITIONS");     _unlock(_id); }  function _unlock(uint256 _id) internal {     require(         insurances[_id].status == true &&             insurances[_id].endTime + parameters.getGrace(msg.sender) <             block.timestamp,         "ERROR: UNLOCK_BAD_COINDITIONS"     );     insurances[_id].status == false;      lockedAmount = lockedAmount - insurances[_id].amount;      emit Unlocked(_id, insurances[_id].amount); } ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L260-L270  ```solidity if (_available >= _amount) {     _compensated = _amount;     _attributionLoss = vault.transferValue(_amount, msg.sender);     emit Compensated(msg.sender, _amount); } else {     //when CDS cannot afford, pay as much as possible     _compensated = _available;     _attributionLoss = vault.transferValue(_available, msg.sender);     emit Compensated(msg.sender, _available); }  ```  ### Recommendation  Change to:  ```solidity _compensated = _available >= _amount? _amount: _available;  _attributionLoss = vault.transferValue(_compensated, msg.sender); emit Compensated(msg.sender, _compensated); ```  - Duplicated codes removed; - Shorter and simpler code.  
# Handle  WatchPug   # Vulnerability details  Cache and reusing the function call results, instead of calling it again, can save gas from unnecessary code execution.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L163-L173  ```solidity if (available() < _amount) {      //when USDC in this contract isn't enough     uint256 _shortage = _amount - available();     _unutilize(_shortage);      assert(available() >= _amount); }  balance -= _amount; IERC20(token).safeTransfer(_to, _amount); ```  ### Recommendation  Change to:  ```solidity uint256 availableAmount = available() if ( availableAmount < _amount) {      //when USDC in this contract isn't enough     uint256 _shortage = _amount - available();     _unutilize(_shortage);      assert(availableAmount >= _amount); }  balance -= _amount; IERC20(token).safeTransfer(_to, _amount); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L295-L304  ```solidity function rate() external view returns (uint256) {     if (totalSupply() > 0) {         return             (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /             totalSupply();     } else {         return 0;     } } ```  `totalSupply()`  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L309-L312  ```solidity if (available() < _retVal) {     uint256 _shortage = _retVal - available();     _unutilize(_shortage); } ```  `available()`  
# Handle  WatchPug   # Vulnerability details  When there are multiple checks, adjusting the sequence to allow the tx to fail earlier can save some gas.  Checks using less gas should be executed earlier than those with higher gas costs, to avoid unnecessary storage read, arithmetic operations, etc when it reverts.  For example:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L238-L256  ```solidity require(paused == false, "ERROR: PAUSED"); require(     request.timestamp +         parameters.getLockup(msg.sender) <         block.timestamp,     "ERROR: WITHDRAWAL_QUEUE" ); require(     request.timestamp +         parameters.getLockup(msg.sender) +         parameters.getWithdrawable(msg.sender) >         block.timestamp,     "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST" ); require(     request.amount >= _amount,     "ERROR: WITHDRAWAL_EXCEEDED_REQUEST" ); require(_amount > 0, "ERROR: WITHDRAWAL_ZERO"); ```  The check of `_amount > 0` can be done earlier to avoid reading from storage when `_amount = 0`.  ## Recommendation  Change to:  ```solidity         require(paused == false, "ERROR: PAUSED");         require(_amount > 0, "ERROR: WITHDRAWAL_ZERO");         require(             request.amount >= _amount,             "ERROR: WITHDRAWAL_EXCEEDED_REQUEST"         );         require(             request.timestamp +                 parameters.getLockup(msg.sender) <                 block.timestamp,             "ERROR: WITHDRAWAL_QUEUE"         );         require(             request.timestamp +                 parameters.getLockup(msg.sender) +                 parameters.getWithdrawable(msg.sender) >                 block.timestamp,             "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"         ); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L189-L191  ```solidity uint256 _balance = balanceOf(msg.sender); require(_balance >= _amount, "ERROR: REQUEST_EXCEED_BALANCE"); require(_amount > 0, "ERROR: REQUEST_ZERO"); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L217-L236  ```solidity require(locked == false, "ERROR: WITHDRAWAL_PENDING"); require(     _requestTime + _lockup < block.timestamp,     "ERROR: WITHDRAWAL_QUEUE" ); require(     _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >         block.timestamp,     "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST" ); require(     withdrawalReq[msg.sender].amount >= _amount,     "ERROR: WITHDRAWAL_EXCEEDED_REQUEST" ); require(_amount > 0, "ERROR: WITHDRAWAL_ZERO");  require(     _retVal <= withdrawable(),     "ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY" ); ```  
# Handle  defsec   # Vulnerability details  The setFeeRate function does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.  ## Proof of Concept  - The setFeeRate function sets the transaction fee rates for the market in which the function is called. In this context, the transaction fee is the percentage of a transaction that is taken by the protocol and moved to a designated reserve account. As the name suggests, transaction fees factor in to many of the essential transaction types performed within the system. - Navigate to "https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Parameters.sol#L177". - On the function there is no upper and lower bound defined. Therefore, users can pay higher fees.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to define upper and lower bounds on the fee array.  
# Handle  defsec   # Vulnerability details  ## Impact  On the InsureDAOERC20, transferFrom function is vulnerable on the re-entrancy.  ## Proof of Concept  1. Navigate to the following contract. Approve function is written after transfer call. It is not possible to exploit on the current environment but that can be possible on the EVM.  ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         _transfer(sender, recipient, amount);          uint256 currentAllowance = _allowances[sender][_msgSender()];         require(             currentAllowance >= amount,             "ERC20: transfer amount exceeds allowance"         );          _approve(sender, _msgSender(), currentAllowance - amount);          return true;     } ```   ## Tools Used  Code Review  ## Recommended Mitigation Steps   Follow check effect interaction pattern. Consider to use openzeppelin erc20 contract. The sample transferFrom function can be seen from below.   ```   function transferFrom(       address sender,       address recipient,       uint256 amount   ) public virtual override returns (bool) {       uint256 currentAllowance = _allowances[sender][_msgSender()];       if (currentAllowance != type(uint256).max) {           require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");           unchecked {               _approve(sender, _msgSender(), currentAllowance - amount);           }       }        _transfer(sender, recipient, amount);        return true;   } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L161  
# Handle  defsec   # Vulnerability details  ## Impact  On the ERC20, There is a known problem named as Approve/TransferFrom race condition. On the transferFrom, allowance max check has not been added.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152  ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         uint256 currentAllowance = _allowances[sender][_msgSender()];         if (currentAllowance != type(uint256).max) {             require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");             unchecked {                 _approve(sender, _msgSender(), currentAllowance - amount);             }         }          _transfer(sender, recipient, amount);          return true;     }  ```  2. Max Allowance check has not been added into the function. ERC20 standart (Openzeppelin) is not followed.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to use openzeppelin erc20 contract. The sample transferFrom function can be seen from below.   ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         uint256 currentAllowance = _allowances[sender][_msgSender()];         if (currentAllowance != type(uint256).max) {             require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");             unchecked {                 _approve(sender, _msgSender(), currentAllowance - amount);             }         }          _transfer(sender, recipient, amount);          return true;     } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L161  
# Handle  leastwood   # Vulnerability details  ## Impact  The current method of market creation involves calling `Factory.createMarket()` with a list of approved `_conditions` and `_references` accounts. If a registered template address has `templates[address(_template)].isOpen == true`, then any user is able to call `createMarket()` using this template. If the template points to `PoolTemplate.sol`, then a malicious market creator can abuse `PoolTemplate.initialize()` as it makes a vault deposit from an account that they control. The vulnerable internal function, `_depositFrom()`, makes a vault deposit from the `_references[4]` address (arbitrarily set to an approved reference address upon market creation).  Hence, if approved `_references` accounts have set an unlimited approval amount for `Vault.sol` before deploying their market, a malicious user can frontrun market creation and cause these tokens to be transferred to the incorrect market.  This issue can cause honest market creators to have their tokens transferred to an incorrectly configured market, leading to unrecoverable funds. If their approval to `Vault.sol` was set to the unlimited amount, malicious users will also be able to force honest market creators to transfer more tokens than they would normally want to allow. ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L158-L231 ``` function createMarket(     IUniversalMarket _template,     string memory _metaData,     uint256[] memory _conditions,     address[] memory _references ) public override returns (address) {     //check eligibility     require(         templates[address(_template)].approval == true,         "ERROR: UNAUTHORIZED_TEMPLATE"     );     if (templates[address(_template)].isOpen == false) {         require(             ownership.owner() == msg.sender,             "ERROR: UNAUTHORIZED_SENDER"         );     }     if (_references.length > 0) {         for (uint256 i = 0; i < _references.length; i++) {             require(                 reflist[address(_template)][i][_references[i]] == true ||                     reflist[address(_template)][i][address(0)] == true,                 "ERROR: UNAUTHORIZED_REFERENCE"             );         }     }      if (_conditions.length > 0) {         for (uint256 i = 0; i < _conditions.length; i++) {             if (conditionlist[address(_template)][i] > 0) {                 _conditions[i] = conditionlist[address(_template)][i];             }         }     }      if (         IRegistry(registry).confirmExistence(             address(_template),             _references[0]         ) == false     ) {         IRegistry(registry).setExistence(             address(_template),             _references[0]         );     } else {         if (templates[address(_template)].allowDuplicate == false) {             revert("ERROR: DUPLICATE_MARKET");         }     }      //create market     IUniversalMarket market = IUniversalMarket(         _createClone(address(_template))     );      IRegistry(registry).supportMarket(address(market));          markets.push(address(market));       //initialize     market.initialize(_metaData, _conditions, _references);      emit MarketCreated(         address(market),         address(_template),         _metaData,         _conditions,         _references     );      return address(market); } ```  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L178-L221 ``` function initialize(     string calldata _metaData,     uint256[] calldata _conditions,     address[] calldata _references ) external override {     require(         initialized == false &&             bytes(_metaData).length > 0 &&             _references[0] != address(0) &&             _references[1] != address(0) &&             _references[2] != address(0) &&             _references[3] != address(0) &&             _references[4] != address(0) &&             _conditions[0] <= _conditions[1],         "ERROR: INITIALIZATION_BAD_CONDITIONS"     );     initialized = true;      string memory _name = string(         abi.encodePacked(             "InsureDAO-",             IERC20Metadata(_references[1]).name(),             "-PoolInsurance"         )     );     string memory _symbol = string(         abi.encodePacked("i-", IERC20Metadata(_references[1]).symbol())     );     uint8 _decimals = IERC20Metadata(_references[0]).decimals();      initializeToken(_name, _symbol, _decimals);      registry = IRegistry(_references[2]);     parameters = IParameters(_references[3]);     vault = IVault(parameters.getVault(_references[1]));      metadata = _metaData;      marketStatus = MarketStatus.Trading;      if (_conditions[1] > 0) {         _depositFrom(_conditions[1], _references[4]);     } } ```  ## Tools Used  Manual code review. Discussions with kohshiba.  ## Recommended Mitigation Steps  After discussions with the sponsor, they have opted to parse a `_creator` address to `PoolTemplate.sol` which will act as the depositor and be set to `msg.sender` in `Factory.createMarket()`. This will prevent malicious market creators from forcing vault deposits from unsuspecting users who are approved in `Factory.sol` and have also approved `Vault.sol` to make transfers on their behalf.  
# Handle  WatchPug   # Vulnerability details  Check of allowance can be done earlier (before `_transfer()`) to save some gas for failure transactions.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152-L168  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     require(         currentAllowance >= amount,         "ERC20: transfer amount exceeds allowance"     );      _approve(sender, _msgSender(), currentAllowance - amount);      return true; } ```   See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162-L169   
# Handle  WatchPug   # Vulnerability details  Removing `return 0` can make the code simpler and save some gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L295-L303  ```solidity     function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return                 (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /                 totalSupply();         } else {             return 0;         }     } ```  ### Recommendation  Can be changed to:  ```solidity     function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return                 (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /                 totalSupply();         }      } ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L312-L317  ```solidity         if (_balance == 0) {             return 0;         } else {             return                 _balance * vault.attributionValue(crowdPool) / totalSupply();         } ```  Can be changed to:  ```solidity if (_balance > 0) {     return         _balance * vault.attributionValue(crowdPool) / totalSupply(); }  ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L176-L176  ```solidity for (uint256 i = 0; i < _references.length; i++) ```  Can be changed to:  ```solidity for (uint256 i; i < _references.length; i++) ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L493-L497  ```solidity if (totalLiquidity() > 0) {     return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); } else {     return 0; } ```  Can be changed to:  ```solidity if (totalLiquidity() > 0) {     return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); }  ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L288-L288  ```solidity require(registry.isListed(msg.sender)); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L100-L100  ```solidity require(address(_template) != address(0)); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L109-L113  ```solidity string memory _name = "InsureDAO-CDS"; string memory _symbol = "iCDS"; uint8 _decimals = IERC20Metadata(_references[0]).decimals();  initializeToken(_name, _symbol, _decimals); ```  The local variable `_name`, `_symbol`, `_decimals` is used only once. Making the expression inline can save gas.  ### Recommendation  Change to:  ```solidity initializeToken("InsureDAO-CDS", "iCDS", IERC20Metadata(_references[0]).decimals()); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L189-L190  ```solidity uint256 _balance = balanceOf(msg.sender); require(_balance >= _amount, "ERROR: REQUEST_EXCEED_BALANCE"); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L257-L257  ```solidity uint256 _surplusAttribution = surplusPool; ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L62-L63  ```solidity uint256 _assetReserve = asset.safeBalance(); require(_assetReserve >= assetReserve + assetIn, 'E304'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L51-L52  ```solidity uint256 _collateralReserve = collateral.safeBalance(); require(_collateralReserve >= collateralReserve + collateralIn, 'E305'); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L456-L463  ```solidity uint256 _shortage; if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = _value + _cds; } ```  `_shortage` and `_cds`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L140-L148  ```solidity if (_supply > 0 && _liquidity > 0) {     _mintAmount = (_amount * _supply) / _liquidity; } else if (_supply > 0 && _liquidity == 0) {     //when vault lose all underwritten asset =      _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again. } else {     //when _supply == 0,     _mintAmount = _amount; } ```  ### Recommendation  Change to:  ```solidity if (_supply == 0) {     _mintAmount = _amount; } else {     _mintAmount = _liquidity == 0 ? _amount * _supply : (_amount * _supply) / _liquidity; }  ```  - Removed 2 checks; - Removed 1 branch; - Simpler branch (costs less gas) goes first.  
# Handle  WatchPug   # Vulnerability details  The Wrapped Ether (WETH) ERC-20 contract has a gas optimization that does not update the allowance if it is the max uint.  The latest version of OpenZeppelin's ERC20 token contract also adopted this optimization.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152-L168  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     require(         currentAllowance >= amount,         "ERC20: transfer amount exceeds allowance"     );      _approve(sender, _msgSender(), currentAllowance - amount);      return true; } ```  See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162 -   https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085  ### Recommendation  Change to:  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     if (currentAllowance != type(uint256).max) {         require(             currentAllowance >= amount,             "ERC20: transfer amount exceeds allowance"         );          _approve(sender, _msgSender(), currentAllowance - amount);     }      return true; } ```  
# Handle  Jujic   # Vulnerability details  ## Impact ``` function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();         } else {             return 0;         }     } ```  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L512-L518  ## Tools Used Remix  ## Recommended Mitigation Steps Change to: ``` function rate() external view returns (uint256) {         if (totalSupply() != 0) {             return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();              }  ```  
# Handle  hyh   # Vulnerability details  ## Impact  System will fail on low-level subtraction without proper logic level error, which can be an issue for troubleshooting and further programmatic usages by other projects.   ## Proof of Concept  Whenever user lacks _attributions (Vault shares) for the withdraw amount requested, the system will fail on subtraction:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L160   ## Recommended Mitigation Steps  Consider adding a check for the enough _attributions throwing a corresponding error   
# Handle  loop   # Vulnerability details  When checking boolean values in a require or if statement it's an unnecessary operation to compare them to `true`, as it's already checked whether the condition is `true`. For comparison to `false`, it is cheaper to use the `!` operator rather than compare the value.  ## Proof of Concept Lines where boolean comparison is used: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L99 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L131 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L161 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L176 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L205 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L122 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L142 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L166-L169 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L178-L179 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L204 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L132 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L165 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L365 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L464 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L184 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L234 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L354 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L388 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L491 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L550 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L612 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L664  ## Recommended Mitigation Steps Remove the `== true` part from boolean comparisons and change `_variableName == false` to `!_variableName` to save some gas.  
# Handle  loop   # Vulnerability details  The function `unlock()` in PoolTemplate has a typo where it compares `insurances[_id].status` to `false` rather than setting it to `false`. If the conditions are met to unlock the funds for an id, the user should be able to call the `unlock()` function once for that id as `insurances[_id].amount` is subtracted from `lockedAmount`. However, since `insurances[_id].status` does not get set to `false`, a user can call `unlock()` multiple times for the same id, resulting in `lockedAmount` being way smaller than it should be since `insurances[_id].amount` is subtracted multiple times.   ## Impact `lockedAmount` is used to calculate the amount of underlying tokens available for withdrawals. If `lockedAmount` is lower than it should be users are able to withdraw more underlying tokens than available for withdrawals.  ## Proof of Concept Typo in `unlock()`: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L360-L362  Calculation of underlying tokens available for withdrawal: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L836  ## Recommended Mitigation Steps Change `insurances[_id].status == false;` to `insurances[_id].status = false;`  
# Handle  hyh   # Vulnerability details  ## Impact  Underlying and index tokens are mixed up in the worth() function description, making code and its description conflicting  ## Proof of Concept  Worth() computes how many iTokens correspond to given amount of underlying. The description says otherwise, mixing them up:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L794-798    ## Recommended Mitigation Steps  Fix the description to say that ‘_value' is the amount of underlying, while the '_amount' is the corresponding output quantity of iTokens   
# Handle  ospwner   # Vulnerability details  ## Impact Checking arrays' length before using it in a for loop is unnecessary when array's length is used in loop exit condition.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L175  ```         if (_references.length > 0) {             for (uint256 i = 0; i < _references.length; i++)  ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L185 ```         if (_conditions.length > 0) {             for (uint256 i = 0; i < _conditions.length; i++)  ```   ## Recommended Mitigation Steps  Remove the two unnecessary  if statements.   
# Handle  0x1f8b   # Vulnerability details  ## Impact Signature replay in `PoolTemplate`.  ## Proof of Concept The `redeem` method of `PoolTemplate` verifies the data stored in `incident`, and the verification logic of this process is performed as following:  ``` require(             MerkleProof.verify(                 _merkleProof,                 _targets,                 keccak256(                     abi.encodePacked(_insurance.target, _insurance.insured)                 )             ) ||                 MerkleProof.verify(                     _merkleProof,                     _targets,                     keccak256(abi.encodePacked(_insurance.target, address(0)))                 ),             "ERROR: INSURANCE_EXEMPTED"         ); ```  As can be seen, the only data related to the `_insurance` are` target` and `insured`, so as the incident has no relation with the` Insurance`, apparently nothing prevents a user to call `insure` with high amounts, after receive the incident, the only thing that prevents this from being reused is that the owner creates the incident with an `_incidentTimestamp` from the past.  So if a owner create a incident from the future it's possible to create a new `insure` that could be reused by the same affected address.  Another lack of input verification that could facilitate this attack is the `_span=0` in the `insure` method.  ## Tools Used Manual review.  ## Recommended Mitigation Steps It is mandatory to add a check in `applyCover` that` _incidentTimestamp` is less than the current date and the `span` argument is greater than 0 in the` insure` method.  
# Handle  Jujic   # Vulnerability details  ## Impact Checking if  `_amount != 0 ` before making the transfer call  can save gas by avoiding the external call in such situations.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L201-L206  ``` function borrowValue(uint256 _amount, address _to) external onlyMarket override {         debts[msg.sender] += _amount;         totalDebt += _amount;          IERC20(token).safeTransfer(_to, _amount);     }  ```  ## Tools Used Remix  ## Recommended Mitigation Steps Add additional check for non zero ` _amount`.  
# Handle  Jujic   # Vulnerability details  ## Impact Some of the variables can be cached to slightly reduce gas usage  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L343  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L406-L407  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L461-L479  ``` function withdrawRedundant(address _token, address _to)         external         override         onlyOwner     {         if (             _token == address(token) &&             balance < IERC20(token).balanceOf(address(this))         ) {             uint256 _redundant = IERC20(token).balanceOf(address(this)) -                 balance;             IERC20(token).safeTransfer(_to, _redundant);         } else if (IERC20(_token).balanceOf(address(this)) > 0) {             IERC20(_token).safeTransfer(                 _to,                 IERC20(_token).balanceOf(address(this))             );         }     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Consider caching those variable for read and make sure write back to storage Example: ``` bal =  IERC20(_token).balanceOf(address(this); ```  
# Handle  0xngndev   # Vulnerability details  ## Impact  Unclear Natspec may confuse the user.  In the `fund` function:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L160](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L160)  The Natspec is a copy-paste of the `deposit` function:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L130](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L130)  The problem here is the **receives ITokens** part of the Natspec. The deposit function indeed mints tokens to the `msg.sender` but the `fund` function doesn’t. I would clarify that the `fund` function adds attributions to the surplusPool.  Another minor and unclear bit of Natspec happens here: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L177](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L177)  It describes `_amount` as sender of value instead of something like **amount of value to send.**  ## Recommended Mitigation Steps  Explain the Natspec of the `fund` function in more detail. Fix the `transferValue` amount natspec. Also it would be good to add some Natspec to the `defund` function too.  
# Handle  0xngndev   # Vulnerability details  ## Impact  In `PoolTemplate.sol` there are multiple instances where variables are declared before the error checks of the functions. In cases where a function reverts due to these error checks, that extra computation of calculating the variable being declared can be avoided by simply moving the declaration after the error checks.  Here are all the functions I found where this can be applied:  - `withdraw` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L293](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L293) - `withdrawCredit` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L416](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L416) - `insure` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L465](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L465) - `reedem` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L548](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L548)  ## Recommended Mitigation Steps  - Change `withdraw` function to:  ```solidity function withdraw(uint256 _amount) external returns (uint256 _retVal) {   require(       marketStatus == MarketStatus.Trading,       "ERROR: WITHDRAWAL_PENDING"   );   require(       withdrawalReq[msg.sender].timestamp +           parameters.getLockup(msg.sender) <           block.timestamp,       "ERROR: WITHDRAWAL_QUEUE"   );   require(       withdrawalReq[msg.sender].timestamp +           parameters.getLockup(msg.sender) +           parameters.getWithdrawable(msg.sender) >           block.timestamp,       "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"   );   require(       withdrawalReq[msg.sender].amount >= _amount,       "ERROR: WITHDRAWAL_EXCEEDED_REQUEST"   );   require(_amount > 0, "ERROR: WITHDRAWAL_ZERO");   require(       _retVal <= availableBalance(),       "ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY"   );    uint256 _supply = totalSupply();   require(_supply != 0, "ERROR: NO_AVAILABLE_LIQUIDITY");    uint256 _liquidity = originalLiquidity();   _retVal = (_amount * _liquidity) / _supply;    //reduce requested amount   withdrawalReq[msg.sender].amount -= _amount;    //Burn iToken   _burn(msg.sender, _amount);    //Withdraw liquidity   vault.withdrawValue(_retVal, msg.sender);    emit Withdraw(msg.sender, _amount, _retVal); } ```  - Change `withdrawCredit` function to:  ```solidity function withdrawCredit(uint256 _credit)         external         override         returns (uint256 _pending)     {       IndexInfo storage _index = indicies[msg.sender];       require(           IRegistry(registry).isListed(msg.sender) &&               _index.credit >= _credit &&               _credit <= availableBalance(),           "ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS"       );        uint256 _rewardPerCredit = rewardPerCredit;        //calculate acrrued premium       _pending = _sub(           (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,           _index.rewardDebt       );        //Withdraw liquidity       if (_credit > 0) {           totalCredit -= _credit;           _index.credit -= _credit;           emit CreditDecrease(msg.sender, _credit);       }        //withdraw acrrued premium       if (_pending > 0) {           vault.transferAttribution(_pending, msg.sender);           attributionDebt -= _pending;           _index.rewardDebt =               (_index.credit * _rewardPerCredit) /               MAGIC_SCALE_1E6;       } } ```  - Change `insure` function to:  ```solidity function insure(         uint256 _amount,         uint256 _maxCost,         uint256 _span,         bytes32 _target     ) external returns (uint256) {       //Distribute premium and fee       uint256 _premium = getPremium(_amount, _span);        require(           _amount <= availableBalance(),           "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"       );       require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");       require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");       require(           parameters.getMinDate(msg.sender) <= _span,           "ERROR: INSURE_SPAN_BELOW_MIN"       );        require(           marketStatus == MarketStatus.Trading,           "ERROR: INSURE_MARKET_PENDING"       );       require(paused == false, "ERROR: INSURE_MARKET_PAUSED");        uint256 _endTime = _span + block.timestamp;       uint256 _fee = parameters.getFeeRate(msg.sender);        //current liquidity       uint256 _liquidity = totalLiquidity();       uint256 _totalCredit = totalCredit;        //accrue premium/fee       uint256[2] memory _newAttribution = vault.addValueBatch(           _premium,           msg.sender,           [address(this), parameters.getOwner()],           [MAGIC_SCALE_1E6 - _fee, _fee]       );        //Lock covered amount       uint256 _id = allInsuranceCount;       lockedAmount += _amount;       Insurance memory _insurance = Insurance(           _id,           block.timestamp,           _endTime,           _amount,           _target,           msg.sender,           true       );       insurances[_id] = _insurance;       allInsuranceCount += 1;        //Calculate liquidity for index       if (_totalCredit > 0) {           uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /               _liquidity;           attributionDebt += _attributionForIndex;           rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /               _totalCredit);       }        emit Insured(           _id,           _amount,           _target,           block.timestamp,           _endTime,           msg.sender,           _premium       );          return _id;   } ```  - Change `redeem` function to:  ```solidity function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {       require(           marketStatus == MarketStatus.Payingout,           "ERROR: NO_APPLICABLE_INCIDENT"       );       Insurance storage _insurance = insurances[_id];       require(_insurance.status == true, "ERROR: INSURANCE_NOT_ACTIVE");       require(_insurance.insured == msg.sender, "ERROR: NOT_YOUR_INSURANCE");       uint256 _incidentTimestamp = incident.incidentTimestamp;       require(           marketStatus == MarketStatus.Payingout &&               _insurance.startTime <= _incidentTimestamp &&               _insurance.endTime >= _incidentTimestamp,           "ERROR: INSURANCE_NOT_APPLICABLE"       );       bytes32 _targets = incident.merkleRoot;       require(           MerkleProof.verify(               _merkleProof,               _targets,               keccak256(                   abi.encodePacked(_insurance.target, _insurance.insured)               )           ) ||               MerkleProof.verify(                   _merkleProof,                   _targets,                   keccak256(abi.encodePacked(_insurance.target, address(0)))               ),           "ERROR: INSURANCE_EXEMPTED"       );       uint256 _payoutNumerator = incident.payoutNumerator;       uint256 _payoutDenominator = incident.payoutDenominator;        _insurance.status = false;       lockedAmount -= _insurance.amount;        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /           _payoutDenominator;        vault.borrowValue(_payoutAmount, msg.sender);        emit Redeemed(           _id,           msg.sender,           _insurance.target,           _insurance.amount,           _payoutAmount       );   } ```  
# Handle  Jujic   # Vulnerability details  ## Impact The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L105  ``` function transfer(address recipient, uint256 amount)         public         virtual         override         returns (bool)     {         _transfer(_msgSender(), recipient, amount);         return true;     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  
# Handle  cccz   # Vulnerability details  ## Impact  The fund function of the CDSTemplate contract does not match the description, the caller will not receive any iToken after sending tokens, and the owner can take away the tokens in surplusPool.  ```     /**      * @notice A liquidity provider supplies collatral to the pool and receives iTokens      * @param _amount amount of token to deposit      */     function fund(uint256 _amount) external {         require(paused == false, "ERROR: PAUSED");          //deposit and pay fees         uint256 _attribution = vault.addValue(             _amount,             msg.sender,             address(this)         );          surplusPool += _attribution;          emit Fund(msg.sender, _amount, _attribution);     }      function defund(uint256 _amount) external override onlyOwner {         require(paused == false, "ERROR: PAUSED");          uint256 _attribution = vault.withdrawValue(_amount, msg.sender);         surplusPool -= _attribution;          emit Defund(msg.sender, _amount, _attribution);     } ```  ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L156-L182  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Change the description of the fund function or send iToken to the caller  
# Handle  camden   # Vulnerability details  ## Impact The owner could potentially extend the insurance period indefinitely in the `applyCover` function without ever allowing the market to resume. This is because there is no check in `applyCover` to ensure that the market is in a `Trading` state.  This can also allow the owner to emit fraudulent `MarketStatusChanged` events.  ## Recommended Mitigation Steps Require that the market be in a `Trading` state to allow another `applyCover` call.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The Vault.sol contract contains several state variables of type address. There is no need to cast these variable to type address because they are already of type address. Removing the cast function can save gas.  ## Proof of Concept  The token address state variable is unnecessarily cast to address type in two places in Vault.sol: - [Line 350](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L350) - [Line 467](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L467)  ## Recommended Mitigation Steps  Remove the unnecessary address cast from address variables.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The Vault.sol contract has two address state variables, the `keeper` variable and the `controller` variable, which are both permitted to be the zero address. If both variables are zero simultaneously, any address can burn the available funds (available funds = balance - totalDebt) by sending these tokens to the zero address with the unprotected `utilitize()` function. If a user has no totalDebt, the user can lose their entire underlying token balance because of this.  ## Proof of Concept  The problematic `utilize()` function is [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L342-L352). To see how the two preconditions can occur: 1. The keeper state variable is only changed by the `setKeeper()` function [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502). If this function is not called, the keeper variable will retain the default value of address(0), which bypasses [the only access control for the utilize function](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L344). 2. There is a comment [here on line 69](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502) stating the controller state variable can be zero. There is no zero address check for the controller state variable in the Vault constructor.  If both address variables are left at their defaults of address(0), then the safeTransfer() call [on line 348](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L348) would send the tokens to address(0).  ## Recommended Mitigation Steps  Add the following line to the very beginning of the `utilize()` function: `require(address(controller) != address(0))`  This check is already found in many other functions in Vault.sol, including the `_unutilize()` function.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The comment for the return value of the `getCDS()` function in Registry.sol is incorrectly copied from elsewhere, possibly the `confirmExistence()` function. The return value is an address, not a boolean. This is considered low risk based on C4's [risk ratings](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  The problematic comment is from the `getCDS()` function [here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L99). It is an incorrect duplicate of the comment for the `confirmExistence()` function [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L113).  ## Recommended Mitigation Steps  Replace the comment with something like `@return CDS contract address`, which is used to describe this value in the `setCDS()` function.  
# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) { uint length = arr.length; for (uint i = 0; i < arr.length; i++) { sum += arr[i]; } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) { uint length = arr.length; for (uint i = 0; i < arr.length; i++) { sum += arr[i]; } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  ``` https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L176  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L186  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  
# Handle  p4st13r4   # Vulnerability details  ## Impact  Users that incorrectly ask for a withdrawal equal to zero, will waste more gas (a storage read) since the check for `amount > 0` is put after the check for the available amount  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L191](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L191) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L199](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L199) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L282](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L282)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Move this require at the top of the `requestWithdraw` function:  ```jsx require(_amount > 0, "ERROR: REQUEST_ZERO"); ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  `totalAllocPoint` in `set()` function is read several times from storage. It can be assigned to a local variable so the function is less expensive overall  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L612](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L612)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `totalAllocPoint` to `localTotalAllocPoint` (or `cachedTotalAllocPoint`)  
# Handle  p4st13r4   # Vulnerability details  ## Impact  When emitting the event, the function argument could be used, instead of reading from storage again  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Ownership.sol#L62](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Ownership.sol#L62)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Change to:  ```jsx emit CommitNewOwnership(newOwner); ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  Many functions that read params, check whether the value is set for the given `target`, otherwise return the value for the zero-address. When doing this kind of check, the value of the `target` is read twice:  - once for checking if it’s set - if it’s set, it’s read once more to read the actual params  These functions are used a lot of times inside all the contracts, so having them optimized as much as possible is required in order to save gas  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L240](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L240) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L271](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L271) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L289](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L289) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L313](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L313) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L331](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L331) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L343](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L343) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L379](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L379) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L397](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L397)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign the target value and, if the check returns a value different from the zero-address, use it. For example, `getFeeRate` becomes:  ```jsx function getFeeRate(address _target)     external     view     override     returns (uint256) {     uint256 _targetFee = _fee[_target];     if (_targetFee == 0) {         return _fee[address(0)];     } else {         return _targetFee;     } } ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  The public `deposit` uses basically the same code of the internal `_depositFrom`. The only difference between them is that the former uses `msg.sender`, while the latter uses a parameter as `from` address. In order to minimize code duplication, `deposit` should be calling `_depositFrom` rather than being reimplemented using copy-paste  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L232](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L232)  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L255](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L255)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Write `deposit` like this:  ```jsx function deposit(uint256 _amount) public returns (uint256 _mintAmount) {     _depositFrom(_amount, msg.sender); } ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  The `setKeeper()` function is operated only by the owner, and should emit an event when the keeper is set for the first time and/or changes  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L502](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L502)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add `emit KeeperChanged(address)` after changing the keeper  
# Handle  p4st13r4   # Vulnerability details  ## Impact  The amount of the withdrawal request is not correctly updated after a withdrawal in `CDSTemplate.sol`. This happens because the withdrawal request is read from storage and put in memory, like this:  ```jsx Withdrawal memory request = withdrawalReq[msg.sender]; ```  However, the requested amount is not updated properly since the `withdrawalReq` in the storage is never updated. Instead, its in-memory version is updated, but it’s useless because that object is never used again:  ```jsx //reduce requested amount request.amount -= _amount; ```  This issue is non critical because there is a function that takes care of updating the withdrawal requests’ amount on every token transfer: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L358](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L358)  The issue lies in the fact that the code seems to behave differently from how it looks at a first glance. Furthermore, the other two templates correctly update the value of the withdrawal request, so the version in `CDSTemplate.sol` should be aligned as well:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L239](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L239) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L327](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L327)  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L230](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L230)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Update the `amount` of the current withdrawal request as well  
# Handle  p4st13r4   # Vulnerability details  ## Impact  The `resume` function can be called by any user, at any time, even when the Index contract is not locked. There should be a check preventing it from being called unless the contract is `locked`  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L459](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L459)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add a require on top:  ```jsx require(locked); ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  `PoolTemplate.sol` and `IndexTemplate.sol` report this same error when trying to withdraw and some conditions are not met: "ERROR: WITHDRAWAL_PENDING”  However, `PoolTemplate.sol` does that when the `marketStatus` is not `Trading`; `IndexTemplate.sol` when the contract is locked. Since `CDSTemplate.sol`, instead, implement a different revert string, it’s best for understanding what revert strings are related to by making them as explicit and clear as possible. `CDSTemplate.sol` has this in the `withdraw` function:  ```jsx require(paused == false, "ERROR: PAUSED"); ```  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217)  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L302](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L302)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Improve revert strings wording  
# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L685 the function emitted a `MarketStatusChanged` event with storage variable which is `marketStatus`. when we emit an event using storage data is more expensive than emitted an event using `MarketStatus.Payingout` value.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L685 ``` contract emitstatust {      enum MarketStatus {         Trading,         Payingout     }     MarketStatus public marketStatus;      event MarketStatusChanged(MarketStatus statusValue);      function amit() public {          marketStatus = MarketStatus.Payingout;      emit MarketStatusChanged(marketStatus);      } } //44792 gas ```  can change to :  ``` contract emitstatust {      enum MarketStatus {         Trading,         Payingout     }     MarketStatus public marketStatus;      event MarketStatusChanged(MarketStatus statusValue);      function amit() public {          marketStatus = MarketStatus.Payingout;      emit MarketStatusChanged(MarketStatus.Payingout);      } } //44659 gas ```  ## Tools Used remix   
# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L508 instead of save `Insurance` value to memory then save to `insurences` storage it's better to save the `Insurence` value directly to `insurences`  storage or mapping to save gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L508 ``` contract insur {      struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     }       mapping(uint256 => Insurance) public insurances;      function coba() public {          uint256 _id = 10;         uint256 _endTime = 10;         uint256 _amount = 12;         bytes32 _target = bytes32(uint256(10));           Insurance memory _insurance = Insurance(             _id,             block.timestamp,             _endTime,             _amount,             _target,             msg.sender,             true         );         insurances[_id] = _insurance;      } } //154623 gas ```  change to : ``` contract insur {      struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     }       mapping(uint256 => Insurance) public insurances;      function coba() public {          uint256 _id = 10;         uint256 _endTime = 10;         uint256 _amount = 12;         bytes32 _target = bytes32(uint256(10));           insurances[_id] = Insurance(             _id,             block.timestamp,             _endTime,             _amount,             _target,             msg.sender,             true         );               } } //154610 gas  ```  ## Tools Used remix  
# Handle  Tomio   # Vulnerability details  ## Impact by saving `totalLiquidity()` to memory can save more gas instead of doing double function call  ## Proof of Concept Before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L829 // gas cost 23862  After: ``` function totalLiquidity() public view returns (uint256){      return 10;  }     function availableBalance()public view returns (uint256 _balance)     {         uint256 saveTotalLiquidity = totalLiquidity();         if (saveTotalLiquidity > 0) {             return saveTotalLiquidity - lockedAmount;         } else {             return 0;         }     } ``` // gas cost 23840  ## Tools Used Remix  
# Handle  0x1f8b   # Vulnerability details  ## Impact Wrong deployment.  ## Proof of Concept The factory contract haven't got any check of `_registry` and `_ownership` and both values must be defined or the logic inside the contract will fault.  ## Tools Used Manual review.  ## Recommended Mitigation Steps It's mandatory to check that the address are not zero or the contract could be wrong deployed.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept There are multiple methods in `Registry` that check a value inside the storage and if it's not defined, use the default one. It's better to cache the value in order to save gas if it was defined avoiding double reading.  For example, instead of the following code: ```     function getCDS(address _address) external view override returns (address) {         if (cds[_address] == address(0)) {             return cds[address(0)];         } else {             return cds[_address];         }     } ``` use ```     function getCDS(address _address) external view override returns (address) {         address val =cds[_address];         if ( val== address(0)) {             return cds[address(0)];         } else {             return val;         }     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Cache the value.  
# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260 have two check inside the require which is `marketStatus == MarketStatus.Trading` and `paused == false` and by spliting this check we can save gas.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260  ``` function woi() public {          require(             marketStatus == MarketStatus.Trading && paused == false,             "ERROR: DEPOSIT_DISABLED"         );      } // 23645 gas ```   can be change to   ``` function woi() public{           require(             marketStatus == MarketStatus.Trading, "ERROR: DEPOSIT_DISABLED"         );         require(               paused == false, "ERROR: DEPOSIT_DISABLED"         );      } //23637 gas ```     
# Handle  Tomio   # Vulnerability details  ## Impact by changing the code from `if (_credit == 0) {` to `if (_credit != 0) {` and remove the else we can save gas when contract is deploy and we can save gas when `_credit` is equal to 0. because if `_credit` equal to 0 the original function will return 0 which a default value for uint256  ## Proof of Concept Before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L776 // gas 24307  After: ``` function pendingPremium(address _index)         external         view         returns (uint256)     {         uint256 _credit = indicies[_index].credit;        if (_credit != 0) {             return                 _sub(                     (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,                     indicies[_index].rewardDebt                 );         }     } ``` // gas 24286   ## Tools Used Remix  ## Recommended Mitigation Steps  
# Handle  defsec   # Vulnerability details  ## Impact  the owner parameter are used for the onlyOwner modifier. In the state variable , proper check up should be done , other wise error in these state variable can lead to redeployment of contract. If the zero address is assigned to rebalanceManager parameter, that will fail all Owner functions.  ## Proof of Concept  1. Navigate to the following contract functions.  "https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L31"  2. Adding zero address into the owner leads to failure of onlyOwner only functions.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add proper zero address validation.  
# Handle  Tomio   # Vulnerability details  ## Impact by using 'unchecked' you can save  +-182 gas  ## Proof of Concept before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L938 //22378 before  after: ``` function _sub(uint256 a, uint256 b) public pure returns (uint256) {         if (a < b) {             return 0;         } else {             unchecked {return a - b;}         }     }   ``` //22196 after   ## Tools Used Remix  ## Recommended Mitigation Steps used 'unchecked' in function _sub  
# Handle  camden   # Vulnerability details  ## Impact The `utilize()` function can be called while the controller is the zero address. This will fail. A comment in the constructor says that the controller shouldn't be the zero address.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L350  ## Recommended Mitigation Steps `utilize` should have a check to see if the controller is not the zero address (like `_unutilize`) and give an appropriate error message.  
# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept The `for` loop at [L109-113](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L109-L113) can be unrolled to remove the overhead of the loop itself, and avoid using an initialized-to-zero uint128 variable.  ## Tools Used Manual review  ## Recommended Mitigation Steps Replace L109-113 with: ``` uint256 _allocation = (_shares[0] * _attributions) / MAGIC_SCALE_1E6; attributions[_beneficiaries[0]] += _allocation; _allocations[0] = _allocation;  _allocation = (_shares[1] * _attributions) / MAGIC_SCALE_1E6; attributions[_beneficiaries[1]] += _allocation; _allocations[1] = _allocation; ```  
# Handle  0xngndev   # Vulnerability details  ## Impact  Error Messages that have a length of 32 or more one require one additional slot to be stored, causing extra gas costs when deploying the contract and when the function is executed and it reverts.  ## Proof of Concept  I put together a quick proof to show the different impact of the errors we can have in Solidity:  - Long require errors => more than 32 bytes - Short require errors => less than 32 bytes - Custom errors  Here are the contract size findings:  ```rust //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  contract Errors {   bool public thisIsFalse;   error WithdrawalExceeded();    /*     Contract Size with just this function: 333 bytes;   */   function moreThan32Bytes() public {     require(thisIsFalse, "ERROR: WITHDRAWAL_EXCEEDED_REQUEST");   }    /*     Contract Size with just this function: 295 bytes; //   */   function lessThan32Bytes() public {     require(thisIsFalse, "WITHDRAWAL_EXCEEDED_REQUEST");   }    /*     Contract Size with just this function: 242 bytes;   */   function customError() public {     if (!thisIsFalse) revert WithdrawalExceeded();   } } ```  I then run tests to see the gas costs of having the functions revert, and although these are not very accurate due to the fact that it’s hard to isolate the gas costs of a reverting function due to the order of execution (I can’t have an event that logs the gas before the function revert and another one after because the one after the revert will never be reached), it still shows some differences.  ```rust //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import "ds-test/test.sol"; import "../Errors.sol";  contract ErrorsTest is DSTest {   Errors errors;    function setUp() public {     errors = new Errors();   }    function testFailLessThan32Bytes() public logs_gas {     errors.lessThan32Bytes();   }    function testFailMoreThan32Bytes() public logs_gas {     errors.moreThan32Bytes();   }    function testFailCustomError() public logs_gas {     errors.customError();   } } ```  ```rust Running 3 tests for "ErrorsTest.json":ErrorsTest [PASS] testFailCustomError() (gas: 3161) [PASS] testFailLessThan32Bytes() (gas: 3314) [PASS] testFailMoreThan32Bytes() (gas: 3401) ```  ## Tools Used  DappTools/Foundry  ## Recommended Mitigation Steps  Personally, I would switch to custom errors and reverts to maximize the savings, but if you dislike revert syntax, then I would suggest to check which of your require errors have a length longer than 32, and shorten them so that their length is less than 32.  Here are some examples of the errors you could shorten in your `CDSTemplate.sol` contract:  - `ERROR: INITIALIZATION_BAD_CONDITIONS` - `ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST` - `ERROR: WITHDRAWAL_EXCEEDED_REQUEST`  Removing the “ERROR” keyword should be enough for most of these. Bear in mind you can always have concise error messages and a section in your documentation that explains them further or have your natspec expand on them if you find them too cryptic.   An example of how to apply a custom error in the first error would be to just have the error `say BadConditions()`. The user knows it’s an error because the function call failed, and the user knows it has happened in the initialize function because he called it, so `BadConditions()` should be a clear message despite being concise  
# Handle  Dravee   # Vulnerability details  In `IndexTemplate.sol:withdrawable()`, the following can be optimized to save gas and avoid a loss of precision, from: ```                 uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;                 _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev; ``` to ```                 uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint *  MAGIC_SCALE_1E6 /  (_targetAllocPoint * targetLev); ```  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `IndexTemplate.sol:_adjustAlloc()`, the 3 following conditions are always evaluated: ```                 //Withdraw or Deposit credit                 if (_current > _target && _available != 0) {                     //if allocated credit is higher than the target, try to decrease                     uint256 _decrease = _current - _target;                     IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);                     totalAllocatedCredit -= _decrease;                 }                 if (_current < _target) {                     uint256 _allocate = _target - _current;                     IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);                     totalAllocatedCredit += _allocate;                 }                 if (_current == _target) {                     IPoolTemplate(_poolList[i].addr).allocateCredit(0);                 } ``` The code can be optimized to save some gas: ```                 if (_current == _target) {                     IPoolTemplate(_poolList[i].addr).allocateCredit(0);                 } else if (_current < _target) {                     uint256 _allocate = _target - _current;                     IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);                     totalAllocatedCredit += _allocate;                 } else if (_current > _target && _available != 0) {                     //Withdraw or Deposit credit                     //if allocated credit is higher than the target, try to decrease                     uint256 _decrease = _current - _target;                     IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);                     totalAllocatedCredit -= _decrease;                 } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  
# Handle  Dravee   # Vulnerability details  ## Impact > The operators “||” and “&&” apply the common short-circuiting rules. This means that in the expression “f(x) || g(y)”, if “f(x)” evaluates to true, “g(y)” will not be evaluated even if it may have side-effects.  Source: https://docs.soliditylang.org/en/v0.5.4/types.html#booleans  ## Proof of Concept In `IndexTemplate.sol:withdrawable()`, there's an if-statement as such: ``` 293:                         if (i == 0 || _availableRate < _lowestAvailableRate) { ``` Here, the condition `i == 0` is always evaluated and is always equal to `false` when `i > 0`, meaning here a total of `poolList.length - 1` evaluations are always evaluated to `false`.  It's best to reorder the conditions such as this condition doesn't get evaluated if `_availableRate < _lowestAvailableRate` is satisfied: ``` 293:                         if (_availableRate < _lowestAvailableRate || i == 0 ) { ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `Factory.sol`, the following `> 0` checks are redundant with the for-loop condition, because if `_references.length == 0` or `_conditions.length == 0`, the condition `uint256 i = 0; i <(_conditions)|(_references).length` will never be satisfied and the for-loop won't iterate: ``` 175:         if (_references.length > 0) { 176:             for (uint256 i = 0; i < _references.length; i++) { 177:                 require( 178:                     reflist[address(_template)][i][_references[i]] == true || 179:                         reflist[address(_template)][i][address(0)] == true, 180:                     "ERROR: UNAUTHORIZED_REFERENCE" 181:                 ); 182:             } 183:         } 184:  185:         if (_conditions.length > 0) { 186:             for (uint256 i = 0; i < _conditions.length; i++) { 187:                 if (conditionlist[address(_template)][i] > 0) { 188:                     _conditions[i] = conditionlist[address(_template)][i]; 189:                 } 190:             } 191:         }  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove these 2 if-statements  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept The variable `T_0` can go through 2 assignments in a row: Here: ``` 75:         uint256 T_0 = _totalLiquidity; 76:         if (T_0 > T_1) { 77:             T_0 = T_1; 78:         } ``` And here: ``` 134:         uint256 T_0 = _totalLiquidity; 135:         if (T_0 > T_1) { 136:             T_0 = T_1; 137:         } ```  The code can be optimized as such to save some gas: ```         uint256 T_0 = _totalLiquidity > T_1 ? _totalLiquidity : T_1; ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto   
# Handle  Dravee   # Vulnerability details  ## Impact Duplicated code, loss of maintainability, increased contract size which leads to increased gas cost  ## Proof of Concept The following can be simplified: ``` 260:         if (_available >= _amount) { 261:             _compensated = _amount; 262:             _attributionLoss = vault.transferValue(_amount, msg.sender); 263:             emit Compensated(msg.sender, _amount); 264:         } else { 265:             //when CDS cannot afford, pay as much as possible 266:             _compensated = _available; 267:             _attributionLoss = vault.transferValue(_available, msg.sender); 268:             emit Compensated(msg.sender, _available); 269:         } ``` to ``` 260:         _compensated = _available >= _amount ? _amount : _available; //when CDS cannot afford, pay as much as possible 261:         _attributionLoss = vault.transferValue(_compensated, msg.sender); 262:         emit Compensated(msg.sender, _compensated); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto and look out for duplicated code  
# Handle  Dravee   # Vulnerability details  ## Impact When a contract imports and implements an interface or another contracts, it doesn't need to import the libraries that were already imported there.  Removing these imports will save gas.  ## Proof of Concept `InsureDAOERC20` imports the following:  ``` 5: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 6: import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"; ```  The following contracts inherit `InsureDAOERC20` and also make those imports: `CDSTemplate`, `IndexTemplate`, `PoolTemplate`  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove the unused imports to reduce the size of the contract and save some deployment gas.  
# Handle  egjlmn1   # Vulnerability details  in all of your for loops, you increase your loop variable using `i++` it has 2 problems: 1. postfix increment is more wasteful than prefix increment (`++i` instead of `i++`) 2. there is no risk for overflow, so you can use `unchecked{}`  ## Impact prefix arithmetic is a bit cheaper than postfix arithmetic, but if you do it in a for loop, this small amount of gas can pile up and be a big waste. also, in solidity 0.8.0+, every arithmetic operation is checked for overflow and underflow, which adds a lot of gas to a single operation. Since in your for loop you don't have the risk for overflow, you can surround the operation in `unchecked{}` to save a lot of gas (which will save a huge amount since it saves a lot in a single loop iteration.)  ## Proof of Concept Checked on remix  ## Tools Used manual code review  ## Recommended Mitigation Steps change every `i++` in your for loops to `unchecked{++i}`  
# Handle  Dravee   # Vulnerability details  ## Impact The compiler won't reserve a storage slot for `immutable` variables  ## Proof of Concept The following variables are initialized in the contract's constructor and can't get updated after: ``` Factory.sol:registry Factory.sol:ownership Parameters:ownership BondingPremium:ownership Registry:ownership Vault:ownership ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Make these variables `immutable`  
# Handle  Dravee   # Vulnerability details  ## Impact Repetitive and expensive SSTORE opcode operations inside loops  ## Proof of Concept ```  totalAllocatedCredit -= _available (contracts/IndexTemplate.sol#368)  totalAllocatedCredit -= _decrease (contracts/IndexTemplate.sol#395)  totalAllocatedCredit += _allocate (contracts/IndexTemplate.sol#401) ```  ## Tools Used Slither  ## Recommended Mitigation Steps Create a memory variable which will be used to compute a `_totalAllocatedCredit` that will get added to `totalAllocatedCredit` storage variable outside the loop. As an idea, you could create 1 such `int` variable and use it's value after the for-loop, or you could create 2 uint variables where 1 would store the _totalDecrease and 1 would store the _totalAllocate, and respectively substract and add them.   
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 slot)  ## Proof of Concept IndexTemplate.pendingEnd (contracts/IndexTemplate.sol#62) should be deleted as it's never used by the contract  ## Tools Used Slither  ## Recommended Mitigation Steps Delete the variable `IndexTemplate.pendingEnd`  
# Handle  Dravee   # Vulnerability details  ## Impact  Increased gas cost.   ## Proof of Concept  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers.  When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block.  https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  These lines are the obvious ones that can't underflow or overflow (operations on constants or checks already made before the operations with `require` statements or `if` statements): ```  PremiumModels\BondingPremium.sol:47:        T_1 = 1000000 * DECIMAL; PremiumModels\BondingPremium.sol:130:        uint256 u1 = BASE - ((_lockedAmount * BASE) / _totalLiquidity); //util rate before. 1000000 = 100.000% PremiumModels\BondingPremium.sol:132:            (((_lockedAmount + _amount) * BASE) / _totalLiquidity); //util rate after. 1000000 = 100.000% IndexTemplate.sol:292:                        uint256 _lockedCredit = _allocated - _availableBalance; PoolTemplate.sol:942:            return a - b; IndexTemplate.sol:308:                    _retVal = _totalLiquidity - _necessaryAmount; IndexTemplate.sol:393:                    uint256 _decrease = _current - _target; IndexTemplate.sol:399:                    uint256 _allocate = _target - _current; IndexTemplate.sol:441:                _shortage = _amount - _value; InsureDAOERC20.sol:255:        _balances[sender] = senderBalance - amount; InsureDAOERC20.sol:303:        _balances[account] = accountBalance - amount; Vault.sol:165:            uint256 _shortage = _amount - available(); Vault.sol:310:            uint256 _shortage = _retVal - available(); ```   ## Tools Used  VS Code   ## Recommended Mitigation Steps Uncheck arithmetic operations when the risk of underflow or overflow is already contained.  
# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ```   Vault.sol:92:        address[2] memory _beneficiaries, Vault.sol:93:        uint256[2] memory _shares ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.   
# Handle  Dravee   # Vulnerability details  ## Impact   Using both named returns and a return statement isn't necessary. Removing unused named return variables can reduce gas usage and improve code clarity. To save gas and improve code quality: consider using only one of those.      ## Proof of Concept   Instances include:   ``` CDSTemplate.sol:287:    function totalLiquidity() public view returns (uint256 _balance) { IndexTemplate.sol:491:    function leverage() public view returns (uint256 _rate) { IndexTemplate.sol:504:    function totalLiquidity() public view returns (uint256 _balance) { PoolTemplate.sol:628:        returns (uint256 premium) PoolTemplate.sol:833:        returns (uint256 _balance) PoolTemplate.sol:846:    function utilizationRate() public view override returns (uint256 _rate) { PoolTemplate.sol:858:    function totalLiquidity() public view override returns (uint256 _balance) { PoolTemplate.sol:866:    function originalLiquidity() public view returns (uint256 _balance) { ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Remove the unused named returns   
# Handle  Dravee   # Vulnerability details  ## Impact   Due to how the EVM natively works on 256 bit numbers, using a 8 bit number in for-loops introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage : > When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. > It is only beneficial to use reduced-size arguments if you are dealing with storage values because the compiler will pack multiple elements into one storage slot, and thus, combine multiple reads or writes into a single operation. When dealing with function arguments or memory values, there is no inherent benefit because the compiler does not pack these values.    ## Proof of Concept   ``` Vault.sol:109:        for (uint128 i = 0; i < 2; i++) { ```  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `uint256` as a counter in for-loops.   
# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept The `withdrawalReq[msg.sender].timestamp` and `parameters.getLockup(msg.sender)` values are used twice in the `require` statements, and both times summed.   ## Tools Used Manual review  ## Recommended Mitigation Steps Cache the sum value in a new variable. I've sent a similar report for IndexTemplate.withdraw() with a similar issue.  
# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept In [L197](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L197) of IndexTemplate, a `_balance` variable is created and initialized to the balance of `msg.sender`. However that variable is used only once in the function.  ## Tools Used Manual review  ## Recommended Mitigation Steps Replace L198 with `require(balanceOf(msg.sender) >= _amount, "ERROR: REQUEST_EXCEED_BALANCE");` and remove L197  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs  ## Proof of Concept  Solidity 0.8.10 has a useful change which reduced gas costs of external calls which expect a return value: https://blog.soliditylang.org/2021/11/09/solidity-0.8.10-release-announcement/  > Code Generator: Skip existence check for external contract if return data is expected. In this case, the ABI decoder will revert if the contract does not exist  InsureDAO is using 0.8.7:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L8  Updating to the newer version of solc will allow InsureDAO to take advantage of these lower costs for external calls.  ## Recommended Mitigation Steps  Update to solc 0.8.10 or above  
# Handle  cccz   # Vulnerability details  ## Impact When setting parameters in the Parameters contract, the input parameters are not verified.  For example, in the setFeeRate function, the _target parameter is not limited. When _target is greater than 1e6, DOS will occur when used in the insure function of the PoolTemplate contract ```     function setFeeRate(address _address, uint256 _target)         external         override         onlyOwner     {         _fee[_address] = _target;         emit FeeRateSet(_address, _target);     }    ...    function insure(         uint256 _amount,         uint256 _maxCost,         uint256 _span,         bytes32 _target     ) external returns (uint256) {         //Distribute premium and fee         uint256 _endTime = _span + block.timestamp;         uint256 _premium = getPremium(_amount, _span);         uint256 _fee = parameters.getFeeRate(msg.sender);          require(             _amount <= availableBalance(),             "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"         );         require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");         require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");         require(             parameters.getMinDate(msg.sender) <= _span,             "ERROR: INSURE_SPAN_BELOW_MIN"         );          require(             marketStatus == MarketStatus.Trading,             "ERROR: INSURE_MARKET_PENDING"         );         require(paused == false, "ERROR: INSURE_MARKET_PAUSED");          //current liquidity         uint256 _liquidity = totalLiquidity();         uint256 _totalCredit = totalCredit;          //accrue premium/fee         uint256[2] memory _newAttribution = vault.addValueBatch(             _premium,             msg.sender,             [address(this), parameters.getOwner()],             [MAGIC_SCALE_1E6-_fee, _fee]         ); ``` ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol  ## Tools Used  Manual analysis   ## Recommended Mitigation Steps  When setting parameters in the Parameters contract, verify the input parameters  
# Handle  Dravee   # Vulnerability details  ## Impact   Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.      ## Proof of Concept   ```   Factory.sol:176:            for (uint256 i = 0; i < _references.length; i++) { Factory.sol:186:            for (uint256 i = 0; i < _conditions.length; i++) { IndexTemplate.sol:655:        for (uint256 i = 0; i < poolList.length; i++) { PoolTemplate.sol:343:        for (uint256 i = 0; i < _ids.length; i++) { PoolTemplate.sol:671:        for (uint256 i = 0; i < indexList.length; i++) { PoolTemplate.sol:703:        for (uint256 i = 0; i < indexList.length; i++) { ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Store the array's length in a variable before the for-loop, and use it instead.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  Here if the lengths of these arrays are zero we'll fall straight through the for loops so there's no need for the if statements.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L175-L191  ## Recommended Mitigation Steps  Remove if statements  
# Handle  Dravee   # Vulnerability details  ## Impact   If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    ## Proof of Concept   Instances include:   ```   Factory.sol:176:            for (uint256 i = 0; i < _references.length; i++) { Factory.sol:186:            for (uint256 i = 0; i < _conditions.length; i++) { IndexTemplate.sol:280:            for (uint256 i = 0; i < _length; i++) { IndexTemplate.sol:348:        for (uint256 i = 0; i < _length; i++) { IndexTemplate.sol:381:        for (uint256 i = 0; i < _length; i++) { IndexTemplate.sol:462:        for (uint256 i = 0; i < _poolLength; i++) { IndexTemplate.sol:655:        for (uint256 i = 0; i < poolList.length; i++) { PoolTemplate.sol:343:        for (uint256 i = 0; i < _ids.length; i++) { PoolTemplate.sol:671:        for (uint256 i = 0; i < indexList.length; i++) { PoolTemplate.sol:703:        for (uint256 i = 0; i < indexList.length; i++) { Vault.sol:109:        for (uint128 i = 0; i < 2; i++) { ```      ## Tools Used   Manual Analysis      ## Recommended Mitigation Steps   Remove explicit initialization for default values.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  Here we push a new market onto an array in the factory whilst we just added the market to the registry.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L214-L216  ## Recommended Mitigation Steps  This array on the factory seems redundant and so it can be removed.  
# Handle  Dravee   # Vulnerability details  ## Impact   Increased gas cost      ## Proof of Concept   Solidity version 0.8.* already implements overflow and underflow checks by default.  Using the SafeMath library from OpenZeppelin (which is more gas expensive than the 0.8.* overflow checks) is therefore redundant.      Instances include:  ```   mocks\ERC20.sol:4:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; mocks\ERC20.sol:30:    using SafeMath for uint256; mocks\TestPremiumModel.sol:3:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; mocks\TestPremiumModel.sol:7:    using SafeMath for uint256; PremiumModels\BondingPremium.sol:10:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the built-in checks instead of SafeMath and remove SafeMath from the dependencies   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  It seems that we always want to get a pool's `allocatedCredit` and `availableBalance` together, suggesting that these values are tightly coupled.   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L284-L287  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L356-L360  If we're regularly going to be requesting these values together it may be worth considering having a single function in the pool template which returns both of these values. This would save gas costs of performing an extra external call to the pool contract.  ## Recommended Mitigation Steps  Consider having a function which returns both of these values to avoid repeated calls into the same contract for related info.  
# Handle  Dravee   # Vulnerability details  ## Impact   `!= 0` costs less gas compared to `> 0` for unsigned integer      ## Proof of Concept   `> 0` is used in the following location(s): ```   CDSTemplate.sol:100:                bytes(_metaData).length > 0 && CDSTemplate.sol:132:        require(_amount > 0, "ERROR: DEPOSIT_ZERO"); CDSTemplate.sol:140:        if (_supply > 0 && _liquidity > 0) { CDSTemplate.sol:142:        } else if (_supply > 0 && _liquidity == 0) { CDSTemplate.sol:191:        require(_amount > 0, "ERROR: REQUEST_ZERO"); CDSTemplate.sol:223:        require(_amount > 0, "ERROR: WITHDRAWAL_ZERO"); CDSTemplate.sol:296:        if (totalSupply() > 0) { Factory.sol:175:        if (_references.length > 0) { Factory.sol:185:        if (_conditions.length > 0) { Factory.sol:187:                if (conditionlist[address(_template)][i] > 0) { IndexTemplate.sol:133:                bytes(_metaData).length > 0 && IndexTemplate.sol:166:        require(_amount > 0, "ERROR: DEPOSIT_ZERO"); IndexTemplate.sol:172:        if (_supply > 0 && _totalLiquidity > 0) { IndexTemplate.sol:174:        } else if (_supply > 0 && _totalLiquidity == 0) { IndexTemplate.sol:199:        require(_amount > 0, "ERROR: REQUEST_ZERO"); IndexTemplate.sol:231:        require(_amount > 0, "ERROR: WITHDRAWAL_ZERO"); IndexTemplate.sol:246:        if (_liquidityAfter > 0) { IndexTemplate.sol:274:        if(_totalLiquidity > 0){ IndexTemplate.sol:283:                if (_allocPoint > 0) { IndexTemplate.sol:391:                if (_current > _target && _available != 0) { IndexTemplate.sol:427:            allocPoints[msg.sender] > 0, IndexTemplate.sol:477:        require(allocPoints[msg.sender] > 0); IndexTemplate.sol:493:        if (totalLiquidity() > 0) { IndexTemplate.sol:513:        if (totalSupply() > 0) { IndexTemplate.sol:612:        if (totalAllocPoint > 0) { IndexTemplate.sol:656:            if (allocPoints[poolList[i]] > 0) { InsureDAOERC20.sol:302:        require(accountBalance >= amount, "ERC20: burn amount exceeds balance"); Parameters.sol:31:    mapping(address => uint256) private _fee; //fee rate in 1e6 (100% = 1e6) PoolTemplate.sol:185:                bytes(_metaData).length > 0 && PoolTemplate.sol:218:        if (_conditions[1] > 0) { PoolTemplate.sol:237:        require(_amount > 0, "ERROR: DEPOSIT_ZERO"); PoolTemplate.sol:263:        require(_amount > 0, "ERROR: DEPOSIT_ZERO"); PoolTemplate.sol:282:        require(_amount > 0, "ERROR: REQUEST_ZERO"); PoolTemplate.sol:321:        require(_amount > 0, "ERROR: WITHDRAWAL_ZERO"); PoolTemplate.sol:391:        } else if (_index.credit > 0) { PoolTemplate.sol:396:            if (_pending > 0) { PoolTemplate.sol:401:        if (_credit > 0) { PoolTemplate.sol:437:        if (_credit > 0) { PoolTemplate.sol:444:        if (_pending > 0) { PoolTemplate.sol:521:        if (_totalCredit > 0) { PoolTemplate.sol:672:            if (indicies[indexList[i]].credit > 0) { PoolTemplate.sol:706:            if (_credit > 0) { PoolTemplate.sol:726:        if (_deductionFromPool > 0) { PoolTemplate.sol:745:        if (totalSupply() > 0) { PoolTemplate.sol:802:        if (_supply > 0 && _originalLiquidity > 0) { PoolTemplate.sol:804:        } else if (_supply > 0 && _originalLiquidity == 0) { PoolTemplate.sol:835:        if (totalLiquidity() > 0) { PoolTemplate.sol:847:        if (lockedAmount > 0) { PoolTemplate.sol:929:        require(b > 0); Vault.sol:154:            attributions[msg.sender] > 0 && Vault.sol:187:            attributions[msg.sender] > 0 && Vault.sol:220:            attributions[msg.sender] > 0 && Vault.sol:347:        if (_amount > 0) { Vault.sol:388:        if (totalAttributions > 0 && _attribution > 0) { Vault.sol:406:        if (attributions[_target] > 0) { Vault.sol:473:        } else if (IERC20(_token).balanceOf(address(this)) > 0) { ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Change `> 0` with `!= 0`.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  gas costs  ## Proof of Concept  Here on L563 we check the market status however we have already done this on L558  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L557-L567  ## Recommended Mitigation Steps  Remove redundant check (check other market templates as well)  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  When transferring any of the market tokens, a check is performed to see if they have a pending withdrawal and reduce it if their balance falls below the requested amount.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L910-L923  In the case where a user has no pending withdrawal we then perform an unnecessary check on their balance. We could save an SLOAD by changing it to the below  ``` if (from != address(0)) {     uint256 reqAmount = withdrawalReq[from].amount     if (reqAmount > 0){         uint256 _after = balanceOf(from) - amount;         if (_after < reqAmount) {             withdrawalReq[from].amount = _after;         }     }  } ```  ## Recommended Mitigation Steps  As above  
# Handle  Dravee   # Vulnerability details  ## Impact   Reducing from public to private will save gas    ## Proof of Concept   ```   PremiumModels\BondingPremium.sol:26:    //constants PremiumModels\BondingPremium.sol:27:    uint256 public constant DECIMAL = uint256(1e6); //Decimals of USDC PremiumModels\BondingPremium.sol:28:    uint256 public constant BASE = uint256(1e6); //bonding curve graph takes 1e6 as 100.0000% PremiumModels\BondingPremium.sol:29:    uint256 public constant BASE_x2 = uint256(1e12); //BASE^2 PremiumModels\BondingPremium.sol:30:    uint256 public constant ADJUSTER = uint256(10); //adjuster of 1e6 to 1e5 (100.0000% to 100.000%) CDSTemplate.sol:55:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation IndexTemplate.sol:95:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation PoolTemplate.sol:146:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation Vault.sol:38:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Theses constants can simply be read from the verified contract, i.e., it is unnecessary to expose it with a public function. Also, constants having "1E6" in their name aren't even "nice to have public constants", as their value is obvious.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept  The `Withdrawal` struct in `IndexTemplate.sol` contains a timestamp and the amount of tokens which the user requests to withdraw.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L81-L84  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L198  If we make the safe assumption that the user's balance does not exceed 2^192 then we can pack this struct into a single storage slot to save an SLOAD by changing the definition to:  ``` struct Withdrawal {     uint64 timestamp;     uint192 amount; } ```  ## Recommended Mitigation Steps  As above  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  gas costs  ## Proof of Concept  In the sqrt function it is known that the while loop will not overflow so it can be safely left unchecked to save gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PremiumModels/BondingPremium.sol#L238-L245  ```     function sqrt(uint256 x) internal pure returns (uint256 y) {         uint256 z = (x + 1) / 2;         unchecked {             y = x;             while (z < y) {                 y = z;                 z = (x / z + z) / 2;             }         }     } ``` ## Recommended Mitigation Steps  wrap entire function body in a unchecked block as above  
# Handle  robee   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          InsureDAOERC20.sol : reachable assert in line 31         Vault.sol : reachable assert in line 167   
# Handle  robee   # Vulnerability details  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           CDSTemplate.sol, totalLiquidity         Factory.sol, _createClone         IndexTemplate.sol, withdrawable         IndexTemplate.sol, leverage         IndexTemplate.sol, totalLiquidity         PoolTemplate.sol, availableBalance         PoolTemplate.sol, utilizationRate         PoolTemplate.sol, totalLiquidity  
# Handle  robee   # Vulnerability details  The following requires are with empty messages.  This is very important to add a message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: CDSTemplate.sol, In line 253 with Empty Require message.         Solidity file: Factory.sol, In line 100 with Empty Require message.         Solidity file: IndexTemplate.sol, In line 477 with Empty Require message.         Solidity file: PoolTemplate.sol, In line 929 with Empty Require message.         Solidity file: Vault.sol, In line 66 with Empty Require message.         Solidity file: Vault.sol, In line 67 with Empty Require message.         Solidity file: Vault.sol, In line 68 with Empty Require message.   
# Handle  robee   # Vulnerability details  The following functions could skip other steps if the amount is 0. (A similar issue: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82)           InsureDAOERC20.sol, name         InsureDAOERC20.sol, symbol         InsureDAOERC20.sol, decimals         InsureDAOERC20.sol, totalSupply         InsureDAOERC20.sol, balanceOf         InsureDAOERC20.sol, transfer         InsureDAOERC20.sol, allowance         InsureDAOERC20.sol, approve         InsureDAOERC20.sol, transferFrom         InsureDAOERC20.sol, increaseAllowance         InsureDAOERC20.sol, decreaseAllowance         InsureDAOERC20.sol, _transfer         InsureDAOERC20.sol, _mint         InsureDAOERC20.sol, _burn         InsureDAOERC20.sol, _approve         InsureDAOERC20.sol, _beforeTokenTransfer         InsureDAOERC20.sol, _afterTokenTransfer  
# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function totalLiquidity in CDSTemplate.sol could be set external         The function valueOfUnderlying in CDSTemplate.sol could be set external         The function createMarket in Factory.sol could be set external         The function totalLiquidity in IndexTemplate.sol could be set external         The function set in IndexTemplate.sol could be set external         The function leverage in IndexTemplate.sol could be set external         The function withdrawable in IndexTemplate.sol could be set external         The function valueOfUnderlying in IndexTemplate.sol could be set external         The function deposit in IndexTemplate.sol could be set external         The function adjustAlloc in IndexTemplate.sol could be set external         The function allowance in InsureDAOERC20.sol could be set external         The function decimals in InsureDAOERC20.sol could be set external         The function totalSupply in InsureDAOERC20.sol could be set external         The function name in InsureDAOERC20.sol could be set external         The function transfer in InsureDAOERC20.sol could be set external         The function increaseAllowance in InsureDAOERC20.sol could be set external         The function transferFrom in InsureDAOERC20.sol could be set external         The function decreaseAllowance in InsureDAOERC20.sol could be set external         The function balanceOf in InsureDAOERC20.sol could be set external         The function symbol in InsureDAOERC20.sol could be set external         The function approve in InsureDAOERC20.sol could be set external         The function getOwner in Parameters.sol could be set external         The function utilizationRate in PoolTemplate.sol could be set external         The function totalLiquidity in PoolTemplate.sol could be set external         The function availableBalance in PoolTemplate.sol could be set external         The function getPremium in PoolTemplate.sol could be set external         The function valueOfUnderlying in PoolTemplate.sol could be set external         The function unlock in PoolTemplate.sol could be set external         The function originalLiquidity in PoolTemplate.sol could be set external         The function deposit in PoolTemplate.sol could be set external         The function allocatedCredit in PoolTemplate.sol could be set external         The function getPremiumRate in BondingPremium.sol could be set external         The function getCurrentPremiumRate in BondingPremium.sol could be set external         The function getPricePerFullShare in Vault.sol could be set external         The function valueAll in Vault.sol could be set external         The function setController in Vault.sol could be set external         The function underlyingValue in Vault.sol could be set external   
# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           CDSTemplate.sol: parameters.getLockup is read twice in withdraw         Factory.sol: registry is read twice in createMarket         IndexTemplate.sol: totalAllocPoint is read twice in set         IndexTemplate.sol: MAGIC_SCALE_1E6 is read twice in withdrawable         PoolTemplate.sol: parameters.getLockup is read twice in withdraw         PoolTemplate.sol: lockedAmount is read twice in utilizationRate         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in allocateCredit         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in withdrawCredit         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in insure         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in resume         BondingPremium.sol: k is read twice in getCurrentPremiumRate         BondingPremium.sol: k is read twice in getPremiumRate         BondingPremium.sol: c is read twice in getPremiumRate         BondingPremium.sol: b is read twice in getCurrentPremiumRate         BondingPremium.sol: b is read twice in getPremiumRate         BondingPremium.sol: T_1 is read twice in getCurrentPremiumRate         BondingPremium.sol: T_1 is read twice in getPremiumRate         BondingPremium.sol: BASE is read twice in getCurrentPremiumRate         BondingPremium.sol: BASE is read twice in getPremiumRate         BondingPremium.sol: BASE_x2 is read twice in getCurrentPremiumRate         BondingPremium.sol: BASE_x2 is read twice in getPremiumRate         Vault.sol: token is read twice in repayDebt         Vault.sol: token is read twice in utilize         Vault.sol: token is read twice in withdrawRedundant         Vault.sol: totalAttributions is read twice in attributionValue         Vault.sol: balance is read twice in valueAll         Vault.sol: balance is read twice in withdrawRedundant   
# Handle  robee   # Vulnerability details  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.  The format is <solidity file>, <unused storage variable name>:           IndexTemplate.sol, pendingEnd         BondingPremium.sol, ADJUSTER   
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           Factory.sol, line 13, import "hardhat/console.sol";         IndexTemplate.sol, line 6, import "hardhat/console.sol";         Parameters.sol, line 12, import "hardhat/console.sol";         BondingPremium.sol, line 9, import "@openzeppelin/contracts/utils/math/SafeMath.sol";   
# Handle  Dravee   # Vulnerability details  ## Impact Checking if the value is 0 before returning 0 is less expensive than returning a calculation that's equal to 0  ## Proof of Concept In `PoolTemplate.sol:rate()`, the code is as follows: ``` File: PoolTemplate.sol 744:     function rate() external view returns (uint256) { 745:         if (totalSupply() > 0) { 746:             return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); 747:         } else { 748:             return 0; 749:         } 750:     }  ``` It can be optimized as such: ``` 744:     function rate() external view returns (uint256) { 745:         uint256 originalLiquidity = originalLiquidity(); 746:         if (originalLiquidity != 0 && totalSupply() > 0) { 747:             return (originalLiquidity * MAGIC_SCALE_1E6) / totalSupply(); 748:         } else { 749:             return 0; 750:         } 751:     }  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable and make the 0 checks to avoid unnecessary calculations if `originalLiquidity() == 0`  
# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `PoolTemplate.sol:worth()`, the code is as follows: ``` 799:     function worth(uint256 _value) public view returns (uint256 _amount) { 800:         uint256 _supply = totalSupply(); 801:         uint256 _originalLiquidity = originalLiquidity(); 802:         if (_supply > 0 && _originalLiquidity > 0) { 803:             _amount = (_value * _supply) / _originalLiquidity; 804:         } else if (_supply > 0 && _originalLiquidity == 0) { 805:             _amount = _value * _supply; 806:         } else { 807:             _amount = _value; 808:         } 809:     } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for further information): ```     function worth(uint256 _value) public view returns (uint256 _amount) {         uint256 _supply = totalSupply();         uint256 _originalLiquidity = originalLiquidity();         if (_supply == 0) {             _amount = _value;         } else if (_originalLiquidity == 0) {             _amount = _value * _supply;         } else {             _amount = (_value * _supply) / _originalLiquidity;         }     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements   
# Handle  pauliax   # Vulnerability details  ## Impact In IndexTemplate, function compensate, When _amount > _value, and <= totalLiquidity(), the value of _compensated is not set, so it gets a default value of 0: ```solidity if (_value >= _amount) {     ...     _compensated = _amount; } else {     ...     if (totalLiquidity() < _amount) {         ...         _compensated = _value + _cds;     }     vault.offsetDebt(_compensated, msg.sender); } ```  But nevertheless, in both cases, it calls vault.offsetDebt, even when the _compensated is 0 (no else block).  ## Recommended Mitigation Steps I think, in this case, it should try to redeem the premium (withdrawCredit?) to cover the whole amount, but I am not sure about the intentions as I didn't have enough time to understand this protocol in depth.  
# Handle  Dravee   # Vulnerability details  ## Impact The transactions could fail if the array get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L703  ## Tools Used VS Code  ## Recommended Mitigation Steps Keep the array size small.  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 MSTORE and 1 MLOAD)  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L553 There's no readability or gas gain from copying `incident.payoutDenominator` to a variable as it's used only once in the method.  ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 MSTORE and 1 MLOAD)  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L552 There's no readability or gas gain from copying `incident.payoutNumerator` to a variable as it's used only once in the method.  ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable  
# Handle  Dravee   # Vulnerability details  ## Impact Checking if the value is 0 before returning 0 is less expensive than returning a calculation that's equal to 0  ## Proof of Concept In `Vault.sol:underlyingValue()`, the code is as follows: ``` Vault.sol 400:     function underlyingValue(address _target) 401:         public 402:         view 403:         override 404:         returns (uint256) 405:     { 406:         if (attributions[_target] > 0) { 407:             return (valueAll() * attributions[_target]) / totalAttributions; 408:         } else { 409:             return 0; 410:         } 411:     } ``` It can be optimized as such:  ``` 406:         uint256 valueAll = valueAll(); 407:         if (valueAll != 0 && attributions[_target] > 0) { 408:             return (valueAll * attributions[_target]) / totalAttributions; 409:         } else { 410:             return 0; 411:         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable and make the 0 checks to avoid unnecessary calculations if `valueAll() == 0`  
# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `attributions[_target]` can be loaded twice from storage: ``` Vault.sol 400:     function underlyingValue(address _target) 401:         public 402:         view 403:         override 404:         returns (uint256) 405:     { 406:         if (attributions[_target] > 0) { 407:             return (valueAll() * attributions[_target]) / totalAttributions; 408:         } else { 409:             return 0; 410:         } 411:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable  
# Handle  pauliax   # Vulnerability details  ## Impact There are some issues with comments/documentation, e.g.: Misleading comment: ```solidity    * @return true if the id within the market already exists   function getCDS(address _address) external view override returns (address) ``` No such function (present in documentation): ```solidity   function getInsuranceCount(address _user) ``` "getInsuranceCount returns how many insurance policies the specified user has."  ## Recommended Mitigation Steps Consider revisiting and updating discrepancies between the documentation and comments.  
# Handle  Kumpirmafyas   # Vulnerability details  ## Impact The order of the "struct Template" in the Factory.sol contract is as follows: 1-bool isOpen 2-bool approval 3-bool allowDuplicate https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L44-L48   The struct above is used in functions as value, in the "key=>value" part in this mapping. https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L49  When using "template" mapping in this function, it is not done in the defined order, Detail: - isOpen bool , defined in Struct in the 1st row, -isOpen bool ,defined in the 1st position in Mapping, naturally -isOpen bool is defined in the 2nd row in the "approveTemplate" function below. -The same applies to the approvel bool struct.  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L101-L103   The problem here is; The order in which Structs are used in a Function is not. Problem ; The order of the structs in the "key => value" mapping definition affects the function. Sequencing is important in struct definition in mappings.   ## Recommended Mitigation Steps The order in the struct = the order in the mapping = the order in the function must be the same.  Here ; Sorting in Mapping with Struct is a mandatory condition, while sorting in a function is within the scope of clean code.  
# Handle  pauliax   # Vulnerability details  ## Impact Statements should be ordered in a way that it costs less gas, that is, less operations are performed when the validating conditions are wrong. e.g. this can be reordered: ```solidity   //Distribute premium and fee   uint256 _endTime = _span + block.timestamp;   uint256 _premium = getPremium(_amount, _span);   uint256 _fee = parameters.getFeeRate(msg.sender);    require(       _amount <= availableBalance(),       "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"   );   require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");   require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");   require(       parameters.getMinDate(msg.sender) <= _span,       "ERROR: INSURE_SPAN_BELOW_MIN"   );    require(       marketStatus == MarketStatus.Trading,       "ERROR: INSURE_MARKET_PENDING"   );   require(paused == false, "ERROR: INSURE_MARKET_PAUSED"); ``` to something like this: ```solidity   require(paused == false, "ERROR: INSURE_MARKET_PAUSED");   require(       marketStatus == MarketStatus.Trading,       "ERROR: INSURE_MARKET_PENDING"   );    require(       _amount <= availableBalance(),       "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"   );    require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");   require(       parameters.getMinDate(msg.sender) <= _span,       "ERROR: INSURE_SPAN_BELOW_MIN"   );    //Distribute premium and fee   uint256 _premium = getPremium(_amount, _span);   require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");    uint256 _endTime = _span + block.timestamp;   uint256 _fee = parameters.getFeeRate(msg.sender); ```  
# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `_fee[_target]` can be loaded twice from storage: ``` 271:     function getFeeRate(address _target) 272:         external 273:         view 274:         override 275:         returns (uint256) 276:     { 277:         if (_fee[_target] == 0) { 278:             return _fee[address(0)]; 279:         } else { 280:             return _fee[_target]; 281:         } 282:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the storage reading in a memory variable  
# Handle  gzeon   # Vulnerability details  ## Impact Use unchecked for safe math to save gas, for example: https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PremiumModels/BondingPremium.sol#L176 ```         premiumRate = premiumRate / T_1 / (u1 - u2) / BASE; ``` Since we have 1) T_1 != 0 (L229) 2) (u1 - u2) != 0 (L126-132) 3) BASE != 0 (L28) we can safely wrap this line in an unchecked block  
# Handle  pauliax   # Vulnerability details  ## Impact _withdrawAttribution should validate that _to is not an empty address 0x0 to prevent accidental burns. Similarly, transferValue _destination param and withdrawValue _to param should also be checked against an empty address unless this is the intended functionality in some cases.  ## Recommended Mitigation Steps require _to != address(0)  
# Handle  Dravee   # Vulnerability details  ## Impact  Division by 0 or functionally incorrect `targetLev`  ## POC A division by `targetLev` is made here : https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L306 and `targetLev` can be set to 0 : https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L575  ## Tools Used VS Code  ## Recommended Mitigation Steps Either make a check on `targetLev` before setting it here: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L575 or make a check before the division here: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L306   
# Handle  pauliax   # Vulnerability details  ## Impact Can be refactored, from this: ```solidity   require(       request.timestamp +           parameters.getLockup(msg.sender) <           block.timestamp,       "ERROR: WITHDRAWAL_QUEUE"   );   require(       request.timestamp +           parameters.getLockup(msg.sender) +           parameters.getWithdrawable(msg.sender) >           block.timestamp,       "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"   ); ``` to this: ```solidity   uint256 unlocksAt = request.timestamp + parameters.getLockup(msg.sender);   require(       unlocksAt < block.timestamp,       "ERROR: WITHDRAWAL_QUEUE"   );   require(       unlocksAt + parameters.getWithdrawable(msg.sender) > block.timestamp,       "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"   ); ```  There are more places where this optimization could be applied besides the provided example, but the basic idea is to cache the result of repeated math operation when the value does not change.  
# Handle  pauliax   # Vulnerability details  ## Impact function repayDebt could be refactored to reduce deployment and operational costs from this: ```solidity   uint256 _debt = debts[_target];   if (_debt >= _amount) {       debts[_target] -= _amount;       totalDebt -= _amount;       IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);   } else {       debts[_target] = 0;       totalDebt -= _debt;       IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);   } ``` to this: ```solidity   uint256 _debt = debts[_target];   if (_debt > _amount) {       debts[_target] = _debt - _amount;   } else {       debts[_target] = 0;       _amount = _debt;   }   totalDebt -= _amount;   IERC20(token).safeTransferFrom(msg.sender, address(this), _amount); ```  
# Handle  pauliax   # Vulnerability details  ## Impact Repeated storage read should be cached, e.g. attributions[_target] is read from storage twice: ```solidity         if (attributions[_target] > 0) {             return (valueAll() * attributions[_target]) / totalAttributions; ``` totalAttributions read twice: ```solidity         if (totalAttributions > 0 && _attribution > 0) {             return (_attribution * valueAll()) / totalAttributions; ``` available() called twice: ```solidity         if (available() < _retVal) {             uint256 _shortage = _retVal - available(); ``` would be cheaper to use _token from memory here: ```solidity     IERC20(token).safeTransfer(_to, _redundant); ```  There are more places where this optimization could be applied besides the provided examples, but the basic idea is to cache storage variables if you need to access them multiple times when the value does not change.  
# Handle  pauliax   # Vulnerability details  ## Impact Avoid repeated external calls, e.g. here token balanceOf is queried 4 times: ```solidity if (     ...     balance < IERC20(token).balanceOf(address(this)) ) {     uint256 _redundant = IERC20(token).balanceOf(address(this)) - balance;     ... } else if (IERC20(_token).balanceOf(address(this)) > 0) {     IERC20(_token).safeTransfer(         _to,         IERC20(_token).balanceOf(address(this))     ); } ``` You should query it only once and then use the cached value as it doesn't change between the statements.  
# Handle  pauliax   # Vulnerability details  ## Impact You dont need this else block, code can be refactored from this: ```solidity   if (address(controller) != address(0)) {       controller.migrate(address(_controller));       controller = IController(_controller);   } else {       controller = IController(_controller);   } ``` to this: ```solidity   if (address(controller) != address(0)) {       controller.migrate(address(_controller));   }   controller = IController(_controller); ```  
# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `totalLiquidity()` is loaded twice from storage ``` 491:     function leverage() public view returns (uint256 _rate) { 492:         //check current leverage rate 493:         if (totalLiquidity() > 0) { 494:             return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); 495:         } else { 496:             return 0; 497:         } 498:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `totalLiquidity()` in a variable  
# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `IndexTemplate.sol:deposit()`, the code is as follows: ``` 172:         if (_supply > 0 && _totalLiquidity > 0) {   173:             _mintAmount = (_amount * _supply) / _totalLiquidity; 174:         } else if (_supply > 0 && _totalLiquidity == 0) { 175:             //when 176:             _mintAmount = _amount * _supply; 177:         } else { 178:             _mintAmount = _amount; 179:         } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for further information): ```       if (_supply == 0) {           _mintAmount = _amount;       } else if (_totalLiquidity == 0) { // @audit-info : implicit _supply > 0 as above condition is false           _mintAmount = _amount * _supply;       } else { // @audit-info : implicit _supply > 0 and _totalLiquidity > 0 as both the previous conditions are false           _mintAmount = (_amount * _supply) / _totalLiquidity;       } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements   
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost as SSTOREs are very expensive  ## Proof of Concept The code is as follows : ``` 094:     function approveTemplate( 095:         IUniversalMarket _template, 096:         bool _approval, 097:         bool _isOpen, 098:         bool _duplicate 099:     ) external override onlyOwner { 100:         require(address(_template) != address(0)); 101:         templates[address(_template)].approval = _approval; //@audit-info SSTORE 102:         templates[address(_template)].isOpen = _isOpen; //@audit-info SSTORE 103:         templates[address(_template)].allowDuplicate = _duplicate; //@audit-info SSTORE 104:         emit TemplateApproval(_template, _approval, _isOpen, _duplicate); 105:     } ``` As we can see, it's making 3 SSTORE operations, one for each boolean. The code could be optimized as follows to save gas : ```     function approveTemplate(         IUniversalMarket _template,         bool _approval,         bool _isOpen,         bool _duplicate     ) external override onlyOwner {         require(address(_template) != address(0));         Template memory approvedTemplate = new Template(_isOpen, _approval, _duplicate);         templates[address(_template)] = approvedTemplate; //@audit-info only one SSTORE         emit TemplateApproval(_template, _approval, _isOpen, _duplicate);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use a memory `Template ` struct and write in storage only once  
# Handle  Dravee   # Vulnerability details  The spec says the function should be called `approveCondition()` instead of `setCondition`: https://insuredao.gitbook.io/developers/market/factory#approvecondition  While this might still be understood nonetheless as `setCondition` is also mentioned, the spec says that the parameter `_slot` is the `index of the reference array`, whereas the code comment says it's the `index within condition array`: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L133  ## Tools Used VS Code  ## Recommended Mitigation Steps My guess is that the spec should be corrected  
# Handle  Dravee   # Vulnerability details  The spec doesn't match with the comments in the code here:   Code: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L90-L91 Spec: https://insuredao.gitbook.io/developers/market/factory#approvetemplate  Here, the spec doesn't mention `_isOpen` and seem to confuse the `_approval` description with what `_isOpen` should be.  ## Tools Used VS Code  ## Recommended Mitigation Steps My guess is that the spec should be corrected  
# Handle  Dravee   # Vulnerability details  ## Impact A division by 0 could occur  ## Proof of Concept While at some places, a check is made to make sure that `totalSupply() > 0`, it's not consistently the case, such as in the following places:  ``` contracts\CDSTemplate.sol:235:        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply(); contracts\CDSTemplate.sol:318:                _balance * vault.attributionValue(crowdPool) / totalSupply(); contracts\IndexTemplate.sol:216:        _retVal = (_liquidty * _amount) / totalSupply(); contracts\IndexTemplate.sol:530:            return (_balance * totalLiquidity()) / totalSupply(); contracts\PoolTemplate.sol:768:            return (_balance * originalLiquidity()) / totalSupply(); ```  At the following places, the check is indeed made: ``` contracts\IndexTemplate.sol:514:            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); contracts\PoolTemplate.sol:747:            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps If this check is at least made at some places, this means that `totalSupply()` can indeed take a value of 0. Therefore, a check should always be made to prevent the div by 0  
# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `CDSTemplate.sol:deposit()`, the code is as follows: ``` 140:         if (_supply > 0 && _liquidity > 0) {  141:             _mintAmount = (_amount * _supply) / _liquidity; 142:         } else if (_supply > 0 && _liquidity == 0) { 143:             //when vault lose all underwritten asset =  144:             _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again. 145:         } else { 146:             //when _supply == 0, 147:             _mintAmount = _amount; 148:         } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for futher information): ```         if (_supply == 0) {              _mintAmount = _amount;         } else if (_liquidity == 0) { // @audit-info : implicit _supply > 0 as above condition is false             //when vault lose all underwritten asset =              _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.         } else { // @audit-info : implicit _supply > 0 and _liquidity > 0 as both the previous conditions are false             _mintAmount = (_amount * _supply) / _liquidity;         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements  
# Handle  Fitraldys   # Vulnerability details  ## Impact In the https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L157 it is the descriptionof the depoist function, and not the correct description for the fund function.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L156-L173    
# Handle  WatchPug   # Vulnerability details  ## Root Cause  Wrong arithmetic.  ---  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L700-L717  ```solidity uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /             totalLiquidity();     uint256 _actualDeduction;     for (uint256 i = 0; i < indexList.length; i++) {         address _index = indexList[i];         uint256 _credit = indicies[_index].credit;         if (_credit > 0) {             uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /                 _totalCredit;             uint256 _redeemAmount = _divCeil(                 _deductionFromIndex,                 _shareOfIndex             );             _actualDeduction += IIndexTemplate(_index).compensate(                 _redeemAmount             );         }     } ```   ### PoC  - totalLiquidity = 200,000* 10**18; - totalCredit = 100,000 * 10**18; - debt = 10,000 * 10**18;  - [Index Pool 1] Credit = 20,000 * 10**18; - [Index Pool 2] Credit = 30,000 * 10**18;  ``` uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /             totalLiquidity(); // _deductionFromIndex = 10,000 * 10**6 * 10**18;  ```  [Index Pool 1]:  ``` uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;   //  _shareOfIndex = 200000  uint256 _redeemAmount = _divCeil(     _deductionFromIndex,     _shareOfIndex );  // _redeemAmount = 25,000 * 10**18; ```  [Index Pool 2]:  ``` uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;   //  _shareOfIndex = 300000  uint256 _redeemAmount = _divCeil(     _deductionFromIndex,     _shareOfIndex );  // _redeemAmount = 16666666666666666666667 (~ 16,666 * 10**18) ```  In most cases, the transaction will revet on underflow at: ``` uint256 _shortage = _deductionFromIndex /             MAGIC_SCALE_1E6 -             _actualDeduction; ```  In some cases, specific pools will be liable for unfair compensation:  If the CSD is empty, `Index Pool 1` only have `6,000 * 10**18` and `Index Pool 2` only have `4,000 * 10**18`, the `_actualDeduction` will be `10,000 * 10**18`, `_deductionFromPool` will be `0`.   `Index Pool 1` should only pay `1,000 * 10**18`, but actually paid `6,000 * 10**18`, the LPs of `Index Pool 1` now suffer funds loss.  ### Recommendation  Change to:  ```solidity uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) / totalLiquidity(); uint256 _actualDeduction; for (uint256 i = 0; i < indexList.length; i++) {     address _index = indexList[i];     uint256 _credit = indicies[_index].credit;     if (_credit > 0) {         uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /             _totalCredit;         uint256 _redeemAmount = _divCeil(             _deductionFromIndex * _shareOfIndex,             MAGIC_SCALE_1E6 * MAGIC_SCALE_1E6         );         _actualDeduction += IIndexTemplate(_index).compensate(             _redeemAmount         );     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L146-L146  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L95-L95  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L55-L55  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L38-L38  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```  For the constants that should not be `public`, changing them to `private` / `internal` can save some gas. To avoid unnecessary getter functions.  
# Handle  WatchPug   # Vulnerability details  In the current implementation, when an incident is reported for a certain pool, the index pool can still `withdrawCredit()` from the pool, which in the best interest of an index pool, the admin of the index pool is preferred to do so.  This allows the index pool to escape from the responsibility for the risks of invested pools.  Making the LPs of the pool take an unfair share of the responsibility.  ### PoC  - Pool A `totalCredit` = 10,000 - Pool A `rewardPerCredit` = 1  1. [Index Pool 1] allocates 1,000 credits to Pool `A`:  - `totalCredit` = 11,000 - indicies[Index Pool 1] = 1,000  2. After a while, Pool A `rewardPerCredit` has grown to `1.1`, and `applyCover()` has been called, [Index Pool 1] call `withdrawCredit()` get 100 premium  - `totalCredit` = 10,000 - indicies[Index Pool 1] = 0  3. After `pendingEnd`, the pool `resume()`,[ Index Pool 1] will not be paying for the compensation since `credit` is 0.  In our case, [Index Pool 1] earned premium without paying for a part of the compensation.  ### Recommendation  Change to:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L416-L421  ```solidity     function withdrawCredit(uint256 _credit)         external         override         returns (uint256 _pending)     {         require(             marketStatus == MarketStatus.Trading,             "ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS"         );         IndexInfo storage _index = indicies[msg.sender]; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L429-L434  ```solidity function _unutilize(uint256 _amount) internal {     require(address(controller) != address(0), "ERROR_CONTROLLER_NOT_SET");      controller.withdraw(address(this), _amount);     balance += _amount; } ```  ### Recommendation  Can be changed to:  ```solidity function _unutilize(uint256 _amount) internal {     require(address(controller) != address(0), "ERROR_CONTROLLER_NOT_SET");      uint256 beforeBalance = IERC20(token).balanceOf(address(this));     controller.withdraw(address(this), _amount);     uint256 received = IERC20(token).balanceOf(address(this)) - beforeBalance;     require(received >= _amount, "...");     balance += received; } ```   
# Handle  WatchPug   # Vulnerability details  ## Root Cause  Precision loss while converting between `the amount of shares` and `the amount of underlying tokens` back and forth is not handled properly.  ---  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L438-L447  ```solidity uint256 _shortage; if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = _value + _cds; } vault.offsetDebt(_compensated, msg.sender); ```  In the current implementation, when someone tries to resume the market after a pending period ends by calling `PoolTemplate.sol#resume()`, `IndexTemplate.sol#compensate()` will be called internally to make a payout. If the index pool is unable to cover the compensation, the CDS pool will then be used to cover the shortage.  However, while `CDSTemplate.sol#compensate()` takes a parameter for the amount of underlying tokens, it uses `vault.transferValue()` to transfer corresponding `_attributions` (shares) instead of underlying tokens.  Due to precision loss, the `_attributions` transferred in the terms of underlying tokens will most certainly be less than the shortage.  At L444, the contract believes that it's been compensated for `_value + _cds`, which is lower than the actual value, due to precision loss.  At L446, when it calls `vault.offsetDebt(_compensated, msg.sender)`, the tx will revert at `require(underlyingValue(msg.sender) >= _amount)`.  As a result, `resume()` can not be done, and the debt can't be repaid.  ### PoC   Given:  - vault.underlyingValue = 10,000 - vault.valueAll = 30,000 - totalAttributions = 2,000,000 - _amount = 1,010,000  0. _shortage = _amount - vault.underlyingValue = 1,000,000 1. _attributions = (_amount * totalAttributions) / valueAll = 67,333,333 2. actualValueTransfered = (valueAll * _attributions) / totalAttributions = 1009999  **Expected results**: actualValueTransfered = _shortage;  **Actual results**: actualValueTransfered < _shortage.  ## Impact  The precision loss isn't just happening on special numbers, but will most certainly always revert the txs.  This will malfunction the contract as the index pool can not `compensate()`, therefore the pool can not `resume()`. Causing the funds of the LPs of the pool and the index pool to be frozen, and other stakeholders of the same vault will suffer fund loss from an unfair share of the funds compensated before.  ## Recommendation  Change to:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L439-L446  ```solidity if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = vault.underlyingValue(address(this)); } vault.offsetDebt(_compensated, msg.sender); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L485-L496  ```solidity function setController(address _controller) public override onlyOwner {     require(_controller != address(0), "ERROR_ZERO_ADDRESS");      if (address(controller) != address(0)) {         controller.migrate(address(_controller));         controller = IController(_controller);     } else {         controller = IController(_controller);     }      emit ControllerSet(_controller); } ```  `controller.migrate()` is a critical operation, we recommend adding validation for the amount of migrated funds.  ### Recommendation  Can be changed to:  ```solidity function setController(address _controller) public override onlyOwner {     require(_controller != address(0), "ERROR_ZERO_ADDRESS");      if (address(controller) != address(0)) {         uint256 beforeUnderlying = controller.valueAll();         controller.migrate(address(_controller));         require(IController(_controller).valueAll() >= beforeUnderlying, "...");         controller = IController(_controller);     } else {         controller = IController(_controller);     }      emit ControllerSet(_controller); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Ownership.sol#L17-L20  ```solidity constructor() {     _owner = msg.sender;     emit AcceptNewOwnership(_owner); } ```  At L19, the parameter of `AcceptNewOwnership` can use `msg.sender` directly to avoid unnecessary storage read of `_owner` to save some gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Ownership.sol#L65-L71  ```solidity function acceptTransferOwnership() external override onlyFutureOwner {     /***         *@notice Accept a transfer of ownership         */     _owner = _futureOwner;     emit AcceptNewOwnership(_owner); } ```  At L69, `_futureOwner` can use `msg.sender` directly to avoid unnecessary storage read of `_futureOwner` to save some gas.  As `onlyFutureOwner()` ensures that `require(_futureOwner == msg.sender, "...");`.  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L153-L158  ```solidity require(     attributions[msg.sender] > 0 &&         underlyingValue(msg.sender) >= _amount,     "ERROR_WITHDRAW-VALUE_BADCONDITOONS" ); _attributions = (totalAttributions * _amount) / valueAll(); ```  In `Vault#withdrawValue()`, `controller.valueAll()` is called twice:  1. L155 `underlyingValue(msg.sender)` -> `valueAll()` -> `controller.valueAll()`; 1. L158 `valueAll()` ->  `controller.valueAll()`.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L400-L411  ```solidity function underlyingValue(address _target)     public     view     override     returns (uint256) {     if (attributions[_target] > 0) {         return (valueAll() * attributions[_target]) / totalAttributions;     } else {         return 0;     } } ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L417-L423  ```solidity function valueAll() public view returns (uint256) {     if (address(controller) != address(0)) {         return balance + controller.valueAll();     } else {         return balance;     } } ```  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on the function call  ## Proof of Concept  availableBalance calls totalLiquidity() twice:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L835  ## Recommended Mitigation Steps  Save the call result to memory and use it  
# Handle  hyh   # Vulnerability details    ## Impact  `setKeeper` / `utilize` descriptions state that it is controller who is set / can run utilize, while keeper and controller are two separate roles, which don't have to coincide.  I.e. the descriptions now mix up the roles and are confusing this way.  ## Proof of Concept  setKeeper:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L499   utilize:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L339   ## Recommended Mitigation Steps  Update the descriptions to relate to the `keeper` role.   
# Handle  Jujic   # Vulnerability details  ## Impact Insurance struct in `PoolTemplate .sol` can be optimized to reduce 2 storage slot  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L127-L128 ``` struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     } ``` `startTime` and `endTime `store block numbers, and 2^48 is being enough for a very long time. ## Tools Used https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html?highlight=Structs#layout-of-state-variables-in-storage   ## Recommended Mitigation Steps The struct can be changed into: ``` struct Insurance {         uint256 id; //each insuance has their own id         uint48 startTime; //timestamp of starttime         uint48 endTime; //timestamp of endtime         address insured; //the address holds the right to get insured         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         bool status; //true if insurance is not expired or redeemed     } ```   
# Handle  cmichel   # Vulnerability details  The `Vault.withdrawRedundant` has wrong logic that allows the admins to steal the underlying vault token.  ```solidity function withdrawRedundant(address _token, address _to)      external      override      onlyOwner {      if (           _token == address(token) &&           balance < IERC20(token).balanceOf(address(this))      ) {           uint256 _redundant = IERC20(token).balanceOf(address(this)) -                balance;           IERC20(token).safeTransfer(_to, _redundant);      } else if (IERC20(_token).balanceOf(address(this)) > 0) {           // @audit they can rug users. let's say balance == IERC20(token).balanceOf(address(this)) => first if false => transfers out everything           IERC20(_token).safeTransfer(                _to,                IERC20(_token).balanceOf(address(this))           );      } } ```  #### POC - Vault deposits increase as `Vault.addValue` is called and the `balance` increases by `_amount` as well as the actual `IERC20(token).balanceOf(this)`. Note that `balance == IERC20(token).balanceOf(this)` - Admins call `vault.withdrawRedundant(vault.token(), attacker)` which goes into the `else if` branch due to the balance inequality condition being `false`. It will transfer out all `vault.token()` amounts to the attacker.  ## Impact There's a backdoor in the `withdrawRedundant` that allows admins to steal all user deposits.  ## Recommended Mitigation Steps I think the devs wanted this logic from the code instead:  ```solidity function withdrawRedundant(address _token, address _to)      external      override      onlyOwner {      if (           _token == address(token)      ) {           if (balance < IERC20(token).balanceOf(address(this))) {                uint256 _redundant = IERC20(token).balanceOf(address(this)) -                     balance;                IERC20(token).safeTransfer(_to, _redundant);           }      } else if (IERC20(_token).balanceOf(address(this)) > 0) {           IERC20(_token).safeTransfer(                _to,                IERC20(_token).balanceOf(address(this))           );      } } ```   
# Handle  cmichel   # Vulnerability details  Note that the `PoolTemplate.initialize` function, called when creating a market with `Factory.createMarket`, calls a vault function to transfer an initial deposit amount (`conditions[1]`) _from_ the initial depositor (`_references[4]`):  ```solidity // PoolTemplate function initialize(      string calldata _metaData,      uint256[] calldata _conditions,      address[] calldata _references ) external override {      // ...       if (_conditions[1] > 0) {           // @audit vault calls asset.transferFrom(_references[4], vault, _conditions[1])           _depositFrom(_conditions[1], _references[4]);      } }  function _depositFrom(uint256 _amount, address _from)      internal      returns (uint256 _mintAmount) {      require(           marketStatus == MarketStatus.Trading && paused == false,           "ERROR: DEPOSIT_DISABLED"      );      require(_amount > 0, "ERROR: DEPOSIT_ZERO");       _mintAmount = worth(_amount);      // @audit vault calls asset.transferFrom(_from, vault, _amount)      vault.addValue(_amount, _from, address(this));       emit Deposit(_from, _amount, _mintAmount);       //mint iToken      _mint(_from, _mintAmount); } ```  The initial depositor needs to first approve the vault contract for the `transferFrom` to succeed.  An attacker can then frontrun the `Factory.createMarket` transaction with their own market creation (it does not have access restrictions) and create a market _with different parameters_ but still passing in `_conditions[1]=amount` and `_references[4]=victim`.  A market with parameters that the initial depositor did not want (different underlying, old whitelisted registry/parameter contract, etc.) can be created with their tokens and these tokens are essentially lost.  ## Recommended Mitigation Steps Can the initial depositor be set to `Factory.createMarket`'s `msg.sender`, instead of being able to pick a whitelisted one as `_references[4]`?   
# Handle  cmichel   # Vulnerability details  The `Parameters.setLowerSlack/setUpperSlack` functions do not check that the new value does still satisfy the `_lowerSlack <= _upperSlack` condition.  ## Recommended Mitigation Steps Check that `_lowerSlack <= _upperSlack`  is still satisfied in these functions.   
# Handle  cmichel   # Vulnerability details  The `Ownership.acceptTransferOwnership` function does not reset `_futureOwner` to zero.  ## Impact The future owner can repeatedly accept the governance, emitting an `AcceptNewOwnership` event each time, bloating listeners for this event with unnecessary data.  ## Recommended Mitigation Steps Reset `_futureOwner` to zero in `acceptTransferOwnership`.   
# Handle  hubble   # Vulnerability details  Feel free to lower the severity of the issue to Non-critical.  ## Impact Correctness of variable name  ## Proof of Concept File : Parameters.sol    line 39 :    mapping(address => uint256) private _withdawable;   line 153 :         _withdawable[_address] = _target;   line 349-352 :         if (_withdawable[_target] == 0) {             return _withdawable[address(0)];         } else {             return _withdawable[_target];  ## Tools Used Manual review  ## Recommended Mitigation Steps Change typo to _withdrawable   
# Handle  hubble   # Vulnerability details   ## Impact Input validation required for few important parameters as mentioned in the below functions.  ## Proof of Concept File : Parameters.sol    line 120 :     function setUpperSlack(address _address, uint256 _target)           Need to check that the _target value should be less than or equal to 100% (1000)     line 134 :     function setLowerSlack(address _address, uint256 _target)          Need to check that the _target value should be less than or equal to corresponding UpperSlack Value     line 177 :     function setFeeRate(address _address, uint256 _target)           Need to check that the _target value should be less than or equal to 1e6 (1000000)     line 191 :     function setMaxList(address _address, uint256 _target)           Need to check that the _target value should be greater than 1  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require statements with proper value and comments for the respective input fields as given above   
# Handle  hubble   # Vulnerability details   ## Impact Inconsistency in pragma solidity versions in different solidity files.  ## Proof of Concept File : InsureDAOERC20.sol        pragma solidity ^0.8.0;  All other solidity files in the project        pragma solidity 0.8.7;  ## Tools Used Manual review  ## Recommended Mitigation Steps Set the version to 0.8.7 in the InsureDAOERC20.sol file  
# Handle  Jujic   # Vulnerability details  ## Impact The constructor is empty. You should remove constructor to save some gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L21 ``` constructor() {} ```  ## Tools Used  ## Recommended Mitigation Steps Remove unused constructor   
# Handle  WatchPug   # Vulnerability details  Check `marketStatus` before for loops can save gas from unnecessary repeated checks.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L342-L365  ```solidity function unlockBatch(uint256[] calldata _ids) external {     for (uint256 i = 0; i < _ids.length; i++) {         unlock(_ids[i]);     } }  function unlock(uint256 _id) public {     require(         insurances[_id].status == true &&             marketStatus == MarketStatus.Trading &&             insurances[_id].endTime + parameters.getGrace(msg.sender) <             block.timestamp,         "ERROR: UNLOCK_BAD_COINDITIONS"     );     insurances[_id].status == false;      lockedAmount = lockedAmount - insurances[_id].amount;      emit Unlocked(_id, insurances[_id].amount); } ```  ### Recomandation  Change to:  ```solidity function unlockBatch(uint256[] calldata _ids) external {     require(marketStatus == MarketStatus.Trading, "ERROR: UNLOCK_BAD_COINDITIONS")     for (uint256 i = 0; i < _ids.length; i++) {         _unlock(_ids[i]);     } }  function unlock(uint256 _id) external {     require(marketStatus == MarketStatus.Trading, "ERROR: UNLOCK_BAD_COINDITIONS");     _unlock(_id); }  function _unlock(uint256 _id) internal {     require(         insurances[_id].status == true &&             insurances[_id].endTime + parameters.getGrace(msg.sender) <             block.timestamp,         "ERROR: UNLOCK_BAD_COINDITIONS"     );     insurances[_id].status == false;      lockedAmount = lockedAmount - insurances[_id].amount;      emit Unlocked(_id, insurances[_id].amount); } ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L260-L270  ```solidity if (_available >= _amount) {     _compensated = _amount;     _attributionLoss = vault.transferValue(_amount, msg.sender);     emit Compensated(msg.sender, _amount); } else {     //when CDS cannot afford, pay as much as possible     _compensated = _available;     _attributionLoss = vault.transferValue(_available, msg.sender);     emit Compensated(msg.sender, _available); }  ```  ### Recommendation  Change to:  ```solidity _compensated = _available >= _amount? _amount: _available;  _attributionLoss = vault.transferValue(_compensated, msg.sender); emit Compensated(msg.sender, _compensated); ```  - Duplicated codes removed; - Shorter and simpler code.  
# Handle  WatchPug   # Vulnerability details  Cache and reusing the function call results, instead of calling it again, can save gas from unnecessary code execution.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L163-L173  ```solidity if (available() < _amount) {      //when USDC in this contract isn't enough     uint256 _shortage = _amount - available();     _unutilize(_shortage);      assert(available() >= _amount); }  balance -= _amount; IERC20(token).safeTransfer(_to, _amount); ```  ### Recommendation  Change to:  ```solidity uint256 availableAmount = available() if ( availableAmount < _amount) {      //when USDC in this contract isn't enough     uint256 _shortage = _amount - available();     _unutilize(_shortage);      assert(availableAmount >= _amount); }  balance -= _amount; IERC20(token).safeTransfer(_to, _amount); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L295-L304  ```solidity function rate() external view returns (uint256) {     if (totalSupply() > 0) {         return             (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /             totalSupply();     } else {         return 0;     } } ```  `totalSupply()`  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L309-L312  ```solidity if (available() < _retVal) {     uint256 _shortage = _retVal - available();     _unutilize(_shortage); } ```  `available()`  
# Handle  WatchPug   # Vulnerability details  When there are multiple checks, adjusting the sequence to allow the tx to fail earlier can save some gas.  Checks using less gas should be executed earlier than those with higher gas costs, to avoid unnecessary storage read, arithmetic operations, etc when it reverts.  For example:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L238-L256  ```solidity require(paused == false, "ERROR: PAUSED"); require(     request.timestamp +         parameters.getLockup(msg.sender) <         block.timestamp,     "ERROR: WITHDRAWAL_QUEUE" ); require(     request.timestamp +         parameters.getLockup(msg.sender) +         parameters.getWithdrawable(msg.sender) >         block.timestamp,     "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST" ); require(     request.amount >= _amount,     "ERROR: WITHDRAWAL_EXCEEDED_REQUEST" ); require(_amount > 0, "ERROR: WITHDRAWAL_ZERO"); ```  The check of `_amount > 0` can be done earlier to avoid reading from storage when `_amount = 0`.  ## Recommendation  Change to:  ```solidity         require(paused == false, "ERROR: PAUSED");         require(_amount > 0, "ERROR: WITHDRAWAL_ZERO");         require(             request.amount >= _amount,             "ERROR: WITHDRAWAL_EXCEEDED_REQUEST"         );         require(             request.timestamp +                 parameters.getLockup(msg.sender) <                 block.timestamp,             "ERROR: WITHDRAWAL_QUEUE"         );         require(             request.timestamp +                 parameters.getLockup(msg.sender) +                 parameters.getWithdrawable(msg.sender) >                 block.timestamp,             "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"         ); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L189-L191  ```solidity uint256 _balance = balanceOf(msg.sender); require(_balance >= _amount, "ERROR: REQUEST_EXCEED_BALANCE"); require(_amount > 0, "ERROR: REQUEST_ZERO"); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L217-L236  ```solidity require(locked == false, "ERROR: WITHDRAWAL_PENDING"); require(     _requestTime + _lockup < block.timestamp,     "ERROR: WITHDRAWAL_QUEUE" ); require(     _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >         block.timestamp,     "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST" ); require(     withdrawalReq[msg.sender].amount >= _amount,     "ERROR: WITHDRAWAL_EXCEEDED_REQUEST" ); require(_amount > 0, "ERROR: WITHDRAWAL_ZERO");  require(     _retVal <= withdrawable(),     "ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY" ); ```  
# Handle  defsec   # Vulnerability details  The setFeeRate function does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.  ## Proof of Concept  - The setFeeRate function sets the transaction fee rates for the market in which the function is called. In this context, the transaction fee is the percentage of a transaction that is taken by the protocol and moved to a designated reserve account. As the name suggests, transaction fees factor in to many of the essential transaction types performed within the system. - Navigate to "https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Parameters.sol#L177". - On the function there is no upper and lower bound defined. Therefore, users can pay higher fees.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to define upper and lower bounds on the fee array.  
# Handle  defsec   # Vulnerability details  ## Impact  On the InsureDAOERC20, transferFrom function is vulnerable on the re-entrancy.  ## Proof of Concept  1. Navigate to the following contract. Approve function is written after transfer call. It is not possible to exploit on the current environment but that can be possible on the EVM.  ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         _transfer(sender, recipient, amount);          uint256 currentAllowance = _allowances[sender][_msgSender()];         require(             currentAllowance >= amount,             "ERC20: transfer amount exceeds allowance"         );          _approve(sender, _msgSender(), currentAllowance - amount);          return true;     } ```   ## Tools Used  Code Review  ## Recommended Mitigation Steps   Follow check effect interaction pattern. Consider to use openzeppelin erc20 contract. The sample transferFrom function can be seen from below.   ```   function transferFrom(       address sender,       address recipient,       uint256 amount   ) public virtual override returns (bool) {       uint256 currentAllowance = _allowances[sender][_msgSender()];       if (currentAllowance != type(uint256).max) {           require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");           unchecked {               _approve(sender, _msgSender(), currentAllowance - amount);           }       }        _transfer(sender, recipient, amount);        return true;   } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L161  
# Handle  defsec   # Vulnerability details  ## Impact  On the ERC20, There is a known problem named as Approve/TransferFrom race condition. On the transferFrom, allowance max check has not been added.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152  ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         uint256 currentAllowance = _allowances[sender][_msgSender()];         if (currentAllowance != type(uint256).max) {             require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");             unchecked {                 _approve(sender, _msgSender(), currentAllowance - amount);             }         }          _transfer(sender, recipient, amount);          return true;     }  ```  2. Max Allowance check has not been added into the function. ERC20 standart (Openzeppelin) is not followed.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to use openzeppelin erc20 contract. The sample transferFrom function can be seen from below.   ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         uint256 currentAllowance = _allowances[sender][_msgSender()];         if (currentAllowance != type(uint256).max) {             require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");             unchecked {                 _approve(sender, _msgSender(), currentAllowance - amount);             }         }          _transfer(sender, recipient, amount);          return true;     } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L161  
# Handle  leastwood   # Vulnerability details  ## Impact  The current method of market creation involves calling `Factory.createMarket()` with a list of approved `_conditions` and `_references` accounts. If a registered template address has `templates[address(_template)].isOpen == true`, then any user is able to call `createMarket()` using this template. If the template points to `PoolTemplate.sol`, then a malicious market creator can abuse `PoolTemplate.initialize()` as it makes a vault deposit from an account that they control. The vulnerable internal function, `_depositFrom()`, makes a vault deposit from the `_references[4]` address (arbitrarily set to an approved reference address upon market creation).  Hence, if approved `_references` accounts have set an unlimited approval amount for `Vault.sol` before deploying their market, a malicious user can frontrun market creation and cause these tokens to be transferred to the incorrect market.  This issue can cause honest market creators to have their tokens transferred to an incorrectly configured market, leading to unrecoverable funds. If their approval to `Vault.sol` was set to the unlimited amount, malicious users will also be able to force honest market creators to transfer more tokens than they would normally want to allow. ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L158-L231 ``` function createMarket(     IUniversalMarket _template,     string memory _metaData,     uint256[] memory _conditions,     address[] memory _references ) public override returns (address) {     //check eligibility     require(         templates[address(_template)].approval == true,         "ERROR: UNAUTHORIZED_TEMPLATE"     );     if (templates[address(_template)].isOpen == false) {         require(             ownership.owner() == msg.sender,             "ERROR: UNAUTHORIZED_SENDER"         );     }     if (_references.length > 0) {         for (uint256 i = 0; i < _references.length; i++) {             require(                 reflist[address(_template)][i][_references[i]] == true ||                     reflist[address(_template)][i][address(0)] == true,                 "ERROR: UNAUTHORIZED_REFERENCE"             );         }     }      if (_conditions.length > 0) {         for (uint256 i = 0; i < _conditions.length; i++) {             if (conditionlist[address(_template)][i] > 0) {                 _conditions[i] = conditionlist[address(_template)][i];             }         }     }      if (         IRegistry(registry).confirmExistence(             address(_template),             _references[0]         ) == false     ) {         IRegistry(registry).setExistence(             address(_template),             _references[0]         );     } else {         if (templates[address(_template)].allowDuplicate == false) {             revert("ERROR: DUPLICATE_MARKET");         }     }      //create market     IUniversalMarket market = IUniversalMarket(         _createClone(address(_template))     );      IRegistry(registry).supportMarket(address(market));          markets.push(address(market));       //initialize     market.initialize(_metaData, _conditions, _references);      emit MarketCreated(         address(market),         address(_template),         _metaData,         _conditions,         _references     );      return address(market); } ```  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L178-L221 ``` function initialize(     string calldata _metaData,     uint256[] calldata _conditions,     address[] calldata _references ) external override {     require(         initialized == false &&             bytes(_metaData).length > 0 &&             _references[0] != address(0) &&             _references[1] != address(0) &&             _references[2] != address(0) &&             _references[3] != address(0) &&             _references[4] != address(0) &&             _conditions[0] <= _conditions[1],         "ERROR: INITIALIZATION_BAD_CONDITIONS"     );     initialized = true;      string memory _name = string(         abi.encodePacked(             "InsureDAO-",             IERC20Metadata(_references[1]).name(),             "-PoolInsurance"         )     );     string memory _symbol = string(         abi.encodePacked("i-", IERC20Metadata(_references[1]).symbol())     );     uint8 _decimals = IERC20Metadata(_references[0]).decimals();      initializeToken(_name, _symbol, _decimals);      registry = IRegistry(_references[2]);     parameters = IParameters(_references[3]);     vault = IVault(parameters.getVault(_references[1]));      metadata = _metaData;      marketStatus = MarketStatus.Trading;      if (_conditions[1] > 0) {         _depositFrom(_conditions[1], _references[4]);     } } ```  ## Tools Used  Manual code review. Discussions with kohshiba.  ## Recommended Mitigation Steps  After discussions with the sponsor, they have opted to parse a `_creator` address to `PoolTemplate.sol` which will act as the depositor and be set to `msg.sender` in `Factory.createMarket()`. This will prevent malicious market creators from forcing vault deposits from unsuspecting users who are approved in `Factory.sol` and have also approved `Vault.sol` to make transfers on their behalf.  
# Handle  WatchPug   # Vulnerability details  Check of allowance can be done earlier (before `_transfer()`) to save some gas for failure transactions.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152-L168  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     require(         currentAllowance >= amount,         "ERC20: transfer amount exceeds allowance"     );      _approve(sender, _msgSender(), currentAllowance - amount);      return true; } ```   See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162-L169   
# Handle  WatchPug   # Vulnerability details  Removing `return 0` can make the code simpler and save some gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L295-L303  ```solidity     function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return                 (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /                 totalSupply();         } else {             return 0;         }     } ```  ### Recommendation  Can be changed to:  ```solidity     function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return                 (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /                 totalSupply();         }      } ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L312-L317  ```solidity         if (_balance == 0) {             return 0;         } else {             return                 _balance * vault.attributionValue(crowdPool) / totalSupply();         } ```  Can be changed to:  ```solidity if (_balance > 0) {     return         _balance * vault.attributionValue(crowdPool) / totalSupply(); }  ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L176-L176  ```solidity for (uint256 i = 0; i < _references.length; i++) ```  Can be changed to:  ```solidity for (uint256 i; i < _references.length; i++) ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L493-L497  ```solidity if (totalLiquidity() > 0) {     return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); } else {     return 0; } ```  Can be changed to:  ```solidity if (totalLiquidity() > 0) {     return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); }  ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L288-L288  ```solidity require(registry.isListed(msg.sender)); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L100-L100  ```solidity require(address(_template) != address(0)); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L109-L113  ```solidity string memory _name = "InsureDAO-CDS"; string memory _symbol = "iCDS"; uint8 _decimals = IERC20Metadata(_references[0]).decimals();  initializeToken(_name, _symbol, _decimals); ```  The local variable `_name`, `_symbol`, `_decimals` is used only once. Making the expression inline can save gas.  ### Recommendation  Change to:  ```solidity initializeToken("InsureDAO-CDS", "iCDS", IERC20Metadata(_references[0]).decimals()); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L189-L190  ```solidity uint256 _balance = balanceOf(msg.sender); require(_balance >= _amount, "ERROR: REQUEST_EXCEED_BALANCE"); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L257-L257  ```solidity uint256 _surplusAttribution = surplusPool; ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L62-L63  ```solidity uint256 _assetReserve = asset.safeBalance(); require(_assetReserve >= assetReserve + assetIn, 'E304'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L51-L52  ```solidity uint256 _collateralReserve = collateral.safeBalance(); require(_collateralReserve >= collateralReserve + collateralIn, 'E305'); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L456-L463  ```solidity uint256 _shortage; if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = _value + _cds; } ```  `_shortage` and `_cds`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L140-L148  ```solidity if (_supply > 0 && _liquidity > 0) {     _mintAmount = (_amount * _supply) / _liquidity; } else if (_supply > 0 && _liquidity == 0) {     //when vault lose all underwritten asset =      _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again. } else {     //when _supply == 0,     _mintAmount = _amount; } ```  ### Recommendation  Change to:  ```solidity if (_supply == 0) {     _mintAmount = _amount; } else {     _mintAmount = _liquidity == 0 ? _amount * _supply : (_amount * _supply) / _liquidity; }  ```  - Removed 2 checks; - Removed 1 branch; - Simpler branch (costs less gas) goes first.  
# Handle  WatchPug   # Vulnerability details  The Wrapped Ether (WETH) ERC-20 contract has a gas optimization that does not update the allowance if it is the max uint.  The latest version of OpenZeppelin's ERC20 token contract also adopted this optimization.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152-L168  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     require(         currentAllowance >= amount,         "ERC20: transfer amount exceeds allowance"     );      _approve(sender, _msgSender(), currentAllowance - amount);      return true; } ```  See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162 -   https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085  ### Recommendation  Change to:  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     if (currentAllowance != type(uint256).max) {         require(             currentAllowance >= amount,             "ERC20: transfer amount exceeds allowance"         );          _approve(sender, _msgSender(), currentAllowance - amount);     }      return true; } ```  
# Handle  Jujic   # Vulnerability details  ## Impact ``` function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();         } else {             return 0;         }     } ```  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L512-L518  ## Tools Used Remix  ## Recommended Mitigation Steps Change to: ``` function rate() external view returns (uint256) {         if (totalSupply() != 0) {             return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();              }  ```  
# Handle  hyh   # Vulnerability details  ## Impact  System will fail on low-level subtraction without proper logic level error, which can be an issue for troubleshooting and further programmatic usages by other projects.   ## Proof of Concept  Whenever user lacks _attributions (Vault shares) for the withdraw amount requested, the system will fail on subtraction:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L160   ## Recommended Mitigation Steps  Consider adding a check for the enough _attributions throwing a corresponding error   
# Handle  loop   # Vulnerability details  When checking boolean values in a require or if statement it's an unnecessary operation to compare them to `true`, as it's already checked whether the condition is `true`. For comparison to `false`, it is cheaper to use the `!` operator rather than compare the value.  ## Proof of Concept Lines where boolean comparison is used: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L99 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L131 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L161 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L176 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L205 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L122 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L142 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L166-L169 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L178-L179 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L204 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L132 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L165 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L365 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L464 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L184 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L234 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L354 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L388 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L491 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L550 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L612 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L664  ## Recommended Mitigation Steps Remove the `== true` part from boolean comparisons and change `_variableName == false` to `!_variableName` to save some gas.  
# Handle  loop   # Vulnerability details  The function `unlock()` in PoolTemplate has a typo where it compares `insurances[_id].status` to `false` rather than setting it to `false`. If the conditions are met to unlock the funds for an id, the user should be able to call the `unlock()` function once for that id as `insurances[_id].amount` is subtracted from `lockedAmount`. However, since `insurances[_id].status` does not get set to `false`, a user can call `unlock()` multiple times for the same id, resulting in `lockedAmount` being way smaller than it should be since `insurances[_id].amount` is subtracted multiple times.   ## Impact `lockedAmount` is used to calculate the amount of underlying tokens available for withdrawals. If `lockedAmount` is lower than it should be users are able to withdraw more underlying tokens than available for withdrawals.  ## Proof of Concept Typo in `unlock()`: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L360-L362  Calculation of underlying tokens available for withdrawal: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L836  ## Recommended Mitigation Steps Change `insurances[_id].status == false;` to `insurances[_id].status = false;`  
# Handle  hyh   # Vulnerability details  ## Impact  Underlying and index tokens are mixed up in the worth() function description, making code and its description conflicting  ## Proof of Concept  Worth() computes how many iTokens correspond to given amount of underlying. The description says otherwise, mixing them up:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L794-798    ## Recommended Mitigation Steps  Fix the description to say that ‘_value' is the amount of underlying, while the '_amount' is the corresponding output quantity of iTokens   
# Handle  ospwner   # Vulnerability details  ## Impact Checking arrays' length before using it in a for loop is unnecessary when array's length is used in loop exit condition.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L175  ```         if (_references.length > 0) {             for (uint256 i = 0; i < _references.length; i++)  ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L185 ```         if (_conditions.length > 0) {             for (uint256 i = 0; i < _conditions.length; i++)  ```   ## Recommended Mitigation Steps  Remove the two unnecessary  if statements.   
# Handle  0x1f8b   # Vulnerability details  ## Impact Signature replay in `PoolTemplate`.  ## Proof of Concept The `redeem` method of `PoolTemplate` verifies the data stored in `incident`, and the verification logic of this process is performed as following:  ``` require(             MerkleProof.verify(                 _merkleProof,                 _targets,                 keccak256(                     abi.encodePacked(_insurance.target, _insurance.insured)                 )             ) ||                 MerkleProof.verify(                     _merkleProof,                     _targets,                     keccak256(abi.encodePacked(_insurance.target, address(0)))                 ),             "ERROR: INSURANCE_EXEMPTED"         ); ```  As can be seen, the only data related to the `_insurance` are` target` and `insured`, so as the incident has no relation with the` Insurance`, apparently nothing prevents a user to call `insure` with high amounts, after receive the incident, the only thing that prevents this from being reused is that the owner creates the incident with an `_incidentTimestamp` from the past.  So if a owner create a incident from the future it's possible to create a new `insure` that could be reused by the same affected address.  Another lack of input verification that could facilitate this attack is the `_span=0` in the `insure` method.  ## Tools Used Manual review.  ## Recommended Mitigation Steps It is mandatory to add a check in `applyCover` that` _incidentTimestamp` is less than the current date and the `span` argument is greater than 0 in the` insure` method.  
# Handle  Jujic   # Vulnerability details  ## Impact Checking if  `_amount != 0 ` before making the transfer call  can save gas by avoiding the external call in such situations.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L201-L206  ``` function borrowValue(uint256 _amount, address _to) external onlyMarket override {         debts[msg.sender] += _amount;         totalDebt += _amount;          IERC20(token).safeTransfer(_to, _amount);     }  ```  ## Tools Used Remix  ## Recommended Mitigation Steps Add additional check for non zero ` _amount`.  
# Handle  Jujic   # Vulnerability details  ## Impact Some of the variables can be cached to slightly reduce gas usage  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L343  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L406-L407  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L461-L479  ``` function withdrawRedundant(address _token, address _to)         external         override         onlyOwner     {         if (             _token == address(token) &&             balance < IERC20(token).balanceOf(address(this))         ) {             uint256 _redundant = IERC20(token).balanceOf(address(this)) -                 balance;             IERC20(token).safeTransfer(_to, _redundant);         } else if (IERC20(_token).balanceOf(address(this)) > 0) {             IERC20(_token).safeTransfer(                 _to,                 IERC20(_token).balanceOf(address(this))             );         }     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Consider caching those variable for read and make sure write back to storage Example: ``` bal =  IERC20(_token).balanceOf(address(this); ```  
# Handle  0xngndev   # Vulnerability details  ## Impact  Unclear Natspec may confuse the user.  In the `fund` function:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L160](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L160)  The Natspec is a copy-paste of the `deposit` function:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L130](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L130)  The problem here is the **receives ITokens** part of the Natspec. The deposit function indeed mints tokens to the `msg.sender` but the `fund` function doesn’t. I would clarify that the `fund` function adds attributions to the surplusPool.  Another minor and unclear bit of Natspec happens here: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L177](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L177)  It describes `_amount` as sender of value instead of something like **amount of value to send.**  ## Recommended Mitigation Steps  Explain the Natspec of the `fund` function in more detail. Fix the `transferValue` amount natspec. Also it would be good to add some Natspec to the `defund` function too.  
# Handle  0xngndev   # Vulnerability details  ## Impact  In `PoolTemplate.sol` there are multiple instances where variables are declared before the error checks of the functions. In cases where a function reverts due to these error checks, that extra computation of calculating the variable being declared can be avoided by simply moving the declaration after the error checks.  Here are all the functions I found where this can be applied:  - `withdraw` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L293](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L293) - `withdrawCredit` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L416](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L416) - `insure` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L465](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L465) - `reedem` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L548](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L548)  ## Recommended Mitigation Steps  - Change `withdraw` function to:  ```solidity function withdraw(uint256 _amount) external returns (uint256 _retVal) {   require(       marketStatus == MarketStatus.Trading,       "ERROR: WITHDRAWAL_PENDING"   );   require(       withdrawalReq[msg.sender].timestamp +           parameters.getLockup(msg.sender) <           block.timestamp,       "ERROR: WITHDRAWAL_QUEUE"   );   require(       withdrawalReq[msg.sender].timestamp +           parameters.getLockup(msg.sender) +           parameters.getWithdrawable(msg.sender) >           block.timestamp,       "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"   );   require(       withdrawalReq[msg.sender].amount >= _amount,       "ERROR: WITHDRAWAL_EXCEEDED_REQUEST"   );   require(_amount > 0, "ERROR: WITHDRAWAL_ZERO");   require(       _retVal <= availableBalance(),       "ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY"   );    uint256 _supply = totalSupply();   require(_supply != 0, "ERROR: NO_AVAILABLE_LIQUIDITY");    uint256 _liquidity = originalLiquidity();   _retVal = (_amount * _liquidity) / _supply;    //reduce requested amount   withdrawalReq[msg.sender].amount -= _amount;    //Burn iToken   _burn(msg.sender, _amount);    //Withdraw liquidity   vault.withdrawValue(_retVal, msg.sender);    emit Withdraw(msg.sender, _amount, _retVal); } ```  - Change `withdrawCredit` function to:  ```solidity function withdrawCredit(uint256 _credit)         external         override         returns (uint256 _pending)     {       IndexInfo storage _index = indicies[msg.sender];       require(           IRegistry(registry).isListed(msg.sender) &&               _index.credit >= _credit &&               _credit <= availableBalance(),           "ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS"       );        uint256 _rewardPerCredit = rewardPerCredit;        //calculate acrrued premium       _pending = _sub(           (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,           _index.rewardDebt       );        //Withdraw liquidity       if (_credit > 0) {           totalCredit -= _credit;           _index.credit -= _credit;           emit CreditDecrease(msg.sender, _credit);       }        //withdraw acrrued premium       if (_pending > 0) {           vault.transferAttribution(_pending, msg.sender);           attributionDebt -= _pending;           _index.rewardDebt =               (_index.credit * _rewardPerCredit) /               MAGIC_SCALE_1E6;       } } ```  - Change `insure` function to:  ```solidity function insure(         uint256 _amount,         uint256 _maxCost,         uint256 _span,         bytes32 _target     ) external returns (uint256) {       //Distribute premium and fee       uint256 _premium = getPremium(_amount, _span);        require(           _amount <= availableBalance(),           "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"       );       require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");       require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");       require(           parameters.getMinDate(msg.sender) <= _span,           "ERROR: INSURE_SPAN_BELOW_MIN"       );        require(           marketStatus == MarketStatus.Trading,           "ERROR: INSURE_MARKET_PENDING"       );       require(paused == false, "ERROR: INSURE_MARKET_PAUSED");        uint256 _endTime = _span + block.timestamp;       uint256 _fee = parameters.getFeeRate(msg.sender);        //current liquidity       uint256 _liquidity = totalLiquidity();       uint256 _totalCredit = totalCredit;        //accrue premium/fee       uint256[2] memory _newAttribution = vault.addValueBatch(           _premium,           msg.sender,           [address(this), parameters.getOwner()],           [MAGIC_SCALE_1E6 - _fee, _fee]       );        //Lock covered amount       uint256 _id = allInsuranceCount;       lockedAmount += _amount;       Insurance memory _insurance = Insurance(           _id,           block.timestamp,           _endTime,           _amount,           _target,           msg.sender,           true       );       insurances[_id] = _insurance;       allInsuranceCount += 1;        //Calculate liquidity for index       if (_totalCredit > 0) {           uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /               _liquidity;           attributionDebt += _attributionForIndex;           rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /               _totalCredit);       }        emit Insured(           _id,           _amount,           _target,           block.timestamp,           _endTime,           msg.sender,           _premium       );          return _id;   } ```  - Change `redeem` function to:  ```solidity function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {       require(           marketStatus == MarketStatus.Payingout,           "ERROR: NO_APPLICABLE_INCIDENT"       );       Insurance storage _insurance = insurances[_id];       require(_insurance.status == true, "ERROR: INSURANCE_NOT_ACTIVE");       require(_insurance.insured == msg.sender, "ERROR: NOT_YOUR_INSURANCE");       uint256 _incidentTimestamp = incident.incidentTimestamp;       require(           marketStatus == MarketStatus.Payingout &&               _insurance.startTime <= _incidentTimestamp &&               _insurance.endTime >= _incidentTimestamp,           "ERROR: INSURANCE_NOT_APPLICABLE"       );       bytes32 _targets = incident.merkleRoot;       require(           MerkleProof.verify(               _merkleProof,               _targets,               keccak256(                   abi.encodePacked(_insurance.target, _insurance.insured)               )           ) ||               MerkleProof.verify(                   _merkleProof,                   _targets,                   keccak256(abi.encodePacked(_insurance.target, address(0)))               ),           "ERROR: INSURANCE_EXEMPTED"       );       uint256 _payoutNumerator = incident.payoutNumerator;       uint256 _payoutDenominator = incident.payoutDenominator;        _insurance.status = false;       lockedAmount -= _insurance.amount;        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /           _payoutDenominator;        vault.borrowValue(_payoutAmount, msg.sender);        emit Redeemed(           _id,           msg.sender,           _insurance.target,           _insurance.amount,           _payoutAmount       );   } ```  
# Handle  Jujic   # Vulnerability details  ## Impact The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L105  ``` function transfer(address recipient, uint256 amount)         public         virtual         override         returns (bool)     {         _transfer(_msgSender(), recipient, amount);         return true;     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  
# Handle  cccz   # Vulnerability details  ## Impact  The fund function of the CDSTemplate contract does not match the description, the caller will not receive any iToken after sending tokens, and the owner can take away the tokens in surplusPool.  ```     /**      * @notice A liquidity provider supplies collatral to the pool and receives iTokens      * @param _amount amount of token to deposit      */     function fund(uint256 _amount) external {         require(paused == false, "ERROR: PAUSED");          //deposit and pay fees         uint256 _attribution = vault.addValue(             _amount,             msg.sender,             address(this)         );          surplusPool += _attribution;          emit Fund(msg.sender, _amount, _attribution);     }      function defund(uint256 _amount) external override onlyOwner {         require(paused == false, "ERROR: PAUSED");          uint256 _attribution = vault.withdrawValue(_amount, msg.sender);         surplusPool -= _attribution;          emit Defund(msg.sender, _amount, _attribution);     } ```  ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L156-L182  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Change the description of the fund function or send iToken to the caller  
# Handle  camden   # Vulnerability details  ## Impact The owner could potentially extend the insurance period indefinitely in the `applyCover` function without ever allowing the market to resume. This is because there is no check in `applyCover` to ensure that the market is in a `Trading` state.  This can also allow the owner to emit fraudulent `MarketStatusChanged` events.  ## Recommended Mitigation Steps Require that the market be in a `Trading` state to allow another `applyCover` call.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The Vault.sol contract contains several state variables of type address. There is no need to cast these variable to type address because they are already of type address. Removing the cast function can save gas.  ## Proof of Concept  The token address state variable is unnecessarily cast to address type in two places in Vault.sol: - [Line 350](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L350) - [Line 467](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L467)  ## Recommended Mitigation Steps  Remove the unnecessary address cast from address variables.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The Vault.sol contract has two address state variables, the `keeper` variable and the `controller` variable, which are both permitted to be the zero address. If both variables are zero simultaneously, any address can burn the available funds (available funds = balance - totalDebt) by sending these tokens to the zero address with the unprotected `utilitize()` function. If a user has no totalDebt, the user can lose their entire underlying token balance because of this.  ## Proof of Concept  The problematic `utilize()` function is [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L342-L352). To see how the two preconditions can occur: 1. The keeper state variable is only changed by the `setKeeper()` function [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502). If this function is not called, the keeper variable will retain the default value of address(0), which bypasses [the only access control for the utilize function](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L344). 2. There is a comment [here on line 69](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502) stating the controller state variable can be zero. There is no zero address check for the controller state variable in the Vault constructor.  If both address variables are left at their defaults of address(0), then the safeTransfer() call [on line 348](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L348) would send the tokens to address(0).  ## Recommended Mitigation Steps  Add the following line to the very beginning of the `utilize()` function: `require(address(controller) != address(0))`  This check is already found in many other functions in Vault.sol, including the `_unutilize()` function.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The comment for the return value of the `getCDS()` function in Registry.sol is incorrectly copied from elsewhere, possibly the `confirmExistence()` function. The return value is an address, not a boolean. This is considered low risk based on C4's [risk ratings](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  The problematic comment is from the `getCDS()` function [here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L99). It is an incorrect duplicate of the comment for the `confirmExistence()` function [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L113).  ## Recommended Mitigation Steps  Replace the comment with something like `@return CDS contract address`, which is used to describe this value in the `setCDS()` function.  
# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) { uint length = arr.length; for (uint i = 0; i < arr.length; i++) { sum += arr[i]; } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) { uint length = arr.length; for (uint i = 0; i < arr.length; i++) { sum += arr[i]; } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  ``` https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L176  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L186  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  
# Handle  p4st13r4   # Vulnerability details  ## Impact  Users that incorrectly ask for a withdrawal equal to zero, will waste more gas (a storage read) since the check for `amount > 0` is put after the check for the available amount  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L191](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L191) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L199](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L199) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L282](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L282)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Move this require at the top of the `requestWithdraw` function:  ```jsx require(_amount > 0, "ERROR: REQUEST_ZERO"); ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  `totalAllocPoint` in `set()` function is read several times from storage. It can be assigned to a local variable so the function is less expensive overall  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L612](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L612)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `totalAllocPoint` to `localTotalAllocPoint` (or `cachedTotalAllocPoint`)  
# Handle  p4st13r4   # Vulnerability details  ## Impact  When emitting the event, the function argument could be used, instead of reading from storage again  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Ownership.sol#L62](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Ownership.sol#L62)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Change to:  ```jsx emit CommitNewOwnership(newOwner); ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  Many functions that read params, check whether the value is set for the given `target`, otherwise return the value for the zero-address. When doing this kind of check, the value of the `target` is read twice:  - once for checking if it’s set - if it’s set, it’s read once more to read the actual params  These functions are used a lot of times inside all the contracts, so having them optimized as much as possible is required in order to save gas  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L240](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L240) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L271](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L271) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L289](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L289) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L313](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L313) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L331](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L331) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L343](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L343) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L379](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L379) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L397](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L397)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign the target value and, if the check returns a value different from the zero-address, use it. For example, `getFeeRate` becomes:  ```jsx function getFeeRate(address _target)     external     view     override     returns (uint256) {     uint256 _targetFee = _fee[_target];     if (_targetFee == 0) {         return _fee[address(0)];     } else {         return _targetFee;     } } ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  The public `deposit` uses basically the same code of the internal `_depositFrom`. The only difference between them is that the former uses `msg.sender`, while the latter uses a parameter as `from` address. In order to minimize code duplication, `deposit` should be calling `_depositFrom` rather than being reimplemented using copy-paste  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L232](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L232)  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L255](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L255)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Write `deposit` like this:  ```jsx function deposit(uint256 _amount) public returns (uint256 _mintAmount) {     _depositFrom(_amount, msg.sender); } ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  The `setKeeper()` function is operated only by the owner, and should emit an event when the keeper is set for the first time and/or changes  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L502](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L502)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add `emit KeeperChanged(address)` after changing the keeper  
# Handle  p4st13r4   # Vulnerability details  ## Impact  The amount of the withdrawal request is not correctly updated after a withdrawal in `CDSTemplate.sol`. This happens because the withdrawal request is read from storage and put in memory, like this:  ```jsx Withdrawal memory request = withdrawalReq[msg.sender]; ```  However, the requested amount is not updated properly since the `withdrawalReq` in the storage is never updated. Instead, its in-memory version is updated, but it’s useless because that object is never used again:  ```jsx //reduce requested amount request.amount -= _amount; ```  This issue is non critical because there is a function that takes care of updating the withdrawal requests’ amount on every token transfer: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L358](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L358)  The issue lies in the fact that the code seems to behave differently from how it looks at a first glance. Furthermore, the other two templates correctly update the value of the withdrawal request, so the version in `CDSTemplate.sol` should be aligned as well:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L239](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L239) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L327](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L327)  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L230](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L230)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Update the `amount` of the current withdrawal request as well  
# Handle  p4st13r4   # Vulnerability details  ## Impact  The `resume` function can be called by any user, at any time, even when the Index contract is not locked. There should be a check preventing it from being called unless the contract is `locked`  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L459](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L459)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add a require on top:  ```jsx require(locked); ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  `PoolTemplate.sol` and `IndexTemplate.sol` report this same error when trying to withdraw and some conditions are not met: "ERROR: WITHDRAWAL_PENDING”  However, `PoolTemplate.sol` does that when the `marketStatus` is not `Trading`; `IndexTemplate.sol` when the contract is locked. Since `CDSTemplate.sol`, instead, implement a different revert string, it’s best for understanding what revert strings are related to by making them as explicit and clear as possible. `CDSTemplate.sol` has this in the `withdraw` function:  ```jsx require(paused == false, "ERROR: PAUSED"); ```  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217)  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L302](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L302)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Improve revert strings wording  
# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L685 the function emitted a `MarketStatusChanged` event with storage variable which is `marketStatus`. when we emit an event using storage data is more expensive than emitted an event using `MarketStatus.Payingout` value.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L685 ``` contract emitstatust {      enum MarketStatus {         Trading,         Payingout     }     MarketStatus public marketStatus;      event MarketStatusChanged(MarketStatus statusValue);      function amit() public {          marketStatus = MarketStatus.Payingout;      emit MarketStatusChanged(marketStatus);      } } //44792 gas ```  can change to :  ``` contract emitstatust {      enum MarketStatus {         Trading,         Payingout     }     MarketStatus public marketStatus;      event MarketStatusChanged(MarketStatus statusValue);      function amit() public {          marketStatus = MarketStatus.Payingout;      emit MarketStatusChanged(MarketStatus.Payingout);      } } //44659 gas ```  ## Tools Used remix   
# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L508 instead of save `Insurance` value to memory then save to `insurences` storage it's better to save the `Insurence` value directly to `insurences`  storage or mapping to save gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L508 ``` contract insur {      struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     }       mapping(uint256 => Insurance) public insurances;      function coba() public {          uint256 _id = 10;         uint256 _endTime = 10;         uint256 _amount = 12;         bytes32 _target = bytes32(uint256(10));           Insurance memory _insurance = Insurance(             _id,             block.timestamp,             _endTime,             _amount,             _target,             msg.sender,             true         );         insurances[_id] = _insurance;      } } //154623 gas ```  change to : ``` contract insur {      struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     }       mapping(uint256 => Insurance) public insurances;      function coba() public {          uint256 _id = 10;         uint256 _endTime = 10;         uint256 _amount = 12;         bytes32 _target = bytes32(uint256(10));           insurances[_id] = Insurance(             _id,             block.timestamp,             _endTime,             _amount,             _target,             msg.sender,             true         );               } } //154610 gas  ```  ## Tools Used remix  
# Handle  Tomio   # Vulnerability details  ## Impact by saving `totalLiquidity()` to memory can save more gas instead of doing double function call  ## Proof of Concept Before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L829 // gas cost 23862  After: ``` function totalLiquidity() public view returns (uint256){      return 10;  }     function availableBalance()public view returns (uint256 _balance)     {         uint256 saveTotalLiquidity = totalLiquidity();         if (saveTotalLiquidity > 0) {             return saveTotalLiquidity - lockedAmount;         } else {             return 0;         }     } ``` // gas cost 23840  ## Tools Used Remix  
# Handle  0x1f8b   # Vulnerability details  ## Impact Wrong deployment.  ## Proof of Concept The factory contract haven't got any check of `_registry` and `_ownership` and both values must be defined or the logic inside the contract will fault.  ## Tools Used Manual review.  ## Recommended Mitigation Steps It's mandatory to check that the address are not zero or the contract could be wrong deployed.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept There are multiple methods in `Registry` that check a value inside the storage and if it's not defined, use the default one. It's better to cache the value in order to save gas if it was defined avoiding double reading.  For example, instead of the following code: ```     function getCDS(address _address) external view override returns (address) {         if (cds[_address] == address(0)) {             return cds[address(0)];         } else {             return cds[_address];         }     } ``` use ```     function getCDS(address _address) external view override returns (address) {         address val =cds[_address];         if ( val== address(0)) {             return cds[address(0)];         } else {             return val;         }     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Cache the value.  
# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260 have two check inside the require which is `marketStatus == MarketStatus.Trading` and `paused == false` and by spliting this check we can save gas.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260  ``` function woi() public {          require(             marketStatus == MarketStatus.Trading && paused == false,             "ERROR: DEPOSIT_DISABLED"         );      } // 23645 gas ```   can be change to   ``` function woi() public{           require(             marketStatus == MarketStatus.Trading, "ERROR: DEPOSIT_DISABLED"         );         require(               paused == false, "ERROR: DEPOSIT_DISABLED"         );      } //23637 gas ```     
# Handle  Tomio   # Vulnerability details  ## Impact by changing the code from `if (_credit == 0) {` to `if (_credit != 0) {` and remove the else we can save gas when contract is deploy and we can save gas when `_credit` is equal to 0. because if `_credit` equal to 0 the original function will return 0 which a default value for uint256  ## Proof of Concept Before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L776 // gas 24307  After: ``` function pendingPremium(address _index)         external         view         returns (uint256)     {         uint256 _credit = indicies[_index].credit;        if (_credit != 0) {             return                 _sub(                     (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,                     indicies[_index].rewardDebt                 );         }     } ``` // gas 24286   ## Tools Used Remix  ## Recommended Mitigation Steps  
# Handle  defsec   # Vulnerability details  ## Impact  the owner parameter are used for the onlyOwner modifier. In the state variable , proper check up should be done , other wise error in these state variable can lead to redeployment of contract. If the zero address is assigned to rebalanceManager parameter, that will fail all Owner functions.  ## Proof of Concept  1. Navigate to the following contract functions.  "https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L31"  2. Adding zero address into the owner leads to failure of onlyOwner only functions.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add proper zero address validation.  
# Handle  Tomio   # Vulnerability details  ## Impact by using 'unchecked' you can save  +-182 gas  ## Proof of Concept before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L938 //22378 before  after: ``` function _sub(uint256 a, uint256 b) public pure returns (uint256) {         if (a < b) {             return 0;         } else {             unchecked {return a - b;}         }     }   ``` //22196 after   ## Tools Used Remix  ## Recommended Mitigation Steps used 'unchecked' in function _sub  
# Handle  camden   # Vulnerability details  ## Impact The `utilize()` function can be called while the controller is the zero address. This will fail. A comment in the constructor says that the controller shouldn't be the zero address.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L350  ## Recommended Mitigation Steps `utilize` should have a check to see if the controller is not the zero address (like `_unutilize`) and give an appropriate error message.  
# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept The `for` loop at [L109-113](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L109-L113) can be unrolled to remove the overhead of the loop itself, and avoid using an initialized-to-zero uint128 variable.  ## Tools Used Manual review  ## Recommended Mitigation Steps Replace L109-113 with: ``` uint256 _allocation = (_shares[0] * _attributions) / MAGIC_SCALE_1E6; attributions[_beneficiaries[0]] += _allocation; _allocations[0] = _allocation;  _allocation = (_shares[1] * _attributions) / MAGIC_SCALE_1E6; attributions[_beneficiaries[1]] += _allocation; _allocations[1] = _allocation; ```  
# Handle  0xngndev   # Vulnerability details  ## Impact  Error Messages that have a length of 32 or more one require one additional slot to be stored, causing extra gas costs when deploying the contract and when the function is executed and it reverts.  ## Proof of Concept  I put together a quick proof to show the different impact of the errors we can have in Solidity:  - Long require errors => more than 32 bytes - Short require errors => less than 32 bytes - Custom errors  Here are the contract size findings:  ```rust //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  contract Errors {   bool public thisIsFalse;   error WithdrawalExceeded();    /*     Contract Size with just this function: 333 bytes;   */   function moreThan32Bytes() public {     require(thisIsFalse, "ERROR: WITHDRAWAL_EXCEEDED_REQUEST");   }    /*     Contract Size with just this function: 295 bytes; //   */   function lessThan32Bytes() public {     require(thisIsFalse, "WITHDRAWAL_EXCEEDED_REQUEST");   }    /*     Contract Size with just this function: 242 bytes;   */   function customError() public {     if (!thisIsFalse) revert WithdrawalExceeded();   } } ```  I then run tests to see the gas costs of having the functions revert, and although these are not very accurate due to the fact that it’s hard to isolate the gas costs of a reverting function due to the order of execution (I can’t have an event that logs the gas before the function revert and another one after because the one after the revert will never be reached), it still shows some differences.  ```rust //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import "ds-test/test.sol"; import "../Errors.sol";  contract ErrorsTest is DSTest {   Errors errors;    function setUp() public {     errors = new Errors();   }    function testFailLessThan32Bytes() public logs_gas {     errors.lessThan32Bytes();   }    function testFailMoreThan32Bytes() public logs_gas {     errors.moreThan32Bytes();   }    function testFailCustomError() public logs_gas {     errors.customError();   } } ```  ```rust Running 3 tests for "ErrorsTest.json":ErrorsTest [PASS] testFailCustomError() (gas: 3161) [PASS] testFailLessThan32Bytes() (gas: 3314) [PASS] testFailMoreThan32Bytes() (gas: 3401) ```  ## Tools Used  DappTools/Foundry  ## Recommended Mitigation Steps  Personally, I would switch to custom errors and reverts to maximize the savings, but if you dislike revert syntax, then I would suggest to check which of your require errors have a length longer than 32, and shorten them so that their length is less than 32.  Here are some examples of the errors you could shorten in your `CDSTemplate.sol` contract:  - `ERROR: INITIALIZATION_BAD_CONDITIONS` - `ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST` - `ERROR: WITHDRAWAL_EXCEEDED_REQUEST`  Removing the “ERROR” keyword should be enough for most of these. Bear in mind you can always have concise error messages and a section in your documentation that explains them further or have your natspec expand on them if you find them too cryptic.   An example of how to apply a custom error in the first error would be to just have the error `say BadConditions()`. The user knows it’s an error because the function call failed, and the user knows it has happened in the initialize function because he called it, so `BadConditions()` should be a clear message despite being concise  
# Handle  Dravee   # Vulnerability details  In `IndexTemplate.sol:withdrawable()`, the following can be optimized to save gas and avoid a loss of precision, from: ```                 uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;                 _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev; ``` to ```                 uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint *  MAGIC_SCALE_1E6 /  (_targetAllocPoint * targetLev); ```  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `IndexTemplate.sol:_adjustAlloc()`, the 3 following conditions are always evaluated: ```                 //Withdraw or Deposit credit                 if (_current > _target && _available != 0) {                     //if allocated credit is higher than the target, try to decrease                     uint256 _decrease = _current - _target;                     IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);                     totalAllocatedCredit -= _decrease;                 }                 if (_current < _target) {                     uint256 _allocate = _target - _current;                     IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);                     totalAllocatedCredit += _allocate;                 }                 if (_current == _target) {                     IPoolTemplate(_poolList[i].addr).allocateCredit(0);                 } ``` The code can be optimized to save some gas: ```                 if (_current == _target) {                     IPoolTemplate(_poolList[i].addr).allocateCredit(0);                 } else if (_current < _target) {                     uint256 _allocate = _target - _current;                     IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);                     totalAllocatedCredit += _allocate;                 } else if (_current > _target && _available != 0) {                     //Withdraw or Deposit credit                     //if allocated credit is higher than the target, try to decrease                     uint256 _decrease = _current - _target;                     IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);                     totalAllocatedCredit -= _decrease;                 } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  
# Handle  Dravee   # Vulnerability details  ## Impact > The operators “||” and “&&” apply the common short-circuiting rules. This means that in the expression “f(x) || g(y)”, if “f(x)” evaluates to true, “g(y)” will not be evaluated even if it may have side-effects.  Source: https://docs.soliditylang.org/en/v0.5.4/types.html#booleans  ## Proof of Concept In `IndexTemplate.sol:withdrawable()`, there's an if-statement as such: ``` 293:                         if (i == 0 || _availableRate < _lowestAvailableRate) { ``` Here, the condition `i == 0` is always evaluated and is always equal to `false` when `i > 0`, meaning here a total of `poolList.length - 1` evaluations are always evaluated to `false`.  It's best to reorder the conditions such as this condition doesn't get evaluated if `_availableRate < _lowestAvailableRate` is satisfied: ``` 293:                         if (_availableRate < _lowestAvailableRate || i == 0 ) { ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `Factory.sol`, the following `> 0` checks are redundant with the for-loop condition, because if `_references.length == 0` or `_conditions.length == 0`, the condition `uint256 i = 0; i <(_conditions)|(_references).length` will never be satisfied and the for-loop won't iterate: ``` 175:         if (_references.length > 0) { 176:             for (uint256 i = 0; i < _references.length; i++) { 177:                 require( 178:                     reflist[address(_template)][i][_references[i]] == true || 179:                         reflist[address(_template)][i][address(0)] == true, 180:                     "ERROR: UNAUTHORIZED_REFERENCE" 181:                 ); 182:             } 183:         } 184:  185:         if (_conditions.length > 0) { 186:             for (uint256 i = 0; i < _conditions.length; i++) { 187:                 if (conditionlist[address(_template)][i] > 0) { 188:                     _conditions[i] = conditionlist[address(_template)][i]; 189:                 } 190:             } 191:         }  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove these 2 if-statements  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept The variable `T_0` can go through 2 assignments in a row: Here: ``` 75:         uint256 T_0 = _totalLiquidity; 76:         if (T_0 > T_1) { 77:             T_0 = T_1; 78:         } ``` And here: ``` 134:         uint256 T_0 = _totalLiquidity; 135:         if (T_0 > T_1) { 136:             T_0 = T_1; 137:         } ```  The code can be optimized as such to save some gas: ```         uint256 T_0 = _totalLiquidity > T_1 ? _totalLiquidity : T_1; ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto   
# Handle  Dravee   # Vulnerability details  ## Impact Duplicated code, loss of maintainability, increased contract size which leads to increased gas cost  ## Proof of Concept The following can be simplified: ``` 260:         if (_available >= _amount) { 261:             _compensated = _amount; 262:             _attributionLoss = vault.transferValue(_amount, msg.sender); 263:             emit Compensated(msg.sender, _amount); 264:         } else { 265:             //when CDS cannot afford, pay as much as possible 266:             _compensated = _available; 267:             _attributionLoss = vault.transferValue(_available, msg.sender); 268:             emit Compensated(msg.sender, _available); 269:         } ``` to ``` 260:         _compensated = _available >= _amount ? _amount : _available; //when CDS cannot afford, pay as much as possible 261:         _attributionLoss = vault.transferValue(_compensated, msg.sender); 262:         emit Compensated(msg.sender, _compensated); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto and look out for duplicated code  
# Handle  Dravee   # Vulnerability details  ## Impact When a contract imports and implements an interface or another contracts, it doesn't need to import the libraries that were already imported there.  Removing these imports will save gas.  ## Proof of Concept `InsureDAOERC20` imports the following:  ``` 5: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 6: import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"; ```  The following contracts inherit `InsureDAOERC20` and also make those imports: `CDSTemplate`, `IndexTemplate`, `PoolTemplate`  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove the unused imports to reduce the size of the contract and save some deployment gas.  
# Handle  egjlmn1   # Vulnerability details  in all of your for loops, you increase your loop variable using `i++` it has 2 problems: 1. postfix increment is more wasteful than prefix increment (`++i` instead of `i++`) 2. there is no risk for overflow, so you can use `unchecked{}`  ## Impact prefix arithmetic is a bit cheaper than postfix arithmetic, but if you do it in a for loop, this small amount of gas can pile up and be a big waste. also, in solidity 0.8.0+, every arithmetic operation is checked for overflow and underflow, which adds a lot of gas to a single operation. Since in your for loop you don't have the risk for overflow, you can surround the operation in `unchecked{}` to save a lot of gas (which will save a huge amount since it saves a lot in a single loop iteration.)  ## Proof of Concept Checked on remix  ## Tools Used manual code review  ## Recommended Mitigation Steps change every `i++` in your for loops to `unchecked{++i}`  
# Handle  Dravee   # Vulnerability details  ## Impact The compiler won't reserve a storage slot for `immutable` variables  ## Proof of Concept The following variables are initialized in the contract's constructor and can't get updated after: ``` Factory.sol:registry Factory.sol:ownership Parameters:ownership BondingPremium:ownership Registry:ownership Vault:ownership ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Make these variables `immutable`  
# Handle  Dravee   # Vulnerability details  ## Impact Repetitive and expensive SSTORE opcode operations inside loops  ## Proof of Concept ```  totalAllocatedCredit -= _available (contracts/IndexTemplate.sol#368)  totalAllocatedCredit -= _decrease (contracts/IndexTemplate.sol#395)  totalAllocatedCredit += _allocate (contracts/IndexTemplate.sol#401) ```  ## Tools Used Slither  ## Recommended Mitigation Steps Create a memory variable which will be used to compute a `_totalAllocatedCredit` that will get added to `totalAllocatedCredit` storage variable outside the loop. As an idea, you could create 1 such `int` variable and use it's value after the for-loop, or you could create 2 uint variables where 1 would store the _totalDecrease and 1 would store the _totalAllocate, and respectively substract and add them.   
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 slot)  ## Proof of Concept IndexTemplate.pendingEnd (contracts/IndexTemplate.sol#62) should be deleted as it's never used by the contract  ## Tools Used Slither  ## Recommended Mitigation Steps Delete the variable `IndexTemplate.pendingEnd`  
# Handle  Dravee   # Vulnerability details  ## Impact  Increased gas cost.   ## Proof of Concept  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers.  When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block.  https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  These lines are the obvious ones that can't underflow or overflow (operations on constants or checks already made before the operations with `require` statements or `if` statements): ```  PremiumModels\BondingPremium.sol:47:        T_1 = 1000000 * DECIMAL; PremiumModels\BondingPremium.sol:130:        uint256 u1 = BASE - ((_lockedAmount * BASE) / _totalLiquidity); //util rate before. 1000000 = 100.000% PremiumModels\BondingPremium.sol:132:            (((_lockedAmount + _amount) * BASE) / _totalLiquidity); //util rate after. 1000000 = 100.000% IndexTemplate.sol:292:                        uint256 _lockedCredit = _allocated - _availableBalance; PoolTemplate.sol:942:            return a - b; IndexTemplate.sol:308:                    _retVal = _totalLiquidity - _necessaryAmount; IndexTemplate.sol:393:                    uint256 _decrease = _current - _target; IndexTemplate.sol:399:                    uint256 _allocate = _target - _current; IndexTemplate.sol:441:                _shortage = _amount - _value; InsureDAOERC20.sol:255:        _balances[sender] = senderBalance - amount; InsureDAOERC20.sol:303:        _balances[account] = accountBalance - amount; Vault.sol:165:            uint256 _shortage = _amount - available(); Vault.sol:310:            uint256 _shortage = _retVal - available(); ```   ## Tools Used  VS Code   ## Recommended Mitigation Steps Uncheck arithmetic operations when the risk of underflow or overflow is already contained.  
# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ```   Vault.sol:92:        address[2] memory _beneficiaries, Vault.sol:93:        uint256[2] memory _shares ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.   
# Handle  Dravee   # Vulnerability details  ## Impact   Using both named returns and a return statement isn't necessary. Removing unused named return variables can reduce gas usage and improve code clarity. To save gas and improve code quality: consider using only one of those.      ## Proof of Concept   Instances include:   ``` CDSTemplate.sol:287:    function totalLiquidity() public view returns (uint256 _balance) { IndexTemplate.sol:491:    function leverage() public view returns (uint256 _rate) { IndexTemplate.sol:504:    function totalLiquidity() public view returns (uint256 _balance) { PoolTemplate.sol:628:        returns (uint256 premium) PoolTemplate.sol:833:        returns (uint256 _balance) PoolTemplate.sol:846:    function utilizationRate() public view override returns (uint256 _rate) { PoolTemplate.sol:858:    function totalLiquidity() public view override returns (uint256 _balance) { PoolTemplate.sol:866:    function originalLiquidity() public view returns (uint256 _balance) { ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Remove the unused named returns   
# Handle  Dravee   # Vulnerability details  ## Impact   Due to how the EVM natively works on 256 bit numbers, using a 8 bit number in for-loops introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage : > When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. > It is only beneficial to use reduced-size arguments if you are dealing with storage values because the compiler will pack multiple elements into one storage slot, and thus, combine multiple reads or writes into a single operation. When dealing with function arguments or memory values, there is no inherent benefit because the compiler does not pack these values.    ## Proof of Concept   ``` Vault.sol:109:        for (uint128 i = 0; i < 2; i++) { ```  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `uint256` as a counter in for-loops.   
# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept The `withdrawalReq[msg.sender].timestamp` and `parameters.getLockup(msg.sender)` values are used twice in the `require` statements, and both times summed.   ## Tools Used Manual review  ## Recommended Mitigation Steps Cache the sum value in a new variable. I've sent a similar report for IndexTemplate.withdraw() with a similar issue.  
# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept In [L197](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L197) of IndexTemplate, a `_balance` variable is created and initialized to the balance of `msg.sender`. However that variable is used only once in the function.  ## Tools Used Manual review  ## Recommended Mitigation Steps Replace L198 with `require(balanceOf(msg.sender) >= _amount, "ERROR: REQUEST_EXCEED_BALANCE");` and remove L197  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs  ## Proof of Concept  Solidity 0.8.10 has a useful change which reduced gas costs of external calls which expect a return value: https://blog.soliditylang.org/2021/11/09/solidity-0.8.10-release-announcement/  > Code Generator: Skip existence check for external contract if return data is expected. In this case, the ABI decoder will revert if the contract does not exist  InsureDAO is using 0.8.7:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L8  Updating to the newer version of solc will allow InsureDAO to take advantage of these lower costs for external calls.  ## Recommended Mitigation Steps  Update to solc 0.8.10 or above  
# Handle  cccz   # Vulnerability details  ## Impact When setting parameters in the Parameters contract, the input parameters are not verified.  For example, in the setFeeRate function, the _target parameter is not limited. When _target is greater than 1e6, DOS will occur when used in the insure function of the PoolTemplate contract ```     function setFeeRate(address _address, uint256 _target)         external         override         onlyOwner     {         _fee[_address] = _target;         emit FeeRateSet(_address, _target);     }    ...    function insure(         uint256 _amount,         uint256 _maxCost,         uint256 _span,         bytes32 _target     ) external returns (uint256) {         //Distribute premium and fee         uint256 _endTime = _span + block.timestamp;         uint256 _premium = getPremium(_amount, _span);         uint256 _fee = parameters.getFeeRate(msg.sender);          require(             _amount <= availableBalance(),             "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"         );         require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");         require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");         require(             parameters.getMinDate(msg.sender) <= _span,             "ERROR: INSURE_SPAN_BELOW_MIN"         );          require(             marketStatus == MarketStatus.Trading,             "ERROR: INSURE_MARKET_PENDING"         );         require(paused == false, "ERROR: INSURE_MARKET_PAUSED");          //current liquidity         uint256 _liquidity = totalLiquidity();         uint256 _totalCredit = totalCredit;          //accrue premium/fee         uint256[2] memory _newAttribution = vault.addValueBatch(             _premium,             msg.sender,             [address(this), parameters.getOwner()],             [MAGIC_SCALE_1E6-_fee, _fee]         ); ``` ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol  ## Tools Used  Manual analysis   ## Recommended Mitigation Steps  When setting parameters in the Parameters contract, verify the input parameters  
# Handle  Dravee   # Vulnerability details  ## Impact   Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.      ## Proof of Concept   ```   Factory.sol:176:            for (uint256 i = 0; i < _references.length; i++) { Factory.sol:186:            for (uint256 i = 0; i < _conditions.length; i++) { IndexTemplate.sol:655:        for (uint256 i = 0; i < poolList.length; i++) { PoolTemplate.sol:343:        for (uint256 i = 0; i < _ids.length; i++) { PoolTemplate.sol:671:        for (uint256 i = 0; i < indexList.length; i++) { PoolTemplate.sol:703:        for (uint256 i = 0; i < indexList.length; i++) { ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Store the array's length in a variable before the for-loop, and use it instead.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  Here if the lengths of these arrays are zero we'll fall straight through the for loops so there's no need for the if statements.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L175-L191  ## Recommended Mitigation Steps  Remove if statements  
# Handle  Dravee   # Vulnerability details  ## Impact   If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    ## Proof of Concept   Instances include:   ```   Factory.sol:176:            for (uint256 i = 0; i < _references.length; i++) { Factory.sol:186:            for (uint256 i = 0; i < _conditions.length; i++) { IndexTemplate.sol:280:            for (uint256 i = 0; i < _length; i++) { IndexTemplate.sol:348:        for (uint256 i = 0; i < _length; i++) { IndexTemplate.sol:381:        for (uint256 i = 0; i < _length; i++) { IndexTemplate.sol:462:        for (uint256 i = 0; i < _poolLength; i++) { IndexTemplate.sol:655:        for (uint256 i = 0; i < poolList.length; i++) { PoolTemplate.sol:343:        for (uint256 i = 0; i < _ids.length; i++) { PoolTemplate.sol:671:        for (uint256 i = 0; i < indexList.length; i++) { PoolTemplate.sol:703:        for (uint256 i = 0; i < indexList.length; i++) { Vault.sol:109:        for (uint128 i = 0; i < 2; i++) { ```      ## Tools Used   Manual Analysis      ## Recommended Mitigation Steps   Remove explicit initialization for default values.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  Here we push a new market onto an array in the factory whilst we just added the market to the registry.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L214-L216  ## Recommended Mitigation Steps  This array on the factory seems redundant and so it can be removed.  
# Handle  Dravee   # Vulnerability details  ## Impact   Increased gas cost      ## Proof of Concept   Solidity version 0.8.* already implements overflow and underflow checks by default.  Using the SafeMath library from OpenZeppelin (which is more gas expensive than the 0.8.* overflow checks) is therefore redundant.      Instances include:  ```   mocks\ERC20.sol:4:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; mocks\ERC20.sol:30:    using SafeMath for uint256; mocks\TestPremiumModel.sol:3:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; mocks\TestPremiumModel.sol:7:    using SafeMath for uint256; PremiumModels\BondingPremium.sol:10:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the built-in checks instead of SafeMath and remove SafeMath from the dependencies   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  It seems that we always want to get a pool's `allocatedCredit` and `availableBalance` together, suggesting that these values are tightly coupled.   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L284-L287  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L356-L360  If we're regularly going to be requesting these values together it may be worth considering having a single function in the pool template which returns both of these values. This would save gas costs of performing an extra external call to the pool contract.  ## Recommended Mitigation Steps  Consider having a function which returns both of these values to avoid repeated calls into the same contract for related info.  
# Handle  Dravee   # Vulnerability details  ## Impact   `!= 0` costs less gas compared to `> 0` for unsigned integer      ## Proof of Concept   `> 0` is used in the following location(s): ```   CDSTemplate.sol:100:                bytes(_metaData).length > 0 && CDSTemplate.sol:132:        require(_amount > 0, "ERROR: DEPOSIT_ZERO"); CDSTemplate.sol:140:        if (_supply > 0 && _liquidity > 0) { CDSTemplate.sol:142:        } else if (_supply > 0 && _liquidity == 0) { CDSTemplate.sol:191:        require(_amount > 0, "ERROR: REQUEST_ZERO"); CDSTemplate.sol:223:        require(_amount > 0, "ERROR: WITHDRAWAL_ZERO"); CDSTemplate.sol:296:        if (totalSupply() > 0) { Factory.sol:175:        if (_references.length > 0) { Factory.sol:185:        if (_conditions.length > 0) { Factory.sol:187:                if (conditionlist[address(_template)][i] > 0) { IndexTemplate.sol:133:                bytes(_metaData).length > 0 && IndexTemplate.sol:166:        require(_amount > 0, "ERROR: DEPOSIT_ZERO"); IndexTemplate.sol:172:        if (_supply > 0 && _totalLiquidity > 0) { IndexTemplate.sol:174:        } else if (_supply > 0 && _totalLiquidity == 0) { IndexTemplate.sol:199:        require(_amount > 0, "ERROR: REQUEST_ZERO"); IndexTemplate.sol:231:        require(_amount > 0, "ERROR: WITHDRAWAL_ZERO"); IndexTemplate.sol:246:        if (_liquidityAfter > 0) { IndexTemplate.sol:274:        if(_totalLiquidity > 0){ IndexTemplate.sol:283:                if (_allocPoint > 0) { IndexTemplate.sol:391:                if (_current > _target && _available != 0) { IndexTemplate.sol:427:            allocPoints[msg.sender] > 0, IndexTemplate.sol:477:        require(allocPoints[msg.sender] > 0); IndexTemplate.sol:493:        if (totalLiquidity() > 0) { IndexTemplate.sol:513:        if (totalSupply() > 0) { IndexTemplate.sol:612:        if (totalAllocPoint > 0) { IndexTemplate.sol:656:            if (allocPoints[poolList[i]] > 0) { InsureDAOERC20.sol:302:        require(accountBalance >= amount, "ERC20: burn amount exceeds balance"); Parameters.sol:31:    mapping(address => uint256) private _fee; //fee rate in 1e6 (100% = 1e6) PoolTemplate.sol:185:                bytes(_metaData).length > 0 && PoolTemplate.sol:218:        if (_conditions[1] > 0) { PoolTemplate.sol:237:        require(_amount > 0, "ERROR: DEPOSIT_ZERO"); PoolTemplate.sol:263:        require(_amount > 0, "ERROR: DEPOSIT_ZERO"); PoolTemplate.sol:282:        require(_amount > 0, "ERROR: REQUEST_ZERO"); PoolTemplate.sol:321:        require(_amount > 0, "ERROR: WITHDRAWAL_ZERO"); PoolTemplate.sol:391:        } else if (_index.credit > 0) { PoolTemplate.sol:396:            if (_pending > 0) { PoolTemplate.sol:401:        if (_credit > 0) { PoolTemplate.sol:437:        if (_credit > 0) { PoolTemplate.sol:444:        if (_pending > 0) { PoolTemplate.sol:521:        if (_totalCredit > 0) { PoolTemplate.sol:672:            if (indicies[indexList[i]].credit > 0) { PoolTemplate.sol:706:            if (_credit > 0) { PoolTemplate.sol:726:        if (_deductionFromPool > 0) { PoolTemplate.sol:745:        if (totalSupply() > 0) { PoolTemplate.sol:802:        if (_supply > 0 && _originalLiquidity > 0) { PoolTemplate.sol:804:        } else if (_supply > 0 && _originalLiquidity == 0) { PoolTemplate.sol:835:        if (totalLiquidity() > 0) { PoolTemplate.sol:847:        if (lockedAmount > 0) { PoolTemplate.sol:929:        require(b > 0); Vault.sol:154:            attributions[msg.sender] > 0 && Vault.sol:187:            attributions[msg.sender] > 0 && Vault.sol:220:            attributions[msg.sender] > 0 && Vault.sol:347:        if (_amount > 0) { Vault.sol:388:        if (totalAttributions > 0 && _attribution > 0) { Vault.sol:406:        if (attributions[_target] > 0) { Vault.sol:473:        } else if (IERC20(_token).balanceOf(address(this)) > 0) { ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Change `> 0` with `!= 0`.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  gas costs  ## Proof of Concept  Here on L563 we check the market status however we have already done this on L558  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L557-L567  ## Recommended Mitigation Steps  Remove redundant check (check other market templates as well)  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  When transferring any of the market tokens, a check is performed to see if they have a pending withdrawal and reduce it if their balance falls below the requested amount.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L910-L923  In the case where a user has no pending withdrawal we then perform an unnecessary check on their balance. We could save an SLOAD by changing it to the below  ``` if (from != address(0)) {     uint256 reqAmount = withdrawalReq[from].amount     if (reqAmount > 0){         uint256 _after = balanceOf(from) - amount;         if (_after < reqAmount) {             withdrawalReq[from].amount = _after;         }     }  } ```  ## Recommended Mitigation Steps  As above  
# Handle  Dravee   # Vulnerability details  ## Impact   Reducing from public to private will save gas    ## Proof of Concept   ```   PremiumModels\BondingPremium.sol:26:    //constants PremiumModels\BondingPremium.sol:27:    uint256 public constant DECIMAL = uint256(1e6); //Decimals of USDC PremiumModels\BondingPremium.sol:28:    uint256 public constant BASE = uint256(1e6); //bonding curve graph takes 1e6 as 100.0000% PremiumModels\BondingPremium.sol:29:    uint256 public constant BASE_x2 = uint256(1e12); //BASE^2 PremiumModels\BondingPremium.sol:30:    uint256 public constant ADJUSTER = uint256(10); //adjuster of 1e6 to 1e5 (100.0000% to 100.000%) CDSTemplate.sol:55:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation IndexTemplate.sol:95:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation PoolTemplate.sol:146:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation Vault.sol:38:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Theses constants can simply be read from the verified contract, i.e., it is unnecessary to expose it with a public function. Also, constants having "1E6" in their name aren't even "nice to have public constants", as their value is obvious.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept  The `Withdrawal` struct in `IndexTemplate.sol` contains a timestamp and the amount of tokens which the user requests to withdraw.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L81-L84  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L198  If we make the safe assumption that the user's balance does not exceed 2^192 then we can pack this struct into a single storage slot to save an SLOAD by changing the definition to:  ``` struct Withdrawal {     uint64 timestamp;     uint192 amount; } ```  ## Recommended Mitigation Steps  As above  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  gas costs  ## Proof of Concept  In the sqrt function it is known that the while loop will not overflow so it can be safely left unchecked to save gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PremiumModels/BondingPremium.sol#L238-L245  ```     function sqrt(uint256 x) internal pure returns (uint256 y) {         uint256 z = (x + 1) / 2;         unchecked {             y = x;             while (z < y) {                 y = z;                 z = (x / z + z) / 2;             }         }     } ``` ## Recommended Mitigation Steps  wrap entire function body in a unchecked block as above  
# Handle  robee   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          InsureDAOERC20.sol : reachable assert in line 31         Vault.sol : reachable assert in line 167   
# Handle  robee   # Vulnerability details  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           CDSTemplate.sol, totalLiquidity         Factory.sol, _createClone         IndexTemplate.sol, withdrawable         IndexTemplate.sol, leverage         IndexTemplate.sol, totalLiquidity         PoolTemplate.sol, availableBalance         PoolTemplate.sol, utilizationRate         PoolTemplate.sol, totalLiquidity  
# Handle  robee   # Vulnerability details  The following requires are with empty messages.  This is very important to add a message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: CDSTemplate.sol, In line 253 with Empty Require message.         Solidity file: Factory.sol, In line 100 with Empty Require message.         Solidity file: IndexTemplate.sol, In line 477 with Empty Require message.         Solidity file: PoolTemplate.sol, In line 929 with Empty Require message.         Solidity file: Vault.sol, In line 66 with Empty Require message.         Solidity file: Vault.sol, In line 67 with Empty Require message.         Solidity file: Vault.sol, In line 68 with Empty Require message.   
# Handle  robee   # Vulnerability details  The following functions could skip other steps if the amount is 0. (A similar issue: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82)           InsureDAOERC20.sol, name         InsureDAOERC20.sol, symbol         InsureDAOERC20.sol, decimals         InsureDAOERC20.sol, totalSupply         InsureDAOERC20.sol, balanceOf         InsureDAOERC20.sol, transfer         InsureDAOERC20.sol, allowance         InsureDAOERC20.sol, approve         InsureDAOERC20.sol, transferFrom         InsureDAOERC20.sol, increaseAllowance         InsureDAOERC20.sol, decreaseAllowance         InsureDAOERC20.sol, _transfer         InsureDAOERC20.sol, _mint         InsureDAOERC20.sol, _burn         InsureDAOERC20.sol, _approve         InsureDAOERC20.sol, _beforeTokenTransfer         InsureDAOERC20.sol, _afterTokenTransfer  
# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function totalLiquidity in CDSTemplate.sol could be set external         The function valueOfUnderlying in CDSTemplate.sol could be set external         The function createMarket in Factory.sol could be set external         The function totalLiquidity in IndexTemplate.sol could be set external         The function set in IndexTemplate.sol could be set external         The function leverage in IndexTemplate.sol could be set external         The function withdrawable in IndexTemplate.sol could be set external         The function valueOfUnderlying in IndexTemplate.sol could be set external         The function deposit in IndexTemplate.sol could be set external         The function adjustAlloc in IndexTemplate.sol could be set external         The function allowance in InsureDAOERC20.sol could be set external         The function decimals in InsureDAOERC20.sol could be set external         The function totalSupply in InsureDAOERC20.sol could be set external         The function name in InsureDAOERC20.sol could be set external         The function transfer in InsureDAOERC20.sol could be set external         The function increaseAllowance in InsureDAOERC20.sol could be set external         The function transferFrom in InsureDAOERC20.sol could be set external         The function decreaseAllowance in InsureDAOERC20.sol could be set external         The function balanceOf in InsureDAOERC20.sol could be set external         The function symbol in InsureDAOERC20.sol could be set external         The function approve in InsureDAOERC20.sol could be set external         The function getOwner in Parameters.sol could be set external         The function utilizationRate in PoolTemplate.sol could be set external         The function totalLiquidity in PoolTemplate.sol could be set external         The function availableBalance in PoolTemplate.sol could be set external         The function getPremium in PoolTemplate.sol could be set external         The function valueOfUnderlying in PoolTemplate.sol could be set external         The function unlock in PoolTemplate.sol could be set external         The function originalLiquidity in PoolTemplate.sol could be set external         The function deposit in PoolTemplate.sol could be set external         The function allocatedCredit in PoolTemplate.sol could be set external         The function getPremiumRate in BondingPremium.sol could be set external         The function getCurrentPremiumRate in BondingPremium.sol could be set external         The function getPricePerFullShare in Vault.sol could be set external         The function valueAll in Vault.sol could be set external         The function setController in Vault.sol could be set external         The function underlyingValue in Vault.sol could be set external   
# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           CDSTemplate.sol: parameters.getLockup is read twice in withdraw         Factory.sol: registry is read twice in createMarket         IndexTemplate.sol: totalAllocPoint is read twice in set         IndexTemplate.sol: MAGIC_SCALE_1E6 is read twice in withdrawable         PoolTemplate.sol: parameters.getLockup is read twice in withdraw         PoolTemplate.sol: lockedAmount is read twice in utilizationRate         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in allocateCredit         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in withdrawCredit         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in insure         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in resume         BondingPremium.sol: k is read twice in getCurrentPremiumRate         BondingPremium.sol: k is read twice in getPremiumRate         BondingPremium.sol: c is read twice in getPremiumRate         BondingPremium.sol: b is read twice in getCurrentPremiumRate         BondingPremium.sol: b is read twice in getPremiumRate         BondingPremium.sol: T_1 is read twice in getCurrentPremiumRate         BondingPremium.sol: T_1 is read twice in getPremiumRate         BondingPremium.sol: BASE is read twice in getCurrentPremiumRate         BondingPremium.sol: BASE is read twice in getPremiumRate         BondingPremium.sol: BASE_x2 is read twice in getCurrentPremiumRate         BondingPremium.sol: BASE_x2 is read twice in getPremiumRate         Vault.sol: token is read twice in repayDebt         Vault.sol: token is read twice in utilize         Vault.sol: token is read twice in withdrawRedundant         Vault.sol: totalAttributions is read twice in attributionValue         Vault.sol: balance is read twice in valueAll         Vault.sol: balance is read twice in withdrawRedundant   
# Handle  robee   # Vulnerability details  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.  The format is <solidity file>, <unused storage variable name>:           IndexTemplate.sol, pendingEnd         BondingPremium.sol, ADJUSTER   
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           Factory.sol, line 13, import "hardhat/console.sol";         IndexTemplate.sol, line 6, import "hardhat/console.sol";         Parameters.sol, line 12, import "hardhat/console.sol";         BondingPremium.sol, line 9, import "@openzeppelin/contracts/utils/math/SafeMath.sol";   
# Handle  Dravee   # Vulnerability details  ## Impact Checking if the value is 0 before returning 0 is less expensive than returning a calculation that's equal to 0  ## Proof of Concept In `PoolTemplate.sol:rate()`, the code is as follows: ``` File: PoolTemplate.sol 744:     function rate() external view returns (uint256) { 745:         if (totalSupply() > 0) { 746:             return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); 747:         } else { 748:             return 0; 749:         } 750:     }  ``` It can be optimized as such: ``` 744:     function rate() external view returns (uint256) { 745:         uint256 originalLiquidity = originalLiquidity(); 746:         if (originalLiquidity != 0 && totalSupply() > 0) { 747:             return (originalLiquidity * MAGIC_SCALE_1E6) / totalSupply(); 748:         } else { 749:             return 0; 750:         } 751:     }  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable and make the 0 checks to avoid unnecessary calculations if `originalLiquidity() == 0`  
# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `PoolTemplate.sol:worth()`, the code is as follows: ``` 799:     function worth(uint256 _value) public view returns (uint256 _amount) { 800:         uint256 _supply = totalSupply(); 801:         uint256 _originalLiquidity = originalLiquidity(); 802:         if (_supply > 0 && _originalLiquidity > 0) { 803:             _amount = (_value * _supply) / _originalLiquidity; 804:         } else if (_supply > 0 && _originalLiquidity == 0) { 805:             _amount = _value * _supply; 806:         } else { 807:             _amount = _value; 808:         } 809:     } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for further information): ```     function worth(uint256 _value) public view returns (uint256 _amount) {         uint256 _supply = totalSupply();         uint256 _originalLiquidity = originalLiquidity();         if (_supply == 0) {             _amount = _value;         } else if (_originalLiquidity == 0) {             _amount = _value * _supply;         } else {             _amount = (_value * _supply) / _originalLiquidity;         }     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements   
# Handle  pauliax   # Vulnerability details  ## Impact In IndexTemplate, function compensate, When _amount > _value, and <= totalLiquidity(), the value of _compensated is not set, so it gets a default value of 0: ```solidity if (_value >= _amount) {     ...     _compensated = _amount; } else {     ...     if (totalLiquidity() < _amount) {         ...         _compensated = _value + _cds;     }     vault.offsetDebt(_compensated, msg.sender); } ```  But nevertheless, in both cases, it calls vault.offsetDebt, even when the _compensated is 0 (no else block).  ## Recommended Mitigation Steps I think, in this case, it should try to redeem the premium (withdrawCredit?) to cover the whole amount, but I am not sure about the intentions as I didn't have enough time to understand this protocol in depth.  
# Handle  Dravee   # Vulnerability details  ## Impact The transactions could fail if the array get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L703  ## Tools Used VS Code  ## Recommended Mitigation Steps Keep the array size small.  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 MSTORE and 1 MLOAD)  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L553 There's no readability or gas gain from copying `incident.payoutDenominator` to a variable as it's used only once in the method.  ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 MSTORE and 1 MLOAD)  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L552 There's no readability or gas gain from copying `incident.payoutNumerator` to a variable as it's used only once in the method.  ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable  
# Handle  Dravee   # Vulnerability details  ## Impact Checking if the value is 0 before returning 0 is less expensive than returning a calculation that's equal to 0  ## Proof of Concept In `Vault.sol:underlyingValue()`, the code is as follows: ``` Vault.sol 400:     function underlyingValue(address _target) 401:         public 402:         view 403:         override 404:         returns (uint256) 405:     { 406:         if (attributions[_target] > 0) { 407:             return (valueAll() * attributions[_target]) / totalAttributions; 408:         } else { 409:             return 0; 410:         } 411:     } ``` It can be optimized as such:  ``` 406:         uint256 valueAll = valueAll(); 407:         if (valueAll != 0 && attributions[_target] > 0) { 408:             return (valueAll * attributions[_target]) / totalAttributions; 409:         } else { 410:             return 0; 411:         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable and make the 0 checks to avoid unnecessary calculations if `valueAll() == 0`  
# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `attributions[_target]` can be loaded twice from storage: ``` Vault.sol 400:     function underlyingValue(address _target) 401:         public 402:         view 403:         override 404:         returns (uint256) 405:     { 406:         if (attributions[_target] > 0) { 407:             return (valueAll() * attributions[_target]) / totalAttributions; 408:         } else { 409:             return 0; 410:         } 411:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable  
# Handle  pauliax   # Vulnerability details  ## Impact There are some issues with comments/documentation, e.g.: Misleading comment: ```solidity    * @return true if the id within the market already exists   function getCDS(address _address) external view override returns (address) ``` No such function (present in documentation): ```solidity   function getInsuranceCount(address _user) ``` "getInsuranceCount returns how many insurance policies the specified user has."  ## Recommended Mitigation Steps Consider revisiting and updating discrepancies between the documentation and comments.  
# Handle  Kumpirmafyas   # Vulnerability details  ## Impact The order of the "struct Template" in the Factory.sol contract is as follows: 1-bool isOpen 2-bool approval 3-bool allowDuplicate https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L44-L48   The struct above is used in functions as value, in the "key=>value" part in this mapping. https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L49  When using "template" mapping in this function, it is not done in the defined order, Detail: - isOpen bool , defined in Struct in the 1st row, -isOpen bool ,defined in the 1st position in Mapping, naturally -isOpen bool is defined in the 2nd row in the "approveTemplate" function below. -The same applies to the approvel bool struct.  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L101-L103   The problem here is; The order in which Structs are used in a Function is not. Problem ; The order of the structs in the "key => value" mapping definition affects the function. Sequencing is important in struct definition in mappings.   ## Recommended Mitigation Steps The order in the struct = the order in the mapping = the order in the function must be the same.  Here ; Sorting in Mapping with Struct is a mandatory condition, while sorting in a function is within the scope of clean code.  
# Handle  pauliax   # Vulnerability details  ## Impact Statements should be ordered in a way that it costs less gas, that is, less operations are performed when the validating conditions are wrong. e.g. this can be reordered: ```solidity   //Distribute premium and fee   uint256 _endTime = _span + block.timestamp;   uint256 _premium = getPremium(_amount, _span);   uint256 _fee = parameters.getFeeRate(msg.sender);    require(       _amount <= availableBalance(),       "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"   );   require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");   require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");   require(       parameters.getMinDate(msg.sender) <= _span,       "ERROR: INSURE_SPAN_BELOW_MIN"   );    require(       marketStatus == MarketStatus.Trading,       "ERROR: INSURE_MARKET_PENDING"   );   require(paused == false, "ERROR: INSURE_MARKET_PAUSED"); ``` to something like this: ```solidity   require(paused == false, "ERROR: INSURE_MARKET_PAUSED");   require(       marketStatus == MarketStatus.Trading,       "ERROR: INSURE_MARKET_PENDING"   );    require(       _amount <= availableBalance(),       "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"   );    require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");   require(       parameters.getMinDate(msg.sender) <= _span,       "ERROR: INSURE_SPAN_BELOW_MIN"   );    //Distribute premium and fee   uint256 _premium = getPremium(_amount, _span);   require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");    uint256 _endTime = _span + block.timestamp;   uint256 _fee = parameters.getFeeRate(msg.sender); ```  
# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `_fee[_target]` can be loaded twice from storage: ``` 271:     function getFeeRate(address _target) 272:         external 273:         view 274:         override 275:         returns (uint256) 276:     { 277:         if (_fee[_target] == 0) { 278:             return _fee[address(0)]; 279:         } else { 280:             return _fee[_target]; 281:         } 282:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the storage reading in a memory variable  
# Handle  gzeon   # Vulnerability details  ## Impact Use unchecked for safe math to save gas, for example: https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PremiumModels/BondingPremium.sol#L176 ```         premiumRate = premiumRate / T_1 / (u1 - u2) / BASE; ``` Since we have 1) T_1 != 0 (L229) 2) (u1 - u2) != 0 (L126-132) 3) BASE != 0 (L28) we can safely wrap this line in an unchecked block  
# Handle  pauliax   # Vulnerability details  ## Impact _withdrawAttribution should validate that _to is not an empty address 0x0 to prevent accidental burns. Similarly, transferValue _destination param and withdrawValue _to param should also be checked against an empty address unless this is the intended functionality in some cases.  ## Recommended Mitigation Steps require _to != address(0)  
# Handle  Dravee   # Vulnerability details  ## Impact  Division by 0 or functionally incorrect `targetLev`  ## POC A division by `targetLev` is made here : https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L306 and `targetLev` can be set to 0 : https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L575  ## Tools Used VS Code  ## Recommended Mitigation Steps Either make a check on `targetLev` before setting it here: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L575 or make a check before the division here: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L306   
# Handle  pauliax   # Vulnerability details  ## Impact Can be refactored, from this: ```solidity   require(       request.timestamp +           parameters.getLockup(msg.sender) <           block.timestamp,       "ERROR: WITHDRAWAL_QUEUE"   );   require(       request.timestamp +           parameters.getLockup(msg.sender) +           parameters.getWithdrawable(msg.sender) >           block.timestamp,       "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"   ); ``` to this: ```solidity   uint256 unlocksAt = request.timestamp + parameters.getLockup(msg.sender);   require(       unlocksAt < block.timestamp,       "ERROR: WITHDRAWAL_QUEUE"   );   require(       unlocksAt + parameters.getWithdrawable(msg.sender) > block.timestamp,       "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"   ); ```  There are more places where this optimization could be applied besides the provided example, but the basic idea is to cache the result of repeated math operation when the value does not change.  
# Handle  pauliax   # Vulnerability details  ## Impact function repayDebt could be refactored to reduce deployment and operational costs from this: ```solidity   uint256 _debt = debts[_target];   if (_debt >= _amount) {       debts[_target] -= _amount;       totalDebt -= _amount;       IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);   } else {       debts[_target] = 0;       totalDebt -= _debt;       IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);   } ``` to this: ```solidity   uint256 _debt = debts[_target];   if (_debt > _amount) {       debts[_target] = _debt - _amount;   } else {       debts[_target] = 0;       _amount = _debt;   }   totalDebt -= _amount;   IERC20(token).safeTransferFrom(msg.sender, address(this), _amount); ```  
# Handle  pauliax   # Vulnerability details  ## Impact Repeated storage read should be cached, e.g. attributions[_target] is read from storage twice: ```solidity         if (attributions[_target] > 0) {             return (valueAll() * attributions[_target]) / totalAttributions; ``` totalAttributions read twice: ```solidity         if (totalAttributions > 0 && _attribution > 0) {             return (_attribution * valueAll()) / totalAttributions; ``` available() called twice: ```solidity         if (available() < _retVal) {             uint256 _shortage = _retVal - available(); ``` would be cheaper to use _token from memory here: ```solidity     IERC20(token).safeTransfer(_to, _redundant); ```  There are more places where this optimization could be applied besides the provided examples, but the basic idea is to cache storage variables if you need to access them multiple times when the value does not change.  
# Handle  pauliax   # Vulnerability details  ## Impact Avoid repeated external calls, e.g. here token balanceOf is queried 4 times: ```solidity if (     ...     balance < IERC20(token).balanceOf(address(this)) ) {     uint256 _redundant = IERC20(token).balanceOf(address(this)) - balance;     ... } else if (IERC20(_token).balanceOf(address(this)) > 0) {     IERC20(_token).safeTransfer(         _to,         IERC20(_token).balanceOf(address(this))     ); } ``` You should query it only once and then use the cached value as it doesn't change between the statements.  
# Handle  pauliax   # Vulnerability details  ## Impact You dont need this else block, code can be refactored from this: ```solidity   if (address(controller) != address(0)) {       controller.migrate(address(_controller));       controller = IController(_controller);   } else {       controller = IController(_controller);   } ``` to this: ```solidity   if (address(controller) != address(0)) {       controller.migrate(address(_controller));   }   controller = IController(_controller); ```  
# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `totalLiquidity()` is loaded twice from storage ``` 491:     function leverage() public view returns (uint256 _rate) { 492:         //check current leverage rate 493:         if (totalLiquidity() > 0) { 494:             return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); 495:         } else { 496:             return 0; 497:         } 498:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `totalLiquidity()` in a variable  
# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `IndexTemplate.sol:deposit()`, the code is as follows: ``` 172:         if (_supply > 0 && _totalLiquidity > 0) {   173:             _mintAmount = (_amount * _supply) / _totalLiquidity; 174:         } else if (_supply > 0 && _totalLiquidity == 0) { 175:             //when 176:             _mintAmount = _amount * _supply; 177:         } else { 178:             _mintAmount = _amount; 179:         } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for further information): ```       if (_supply == 0) {           _mintAmount = _amount;       } else if (_totalLiquidity == 0) { // @audit-info : implicit _supply > 0 as above condition is false           _mintAmount = _amount * _supply;       } else { // @audit-info : implicit _supply > 0 and _totalLiquidity > 0 as both the previous conditions are false           _mintAmount = (_amount * _supply) / _totalLiquidity;       } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements   
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost as SSTOREs are very expensive  ## Proof of Concept The code is as follows : ``` 094:     function approveTemplate( 095:         IUniversalMarket _template, 096:         bool _approval, 097:         bool _isOpen, 098:         bool _duplicate 099:     ) external override onlyOwner { 100:         require(address(_template) != address(0)); 101:         templates[address(_template)].approval = _approval; //@audit-info SSTORE 102:         templates[address(_template)].isOpen = _isOpen; //@audit-info SSTORE 103:         templates[address(_template)].allowDuplicate = _duplicate; //@audit-info SSTORE 104:         emit TemplateApproval(_template, _approval, _isOpen, _duplicate); 105:     } ``` As we can see, it's making 3 SSTORE operations, one for each boolean. The code could be optimized as follows to save gas : ```     function approveTemplate(         IUniversalMarket _template,         bool _approval,         bool _isOpen,         bool _duplicate     ) external override onlyOwner {         require(address(_template) != address(0));         Template memory approvedTemplate = new Template(_isOpen, _approval, _duplicate);         templates[address(_template)] = approvedTemplate; //@audit-info only one SSTORE         emit TemplateApproval(_template, _approval, _isOpen, _duplicate);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use a memory `Template ` struct and write in storage only once  
# Handle  Dravee   # Vulnerability details  The spec says the function should be called `approveCondition()` instead of `setCondition`: https://insuredao.gitbook.io/developers/market/factory#approvecondition  While this might still be understood nonetheless as `setCondition` is also mentioned, the spec says that the parameter `_slot` is the `index of the reference array`, whereas the code comment says it's the `index within condition array`: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L133  ## Tools Used VS Code  ## Recommended Mitigation Steps My guess is that the spec should be corrected  
# Handle  Dravee   # Vulnerability details  The spec doesn't match with the comments in the code here:   Code: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L90-L91 Spec: https://insuredao.gitbook.io/developers/market/factory#approvetemplate  Here, the spec doesn't mention `_isOpen` and seem to confuse the `_approval` description with what `_isOpen` should be.  ## Tools Used VS Code  ## Recommended Mitigation Steps My guess is that the spec should be corrected  
# Handle  Dravee   # Vulnerability details  ## Impact A division by 0 could occur  ## Proof of Concept While at some places, a check is made to make sure that `totalSupply() > 0`, it's not consistently the case, such as in the following places:  ``` contracts\CDSTemplate.sol:235:        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply(); contracts\CDSTemplate.sol:318:                _balance * vault.attributionValue(crowdPool) / totalSupply(); contracts\IndexTemplate.sol:216:        _retVal = (_liquidty * _amount) / totalSupply(); contracts\IndexTemplate.sol:530:            return (_balance * totalLiquidity()) / totalSupply(); contracts\PoolTemplate.sol:768:            return (_balance * originalLiquidity()) / totalSupply(); ```  At the following places, the check is indeed made: ``` contracts\IndexTemplate.sol:514:            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); contracts\PoolTemplate.sol:747:            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps If this check is at least made at some places, this means that `totalSupply()` can indeed take a value of 0. Therefore, a check should always be made to prevent the div by 0  
# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `CDSTemplate.sol:deposit()`, the code is as follows: ``` 140:         if (_supply > 0 && _liquidity > 0) {  141:             _mintAmount = (_amount * _supply) / _liquidity; 142:         } else if (_supply > 0 && _liquidity == 0) { 143:             //when vault lose all underwritten asset =  144:             _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again. 145:         } else { 146:             //when _supply == 0, 147:             _mintAmount = _amount; 148:         } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for futher information): ```         if (_supply == 0) {              _mintAmount = _amount;         } else if (_liquidity == 0) { // @audit-info : implicit _supply > 0 as above condition is false             //when vault lose all underwritten asset =              _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.         } else { // @audit-info : implicit _supply > 0 and _liquidity > 0 as both the previous conditions are false             _mintAmount = (_amount * _supply) / _liquidity;         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements  
# Handle  Fitraldys   # Vulnerability details  ## Impact In the https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L157 it is the descriptionof the depoist function, and not the correct description for the fund function.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L156-L173    
# Handle  WatchPug   # Vulnerability details  ## Root Cause  Wrong arithmetic.  ---  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L700-L717  ```solidity uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /             totalLiquidity();     uint256 _actualDeduction;     for (uint256 i = 0; i < indexList.length; i++) {         address _index = indexList[i];         uint256 _credit = indicies[_index].credit;         if (_credit > 0) {             uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /                 _totalCredit;             uint256 _redeemAmount = _divCeil(                 _deductionFromIndex,                 _shareOfIndex             );             _actualDeduction += IIndexTemplate(_index).compensate(                 _redeemAmount             );         }     } ```   ### PoC  - totalLiquidity = 200,000* 10**18; - totalCredit = 100,000 * 10**18; - debt = 10,000 * 10**18;  - [Index Pool 1] Credit = 20,000 * 10**18; - [Index Pool 2] Credit = 30,000 * 10**18;  ``` uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /             totalLiquidity(); // _deductionFromIndex = 10,000 * 10**6 * 10**18;  ```  [Index Pool 1]:  ``` uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;   //  _shareOfIndex = 200000  uint256 _redeemAmount = _divCeil(     _deductionFromIndex,     _shareOfIndex );  // _redeemAmount = 25,000 * 10**18; ```  [Index Pool 2]:  ``` uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;   //  _shareOfIndex = 300000  uint256 _redeemAmount = _divCeil(     _deductionFromIndex,     _shareOfIndex );  // _redeemAmount = 16666666666666666666667 (~ 16,666 * 10**18) ```  In most cases, the transaction will revet on underflow at: ``` uint256 _shortage = _deductionFromIndex /             MAGIC_SCALE_1E6 -             _actualDeduction; ```  In some cases, specific pools will be liable for unfair compensation:  If the CSD is empty, `Index Pool 1` only have `6,000 * 10**18` and `Index Pool 2` only have `4,000 * 10**18`, the `_actualDeduction` will be `10,000 * 10**18`, `_deductionFromPool` will be `0`.   `Index Pool 1` should only pay `1,000 * 10**18`, but actually paid `6,000 * 10**18`, the LPs of `Index Pool 1` now suffer funds loss.  ### Recommendation  Change to:  ```solidity uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) / totalLiquidity(); uint256 _actualDeduction; for (uint256 i = 0; i < indexList.length; i++) {     address _index = indexList[i];     uint256 _credit = indicies[_index].credit;     if (_credit > 0) {         uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /             _totalCredit;         uint256 _redeemAmount = _divCeil(             _deductionFromIndex * _shareOfIndex,             MAGIC_SCALE_1E6 * MAGIC_SCALE_1E6         );         _actualDeduction += IIndexTemplate(_index).compensate(             _redeemAmount         );     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L146-L146  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L95-L95  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L55-L55  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L38-L38  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```  For the constants that should not be `public`, changing them to `private` / `internal` can save some gas. To avoid unnecessary getter functions.  
# Handle  WatchPug   # Vulnerability details  In the current implementation, when an incident is reported for a certain pool, the index pool can still `withdrawCredit()` from the pool, which in the best interest of an index pool, the admin of the index pool is preferred to do so.  This allows the index pool to escape from the responsibility for the risks of invested pools.  Making the LPs of the pool take an unfair share of the responsibility.  ### PoC  - Pool A `totalCredit` = 10,000 - Pool A `rewardPerCredit` = 1  1. [Index Pool 1] allocates 1,000 credits to Pool `A`:  - `totalCredit` = 11,000 - indicies[Index Pool 1] = 1,000  2. After a while, Pool A `rewardPerCredit` has grown to `1.1`, and `applyCover()` has been called, [Index Pool 1] call `withdrawCredit()` get 100 premium  - `totalCredit` = 10,000 - indicies[Index Pool 1] = 0  3. After `pendingEnd`, the pool `resume()`,[ Index Pool 1] will not be paying for the compensation since `credit` is 0.  In our case, [Index Pool 1] earned premium without paying for a part of the compensation.  ### Recommendation  Change to:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L416-L421  ```solidity     function withdrawCredit(uint256 _credit)         external         override         returns (uint256 _pending)     {         require(             marketStatus == MarketStatus.Trading,             "ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS"         );         IndexInfo storage _index = indicies[msg.sender]; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L429-L434  ```solidity function _unutilize(uint256 _amount) internal {     require(address(controller) != address(0), "ERROR_CONTROLLER_NOT_SET");      controller.withdraw(address(this), _amount);     balance += _amount; } ```  ### Recommendation  Can be changed to:  ```solidity function _unutilize(uint256 _amount) internal {     require(address(controller) != address(0), "ERROR_CONTROLLER_NOT_SET");      uint256 beforeBalance = IERC20(token).balanceOf(address(this));     controller.withdraw(address(this), _amount);     uint256 received = IERC20(token).balanceOf(address(this)) - beforeBalance;     require(received >= _amount, "...");     balance += received; } ```   
# Handle  WatchPug   # Vulnerability details  ## Root Cause  Precision loss while converting between `the amount of shares` and `the amount of underlying tokens` back and forth is not handled properly.  ---  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L438-L447  ```solidity uint256 _shortage; if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = _value + _cds; } vault.offsetDebt(_compensated, msg.sender); ```  In the current implementation, when someone tries to resume the market after a pending period ends by calling `PoolTemplate.sol#resume()`, `IndexTemplate.sol#compensate()` will be called internally to make a payout. If the index pool is unable to cover the compensation, the CDS pool will then be used to cover the shortage.  However, while `CDSTemplate.sol#compensate()` takes a parameter for the amount of underlying tokens, it uses `vault.transferValue()` to transfer corresponding `_attributions` (shares) instead of underlying tokens.  Due to precision loss, the `_attributions` transferred in the terms of underlying tokens will most certainly be less than the shortage.  At L444, the contract believes that it's been compensated for `_value + _cds`, which is lower than the actual value, due to precision loss.  At L446, when it calls `vault.offsetDebt(_compensated, msg.sender)`, the tx will revert at `require(underlyingValue(msg.sender) >= _amount)`.  As a result, `resume()` can not be done, and the debt can't be repaid.  ### PoC   Given:  - vault.underlyingValue = 10,000 - vault.valueAll = 30,000 - totalAttributions = 2,000,000 - _amount = 1,010,000  0. _shortage = _amount - vault.underlyingValue = 1,000,000 1. _attributions = (_amount * totalAttributions) / valueAll = 67,333,333 2. actualValueTransfered = (valueAll * _attributions) / totalAttributions = 1009999  **Expected results**: actualValueTransfered = _shortage;  **Actual results**: actualValueTransfered < _shortage.  ## Impact  The precision loss isn't just happening on special numbers, but will most certainly always revert the txs.  This will malfunction the contract as the index pool can not `compensate()`, therefore the pool can not `resume()`. Causing the funds of the LPs of the pool and the index pool to be frozen, and other stakeholders of the same vault will suffer fund loss from an unfair share of the funds compensated before.  ## Recommendation  Change to:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L439-L446  ```solidity if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = vault.underlyingValue(address(this)); } vault.offsetDebt(_compensated, msg.sender); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L485-L496  ```solidity function setController(address _controller) public override onlyOwner {     require(_controller != address(0), "ERROR_ZERO_ADDRESS");      if (address(controller) != address(0)) {         controller.migrate(address(_controller));         controller = IController(_controller);     } else {         controller = IController(_controller);     }      emit ControllerSet(_controller); } ```  `controller.migrate()` is a critical operation, we recommend adding validation for the amount of migrated funds.  ### Recommendation  Can be changed to:  ```solidity function setController(address _controller) public override onlyOwner {     require(_controller != address(0), "ERROR_ZERO_ADDRESS");      if (address(controller) != address(0)) {         uint256 beforeUnderlying = controller.valueAll();         controller.migrate(address(_controller));         require(IController(_controller).valueAll() >= beforeUnderlying, "...");         controller = IController(_controller);     } else {         controller = IController(_controller);     }      emit ControllerSet(_controller); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Ownership.sol#L17-L20  ```solidity constructor() {     _owner = msg.sender;     emit AcceptNewOwnership(_owner); } ```  At L19, the parameter of `AcceptNewOwnership` can use `msg.sender` directly to avoid unnecessary storage read of `_owner` to save some gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Ownership.sol#L65-L71  ```solidity function acceptTransferOwnership() external override onlyFutureOwner {     /***         *@notice Accept a transfer of ownership         */     _owner = _futureOwner;     emit AcceptNewOwnership(_owner); } ```  At L69, `_futureOwner` can use `msg.sender` directly to avoid unnecessary storage read of `_futureOwner` to save some gas.  As `onlyFutureOwner()` ensures that `require(_futureOwner == msg.sender, "...");`.  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L153-L158  ```solidity require(     attributions[msg.sender] > 0 &&         underlyingValue(msg.sender) >= _amount,     "ERROR_WITHDRAW-VALUE_BADCONDITOONS" ); _attributions = (totalAttributions * _amount) / valueAll(); ```  In `Vault#withdrawValue()`, `controller.valueAll()` is called twice:  1. L155 `underlyingValue(msg.sender)` -> `valueAll()` -> `controller.valueAll()`; 1. L158 `valueAll()` ->  `controller.valueAll()`.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L400-L411  ```solidity function underlyingValue(address _target)     public     view     override     returns (uint256) {     if (attributions[_target] > 0) {         return (valueAll() * attributions[_target]) / totalAttributions;     } else {         return 0;     } } ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L417-L423  ```solidity function valueAll() public view returns (uint256) {     if (address(controller) != address(0)) {         return balance + controller.valueAll();     } else {         return balance;     } } ```  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on the function call  ## Proof of Concept  availableBalance calls totalLiquidity() twice:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L835  ## Recommended Mitigation Steps  Save the call result to memory and use it  
# Handle  hyh   # Vulnerability details    ## Impact  `setKeeper` / `utilize` descriptions state that it is controller who is set / can run utilize, while keeper and controller are two separate roles, which don't have to coincide.  I.e. the descriptions now mix up the roles and are confusing this way.  ## Proof of Concept  setKeeper:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L499   utilize:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L339   ## Recommended Mitigation Steps  Update the descriptions to relate to the `keeper` role.   
# Handle  Jujic   # Vulnerability details  ## Impact Insurance struct in `PoolTemplate .sol` can be optimized to reduce 2 storage slot  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L127-L128 ``` struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     } ``` `startTime` and `endTime `store block numbers, and 2^48 is being enough for a very long time. ## Tools Used https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html?highlight=Structs#layout-of-state-variables-in-storage   ## Recommended Mitigation Steps The struct can be changed into: ``` struct Insurance {         uint256 id; //each insuance has their own id         uint48 startTime; //timestamp of starttime         uint48 endTime; //timestamp of endtime         address insured; //the address holds the right to get insured         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         bool status; //true if insurance is not expired or redeemed     } ```   
# Handle  cmichel   # Vulnerability details  The `Vault.withdrawRedundant` has wrong logic that allows the admins to steal the underlying vault token.  ```solidity function withdrawRedundant(address _token, address _to)      external      override      onlyOwner {      if (           _token == address(token) &&           balance < IERC20(token).balanceOf(address(this))      ) {           uint256 _redundant = IERC20(token).balanceOf(address(this)) -                balance;           IERC20(token).safeTransfer(_to, _redundant);      } else if (IERC20(_token).balanceOf(address(this)) > 0) {           // @audit they can rug users. let's say balance == IERC20(token).balanceOf(address(this)) => first if false => transfers out everything           IERC20(_token).safeTransfer(                _to,                IERC20(_token).balanceOf(address(this))           );      } } ```  #### POC - Vault deposits increase as `Vault.addValue` is called and the `balance` increases by `_amount` as well as the actual `IERC20(token).balanceOf(this)`. Note that `balance == IERC20(token).balanceOf(this)` - Admins call `vault.withdrawRedundant(vault.token(), attacker)` which goes into the `else if` branch due to the balance inequality condition being `false`. It will transfer out all `vault.token()` amounts to the attacker.  ## Impact There's a backdoor in the `withdrawRedundant` that allows admins to steal all user deposits.  ## Recommended Mitigation Steps I think the devs wanted this logic from the code instead:  ```solidity function withdrawRedundant(address _token, address _to)      external      override      onlyOwner {      if (           _token == address(token)      ) {           if (balance < IERC20(token).balanceOf(address(this))) {                uint256 _redundant = IERC20(token).balanceOf(address(this)) -                     balance;                IERC20(token).safeTransfer(_to, _redundant);           }      } else if (IERC20(_token).balanceOf(address(this)) > 0) {           IERC20(_token).safeTransfer(                _to,                IERC20(_token).balanceOf(address(this))           );      } } ```   
# Handle  cmichel   # Vulnerability details  Note that the `PoolTemplate.initialize` function, called when creating a market with `Factory.createMarket`, calls a vault function to transfer an initial deposit amount (`conditions[1]`) _from_ the initial depositor (`_references[4]`):  ```solidity // PoolTemplate function initialize(      string calldata _metaData,      uint256[] calldata _conditions,      address[] calldata _references ) external override {      // ...       if (_conditions[1] > 0) {           // @audit vault calls asset.transferFrom(_references[4], vault, _conditions[1])           _depositFrom(_conditions[1], _references[4]);      } }  function _depositFrom(uint256 _amount, address _from)      internal      returns (uint256 _mintAmount) {      require(           marketStatus == MarketStatus.Trading && paused == false,           "ERROR: DEPOSIT_DISABLED"      );      require(_amount > 0, "ERROR: DEPOSIT_ZERO");       _mintAmount = worth(_amount);      // @audit vault calls asset.transferFrom(_from, vault, _amount)      vault.addValue(_amount, _from, address(this));       emit Deposit(_from, _amount, _mintAmount);       //mint iToken      _mint(_from, _mintAmount); } ```  The initial depositor needs to first approve the vault contract for the `transferFrom` to succeed.  An attacker can then frontrun the `Factory.createMarket` transaction with their own market creation (it does not have access restrictions) and create a market _with different parameters_ but still passing in `_conditions[1]=amount` and `_references[4]=victim`.  A market with parameters that the initial depositor did not want (different underlying, old whitelisted registry/parameter contract, etc.) can be created with their tokens and these tokens are essentially lost.  ## Recommended Mitigation Steps Can the initial depositor be set to `Factory.createMarket`'s `msg.sender`, instead of being able to pick a whitelisted one as `_references[4]`?   
# Handle  cmichel   # Vulnerability details  The `Parameters.setLowerSlack/setUpperSlack` functions do not check that the new value does still satisfy the `_lowerSlack <= _upperSlack` condition.  ## Recommended Mitigation Steps Check that `_lowerSlack <= _upperSlack`  is still satisfied in these functions.   
# Handle  cmichel   # Vulnerability details  The `Ownership.acceptTransferOwnership` function does not reset `_futureOwner` to zero.  ## Impact The future owner can repeatedly accept the governance, emitting an `AcceptNewOwnership` event each time, bloating listeners for this event with unnecessary data.  ## Recommended Mitigation Steps Reset `_futureOwner` to zero in `acceptTransferOwnership`.   
# Handle  hubble   # Vulnerability details  Feel free to lower the severity of the issue to Non-critical.  ## Impact Correctness of variable name  ## Proof of Concept File : Parameters.sol    line 39 :    mapping(address => uint256) private _withdawable;   line 153 :         _withdawable[_address] = _target;   line 349-352 :         if (_withdawable[_target] == 0) {             return _withdawable[address(0)];         } else {             return _withdawable[_target];  ## Tools Used Manual review  ## Recommended Mitigation Steps Change typo to _withdrawable   
# Handle  hubble   # Vulnerability details   ## Impact Input validation required for few important parameters as mentioned in the below functions.  ## Proof of Concept File : Parameters.sol    line 120 :     function setUpperSlack(address _address, uint256 _target)           Need to check that the _target value should be less than or equal to 100% (1000)     line 134 :     function setLowerSlack(address _address, uint256 _target)          Need to check that the _target value should be less than or equal to corresponding UpperSlack Value     line 177 :     function setFeeRate(address _address, uint256 _target)           Need to check that the _target value should be less than or equal to 1e6 (1000000)     line 191 :     function setMaxList(address _address, uint256 _target)           Need to check that the _target value should be greater than 1  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require statements with proper value and comments for the respective input fields as given above   
# Handle  hubble   # Vulnerability details   ## Impact Inconsistency in pragma solidity versions in different solidity files.  ## Proof of Concept File : InsureDAOERC20.sol        pragma solidity ^0.8.0;  All other solidity files in the project        pragma solidity 0.8.7;  ## Tools Used Manual review  ## Recommended Mitigation Steps Set the version to 0.8.7 in the InsureDAOERC20.sol file  
# Handle  Jujic   # Vulnerability details  ## Impact The constructor is empty. You should remove constructor to save some gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L21 ``` constructor() {} ```  ## Tools Used  ## Recommended Mitigation Steps Remove unused constructor   
# Handle  WatchPug   # Vulnerability details  Check `marketStatus` before for loops can save gas from unnecessary repeated checks.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L342-L365  ```solidity function unlockBatch(uint256[] calldata _ids) external {     for (uint256 i = 0; i < _ids.length; i++) {         unlock(_ids[i]);     } }  function unlock(uint256 _id) public {     require(         insurances[_id].status == true &&             marketStatus == MarketStatus.Trading &&             insurances[_id].endTime + parameters.getGrace(msg.sender) <             block.timestamp,         "ERROR: UNLOCK_BAD_COINDITIONS"     );     insurances[_id].status == false;      lockedAmount = lockedAmount - insurances[_id].amount;      emit Unlocked(_id, insurances[_id].amount); } ```  ### Recomandation  Change to:  ```solidity function unlockBatch(uint256[] calldata _ids) external {     require(marketStatus == MarketStatus.Trading, "ERROR: UNLOCK_BAD_COINDITIONS")     for (uint256 i = 0; i < _ids.length; i++) {         _unlock(_ids[i]);     } }  function unlock(uint256 _id) external {     require(marketStatus == MarketStatus.Trading, "ERROR: UNLOCK_BAD_COINDITIONS");     _unlock(_id); }  function _unlock(uint256 _id) internal {     require(         insurances[_id].status == true &&             insurances[_id].endTime + parameters.getGrace(msg.sender) <             block.timestamp,         "ERROR: UNLOCK_BAD_COINDITIONS"     );     insurances[_id].status == false;      lockedAmount = lockedAmount - insurances[_id].amount;      emit Unlocked(_id, insurances[_id].amount); } ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L260-L270  ```solidity if (_available >= _amount) {     _compensated = _amount;     _attributionLoss = vault.transferValue(_amount, msg.sender);     emit Compensated(msg.sender, _amount); } else {     //when CDS cannot afford, pay as much as possible     _compensated = _available;     _attributionLoss = vault.transferValue(_available, msg.sender);     emit Compensated(msg.sender, _available); }  ```  ### Recommendation  Change to:  ```solidity _compensated = _available >= _amount? _amount: _available;  _attributionLoss = vault.transferValue(_compensated, msg.sender); emit Compensated(msg.sender, _compensated); ```  - Duplicated codes removed; - Shorter and simpler code.  
# Handle  WatchPug   # Vulnerability details  Cache and reusing the function call results, instead of calling it again, can save gas from unnecessary code execution.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L163-L173  ```solidity if (available() < _amount) {      //when USDC in this contract isn't enough     uint256 _shortage = _amount - available();     _unutilize(_shortage);      assert(available() >= _amount); }  balance -= _amount; IERC20(token).safeTransfer(_to, _amount); ```  ### Recommendation  Change to:  ```solidity uint256 availableAmount = available() if ( availableAmount < _amount) {      //when USDC in this contract isn't enough     uint256 _shortage = _amount - available();     _unutilize(_shortage);      assert(availableAmount >= _amount); }  balance -= _amount; IERC20(token).safeTransfer(_to, _amount); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L295-L304  ```solidity function rate() external view returns (uint256) {     if (totalSupply() > 0) {         return             (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /             totalSupply();     } else {         return 0;     } } ```  `totalSupply()`  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L309-L312  ```solidity if (available() < _retVal) {     uint256 _shortage = _retVal - available();     _unutilize(_shortage); } ```  `available()`  
# Handle  WatchPug   # Vulnerability details  When there are multiple checks, adjusting the sequence to allow the tx to fail earlier can save some gas.  Checks using less gas should be executed earlier than those with higher gas costs, to avoid unnecessary storage read, arithmetic operations, etc when it reverts.  For example:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L238-L256  ```solidity require(paused == false, "ERROR: PAUSED"); require(     request.timestamp +         parameters.getLockup(msg.sender) <         block.timestamp,     "ERROR: WITHDRAWAL_QUEUE" ); require(     request.timestamp +         parameters.getLockup(msg.sender) +         parameters.getWithdrawable(msg.sender) >         block.timestamp,     "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST" ); require(     request.amount >= _amount,     "ERROR: WITHDRAWAL_EXCEEDED_REQUEST" ); require(_amount > 0, "ERROR: WITHDRAWAL_ZERO"); ```  The check of `_amount > 0` can be done earlier to avoid reading from storage when `_amount = 0`.  ## Recommendation  Change to:  ```solidity         require(paused == false, "ERROR: PAUSED");         require(_amount > 0, "ERROR: WITHDRAWAL_ZERO");         require(             request.amount >= _amount,             "ERROR: WITHDRAWAL_EXCEEDED_REQUEST"         );         require(             request.timestamp +                 parameters.getLockup(msg.sender) <                 block.timestamp,             "ERROR: WITHDRAWAL_QUEUE"         );         require(             request.timestamp +                 parameters.getLockup(msg.sender) +                 parameters.getWithdrawable(msg.sender) >                 block.timestamp,             "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"         ); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L189-L191  ```solidity uint256 _balance = balanceOf(msg.sender); require(_balance >= _amount, "ERROR: REQUEST_EXCEED_BALANCE"); require(_amount > 0, "ERROR: REQUEST_ZERO"); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L217-L236  ```solidity require(locked == false, "ERROR: WITHDRAWAL_PENDING"); require(     _requestTime + _lockup < block.timestamp,     "ERROR: WITHDRAWAL_QUEUE" ); require(     _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >         block.timestamp,     "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST" ); require(     withdrawalReq[msg.sender].amount >= _amount,     "ERROR: WITHDRAWAL_EXCEEDED_REQUEST" ); require(_amount > 0, "ERROR: WITHDRAWAL_ZERO");  require(     _retVal <= withdrawable(),     "ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY" ); ```  
# Handle  defsec   # Vulnerability details  The setFeeRate function does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.  ## Proof of Concept  - The setFeeRate function sets the transaction fee rates for the market in which the function is called. In this context, the transaction fee is the percentage of a transaction that is taken by the protocol and moved to a designated reserve account. As the name suggests, transaction fees factor in to many of the essential transaction types performed within the system. - Navigate to "https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Parameters.sol#L177". - On the function there is no upper and lower bound defined. Therefore, users can pay higher fees.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to define upper and lower bounds on the fee array.  
# Handle  defsec   # Vulnerability details  ## Impact  On the InsureDAOERC20, transferFrom function is vulnerable on the re-entrancy.  ## Proof of Concept  1. Navigate to the following contract. Approve function is written after transfer call. It is not possible to exploit on the current environment but that can be possible on the EVM.  ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         _transfer(sender, recipient, amount);          uint256 currentAllowance = _allowances[sender][_msgSender()];         require(             currentAllowance >= amount,             "ERC20: transfer amount exceeds allowance"         );          _approve(sender, _msgSender(), currentAllowance - amount);          return true;     } ```   ## Tools Used  Code Review  ## Recommended Mitigation Steps   Follow check effect interaction pattern. Consider to use openzeppelin erc20 contract. The sample transferFrom function can be seen from below.   ```   function transferFrom(       address sender,       address recipient,       uint256 amount   ) public virtual override returns (bool) {       uint256 currentAllowance = _allowances[sender][_msgSender()];       if (currentAllowance != type(uint256).max) {           require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");           unchecked {               _approve(sender, _msgSender(), currentAllowance - amount);           }       }        _transfer(sender, recipient, amount);        return true;   } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L161  
# Handle  defsec   # Vulnerability details  ## Impact  On the ERC20, There is a known problem named as Approve/TransferFrom race condition. On the transferFrom, allowance max check has not been added.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152  ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         uint256 currentAllowance = _allowances[sender][_msgSender()];         if (currentAllowance != type(uint256).max) {             require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");             unchecked {                 _approve(sender, _msgSender(), currentAllowance - amount);             }         }          _transfer(sender, recipient, amount);          return true;     }  ```  2. Max Allowance check has not been added into the function. ERC20 standart (Openzeppelin) is not followed.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to use openzeppelin erc20 contract. The sample transferFrom function can be seen from below.   ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         uint256 currentAllowance = _allowances[sender][_msgSender()];         if (currentAllowance != type(uint256).max) {             require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");             unchecked {                 _approve(sender, _msgSender(), currentAllowance - amount);             }         }          _transfer(sender, recipient, amount);          return true;     } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L161  
# Handle  leastwood   # Vulnerability details  ## Impact  The current method of market creation involves calling `Factory.createMarket()` with a list of approved `_conditions` and `_references` accounts. If a registered template address has `templates[address(_template)].isOpen == true`, then any user is able to call `createMarket()` using this template. If the template points to `PoolTemplate.sol`, then a malicious market creator can abuse `PoolTemplate.initialize()` as it makes a vault deposit from an account that they control. The vulnerable internal function, `_depositFrom()`, makes a vault deposit from the `_references[4]` address (arbitrarily set to an approved reference address upon market creation).  Hence, if approved `_references` accounts have set an unlimited approval amount for `Vault.sol` before deploying their market, a malicious user can frontrun market creation and cause these tokens to be transferred to the incorrect market.  This issue can cause honest market creators to have their tokens transferred to an incorrectly configured market, leading to unrecoverable funds. If their approval to `Vault.sol` was set to the unlimited amount, malicious users will also be able to force honest market creators to transfer more tokens than they would normally want to allow. ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L158-L231 ``` function createMarket(     IUniversalMarket _template,     string memory _metaData,     uint256[] memory _conditions,     address[] memory _references ) public override returns (address) {     //check eligibility     require(         templates[address(_template)].approval == true,         "ERROR: UNAUTHORIZED_TEMPLATE"     );     if (templates[address(_template)].isOpen == false) {         require(             ownership.owner() == msg.sender,             "ERROR: UNAUTHORIZED_SENDER"         );     }     if (_references.length > 0) {         for (uint256 i = 0; i < _references.length; i++) {             require(                 reflist[address(_template)][i][_references[i]] == true ||                     reflist[address(_template)][i][address(0)] == true,                 "ERROR: UNAUTHORIZED_REFERENCE"             );         }     }      if (_conditions.length > 0) {         for (uint256 i = 0; i < _conditions.length; i++) {             if (conditionlist[address(_template)][i] > 0) {                 _conditions[i] = conditionlist[address(_template)][i];             }         }     }      if (         IRegistry(registry).confirmExistence(             address(_template),             _references[0]         ) == false     ) {         IRegistry(registry).setExistence(             address(_template),             _references[0]         );     } else {         if (templates[address(_template)].allowDuplicate == false) {             revert("ERROR: DUPLICATE_MARKET");         }     }      //create market     IUniversalMarket market = IUniversalMarket(         _createClone(address(_template))     );      IRegistry(registry).supportMarket(address(market));          markets.push(address(market));       //initialize     market.initialize(_metaData, _conditions, _references);      emit MarketCreated(         address(market),         address(_template),         _metaData,         _conditions,         _references     );      return address(market); } ```  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L178-L221 ``` function initialize(     string calldata _metaData,     uint256[] calldata _conditions,     address[] calldata _references ) external override {     require(         initialized == false &&             bytes(_metaData).length > 0 &&             _references[0] != address(0) &&             _references[1] != address(0) &&             _references[2] != address(0) &&             _references[3] != address(0) &&             _references[4] != address(0) &&             _conditions[0] <= _conditions[1],         "ERROR: INITIALIZATION_BAD_CONDITIONS"     );     initialized = true;      string memory _name = string(         abi.encodePacked(             "InsureDAO-",             IERC20Metadata(_references[1]).name(),             "-PoolInsurance"         )     );     string memory _symbol = string(         abi.encodePacked("i-", IERC20Metadata(_references[1]).symbol())     );     uint8 _decimals = IERC20Metadata(_references[0]).decimals();      initializeToken(_name, _symbol, _decimals);      registry = IRegistry(_references[2]);     parameters = IParameters(_references[3]);     vault = IVault(parameters.getVault(_references[1]));      metadata = _metaData;      marketStatus = MarketStatus.Trading;      if (_conditions[1] > 0) {         _depositFrom(_conditions[1], _references[4]);     } } ```  ## Tools Used  Manual code review. Discussions with kohshiba.  ## Recommended Mitigation Steps  After discussions with the sponsor, they have opted to parse a `_creator` address to `PoolTemplate.sol` which will act as the depositor and be set to `msg.sender` in `Factory.createMarket()`. This will prevent malicious market creators from forcing vault deposits from unsuspecting users who are approved in `Factory.sol` and have also approved `Vault.sol` to make transfers on their behalf.  
# Handle  WatchPug   # Vulnerability details  Check of allowance can be done earlier (before `_transfer()`) to save some gas for failure transactions.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152-L168  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     require(         currentAllowance >= amount,         "ERC20: transfer amount exceeds allowance"     );      _approve(sender, _msgSender(), currentAllowance - amount);      return true; } ```   See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162-L169   
# Handle  WatchPug   # Vulnerability details  Removing `return 0` can make the code simpler and save some gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L295-L303  ```solidity     function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return                 (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /                 totalSupply();         } else {             return 0;         }     } ```  ### Recommendation  Can be changed to:  ```solidity     function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return                 (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /                 totalSupply();         }      } ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L312-L317  ```solidity         if (_balance == 0) {             return 0;         } else {             return                 _balance * vault.attributionValue(crowdPool) / totalSupply();         } ```  Can be changed to:  ```solidity if (_balance > 0) {     return         _balance * vault.attributionValue(crowdPool) / totalSupply(); }  ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L176-L176  ```solidity for (uint256 i = 0; i < _references.length; i++) ```  Can be changed to:  ```solidity for (uint256 i; i < _references.length; i++) ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L493-L497  ```solidity if (totalLiquidity() > 0) {     return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); } else {     return 0; } ```  Can be changed to:  ```solidity if (totalLiquidity() > 0) {     return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); }  ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L288-L288  ```solidity require(registry.isListed(msg.sender)); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L100-L100  ```solidity require(address(_template) != address(0)); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L109-L113  ```solidity string memory _name = "InsureDAO-CDS"; string memory _symbol = "iCDS"; uint8 _decimals = IERC20Metadata(_references[0]).decimals();  initializeToken(_name, _symbol, _decimals); ```  The local variable `_name`, `_symbol`, `_decimals` is used only once. Making the expression inline can save gas.  ### Recommendation  Change to:  ```solidity initializeToken("InsureDAO-CDS", "iCDS", IERC20Metadata(_references[0]).decimals()); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L189-L190  ```solidity uint256 _balance = balanceOf(msg.sender); require(_balance >= _amount, "ERROR: REQUEST_EXCEED_BALANCE"); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L257-L257  ```solidity uint256 _surplusAttribution = surplusPool; ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L62-L63  ```solidity uint256 _assetReserve = asset.safeBalance(); require(_assetReserve >= assetReserve + assetIn, 'E304'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L51-L52  ```solidity uint256 _collateralReserve = collateral.safeBalance(); require(_collateralReserve >= collateralReserve + collateralIn, 'E305'); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L456-L463  ```solidity uint256 _shortage; if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = _value + _cds; } ```  `_shortage` and `_cds`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L140-L148  ```solidity if (_supply > 0 && _liquidity > 0) {     _mintAmount = (_amount * _supply) / _liquidity; } else if (_supply > 0 && _liquidity == 0) {     //when vault lose all underwritten asset =      _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again. } else {     //when _supply == 0,     _mintAmount = _amount; } ```  ### Recommendation  Change to:  ```solidity if (_supply == 0) {     _mintAmount = _amount; } else {     _mintAmount = _liquidity == 0 ? _amount * _supply : (_amount * _supply) / _liquidity; }  ```  - Removed 2 checks; - Removed 1 branch; - Simpler branch (costs less gas) goes first.  
# Handle  WatchPug   # Vulnerability details  The Wrapped Ether (WETH) ERC-20 contract has a gas optimization that does not update the allowance if it is the max uint.  The latest version of OpenZeppelin's ERC20 token contract also adopted this optimization.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152-L168  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     require(         currentAllowance >= amount,         "ERC20: transfer amount exceeds allowance"     );      _approve(sender, _msgSender(), currentAllowance - amount);      return true; } ```  See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162 -   https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085  ### Recommendation  Change to:  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     if (currentAllowance != type(uint256).max) {         require(             currentAllowance >= amount,             "ERC20: transfer amount exceeds allowance"         );          _approve(sender, _msgSender(), currentAllowance - amount);     }      return true; } ```  
# Handle  Jujic   # Vulnerability details  ## Impact ``` function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();         } else {             return 0;         }     } ```  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L512-L518  ## Tools Used Remix  ## Recommended Mitigation Steps Change to: ``` function rate() external view returns (uint256) {         if (totalSupply() != 0) {             return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();              }  ```  
# Handle  hyh   # Vulnerability details  ## Impact  System will fail on low-level subtraction without proper logic level error, which can be an issue for troubleshooting and further programmatic usages by other projects.   ## Proof of Concept  Whenever user lacks _attributions (Vault shares) for the withdraw amount requested, the system will fail on subtraction:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L160   ## Recommended Mitigation Steps  Consider adding a check for the enough _attributions throwing a corresponding error   
# Handle  loop   # Vulnerability details  When checking boolean values in a require or if statement it's an unnecessary operation to compare them to `true`, as it's already checked whether the condition is `true`. For comparison to `false`, it is cheaper to use the `!` operator rather than compare the value.  ## Proof of Concept Lines where boolean comparison is used: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L99 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L131 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L161 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L176 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L205 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L122 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L142 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L166-L169 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L178-L179 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L204 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L132 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L165 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L365 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L464 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L184 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L234 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L354 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L388 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L491 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L550 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L612 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L664  ## Recommended Mitigation Steps Remove the `== true` part from boolean comparisons and change `_variableName == false` to `!_variableName` to save some gas.  
# Handle  loop   # Vulnerability details  The function `unlock()` in PoolTemplate has a typo where it compares `insurances[_id].status` to `false` rather than setting it to `false`. If the conditions are met to unlock the funds for an id, the user should be able to call the `unlock()` function once for that id as `insurances[_id].amount` is subtracted from `lockedAmount`. However, since `insurances[_id].status` does not get set to `false`, a user can call `unlock()` multiple times for the same id, resulting in `lockedAmount` being way smaller than it should be since `insurances[_id].amount` is subtracted multiple times.   ## Impact `lockedAmount` is used to calculate the amount of underlying tokens available for withdrawals. If `lockedAmount` is lower than it should be users are able to withdraw more underlying tokens than available for withdrawals.  ## Proof of Concept Typo in `unlock()`: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L360-L362  Calculation of underlying tokens available for withdrawal: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L836  ## Recommended Mitigation Steps Change `insurances[_id].status == false;` to `insurances[_id].status = false;`  
# Handle  hyh   # Vulnerability details  ## Impact  Underlying and index tokens are mixed up in the worth() function description, making code and its description conflicting  ## Proof of Concept  Worth() computes how many iTokens correspond to given amount of underlying. The description says otherwise, mixing them up:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L794-798    ## Recommended Mitigation Steps  Fix the description to say that ‘_value' is the amount of underlying, while the '_amount' is the corresponding output quantity of iTokens   
# Handle  ospwner   # Vulnerability details  ## Impact Checking arrays' length before using it in a for loop is unnecessary when array's length is used in loop exit condition.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L175  ```         if (_references.length > 0) {             for (uint256 i = 0; i < _references.length; i++)  ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L185 ```         if (_conditions.length > 0) {             for (uint256 i = 0; i < _conditions.length; i++)  ```   ## Recommended Mitigation Steps  Remove the two unnecessary  if statements.   
# Handle  0x1f8b   # Vulnerability details  ## Impact Signature replay in `PoolTemplate`.  ## Proof of Concept The `redeem` method of `PoolTemplate` verifies the data stored in `incident`, and the verification logic of this process is performed as following:  ``` require(             MerkleProof.verify(                 _merkleProof,                 _targets,                 keccak256(                     abi.encodePacked(_insurance.target, _insurance.insured)                 )             ) ||                 MerkleProof.verify(                     _merkleProof,                     _targets,                     keccak256(abi.encodePacked(_insurance.target, address(0)))                 ),             "ERROR: INSURANCE_EXEMPTED"         ); ```  As can be seen, the only data related to the `_insurance` are` target` and `insured`, so as the incident has no relation with the` Insurance`, apparently nothing prevents a user to call `insure` with high amounts, after receive the incident, the only thing that prevents this from being reused is that the owner creates the incident with an `_incidentTimestamp` from the past.  So if a owner create a incident from the future it's possible to create a new `insure` that could be reused by the same affected address.  Another lack of input verification that could facilitate this attack is the `_span=0` in the `insure` method.  ## Tools Used Manual review.  ## Recommended Mitigation Steps It is mandatory to add a check in `applyCover` that` _incidentTimestamp` is less than the current date and the `span` argument is greater than 0 in the` insure` method.  
# Handle  Jujic   # Vulnerability details  ## Impact Checking if  `_amount != 0 ` before making the transfer call  can save gas by avoiding the external call in such situations.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L201-L206  ``` function borrowValue(uint256 _amount, address _to) external onlyMarket override {         debts[msg.sender] += _amount;         totalDebt += _amount;          IERC20(token).safeTransfer(_to, _amount);     }  ```  ## Tools Used Remix  ## Recommended Mitigation Steps Add additional check for non zero ` _amount`.  
# Handle  Jujic   # Vulnerability details  ## Impact Some of the variables can be cached to slightly reduce gas usage  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L343  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L406-L407  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L461-L479  ``` function withdrawRedundant(address _token, address _to)         external         override         onlyOwner     {         if (             _token == address(token) &&             balance < IERC20(token).balanceOf(address(this))         ) {             uint256 _redundant = IERC20(token).balanceOf(address(this)) -                 balance;             IERC20(token).safeTransfer(_to, _redundant);         } else if (IERC20(_token).balanceOf(address(this)) > 0) {             IERC20(_token).safeTransfer(                 _to,                 IERC20(_token).balanceOf(address(this))             );         }     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Consider caching those variable for read and make sure write back to storage Example: ``` bal =  IERC20(_token).balanceOf(address(this); ```  
# Handle  0xngndev   # Vulnerability details  ## Impact  Unclear Natspec may confuse the user.  In the `fund` function:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L160](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L160)  The Natspec is a copy-paste of the `deposit` function:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L130](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L130)  The problem here is the **receives ITokens** part of the Natspec. The deposit function indeed mints tokens to the `msg.sender` but the `fund` function doesn’t. I would clarify that the `fund` function adds attributions to the surplusPool.  Another minor and unclear bit of Natspec happens here: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L177](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L177)  It describes `_amount` as sender of value instead of something like **amount of value to send.**  ## Recommended Mitigation Steps  Explain the Natspec of the `fund` function in more detail. Fix the `transferValue` amount natspec. Also it would be good to add some Natspec to the `defund` function too.  
# Handle  0xngndev   # Vulnerability details  ## Impact  In `PoolTemplate.sol` there are multiple instances where variables are declared before the error checks of the functions. In cases where a function reverts due to these error checks, that extra computation of calculating the variable being declared can be avoided by simply moving the declaration after the error checks.  Here are all the functions I found where this can be applied:  - `withdraw` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L293](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L293) - `withdrawCredit` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L416](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L416) - `insure` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L465](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L465) - `reedem` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L548](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L548)  ## Recommended Mitigation Steps  - Change `withdraw` function to:  ```solidity function withdraw(uint256 _amount) external returns (uint256 _retVal) {   require(       marketStatus == MarketStatus.Trading,       "ERROR: WITHDRAWAL_PENDING"   );   require(       withdrawalReq[msg.sender].timestamp +           parameters.getLockup(msg.sender) <           block.timestamp,       "ERROR: WITHDRAWAL_QUEUE"   );   require(       withdrawalReq[msg.sender].timestamp +           parameters.getLockup(msg.sender) +           parameters.getWithdrawable(msg.sender) >           block.timestamp,       "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"   );   require(       withdrawalReq[msg.sender].amount >= _amount,       "ERROR: WITHDRAWAL_EXCEEDED_REQUEST"   );   require(_amount > 0, "ERROR: WITHDRAWAL_ZERO");   require(       _retVal <= availableBalance(),       "ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY"   );    uint256 _supply = totalSupply();   require(_supply != 0, "ERROR: NO_AVAILABLE_LIQUIDITY");    uint256 _liquidity = originalLiquidity();   _retVal = (_amount * _liquidity) / _supply;    //reduce requested amount   withdrawalReq[msg.sender].amount -= _amount;    //Burn iToken   _burn(msg.sender, _amount);    //Withdraw liquidity   vault.withdrawValue(_retVal, msg.sender);    emit Withdraw(msg.sender, _amount, _retVal); } ```  - Change `withdrawCredit` function to:  ```solidity function withdrawCredit(uint256 _credit)         external         override         returns (uint256 _pending)     {       IndexInfo storage _index = indicies[msg.sender];       require(           IRegistry(registry).isListed(msg.sender) &&               _index.credit >= _credit &&               _credit <= availableBalance(),           "ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS"       );        uint256 _rewardPerCredit = rewardPerCredit;        //calculate acrrued premium       _pending = _sub(           (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,           _index.rewardDebt       );        //Withdraw liquidity       if (_credit > 0) {           totalCredit -= _credit;           _index.credit -= _credit;           emit CreditDecrease(msg.sender, _credit);       }        //withdraw acrrued premium       if (_pending > 0) {           vault.transferAttribution(_pending, msg.sender);           attributionDebt -= _pending;           _index.rewardDebt =               (_index.credit * _rewardPerCredit) /               MAGIC_SCALE_1E6;       } } ```  - Change `insure` function to:  ```solidity function insure(         uint256 _amount,         uint256 _maxCost,         uint256 _span,         bytes32 _target     ) external returns (uint256) {       //Distribute premium and fee       uint256 _premium = getPremium(_amount, _span);        require(           _amount <= availableBalance(),           "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"       );       require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");       require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");       require(           parameters.getMinDate(msg.sender) <= _span,           "ERROR: INSURE_SPAN_BELOW_MIN"       );        require(           marketStatus == MarketStatus.Trading,           "ERROR: INSURE_MARKET_PENDING"       );       require(paused == false, "ERROR: INSURE_MARKET_PAUSED");        uint256 _endTime = _span + block.timestamp;       uint256 _fee = parameters.getFeeRate(msg.sender);        //current liquidity       uint256 _liquidity = totalLiquidity();       uint256 _totalCredit = totalCredit;        //accrue premium/fee       uint256[2] memory _newAttribution = vault.addValueBatch(           _premium,           msg.sender,           [address(this), parameters.getOwner()],           [MAGIC_SCALE_1E6 - _fee, _fee]       );        //Lock covered amount       uint256 _id = allInsuranceCount;       lockedAmount += _amount;       Insurance memory _insurance = Insurance(           _id,           block.timestamp,           _endTime,           _amount,           _target,           msg.sender,           true       );       insurances[_id] = _insurance;       allInsuranceCount += 1;        //Calculate liquidity for index       if (_totalCredit > 0) {           uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /               _liquidity;           attributionDebt += _attributionForIndex;           rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /               _totalCredit);       }        emit Insured(           _id,           _amount,           _target,           block.timestamp,           _endTime,           msg.sender,           _premium       );          return _id;   } ```  - Change `redeem` function to:  ```solidity function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {       require(           marketStatus == MarketStatus.Payingout,           "ERROR: NO_APPLICABLE_INCIDENT"       );       Insurance storage _insurance = insurances[_id];       require(_insurance.status == true, "ERROR: INSURANCE_NOT_ACTIVE");       require(_insurance.insured == msg.sender, "ERROR: NOT_YOUR_INSURANCE");       uint256 _incidentTimestamp = incident.incidentTimestamp;       require(           marketStatus == MarketStatus.Payingout &&               _insurance.startTime <= _incidentTimestamp &&               _insurance.endTime >= _incidentTimestamp,           "ERROR: INSURANCE_NOT_APPLICABLE"       );       bytes32 _targets = incident.merkleRoot;       require(           MerkleProof.verify(               _merkleProof,               _targets,               keccak256(                   abi.encodePacked(_insurance.target, _insurance.insured)               )           ) ||               MerkleProof.verify(                   _merkleProof,                   _targets,                   keccak256(abi.encodePacked(_insurance.target, address(0)))               ),           "ERROR: INSURANCE_EXEMPTED"       );       uint256 _payoutNumerator = incident.payoutNumerator;       uint256 _payoutDenominator = incident.payoutDenominator;        _insurance.status = false;       lockedAmount -= _insurance.amount;        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /           _payoutDenominator;        vault.borrowValue(_payoutAmount, msg.sender);        emit Redeemed(           _id,           msg.sender,           _insurance.target,           _insurance.amount,           _payoutAmount       );   } ```  
# Handle  Jujic   # Vulnerability details  ## Impact The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L105  ``` function transfer(address recipient, uint256 amount)         public         virtual         override         returns (bool)     {         _transfer(_msgSender(), recipient, amount);         return true;     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  
# Handle  cccz   # Vulnerability details  ## Impact  The fund function of the CDSTemplate contract does not match the description, the caller will not receive any iToken after sending tokens, and the owner can take away the tokens in surplusPool.  ```     /**      * @notice A liquidity provider supplies collatral to the pool and receives iTokens      * @param _amount amount of token to deposit      */     function fund(uint256 _amount) external {         require(paused == false, "ERROR: PAUSED");          //deposit and pay fees         uint256 _attribution = vault.addValue(             _amount,             msg.sender,             address(this)         );          surplusPool += _attribution;          emit Fund(msg.sender, _amount, _attribution);     }      function defund(uint256 _amount) external override onlyOwner {         require(paused == false, "ERROR: PAUSED");          uint256 _attribution = vault.withdrawValue(_amount, msg.sender);         surplusPool -= _attribution;          emit Defund(msg.sender, _amount, _attribution);     } ```  ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L156-L182  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Change the description of the fund function or send iToken to the caller  
# Handle  camden   # Vulnerability details  ## Impact The owner could potentially extend the insurance period indefinitely in the `applyCover` function without ever allowing the market to resume. This is because there is no check in `applyCover` to ensure that the market is in a `Trading` state.  This can also allow the owner to emit fraudulent `MarketStatusChanged` events.  ## Recommended Mitigation Steps Require that the market be in a `Trading` state to allow another `applyCover` call.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The Vault.sol contract contains several state variables of type address. There is no need to cast these variable to type address because they are already of type address. Removing the cast function can save gas.  ## Proof of Concept  The token address state variable is unnecessarily cast to address type in two places in Vault.sol: - [Line 350](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L350) - [Line 467](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L467)  ## Recommended Mitigation Steps  Remove the unnecessary address cast from address variables.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The Vault.sol contract has two address state variables, the `keeper` variable and the `controller` variable, which are both permitted to be the zero address. If both variables are zero simultaneously, any address can burn the available funds (available funds = balance - totalDebt) by sending these tokens to the zero address with the unprotected `utilitize()` function. If a user has no totalDebt, the user can lose their entire underlying token balance because of this.  ## Proof of Concept  The problematic `utilize()` function is [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L342-L352). To see how the two preconditions can occur: 1. The keeper state variable is only changed by the `setKeeper()` function [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502). If this function is not called, the keeper variable will retain the default value of address(0), which bypasses [the only access control for the utilize function](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L344). 2. There is a comment [here on line 69](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502) stating the controller state variable can be zero. There is no zero address check for the controller state variable in the Vault constructor.  If both address variables are left at their defaults of address(0), then the safeTransfer() call [on line 348](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L348) would send the tokens to address(0).  ## Recommended Mitigation Steps  Add the following line to the very beginning of the `utilize()` function: `require(address(controller) != address(0))`  This check is already found in many other functions in Vault.sol, including the `_unutilize()` function.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The comment for the return value of the `getCDS()` function in Registry.sol is incorrectly copied from elsewhere, possibly the `confirmExistence()` function. The return value is an address, not a boolean. This is considered low risk based on C4's [risk ratings](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  The problematic comment is from the `getCDS()` function [here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L99). It is an incorrect duplicate of the comment for the `confirmExistence()` function [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L113).  ## Recommended Mitigation Steps  Replace the comment with something like `@return CDS contract address`, which is used to describe this value in the `setCDS()` function.  
# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) { uint length = arr.length; for (uint i = 0; i < arr.length; i++) { sum += arr[i]; } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) { uint length = arr.length; for (uint i = 0; i < arr.length; i++) { sum += arr[i]; } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  ``` https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L176  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L186  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  
# Handle  p4st13r4   # Vulnerability details  ## Impact  Users that incorrectly ask for a withdrawal equal to zero, will waste more gas (a storage read) since the check for `amount > 0` is put after the check for the available amount  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L191](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L191) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L199](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L199) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L282](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L282)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Move this require at the top of the `requestWithdraw` function:  ```jsx require(_amount > 0, "ERROR: REQUEST_ZERO"); ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  `totalAllocPoint` in `set()` function is read several times from storage. It can be assigned to a local variable so the function is less expensive overall  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L612](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L612)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `totalAllocPoint` to `localTotalAllocPoint` (or `cachedTotalAllocPoint`)  
# Handle  p4st13r4   # Vulnerability details  ## Impact  When emitting the event, the function argument could be used, instead of reading from storage again  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Ownership.sol#L62](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Ownership.sol#L62)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Change to:  ```jsx emit CommitNewOwnership(newOwner); ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  Many functions that read params, check whether the value is set for the given `target`, otherwise return the value for the zero-address. When doing this kind of check, the value of the `target` is read twice:  - once for checking if it’s set - if it’s set, it’s read once more to read the actual params  These functions are used a lot of times inside all the contracts, so having them optimized as much as possible is required in order to save gas  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L240](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L240) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L271](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L271) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L289](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L289) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L313](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L313) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L331](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L331) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L343](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L343) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L379](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L379) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L397](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L397)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign the target value and, if the check returns a value different from the zero-address, use it. For example, `getFeeRate` becomes:  ```jsx function getFeeRate(address _target)     external     view     override     returns (uint256) {     uint256 _targetFee = _fee[_target];     if (_targetFee == 0) {         return _fee[address(0)];     } else {         return _targetFee;     } } ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  The public `deposit` uses basically the same code of the internal `_depositFrom`. The only difference between them is that the former uses `msg.sender`, while the latter uses a parameter as `from` address. In order to minimize code duplication, `deposit` should be calling `_depositFrom` rather than being reimplemented using copy-paste  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L232](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L232)  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L255](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L255)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Write `deposit` like this:  ```jsx function deposit(uint256 _amount) public returns (uint256 _mintAmount) {     _depositFrom(_amount, msg.sender); } ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  The `setKeeper()` function is operated only by the owner, and should emit an event when the keeper is set for the first time and/or changes  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L502](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L502)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add `emit KeeperChanged(address)` after changing the keeper  
# Handle  p4st13r4   # Vulnerability details  ## Impact  The amount of the withdrawal request is not correctly updated after a withdrawal in `CDSTemplate.sol`. This happens because the withdrawal request is read from storage and put in memory, like this:  ```jsx Withdrawal memory request = withdrawalReq[msg.sender]; ```  However, the requested amount is not updated properly since the `withdrawalReq` in the storage is never updated. Instead, its in-memory version is updated, but it’s useless because that object is never used again:  ```jsx //reduce requested amount request.amount -= _amount; ```  This issue is non critical because there is a function that takes care of updating the withdrawal requests’ amount on every token transfer: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L358](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L358)  The issue lies in the fact that the code seems to behave differently from how it looks at a first glance. Furthermore, the other two templates correctly update the value of the withdrawal request, so the version in `CDSTemplate.sol` should be aligned as well:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L239](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L239) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L327](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L327)  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L230](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L230)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Update the `amount` of the current withdrawal request as well  
# Handle  p4st13r4   # Vulnerability details  ## Impact  The `resume` function can be called by any user, at any time, even when the Index contract is not locked. There should be a check preventing it from being called unless the contract is `locked`  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L459](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L459)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add a require on top:  ```jsx require(locked); ```  
# Handle  p4st13r4   # Vulnerability details  ## Impact  `PoolTemplate.sol` and `IndexTemplate.sol` report this same error when trying to withdraw and some conditions are not met: "ERROR: WITHDRAWAL_PENDING”  However, `PoolTemplate.sol` does that when the `marketStatus` is not `Trading`; `IndexTemplate.sol` when the contract is locked. Since `CDSTemplate.sol`, instead, implement a different revert string, it’s best for understanding what revert strings are related to by making them as explicit and clear as possible. `CDSTemplate.sol` has this in the `withdraw` function:  ```jsx require(paused == false, "ERROR: PAUSED"); ```  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217)  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L302](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L302)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Improve revert strings wording  
# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L685 the function emitted a `MarketStatusChanged` event with storage variable which is `marketStatus`. when we emit an event using storage data is more expensive than emitted an event using `MarketStatus.Payingout` value.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L685 ``` contract emitstatust {      enum MarketStatus {         Trading,         Payingout     }     MarketStatus public marketStatus;      event MarketStatusChanged(MarketStatus statusValue);      function amit() public {          marketStatus = MarketStatus.Payingout;      emit MarketStatusChanged(marketStatus);      } } //44792 gas ```  can change to :  ``` contract emitstatust {      enum MarketStatus {         Trading,         Payingout     }     MarketStatus public marketStatus;      event MarketStatusChanged(MarketStatus statusValue);      function amit() public {          marketStatus = MarketStatus.Payingout;      emit MarketStatusChanged(MarketStatus.Payingout);      } } //44659 gas ```  ## Tools Used remix   
# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L508 instead of save `Insurance` value to memory then save to `insurences` storage it's better to save the `Insurence` value directly to `insurences`  storage or mapping to save gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L508 ``` contract insur {      struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     }       mapping(uint256 => Insurance) public insurances;      function coba() public {          uint256 _id = 10;         uint256 _endTime = 10;         uint256 _amount = 12;         bytes32 _target = bytes32(uint256(10));           Insurance memory _insurance = Insurance(             _id,             block.timestamp,             _endTime,             _amount,             _target,             msg.sender,             true         );         insurances[_id] = _insurance;      } } //154623 gas ```  change to : ``` contract insur {      struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     }       mapping(uint256 => Insurance) public insurances;      function coba() public {          uint256 _id = 10;         uint256 _endTime = 10;         uint256 _amount = 12;         bytes32 _target = bytes32(uint256(10));           insurances[_id] = Insurance(             _id,             block.timestamp,             _endTime,             _amount,             _target,             msg.sender,             true         );               } } //154610 gas  ```  ## Tools Used remix  
# Handle  Tomio   # Vulnerability details  ## Impact by saving `totalLiquidity()` to memory can save more gas instead of doing double function call  ## Proof of Concept Before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L829 // gas cost 23862  After: ``` function totalLiquidity() public view returns (uint256){      return 10;  }     function availableBalance()public view returns (uint256 _balance)     {         uint256 saveTotalLiquidity = totalLiquidity();         if (saveTotalLiquidity > 0) {             return saveTotalLiquidity - lockedAmount;         } else {             return 0;         }     } ``` // gas cost 23840  ## Tools Used Remix  
# Handle  0x1f8b   # Vulnerability details  ## Impact Wrong deployment.  ## Proof of Concept The factory contract haven't got any check of `_registry` and `_ownership` and both values must be defined or the logic inside the contract will fault.  ## Tools Used Manual review.  ## Recommended Mitigation Steps It's mandatory to check that the address are not zero or the contract could be wrong deployed.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept There are multiple methods in `Registry` that check a value inside the storage and if it's not defined, use the default one. It's better to cache the value in order to save gas if it was defined avoiding double reading.  For example, instead of the following code: ```     function getCDS(address _address) external view override returns (address) {         if (cds[_address] == address(0)) {             return cds[address(0)];         } else {             return cds[_address];         }     } ``` use ```     function getCDS(address _address) external view override returns (address) {         address val =cds[_address];         if ( val== address(0)) {             return cds[address(0)];         } else {             return val;         }     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Cache the value.  
# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260 have two check inside the require which is `marketStatus == MarketStatus.Trading` and `paused == false` and by spliting this check we can save gas.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260  ``` function woi() public {          require(             marketStatus == MarketStatus.Trading && paused == false,             "ERROR: DEPOSIT_DISABLED"         );      } // 23645 gas ```   can be change to   ``` function woi() public{           require(             marketStatus == MarketStatus.Trading, "ERROR: DEPOSIT_DISABLED"         );         require(               paused == false, "ERROR: DEPOSIT_DISABLED"         );      } //23637 gas ```     
# Handle  Tomio   # Vulnerability details  ## Impact by changing the code from `if (_credit == 0) {` to `if (_credit != 0) {` and remove the else we can save gas when contract is deploy and we can save gas when `_credit` is equal to 0. because if `_credit` equal to 0 the original function will return 0 which a default value for uint256  ## Proof of Concept Before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L776 // gas 24307  After: ``` function pendingPremium(address _index)         external         view         returns (uint256)     {         uint256 _credit = indicies[_index].credit;        if (_credit != 0) {             return                 _sub(                     (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,                     indicies[_index].rewardDebt                 );         }     } ``` // gas 24286   ## Tools Used Remix  ## Recommended Mitigation Steps  
# Handle  defsec   # Vulnerability details  ## Impact  the owner parameter are used for the onlyOwner modifier. In the state variable , proper check up should be done , other wise error in these state variable can lead to redeployment of contract. If the zero address is assigned to rebalanceManager parameter, that will fail all Owner functions.  ## Proof of Concept  1. Navigate to the following contract functions.  "https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L31"  2. Adding zero address into the owner leads to failure of onlyOwner only functions.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add proper zero address validation.  
# Handle  Tomio   # Vulnerability details  ## Impact by using 'unchecked' you can save  +-182 gas  ## Proof of Concept before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L938 //22378 before  after: ``` function _sub(uint256 a, uint256 b) public pure returns (uint256) {         if (a < b) {             return 0;         } else {             unchecked {return a - b;}         }     }   ``` //22196 after   ## Tools Used Remix  ## Recommended Mitigation Steps used 'unchecked' in function _sub  
# Handle  camden   # Vulnerability details  ## Impact The `utilize()` function can be called while the controller is the zero address. This will fail. A comment in the constructor says that the controller shouldn't be the zero address.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L350  ## Recommended Mitigation Steps `utilize` should have a check to see if the controller is not the zero address (like `_unutilize`) and give an appropriate error message.  
# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept The `for` loop at [L109-113](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L109-L113) can be unrolled to remove the overhead of the loop itself, and avoid using an initialized-to-zero uint128 variable.  ## Tools Used Manual review  ## Recommended Mitigation Steps Replace L109-113 with: ``` uint256 _allocation = (_shares[0] * _attributions) / MAGIC_SCALE_1E6; attributions[_beneficiaries[0]] += _allocation; _allocations[0] = _allocation;  _allocation = (_shares[1] * _attributions) / MAGIC_SCALE_1E6; attributions[_beneficiaries[1]] += _allocation; _allocations[1] = _allocation; ```  
# Handle  0xngndev   # Vulnerability details  ## Impact  Error Messages that have a length of 32 or more one require one additional slot to be stored, causing extra gas costs when deploying the contract and when the function is executed and it reverts.  ## Proof of Concept  I put together a quick proof to show the different impact of the errors we can have in Solidity:  - Long require errors => more than 32 bytes - Short require errors => less than 32 bytes - Custom errors  Here are the contract size findings:  ```rust //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  contract Errors {   bool public thisIsFalse;   error WithdrawalExceeded();    /*     Contract Size with just this function: 333 bytes;   */   function moreThan32Bytes() public {     require(thisIsFalse, "ERROR: WITHDRAWAL_EXCEEDED_REQUEST");   }    /*     Contract Size with just this function: 295 bytes; //   */   function lessThan32Bytes() public {     require(thisIsFalse, "WITHDRAWAL_EXCEEDED_REQUEST");   }    /*     Contract Size with just this function: 242 bytes;   */   function customError() public {     if (!thisIsFalse) revert WithdrawalExceeded();   } } ```  I then run tests to see the gas costs of having the functions revert, and although these are not very accurate due to the fact that it’s hard to isolate the gas costs of a reverting function due to the order of execution (I can’t have an event that logs the gas before the function revert and another one after because the one after the revert will never be reached), it still shows some differences.  ```rust //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import "ds-test/test.sol"; import "../Errors.sol";  contract ErrorsTest is DSTest {   Errors errors;    function setUp() public {     errors = new Errors();   }    function testFailLessThan32Bytes() public logs_gas {     errors.lessThan32Bytes();   }    function testFailMoreThan32Bytes() public logs_gas {     errors.moreThan32Bytes();   }    function testFailCustomError() public logs_gas {     errors.customError();   } } ```  ```rust Running 3 tests for "ErrorsTest.json":ErrorsTest [PASS] testFailCustomError() (gas: 3161) [PASS] testFailLessThan32Bytes() (gas: 3314) [PASS] testFailMoreThan32Bytes() (gas: 3401) ```  ## Tools Used  DappTools/Foundry  ## Recommended Mitigation Steps  Personally, I would switch to custom errors and reverts to maximize the savings, but if you dislike revert syntax, then I would suggest to check which of your require errors have a length longer than 32, and shorten them so that their length is less than 32.  Here are some examples of the errors you could shorten in your `CDSTemplate.sol` contract:  - `ERROR: INITIALIZATION_BAD_CONDITIONS` - `ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST` - `ERROR: WITHDRAWAL_EXCEEDED_REQUEST`  Removing the “ERROR” keyword should be enough for most of these. Bear in mind you can always have concise error messages and a section in your documentation that explains them further or have your natspec expand on them if you find them too cryptic.   An example of how to apply a custom error in the first error would be to just have the error `say BadConditions()`. The user knows it’s an error because the function call failed, and the user knows it has happened in the initialize function because he called it, so `BadConditions()` should be a clear message despite being concise  
# Handle  Dravee   # Vulnerability details  In `IndexTemplate.sol:withdrawable()`, the following can be optimized to save gas and avoid a loss of precision, from: ```                 uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;                 _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev; ``` to ```                 uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint *  MAGIC_SCALE_1E6 /  (_targetAllocPoint * targetLev); ```  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `IndexTemplate.sol:_adjustAlloc()`, the 3 following conditions are always evaluated: ```                 //Withdraw or Deposit credit                 if (_current > _target && _available != 0) {                     //if allocated credit is higher than the target, try to decrease                     uint256 _decrease = _current - _target;                     IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);                     totalAllocatedCredit -= _decrease;                 }                 if (_current < _target) {                     uint256 _allocate = _target - _current;                     IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);                     totalAllocatedCredit += _allocate;                 }                 if (_current == _target) {                     IPoolTemplate(_poolList[i].addr).allocateCredit(0);                 } ``` The code can be optimized to save some gas: ```                 if (_current == _target) {                     IPoolTemplate(_poolList[i].addr).allocateCredit(0);                 } else if (_current < _target) {                     uint256 _allocate = _target - _current;                     IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);                     totalAllocatedCredit += _allocate;                 } else if (_current > _target && _available != 0) {                     //Withdraw or Deposit credit                     //if allocated credit is higher than the target, try to decrease                     uint256 _decrease = _current - _target;                     IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);                     totalAllocatedCredit -= _decrease;                 } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  
# Handle  Dravee   # Vulnerability details  ## Impact > The operators “||” and “&&” apply the common short-circuiting rules. This means that in the expression “f(x) || g(y)”, if “f(x)” evaluates to true, “g(y)” will not be evaluated even if it may have side-effects.  Source: https://docs.soliditylang.org/en/v0.5.4/types.html#booleans  ## Proof of Concept In `IndexTemplate.sol:withdrawable()`, there's an if-statement as such: ``` 293:                         if (i == 0 || _availableRate < _lowestAvailableRate) { ``` Here, the condition `i == 0` is always evaluated and is always equal to `false` when `i > 0`, meaning here a total of `poolList.length - 1` evaluations are always evaluated to `false`.  It's best to reorder the conditions such as this condition doesn't get evaluated if `_availableRate < _lowestAvailableRate` is satisfied: ``` 293:                         if (_availableRate < _lowestAvailableRate || i == 0 ) { ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `Factory.sol`, the following `> 0` checks are redundant with the for-loop condition, because if `_references.length == 0` or `_conditions.length == 0`, the condition `uint256 i = 0; i <(_conditions)|(_references).length` will never be satisfied and the for-loop won't iterate: ``` 175:         if (_references.length > 0) { 176:             for (uint256 i = 0; i < _references.length; i++) { 177:                 require( 178:                     reflist[address(_template)][i][_references[i]] == true || 179:                         reflist[address(_template)][i][address(0)] == true, 180:                     "ERROR: UNAUTHORIZED_REFERENCE" 181:                 ); 182:             } 183:         } 184:  185:         if (_conditions.length > 0) { 186:             for (uint256 i = 0; i < _conditions.length; i++) { 187:                 if (conditionlist[address(_template)][i] > 0) { 188:                     _conditions[i] = conditionlist[address(_template)][i]; 189:                 } 190:             } 191:         }  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove these 2 if-statements  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept The variable `T_0` can go through 2 assignments in a row: Here: ``` 75:         uint256 T_0 = _totalLiquidity; 76:         if (T_0 > T_1) { 77:             T_0 = T_1; 78:         } ``` And here: ``` 134:         uint256 T_0 = _totalLiquidity; 135:         if (T_0 > T_1) { 136:             T_0 = T_1; 137:         } ```  The code can be optimized as such to save some gas: ```         uint256 T_0 = _totalLiquidity > T_1 ? _totalLiquidity : T_1; ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto   
# Handle  Dravee   # Vulnerability details  ## Impact Duplicated code, loss of maintainability, increased contract size which leads to increased gas cost  ## Proof of Concept The following can be simplified: ``` 260:         if (_available >= _amount) { 261:             _compensated = _amount; 262:             _attributionLoss = vault.transferValue(_amount, msg.sender); 263:             emit Compensated(msg.sender, _amount); 264:         } else { 265:             //when CDS cannot afford, pay as much as possible 266:             _compensated = _available; 267:             _attributionLoss = vault.transferValue(_available, msg.sender); 268:             emit Compensated(msg.sender, _available); 269:         } ``` to ``` 260:         _compensated = _available >= _amount ? _amount : _available; //when CDS cannot afford, pay as much as possible 261:         _attributionLoss = vault.transferValue(_compensated, msg.sender); 262:         emit Compensated(msg.sender, _compensated); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto and look out for duplicated code  
# Handle  Dravee   # Vulnerability details  ## Impact When a contract imports and implements an interface or another contracts, it doesn't need to import the libraries that were already imported there.  Removing these imports will save gas.  ## Proof of Concept `InsureDAOERC20` imports the following:  ``` 5: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 6: import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"; ```  The following contracts inherit `InsureDAOERC20` and also make those imports: `CDSTemplate`, `IndexTemplate`, `PoolTemplate`  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove the unused imports to reduce the size of the contract and save some deployment gas.  
# Handle  egjlmn1   # Vulnerability details  in all of your for loops, you increase your loop variable using `i++` it has 2 problems: 1. postfix increment is more wasteful than prefix increment (`++i` instead of `i++`) 2. there is no risk for overflow, so you can use `unchecked{}`  ## Impact prefix arithmetic is a bit cheaper than postfix arithmetic, but if you do it in a for loop, this small amount of gas can pile up and be a big waste. also, in solidity 0.8.0+, every arithmetic operation is checked for overflow and underflow, which adds a lot of gas to a single operation. Since in your for loop you don't have the risk for overflow, you can surround the operation in `unchecked{}` to save a lot of gas (which will save a huge amount since it saves a lot in a single loop iteration.)  ## Proof of Concept Checked on remix  ## Tools Used manual code review  ## Recommended Mitigation Steps change every `i++` in your for loops to `unchecked{++i}`  
# Handle  Dravee   # Vulnerability details  ## Impact The compiler won't reserve a storage slot for `immutable` variables  ## Proof of Concept The following variables are initialized in the contract's constructor and can't get updated after: ``` Factory.sol:registry Factory.sol:ownership Parameters:ownership BondingPremium:ownership Registry:ownership Vault:ownership ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Make these variables `immutable`  
# Handle  Dravee   # Vulnerability details  ## Impact Repetitive and expensive SSTORE opcode operations inside loops  ## Proof of Concept ```  totalAllocatedCredit -= _available (contracts/IndexTemplate.sol#368)  totalAllocatedCredit -= _decrease (contracts/IndexTemplate.sol#395)  totalAllocatedCredit += _allocate (contracts/IndexTemplate.sol#401) ```  ## Tools Used Slither  ## Recommended Mitigation Steps Create a memory variable which will be used to compute a `_totalAllocatedCredit` that will get added to `totalAllocatedCredit` storage variable outside the loop. As an idea, you could create 1 such `int` variable and use it's value after the for-loop, or you could create 2 uint variables where 1 would store the _totalDecrease and 1 would store the _totalAllocate, and respectively substract and add them.   
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 slot)  ## Proof of Concept IndexTemplate.pendingEnd (contracts/IndexTemplate.sol#62) should be deleted as it's never used by the contract  ## Tools Used Slither  ## Recommended Mitigation Steps Delete the variable `IndexTemplate.pendingEnd`  
# Handle  Dravee   # Vulnerability details  ## Impact  Increased gas cost.   ## Proof of Concept  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers.  When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block.  https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  These lines are the obvious ones that can't underflow or overflow (operations on constants or checks already made before the operations with `require` statements or `if` statements): ```  PremiumModels\BondingPremium.sol:47:        T_1 = 1000000 * DECIMAL; PremiumModels\BondingPremium.sol:130:        uint256 u1 = BASE - ((_lockedAmount * BASE) / _totalLiquidity); //util rate before. 1000000 = 100.000% PremiumModels\BondingPremium.sol:132:            (((_lockedAmount + _amount) * BASE) / _totalLiquidity); //util rate after. 1000000 = 100.000% IndexTemplate.sol:292:                        uint256 _lockedCredit = _allocated - _availableBalance; PoolTemplate.sol:942:            return a - b; IndexTemplate.sol:308:                    _retVal = _totalLiquidity - _necessaryAmount; IndexTemplate.sol:393:                    uint256 _decrease = _current - _target; IndexTemplate.sol:399:                    uint256 _allocate = _target - _current; IndexTemplate.sol:441:                _shortage = _amount - _value; InsureDAOERC20.sol:255:        _balances[sender] = senderBalance - amount; InsureDAOERC20.sol:303:        _balances[account] = accountBalance - amount; Vault.sol:165:            uint256 _shortage = _amount - available(); Vault.sol:310:            uint256 _shortage = _retVal - available(); ```   ## Tools Used  VS Code   ## Recommended Mitigation Steps Uncheck arithmetic operations when the risk of underflow or overflow is already contained.  
# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ```   Vault.sol:92:        address[2] memory _beneficiaries, Vault.sol:93:        uint256[2] memory _shares ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.   
# Handle  Dravee   # Vulnerability details  ## Impact   Using both named returns and a return statement isn't necessary. Removing unused named return variables can reduce gas usage and improve code clarity. To save gas and improve code quality: consider using only one of those.      ## Proof of Concept   Instances include:   ``` CDSTemplate.sol:287:    function totalLiquidity() public view returns (uint256 _balance) { IndexTemplate.sol:491:    function leverage() public view returns (uint256 _rate) { IndexTemplate.sol:504:    function totalLiquidity() public view returns (uint256 _balance) { PoolTemplate.sol:628:        returns (uint256 premium) PoolTemplate.sol:833:        returns (uint256 _balance) PoolTemplate.sol:846:    function utilizationRate() public view override returns (uint256 _rate) { PoolTemplate.sol:858:    function totalLiquidity() public view override returns (uint256 _balance) { PoolTemplate.sol:866:    function originalLiquidity() public view returns (uint256 _balance) { ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Remove the unused named returns   
# Handle  Dravee   # Vulnerability details  ## Impact   Due to how the EVM natively works on 256 bit numbers, using a 8 bit number in for-loops introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage : > When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. > It is only beneficial to use reduced-size arguments if you are dealing with storage values because the compiler will pack multiple elements into one storage slot, and thus, combine multiple reads or writes into a single operation. When dealing with function arguments or memory values, there is no inherent benefit because the compiler does not pack these values.    ## Proof of Concept   ``` Vault.sol:109:        for (uint128 i = 0; i < 2; i++) { ```  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `uint256` as a counter in for-loops.   
# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept The `withdrawalReq[msg.sender].timestamp` and `parameters.getLockup(msg.sender)` values are used twice in the `require` statements, and both times summed.   ## Tools Used Manual review  ## Recommended Mitigation Steps Cache the sum value in a new variable. I've sent a similar report for IndexTemplate.withdraw() with a similar issue.  
# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept In [L197](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L197) of IndexTemplate, a `_balance` variable is created and initialized to the balance of `msg.sender`. However that variable is used only once in the function.  ## Tools Used Manual review  ## Recommended Mitigation Steps Replace L198 with `require(balanceOf(msg.sender) >= _amount, "ERROR: REQUEST_EXCEED_BALANCE");` and remove L197  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs  ## Proof of Concept  Solidity 0.8.10 has a useful change which reduced gas costs of external calls which expect a return value: https://blog.soliditylang.org/2021/11/09/solidity-0.8.10-release-announcement/  > Code Generator: Skip existence check for external contract if return data is expected. In this case, the ABI decoder will revert if the contract does not exist  InsureDAO is using 0.8.7:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L8  Updating to the newer version of solc will allow InsureDAO to take advantage of these lower costs for external calls.  ## Recommended Mitigation Steps  Update to solc 0.8.10 or above  
# Handle  cccz   # Vulnerability details  ## Impact When setting parameters in the Parameters contract, the input parameters are not verified.  For example, in the setFeeRate function, the _target parameter is not limited. When _target is greater than 1e6, DOS will occur when used in the insure function of the PoolTemplate contract ```     function setFeeRate(address _address, uint256 _target)         external         override         onlyOwner     {         _fee[_address] = _target;         emit FeeRateSet(_address, _target);     }    ...    function insure(         uint256 _amount,         uint256 _maxCost,         uint256 _span,         bytes32 _target     ) external returns (uint256) {         //Distribute premium and fee         uint256 _endTime = _span + block.timestamp;         uint256 _premium = getPremium(_amount, _span);         uint256 _fee = parameters.getFeeRate(msg.sender);          require(             _amount <= availableBalance(),             "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"         );         require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");         require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");         require(             parameters.getMinDate(msg.sender) <= _span,             "ERROR: INSURE_SPAN_BELOW_MIN"         );          require(             marketStatus == MarketStatus.Trading,             "ERROR: INSURE_MARKET_PENDING"         );         require(paused == false, "ERROR: INSURE_MARKET_PAUSED");          //current liquidity         uint256 _liquidity = totalLiquidity();         uint256 _totalCredit = totalCredit;          //accrue premium/fee         uint256[2] memory _newAttribution = vault.addValueBatch(             _premium,             msg.sender,             [address(this), parameters.getOwner()],             [MAGIC_SCALE_1E6-_fee, _fee]         ); ``` ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol  ## Tools Used  Manual analysis   ## Recommended Mitigation Steps  When setting parameters in the Parameters contract, verify the input parameters  
# Handle  Dravee   # Vulnerability details  ## Impact   Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.      ## Proof of Concept   ```   Factory.sol:176:            for (uint256 i = 0; i < _references.length; i++) { Factory.sol:186:            for (uint256 i = 0; i < _conditions.length; i++) { IndexTemplate.sol:655:        for (uint256 i = 0; i < poolList.length; i++) { PoolTemplate.sol:343:        for (uint256 i = 0; i < _ids.length; i++) { PoolTemplate.sol:671:        for (uint256 i = 0; i < indexList.length; i++) { PoolTemplate.sol:703:        for (uint256 i = 0; i < indexList.length; i++) { ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Store the array's length in a variable before the for-loop, and use it instead.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  Here if the lengths of these arrays are zero we'll fall straight through the for loops so there's no need for the if statements.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L175-L191  ## Recommended Mitigation Steps  Remove if statements  
# Handle  Dravee   # Vulnerability details  ## Impact   If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    ## Proof of Concept   Instances include:   ```   Factory.sol:176:            for (uint256 i = 0; i < _references.length; i++) { Factory.sol:186:            for (uint256 i = 0; i < _conditions.length; i++) { IndexTemplate.sol:280:            for (uint256 i = 0; i < _length; i++) { IndexTemplate.sol:348:        for (uint256 i = 0; i < _length; i++) { IndexTemplate.sol:381:        for (uint256 i = 0; i < _length; i++) { IndexTemplate.sol:462:        for (uint256 i = 0; i < _poolLength; i++) { IndexTemplate.sol:655:        for (uint256 i = 0; i < poolList.length; i++) { PoolTemplate.sol:343:        for (uint256 i = 0; i < _ids.length; i++) { PoolTemplate.sol:671:        for (uint256 i = 0; i < indexList.length; i++) { PoolTemplate.sol:703:        for (uint256 i = 0; i < indexList.length; i++) { Vault.sol:109:        for (uint128 i = 0; i < 2; i++) { ```      ## Tools Used   Manual Analysis      ## Recommended Mitigation Steps   Remove explicit initialization for default values.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  Here we push a new market onto an array in the factory whilst we just added the market to the registry.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L214-L216  ## Recommended Mitigation Steps  This array on the factory seems redundant and so it can be removed.  
# Handle  Dravee   # Vulnerability details  ## Impact   Increased gas cost      ## Proof of Concept   Solidity version 0.8.* already implements overflow and underflow checks by default.  Using the SafeMath library from OpenZeppelin (which is more gas expensive than the 0.8.* overflow checks) is therefore redundant.      Instances include:  ```   mocks\ERC20.sol:4:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; mocks\ERC20.sol:30:    using SafeMath for uint256; mocks\TestPremiumModel.sol:3:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; mocks\TestPremiumModel.sol:7:    using SafeMath for uint256; PremiumModels\BondingPremium.sol:10:import "@openzeppelin/contracts/utils/math/SafeMath.sol"; ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the built-in checks instead of SafeMath and remove SafeMath from the dependencies   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  It seems that we always want to get a pool's `allocatedCredit` and `availableBalance` together, suggesting that these values are tightly coupled.   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L284-L287  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L356-L360  If we're regularly going to be requesting these values together it may be worth considering having a single function in the pool template which returns both of these values. This would save gas costs of performing an extra external call to the pool contract.  ## Recommended Mitigation Steps  Consider having a function which returns both of these values to avoid repeated calls into the same contract for related info.  
# Handle  Dravee   # Vulnerability details  ## Impact   `!= 0` costs less gas compared to `> 0` for unsigned integer      ## Proof of Concept   `> 0` is used in the following location(s): ```   CDSTemplate.sol:100:                bytes(_metaData).length > 0 && CDSTemplate.sol:132:        require(_amount > 0, "ERROR: DEPOSIT_ZERO"); CDSTemplate.sol:140:        if (_supply > 0 && _liquidity > 0) { CDSTemplate.sol:142:        } else if (_supply > 0 && _liquidity == 0) { CDSTemplate.sol:191:        require(_amount > 0, "ERROR: REQUEST_ZERO"); CDSTemplate.sol:223:        require(_amount > 0, "ERROR: WITHDRAWAL_ZERO"); CDSTemplate.sol:296:        if (totalSupply() > 0) { Factory.sol:175:        if (_references.length > 0) { Factory.sol:185:        if (_conditions.length > 0) { Factory.sol:187:                if (conditionlist[address(_template)][i] > 0) { IndexTemplate.sol:133:                bytes(_metaData).length > 0 && IndexTemplate.sol:166:        require(_amount > 0, "ERROR: DEPOSIT_ZERO"); IndexTemplate.sol:172:        if (_supply > 0 && _totalLiquidity > 0) { IndexTemplate.sol:174:        } else if (_supply > 0 && _totalLiquidity == 0) { IndexTemplate.sol:199:        require(_amount > 0, "ERROR: REQUEST_ZERO"); IndexTemplate.sol:231:        require(_amount > 0, "ERROR: WITHDRAWAL_ZERO"); IndexTemplate.sol:246:        if (_liquidityAfter > 0) { IndexTemplate.sol:274:        if(_totalLiquidity > 0){ IndexTemplate.sol:283:                if (_allocPoint > 0) { IndexTemplate.sol:391:                if (_current > _target && _available != 0) { IndexTemplate.sol:427:            allocPoints[msg.sender] > 0, IndexTemplate.sol:477:        require(allocPoints[msg.sender] > 0); IndexTemplate.sol:493:        if (totalLiquidity() > 0) { IndexTemplate.sol:513:        if (totalSupply() > 0) { IndexTemplate.sol:612:        if (totalAllocPoint > 0) { IndexTemplate.sol:656:            if (allocPoints[poolList[i]] > 0) { InsureDAOERC20.sol:302:        require(accountBalance >= amount, "ERC20: burn amount exceeds balance"); Parameters.sol:31:    mapping(address => uint256) private _fee; //fee rate in 1e6 (100% = 1e6) PoolTemplate.sol:185:                bytes(_metaData).length > 0 && PoolTemplate.sol:218:        if (_conditions[1] > 0) { PoolTemplate.sol:237:        require(_amount > 0, "ERROR: DEPOSIT_ZERO"); PoolTemplate.sol:263:        require(_amount > 0, "ERROR: DEPOSIT_ZERO"); PoolTemplate.sol:282:        require(_amount > 0, "ERROR: REQUEST_ZERO"); PoolTemplate.sol:321:        require(_amount > 0, "ERROR: WITHDRAWAL_ZERO"); PoolTemplate.sol:391:        } else if (_index.credit > 0) { PoolTemplate.sol:396:            if (_pending > 0) { PoolTemplate.sol:401:        if (_credit > 0) { PoolTemplate.sol:437:        if (_credit > 0) { PoolTemplate.sol:444:        if (_pending > 0) { PoolTemplate.sol:521:        if (_totalCredit > 0) { PoolTemplate.sol:672:            if (indicies[indexList[i]].credit > 0) { PoolTemplate.sol:706:            if (_credit > 0) { PoolTemplate.sol:726:        if (_deductionFromPool > 0) { PoolTemplate.sol:745:        if (totalSupply() > 0) { PoolTemplate.sol:802:        if (_supply > 0 && _originalLiquidity > 0) { PoolTemplate.sol:804:        } else if (_supply > 0 && _originalLiquidity == 0) { PoolTemplate.sol:835:        if (totalLiquidity() > 0) { PoolTemplate.sol:847:        if (lockedAmount > 0) { PoolTemplate.sol:929:        require(b > 0); Vault.sol:154:            attributions[msg.sender] > 0 && Vault.sol:187:            attributions[msg.sender] > 0 && Vault.sol:220:            attributions[msg.sender] > 0 && Vault.sol:347:        if (_amount > 0) { Vault.sol:388:        if (totalAttributions > 0 && _attribution > 0) { Vault.sol:406:        if (attributions[_target] > 0) { Vault.sol:473:        } else if (IERC20(_token).balanceOf(address(this)) > 0) { ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Change `> 0` with `!= 0`.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  gas costs  ## Proof of Concept  Here on L563 we check the market status however we have already done this on L558  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L557-L567  ## Recommended Mitigation Steps  Remove redundant check (check other market templates as well)  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  When transferring any of the market tokens, a check is performed to see if they have a pending withdrawal and reduce it if their balance falls below the requested amount.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L910-L923  In the case where a user has no pending withdrawal we then perform an unnecessary check on their balance. We could save an SLOAD by changing it to the below  ``` if (from != address(0)) {     uint256 reqAmount = withdrawalReq[from].amount     if (reqAmount > 0){         uint256 _after = balanceOf(from) - amount;         if (_after < reqAmount) {             withdrawalReq[from].amount = _after;         }     }  } ```  ## Recommended Mitigation Steps  As above  
# Handle  Dravee   # Vulnerability details  ## Impact   Reducing from public to private will save gas    ## Proof of Concept   ```   PremiumModels\BondingPremium.sol:26:    //constants PremiumModels\BondingPremium.sol:27:    uint256 public constant DECIMAL = uint256(1e6); //Decimals of USDC PremiumModels\BondingPremium.sol:28:    uint256 public constant BASE = uint256(1e6); //bonding curve graph takes 1e6 as 100.0000% PremiumModels\BondingPremium.sol:29:    uint256 public constant BASE_x2 = uint256(1e12); //BASE^2 PremiumModels\BondingPremium.sol:30:    uint256 public constant ADJUSTER = uint256(10); //adjuster of 1e6 to 1e5 (100.0000% to 100.000%) CDSTemplate.sol:55:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation IndexTemplate.sol:95:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation PoolTemplate.sol:146:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation Vault.sol:38:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Theses constants can simply be read from the verified contract, i.e., it is unnecessary to expose it with a public function. Also, constants having "1E6" in their name aren't even "nice to have public constants", as their value is obvious.   
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept  The `Withdrawal` struct in `IndexTemplate.sol` contains a timestamp and the amount of tokens which the user requests to withdraw.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L81-L84  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L198  If we make the safe assumption that the user's balance does not exceed 2^192 then we can pack this struct into a single storage slot to save an SLOAD by changing the definition to:  ``` struct Withdrawal {     uint64 timestamp;     uint192 amount; } ```  ## Recommended Mitigation Steps  As above  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  gas costs  ## Proof of Concept  In the sqrt function it is known that the while loop will not overflow so it can be safely left unchecked to save gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PremiumModels/BondingPremium.sol#L238-L245  ```     function sqrt(uint256 x) internal pure returns (uint256 y) {         uint256 z = (x + 1) / 2;         unchecked {             y = x;             while (z < y) {                 y = z;                 z = (x / z + z) / 2;             }         }     } ``` ## Recommended Mitigation Steps  wrap entire function body in a unchecked block as above  
# Handle  robee   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          InsureDAOERC20.sol : reachable assert in line 31         Vault.sol : reachable assert in line 167   
# Handle  robee   # Vulnerability details  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           CDSTemplate.sol, totalLiquidity         Factory.sol, _createClone         IndexTemplate.sol, withdrawable         IndexTemplate.sol, leverage         IndexTemplate.sol, totalLiquidity         PoolTemplate.sol, availableBalance         PoolTemplate.sol, utilizationRate         PoolTemplate.sol, totalLiquidity  
# Handle  robee   # Vulnerability details  The following requires are with empty messages.  This is very important to add a message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: CDSTemplate.sol, In line 253 with Empty Require message.         Solidity file: Factory.sol, In line 100 with Empty Require message.         Solidity file: IndexTemplate.sol, In line 477 with Empty Require message.         Solidity file: PoolTemplate.sol, In line 929 with Empty Require message.         Solidity file: Vault.sol, In line 66 with Empty Require message.         Solidity file: Vault.sol, In line 67 with Empty Require message.         Solidity file: Vault.sol, In line 68 with Empty Require message.   
# Handle  robee   # Vulnerability details  The following functions could skip other steps if the amount is 0. (A similar issue: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82)           InsureDAOERC20.sol, name         InsureDAOERC20.sol, symbol         InsureDAOERC20.sol, decimals         InsureDAOERC20.sol, totalSupply         InsureDAOERC20.sol, balanceOf         InsureDAOERC20.sol, transfer         InsureDAOERC20.sol, allowance         InsureDAOERC20.sol, approve         InsureDAOERC20.sol, transferFrom         InsureDAOERC20.sol, increaseAllowance         InsureDAOERC20.sol, decreaseAllowance         InsureDAOERC20.sol, _transfer         InsureDAOERC20.sol, _mint         InsureDAOERC20.sol, _burn         InsureDAOERC20.sol, _approve         InsureDAOERC20.sol, _beforeTokenTransfer         InsureDAOERC20.sol, _afterTokenTransfer  
# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function totalLiquidity in CDSTemplate.sol could be set external         The function valueOfUnderlying in CDSTemplate.sol could be set external         The function createMarket in Factory.sol could be set external         The function totalLiquidity in IndexTemplate.sol could be set external         The function set in IndexTemplate.sol could be set external         The function leverage in IndexTemplate.sol could be set external         The function withdrawable in IndexTemplate.sol could be set external         The function valueOfUnderlying in IndexTemplate.sol could be set external         The function deposit in IndexTemplate.sol could be set external         The function adjustAlloc in IndexTemplate.sol could be set external         The function allowance in InsureDAOERC20.sol could be set external         The function decimals in InsureDAOERC20.sol could be set external         The function totalSupply in InsureDAOERC20.sol could be set external         The function name in InsureDAOERC20.sol could be set external         The function transfer in InsureDAOERC20.sol could be set external         The function increaseAllowance in InsureDAOERC20.sol could be set external         The function transferFrom in InsureDAOERC20.sol could be set external         The function decreaseAllowance in InsureDAOERC20.sol could be set external         The function balanceOf in InsureDAOERC20.sol could be set external         The function symbol in InsureDAOERC20.sol could be set external         The function approve in InsureDAOERC20.sol could be set external         The function getOwner in Parameters.sol could be set external         The function utilizationRate in PoolTemplate.sol could be set external         The function totalLiquidity in PoolTemplate.sol could be set external         The function availableBalance in PoolTemplate.sol could be set external         The function getPremium in PoolTemplate.sol could be set external         The function valueOfUnderlying in PoolTemplate.sol could be set external         The function unlock in PoolTemplate.sol could be set external         The function originalLiquidity in PoolTemplate.sol could be set external         The function deposit in PoolTemplate.sol could be set external         The function allocatedCredit in PoolTemplate.sol could be set external         The function getPremiumRate in BondingPremium.sol could be set external         The function getCurrentPremiumRate in BondingPremium.sol could be set external         The function getPricePerFullShare in Vault.sol could be set external         The function valueAll in Vault.sol could be set external         The function setController in Vault.sol could be set external         The function underlyingValue in Vault.sol could be set external   
# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           CDSTemplate.sol: parameters.getLockup is read twice in withdraw         Factory.sol: registry is read twice in createMarket         IndexTemplate.sol: totalAllocPoint is read twice in set         IndexTemplate.sol: MAGIC_SCALE_1E6 is read twice in withdrawable         PoolTemplate.sol: parameters.getLockup is read twice in withdraw         PoolTemplate.sol: lockedAmount is read twice in utilizationRate         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in allocateCredit         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in withdrawCredit         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in insure         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in resume         BondingPremium.sol: k is read twice in getCurrentPremiumRate         BondingPremium.sol: k is read twice in getPremiumRate         BondingPremium.sol: c is read twice in getPremiumRate         BondingPremium.sol: b is read twice in getCurrentPremiumRate         BondingPremium.sol: b is read twice in getPremiumRate         BondingPremium.sol: T_1 is read twice in getCurrentPremiumRate         BondingPremium.sol: T_1 is read twice in getPremiumRate         BondingPremium.sol: BASE is read twice in getCurrentPremiumRate         BondingPremium.sol: BASE is read twice in getPremiumRate         BondingPremium.sol: BASE_x2 is read twice in getCurrentPremiumRate         BondingPremium.sol: BASE_x2 is read twice in getPremiumRate         Vault.sol: token is read twice in repayDebt         Vault.sol: token is read twice in utilize         Vault.sol: token is read twice in withdrawRedundant         Vault.sol: totalAttributions is read twice in attributionValue         Vault.sol: balance is read twice in valueAll         Vault.sol: balance is read twice in withdrawRedundant   
# Handle  robee   # Vulnerability details  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.  The format is <solidity file>, <unused storage variable name>:           IndexTemplate.sol, pendingEnd         BondingPremium.sol, ADJUSTER   
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           Factory.sol, line 13, import "hardhat/console.sol";         IndexTemplate.sol, line 6, import "hardhat/console.sol";         Parameters.sol, line 12, import "hardhat/console.sol";         BondingPremium.sol, line 9, import "@openzeppelin/contracts/utils/math/SafeMath.sol";   
