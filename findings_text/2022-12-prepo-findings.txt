# Lines of code  https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/WithdrawHook.sol#L61 https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/WithdrawHook.sol#L68   # Vulnerability details  ## Description  In Collateral.sol, users may withdraw underlying tokens using withdraw. Importantly, the withdrawal must be approved by withdrawHook if set: ``` function withdraw(uint256 _amount) external override nonReentrant {   uint256 _baseTokenAmount = (_amount * baseTokenDenominator) / 1e18;   uint256 _fee = (_baseTokenAmount * withdrawFee) / FEE_DENOMINATOR;   if (withdrawFee > 0) { require(_fee > 0, "fee = 0"); }   else { require(_baseTokenAmount > 0, "amount = 0"); }   _burn(msg.sender, _amount);   uint256 _baseTokenAmountAfterFee = _baseTokenAmount - _fee;   if (address(withdrawHook) != address(0)) {     baseToken.approve(address(withdrawHook), _fee);     withdrawHook.hook(msg.sender, _baseTokenAmount, _baseTokenAmountAfterFee);     baseToken.approve(address(withdrawHook), 0);   }   baseToken.transfer(msg.sender, _baseTokenAmountAfterFee);   emit Withdraw(msg.sender, _baseTokenAmountAfterFee, _fee); } ```  The hook requires that two checks are passed: ``` if (lastGlobalPeriodReset + globalPeriodLength < block.timestamp) {   lastGlobalPeriodReset = block.timestamp;   globalAmountWithdrawnThisPeriod = _amountBeforeFee; } else {   require(globalAmountWithdrawnThisPeriod + _amountBeforeFee <= globalWithdrawLimitPerPeriod, "global withdraw limit exceeded");   globalAmountWithdrawnThisPeriod += _amountBeforeFee; } if (lastUserPeriodReset + userPeriodLength < block.timestamp) {   lastUserPeriodReset = block.timestamp;   userToAmountWithdrawnThisPeriod[_sender] = _amountBeforeFee; } else {   require(userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee <= userWithdrawLimitPerPeriod, "user withdraw limit exceeded");   userToAmountWithdrawnThisPeriod[_sender] += _amountBeforeFee; } ```  If it has been less than "globalPeriodLength" seconds since the global reset, we step into the if block, reset time becomes now and starting amount is the current requested amount. Otherwise, the new amount must not overpass the globalWithdrawLimitPerPeriod. Very similar check is done for "user" variables.  The big issue here is that the limit can be easily bypassed by the first person calling withdraw in each group ("global" and "user"). It will step directly into the if block where no check is done, and fill the variable with any input amount.  As I understand, the withdraw limit is meant to make sure everyone is guaranteed to be able to withdraw the specified amount, so there is no chance of freeze of funds. However, due to the bypassing of this check, a whale user is able to empty the current reserves put in place and cause a freeze of funds for other users, until the Collateral contract is replenished.  ## Impact  A whale user is able to cause freeze of funds of other users by bypassing withdraw limit  ## Proof of Concept   1. Collateral.sol has 10000 USDC reserve 2. Withdraw limit is 150 USDC per user per period 3. There are 5 users - Alpha with collateral worth 12,000 USDC, and 4 users each with 1,000 USDC 4. Alpha waits for a time when request would create a new lastGlobalPeriodReset **and** new lastUserPeriodReset. He requests a withdraw of 10,000 USDC 5. The hook is passed and he withdraws the entire collateral reserves 6. At this point, victim Vic is not able to withdraw their 150 USDC. It is a freeze of funds.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Add limit checks in the if blocks as well, to make sure the first request does not overflow the limit.  ## Judge note  I've confirmed with PrePO team during the contest that withdraw limit bypass is a very serious issue
# Lines of code  https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/WithdrawHook.sol#L53-L79   # Vulnerability details  ## Impact When a manager withdraws funds from Collateral.sol, there is a check in the `managerWithdrawHook` to confirm that they aren't pushing the contract below the minimum reserve balance.  ```solidity require(collateral.getReserve() - _amountAfterFee >= getMinReserve(), "reserve would fall below minimum"); ```  However, a similar check doesn't happen in the `withdraw()` function.   The manager can use this flaw to get around the reserve balance by making a large deposit, taking a manager withdrawal, and then withdrawing their deposit.  ## Proof of Concept  Imagine a situation where the token has a balance of 100, deposits of 1000, and a reserve percentage of 10%. In this situation, the manager should not be able to make any withdrawal.  But, with the following series of events, they can: - Manager calls `deposit()` with 100 additional tokens - Manager calls `managerWithdraw()` to pull 100 tokens from the contract - Manager calls `withdraw()` to remove the 100 tokens they added  The result is that they are able to drain the balance of the contract all the way to zero, avoiding the intended restrictions.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Include a check on the reserves in the `withdraw()` function as well as `managerWithdraw()`.
# Lines of code  https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/PrePOMarket.sol#L119   # Vulnerability details  ## Impact If `finalLongPayout` is changed twice by admin fault, the market would be insolvent as it should pay more collateral than it has.  ## Proof of Concept If `finalLongPayout` is less than `MAX_PAYOUT`, it means the market is ended and `longToken Price = finalLongPayout, shortToken Price = MAX_PAYOUT - finalLongPayout`.  So when users redeem their long/short tokens, the total amount of collateral tokens will be the same as the amount that users transferred during mint().  Btw in `setFinalLongPayout()`, there is no validation that this function can't be called twice and the below scenario would be possible.  1. Let's assume there is one user `Bob` in the market for simplicity. 2. `Bob` transferred 100 amounts of `collateral` and got 100 long/short tokens. The market has 100 `collateral`. 3. The market admin set `finalLongPayout = 60 * 1e16` and `Bob` redeemed 100 `longToken` and received 60 `collateral`. The market has 40 `collateral` now. 4. After that, the admin realized `finalLongPayout` is too high and changed `finalLongPayout = 40 * 1e16` again. 5. `Bob` tries to redeem 100 `shortToken` and receive 60 `collateral` but the market can't offer as it has 40 `collateral` only.  When there are several users in the market, some users can't redeem their long/short tokens as the market doesn't have enough `collaterals`.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should modify `setFinalLongPayout()` like below so it can't be finalized twice.  ```solidity   function setFinalLongPayout(uint256 _finalLongPayout) external override onlyOwner {      require(finalLongPayout > MAX_PAYOUT, "Finalized already"); //++++++++++++++++++++++++      require(_finalLongPayout >= floorLongPayout, "Payout cannot be below floor");     require(_finalLongPayout <= ceilingLongPayout, "Payout cannot exceed ceiling");     finalLongPayout = _finalLongPayout;     emit FinalLongPayoutSet(_finalLongPayout);   } ```
# Lines of code  https://github.com/prepo-io/prepo-monorepo/blob/feat/2022-12-prepo/apps/smart-contracts/core/contracts/WithdrawHook.sol#L70   # Vulnerability details  ## Impact User can bypass the `userWithdrawLimitPerPeriod` check by transferring balance to another account  ## Proof of Concept 1. Assume `userWithdrawLimitPerPeriod` is set to `1000` 2. User A has current deposit of amount `2000` and wants to withdraw everything instantly 3. User A calls the withdraw function and takes out the `1000` amount  ``` function withdraw(uint256 _amount) external override nonReentrant {     uint256 _baseTokenAmount = (_amount * baseTokenDenominator) / 1e18;     uint256 _fee = (_baseTokenAmount * withdrawFee) / FEE_DENOMINATOR;     if (withdrawFee > 0) { require(_fee > 0, "fee = 0"); }     else { require(_baseTokenAmount > 0, "amount = 0"); }     _burn(msg.sender, _amount);     uint256 _baseTokenAmountAfterFee = _baseTokenAmount - _fee;     if (address(withdrawHook) != address(0)) {       baseToken.approve(address(withdrawHook), _fee);       withdrawHook.hook(msg.sender, _baseTokenAmount, _baseTokenAmountAfterFee);       baseToken.approve(address(withdrawHook), 0);     }     baseToken.transfer(msg.sender, _baseTokenAmountAfterFee);     emit Withdraw(msg.sender, _baseTokenAmountAfterFee, _fee);   } ```  4. Remaining `1000` amount cannot be withdrawn since `userWithdrawLimitPerPeriod` is reached  ``` function hook(     address _sender,     uint256 _amountBeforeFee,     uint256 _amountAfterFee   ) external override onlyCollateral { ... require(userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee <= userWithdrawLimitPerPeriod, "user withdraw limit exceeded"); ... } ```  5. User simply transfer his balance to his another account and withdraw from that account  6. Since withdraw limit is tied to account so this new account will be allowed to make withdrawal thus bypassing userWithdrawLimitPerPeriod   ## Recommended Mitigation Steps User should only be allowed to transfer leftover limit. For example if User already utilized limit X then he should only be able to transfer userWithdrawLimitPerPeriod-X
# Lines of code  https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/WithdrawHook.sol#L61 https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/WithdrawHook.sol#L68   # Vulnerability details  ## Description  In Collateral.sol, users may withdraw underlying tokens using withdraw. Importantly, the withdrawal must be approved by withdrawHook if set: ``` function withdraw(uint256 _amount) external override nonReentrant {   uint256 _baseTokenAmount = (_amount * baseTokenDenominator) / 1e18;   uint256 _fee = (_baseTokenAmount * withdrawFee) / FEE_DENOMINATOR;   if (withdrawFee > 0) { require(_fee > 0, "fee = 0"); }   else { require(_baseTokenAmount > 0, "amount = 0"); }   _burn(msg.sender, _amount);   uint256 _baseTokenAmountAfterFee = _baseTokenAmount - _fee;   if (address(withdrawHook) != address(0)) {     baseToken.approve(address(withdrawHook), _fee);     withdrawHook.hook(msg.sender, _baseTokenAmount, _baseTokenAmountAfterFee);     baseToken.approve(address(withdrawHook), 0);   }   baseToken.transfer(msg.sender, _baseTokenAmountAfterFee);   emit Withdraw(msg.sender, _baseTokenAmountAfterFee, _fee); } ```  The hook requires that two checks are passed: ``` if (lastGlobalPeriodReset + globalPeriodLength < block.timestamp) {   lastGlobalPeriodReset = block.timestamp;   globalAmountWithdrawnThisPeriod = _amountBeforeFee; } else {   require(globalAmountWithdrawnThisPeriod + _amountBeforeFee <= globalWithdrawLimitPerPeriod, "global withdraw limit exceeded");   globalAmountWithdrawnThisPeriod += _amountBeforeFee; } if (lastUserPeriodReset + userPeriodLength < block.timestamp) {   lastUserPeriodReset = block.timestamp;   userToAmountWithdrawnThisPeriod[_sender] = _amountBeforeFee; } else {   require(userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee <= userWithdrawLimitPerPeriod, "user withdraw limit exceeded");   userToAmountWithdrawnThisPeriod[_sender] += _amountBeforeFee; } ```  If it has been less than "globalPeriodLength" seconds since the global reset, we step into the if block, reset time becomes now and starting amount is the current requested amount. Otherwise, the new amount must not overpass the globalWithdrawLimitPerPeriod. Very similar check is done for "user" variables.  The big issue here is that the limit can be easily bypassed by the first person calling withdraw in each group ("global" and "user"). It will step directly into the if block where no check is done, and fill the variable with any input amount.  As I understand, the withdraw limit is meant to make sure everyone is guaranteed to be able to withdraw the specified amount, so there is no chance of freeze of funds. However, due to the bypassing of this check, a whale user is able to empty the current reserves put in place and cause a freeze of funds for other users, until the Collateral contract is replenished.  ## Impact  A whale user is able to cause freeze of funds of other users by bypassing withdraw limit  ## Proof of Concept   1. Collateral.sol has 10000 USDC reserve 2. Withdraw limit is 150 USDC per user per period 3. There are 5 users - Alpha with collateral worth 12,000 USDC, and 4 users each with 1,000 USDC 4. Alpha waits for a time when request would create a new lastGlobalPeriodReset **and** new lastUserPeriodReset. He requests a withdraw of 10,000 USDC 5. The hook is passed and he withdraws the entire collateral reserves 6. At this point, victim Vic is not able to withdraw their 150 USDC. It is a freeze of funds.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Add limit checks in the if blocks as well, to make sure the first request does not overflow the limit.  ## Judge note  I've confirmed with PrePO team during the contest that withdraw limit bypass is a very serious issue
# Lines of code  https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/WithdrawHook.sol#L53-L79   # Vulnerability details  ## Impact When a manager withdraws funds from Collateral.sol, there is a check in the `managerWithdrawHook` to confirm that they aren't pushing the contract below the minimum reserve balance.  ```solidity require(collateral.getReserve() - _amountAfterFee >= getMinReserve(), "reserve would fall below minimum"); ```  However, a similar check doesn't happen in the `withdraw()` function.   The manager can use this flaw to get around the reserve balance by making a large deposit, taking a manager withdrawal, and then withdrawing their deposit.  ## Proof of Concept  Imagine a situation where the token has a balance of 100, deposits of 1000, and a reserve percentage of 10%. In this situation, the manager should not be able to make any withdrawal.  But, with the following series of events, they can: - Manager calls `deposit()` with 100 additional tokens - Manager calls `managerWithdraw()` to pull 100 tokens from the contract - Manager calls `withdraw()` to remove the 100 tokens they added  The result is that they are able to drain the balance of the contract all the way to zero, avoiding the intended restrictions.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Include a check on the reserves in the `withdraw()` function as well as `managerWithdraw()`.
# Lines of code  https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/PrePOMarket.sol#L119   # Vulnerability details  ## Impact If `finalLongPayout` is changed twice by admin fault, the market would be insolvent as it should pay more collateral than it has.  ## Proof of Concept If `finalLongPayout` is less than `MAX_PAYOUT`, it means the market is ended and `longToken Price = finalLongPayout, shortToken Price = MAX_PAYOUT - finalLongPayout`.  So when users redeem their long/short tokens, the total amount of collateral tokens will be the same as the amount that users transferred during mint().  Btw in `setFinalLongPayout()`, there is no validation that this function can't be called twice and the below scenario would be possible.  1. Let's assume there is one user `Bob` in the market for simplicity. 2. `Bob` transferred 100 amounts of `collateral` and got 100 long/short tokens. The market has 100 `collateral`. 3. The market admin set `finalLongPayout = 60 * 1e16` and `Bob` redeemed 100 `longToken` and received 60 `collateral`. The market has 40 `collateral` now. 4. After that, the admin realized `finalLongPayout` is too high and changed `finalLongPayout = 40 * 1e16` again. 5. `Bob` tries to redeem 100 `shortToken` and receive 60 `collateral` but the market can't offer as it has 40 `collateral` only.  When there are several users in the market, some users can't redeem their long/short tokens as the market doesn't have enough `collaterals`.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should modify `setFinalLongPayout()` like below so it can't be finalized twice.  ```solidity   function setFinalLongPayout(uint256 _finalLongPayout) external override onlyOwner {      require(finalLongPayout > MAX_PAYOUT, "Finalized already"); //++++++++++++++++++++++++      require(_finalLongPayout >= floorLongPayout, "Payout cannot be below floor");     require(_finalLongPayout <= ceilingLongPayout, "Payout cannot exceed ceiling");     finalLongPayout = _finalLongPayout;     emit FinalLongPayoutSet(_finalLongPayout);   } ```
# Lines of code  https://github.com/prepo-io/prepo-monorepo/blob/feat/2022-12-prepo/apps/smart-contracts/core/contracts/WithdrawHook.sol#L70   # Vulnerability details  ## Impact User can bypass the `userWithdrawLimitPerPeriod` check by transferring balance to another account  ## Proof of Concept 1. Assume `userWithdrawLimitPerPeriod` is set to `1000` 2. User A has current deposit of amount `2000` and wants to withdraw everything instantly 3. User A calls the withdraw function and takes out the `1000` amount  ``` function withdraw(uint256 _amount) external override nonReentrant {     uint256 _baseTokenAmount = (_amount * baseTokenDenominator) / 1e18;     uint256 _fee = (_baseTokenAmount * withdrawFee) / FEE_DENOMINATOR;     if (withdrawFee > 0) { require(_fee > 0, "fee = 0"); }     else { require(_baseTokenAmount > 0, "amount = 0"); }     _burn(msg.sender, _amount);     uint256 _baseTokenAmountAfterFee = _baseTokenAmount - _fee;     if (address(withdrawHook) != address(0)) {       baseToken.approve(address(withdrawHook), _fee);       withdrawHook.hook(msg.sender, _baseTokenAmount, _baseTokenAmountAfterFee);       baseToken.approve(address(withdrawHook), 0);     }     baseToken.transfer(msg.sender, _baseTokenAmountAfterFee);     emit Withdraw(msg.sender, _baseTokenAmountAfterFee, _fee);   } ```  4. Remaining `1000` amount cannot be withdrawn since `userWithdrawLimitPerPeriod` is reached  ``` function hook(     address _sender,     uint256 _amountBeforeFee,     uint256 _amountAfterFee   ) external override onlyCollateral { ... require(userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee <= userWithdrawLimitPerPeriod, "user withdraw limit exceeded"); ... } ```  5. User simply transfer his balance to his another account and withdraw from that account  6. Since withdraw limit is tied to account so this new account will be allowed to make withdrawal thus bypassing userWithdrawLimitPerPeriod   ## Recommended Mitigation Steps User should only be allowed to transfer leftover limit. For example if User already utilized limit X then he should only be able to transfer userWithdrawLimitPerPeriod-X
