# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L41-L60   # Vulnerability details  ## Impact  Malicious user can populate `rewards` array with different tokens early reaching limit of `MAX_REWARD_TOKENS` sending very small amount of different tokens. It will restrict any other tokens to be used as `rewards` in [Bribe.sol#notifyRewardAmount()](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L41)  ## Proof of Concept  A custom malicious contract can be created that can make multiple calls to `notifyRewardAmount()` sending very small amounts of different tokens to populate the array `rewards` and fulfill the total of `MAX_REWARD_TOKENS` . This will restrict any other person from adding to `rewards` array.   ## Tools Used  - Manual analysis  ## Recommended Mitigation Steps  
# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L83-L90   # Vulnerability details  ## Impact Function `deliverReward()` in `Bribe` contract won't set `tokenRewardsPerEpoch[token][epochStart]` to `0` after transferring rewards. `Gauge.getReward()` calls `Voter.distribute()` which calls `Gauge.deliverBribes()` which calls `Bribe.deliverReward()`. so if `Gauge.getReward()` or `Voter.distribute()` get called multiple times in same epoch then `deliverReward()` will transfer `Bribe` tokens multiple times because it doesn't set `tokenRewardsPerEpoch[token][epochStart]` to `0` after transferring.  ## Proof of Concept This is `deliverReward()` code in `Bribe`: ```   function deliverReward(address token, uint epochStart) external lock returns (uint) {     require(msg.sender == gauge);     uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];     if (rewardPerEpoch > 0) {       _safeTransfer(token, address(gauge), rewardPerEpoch);     }     return rewardPerEpoch;   } ``` As you can see it doesn't set `tokenRewardsPerEpoch[token][epochStart]` value to `0`, so if this function get called multiple times it will transfer epoch rewards multiple times (it will use other epoch's rewards tokens). function `Gauge.deliverBribes()` calls `Bribe.deliverReward()` and  `Gauge.deliverBribes()` is called by `Voter.distribute()` if the condition `claimable[_gauge] > DURATION` is `True`. This is those functions codes: ```     function deliverBribes() external lock {         require(msg.sender == voter);         IBribe sb = IBribe(bribe);         uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;         uint numRewards = sb.rewardsListLength();          for (uint i = 0; i < numRewards; i++) {             address token = sb.rewards(i);             uint epochRewards = sb.deliverReward(token, bribeStart);             if (epochRewards > 0) {                 _notifyBribeAmount(token, epochRewards, bribeStart);             }         }     } ``` ```     function distribute(address _gauge) public lock {         require(isAlive[_gauge]); // killed gauges cannot distribute         uint dayCalc = block.timestamp % (7 days);         require((dayCalc < BRIBE_LAG) || (dayCalc > (DURATION + BRIBE_LAG)), "cannot claim during votes period");         IMinter(minter).update_period();         _updateFor(_gauge);         uint _claimable = claimable[_gauge];         if (_claimable > IGauge(_gauge).left(base) && _claimable / DURATION > 0) {             claimable[_gauge] = 0;             IGauge(_gauge).notifyRewardAmount(base, _claimable);             emit DistributeReward(msg.sender, _gauge, _claimable);             // distribute bribes & fees too             IGauge(_gauge).deliverBribes();         }     } ``` also `Gauge.getReward()` calls `Voter.getReward()`. condition `claimable[_gauge] > DURATION` in `Voter.distribute()` can be true multiple time in one epoch (`deliverBribes()` would be called multiple times) because `claimable[_gauge]` is based on `index` and `index` increase by `notifyRewardAmount()` in `Voter` anytime.  ## Tools Used VIM  ## Recommended Mitigation Steps set `tokenRewardsPerEpoch[token][epochStart]` to `0` in `deliverReward`  
# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L517-L528   # Vulnerability details  ## Impact Users can get unlimited votes which leads to them: 1. gaining control over governance 2. getting undeserved rewards 3. having their pools favored due to gauge values  ## Proof of Concept `_mint()` calls `_moveTokenDelegates()` to set up delegation... ```solidity File: contracts/contracts/VotingEscrow.sol   #1  462       function _mint(address _to, uint _tokenId) internal returns (bool) { 463           // Throws if `_to` is zero address 464           assert(_to != address(0)); 465           // TODO add delegates 466           // checkpoint for gov 467           _moveTokenDelegates(address(0), delegates(_to), _tokenId); ``` https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L462-L467  and `_transferFrom()` calls `_moveTokenDelegates()` to transfer delegates... ```solidity File: contracts/contracts/VotingEscrow.sol   #2  301       function _transferFrom( 302           address _from, 303           address _to, 304           uint _tokenId, 305           address _sender 306       ) internal { 307           require(attachments[_tokenId] == 0 && !voted[_tokenId], "attached"); 308           // Check requirements 309           require(_isApprovedOrOwner(_sender, _tokenId)); 310           // Clear approval. Throws if `_from` is not the current owner 311           _clearApproval(_from, _tokenId); 312           // Remove NFT. Throws if `_tokenId` is not a valid NFT 313           _removeTokenFrom(_from, _tokenId); 314           // TODO delegates 315           // auto re-delegate 316           _moveTokenDelegates(delegates(_from), delegates(_to), _tokenId); ``` https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L301-L316  but `_burn()` does not transfer them back to `address(0)` ```solidity File: contracts/contracts/VotingEscrow.sol   #3  517       function _burn(uint _tokenId) internal { 518           require(_isApprovedOrOwner(msg.sender, _tokenId), "caller is not owner nor approved"); 519    520           address owner = ownerOf(_tokenId); 521    522           // Clear approval 523           approve(address(0), _tokenId); 524           // TODO add delegates 525           // Remove token 526           _removeTokenFrom(msg.sender, _tokenId); 527           emit Transfer(owner, address(0), _tokenId); 528       } ``` https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L517-L528  A user can deposit a token, lock it, wait for the lock to expire, transfer the token to another address, and repeat. During each iteration, a new NFT is minted and checkpointed. Calls to `getPastVotes()` will show the wrong values, since it will think the account still holds the delegation of the burnt NFT. Bribes and gauges also look at the checkpoints and will also have the wrong information  ## Tools Used Code inspection  ## Recommended Mitigation Steps Call `_moveTokenDelegates(owner,address(0))` in `_burn()`   
# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L30-L33   # Vulnerability details  If Bribe and Gauge constructors are run not in the same transaction, the griefing attack is possible. A malicious user can run setGauge after Bribe, but before Gauge constructor, making Bribe contract unusable. The fix here is Bribe redeployment.  Setting severity to be medium as that is temporary system breaking impact.  ## Proof of Concept  setGauge can be run by anyone, but only once with a meaningful gauge:  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L30-L33  ```solidity   function setGauge(address _gauge) external {     require(gauge == address(0), "gauge already set");     gauge = _gauge;   } ```  Now it is called in Gauge constructor:  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L96-L104  ```solidity     constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {         stake = _stake;         bribe = _bribe;         _ve = __ve;         voter = _voter;          factory = msg.sender;          IBribe(bribe).setGauge(address(this)); ```  This way it will not be called before Gauge constructor, but if it is not atomic with Bribe constructor, an attacker can call in-between.  ## Recommended Mitigation Steps  Consider either running Bribe and then Gauge constructors atomically, or introducing an owner role in Bribe constructor and onlyOwner access control in setGauge, setting it manually.  
# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L41-L60   # Vulnerability details  ## Impact  Malicious user can populate `rewards` array with different tokens early reaching limit of `MAX_REWARD_TOKENS` sending very small amount of different tokens. It will restrict any other tokens to be used as `rewards` in [Bribe.sol#notifyRewardAmount()](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L41)  ## Proof of Concept  A custom malicious contract can be created that can make multiple calls to `notifyRewardAmount()` sending very small amounts of different tokens to populate the array `rewards` and fulfill the total of `MAX_REWARD_TOKENS` . This will restrict any other person from adding to `rewards` array.   ## Tools Used  - Manual analysis  ## Recommended Mitigation Steps  
# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L83-L90   # Vulnerability details  ## Impact Function `deliverReward()` in `Bribe` contract won't set `tokenRewardsPerEpoch[token][epochStart]` to `0` after transferring rewards. `Gauge.getReward()` calls `Voter.distribute()` which calls `Gauge.deliverBribes()` which calls `Bribe.deliverReward()`. so if `Gauge.getReward()` or `Voter.distribute()` get called multiple times in same epoch then `deliverReward()` will transfer `Bribe` tokens multiple times because it doesn't set `tokenRewardsPerEpoch[token][epochStart]` to `0` after transferring.  ## Proof of Concept This is `deliverReward()` code in `Bribe`: ```   function deliverReward(address token, uint epochStart) external lock returns (uint) {     require(msg.sender == gauge);     uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];     if (rewardPerEpoch > 0) {       _safeTransfer(token, address(gauge), rewardPerEpoch);     }     return rewardPerEpoch;   } ``` As you can see it doesn't set `tokenRewardsPerEpoch[token][epochStart]` value to `0`, so if this function get called multiple times it will transfer epoch rewards multiple times (it will use other epoch's rewards tokens). function `Gauge.deliverBribes()` calls `Bribe.deliverReward()` and  `Gauge.deliverBribes()` is called by `Voter.distribute()` if the condition `claimable[_gauge] > DURATION` is `True`. This is those functions codes: ```     function deliverBribes() external lock {         require(msg.sender == voter);         IBribe sb = IBribe(bribe);         uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;         uint numRewards = sb.rewardsListLength();          for (uint i = 0; i < numRewards; i++) {             address token = sb.rewards(i);             uint epochRewards = sb.deliverReward(token, bribeStart);             if (epochRewards > 0) {                 _notifyBribeAmount(token, epochRewards, bribeStart);             }         }     } ``` ```     function distribute(address _gauge) public lock {         require(isAlive[_gauge]); // killed gauges cannot distribute         uint dayCalc = block.timestamp % (7 days);         require((dayCalc < BRIBE_LAG) || (dayCalc > (DURATION + BRIBE_LAG)), "cannot claim during votes period");         IMinter(minter).update_period();         _updateFor(_gauge);         uint _claimable = claimable[_gauge];         if (_claimable > IGauge(_gauge).left(base) && _claimable / DURATION > 0) {             claimable[_gauge] = 0;             IGauge(_gauge).notifyRewardAmount(base, _claimable);             emit DistributeReward(msg.sender, _gauge, _claimable);             // distribute bribes & fees too             IGauge(_gauge).deliverBribes();         }     } ``` also `Gauge.getReward()` calls `Voter.getReward()`. condition `claimable[_gauge] > DURATION` in `Voter.distribute()` can be true multiple time in one epoch (`deliverBribes()` would be called multiple times) because `claimable[_gauge]` is based on `index` and `index` increase by `notifyRewardAmount()` in `Voter` anytime.  ## Tools Used VIM  ## Recommended Mitigation Steps set `tokenRewardsPerEpoch[token][epochStart]` to `0` in `deliverReward`  
# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L517-L528   # Vulnerability details  ## Impact Users can get unlimited votes which leads to them: 1. gaining control over governance 2. getting undeserved rewards 3. having their pools favored due to gauge values  ## Proof of Concept `_mint()` calls `_moveTokenDelegates()` to set up delegation... ```solidity File: contracts/contracts/VotingEscrow.sol   #1  462       function _mint(address _to, uint _tokenId) internal returns (bool) { 463           // Throws if `_to` is zero address 464           assert(_to != address(0)); 465           // TODO add delegates 466           // checkpoint for gov 467           _moveTokenDelegates(address(0), delegates(_to), _tokenId); ``` https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L462-L467  and `_transferFrom()` calls `_moveTokenDelegates()` to transfer delegates... ```solidity File: contracts/contracts/VotingEscrow.sol   #2  301       function _transferFrom( 302           address _from, 303           address _to, 304           uint _tokenId, 305           address _sender 306       ) internal { 307           require(attachments[_tokenId] == 0 && !voted[_tokenId], "attached"); 308           // Check requirements 309           require(_isApprovedOrOwner(_sender, _tokenId)); 310           // Clear approval. Throws if `_from` is not the current owner 311           _clearApproval(_from, _tokenId); 312           // Remove NFT. Throws if `_tokenId` is not a valid NFT 313           _removeTokenFrom(_from, _tokenId); 314           // TODO delegates 315           // auto re-delegate 316           _moveTokenDelegates(delegates(_from), delegates(_to), _tokenId); ``` https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L301-L316  but `_burn()` does not transfer them back to `address(0)` ```solidity File: contracts/contracts/VotingEscrow.sol   #3  517       function _burn(uint _tokenId) internal { 518           require(_isApprovedOrOwner(msg.sender, _tokenId), "caller is not owner nor approved"); 519    520           address owner = ownerOf(_tokenId); 521    522           // Clear approval 523           approve(address(0), _tokenId); 524           // TODO add delegates 525           // Remove token 526           _removeTokenFrom(msg.sender, _tokenId); 527           emit Transfer(owner, address(0), _tokenId); 528       } ``` https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L517-L528  A user can deposit a token, lock it, wait for the lock to expire, transfer the token to another address, and repeat. During each iteration, a new NFT is minted and checkpointed. Calls to `getPastVotes()` will show the wrong values, since it will think the account still holds the delegation of the burnt NFT. Bribes and gauges also look at the checkpoints and will also have the wrong information  ## Tools Used Code inspection  ## Recommended Mitigation Steps Call `_moveTokenDelegates(owner,address(0))` in `_burn()`   
# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L30-L33   # Vulnerability details  If Bribe and Gauge constructors are run not in the same transaction, the griefing attack is possible. A malicious user can run setGauge after Bribe, but before Gauge constructor, making Bribe contract unusable. The fix here is Bribe redeployment.  Setting severity to be medium as that is temporary system breaking impact.  ## Proof of Concept  setGauge can be run by anyone, but only once with a meaningful gauge:  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L30-L33  ```solidity   function setGauge(address _gauge) external {     require(gauge == address(0), "gauge already set");     gauge = _gauge;   } ```  Now it is called in Gauge constructor:  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L96-L104  ```solidity     constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {         stake = _stake;         bribe = _bribe;         _ve = __ve;         voter = _voter;          factory = msg.sender;          IBribe(bribe).setGauge(address(this)); ```  This way it will not be called before Gauge constructor, but if it is not atomic with Bribe constructor, an attacker can call in-between.  ## Recommended Mitigation Steps  Consider either running Bribe and then Gauge constructors atomically, or introducing an owner role in Bribe constructor and onlyOwner access control in setGauge, setting it manually.  
