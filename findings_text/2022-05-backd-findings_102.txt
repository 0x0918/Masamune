## Don't explicitly initialize variables with the default value  Uninitialized variables are assigned with the default value of their type, initializing a variable with its default value costs unnecessary gas.  ### Instances include : ``` contracts/tokenomics/InflationManager.sol:412:        bool keeperGaugeExists = false; ```  ### Recommendation It is recommended to initialize variables without assigning them the default value, for example : ``` contracts/tokenomics/InflationManager.sol:412:        bool keeperGaugeExists; ``` ---  ## Cache array length outside of for loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop.  ### Instances include : ``` contracts/RewardHandler.sol:42:        for (uint256 i; i < pools.length; i = i.uncheckedInc()) { contracts/access/RoleManager.sol:82:        for (uint256 i; i < roles.length; i = i.uncheckedInc()) { contracts/StakerVault.sol:259:        for (uint256 i; i < actions.length; i = i.uncheckedInc()) { contracts/tokenomics/VestedEscrow.sol:94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { contracts/tokenomics/InflationManager.sol:116:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { contracts/tokenomics/FeeBurner.sol:56:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { contracts/zaps/PoolMigrationZap.sol:22:        for (uint256 i; i < newPools_.length; ++i) { contracts/zaps/PoolMigrationZap.sol:39:        for (uint256 i; i < oldPoolAddresses_.length; ) { ```  ### Recommendation It is recommended to cache the array length on a variable before running the loop, then it doesn't need to read the length on every iteration, which cost gas, for example : ``` uint256 len = pools.length; contracts/RewardHandler.sol:42:        for (uint256 i; i < len; i = i.uncheckedInc()) { ``` ---  ## Use != 0 instead of > 0 when comparing unsigned integers  != 0 will do the same as > 0 for unsigned integers, but != 0 costs less gas compared to > 0 for unsigned integers in require statements with the optimizer enabled.  ### Instances include : ``` contracts/BkdLocker.sol:91:        require(amount > 0, Error.INVALID_AMOUNT); contracts/BkdLocker.sol:92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); contracts/BkdLocker.sol:137:        require(length > 0, "No entries"); contracts/tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, "No reward tokens in contract"); contracts/tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); ```  ### Recommendation It is recommended to replace `> 0` with `!= 0`, as they do the same thing for unsigned integers, and '!= 0' costs less gas compared to `> 0` in require statements with the optimizer enabled, also enable the optimizer.   For example : ``` contracts/BkdLocker.sol:91:        require(amount != 0, Error.INVALID_AMOUNT); ``` ---  ## If possible, use prefix increment instead of postfix increment  Prefix increment `++i` returns the updated value after it's incremented and postfix increment `i++` returns the original value then increments it. Prefix increment costs less gas compared to postfix increment.  ### Instances includes : ``` contracts/tokenomics/KeeperGauge.sol:59:        epoch++; contracts/tokenomics/KeeperGauge.sol:98:        epoch++; ```  ### Recommendation It is recommended to use prefix increment instead of postfix one when the return value is not needed, as both of them will give the same result and prefix increment costs less gas.   For example : ``` contracts/tokenomics/KeeperGauge.sol:59:        ++epoch; ``` ---
