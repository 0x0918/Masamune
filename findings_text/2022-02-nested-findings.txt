Gas optimization  1 Use default value for uint256 and use ++i instead of i++ in for loop  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L136-L139 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L148 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L165 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L261 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L280 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L318  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L103 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L113 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L153 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L213 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L273 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L327 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L369 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L581  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L581  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/OperatorResolver.sol#L40 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/OperatorResolver.sol#L75   Feesplitter.sol  2 Use storage for shareholders[_accountIndex]saves gas in updateShareholder.  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L134-L140  function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {         require(_accountIndex < shareholders.length, "FS: INVALID_ACCOUNT_INDEX");         Shareholder storage _shareholder = shareholders[_accountIndex];         totalWeights = totalWeights + _weight - _shareholder.weight;         require(totalWeights != 0, "FS: TOTAL_WEIGHTS_ZERO");         _shareholder.weight = _weight;         emit ShareholderUpdated(_shareholder.account, _weight);     }  NestedRecords.sol  3 Check _reserve != address(0) earlier in store save gas.  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L111-L127  require(_reserve != address(0), “NRC: NO_ADDRESS”); must be checked separately at the beginning of function.  4 Use storage for records[_nftId] saves gas in store.  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L111-L132  function store(         uint256 _nftId,         address _token,         uint256 _amount,         address _reserve     ) external onlyFactory {         NftRecord storage _record = records[_nftId];         uint256 amount = _record.holdings[_token];         // uint256 amount = records[_nftId].holdings[_token];         if (amount != 0) {             require(_record.reserve == _reserve, "NRC: RESERVE_MISMATCH");             updateHoldingAmount(_nftId, _token, amount + _amount);             return;         }         require(_record.tokens.length < maxHoldingsCount, "NRC: TOO_MANY_TOKENS");         require(             _reserve != address(0) && (_reserve == _record.reserve || _record.reserve == address(0)),             "NRC: INVALID_RESERVE"         );           _record.holdings[_token] = _amount;         _record.tokens.push(_token);         _record.reserve = _reserve;     }   
# QA Report   **Table of Contents:**   - [QA Report](#qa-report)   - [Foreword](#foreword)   - [Comparisons](#comparisons)     - [Comparison that should be inclusive in NestedRecords.sol](#comparison-that-should-be-inclusive-in-nestedrecordssol)   - [Variables](#variables)     - [Missing Address(0) checks](#missing-address0-checks)     - [Check if a value is in an array before a push](#check-if-a-value-is-in-an-array-before-a-push)     - [Variables that should be grouped together in a struct](#variables-that-should-be-grouped-together-in-a-struct)       - [File: FeeSplitter.sol](#file-feesplittersol)   - [Arithmetics](#arithmetics)     - [Possible division by 0](#possible-division-by-0)   - [Revert Strings](#revert-strings)     - [File: NestedFactory.sol](#file-nestedfactorysol)       - [Inconsistent Revert string](#inconsistent-revert-string)     - [File: MixinOperatorResolver.sol](#file-mixinoperatorresolversol)       - [Inconsistent Revert string (1)](#inconsistent-revert-string-1)       - [Misleading + Inconsistent Revert string (2)](#misleading--inconsistent-revert-string-2)     - [File: OwnableProxyDelegation.sol](#file-ownableproxydelegationsol)       - [Inconsistent Revert string (1)](#inconsistent-revert-string-1-1)       - [Inconsistent Revert string (2)](#inconsistent-revert-string-2)     - [File: ZeroExOperator.sol](#file-zeroexoperatorsol)       - [Inconsistent Revert string (1)](#inconsistent-revert-string-1-2)       - [Inconsistent Revert string (2)](#inconsistent-revert-string-2-1)   - [Comments](#comments)     - [File: NestedFactory.sol](#file-nestedfactorysol-1)       - [Missing comment "@return" (1)](#missing-comment-return-1)       - [Missing comment "@return" (2)](#missing-comment-return-2)       - [Missing comment "@param" (1)](#missing-comment-param-1)     - [File: NestedRecords.sol](#file-nestedrecordssol)       - [Missing comment "@return" (1)](#missing-comment-return-1-1)       - [Missing comment "@return" (2)](#missing-comment-return-2-1)       - [Misleading comment on "@return"](#misleading-comment-on-return)     - [File: MixinOperatorResolver.sol](#file-mixinoperatorresolversol-1)       - [Missing 2 comments "@param" & changeable "@return" comment/variable](#missing-2-comments-param--changeable-return-commentvariable)     - [File: ExchangeHelpers.sol](#file-exchangehelperssol)       - [Missing comment "@return"](#missing-comment-return)  ## Foreword - **`@audit` tags** > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Comparisons ### Comparison that should be inclusive in NestedRecords.sol ``` File: NestedRecords.sol 123:         require(records[_nftId].tokens.length < maxHoldingsCount, "NRC: TOO_MANY_TOKENS"); //@audit should be inclusive ```  As length isn't 0 indexed, I believe, as an example to illustrate, that if `maxHoldingsCount == 1`, then `records[_nftId].tokens.length == 1` should be a passing condition. Therefore, I suggest changing `<` with `<=`  ## Variables   ### Missing Address(0) checks   ``` File: MixinOperatorResolver.sol 22:     constructor(address _resolver) { 23:         resolver = OperatorResolver(_resolver); //@audit missing address(0) check on immutable just like in the constructors in FeeSplitter.sol and NestedFactory.sol 24:     } ```  ### Check if a value is in an array before a push In `NestedRecords.sol`'s `store` function, it's possible to push an existing `address _token` several times in the same array  ``` File: NestedRecords.sol 130:         records[_nftId].tokens.push(_token); //@audit : should check existence ``` The previous lines of codes don't prevent this. The `store` function has the modifier `onlyFactory` and the only impact seem to be a possible maximization of `records[_nftId].tokens.length` (so that it reaches `maxHoldingsCount`).  ### Variables that should be grouped together in a struct   For maps that use the same key value: having separate fields is error prone (like in case of deletion or future new fields).   By regrouping, it's then possible to delete all related fields with a simple `delete newStruct[previousSameKeyForAllPreviousMaps]`.    #### File: FeeSplitter.sol 2 maps can be grouped together, as they use the same `_account` key:   ```   62:     struct TokenRecords { 63:         uint256 totalShares; 64:         uint256 totalReleased; 65:         mapping(address => uint256) shares; //@audit group  66:         mapping(address => uint256) released; //@audit group  67:     } ```   I'd suggest these 2 related data get grouped in a struct, let's name it `AccountInfo`:    ```   struct AccountInfo {        uint256 shares;        uint256 released;    }    ```   And it would be used in this manner (where `address` is `_account`):    ```        struct TokenRecords {         uint256 totalShares;         uint256 totalReleased;         mapping(address => AccountInfo) accountInfo;     }    ```    ## Arithmetics   ### Possible division by 0   There are no checks that the denominator is `!= 0` here:   ```   File: FeeSplitter.sol 327:     function _computeShareCount( 328:         uint256 _amount, 329:         uint256 _weight, 330:         uint256 _totalWeights 331:     ) private pure returns (uint256) { 332:         return (_amount * _weight) / _totalWeights; // @audit _totalWeights can be equal to 0, see FeeSplitter.sol:L184 333:     } ```  ## Revert Strings ### File: NestedFactory.sol #### Inconsistent Revert string ``` 44:         require(_exists(_tokenId), "URI query for nonexistent token"); ``` All other revert strings in `NestedAsset.sol` begin with `NA: `. Only this one doesn't. It's possible to gain consistency and still have an < 32 bytes size string with the following: `"NA: URI query - inexistent token"`  ### File: MixinOperatorResolver.sol #### Inconsistent Revert string (1) ``` 100:             require(tokens[0] == _outputToken, "OH: INVALID_OUTPUT_TOKEN");//@audit LOW comment : MOR like above ``` Here, `"OH: INVALID_OUTPUT_TOKEN"` should be replaced with `"MOR: INVALID_OUTPUT_TOKEN"`  #### Misleading + Inconsistent Revert string (2) ``` 101:             require(tokens[1] == _inputToken, "OH: INVALID_OUTPUT_TOKEN"); //@audit LOW comment : INVALID_INPUT_TOKEN //@audit LOW comment : MOR ``` Here, `"OH: INVALID_OUTPUT_TOKEN"` should be replaced with `"MOR: INVALID_INPUT_TOKEN"`  ### File: OwnableProxyDelegation.sol #### Inconsistent Revert string (1) ``` 25:         require(!initialized, "OFP: INITIALIZED"); //@audit low OFP doesn't make sense, use OPD instead (example: OwnableFactoryHandler is OFH, MixinOperatorResolver is MOR) ``` Is most contracts, the capital letters from the contract's name are used as a prefix in the revert strings (`OwnableFactoryHandler` has `OFH`, `MixinOperatorResolver` has `MOR`). Here, `OFP` doesn't really reflect `OwnableProxyDelegation`. It should be `OPD`.  #### Inconsistent Revert string (2) ``` 26:         require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, "OFP: FORBIDDEN");//@audit should be "OPD: FORBIDDEN"  ``` Same as above: `OFP` should be `OPD`.  ### File: ZeroExOperator.sol #### Inconsistent Revert string (1) ``` 32:         require(success, "ZEO: SWAP_FAILED"); ... 36:         require(amountBought != 0, "ZeroExOperator::performSwap: amountBought cant be zero"); //@audit LOW do like line 32 : "ZEO: amountBought cant be zero" < 32 bytes & consistent ``` As said before, the capital letters from the contract's name are used as a prefix in the revert strings. Here, the revert string's size is > 32 bytes and isn't using the same style as 4 lines above it. `ZeroExOperator::performSwap` should be `ZEO`.  #### Inconsistent Revert string (2) ``` 32:         require(success, "ZEO: SWAP_FAILED"); ... 37:         require(amountSold != 0, "ZeroExOperator::performSwap: amountSold cant be zero");//@audit do like line 32 : "ZEO: amountSold cant be zero" < 32 bytes & consistent ``` Same as above: `ZeroExOperator::performSwap` should be `ZEO`.  ## Comments ### File: NestedFactory.sol #### Missing comment "@return" (1) ``` 403:     /// @dev Call the operator to submit the order and add the output 404:     /// assets to the reserve (if needed). 405:     /// @param _inputToken Token used to make the orders 406:     /// @param _outputToken Expected output token 407:     /// @param _nftId The nftId 408:     /// @param _order The order calldata 409:     /// @param _toReserve True if the output is store in the reserve/records, false if not. //@audit missing @return  410:     function _submitOrder( 411:         address _inputToken, 412:         address _outputToken, 413:         uint256 _nftId, 414:         Order calldata _order, 415:         bool _toReserve 416:     ) private returns (uint256 amountSpent) { ```  #### Missing comment "@return" (2) ``` 474:     /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve 475:     ///      or the user wallet, to the factory. 476:     /// @param _nftId The NFT id 477:     /// @param _inputToken The token to receive 478:     /// @param _inputTokenAmount Amount to transfer 479:     /// @param _fromReserve True to transfer from the reserve 480:     /// @return Token transfered (in case of ETH) 481:     ///         The real amount received after the transfer to the factory //@audit missing @return (not the description, just the keyword) 482:     function _transferInputTokens( 483:         uint256 _nftId, 484:         IERC20 _inputToken, 485:         uint256 _inputTokenAmount, 486:         bool _fromReserve 487:     ) private returns (IERC20, uint256) { ```  #### Missing comment "@param" (1) ``` 562:     /// @dev Transfer from factory and collect fees 563:     /// @param _token The token to transfer 564:     /// @param _amount The amount (with fees) to transfer 565:     /// @param _dest The address receiving the funds //@audit missing @param 566:     function _safeTransferWithFees( 567:         IERC20 _token, 568:         uint256 _amount, 569:         address _dest, 570:         uint256 _nftId 571:     ) private { ```  ### File: NestedRecords.sol #### Missing comment "@return" (1) ``` 162:     /// @param _nftId The id of the NFT> //@audit missing @return 163:     function getAssetTokens(uint256 _nftId) public view returns (address[] memory) { ```  #### Missing comment "@return" (2) ``` 183:     /// @param _token The address of the token //@audit missing @return 184:     function getAssetHolding(uint256 _nftId, address _token) public view returns (uint256) { ```  #### Misleading comment on "@return" Here, the comment `@return The holdings`, which is the unique `@return` comment, suggests a returned `mapping(address => uint256) holdings` as seen on `struct NftRecord`. However, the function is actually returning a `uint256[]` and an `address[]`. Therefore, two `@return` are required and the previous one should be deleted.  Code: ``` 188:     /// @notice Returns the holdings associated to a NestedAsset 189:     /// @param _nftId the id of the NestedAsset 190:     /// @return The holdings //@audit "The holdings" suggests a "mapping(address => uint256)" but a uint256[] and an address[] are returned.   191:     function tokenHoldings(uint256 _nftId) public view returns (address[] memory, uint256[] memory) { ```  ### File: MixinOperatorResolver.sol #### Missing 2 comments "@param" & changeable "@return" comment/variable ```     /// @dev Build the calldata (with safe datas) and call the Operator     /// @param _order The order to execute //@audit missing @param _inputToken and @param _outputToken     /// @return success If the operator call is successful     /// @return amounts The amounts from the execution (used and received) //@audit why not use uint256[2]?     ///         - amounts[0] : The amount of output token     ///         - amounts[1] : The amount of input token USED by the operator (can be different than expected)     function callOperator(         INestedFactory.Order calldata _order,         address _inputToken,         address _outputToken     ) internal returns (bool success, uint256[] memory amounts) { ``` I suggest changing the returned uint256[] to uint256[2]  ### File: ExchangeHelpers.sol #### Missing comment "@return" ``` 10:     /// @dev Perform a swap between two tokens 11:     /// @param _sellToken Token to exchange 12:     /// @param _swapTarget The address of the contract that swaps tokens 13:     /// @param _swapCallData Call data provided by 0x to fill the quote //@audit missing @return 14:     function fillQuote( 15:         IERC20 _sellToken, 16:         address _swapTarget, 17:         bytes memory _swapCallData 18:     ) internal returns (bool) { ```
Use cached variable value  ## Impact  The `_submitOutOrders()` function sets `batchLength = _batchedOrders.orders.length`, but in the for loop the value "_batchedOrders.orders.length" is used instead of "batchLength". Using the cached variable could save gas.  ## Proof of Concept  The for loop on [line 369](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L369) could use the batchLength variable. This approach is used in the similar for loop on [line 327](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L327).  ## Recommended Mitigation Steps  Use the cached "batchLength" variable
* function transfer in NestedReserve is never used and can only be called by the factory (onlyFactory), so consider removing it because I think the factory uses a withdraw function from the Reserve.  * Currently never used: ```solidity   function setReserve onlyFactory ``` You can remove it to save some gas, or leave it if it was intended for future use with other factories.  * functions that add or remove operators or shareholders iterate over the whole array, so you can consider using EnumerableSet to store them: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol  * Could just use msg.sender and do not call an owner() function here: ```solidity     function unlockTokens(IERC20 _token) external override onlyOwner {         ...         _token.safeTransfer(owner(), amount); ```  * There are several functions that call _checkMsgValue. This function is quite expensive as it iterates over all the _batchedOrders and is only relevant when the inputToken is ETH. Later the callers will have to iterate over all the _batchedOrders again anyway, so I think this function should be refactored to significantly reduce gas. My suggestion: because processInputOrders and processInputAndOutputOrders both call _processInputOrders, the logic from _checkMsgValue could be moved to _processInputOrders. function create then can be refactored to re-use _processInputOrders. I see 2 discrepancies here: _fromReserve is always false when _submitInOrders is called from create (could be solved if _processInputOrders takes extra parameter), and _processInputOrders has this extra line: ```solidity   require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); ``` but this could be solved if you first mint the NFT and then invoke _processInputOrders from create.  * function withdraw calls nestedRecords twice: ```solidity  uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);  ...   address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];  ```  I think it could just substitute these links by first fetching all the tokens, and then calculating the length itself instead of making 2 external calls for pretty much the same data.    * Could use 'unchecked' maths here, as underflow is not possible: ```solidity    if (_amountToSpend > amounts[1]) {       IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);     } ```
-check `_metadataURI` !="" https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedAsset.sol#L106 `backfillTokenURI()` & `mintWithMetadata`was expected to change `tokenURI`. By not validating `metadataURI`!= "", it will just spend user gas more and nothing was changed
GAS :  1. Title: Unnecessary owner function call  Impact: In the `https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L134` it uses owner function call, instead of _owner, using _owner directly can save some gas  POC :  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L134  2. Title: It cheaper to remove the `&&` operator and make the 2 different require  POC :  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedAsset.sol#L78  Mitigation :  ``` require(_exists(_replicatedTokenId), "NA: INVALID_REPLICATED_TOKEN_ID"); require(tokenId != _replicatedTokenId, "NA: INVALID_REPLICATED_TOKEN_ID"); ```  3. Title : It Cheaper to use 0 instead of empty string  Impact : change bytes32("") to bytes32(0) can save +- 3 gas, both check for zero bytes32  POC :  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L101  Mitigation :   ``` require(operator != bytes32(0), "NF: INVALID_OPERATOR_NAME"); ```  4. Title : It cheaper to cached the operators to a memory instead use storage multiple times  Impact : In the `removeOperator` function it do the check in the loop by calling the operators storage, instead checking it with memory, multiple storage read is more expansive than doing multiple read from memory therefore saving the operator value to a memory first before checking inside a loop can make this call cheaper, just like `addOperator` function do.  POC :  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L111  Mitigation :  ``` function removeOperator(bytes32 operator) external override onlyOwner {         bytes32[] memory operatorsCache = operators;         uint256 operatorsLength = operatorsCache.length;         for (uint256 i = 0; i < operatorsLength; i++) {             if (operatorsCache[i] == operator) {                 operators[i] = operatorsCache[operatorsLength - 1];                 operators.pop();                 emit OperatorRemoved(operator);                 return;             }         }         revert("NF: NON_EXISTENT_OPERATOR");     } ``` 
## Nested Finance Gas Optimization Report  Unless otherwise noted, manual auditing and testing were done using Visual Studio Code and Remix. The sponsor-provided test suite was used to verify the findings.   The audit was done from February 10-12, 2022 by ye0lde through code4rena.  - [Nested Finance Gas Optimization Report](#nested-finance-gas-optimization-report) - [Findings](#findings)   - [G-1 - Function `store` can be more efficient (NestedRecords.sol)](#g-1---function-store-can-be-more-efficient-nestedrecordssol)   - [G-2 - Save gas and retain code clarity with the `unchecked` keyword (NestedFactory.sol)](#g-2---save-gas-and-retain-code-clarity-with-the-unchecked-keyword-nestedfactorysol)      ## Findings    ### G-1 - Function `store` can be more efficient (NestedRecords.sol)  #### Impact Caching the references to `records[_nftId]` in the `store` function will decrease gas usage as `store` is called frequently from NestedFactory.sol    Below are the relevant numbers from the sponsor's test suite before and after the change:  | Function     | Before (AVG) | After (AVG) |  | ----------- | ----------- | ----------- | | create     | 701747      | 701219 | | processInputAndOutputOrders   | 871716       |  871184 | | processInputOrders   | 406972       |  406779 | | processOutputOrders   | 449829       |  449712 | | store   | 83927       |  83684 |   #### Proof of Concept The `store` function is here: https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L111-L132  ```     function store(         uint256 _nftId,         address _token,         uint256 _amount,         address _reserve     ) external onlyFactory {         uint256 amount = records[_nftId].holdings[_token];         if (amount != 0) {             require(records[_nftId].reserve == _reserve, "NRC: RESERVE_MISMATCH");             updateHoldingAmount(_nftId, _token, amount + _amount);             return;         }         require(records[_nftId].tokens.length < maxHoldingsCount, "NRC: TOO_MANY_TOKENS");         require(             _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)),             "NRC: INVALID_RESERVE"         );           records[_nftId].holdings[_token] = _amount;         records[_nftId].tokens.push(_token);         records[_nftId].reserve = _reserve;     } ```  #### Recommended Mitigation Steps I suggest the following changes:  ```     function store(         uint256 _nftId,         address _token,         uint256 _amount,         address _reserve     ) external onlyFactory {          NftRecord storage nftRecord = records[_nftId];         uint256 amount = nftRecord.holdings[_token];         if (amount != 0) {             require(nftRecord.reserve == _reserve, "NRC: RESERVE_MISMATCH");             updateHoldingAmount(_nftId, _token, amount + _amount);             return;         }         require(nftRecord.tokens.length < maxHoldingsCount, "NRC: TOO_MANY_TOKENS");         require(             _reserve != address(0) && (_reserve == nftRecord.reserve || nftRecord.reserve == address(0)),             "NRC: INVALID_RESERVE"         );          nftRecord.holdings[_token] = _amount;         nftRecord.tokens.push(_token);         nftRecord.reserve = _reserve;     }  ``` ---  ### G-2 - Save gas and retain code clarity with the `unchecked` keyword (NestedFactory.sol)  #### Impact In a previous Code4rena audit, various "unchecked" optimizations were suggested.  Some of which were implemented and some were not because the sponsor's focus was code clarity over optimization.    I believe this suggestion meets the requirements for both optimization and clarity. Below are the relevant numbers from the sponsor's test suite before and after the change:  | Function     | Before (AVG) | After (AVG) |  | ----------- | ----------- | ----------- | | create     | 701747      | 701623 | | processInputAndOutputOrders   | 871716       |  871468 | | processInputOrders   | 406972       |  406784 |   #### Proof of Concept The code that can be `unchecked` is here: https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L339-L347  The "unchecked" keyword can be applied here since there is a `require` statement at #337 that ensures the arithmetic operations would not cause an integer underflow or overflow.  ``` uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;  if (underSpentAmount != 0) {      tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);  }    // If input is from the reserve, update the records   if (_fromReserve) {       _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);   } ```  #### Recommended Mitigation Steps Add `unchecked` around #L339-L347 as shown below.  ``` require(amountSpent <= _inputTokenAmount - feesAmount, "NF: OVERSPENT");  unchecked {     uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;      if (underSpentAmount != 0) {         tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);     }      // If input is from the reserve, update the records     if (_fromReserve) {         _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);     } } ``` ---     
1. considered using require instead of && can save gas https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L123 // gas cost 35473  Change to: ``` require(accountsLength != 0); require (accountsLength == _weights.length, "FS: INPUTS_LENGTH_MUST_MATCH"); ``` // gas cost 35465  ========================================================================  2. considered add unchecked can save gas https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L327 // gas cost 22798  add unchecked ``` unchecked { return (_amount * _weight) / _totalWeights; } ``` // gas cost 22440  ========================================================================  3. avoid unnecessary `i = 0` because the default of uint is already 0 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L126  considered removing 0 value can save gas  ========================================================================  4. `SafeERC20` Gas Optimization https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L19 by not declaring this ``` using SafeERC20 for IERC20; ```  and for example, use this: ``` SafeERC20.safeTransfer(IERC20(_inputToken)_msgSender(), _amountToSpend - amounts[1]); ```  ========================================================================  5. just read it directly to storage can save gas  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L279 // gas cost 24794  Change to: ``` Shareholder[] storage shareholdersCache = shareholders; ``` // gas cost 24684  ========================================================================  6. the original function will return 0 which a default value for uint256 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L216  // gas cost 24940  Change to: ```      function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];         if (_tokenRecords.totalShares != 0) {          uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));         return             (totalReceived * _tokenRecords.shares[_account]) /             _tokenRecords.totalShares -             _tokenRecords.released[_account];         }     } ``` // gas cost 24919  ========================================================================
## [N1] Unused imports  The following source units are imported but not referenced in the contract:  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/operators/Flat/FlatOperator.sol#L4-L4  ```solidity import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/operators/Flat/IFlatOperator.sol#L4-L4  ```solidity import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; ```  ### Recommendation  Check all imports and remove all unused/unreferenced and unnecessary imports.   ## [N2] Using `public` to generate the getter function can make the code simpler and cleaner  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/operators/ZeroEx/ZeroExStorage.sol#L7-L19  ```solidity contract ZeroExStorage is Ownable {     address private _swapTarget;      /// @notice Returns the address of 0x swaptarget     function swapTarget() external view returns (address) {         return _swapTarget;     }      /// @notice Update the address of 0x swaptarget     function updatesSwapTarget(address swapTargetValue) external onlyOwner {         _swapTarget = swapTargetValue;     } } ```  Can be changed to:  ```solidity contract ZeroExStorage is Ownable {     address public swapTarget;      /// @notice Update the address of 0x swaptarget     function updatesSwapTarget(address swapTargetValue) external onlyOwner {         swapTarget = swapTargetValue;     } } ```  ## [N3] Inconsistent use of `_msgSender()`  Direct use of `msg.sender` vs internal call of `_msgSender()`.  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/operators/ZeroEx/ZeroExOperator.sol#L17-L17  ```solidity ZeroExStorage(operatorStorage).transferOwnership(msg.sender); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/NestedReserve.sol#L30-L30  ```solidity _token.safeTransfer(msg.sender, _amount); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/abstracts/OwnableFactoryHandler.sol#L21-L21  ```solidity require(supportedFactories[msg.sender], "OFH: FORBIDDEN"); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/FeeSplitter.sol#L103-L103  ```solidity require(msg.sender == weth, "FS: ETH_SENDER_NOT_WETH"); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/FeeSplitter.sol#L166-L168  ```solidity amount = _releaseToken(_msgSender(), _tokens[i]); _tokens[i].safeTransfer(_msgSender(), amount); emit PaymentReleased(_msgSender(), address(_tokens[i]), amount); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/FeeSplitter.sol#L199-L199  ```solidity _token.safeTransferFrom(_msgSender(), address(this), _amount); ```  ### Recommendation  Consider replacing `_msgSender()` with `msg.sender` for consistency.
# rebuildCaches lack input validation `rebuildCaches` function will call `rebuildCache()` for arbitary destinations contract https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L74 ```     function rebuildCaches(MixinOperatorResolver[] calldata destinations) public {         for (uint256 i = 0; i < destinations.length; i++) {             destinations[i].rebuildCache();         }     } ```  # Event name must be in CamelCase https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L22 ```     event reserveUpdated(uint256 nftId, address newReserve); ```
## [L1] Check against same-token `swap`:  Assessed risk: 2/10  Urgency: N/A  Codebase frequency: 1  ### [L1 - Impact]:  Users would typically not swap against the same token, hence, developers must put in place a check against such swaps. Because of the rapid development and innovation that happens within the ETH smart contract ecosystem, one should never assume that what does not go wrong now will not go wrong in a few months, hence no exceptions are to be made when it comes to security and best practices.  ```bash function performSwap(   IERC20 sellToken,   IERC20 buyToken,   bytes calldata swapCallData ) external payable override returns (uint256[] memory amounts, address[] memory tokens) {     amounts = new uint256[](2);     tokens = new address[](2);     uint256 buyBalanceBeforePurchase = buyToken.balanceOf(address(this));     uint256 sellBalanceBeforePurchase = sellToken.balanceOf(address(this));   ... ```  ### [L1 - References]:  ```solidity operators/ZeroEx/ZeroExOperator.sol line 21 ```  ### [L1 - Mitigation]:  Adding a require statement would prevent such a swap.  ```bash require(buyToken != sellToken, "ERR: same token swap"); ```  ### [L2] Add `_weight != 0` check in FeeSplitter  Assessed risk: 2/10  Urgency: N/A  Codebase frequency: 1  ### [L2 - Impact]:  Keeping a consistent check among all functions of the contract that deal with `_weight` is important, both from the security and clean code philosophies. One of the functions implemented in `FeeSplitter.sol` does not check against the latest `_weight` to be different than `0`, contrary to all the similar functions that have this check.  ```bash function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {     require(_accountIndex < shareholders.length, "FS: INVALID_ACCOUNT_INDEX");     totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;     require(totalWeights != 0, "FS: TOTAL_WEIGHTS_ZERO");     shareholders[_accountIndex].weight = _weight;     emit ShareholderUpdated(shareholders[_accountIndex].account, _weight); } ```  ### [L2 - References]:  ```solidity FeeSplitter.sol line 134 ```  ### [L2 - Mitigation]:  Add a check against the `_weight` being 0.  ```bash require(_weight != 0, "FS: ZERO_WEIGHT"); ```
# Lines of code  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L71 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L286-L296 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L370-L375 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L482-L492   # Vulnerability details  ## Impact  Should a user accidentally send ETH to the `NestedFactory`, anyone can utilise it to their own benefit by calling `processOutputOrders()` / `processInputAndOutputOrders()`. This is possible because:  1. `receive()` has no restriction on the sender 2. `processOutputOrders()` does not check `msg.value`, and rightly so, because funds are expected to come from `reserve`. 3. `transferInputTokens()` does not handle the case where `ETH` could be specified as an address by the user for an output order.  ```jsx if (address(_inputToken) == ETH) {   require(address(this).balance >= _inputTokenAmount, "NF: INVALID_AMOUNT_IN");   weth.deposit{ value: _inputTokenAmount }();   return (IERC20(address(weth)), _inputTokenAmount); } ```  Hence, the attack vector is simple. Should a user accidentally send ETH to the contract, create an output `Order` with `token` being `ETH` and amount corresponding to the NestedFactory’s ETH balance.  ## Recommended Mitigation Steps  1. Since plain / direct`ETH` transfers are only expected to solely come from `weth` (excluding payable functions), we recommend restricting the sender to be `weth`, like how it is done in `[FeeSplitter](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L101-L104)`.          We are aware that this was raised previously here: https://github.com/code-423n4/2021-11-nested-findings/issues/188 and would like to add that the restricting the sender in the `receive()` function will not affect `payable` functions. From from what we see, plain ETH transfers are also not expected to come from other sources like `NestedReserve` or operators.       ```jsx receive() external payable {   require(msg.sender == address(weth), "NF: ETH_SENDER_NOT_WETH"); } ```  1. Check that `_fromReserve` is false in the scenario `address(_inputToken) == ETH`.  ```jsx if (address(_inputToken) == ETH) {   require(!_fromReserve, "NF: INVALID_INPUT_TOKEN");   require(address(this).balance >= _inputTokenAmount, "NF: INVALID_AMOUNT_IN");   weth.deposit{ value: _inputTokenAmount }();   return (IERC20(address(weth)), _inputTokenAmount); } ```  
# Codebase Impressions & Summary  As this is a mitigation contest, there were far less issues discovered. Overall, the contracts were well-documented and are of high quality. The high and medium severity issues raised previously are rectified in the new codebase while the low and non critical issues are either fixed or acknowledged.  # Non-Critical Findings  ## NC01: Inconsistent capitalization for event `reserveUpdated`  ### Line References  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L22](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L22)  ### Description  All declared events are in PascalCase except `reserveUpdated`.  ## NC02: Spelling Error  ### Line References  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L32-L33](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L32-L33)  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L37](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L37)  `weigth` → `weight`
## G01: Redundant variables / events  The following variables / events are initialized / declared, but their values are not used in the contract subsequently. Consider removing them.  ### Variables  ### Events  `[INestedFactory.ReserveUpdated](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/interfaces/INestedFactory.sol#L16-L18)`  ## G02: NestedFactory: Redundant `weth` casting  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L554](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L554)  `weth` is already of type `IWETH`, so the casting is redundant.  ## G03: NestedFactory: Shift `RESERVE_MISMATCH` checks in `_processInputOrders()` and `_processOutputOrders()` to external functions  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L271](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L271)  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L289](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L289)  The checks above can be shifted to the parent functions `processInputOrders()`, `processOutputOrders()` and `processInputAndOutputOrders()` to prevent a duplicate check in the combined function `processInputAndOutputOrders()`.  ## G04: NestedFactory: Use a locally scoped variable in `destroy()`  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L213-L219](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L213-L219)  Instead of calling `tokens[i]` multiple times, you can store it as a locally scoped variable and use the variable multiple times instead.  ## G05: FeeSplitter: Redundant check on `totalWeights` in `updateShareholder()`  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L137](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L137)  The check `require(totalWeights != 0, "FS: TOTAL_WEIGHTS_ZERO");` is redundant because `totalWeights` is minimally `royaltiesWeight`, and `royaltiesWeight` is strictly greater than zero when it is set.  ## G06: FeeSplitter: Replace nested loop in `setShareholders` with previous proposed solution of sorting array off-chain, or a mapping  [https://github.com/code-423n4/2021-11-nested-findings/issues/135](https://github.com/code-423n4/2021-11-nested-findings/issues/135)  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L120](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L120)  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L315](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L315)  `setShareholders()` iterates through all the accounts to be added but at each iteration, `_addShareholders()` iterates through all the previously added shareholders to ensure there are no duplicates. This nested loop is very expensive.   It would be more gas-efficient to sort the array off-chain first, then check that the next address is greater than the previous, as suggested in our initial finding.  Alternatively, use a mapping to check if a shareholder exists and if it doesn’t, then push it to the `shareholders` array. Note that in order to delete the mapping, you need to iterate through the old `shareholders` array and delete the mapping first before deleting the old `shareholders`.
# Lines of code  https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L99-L108 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L30-L47 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L110-L122 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L49-L55   # Vulnerability details  `NestedFactory` extends the `MixinOperatorResolver` contract which comes from the [`synthetix/MixinResolver.sol`](https://github.com/Synthetixio/synthetix/blob/a1786e5d64b5b51212785ade6d8b42435f69c387/contracts/MixinResolver.sol) code base where the expectation is that `isResolverCached()` returns false until [`rebuildCache()` is called and the cache is fully up to date](https://github.com/Synthetixio/synthetix/blob/a1786e5d64b5b51212785ade6d8b42435f69c387/test/contracts/MixinResolver.js#L82-L105). Due to [a medium issue](https://github.com/code-423n4/2021-11-nested-findings/issues/217) identified in a prior contest, the `OperatorResolver.importOperators()` step was made to be atomically combined with the `NestedFactory.rebuildCache()` step. However, the atomicity was not applied everywhere and the ability to add/remove operators from the `NestedFactory` also had other cache-inconsistency issues. There are *four separate instances* of operator tracking problems in this submission.  ## Impact As with the prior issue, many core operations (such as `NestedFactory.create()` and `NestedFactory.swapTokenForTokens()`) are dependant on the assumption that the `operatorCache` cache is synced prior to these functions being executed, but this may not necessarily be the case. Unlike the prior issue which was about updates to the resolver not getting reflected in the cache, this issue is about changes to the factory not updating the cache.  ## Proof of Concept  ### 1. `removeOperator()` does not call `rebuildCache()` 1. `NestedFactory.removeOperator()` is called to remove an operator 2. A user calls `NestedFactory(MixinOperatorResolver).create()` using that operator and succeedes 3. `NestedFactory.rebuildCache()` is called to rebuild cache This flow is not aware that the cache is not in sync  ```solidity     /// @inheritdoc INestedFactory     function addOperator(bytes32 operator) external override onlyOwner {         require(operator != bytes32(""), "NF: INVALID_OPERATOR_NAME");         bytes32[] memory operatorsCache = operators;         for (uint256 i = 0; i < operatorsCache.length; i++) {             require(operatorsCache[i] != operator, "NF: EXISTENT_OPERATOR");         }         operators.push(operator);         emit OperatorAdded(operator);     } ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L99-L108  ### 2. Using both `removeOperator()` and `rebuildCache()` does not prevent `create()` from using the operator Even if `removeOperator()` calls `rebuildCache()` the function will still not work because `resolverOperatorsRequired()` only keeps track of remaining operators, and `rebuildCache()` currently has no way of knowing that an entry was removed from that array and that a corresponding entry from `operatorCache` needs to be removed too.  ```solidity     /// @notice Rebuild the operatorCache     function rebuildCache() external {         bytes32[] memory requiredOperators = resolverOperatorsRequired();         bytes32 name;         IOperatorResolver.Operator memory destination;         // The resolver must call this function whenever it updates its state         for (uint256 i = 0; i < requiredOperators.length; i++) {             name = requiredOperators[i];             // Note: can only be invoked once the resolver has all the targets needed added             destination = resolver.getOperator(name);             if (destination.implementation != address(0)) {                 operatorCache[name] = destination;             } else {                 delete operatorCache[name];             }             emit CacheUpdated(name, destination);         }     } ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L30-L47  ### 3. `addOperator()` does not call `rebuildCache()` 1. `NestedFactory.addOperator()` is called to add an operator 2. A user calls `NestedFactory(MixinOperatorResolver).create()` using that operator and fails because the operator wasn't in the `resolverOperatorsRequired()` during the last call to `rebuildCaches()`, so the operator isn't in `operatorCache` 3. `NestedFactory.rebuildCache()` is called to rebuild cache This flow is not aware that the cache is not in sync  ```solidity     /// @inheritdoc INestedFactory     function removeOperator(bytes32 operator) external override onlyOwner {         uint256 operatorsLength = operators.length;         for (uint256 i = 0; i < operatorsLength; i++) {             if (operators[i] == operator) {                 operators[i] = operators[operatorsLength - 1];                 operators.pop();                 emit OperatorRemoved(operator);                 return;             }         }         revert("NF: NON_EXISTENT_OPERATOR");     } ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L110-L122  ### 4. `isResolverCached()` does not reflect the actual updated-or-not state This function, like `removeOperator()` is not able to tell that there is an operator that needs to be removed from `resolverCache`, causing the owner not to know a call to `rebuildCache()` is required to 'remove' the operator ```solidity     /// @notice Check the state of operatorCache     function isResolverCached() external view returns (bool) {         bytes32[] memory requiredOperators = resolverOperatorsRequired();         bytes32 name;         IOperatorResolver.Operator memory cacheTmp;         IOperatorResolver.Operator memory actualValue;         for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L49-L55  ## Tools Used Code inspection  ## Recommended Mitigation Steps Add calls to `rebuildCache()` in `addOperator()` and `removeOperator()`, have `INestedFactory` also track operators that have been removed with a new array, and have `isResolverCached()` also check whether this new array is empty or not.   
# 1. Prefix increaments are cheaper than postfix increaments # Vulnerability details  ## Impact The functions use prefix increaments (i ++) instead of postfix increaments (++ i). Prefix increaments are cheaper than postfix increaments.  ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L40 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L60 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L75 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L103 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L113 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L213 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L273 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L291 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L327 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L369 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L581 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L196 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L126 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L148 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L165 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L261 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L280 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L318 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L36 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L55  ``` for (uint256 i = 0; i < namesLength; i++) { ```  ## Tools Manual analysis  ## Recommended Mitigation Steps Change all prefix increaments to postfix increaments where it doesn't affects the functionality.   # 2. Unnecessary initialization of loop index variable # Vulnerability details   ## Impact For loop indices across the contract functions use explicit 0 initializations which are not required because the default value of uints is 0. Removing this explicit unnecessary initialization will save a little gas.  ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L40 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L60 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L75 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L103 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L113 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L153 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L213 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L273 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L291 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L327 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L369 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L196 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L318  ``` for (uint256 i = 0; i < namesLength; i++) { ```  ## Tools  Remix ## Recommended Mitigation Steps Remove unnecessary initialization of loop index variable  # 3. Cache array length in for loops can save gas # Vulnerability details ## Impact Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack. Caching the array length in the stack saves around 3 gas per iteration. ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L261 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L318 ``` function findShareholder(address _account) external view returns (uint256) {         for (uint256 i = 0; i < shareholders.length; i++) {             if (shareholders[i].account == _account) return i;         }         revert("FS: SHAREHOLDER_NOT_FOUND");     } ``` ## Tools  Manual ## Recommended Mitigation Steps Caching len = shareholders.length and using the len instead will save gas.  # 4. Adding unchecked directive can save gas  # Vulnerability details ## Impact For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks. ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L445-L446  https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L572   ## Tools  Manual analysis ## Recommended Mitigation Steps Consider using 'unchecked' where it is safe to do so.  # 5. Avoid use of state variables in event emissions to save gas # Vulnerability details  ## Impact Where possible, use equivalent function parameters or local variables in event emits instead of state variables to prevent expensive SLOADs. Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase. ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L55 ``` function setMaxHoldingsCount(uint256 _maxHoldingsCount) external onlyOwner {         require(_maxHoldingsCount != 0, "NRC: INVALID_MAX_HOLDINGS");         maxHoldingsCount = _maxHoldingsCount;         emit MaxHoldingsChanges(maxHoldingsCount);     } ``` ## Tools Manual analysis ## Recommended Mitigation Steps  # 6. Long Revert Strings # Vulnerability details  ## Impact Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L444 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/operators/ZeroEx/ZeroExOperator.sol#L36 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/operators/ZeroEx/ZeroExOperator.sol#L37 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/OwnableProxyDelegation.sol#L56  ```  require(amounts[1] <= _amountToSpend, "NestedFactory::_safeSubmitOrder: Overspent"); ``` ## Tools Manual analysis ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes. 
# Gas Report **Table of Contents:** - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [File: NestedRecords.sol](#file-nestedrecordssol)     - [function store()](#function-store)       - [Cache `records[_nftId].reserve`](#cache-records_nftidreserve)       - [Inclusive comparison](#inclusive-comparison)     - [function deleteAsset()](#function-deleteasset)       - [Unchecked block](#unchecked-block)   - [File: NestedFactory.sol](#file-nestedfactorysol)     - [function removeOperator()](#function-removeoperator)       - [Unchecked block](#unchecked-block-1)     - [function destroy()](#function-destroy)       - [Unchecked block (1)](#unchecked-block-1)       - [Unchecked block (2)](#unchecked-block-2)     - [function _submitInOrders()](#function-_submitinorders)       - [Unchecked block (1)](#unchecked-block-1-1)       - [Unchecked block (2)](#unchecked-block-2-1)     - [function _submitOutOrders()](#function-_submitoutorders)       - [Unchecked block (1)](#unchecked-block-1-2)       - [Unchecked block (2)](#unchecked-block-2-2)       - [Unchecked block (3)](#unchecked-block-3)       - [Unchecked block (4)](#unchecked-block-4)     - [function _safeSubmitOrder()](#function-_safesubmitorder)       - [Unchecked block](#unchecked-block-2)     - [function _transferToReserveAndStore()](#function-_transfertoreserveandstore)       - [Unchecked block](#unchecked-block-3)     - [function _transferInputTokens()](#function-_transferinputtokens)       - [Unchecked block](#unchecked-block-4)     - [function _safeTransferWithFees()](#function-_safetransferwithfees)       - [Unchecked block](#unchecked-block-5)   - [File: FeeSplitter.sol](#file-feesplittersol)     - [function updateShareholder()](#function-updateshareholder)       - [Cache `totalWeights`](#cache-totalweights)     - [function sendFees()](#function-sendfees)       - [Unchecked block](#unchecked-block-6)     - [function sendFeesWithRoyalties()](#function-sendfeeswithroyalties)       - [Unchecked block](#unchecked-block-7)       - [Cache `totalWeights`](#cache-totalweights-1)     - [function getAmountDue()](#function-getamountdue)       - [Cache `_tokenRecords.totalShares`](#cache-_tokenrecordstotalshares)     - [function _addShareholder()](#function-_addshareholder)       - [A private function used only once can get inlined](#a-private-function-used-only-once-can-get-inlined)   - [File: ZeroExOperator.sol](#file-zeroexoperatorsol)     - [function performSwap()](#function-performswap)       - [Unchecked block (1)](#unchecked-block-1-3)       - [Unchecked block (2)](#unchecked-block-2-3)   - [File: INestedFactory.sol](#file-inestedfactorysol)     - [Storage](#storage)       - [Tightly pack struct `BatchedInputOrders`](#tightly-pack-struct-batchedinputorders)       - [Tightly pack struct `BatchedOutputOrders`](#tightly-pack-struct-batchedoutputorders)       - [Only use 1 struct](#only-use-1-struct)   - [General recommendations](#general-recommendations)     - [Variables](#variables)       - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values)     - [Comparisons](#comparisons)     - [Amounts should be checked for 0 before calling a transfer](#amounts-should-be-checked-for-0-before-calling-a-transfer)     - [For-Loops](#for-loops)       - [`++i` costs less gas compared to `i++`](#i-costs-less-gas-compared-to-i)       - [Increments can be unchecked](#increments-can-be-unchecked)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)     - [Errors](#errors)       - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword - **Storage-reading optimizations** > The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). In the paragraphs below, please see the `@audit-issue` tags in the pieces of code's comments for more information about SLOADs that could be saved by caching the mentioned **storage** variables in **memory** variables.  - **Unchecking arithmetics operations that can't underflow/overflow** > Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block: https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  - **`@audit` tags** > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## File: NestedRecords.sol ### function store() ``` 111:     function store( ... 118:         if (amount != 0) { 119:             require(records[_nftId].reserve == _reserve, "NRC: RESERVE_MISMATCH"); //@audit records[_nftId].reserve SLOAD 1  120:             updateHoldingAmount(_nftId, _token, amount + _amount); 121:             return; 122:         } 123:         require(records[_nftId].tokens.length < maxHoldingsCount, "NRC: TOO_MANY_TOKENS"); //@audit should be inclusive 124:         require( 125:             _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)), //@audit records[_nftId].reserve SLOAD 1 & 2 126:             "NRC: INVALID_RESERVE" 127:         ); ... ``` #### Cache `records[_nftId].reserve` Caching this in memory can save around 1 SLOAD  #### Inclusive comparison By definition, `maxHoldingsCount` is the `The maximum number of holdings for an NFT record`.  Here, as an example, if `maxHoldingsCount == 1` and `records[_nftId].tokens.length == 1`, the function will revert.  I believe this check should be inclusive (like this `records[_nftId].tokens.length <= maxHoldingsCount`). This is both a Low-risk issue and a gas issue as `<` costs 3 more gas than `<=` due to the additional `ISZERO` opcode (even with the Optimizer)  ### function deleteAsset() ``` 88:     function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory { 89:         address[] storage tokens = records[_nftId].tokens; 90:         address token = tokens[_tokenIndex]; 91:  92:         require(records[_nftId].holdings[token] != 0, "NRC: HOLDING_INACTIVE"); 93:  94:         delete records[_nftId].holdings[token]; 95:         tokens[_tokenIndex] = tokens[tokens.length - 1]; //@audit gas: can't underflow 96:         tokens.pop(); 97:     }  ``` #### Unchecked block  If `tokens.length == 1`, all assets would be deleted. If `tokens.length == 0`, line 90 would've thrown an error and trigger a revert. As it's impossible for line 95 to underflow, it should be wrapped inside an `unchecked` block.  ## File: NestedFactory.sol ### function removeOperator() ``` 111:     function removeOperator(bytes32 operator) external override onlyOwner { 112:         uint256 operatorsLength = operators.length; 113:         for (uint256 i = 0; i < operatorsLength; i++) { 114:             if (operators[i] == operator) { 115:                 operators[i] = operators[operatorsLength - 1];  //@audit can't underflow ... ``` #### Unchecked block Line 115 can't underflow due to `operatorsLength > 0` (the for-loop wouldn't iterate otherwise). Therefore, line 115 should be wrapped inside an `unchecked` block.  ### function destroy() ``` 200:     function destroy( ... 211:         uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this)); 212:  213:         for (uint256 i = 0; i < tokensLength; i++) { 214:             uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]); 215:             reserve.withdraw(IERC20(tokens[i]), amount); 216:  217:             _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]); 218:             nestedRecords.freeHolding(_nftId, tokens[i]); 219:         } 220:  221:         // Amount calculation to send fees and tokens 222:         uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;//@audit can't underflow  223:         uint256 amountFees = amountBought / 100; // 1% Fee 224:         amountBought -= amountFees; //@audit can't underflow (equivalent to "amountBought = amountBought - (amountBought / 100)") ... ```  #### Unchecked block (1) As `buyTokenInitialBalance` is  `<=` to the final `_buyToken.balanceOf(address(this))`, line 222 can't underflow.  Therefore, line 222 should be wrapped inside an `unchecked` block.  #### Unchecked block (2) As `amountBought -= amountFees` is equivalent to `amountBought = amountBought - (amountBought / 100)`, the result can't underflow. Therefore, line 223 should be wrapped inside an `unchecked` block.  ### function _submitInOrders() ``` 311:     function _submitInOrders( ... 337:         require(amountSpent <= _inputTokenAmount - feesAmount, "NF: OVERSPENT"); 338:  339:         uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent; //@audit can't underflow 340:         if (underSpentAmount != 0) { 341:             tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount); 342:         } 343:  344:         // If input is from the reserve, update the records 345:         if (_fromReserve) { 346:             _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount); //@audit can't underflow 347:         } ... ```  #### Unchecked block (1) Line 339 can't underflow due to the require statement line 337.  Therefore, line 339 should be wrapped inside an `unchecked` block.  #### Unchecked block (2) As `underSpentAmount = _inputTokenAmount - feesAmount - amountSpent` (line 339): `_inputTokenAmount >= underSpentAmount`. Therefore, line 346 can't underflow and should be wrapped inside an `unchecked` block.  ### function _submitOutOrders() ``` 357:     function _submitOutOrders( ... 365:         amountBought = _batchedOrders.outputToken.balanceOf(address(this)); ... 385:             require(amountSpent <= _inputTokenAmount, "NF: OVERSPENT"); 386:  387:             uint256 underSpentAmount = _inputTokenAmount - amountSpent; //@audit can't underflow 388:             if (underSpentAmount != 0) { 389:                 _inputToken.safeTransfer(address(reserve), underSpentAmount); 390:             } 391:  392:             _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount); //@audit can't underflow 393:         } 394:  395:         amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought; //@audit can't underflow 396:         feesAmount = amountBought / 100; // 1% Fee //@audit HIGH free stuff under 100 ? Check on Remix. That's one of Secureum's audit findings 397:  398:         if (_toReserve) { 399:             _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);//@audit can't underflow 400:         } 401:     } ```  #### Unchecked block (1) Line 387 can't underflow due to the require statement line 385.  Therefore, line 387 should be wrapped inside an `unchecked` block.  #### Unchecked block (2) As `underSpentAmount = _inputTokenAmount - amountSpent`: `_inputTokenAmount >= underSpentAmount`. Therefore, line 392 can't underflow and should be wrapped inside an `unchecked` block.  #### Unchecked block (3) As the initial `_batchedOrders.outputToken.balanceOf(address(this))` line 365 is  `<=` to the final `_batchedOrders.outputToken.balanceOf(address(this))` line 395: line 395 can't underflow.  Therefore, line 395 should be wrapped inside an `unchecked` block.  #### Unchecked block (4) As `amountBought - feesAmount` is equivalent to `amountBought - (amountBought / 100)`, the result can't underflow. Therefore, line 399 should be wrapped inside an `unchecked` block.  ### function _safeSubmitOrder() ``` 435:     function _safeSubmitOrder( ... 445:             if (_amountToSpend > amounts[1]) { 446:                 IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]); //@audit should be unchecked (see L445) 447:             } ... ```  #### Unchecked block Line 446 can't underflow due to the require statement line 445.  Therefore, line 446 should be wrapped inside an `unchecked` block.  ### function _transferToReserveAndStore() ``` 458:     function _transferToReserveAndStore( 459:         IERC20 _token, 460:         uint256 _amount, 461:         uint256 _nftId 462:     ) private { 463:         address reserveAddr = address(reserve); 464:         uint256 balanceReserveBefore = _token.balanceOf(reserveAddr); 465:  466:         // Send output to reserve 467:         _token.safeTransfer(reserveAddr, _amount); 468:  469:         uint256 balanceReserveAfter = _token.balanceOf(reserveAddr); 470:  471:         nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);//@audit can't underflow 472:     } ```  #### Unchecked block As the initial `_token.balanceOf(reserveAddr)` is  `<=` to the final `_token.balanceOf(reserveAddr)`: line 471 can't underflow.  Therefore, line 471 should be wrapped inside an `unchecked` block.  ### function _transferInputTokens() ``` 482:     function _transferInputTokens( ... 494:         uint256 balanceBefore = _inputToken.balanceOf(address(this)); 495:         if (_fromReserve) { 496:             require( 497:                 nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount, 498:                 "NF: INSUFFICIENT_AMOUNT_IN" 499:             ); 500:             // Get input from reserve 501:             reserve.withdraw(IERC20(_inputToken), _inputTokenAmount); 502:         } else { 503:             _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount); 504:         } 505:         return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore); //@audit can't underflow 506:     } ```  #### Unchecked block As the initial `_inputToken.balanceOf(address(this))` is  `<=` to the final `_inputToken.balanceOf(address(this))`: line 505 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  ### function _safeTransferWithFees() ``` 566:     function _safeTransferWithFees( 567:         IERC20 _token, 568:         uint256 _amount, 569:         address _dest, 570:         uint256 _nftId 571:     ) private { 572:         uint256 feeAmount = _amount / 100; // 1% Fee 573:         _transferFeeWithRoyalty(feeAmount, _token, _nftId); 574:         _token.safeTransfer(_dest, _amount - feeAmount);//@audit can't underflow 575:     } ```  #### Unchecked block As `_amount - feeAmount` is equivalent to `_amount - (_amount / 100)`, the result can't underflow. Therefore, line 574 should be wrapped inside an `unchecked` block.  ## File: FeeSplitter.sol  ### function updateShareholder() ```) 134:     function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner { 135:         require(_accountIndex < shareholders.length, "FS: INVALID_ACCOUNT_INDEX"); 136:         totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight; //@audit cache 137:         require(totalWeights != 0, "FS: TOTAL_WEIGHTS_ZERO"); 138:         shareholders[_accountIndex].weight = _weight; 139:         emit ShareholderUpdated(shareholders[_accountIndex].account, _weight); 140:     } ``` #### Cache `totalWeights` It's possible to save around 1 SLOAD by caching `totalWeights` in memory, like this: ```) 134:     function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner { 135:         require(_accountIndex < shareholders.length, "FS: INVALID_ACCOUNT_INDEX"); 136:         uint256 _totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;  //@audit +MSTORE 137:         require(_totalWeights != 0, "FS: TOTAL_WEIGHTS_ZERO"); //@audit +MLOAD -SLOAD 138:         totalWeights = _totalWeights; //@audit +MLOAD 139:         shareholders[_accountIndex].weight = _weight; 140:         emit ShareholderUpdated(shareholders[_accountIndex].account, _weight); 141:     } ```  ### function sendFees() ``` 175:     function sendFees(IERC20 _token, uint256 _amount) external nonReentrant { 176:         uint256 weights; 177:         unchecked { 178:             weights = totalWeights - royaltiesWeight; 179:         } 180:  181:         uint256 balanceBeforeTransfer = _token.balanceOf(address(this)); 182:         _token.safeTransferFrom(_msgSender(), address(this), _amount);  183:  184:         _sendFees(_token, _token.balanceOf(address(this)) - balanceBeforeTransfer, weights); //@audit can't underflow (see L181 and L182) 185:     } ```  #### Unchecked block As the initial `_token.balanceOf(address(this))` is  `<=` to the final `_token.balanceOf(address(this))`: line 184 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  ### function sendFeesWithRoyalties() ``` 191:     function sendFeesWithRoyalties( ... 198:         uint256 balanceBeforeTransfer = _token.balanceOf(address(this)); 199:         _token.safeTransferFrom(_msgSender(), address(this), _amount); 200:         uint256 amountReceived = _token.balanceOf(address(this)) - balanceBeforeTransfer;  //@audit can't underflow 201:  202:         uint256 royaltiesAmount = _computeShareCount(amountReceived, royaltiesWeight, totalWeights); //@audit totalWeights SLOAD 1 203:  204:         _sendFees(_token, amountReceived, totalWeights);//@audit totalWeights SLOAD 2 ... ```  #### Unchecked block As the initial `_token.balanceOf(address(this))` is  `<=` to the final `_token.balanceOf(address(this))`: line 200 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  #### Cache `totalWeights`  Caching this in memory can save around 1 SLOAD  ### function getAmountDue() ``` 216:     function getAmountDue(address _account, IERC20 _token) public view returns (uint256) { 217:         TokenRecords storage _tokenRecords = tokenRecords[address(_token)]; 218:         if (_tokenRecords.totalShares == 0) return 0;//@audit _tokenRecords.totalShares SLOAD 1 219:  220:         uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this)); 221:         return 222:             (totalReceived * _tokenRecords.shares[_account]) / 223:             _tokenRecords.totalShares - //@audit _tokenRecords.totalShares SLOAD 2 224:             _tokenRecords.released[_account]; 225:     } ```  #### Cache `_tokenRecords.totalShares`  Caching this in memory can save around 1 SLOAD  ### function _addShareholder() #### A private function used only once can get inlined  As this private function is only used once line 127 in function setShareholders(), it can get inlined to save some gas.  ## File: ZeroExOperator.sol ### function performSwap() ``` 21:     function performSwap( ... 28:         uint256 buyBalanceBeforePurchase = buyToken.balanceOf(address(this)); 29:         uint256 sellBalanceBeforePurchase = sellToken.balanceOf(address(this)); 30:  31:         bool success = ExchangeHelpers.fillQuote(sellToken, operatorStorage.swapTarget(), swapCallData); 32:         require(success, "ZEO: SWAP_FAILED"); 33:  34:         uint256 amountBought = buyToken.balanceOf(address(this)) - buyBalanceBeforePurchase; //@audit can't underflow (see L28 and L31) 35:         uint256 amountSold = sellBalanceBeforePurchase - sellToken.balanceOf(address(this));//@audit can't underflow (see L29 and L31) 36:         require(amountBought != 0, "ZeroExOperator::performSwap: amountBought cant be zero"); //@audit-info move up 1 ? Will certainly cost more gas on happy path while saving some on sad path. Not a good trade-off 37:         require(amountSold != 0, "ZeroExOperator::performSwap: amountSold cant be zero"); ... ```  #### Unchecked block (1) As the initial `buyToken.balanceOf(address(this))` is  `<=` to the final `buyToken.balanceOf(address(this))`: line 34 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  #### Unchecked block (2) As the initial `sellToken.balanceOf(address(this))` is  `<=` to the final `sellToken.balanceOf(address(this))`: line 35 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  ## File: INestedFactory.sol ### Storage #### Tightly pack struct `BatchedInputOrders`  `struct BatchedInputOrders` can be tightly packed to save 1 storage slot by changing the code from this: ```     struct BatchedInputOrders {         IERC20 inputToken;//@audit 20 byte         uint256 amount; //@audit 32 byte         Order[] orders; //@audit fully takes slots         bool fromReserve; //@audit 1 byte     } ``` to this: ```     struct BatchedInputOrders {         IERC20 inputToken;//@audit 20 byte         bool fromReserve; //@audit 1 byte         uint256 amount; //@audit 32 byte         Order[] orders; //@audit fully takes slots     } ```  #### Tightly pack struct `BatchedOutputOrders`  `struct BatchedOutputOrders` can be tightly packed to save 1 storage slot by changing the code from this: ```     struct BatchedOutputOrders {         IERC20 outputToken;//@audit 20 byte         uint256[] amounts;//@audit 32 byte         Order[] orders;//@audit fully takes slots         bool toReserve;//@audit 1 byte     } ``` to this: ```     struct BatchedOutputOrders {         IERC20 outputToken;//@audit 20 byte         bool toReserve;//@audit 1 byte         uint256[] amounts;//@audit 32 byte         Order[] orders;//@audit fully takes slots     } ```  #### Only use 1 struct  In my opinion, the structs here are used in an unintended way: it's not up to a struct to carry the input/output concept here.  It's possible to use only 1 struct for the whole logic, as such: ```     struct BatchedOrders {         IERC20 token;         bool hasReserve;         uint256[] amounts;         Order[] orders;     } ``` And then declare input and output variables with this, like: `BatchedOrders[] _batchedInputOrders` or `BatchedOrders[] _batchedOutputOrders`.  Same struct, different variables.  I suggest going from: ``` NestedFactory.sol:   141:     function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)   162:     function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)   176:     function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)   190:         BatchedInputOrders[] calldata _batchedInputOrders,   191:         BatchedOutputOrders[] calldata _batchedOutputOrders   193:         _checkMsgValue(_batchedInputOrders);   194:         _processInputOrders(_nftId, _batchedInputOrders);   195:         _processOutputOrders(_nftId, _batchedOutputOrders);   268:     function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {   286:     function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {   313:         BatchedInputOrders calldata _batchedOrders,   359:         BatchedOutputOrders calldata _batchedOrders,   579:     function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {  interfaces\INestedFactory.sol:   106:     function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders) external payable;   111:     function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) external payable;   116:     function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) external;   120:     /// @param _batchedInputOrders The input orders to execute (first)   121:     /// @param _batchedOutputOrders The output orders to execute (after)   124:         BatchedInputOrders[] calldata _batchedInputOrders,   125:         BatchedOutputOrders[] calldata _batchedOutputOrders ``` to ``` NestedFactory.sol:   141:     function create(uint256 _originalTokenId, BatchedOrders[] calldata _batchedInputOrders)   162:     function processInputOrders(uint256 _nftId, BatchedOrders[] calldata _batchedInputOrders)   176:     function processOutputOrders(uint256 _nftId, BatchedOrders[] calldata _batchedOutputOrders)   190:         BatchedOrders[] calldata _batchedInputOrders,   191:         BatchedOrders[] calldata _batchedOutputOrders   193:         _checkMsgValue(_batchedInputOrders);   194:         _processInputOrders(_nftId, _batchedInputOrders);   195:         _processOutputOrders(_nftId, _batchedOutputOrders);   268:     function _processInputOrders(uint256 _nftId, BatchedOrders[] calldata _batchedInputOrders) private {   286:     function _processOutputOrders(uint256 _nftId, BatchedOrders[] calldata _batchedOutputOrders) private {   313:         BatchedOrders calldata _batchedInputOrders,   359:         BatchedOrders calldata _batchedOutputOrders,   579:     function _checkMsgValue(BatchedOrders[] calldata _batchedInputOrders) private {  interfaces\INestedFactory.sol:   106:     function create(uint256 _originalTokenId, BatchedOrders[] calldata _batchedInputOrders) external payable;   111:     function processInputOrders(uint256 _nftId, BatchedOrders[] calldata _batchedInputOrders) external payable;   116:     function processOutputOrders(uint256 _nftId, BatchedOrders[] calldata _batchedOutputOrders) external;   124:         BatchedOrders[] calldata _batchedInputOrders,   125:         BatchedOrders[] calldata _batchedOutputOrders ```  ## General recommendations ### Variables #### No need to explicitly initialize variables with default values   If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.   As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Instances include:   ``` abstracts\MixinOperatorResolver.sol:36:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts\MixinOperatorResolver.sol:55:        for (uint256 i = 0; i < requiredOperators.length; i++) { FeeSplitter.sol:126:        for (uint256 i = 0; i < accountsLength; i++) { FeeSplitter.sol:148:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:165:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:261:        for (uint256 i = 0; i < shareholders.length; i++) { FeeSplitter.sol:280:        for (uint256 i = 0; i < shareholdersCache.length; i++) { FeeSplitter.sol:318:        for (uint256 i = 0; i < shareholders.length; i++) { NestedFactory.sol:103:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:113:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:153:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:213:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:273:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:291:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:327:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) { NestedFactory.sol:581:        for (uint256 i = 0; i < _batchedOrders.length; i++) { NestedRecords.sol:71:            uint256 tokenIndex = 0; NestedRecords.sol:196:        for (uint256 i = 0; i < tokensCount; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```   I suggest removing explicit initializations for default values.  ### Comparisons ### Amounts should be checked for 0 before calling a transfer Checking non-zero transfer values can avoid an expensive external call and save gas.    Places I suggest adding a non-zero-value check:   ```   FeeSplitter.sol:155:                _tokens[i].safeTransfer(_msgSender(), amount); FeeSplitter.sol:167:            _tokens[i].safeTransfer(_msgSender(), amount); FeeSplitter.sol:182:        _token.safeTransferFrom(_msgSender(), address(this), _amount); FeeSplitter.sol:199:        _token.safeTransferFrom(_msgSender(), address(this), _amount); NestedFactory.sol:134:        _token.safeTransfer(owner(), amount); NestedFactory.sol:467:        _token.safeTransfer(reserveAddr, _amount); NestedFactory.sol:503:            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount); NestedFactory.sol:558:            _token.safeTransfer(_dest, _amount); NestedFactory.sol:574:        _token.safeTransfer(_dest, _amount - feeAmount); NestedReserve.sol:23:        _token.safeTransfer(_recipient, _amount); NestedReserve.sol:30:        _token.safeTransfer(msg.sender, _amount); ```    ### For-Loops #### `++i` costs less gas compared to `i++` `++i` costs less gas compared to `i++` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration)    `i++` increments `i` and returns the initial value of `i`. Which means:      ``` uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ``` uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:   ``` abstracts\MixinOperatorResolver.sol:36:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts\MixinOperatorResolver.sol:55:        for (uint256 i = 0; i < requiredOperators.length; i++) { FeeSplitter.sol:126:        for (uint256 i = 0; i < accountsLength; i++) { FeeSplitter.sol:148:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:165:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:261:        for (uint256 i = 0; i < shareholders.length; i++) { FeeSplitter.sol:280:        for (uint256 i = 0; i < shareholdersCache.length; i++) { FeeSplitter.sol:318:        for (uint256 i = 0; i < shareholders.length; i++) { NestedFactory.sol:103:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:113:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:153:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:213:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:273:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:291:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:327:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) { NestedFactory.sol:581:        for (uint256 i = 0; i < _batchedOrders.length; i++) { NestedRecords.sol:78:                tokenIndex++; NestedRecords.sol:196:        for (uint256 i = 0; i < tokensCount; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```   I suggest using `++i` instead of `i++` to increment the value of an uint variable.  #### Increments can be unchecked In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Instances include:   ``` abstracts\MixinOperatorResolver.sol:36:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts\MixinOperatorResolver.sol:55:        for (uint256 i = 0; i < requiredOperators.length; i++) { FeeSplitter.sol:126:        for (uint256 i = 0; i < accountsLength; i++) { FeeSplitter.sol:148:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:165:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:261:        for (uint256 i = 0; i < shareholders.length; i++) { FeeSplitter.sol:280:        for (uint256 i = 0; i < shareholdersCache.length; i++) { FeeSplitter.sol:318:        for (uint256 i = 0; i < shareholders.length; i++) { NestedFactory.sol:103:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:113:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:153:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:213:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:273:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:291:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:327:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) { NestedFactory.sol:581:        for (uint256 i = 0; i < _batchedOrders.length; i++) { NestedRecords.sol:78:                tokenIndex++; NestedRecords.sol:196:        for (uint256 i = 0; i < tokensCount; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```   The code would go from:      ``` for (uint256 i; i < numIterations; i++) {    // ...   }   ``` to:   ``` for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ``` The risk of overflow is inexistant for a `uint256` here.  #### An array's length should be cached to save gas in for-loops Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead: ``` abstracts\MixinOperatorResolver.sol:36:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts\MixinOperatorResolver.sol:55:        for (uint256 i = 0; i < requiredOperators.length; i++) { FeeSplitter.sol:148:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:165:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:261:        for (uint256 i = 0; i < shareholders.length; i++) { FeeSplitter.sol:280:        for (uint256 i = 0; i < shareholdersCache.length; i++) { FeeSplitter.sol:318:        for (uint256 i = 0; i < shareholders.length; i++) { NestedFactory.sol:103:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) { NestedFactory.sol:581:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  ### Errors  #### Reduce the size of error messages (Long revert Strings) Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.   Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   Revert strings > 32 bytes are here:   ``` abstracts\OwnableProxyDelegation.sol:56:        require(newOwner != address(0), "Ownable: new owner is the zero address"); operators\ZeroEx\ZeroExOperator.sol:36:        require(amountBought != 0, "ZeroExOperator::performSwap: amountBought cant be zero"); operators\ZeroEx\ZeroExOperator.sol:37:        require(amountSold != 0, "ZeroExOperator::performSwap: amountSold cant be zero"); NestedFactory.sol:444:            require(amounts[1] <= _amountToSpend, "NestedFactory::_safeSubmitOrder: Overspent");  ```  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next.  #### Use Custom Errors instead of Revert Strings to save Gas Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: https://blog.soliditylang.org/2021/04/21/custom-errors/: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:   ``` abstracts\MixinOperatorResolver.sol:76:        require(_foundAddress.implementation != address(0), string(abi.encodePacked("MOR: MISSING_OPERATOR: ", name))); abstracts\MixinOperatorResolver.sol:100:            require(tokens[0] == _outputToken, "OH: INVALID_OUTPUT_TOKEN"); abstracts\MixinOperatorResolver.sol:101:            require(tokens[1] == _inputToken, "OH: INVALID_OUTPUT_TOKEN"); abstracts\OwnableFactoryHandler.sol:21:        require(supportedFactories[msg.sender], "OFH: FORBIDDEN"); abstracts\OwnableFactoryHandler.sol:28:        require(_factory != address(0), "OFH: INVALID_ADDRESS"); abstracts\OwnableFactoryHandler.sol:36:        require(supportedFactories[_factory], "OFH: NOT_SUPPORTED"); abstracts\OwnableProxyDelegation.sol:25:        require(!initialized, "OFP: INITIALIZED"); abstracts\OwnableProxyDelegation.sol:26:        require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, "OFP: FORBIDDEN"); abstracts\OwnableProxyDelegation.sol:40:        require(owner() == _msgSender(), "Ownable: caller is not the owner"); abstracts\OwnableProxyDelegation.sol:56:        require(newOwner != address(0), "Ownable: new owner is the zero address"); operators\Flat\FlatOperator.sol:18:        require(amount != 0, "FO: INVALID_AMOUNT"); operators\ZeroEx\ZeroExOperator.sol:32:        require(success, "ZEO: SWAP_FAILED"); operators\ZeroEx\ZeroExOperator.sol:36:        require(amountBought != 0, "ZeroExOperator::performSwap: amountBought cant be zero"); operators\ZeroEx\ZeroExOperator.sol:37:        require(amountSold != 0, "ZeroExOperator::performSwap: amountSold cant be zero"); FeeSplitter.sol:94:        require(_weth != address(0), "FS: INVALID_ADDRESS"); FeeSplitter.sol:103:        require(msg.sender == weth, "FS: ETH_SENDER_NOT_WETH"); FeeSplitter.sol:111:        require(_weight != 0, "FS: WEIGHT_ZERO"); FeeSplitter.sol:123:        require(accountsLength != 0 && accountsLength == _weights.length, "FS: INPUTS_LENGTH_MUST_MATCH"); FeeSplitter.sol:135:        require(_accountIndex < shareholders.length, "FS: INVALID_ACCOUNT_INDEX"); FeeSplitter.sol:137:        require(totalWeights != 0, "FS: TOTAL_WEIGHTS_ZERO"); FeeSplitter.sol:153:                require(success, "FS: ETH_TRANFER_ERROR"); FeeSplitter.sol:196:        require(_royaltiesTarget != address(0), "FS: INVALID_ROYALTIES_TARGET"); FeeSplitter.sol:306:        require(amountToRelease != 0, "FS: NO_PAYMENT_DUE"); FeeSplitter.sol:316:        require(_weight != 0, "FS: ZERO_WEIGHT"); FeeSplitter.sol:317:        require(_account != address(0), "FS: INVALID_ADDRESS"); FeeSplitter.sol:319:            require(shareholders[i].account != _account, "FS: ALREADY_SHAREHOLDER"); NestedAsset.sol:34:        require(_address == ownerOf(_tokenId), "NA: FORBIDDEN_NOT_OWNER"); NestedAsset.sol:44:        require(_exists(_tokenId), "URI query for nonexistent token"); NestedAsset.sol:78:        require(_exists(_replicatedTokenId) && tokenId != _replicatedTokenId, "NA: INVALID_REPLICATED_TOKEN_ID"); NestedAsset.sol:111:        require(bytes(tokenURI(_tokenId)).length == 0, "NA: TOKEN_URI_IMMUTABLE"); NestedFactory.sol:54:        require( NestedFactory.sol:78:        require(nestedAsset.ownerOf(_nftId) == _msgSender(), "NF: CALLER_NOT_OWNER"); NestedFactory.sol:86:        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), "NF: LOCKED_NFT"); NestedFactory.sol:101:        require(operator != bytes32(""), "NF: INVALID_OPERATOR_NAME"); NestedFactory.sol:104:            require(operatorsCache[i] != operator, "NF: EXISTENT_OPERATOR"); NestedFactory.sol:126:        require(address(_feeSplitter) != address(0), "NF: INVALID_FEE_SPLITTER_ADDRESS"); NestedFactory.sol:148:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:207:        require(_orders.length != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:208:        require(tokensLength == _orders.length, "NF: INPUTS_LENGTH_MUST_MATCH"); NestedFactory.sol:209:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:243:        require(assetTokensLength > _tokenIndex, "NF: INVALID_TOKEN_INDEX"); NestedFactory.sol:245:        require(assetTokensLength > 1, "NF: UNALLOWED_EMPTY_PORTFOLIO"); NestedFactory.sol:246:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:270:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:271:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:288:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:289:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:317:        require(batchLength != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:337:        require(amountSpent <= _inputTokenAmount - feesAmount, "NF: OVERSPENT"); NestedFactory.sol:363:        require(batchLength != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:364:        require(_batchedOrders.amounts.length == batchLength, "NF: INPUTS_LENGTH_MUST_MATCH"); NestedFactory.sol:385:            require(amountSpent <= _inputTokenAmount, "NF: OVERSPENT"); NestedFactory.sol:418:        require(success, "NF: OPERATOR_CALL_FAILED"); NestedFactory.sol:444:            require(amounts[1] <= _amountToSpend, "NestedFactory::_safeSubmitOrder: Overspent"); NestedFactory.sol:489:            require(address(this).balance >= _inputTokenAmount, "NF: INVALID_AMOUNT_IN"); NestedFactory.sol:496:            require( NestedFactory.sol:556:            require(success, "NF: ETH_TRANSFER_ERROR"); NestedFactory.sol:586:        require(msg.value == ethNeeded, "NF: WRONG_MSG_VALUE"); NestedRecords.sol:53:        require(_maxHoldingsCount != 0, "NRC: INVALID_MAX_HOLDINGS"); NestedRecords.sol:92:        require(records[_nftId].holdings[token] != 0, "NRC: HOLDING_INACTIVE"); NestedRecords.sol:119:            require(records[_nftId].reserve == _reserve, "NRC: RESERVE_MISMATCH"); NestedRecords.sol:123:        require(records[_nftId].tokens.length < maxHoldingsCount, "NRC: TOO_MANY_TOKENS"); NestedRecords.sol:124:        require( NestedRecords.sol:140:        require(_timestamp > records[_nftId].lockTimestamp, "NRC: LOCK_PERIOD_CANT_DECREASE"); NestedReserve.sol:22:        require(_recipient != address(0), "NRS: INVALID_ADDRESS"); OperatorResolver.sol:27:        require(_foundOperator.implementation != address(0), reason); OperatorResolver.sol:39:        require(namesLength == destinations.length, "OR: INPUTS_LENGTH_MUST_MATCH"); OperatorResolver.sol:57:        require(names.length == operatorsToImport.length, "OR: INPUTS_LENGTH_MUST_MATCH"); ```  I suggest replacing revert strings with custom errors.  
Gas fee improvement https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L100 there is no need to use extra variable operatorsCache to check if operator exists.   https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L111 In the removeOperator function, no need for this line uint256 operatorsLength = operators.length; Use operators.length directly in the loop  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L177 getAssetTokensLength() function is not called from the contract. If not needed it can removed or should be made external  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L191 Function tokenHoldings() is not called from within the contract. If not needed it can be removed or should be made external  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedAsset.sol#L52 Function originalOwner() is not called from within the contract. If not needed it can be removed or should be made external  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/OperatorResolver.sol#L16 Add empty string check for this function  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/OperatorResolver.sol#L57 If bith names.length and operatorsToImport.length == 0, this check passes. Consider adding empty check to both structures  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L204 Nested _addShare _sendFees calls _addShare But in sendFeesWithRoyalties(), _addShare is called again after _sendFees. This can lead to nested executed. Please consider refactoring this code.
# Lines of code  https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L42-L43   # Vulnerability details  ## Impact The logic related to the `areOperatorsImported` method is incorrect and can cause an operator not to be updated because the owner thinks it is already updated, and a vulnerable or defective one can be used.  ## Proof of Concept The `operators` mapping is made up of a key `bytes32 name` and a value made up of two values: `implementation` and `selector`, both of which identify the contract and function to be called when an operator is invoked.  The `areOperatorsImported` method tries to check if the operators to check already exist, however, the check is not done correctly, since && is used instead of ||.  If the operator with name `A` and value `{implementation=0x27f8d03b3a2196956ed754badc28d73be8830a6e,selector="performSwapVulnerable"}` exists, and the owner try to check if the operator with name `A` and value `{implementation=0x27f8d03b3a2196956ed754badc28d73be8830a6e,selector="performSwapFixed"}` exists, that function will return `true`, and the owner may decide not to import it , producing unexpected errors. Because operators manage the tokens, this error can produce a token lost.  ## Recommended Mitigation Steps Change && by ||    
## Missing token whitelisting puts stakeholders on risk  Contract: https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L146  1. Attacker can call sendFees with a malicious token contract   2. This increases the share balance of malicious token for each stake holder  3. When stakeholders tries to withdraw there share of malicious token using releaseTokens, malicious contract will be called and code written by attacker will be executed (asking for unauthorized approvals, wasting Gas etc)  ## sendFees & sendFeesWithRoyalties not handling ETH token  Contract: https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L175  1. Both sendFees & sendFeesWithRoyalties are not considering if the input _token is ETH as done in releaseTokens  ## Incorrect return message  Contract: https://github.com/code-423n4/2022-02-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L101  1. The require statement incorrectly mentions INVALID_OUTPUT_TOKEN when it should be INVALID_INPUT_TOKEN
## https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol (#L191, #L149, #L166)  1. In sendFeesWithRoyalties, releaseTokens, releaseTokensNoETH function, add check amount!=0  ``` require(amount!=0, "Incorrect amount"); ```  ## https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L76  1. In updateHoldingAmount function, under the while loop, use return instead of break  ``` if (tokens[tokenIndex] == _token) {                     ...                     return;                 } ```  ## https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L317  1.  No need to check require(batchLength != 0, "NF: INVALID_ORDERS"); as this is already checked in all the calling functions like create, _processInputOrders  ## https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L445  1. The condition if (_amountToSpend > amounts[1])  is not required as the parent condition is already checking for require(amounts[1] <= _amountToSpend, "NestedFactory::_safeSubmitOrder: Overspent");
Title: State variables that could be set immutable Severity: GAS  In the following files there are state variables that could be set immutable to save gas.           operator in TestableOperatorCaller.sol         resolver in MixinOperatorResolver.sol         operatorStorage in ZeroExOperator.sol    Title: Unused state variables Severity: GAS  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           TestableMixingOperatorResolver.sol, addressesToCache    Title: Unused declared local variables Severity: GAS  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           TestableOperatorCaller.sol, performSwap, data    Title: Unnecessary array boundaries check when loading an array element twice Severity: GAS       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:               NestedFactory.sol._processOutputOrders - double load of _batchedOrders[i]         NestedFactory.sol._processInputOrders - double load of _batchedOrders[i]    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           FeeSplitter.sol, _tokens, 148         MixinOperatorResolver.sol, requiredOperators, 55         NestedFactory.sol, operatorsCache, 103         NestedFactory.sol, orders._batchedOrders, 369         FeeSplitter.sol, shareholders, 261         FeeSplitter.sol, shareholdersCache, 280         FeeSplitter.sol, shareholders, 318         OperatorResolver.sol, names, 60         FeeSplitter.sol, _tokens, 165         OperatorResolver.sol, destinations, 75         MixinOperatorResolver.sol, requiredOperators, 36         NestedFactory.sol, _batchedOrders, 581    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: NestedFactory.sol, i, 153         change to prefix increment and unchecked: MixinOperatorResolver.sol, i, 55         change to prefix increment and unchecked: NestedFactory.sol, i, 103         change to prefix increment and unchecked: NestedFactory.sol, i, 327         change to prefix increment and unchecked: NestedRecords.sol, i, 196         change to prefix increment and unchecked: FeeSplitter.sol, i, 148         change to prefix increment and unchecked: FeeSplitter.sol, i, 318         change to prefix increment and unchecked: OperatorResolver.sol, i, 40         change to prefix increment and unchecked: OperatorResolver.sol, i, 60         change to prefix increment and unchecked: FeeSplitter.sol, i, 280         change to prefix increment and unchecked: FeeSplitter.sol, i, 165         change to prefix increment and unchecked: FeeSplitter.sol, i, 261         change to prefix increment and unchecked: MixinOperatorResolver.sol, i, 36         change to prefix increment and unchecked: NestedFactory.sol, i, 273         change to prefix increment and unchecked: NestedFactory.sol, i, 213         change to prefix increment and unchecked: NestedFactory.sol, i, 369         change to prefix increment and unchecked: NestedFactory.sol, i, 581         change to prefix increment and unchecked: OperatorResolver.sol, i, 75         change to prefix increment and unchecked: FeeSplitter.sol, i, 126         change to prefix increment and unchecked: NestedFactory.sol, i, 113         change to prefix increment and unchecked: NestedFactory.sol, i, 291    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          MixinOperatorResolver.sol, 36         NestedFactory.sol, 153         OperatorResolver.sol, 75         NestedFactory.sol, 273         OperatorResolver.sol, 60         NestedFactory.sol, 213         FeeSplitter.sol, 318         MixinOperatorResolver.sol, 55         FeeSplitter.sol, 261         NestedFactory.sol, 291         NestedFactory.sol, 113         OperatorResolver.sol, 40         NestedFactory.sol, 369         NestedFactory.sol, 581         FeeSplitter.sol, 126         FeeSplitter.sol, 280         NestedFactory.sol, 103         FeeSplitter.sol, 165         NestedFactory.sol, 327         FeeSplitter.sol, 148         NestedRecords.sol, 196    Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          MixinOperatorResolver.sol, callOperator         NestedAsset.sol, _setTokenURI         ExchangeHelpers.sol, setMaxAllowance         ExchangeHelpers.sol, fillQuote         MixinOperatorResolver.sol, requireAndGetAddress    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           DeflationaryMockERC20.sol, transferFrom         TestableMixingOperatorResolver.sol, resolverOperatorsRequired         NestedRecords.sol, tokenHoldings         NestedAsset.sol, originalOwner         NestedRecords.sol, getAssetTokensLength         NestedRecords.sol, freeHolding         NestedAsset.sol, tokenURI         OwnableProxyDelegation.sol, renounceOwnership         OwnableProxyDelegation.sol, owner         OwnableProxyDelegation.sol, transferOwnership    Title: Unnecessary payable Severity: GAS  The following functions are payable but msg.value isn't used - therefore the function payable state modifier isn't necessary. Payable functions are more gas expensive than others, and it's danger the users if they send ETH by mistake.           ZeroExOperator.sol, performSwap is payable but doesn't use msg.value         FlatOperator.sol, transfer is payable but doesn't use msg.value    Title: Rearrange state variables Severity: GAS  You can change the order of the storage variables to decrease memory uses.  In OwnableProxyDelegation.sol,rearranging the storage fields can optimize to: 2 slots from: 3 slots. The new order of types (you choose the actual variables):         1. bytes32         2. address         3. bool     Title: Short the following require messages Severity: GAS  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: OwnableProxyDelegation.sol, In line 56, Require message length to shorten: 38, The message: Ownable: new owner is the zero address    Title: Unused imports Severity: GAS   In the following files there are contract imports that aren't used Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore)          IFlatOperator.sol, line 3, import "@openzeppelin/contracts/token/ERC20/IERC20.sol";         FlatOperator.sol, line 3, import "@openzeppelin/contracts/token/ERC20/IERC20.sol";         INestedFactory.sol, line 4, import "../NestedReserve.sol";    Title: Unused inheritance Severity: GAS       Some of your contract inherent contracts but aren't use them at all.     We recommend not to inherent those contracts.              NestedAsset.sol; the inherited contracts OwnableFactoryHandler not used         NestedReserve.sol; the inherited contracts OwnableFactoryHandler not used         NestedRecords.sol; the inherited contracts OwnableFactoryHandler not used    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           NestedFactory.sol, 489: change 'balance > 0' to 'balance != 0'    Title: Unnecessary constructor Severity: GAS  The following constructors are empty.      (A similar issue https://github.com/code-423n4/2021-11-fei-findings/issues/12)              TestableMixingOperatorResolver.sol.constructor         NestedAsset.sol.constructor    Title: Unnecessary functions Severity: GAS       The following functions are not used at all. Therefore you can remove them to save deployment gas and improve code clearness.                   MixinOperatorResolver.sol, callOperator         ExchangeHelpers.sol, fillQuote    Title: Unnecessary cast Severity: Gas                IERC20 NestedFactory.sol._transferInputTokens - unnecessary casting IERC20(_inputToken)    Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               NestedAsset.backfillTokenURI (_metadataURI)         ExchangeHelpers.fillQuote (_swapCallData)         NestedAsset._setTokenURI (_metadataURI)         DeflationaryMockERC20.constructor (_name)         NestedAsset.mintWithMetadata (_metadataURI)         MockERC20.constructor (_symbol)         DeflationaryMockERC20.constructor (_symbol)         MockERC20.constructor (_name)    Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               FeeSplitter.sol, _computeShareCount, { return (_amount * _weight) / _totalWeights; }    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               FeeSplitter.sol, _addShareholder         MixinOperatorResolver.sol, requireAndGetAddress         ExchangeHelpers.sol, setMaxAllowance    Title: Check if amount is not zero to save gas Severity: GAS  The following functions could skip other steps if the amount is 0. (A similar issue: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82)           DeflationaryMockERC20.sol, transferFrom         FeeSplitter.sol, sendFees  
 Title: Does not validate the input fee parameter Severity: Low Risk  Some fee parameters of functions are not checked for invalid values. Validate the parameters:                  NestedFactory.constructor (_feeSplitter)         NestedFactory.setFeeSplitter (_feeSplitter)      Title: Solidity compiler versions mismatch Severity: Low Risk  The project is compiled with different versions of solidity, which is not recommended due ti  undefined behaviors as a result of it.             Title: Init function calls an owner function Severity: Low Risk       Init function that calls an onlyOwner function is problematic since sometimes the initializer or the one applies      the constructor isn't necessary the owner of the protocol. And if a contract does it then you might get a situation     that all the onlyOwner functions are blocked since only the factory contract may use them but isn't necessary      support it.                    FeeSplitter.sol.constructor - calls setRoyaltiesWeight         FeeSplitter.sol.constructor - calls setShareholders    Title: Not verified owner Severity: Low Risk       owner param should be validated to make sure the owner address is not address(0).     Otherwise if not given the right input all only owner accessible functions will be unaccessible.                   OwnableProxyDelegation.sol.transferOwnership newOwner         OwnableProxyDelegation.sol.initialize ownerAddr         NestedAsset.sol.burn _owner         NestedAsset.sol.mint _owner         NestedAsset.sol.backfillTokenURI _owner         NestedAsset.sol.mintWithMetadata _owner         OwnableProxyDelegation.sol._setOwner newOwner    Title: Two Steps Verification before Transferring Ownership Severity: Low Risk  The following contracts have a function that allows them an admin to change it to a different address. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked. It is important to have two steps admin change where the first is announcing a pending new admin and the new address should then claim its ownership.  A similar issue was reported in a previous contest and was assigned a severity of medium: [code-423n4/2021-06-realitycards-findings#105](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105)           OwnableProxyDelegation.sol    Title: Missing non reentrancy modifier Severity: Low Risk  The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..          FeeSplitter.sol, updateShareholder is missing a reentrancy modifier         NestedFactory.sol, receive is missing a reentrancy modifier         FeeSplitter.sol, receive is missing a reentrancy modifier         NestedFactory.sol, removeOperator is missing a reentrancy modifier         NestedFactory.sol, addOperator is missing a reentrancy modifier         NestedFactory.sol, setFeeSplitter is missing a reentrancy modifier         FeeSplitter.sol, setShareholders is missing a reentrancy modifier         NestedFactory.sol, unlockTokens is missing a reentrancy modifier         FeeSplitter.sol, setRoyaltiesWeight is missing a reentrancy modifier         NestedFactory.sol, updateLockTimestamp is missing a reentrancy modifier    Title: In the following public update functions no value is returned Severity: Low Risk  In the following functions no value is returned, due to which by default value of return will be 0.  We assumed that after the update you return the latest new value.  (similar issue here: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/85).           ZeroExStorage.sol, updatesSwapTarget         NestedRecords.sol, updateHoldingAmount         NestedFactory.sol, updateLockTimestamp         NestedRecords.sol, updateLockTimestamp         FeeSplitter.sol, updateShareholder    Title: Never used parameters Severity: Low Risk  Those are functions and parameters pairs that the function doesn't use the parameter. In case those functions are external/public this is even worst since the user is required to put value that never used and can misslead him and waste its time.           MockERC20.sol: function constructor parameter _symbol isn't used. (constructor is default)         NestedAsset.sol: function backfillTokenURI parameter _owner isn't used. (backfillTokenURI is external)         TestableMixingOperatorResolver.sol: function constructor parameter _resolver isn't used. (constructor is default)         DeflationaryMockERC20.sol: function constructor parameter _symbol isn't used. (constructor is default)         DeflationaryMockERC20.sol: function constructor parameter _name isn't used. (constructor is default)         TestableOperatorCaller.sol: function performSwap parameter own isn't used. (performSwap is external)         MockERC20.sol: function constructor parameter _name isn't used. (constructor is default)    Title: Missing commenting Severity: Low Risk       The following functions are missing commenting as describe below:              FeeSplitter.sol, _addShareholder (private), parameters _account, _weight not commented         NestedRecords.sol, getAssetTokens (public), @return is missing         FeeSplitter.sol, _releaseToken (private), @return is missing         FeeSplitter.sol, _computeShareCount (private), parameters _amount, _weight, _totalWeights not commented         NestedRecords.sol, getAssetHolding (public), @return is missing         FeeSplitter.sol, _releaseToken (private), parameters _account, _token not commented         FeeSplitter.sol, _computeShareCount (private), @return is missing    Title: Anyone can withdraw others Severity: Low Risk  Anyone can withdraw users shares. Although we think that they are sent to the right address, it is still         1) not the desired behavior         2) can be dangerous if the receiver is a smart contract         3) the receiver may not know someone withdraw him                   NestedFactory.withdraw         NestedReserve.withdraw   Title: Not verified input Severity: Low Risk  external / public functions parameters should be validated to make sure the address is not 0. Otherwise if not given the right input it can mistakenly lead to loss of user funds.              FeeSplitter.sol._addShares _token         FeeSplitter.sol._addShares _account         DeflationaryMockERC20.sol.transferFrom recipient         OwnableFactoryHandler.sol.removeFactory _factory  
Gas optimization  1 Use default value for uint256 and use ++i instead of i++ in for loop  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L136-L139 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L148 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L165 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L261 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L280 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L318  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L103 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L113 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L153 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L213 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L273 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L327 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L369 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L581  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L581  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/OperatorResolver.sol#L40 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/OperatorResolver.sol#L75   Feesplitter.sol  2 Use storage for shareholders[_accountIndex]saves gas in updateShareholder.  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L134-L140  function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {         require(_accountIndex < shareholders.length, "FS: INVALID_ACCOUNT_INDEX");         Shareholder storage _shareholder = shareholders[_accountIndex];         totalWeights = totalWeights + _weight - _shareholder.weight;         require(totalWeights != 0, "FS: TOTAL_WEIGHTS_ZERO");         _shareholder.weight = _weight;         emit ShareholderUpdated(_shareholder.account, _weight);     }  NestedRecords.sol  3 Check _reserve != address(0) earlier in store save gas.  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L111-L127  require(_reserve != address(0), “NRC: NO_ADDRESS”); must be checked separately at the beginning of function.  4 Use storage for records[_nftId] saves gas in store.  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L111-L132  function store(         uint256 _nftId,         address _token,         uint256 _amount,         address _reserve     ) external onlyFactory {         NftRecord storage _record = records[_nftId];         uint256 amount = _record.holdings[_token];         // uint256 amount = records[_nftId].holdings[_token];         if (amount != 0) {             require(_record.reserve == _reserve, "NRC: RESERVE_MISMATCH");             updateHoldingAmount(_nftId, _token, amount + _amount);             return;         }         require(_record.tokens.length < maxHoldingsCount, "NRC: TOO_MANY_TOKENS");         require(             _reserve != address(0) && (_reserve == _record.reserve || _record.reserve == address(0)),             "NRC: INVALID_RESERVE"         );           _record.holdings[_token] = _amount;         _record.tokens.push(_token);         _record.reserve = _reserve;     }   
# QA Report   **Table of Contents:**   - [QA Report](#qa-report)   - [Foreword](#foreword)   - [Comparisons](#comparisons)     - [Comparison that should be inclusive in NestedRecords.sol](#comparison-that-should-be-inclusive-in-nestedrecordssol)   - [Variables](#variables)     - [Missing Address(0) checks](#missing-address0-checks)     - [Check if a value is in an array before a push](#check-if-a-value-is-in-an-array-before-a-push)     - [Variables that should be grouped together in a struct](#variables-that-should-be-grouped-together-in-a-struct)       - [File: FeeSplitter.sol](#file-feesplittersol)   - [Arithmetics](#arithmetics)     - [Possible division by 0](#possible-division-by-0)   - [Revert Strings](#revert-strings)     - [File: NestedFactory.sol](#file-nestedfactorysol)       - [Inconsistent Revert string](#inconsistent-revert-string)     - [File: MixinOperatorResolver.sol](#file-mixinoperatorresolversol)       - [Inconsistent Revert string (1)](#inconsistent-revert-string-1)       - [Misleading + Inconsistent Revert string (2)](#misleading--inconsistent-revert-string-2)     - [File: OwnableProxyDelegation.sol](#file-ownableproxydelegationsol)       - [Inconsistent Revert string (1)](#inconsistent-revert-string-1-1)       - [Inconsistent Revert string (2)](#inconsistent-revert-string-2)     - [File: ZeroExOperator.sol](#file-zeroexoperatorsol)       - [Inconsistent Revert string (1)](#inconsistent-revert-string-1-2)       - [Inconsistent Revert string (2)](#inconsistent-revert-string-2-1)   - [Comments](#comments)     - [File: NestedFactory.sol](#file-nestedfactorysol-1)       - [Missing comment "@return" (1)](#missing-comment-return-1)       - [Missing comment "@return" (2)](#missing-comment-return-2)       - [Missing comment "@param" (1)](#missing-comment-param-1)     - [File: NestedRecords.sol](#file-nestedrecordssol)       - [Missing comment "@return" (1)](#missing-comment-return-1-1)       - [Missing comment "@return" (2)](#missing-comment-return-2-1)       - [Misleading comment on "@return"](#misleading-comment-on-return)     - [File: MixinOperatorResolver.sol](#file-mixinoperatorresolversol-1)       - [Missing 2 comments "@param" & changeable "@return" comment/variable](#missing-2-comments-param--changeable-return-commentvariable)     - [File: ExchangeHelpers.sol](#file-exchangehelperssol)       - [Missing comment "@return"](#missing-comment-return)  ## Foreword - **`@audit` tags** > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Comparisons ### Comparison that should be inclusive in NestedRecords.sol ``` File: NestedRecords.sol 123:         require(records[_nftId].tokens.length < maxHoldingsCount, "NRC: TOO_MANY_TOKENS"); //@audit should be inclusive ```  As length isn't 0 indexed, I believe, as an example to illustrate, that if `maxHoldingsCount == 1`, then `records[_nftId].tokens.length == 1` should be a passing condition. Therefore, I suggest changing `<` with `<=`  ## Variables   ### Missing Address(0) checks   ``` File: MixinOperatorResolver.sol 22:     constructor(address _resolver) { 23:         resolver = OperatorResolver(_resolver); //@audit missing address(0) check on immutable just like in the constructors in FeeSplitter.sol and NestedFactory.sol 24:     } ```  ### Check if a value is in an array before a push In `NestedRecords.sol`'s `store` function, it's possible to push an existing `address _token` several times in the same array  ``` File: NestedRecords.sol 130:         records[_nftId].tokens.push(_token); //@audit : should check existence ``` The previous lines of codes don't prevent this. The `store` function has the modifier `onlyFactory` and the only impact seem to be a possible maximization of `records[_nftId].tokens.length` (so that it reaches `maxHoldingsCount`).  ### Variables that should be grouped together in a struct   For maps that use the same key value: having separate fields is error prone (like in case of deletion or future new fields).   By regrouping, it's then possible to delete all related fields with a simple `delete newStruct[previousSameKeyForAllPreviousMaps]`.    #### File: FeeSplitter.sol 2 maps can be grouped together, as they use the same `_account` key:   ```   62:     struct TokenRecords { 63:         uint256 totalShares; 64:         uint256 totalReleased; 65:         mapping(address => uint256) shares; //@audit group  66:         mapping(address => uint256) released; //@audit group  67:     } ```   I'd suggest these 2 related data get grouped in a struct, let's name it `AccountInfo`:    ```   struct AccountInfo {        uint256 shares;        uint256 released;    }    ```   And it would be used in this manner (where `address` is `_account`):    ```        struct TokenRecords {         uint256 totalShares;         uint256 totalReleased;         mapping(address => AccountInfo) accountInfo;     }    ```    ## Arithmetics   ### Possible division by 0   There are no checks that the denominator is `!= 0` here:   ```   File: FeeSplitter.sol 327:     function _computeShareCount( 328:         uint256 _amount, 329:         uint256 _weight, 330:         uint256 _totalWeights 331:     ) private pure returns (uint256) { 332:         return (_amount * _weight) / _totalWeights; // @audit _totalWeights can be equal to 0, see FeeSplitter.sol:L184 333:     } ```  ## Revert Strings ### File: NestedFactory.sol #### Inconsistent Revert string ``` 44:         require(_exists(_tokenId), "URI query for nonexistent token"); ``` All other revert strings in `NestedAsset.sol` begin with `NA: `. Only this one doesn't. It's possible to gain consistency and still have an < 32 bytes size string with the following: `"NA: URI query - inexistent token"`  ### File: MixinOperatorResolver.sol #### Inconsistent Revert string (1) ``` 100:             require(tokens[0] == _outputToken, "OH: INVALID_OUTPUT_TOKEN");//@audit LOW comment : MOR like above ``` Here, `"OH: INVALID_OUTPUT_TOKEN"` should be replaced with `"MOR: INVALID_OUTPUT_TOKEN"`  #### Misleading + Inconsistent Revert string (2) ``` 101:             require(tokens[1] == _inputToken, "OH: INVALID_OUTPUT_TOKEN"); //@audit LOW comment : INVALID_INPUT_TOKEN //@audit LOW comment : MOR ``` Here, `"OH: INVALID_OUTPUT_TOKEN"` should be replaced with `"MOR: INVALID_INPUT_TOKEN"`  ### File: OwnableProxyDelegation.sol #### Inconsistent Revert string (1) ``` 25:         require(!initialized, "OFP: INITIALIZED"); //@audit low OFP doesn't make sense, use OPD instead (example: OwnableFactoryHandler is OFH, MixinOperatorResolver is MOR) ``` Is most contracts, the capital letters from the contract's name are used as a prefix in the revert strings (`OwnableFactoryHandler` has `OFH`, `MixinOperatorResolver` has `MOR`). Here, `OFP` doesn't really reflect `OwnableProxyDelegation`. It should be `OPD`.  #### Inconsistent Revert string (2) ``` 26:         require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, "OFP: FORBIDDEN");//@audit should be "OPD: FORBIDDEN"  ``` Same as above: `OFP` should be `OPD`.  ### File: ZeroExOperator.sol #### Inconsistent Revert string (1) ``` 32:         require(success, "ZEO: SWAP_FAILED"); ... 36:         require(amountBought != 0, "ZeroExOperator::performSwap: amountBought cant be zero"); //@audit LOW do like line 32 : "ZEO: amountBought cant be zero" < 32 bytes & consistent ``` As said before, the capital letters from the contract's name are used as a prefix in the revert strings. Here, the revert string's size is > 32 bytes and isn't using the same style as 4 lines above it. `ZeroExOperator::performSwap` should be `ZEO`.  #### Inconsistent Revert string (2) ``` 32:         require(success, "ZEO: SWAP_FAILED"); ... 37:         require(amountSold != 0, "ZeroExOperator::performSwap: amountSold cant be zero");//@audit do like line 32 : "ZEO: amountSold cant be zero" < 32 bytes & consistent ``` Same as above: `ZeroExOperator::performSwap` should be `ZEO`.  ## Comments ### File: NestedFactory.sol #### Missing comment "@return" (1) ``` 403:     /// @dev Call the operator to submit the order and add the output 404:     /// assets to the reserve (if needed). 405:     /// @param _inputToken Token used to make the orders 406:     /// @param _outputToken Expected output token 407:     /// @param _nftId The nftId 408:     /// @param _order The order calldata 409:     /// @param _toReserve True if the output is store in the reserve/records, false if not. //@audit missing @return  410:     function _submitOrder( 411:         address _inputToken, 412:         address _outputToken, 413:         uint256 _nftId, 414:         Order calldata _order, 415:         bool _toReserve 416:     ) private returns (uint256 amountSpent) { ```  #### Missing comment "@return" (2) ``` 474:     /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve 475:     ///      or the user wallet, to the factory. 476:     /// @param _nftId The NFT id 477:     /// @param _inputToken The token to receive 478:     /// @param _inputTokenAmount Amount to transfer 479:     /// @param _fromReserve True to transfer from the reserve 480:     /// @return Token transfered (in case of ETH) 481:     ///         The real amount received after the transfer to the factory //@audit missing @return (not the description, just the keyword) 482:     function _transferInputTokens( 483:         uint256 _nftId, 484:         IERC20 _inputToken, 485:         uint256 _inputTokenAmount, 486:         bool _fromReserve 487:     ) private returns (IERC20, uint256) { ```  #### Missing comment "@param" (1) ``` 562:     /// @dev Transfer from factory and collect fees 563:     /// @param _token The token to transfer 564:     /// @param _amount The amount (with fees) to transfer 565:     /// @param _dest The address receiving the funds //@audit missing @param 566:     function _safeTransferWithFees( 567:         IERC20 _token, 568:         uint256 _amount, 569:         address _dest, 570:         uint256 _nftId 571:     ) private { ```  ### File: NestedRecords.sol #### Missing comment "@return" (1) ``` 162:     /// @param _nftId The id of the NFT> //@audit missing @return 163:     function getAssetTokens(uint256 _nftId) public view returns (address[] memory) { ```  #### Missing comment "@return" (2) ``` 183:     /// @param _token The address of the token //@audit missing @return 184:     function getAssetHolding(uint256 _nftId, address _token) public view returns (uint256) { ```  #### Misleading comment on "@return" Here, the comment `@return The holdings`, which is the unique `@return` comment, suggests a returned `mapping(address => uint256) holdings` as seen on `struct NftRecord`. However, the function is actually returning a `uint256[]` and an `address[]`. Therefore, two `@return` are required and the previous one should be deleted.  Code: ``` 188:     /// @notice Returns the holdings associated to a NestedAsset 189:     /// @param _nftId the id of the NestedAsset 190:     /// @return The holdings //@audit "The holdings" suggests a "mapping(address => uint256)" but a uint256[] and an address[] are returned.   191:     function tokenHoldings(uint256 _nftId) public view returns (address[] memory, uint256[] memory) { ```  ### File: MixinOperatorResolver.sol #### Missing 2 comments "@param" & changeable "@return" comment/variable ```     /// @dev Build the calldata (with safe datas) and call the Operator     /// @param _order The order to execute //@audit missing @param _inputToken and @param _outputToken     /// @return success If the operator call is successful     /// @return amounts The amounts from the execution (used and received) //@audit why not use uint256[2]?     ///         - amounts[0] : The amount of output token     ///         - amounts[1] : The amount of input token USED by the operator (can be different than expected)     function callOperator(         INestedFactory.Order calldata _order,         address _inputToken,         address _outputToken     ) internal returns (bool success, uint256[] memory amounts) { ``` I suggest changing the returned uint256[] to uint256[2]  ### File: ExchangeHelpers.sol #### Missing comment "@return" ``` 10:     /// @dev Perform a swap between two tokens 11:     /// @param _sellToken Token to exchange 12:     /// @param _swapTarget The address of the contract that swaps tokens 13:     /// @param _swapCallData Call data provided by 0x to fill the quote //@audit missing @return 14:     function fillQuote( 15:         IERC20 _sellToken, 16:         address _swapTarget, 17:         bytes memory _swapCallData 18:     ) internal returns (bool) { ```
Use cached variable value  ## Impact  The `_submitOutOrders()` function sets `batchLength = _batchedOrders.orders.length`, but in the for loop the value "_batchedOrders.orders.length" is used instead of "batchLength". Using the cached variable could save gas.  ## Proof of Concept  The for loop on [line 369](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L369) could use the batchLength variable. This approach is used in the similar for loop on [line 327](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L327).  ## Recommended Mitigation Steps  Use the cached "batchLength" variable
* function transfer in NestedReserve is never used and can only be called by the factory (onlyFactory), so consider removing it because I think the factory uses a withdraw function from the Reserve.  * Currently never used: ```solidity   function setReserve onlyFactory ``` You can remove it to save some gas, or leave it if it was intended for future use with other factories.  * functions that add or remove operators or shareholders iterate over the whole array, so you can consider using EnumerableSet to store them: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol  * Could just use msg.sender and do not call an owner() function here: ```solidity     function unlockTokens(IERC20 _token) external override onlyOwner {         ...         _token.safeTransfer(owner(), amount); ```  * There are several functions that call _checkMsgValue. This function is quite expensive as it iterates over all the _batchedOrders and is only relevant when the inputToken is ETH. Later the callers will have to iterate over all the _batchedOrders again anyway, so I think this function should be refactored to significantly reduce gas. My suggestion: because processInputOrders and processInputAndOutputOrders both call _processInputOrders, the logic from _checkMsgValue could be moved to _processInputOrders. function create then can be refactored to re-use _processInputOrders. I see 2 discrepancies here: _fromReserve is always false when _submitInOrders is called from create (could be solved if _processInputOrders takes extra parameter), and _processInputOrders has this extra line: ```solidity   require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); ``` but this could be solved if you first mint the NFT and then invoke _processInputOrders from create.  * function withdraw calls nestedRecords twice: ```solidity  uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);  ...   address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];  ```  I think it could just substitute these links by first fetching all the tokens, and then calculating the length itself instead of making 2 external calls for pretty much the same data.    * Could use 'unchecked' maths here, as underflow is not possible: ```solidity    if (_amountToSpend > amounts[1]) {       IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);     } ```
-check `_metadataURI` !="" https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedAsset.sol#L106 `backfillTokenURI()` & `mintWithMetadata`was expected to change `tokenURI`. By not validating `metadataURI`!= "", it will just spend user gas more and nothing was changed
GAS :  1. Title: Unnecessary owner function call  Impact: In the `https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L134` it uses owner function call, instead of _owner, using _owner directly can save some gas  POC :  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L134  2. Title: It cheaper to remove the `&&` operator and make the 2 different require  POC :  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedAsset.sol#L78  Mitigation :  ``` require(_exists(_replicatedTokenId), "NA: INVALID_REPLICATED_TOKEN_ID"); require(tokenId != _replicatedTokenId, "NA: INVALID_REPLICATED_TOKEN_ID"); ```  3. Title : It Cheaper to use 0 instead of empty string  Impact : change bytes32("") to bytes32(0) can save +- 3 gas, both check for zero bytes32  POC :  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L101  Mitigation :   ``` require(operator != bytes32(0), "NF: INVALID_OPERATOR_NAME"); ```  4. Title : It cheaper to cached the operators to a memory instead use storage multiple times  Impact : In the `removeOperator` function it do the check in the loop by calling the operators storage, instead checking it with memory, multiple storage read is more expansive than doing multiple read from memory therefore saving the operator value to a memory first before checking inside a loop can make this call cheaper, just like `addOperator` function do.  POC :  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L111  Mitigation :  ``` function removeOperator(bytes32 operator) external override onlyOwner {         bytes32[] memory operatorsCache = operators;         uint256 operatorsLength = operatorsCache.length;         for (uint256 i = 0; i < operatorsLength; i++) {             if (operatorsCache[i] == operator) {                 operators[i] = operatorsCache[operatorsLength - 1];                 operators.pop();                 emit OperatorRemoved(operator);                 return;             }         }         revert("NF: NON_EXISTENT_OPERATOR");     } ``` 
## Nested Finance Gas Optimization Report  Unless otherwise noted, manual auditing and testing were done using Visual Studio Code and Remix. The sponsor-provided test suite was used to verify the findings.   The audit was done from February 10-12, 2022 by ye0lde through code4rena.  - [Nested Finance Gas Optimization Report](#nested-finance-gas-optimization-report) - [Findings](#findings)   - [G-1 - Function `store` can be more efficient (NestedRecords.sol)](#g-1---function-store-can-be-more-efficient-nestedrecordssol)   - [G-2 - Save gas and retain code clarity with the `unchecked` keyword (NestedFactory.sol)](#g-2---save-gas-and-retain-code-clarity-with-the-unchecked-keyword-nestedfactorysol)      ## Findings    ### G-1 - Function `store` can be more efficient (NestedRecords.sol)  #### Impact Caching the references to `records[_nftId]` in the `store` function will decrease gas usage as `store` is called frequently from NestedFactory.sol    Below are the relevant numbers from the sponsor's test suite before and after the change:  | Function     | Before (AVG) | After (AVG) |  | ----------- | ----------- | ----------- | | create     | 701747      | 701219 | | processInputAndOutputOrders   | 871716       |  871184 | | processInputOrders   | 406972       |  406779 | | processOutputOrders   | 449829       |  449712 | | store   | 83927       |  83684 |   #### Proof of Concept The `store` function is here: https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L111-L132  ```     function store(         uint256 _nftId,         address _token,         uint256 _amount,         address _reserve     ) external onlyFactory {         uint256 amount = records[_nftId].holdings[_token];         if (amount != 0) {             require(records[_nftId].reserve == _reserve, "NRC: RESERVE_MISMATCH");             updateHoldingAmount(_nftId, _token, amount + _amount);             return;         }         require(records[_nftId].tokens.length < maxHoldingsCount, "NRC: TOO_MANY_TOKENS");         require(             _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)),             "NRC: INVALID_RESERVE"         );           records[_nftId].holdings[_token] = _amount;         records[_nftId].tokens.push(_token);         records[_nftId].reserve = _reserve;     } ```  #### Recommended Mitigation Steps I suggest the following changes:  ```     function store(         uint256 _nftId,         address _token,         uint256 _amount,         address _reserve     ) external onlyFactory {          NftRecord storage nftRecord = records[_nftId];         uint256 amount = nftRecord.holdings[_token];         if (amount != 0) {             require(nftRecord.reserve == _reserve, "NRC: RESERVE_MISMATCH");             updateHoldingAmount(_nftId, _token, amount + _amount);             return;         }         require(nftRecord.tokens.length < maxHoldingsCount, "NRC: TOO_MANY_TOKENS");         require(             _reserve != address(0) && (_reserve == nftRecord.reserve || nftRecord.reserve == address(0)),             "NRC: INVALID_RESERVE"         );          nftRecord.holdings[_token] = _amount;         nftRecord.tokens.push(_token);         nftRecord.reserve = _reserve;     }  ``` ---  ### G-2 - Save gas and retain code clarity with the `unchecked` keyword (NestedFactory.sol)  #### Impact In a previous Code4rena audit, various "unchecked" optimizations were suggested.  Some of which were implemented and some were not because the sponsor's focus was code clarity over optimization.    I believe this suggestion meets the requirements for both optimization and clarity. Below are the relevant numbers from the sponsor's test suite before and after the change:  | Function     | Before (AVG) | After (AVG) |  | ----------- | ----------- | ----------- | | create     | 701747      | 701623 | | processInputAndOutputOrders   | 871716       |  871468 | | processInputOrders   | 406972       |  406784 |   #### Proof of Concept The code that can be `unchecked` is here: https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L339-L347  The "unchecked" keyword can be applied here since there is a `require` statement at #337 that ensures the arithmetic operations would not cause an integer underflow or overflow.  ``` uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;  if (underSpentAmount != 0) {      tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);  }    // If input is from the reserve, update the records   if (_fromReserve) {       _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);   } ```  #### Recommended Mitigation Steps Add `unchecked` around #L339-L347 as shown below.  ``` require(amountSpent <= _inputTokenAmount - feesAmount, "NF: OVERSPENT");  unchecked {     uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;      if (underSpentAmount != 0) {         tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);     }      // If input is from the reserve, update the records     if (_fromReserve) {         _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);     } } ``` ---     
1. considered using require instead of && can save gas https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L123 // gas cost 35473  Change to: ``` require(accountsLength != 0); require (accountsLength == _weights.length, "FS: INPUTS_LENGTH_MUST_MATCH"); ``` // gas cost 35465  ========================================================================  2. considered add unchecked can save gas https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L327 // gas cost 22798  add unchecked ``` unchecked { return (_amount * _weight) / _totalWeights; } ``` // gas cost 22440  ========================================================================  3. avoid unnecessary `i = 0` because the default of uint is already 0 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L126  considered removing 0 value can save gas  ========================================================================  4. `SafeERC20` Gas Optimization https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L19 by not declaring this ``` using SafeERC20 for IERC20; ```  and for example, use this: ``` SafeERC20.safeTransfer(IERC20(_inputToken)_msgSender(), _amountToSpend - amounts[1]); ```  ========================================================================  5. just read it directly to storage can save gas  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L279 // gas cost 24794  Change to: ``` Shareholder[] storage shareholdersCache = shareholders; ``` // gas cost 24684  ========================================================================  6. the original function will return 0 which a default value for uint256 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L216  // gas cost 24940  Change to: ```      function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];         if (_tokenRecords.totalShares != 0) {          uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));         return             (totalReceived * _tokenRecords.shares[_account]) /             _tokenRecords.totalShares -             _tokenRecords.released[_account];         }     } ``` // gas cost 24919  ========================================================================
## [N1] Unused imports  The following source units are imported but not referenced in the contract:  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/operators/Flat/FlatOperator.sol#L4-L4  ```solidity import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/operators/Flat/IFlatOperator.sol#L4-L4  ```solidity import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; ```  ### Recommendation  Check all imports and remove all unused/unreferenced and unnecessary imports.   ## [N2] Using `public` to generate the getter function can make the code simpler and cleaner  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/operators/ZeroEx/ZeroExStorage.sol#L7-L19  ```solidity contract ZeroExStorage is Ownable {     address private _swapTarget;      /// @notice Returns the address of 0x swaptarget     function swapTarget() external view returns (address) {         return _swapTarget;     }      /// @notice Update the address of 0x swaptarget     function updatesSwapTarget(address swapTargetValue) external onlyOwner {         _swapTarget = swapTargetValue;     } } ```  Can be changed to:  ```solidity contract ZeroExStorage is Ownable {     address public swapTarget;      /// @notice Update the address of 0x swaptarget     function updatesSwapTarget(address swapTargetValue) external onlyOwner {         swapTarget = swapTargetValue;     } } ```  ## [N3] Inconsistent use of `_msgSender()`  Direct use of `msg.sender` vs internal call of `_msgSender()`.  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/operators/ZeroEx/ZeroExOperator.sol#L17-L17  ```solidity ZeroExStorage(operatorStorage).transferOwnership(msg.sender); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/NestedReserve.sol#L30-L30  ```solidity _token.safeTransfer(msg.sender, _amount); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/abstracts/OwnableFactoryHandler.sol#L21-L21  ```solidity require(supportedFactories[msg.sender], "OFH: FORBIDDEN"); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/FeeSplitter.sol#L103-L103  ```solidity require(msg.sender == weth, "FS: ETH_SENDER_NOT_WETH"); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/FeeSplitter.sol#L166-L168  ```solidity amount = _releaseToken(_msgSender(), _tokens[i]); _tokens[i].safeTransfer(_msgSender(), amount); emit PaymentReleased(_msgSender(), address(_tokens[i]), amount); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/FeeSplitter.sol#L199-L199  ```solidity _token.safeTransferFrom(_msgSender(), address(this), _amount); ```  ### Recommendation  Consider replacing `_msgSender()` with `msg.sender` for consistency.
# rebuildCaches lack input validation `rebuildCaches` function will call `rebuildCache()` for arbitary destinations contract https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L74 ```     function rebuildCaches(MixinOperatorResolver[] calldata destinations) public {         for (uint256 i = 0; i < destinations.length; i++) {             destinations[i].rebuildCache();         }     } ```  # Event name must be in CamelCase https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L22 ```     event reserveUpdated(uint256 nftId, address newReserve); ```
## [L1] Check against same-token `swap`:  Assessed risk: 2/10  Urgency: N/A  Codebase frequency: 1  ### [L1 - Impact]:  Users would typically not swap against the same token, hence, developers must put in place a check against such swaps. Because of the rapid development and innovation that happens within the ETH smart contract ecosystem, one should never assume that what does not go wrong now will not go wrong in a few months, hence no exceptions are to be made when it comes to security and best practices.  ```bash function performSwap(   IERC20 sellToken,   IERC20 buyToken,   bytes calldata swapCallData ) external payable override returns (uint256[] memory amounts, address[] memory tokens) {     amounts = new uint256[](2);     tokens = new address[](2);     uint256 buyBalanceBeforePurchase = buyToken.balanceOf(address(this));     uint256 sellBalanceBeforePurchase = sellToken.balanceOf(address(this));   ... ```  ### [L1 - References]:  ```solidity operators/ZeroEx/ZeroExOperator.sol line 21 ```  ### [L1 - Mitigation]:  Adding a require statement would prevent such a swap.  ```bash require(buyToken != sellToken, "ERR: same token swap"); ```  ### [L2] Add `_weight != 0` check in FeeSplitter  Assessed risk: 2/10  Urgency: N/A  Codebase frequency: 1  ### [L2 - Impact]:  Keeping a consistent check among all functions of the contract that deal with `_weight` is important, both from the security and clean code philosophies. One of the functions implemented in `FeeSplitter.sol` does not check against the latest `_weight` to be different than `0`, contrary to all the similar functions that have this check.  ```bash function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {     require(_accountIndex < shareholders.length, "FS: INVALID_ACCOUNT_INDEX");     totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;     require(totalWeights != 0, "FS: TOTAL_WEIGHTS_ZERO");     shareholders[_accountIndex].weight = _weight;     emit ShareholderUpdated(shareholders[_accountIndex].account, _weight); } ```  ### [L2 - References]:  ```solidity FeeSplitter.sol line 134 ```  ### [L2 - Mitigation]:  Add a check against the `_weight` being 0.  ```bash require(_weight != 0, "FS: ZERO_WEIGHT"); ```
# Lines of code  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L71 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L286-L296 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L370-L375 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L482-L492   # Vulnerability details  ## Impact  Should a user accidentally send ETH to the `NestedFactory`, anyone can utilise it to their own benefit by calling `processOutputOrders()` / `processInputAndOutputOrders()`. This is possible because:  1. `receive()` has no restriction on the sender 2. `processOutputOrders()` does not check `msg.value`, and rightly so, because funds are expected to come from `reserve`. 3. `transferInputTokens()` does not handle the case where `ETH` could be specified as an address by the user for an output order.  ```jsx if (address(_inputToken) == ETH) {   require(address(this).balance >= _inputTokenAmount, "NF: INVALID_AMOUNT_IN");   weth.deposit{ value: _inputTokenAmount }();   return (IERC20(address(weth)), _inputTokenAmount); } ```  Hence, the attack vector is simple. Should a user accidentally send ETH to the contract, create an output `Order` with `token` being `ETH` and amount corresponding to the NestedFactory’s ETH balance.  ## Recommended Mitigation Steps  1. Since plain / direct`ETH` transfers are only expected to solely come from `weth` (excluding payable functions), we recommend restricting the sender to be `weth`, like how it is done in `[FeeSplitter](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L101-L104)`.          We are aware that this was raised previously here: https://github.com/code-423n4/2021-11-nested-findings/issues/188 and would like to add that the restricting the sender in the `receive()` function will not affect `payable` functions. From from what we see, plain ETH transfers are also not expected to come from other sources like `NestedReserve` or operators.       ```jsx receive() external payable {   require(msg.sender == address(weth), "NF: ETH_SENDER_NOT_WETH"); } ```  1. Check that `_fromReserve` is false in the scenario `address(_inputToken) == ETH`.  ```jsx if (address(_inputToken) == ETH) {   require(!_fromReserve, "NF: INVALID_INPUT_TOKEN");   require(address(this).balance >= _inputTokenAmount, "NF: INVALID_AMOUNT_IN");   weth.deposit{ value: _inputTokenAmount }();   return (IERC20(address(weth)), _inputTokenAmount); } ```  
# Codebase Impressions & Summary  As this is a mitigation contest, there were far less issues discovered. Overall, the contracts were well-documented and are of high quality. The high and medium severity issues raised previously are rectified in the new codebase while the low and non critical issues are either fixed or acknowledged.  # Non-Critical Findings  ## NC01: Inconsistent capitalization for event `reserveUpdated`  ### Line References  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L22](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L22)  ### Description  All declared events are in PascalCase except `reserveUpdated`.  ## NC02: Spelling Error  ### Line References  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L32-L33](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L32-L33)  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L37](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L37)  `weigth` → `weight`
## G01: Redundant variables / events  The following variables / events are initialized / declared, but their values are not used in the contract subsequently. Consider removing them.  ### Variables  ### Events  `[INestedFactory.ReserveUpdated](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/interfaces/INestedFactory.sol#L16-L18)`  ## G02: NestedFactory: Redundant `weth` casting  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L554](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L554)  `weth` is already of type `IWETH`, so the casting is redundant.  ## G03: NestedFactory: Shift `RESERVE_MISMATCH` checks in `_processInputOrders()` and `_processOutputOrders()` to external functions  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L271](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L271)  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L289](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L289)  The checks above can be shifted to the parent functions `processInputOrders()`, `processOutputOrders()` and `processInputAndOutputOrders()` to prevent a duplicate check in the combined function `processInputAndOutputOrders()`.  ## G04: NestedFactory: Use a locally scoped variable in `destroy()`  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L213-L219](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L213-L219)  Instead of calling `tokens[i]` multiple times, you can store it as a locally scoped variable and use the variable multiple times instead.  ## G05: FeeSplitter: Redundant check on `totalWeights` in `updateShareholder()`  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L137](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L137)  The check `require(totalWeights != 0, "FS: TOTAL_WEIGHTS_ZERO");` is redundant because `totalWeights` is minimally `royaltiesWeight`, and `royaltiesWeight` is strictly greater than zero when it is set.  ## G06: FeeSplitter: Replace nested loop in `setShareholders` with previous proposed solution of sorting array off-chain, or a mapping  [https://github.com/code-423n4/2021-11-nested-findings/issues/135](https://github.com/code-423n4/2021-11-nested-findings/issues/135)  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L120](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L120)  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L315](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L315)  `setShareholders()` iterates through all the accounts to be added but at each iteration, `_addShareholders()` iterates through all the previously added shareholders to ensure there are no duplicates. This nested loop is very expensive.   It would be more gas-efficient to sort the array off-chain first, then check that the next address is greater than the previous, as suggested in our initial finding.  Alternatively, use a mapping to check if a shareholder exists and if it doesn’t, then push it to the `shareholders` array. Note that in order to delete the mapping, you need to iterate through the old `shareholders` array and delete the mapping first before deleting the old `shareholders`.
# Lines of code  https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L99-L108 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L30-L47 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L110-L122 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L49-L55   # Vulnerability details  `NestedFactory` extends the `MixinOperatorResolver` contract which comes from the [`synthetix/MixinResolver.sol`](https://github.com/Synthetixio/synthetix/blob/a1786e5d64b5b51212785ade6d8b42435f69c387/contracts/MixinResolver.sol) code base where the expectation is that `isResolverCached()` returns false until [`rebuildCache()` is called and the cache is fully up to date](https://github.com/Synthetixio/synthetix/blob/a1786e5d64b5b51212785ade6d8b42435f69c387/test/contracts/MixinResolver.js#L82-L105). Due to [a medium issue](https://github.com/code-423n4/2021-11-nested-findings/issues/217) identified in a prior contest, the `OperatorResolver.importOperators()` step was made to be atomically combined with the `NestedFactory.rebuildCache()` step. However, the atomicity was not applied everywhere and the ability to add/remove operators from the `NestedFactory` also had other cache-inconsistency issues. There are *four separate instances* of operator tracking problems in this submission.  ## Impact As with the prior issue, many core operations (such as `NestedFactory.create()` and `NestedFactory.swapTokenForTokens()`) are dependant on the assumption that the `operatorCache` cache is synced prior to these functions being executed, but this may not necessarily be the case. Unlike the prior issue which was about updates to the resolver not getting reflected in the cache, this issue is about changes to the factory not updating the cache.  ## Proof of Concept  ### 1. `removeOperator()` does not call `rebuildCache()` 1. `NestedFactory.removeOperator()` is called to remove an operator 2. A user calls `NestedFactory(MixinOperatorResolver).create()` using that operator and succeedes 3. `NestedFactory.rebuildCache()` is called to rebuild cache This flow is not aware that the cache is not in sync  ```solidity     /// @inheritdoc INestedFactory     function addOperator(bytes32 operator) external override onlyOwner {         require(operator != bytes32(""), "NF: INVALID_OPERATOR_NAME");         bytes32[] memory operatorsCache = operators;         for (uint256 i = 0; i < operatorsCache.length; i++) {             require(operatorsCache[i] != operator, "NF: EXISTENT_OPERATOR");         }         operators.push(operator);         emit OperatorAdded(operator);     } ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L99-L108  ### 2. Using both `removeOperator()` and `rebuildCache()` does not prevent `create()` from using the operator Even if `removeOperator()` calls `rebuildCache()` the function will still not work because `resolverOperatorsRequired()` only keeps track of remaining operators, and `rebuildCache()` currently has no way of knowing that an entry was removed from that array and that a corresponding entry from `operatorCache` needs to be removed too.  ```solidity     /// @notice Rebuild the operatorCache     function rebuildCache() external {         bytes32[] memory requiredOperators = resolverOperatorsRequired();         bytes32 name;         IOperatorResolver.Operator memory destination;         // The resolver must call this function whenever it updates its state         for (uint256 i = 0; i < requiredOperators.length; i++) {             name = requiredOperators[i];             // Note: can only be invoked once the resolver has all the targets needed added             destination = resolver.getOperator(name);             if (destination.implementation != address(0)) {                 operatorCache[name] = destination;             } else {                 delete operatorCache[name];             }             emit CacheUpdated(name, destination);         }     } ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L30-L47  ### 3. `addOperator()` does not call `rebuildCache()` 1. `NestedFactory.addOperator()` is called to add an operator 2. A user calls `NestedFactory(MixinOperatorResolver).create()` using that operator and fails because the operator wasn't in the `resolverOperatorsRequired()` during the last call to `rebuildCaches()`, so the operator isn't in `operatorCache` 3. `NestedFactory.rebuildCache()` is called to rebuild cache This flow is not aware that the cache is not in sync  ```solidity     /// @inheritdoc INestedFactory     function removeOperator(bytes32 operator) external override onlyOwner {         uint256 operatorsLength = operators.length;         for (uint256 i = 0; i < operatorsLength; i++) {             if (operators[i] == operator) {                 operators[i] = operators[operatorsLength - 1];                 operators.pop();                 emit OperatorRemoved(operator);                 return;             }         }         revert("NF: NON_EXISTENT_OPERATOR");     } ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L110-L122  ### 4. `isResolverCached()` does not reflect the actual updated-or-not state This function, like `removeOperator()` is not able to tell that there is an operator that needs to be removed from `resolverCache`, causing the owner not to know a call to `rebuildCache()` is required to 'remove' the operator ```solidity     /// @notice Check the state of operatorCache     function isResolverCached() external view returns (bool) {         bytes32[] memory requiredOperators = resolverOperatorsRequired();         bytes32 name;         IOperatorResolver.Operator memory cacheTmp;         IOperatorResolver.Operator memory actualValue;         for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L49-L55  ## Tools Used Code inspection  ## Recommended Mitigation Steps Add calls to `rebuildCache()` in `addOperator()` and `removeOperator()`, have `INestedFactory` also track operators that have been removed with a new array, and have `isResolverCached()` also check whether this new array is empty or not.   
# 1. Prefix increaments are cheaper than postfix increaments # Vulnerability details  ## Impact The functions use prefix increaments (i ++) instead of postfix increaments (++ i). Prefix increaments are cheaper than postfix increaments.  ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L40 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L60 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L75 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L103 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L113 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L213 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L273 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L291 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L327 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L369 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L581 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L196 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L126 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L148 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L165 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L261 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L280 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L318 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L36 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L55  ``` for (uint256 i = 0; i < namesLength; i++) { ```  ## Tools Manual analysis  ## Recommended Mitigation Steps Change all prefix increaments to postfix increaments where it doesn't affects the functionality.   # 2. Unnecessary initialization of loop index variable # Vulnerability details   ## Impact For loop indices across the contract functions use explicit 0 initializations which are not required because the default value of uints is 0. Removing this explicit unnecessary initialization will save a little gas.  ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L40 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L60 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L75 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L103 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L113 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L153 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L213 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L273 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L291 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L327 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L369 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L196 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L318  ``` for (uint256 i = 0; i < namesLength; i++) { ```  ## Tools  Remix ## Recommended Mitigation Steps Remove unnecessary initialization of loop index variable  # 3. Cache array length in for loops can save gas # Vulnerability details ## Impact Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack. Caching the array length in the stack saves around 3 gas per iteration. ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L261 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L318 ``` function findShareholder(address _account) external view returns (uint256) {         for (uint256 i = 0; i < shareholders.length; i++) {             if (shareholders[i].account == _account) return i;         }         revert("FS: SHAREHOLDER_NOT_FOUND");     } ``` ## Tools  Manual ## Recommended Mitigation Steps Caching len = shareholders.length and using the len instead will save gas.  # 4. Adding unchecked directive can save gas  # Vulnerability details ## Impact For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks. ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L445-L446  https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L572   ## Tools  Manual analysis ## Recommended Mitigation Steps Consider using 'unchecked' where it is safe to do so.  # 5. Avoid use of state variables in event emissions to save gas # Vulnerability details  ## Impact Where possible, use equivalent function parameters or local variables in event emits instead of state variables to prevent expensive SLOADs. Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase. ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L55 ``` function setMaxHoldingsCount(uint256 _maxHoldingsCount) external onlyOwner {         require(_maxHoldingsCount != 0, "NRC: INVALID_MAX_HOLDINGS");         maxHoldingsCount = _maxHoldingsCount;         emit MaxHoldingsChanges(maxHoldingsCount);     } ``` ## Tools Manual analysis ## Recommended Mitigation Steps  # 6. Long Revert Strings # Vulnerability details  ## Impact Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L444 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/operators/ZeroEx/ZeroExOperator.sol#L36 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/operators/ZeroEx/ZeroExOperator.sol#L37 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/OwnableProxyDelegation.sol#L56  ```  require(amounts[1] <= _amountToSpend, "NestedFactory::_safeSubmitOrder: Overspent"); ``` ## Tools Manual analysis ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes. 
# Gas Report **Table of Contents:** - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [File: NestedRecords.sol](#file-nestedrecordssol)     - [function store()](#function-store)       - [Cache `records[_nftId].reserve`](#cache-records_nftidreserve)       - [Inclusive comparison](#inclusive-comparison)     - [function deleteAsset()](#function-deleteasset)       - [Unchecked block](#unchecked-block)   - [File: NestedFactory.sol](#file-nestedfactorysol)     - [function removeOperator()](#function-removeoperator)       - [Unchecked block](#unchecked-block-1)     - [function destroy()](#function-destroy)       - [Unchecked block (1)](#unchecked-block-1)       - [Unchecked block (2)](#unchecked-block-2)     - [function _submitInOrders()](#function-_submitinorders)       - [Unchecked block (1)](#unchecked-block-1-1)       - [Unchecked block (2)](#unchecked-block-2-1)     - [function _submitOutOrders()](#function-_submitoutorders)       - [Unchecked block (1)](#unchecked-block-1-2)       - [Unchecked block (2)](#unchecked-block-2-2)       - [Unchecked block (3)](#unchecked-block-3)       - [Unchecked block (4)](#unchecked-block-4)     - [function _safeSubmitOrder()](#function-_safesubmitorder)       - [Unchecked block](#unchecked-block-2)     - [function _transferToReserveAndStore()](#function-_transfertoreserveandstore)       - [Unchecked block](#unchecked-block-3)     - [function _transferInputTokens()](#function-_transferinputtokens)       - [Unchecked block](#unchecked-block-4)     - [function _safeTransferWithFees()](#function-_safetransferwithfees)       - [Unchecked block](#unchecked-block-5)   - [File: FeeSplitter.sol](#file-feesplittersol)     - [function updateShareholder()](#function-updateshareholder)       - [Cache `totalWeights`](#cache-totalweights)     - [function sendFees()](#function-sendfees)       - [Unchecked block](#unchecked-block-6)     - [function sendFeesWithRoyalties()](#function-sendfeeswithroyalties)       - [Unchecked block](#unchecked-block-7)       - [Cache `totalWeights`](#cache-totalweights-1)     - [function getAmountDue()](#function-getamountdue)       - [Cache `_tokenRecords.totalShares`](#cache-_tokenrecordstotalshares)     - [function _addShareholder()](#function-_addshareholder)       - [A private function used only once can get inlined](#a-private-function-used-only-once-can-get-inlined)   - [File: ZeroExOperator.sol](#file-zeroexoperatorsol)     - [function performSwap()](#function-performswap)       - [Unchecked block (1)](#unchecked-block-1-3)       - [Unchecked block (2)](#unchecked-block-2-3)   - [File: INestedFactory.sol](#file-inestedfactorysol)     - [Storage](#storage)       - [Tightly pack struct `BatchedInputOrders`](#tightly-pack-struct-batchedinputorders)       - [Tightly pack struct `BatchedOutputOrders`](#tightly-pack-struct-batchedoutputorders)       - [Only use 1 struct](#only-use-1-struct)   - [General recommendations](#general-recommendations)     - [Variables](#variables)       - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values)     - [Comparisons](#comparisons)     - [Amounts should be checked for 0 before calling a transfer](#amounts-should-be-checked-for-0-before-calling-a-transfer)     - [For-Loops](#for-loops)       - [`++i` costs less gas compared to `i++`](#i-costs-less-gas-compared-to-i)       - [Increments can be unchecked](#increments-can-be-unchecked)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)     - [Errors](#errors)       - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword - **Storage-reading optimizations** > The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). In the paragraphs below, please see the `@audit-issue` tags in the pieces of code's comments for more information about SLOADs that could be saved by caching the mentioned **storage** variables in **memory** variables.  - **Unchecking arithmetics operations that can't underflow/overflow** > Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block: https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  - **`@audit` tags** > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## File: NestedRecords.sol ### function store() ``` 111:     function store( ... 118:         if (amount != 0) { 119:             require(records[_nftId].reserve == _reserve, "NRC: RESERVE_MISMATCH"); //@audit records[_nftId].reserve SLOAD 1  120:             updateHoldingAmount(_nftId, _token, amount + _amount); 121:             return; 122:         } 123:         require(records[_nftId].tokens.length < maxHoldingsCount, "NRC: TOO_MANY_TOKENS"); //@audit should be inclusive 124:         require( 125:             _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)), //@audit records[_nftId].reserve SLOAD 1 & 2 126:             "NRC: INVALID_RESERVE" 127:         ); ... ``` #### Cache `records[_nftId].reserve` Caching this in memory can save around 1 SLOAD  #### Inclusive comparison By definition, `maxHoldingsCount` is the `The maximum number of holdings for an NFT record`.  Here, as an example, if `maxHoldingsCount == 1` and `records[_nftId].tokens.length == 1`, the function will revert.  I believe this check should be inclusive (like this `records[_nftId].tokens.length <= maxHoldingsCount`). This is both a Low-risk issue and a gas issue as `<` costs 3 more gas than `<=` due to the additional `ISZERO` opcode (even with the Optimizer)  ### function deleteAsset() ``` 88:     function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory { 89:         address[] storage tokens = records[_nftId].tokens; 90:         address token = tokens[_tokenIndex]; 91:  92:         require(records[_nftId].holdings[token] != 0, "NRC: HOLDING_INACTIVE"); 93:  94:         delete records[_nftId].holdings[token]; 95:         tokens[_tokenIndex] = tokens[tokens.length - 1]; //@audit gas: can't underflow 96:         tokens.pop(); 97:     }  ``` #### Unchecked block  If `tokens.length == 1`, all assets would be deleted. If `tokens.length == 0`, line 90 would've thrown an error and trigger a revert. As it's impossible for line 95 to underflow, it should be wrapped inside an `unchecked` block.  ## File: NestedFactory.sol ### function removeOperator() ``` 111:     function removeOperator(bytes32 operator) external override onlyOwner { 112:         uint256 operatorsLength = operators.length; 113:         for (uint256 i = 0; i < operatorsLength; i++) { 114:             if (operators[i] == operator) { 115:                 operators[i] = operators[operatorsLength - 1];  //@audit can't underflow ... ``` #### Unchecked block Line 115 can't underflow due to `operatorsLength > 0` (the for-loop wouldn't iterate otherwise). Therefore, line 115 should be wrapped inside an `unchecked` block.  ### function destroy() ``` 200:     function destroy( ... 211:         uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this)); 212:  213:         for (uint256 i = 0; i < tokensLength; i++) { 214:             uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]); 215:             reserve.withdraw(IERC20(tokens[i]), amount); 216:  217:             _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]); 218:             nestedRecords.freeHolding(_nftId, tokens[i]); 219:         } 220:  221:         // Amount calculation to send fees and tokens 222:         uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;//@audit can't underflow  223:         uint256 amountFees = amountBought / 100; // 1% Fee 224:         amountBought -= amountFees; //@audit can't underflow (equivalent to "amountBought = amountBought - (amountBought / 100)") ... ```  #### Unchecked block (1) As `buyTokenInitialBalance` is  `<=` to the final `_buyToken.balanceOf(address(this))`, line 222 can't underflow.  Therefore, line 222 should be wrapped inside an `unchecked` block.  #### Unchecked block (2) As `amountBought -= amountFees` is equivalent to `amountBought = amountBought - (amountBought / 100)`, the result can't underflow. Therefore, line 223 should be wrapped inside an `unchecked` block.  ### function _submitInOrders() ``` 311:     function _submitInOrders( ... 337:         require(amountSpent <= _inputTokenAmount - feesAmount, "NF: OVERSPENT"); 338:  339:         uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent; //@audit can't underflow 340:         if (underSpentAmount != 0) { 341:             tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount); 342:         } 343:  344:         // If input is from the reserve, update the records 345:         if (_fromReserve) { 346:             _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount); //@audit can't underflow 347:         } ... ```  #### Unchecked block (1) Line 339 can't underflow due to the require statement line 337.  Therefore, line 339 should be wrapped inside an `unchecked` block.  #### Unchecked block (2) As `underSpentAmount = _inputTokenAmount - feesAmount - amountSpent` (line 339): `_inputTokenAmount >= underSpentAmount`. Therefore, line 346 can't underflow and should be wrapped inside an `unchecked` block.  ### function _submitOutOrders() ``` 357:     function _submitOutOrders( ... 365:         amountBought = _batchedOrders.outputToken.balanceOf(address(this)); ... 385:             require(amountSpent <= _inputTokenAmount, "NF: OVERSPENT"); 386:  387:             uint256 underSpentAmount = _inputTokenAmount - amountSpent; //@audit can't underflow 388:             if (underSpentAmount != 0) { 389:                 _inputToken.safeTransfer(address(reserve), underSpentAmount); 390:             } 391:  392:             _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount); //@audit can't underflow 393:         } 394:  395:         amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought; //@audit can't underflow 396:         feesAmount = amountBought / 100; // 1% Fee //@audit HIGH free stuff under 100 ? Check on Remix. That's one of Secureum's audit findings 397:  398:         if (_toReserve) { 399:             _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);//@audit can't underflow 400:         } 401:     } ```  #### Unchecked block (1) Line 387 can't underflow due to the require statement line 385.  Therefore, line 387 should be wrapped inside an `unchecked` block.  #### Unchecked block (2) As `underSpentAmount = _inputTokenAmount - amountSpent`: `_inputTokenAmount >= underSpentAmount`. Therefore, line 392 can't underflow and should be wrapped inside an `unchecked` block.  #### Unchecked block (3) As the initial `_batchedOrders.outputToken.balanceOf(address(this))` line 365 is  `<=` to the final `_batchedOrders.outputToken.balanceOf(address(this))` line 395: line 395 can't underflow.  Therefore, line 395 should be wrapped inside an `unchecked` block.  #### Unchecked block (4) As `amountBought - feesAmount` is equivalent to `amountBought - (amountBought / 100)`, the result can't underflow. Therefore, line 399 should be wrapped inside an `unchecked` block.  ### function _safeSubmitOrder() ``` 435:     function _safeSubmitOrder( ... 445:             if (_amountToSpend > amounts[1]) { 446:                 IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]); //@audit should be unchecked (see L445) 447:             } ... ```  #### Unchecked block Line 446 can't underflow due to the require statement line 445.  Therefore, line 446 should be wrapped inside an `unchecked` block.  ### function _transferToReserveAndStore() ``` 458:     function _transferToReserveAndStore( 459:         IERC20 _token, 460:         uint256 _amount, 461:         uint256 _nftId 462:     ) private { 463:         address reserveAddr = address(reserve); 464:         uint256 balanceReserveBefore = _token.balanceOf(reserveAddr); 465:  466:         // Send output to reserve 467:         _token.safeTransfer(reserveAddr, _amount); 468:  469:         uint256 balanceReserveAfter = _token.balanceOf(reserveAddr); 470:  471:         nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);//@audit can't underflow 472:     } ```  #### Unchecked block As the initial `_token.balanceOf(reserveAddr)` is  `<=` to the final `_token.balanceOf(reserveAddr)`: line 471 can't underflow.  Therefore, line 471 should be wrapped inside an `unchecked` block.  ### function _transferInputTokens() ``` 482:     function _transferInputTokens( ... 494:         uint256 balanceBefore = _inputToken.balanceOf(address(this)); 495:         if (_fromReserve) { 496:             require( 497:                 nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount, 498:                 "NF: INSUFFICIENT_AMOUNT_IN" 499:             ); 500:             // Get input from reserve 501:             reserve.withdraw(IERC20(_inputToken), _inputTokenAmount); 502:         } else { 503:             _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount); 504:         } 505:         return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore); //@audit can't underflow 506:     } ```  #### Unchecked block As the initial `_inputToken.balanceOf(address(this))` is  `<=` to the final `_inputToken.balanceOf(address(this))`: line 505 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  ### function _safeTransferWithFees() ``` 566:     function _safeTransferWithFees( 567:         IERC20 _token, 568:         uint256 _amount, 569:         address _dest, 570:         uint256 _nftId 571:     ) private { 572:         uint256 feeAmount = _amount / 100; // 1% Fee 573:         _transferFeeWithRoyalty(feeAmount, _token, _nftId); 574:         _token.safeTransfer(_dest, _amount - feeAmount);//@audit can't underflow 575:     } ```  #### Unchecked block As `_amount - feeAmount` is equivalent to `_amount - (_amount / 100)`, the result can't underflow. Therefore, line 574 should be wrapped inside an `unchecked` block.  ## File: FeeSplitter.sol  ### function updateShareholder() ```) 134:     function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner { 135:         require(_accountIndex < shareholders.length, "FS: INVALID_ACCOUNT_INDEX"); 136:         totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight; //@audit cache 137:         require(totalWeights != 0, "FS: TOTAL_WEIGHTS_ZERO"); 138:         shareholders[_accountIndex].weight = _weight; 139:         emit ShareholderUpdated(shareholders[_accountIndex].account, _weight); 140:     } ``` #### Cache `totalWeights` It's possible to save around 1 SLOAD by caching `totalWeights` in memory, like this: ```) 134:     function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner { 135:         require(_accountIndex < shareholders.length, "FS: INVALID_ACCOUNT_INDEX"); 136:         uint256 _totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;  //@audit +MSTORE 137:         require(_totalWeights != 0, "FS: TOTAL_WEIGHTS_ZERO"); //@audit +MLOAD -SLOAD 138:         totalWeights = _totalWeights; //@audit +MLOAD 139:         shareholders[_accountIndex].weight = _weight; 140:         emit ShareholderUpdated(shareholders[_accountIndex].account, _weight); 141:     } ```  ### function sendFees() ``` 175:     function sendFees(IERC20 _token, uint256 _amount) external nonReentrant { 176:         uint256 weights; 177:         unchecked { 178:             weights = totalWeights - royaltiesWeight; 179:         } 180:  181:         uint256 balanceBeforeTransfer = _token.balanceOf(address(this)); 182:         _token.safeTransferFrom(_msgSender(), address(this), _amount);  183:  184:         _sendFees(_token, _token.balanceOf(address(this)) - balanceBeforeTransfer, weights); //@audit can't underflow (see L181 and L182) 185:     } ```  #### Unchecked block As the initial `_token.balanceOf(address(this))` is  `<=` to the final `_token.balanceOf(address(this))`: line 184 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  ### function sendFeesWithRoyalties() ``` 191:     function sendFeesWithRoyalties( ... 198:         uint256 balanceBeforeTransfer = _token.balanceOf(address(this)); 199:         _token.safeTransferFrom(_msgSender(), address(this), _amount); 200:         uint256 amountReceived = _token.balanceOf(address(this)) - balanceBeforeTransfer;  //@audit can't underflow 201:  202:         uint256 royaltiesAmount = _computeShareCount(amountReceived, royaltiesWeight, totalWeights); //@audit totalWeights SLOAD 1 203:  204:         _sendFees(_token, amountReceived, totalWeights);//@audit totalWeights SLOAD 2 ... ```  #### Unchecked block As the initial `_token.balanceOf(address(this))` is  `<=` to the final `_token.balanceOf(address(this))`: line 200 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  #### Cache `totalWeights`  Caching this in memory can save around 1 SLOAD  ### function getAmountDue() ``` 216:     function getAmountDue(address _account, IERC20 _token) public view returns (uint256) { 217:         TokenRecords storage _tokenRecords = tokenRecords[address(_token)]; 218:         if (_tokenRecords.totalShares == 0) return 0;//@audit _tokenRecords.totalShares SLOAD 1 219:  220:         uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this)); 221:         return 222:             (totalReceived * _tokenRecords.shares[_account]) / 223:             _tokenRecords.totalShares - //@audit _tokenRecords.totalShares SLOAD 2 224:             _tokenRecords.released[_account]; 225:     } ```  #### Cache `_tokenRecords.totalShares`  Caching this in memory can save around 1 SLOAD  ### function _addShareholder() #### A private function used only once can get inlined  As this private function is only used once line 127 in function setShareholders(), it can get inlined to save some gas.  ## File: ZeroExOperator.sol ### function performSwap() ``` 21:     function performSwap( ... 28:         uint256 buyBalanceBeforePurchase = buyToken.balanceOf(address(this)); 29:         uint256 sellBalanceBeforePurchase = sellToken.balanceOf(address(this)); 30:  31:         bool success = ExchangeHelpers.fillQuote(sellToken, operatorStorage.swapTarget(), swapCallData); 32:         require(success, "ZEO: SWAP_FAILED"); 33:  34:         uint256 amountBought = buyToken.balanceOf(address(this)) - buyBalanceBeforePurchase; //@audit can't underflow (see L28 and L31) 35:         uint256 amountSold = sellBalanceBeforePurchase - sellToken.balanceOf(address(this));//@audit can't underflow (see L29 and L31) 36:         require(amountBought != 0, "ZeroExOperator::performSwap: amountBought cant be zero"); //@audit-info move up 1 ? Will certainly cost more gas on happy path while saving some on sad path. Not a good trade-off 37:         require(amountSold != 0, "ZeroExOperator::performSwap: amountSold cant be zero"); ... ```  #### Unchecked block (1) As the initial `buyToken.balanceOf(address(this))` is  `<=` to the final `buyToken.balanceOf(address(this))`: line 34 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  #### Unchecked block (2) As the initial `sellToken.balanceOf(address(this))` is  `<=` to the final `sellToken.balanceOf(address(this))`: line 35 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  ## File: INestedFactory.sol ### Storage #### Tightly pack struct `BatchedInputOrders`  `struct BatchedInputOrders` can be tightly packed to save 1 storage slot by changing the code from this: ```     struct BatchedInputOrders {         IERC20 inputToken;//@audit 20 byte         uint256 amount; //@audit 32 byte         Order[] orders; //@audit fully takes slots         bool fromReserve; //@audit 1 byte     } ``` to this: ```     struct BatchedInputOrders {         IERC20 inputToken;//@audit 20 byte         bool fromReserve; //@audit 1 byte         uint256 amount; //@audit 32 byte         Order[] orders; //@audit fully takes slots     } ```  #### Tightly pack struct `BatchedOutputOrders`  `struct BatchedOutputOrders` can be tightly packed to save 1 storage slot by changing the code from this: ```     struct BatchedOutputOrders {         IERC20 outputToken;//@audit 20 byte         uint256[] amounts;//@audit 32 byte         Order[] orders;//@audit fully takes slots         bool toReserve;//@audit 1 byte     } ``` to this: ```     struct BatchedOutputOrders {         IERC20 outputToken;//@audit 20 byte         bool toReserve;//@audit 1 byte         uint256[] amounts;//@audit 32 byte         Order[] orders;//@audit fully takes slots     } ```  #### Only use 1 struct  In my opinion, the structs here are used in an unintended way: it's not up to a struct to carry the input/output concept here.  It's possible to use only 1 struct for the whole logic, as such: ```     struct BatchedOrders {         IERC20 token;         bool hasReserve;         uint256[] amounts;         Order[] orders;     } ``` And then declare input and output variables with this, like: `BatchedOrders[] _batchedInputOrders` or `BatchedOrders[] _batchedOutputOrders`.  Same struct, different variables.  I suggest going from: ``` NestedFactory.sol:   141:     function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)   162:     function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)   176:     function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)   190:         BatchedInputOrders[] calldata _batchedInputOrders,   191:         BatchedOutputOrders[] calldata _batchedOutputOrders   193:         _checkMsgValue(_batchedInputOrders);   194:         _processInputOrders(_nftId, _batchedInputOrders);   195:         _processOutputOrders(_nftId, _batchedOutputOrders);   268:     function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {   286:     function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {   313:         BatchedInputOrders calldata _batchedOrders,   359:         BatchedOutputOrders calldata _batchedOrders,   579:     function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {  interfaces\INestedFactory.sol:   106:     function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders) external payable;   111:     function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) external payable;   116:     function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) external;   120:     /// @param _batchedInputOrders The input orders to execute (first)   121:     /// @param _batchedOutputOrders The output orders to execute (after)   124:         BatchedInputOrders[] calldata _batchedInputOrders,   125:         BatchedOutputOrders[] calldata _batchedOutputOrders ``` to ``` NestedFactory.sol:   141:     function create(uint256 _originalTokenId, BatchedOrders[] calldata _batchedInputOrders)   162:     function processInputOrders(uint256 _nftId, BatchedOrders[] calldata _batchedInputOrders)   176:     function processOutputOrders(uint256 _nftId, BatchedOrders[] calldata _batchedOutputOrders)   190:         BatchedOrders[] calldata _batchedInputOrders,   191:         BatchedOrders[] calldata _batchedOutputOrders   193:         _checkMsgValue(_batchedInputOrders);   194:         _processInputOrders(_nftId, _batchedInputOrders);   195:         _processOutputOrders(_nftId, _batchedOutputOrders);   268:     function _processInputOrders(uint256 _nftId, BatchedOrders[] calldata _batchedInputOrders) private {   286:     function _processOutputOrders(uint256 _nftId, BatchedOrders[] calldata _batchedOutputOrders) private {   313:         BatchedOrders calldata _batchedInputOrders,   359:         BatchedOrders calldata _batchedOutputOrders,   579:     function _checkMsgValue(BatchedOrders[] calldata _batchedInputOrders) private {  interfaces\INestedFactory.sol:   106:     function create(uint256 _originalTokenId, BatchedOrders[] calldata _batchedInputOrders) external payable;   111:     function processInputOrders(uint256 _nftId, BatchedOrders[] calldata _batchedInputOrders) external payable;   116:     function processOutputOrders(uint256 _nftId, BatchedOrders[] calldata _batchedOutputOrders) external;   124:         BatchedOrders[] calldata _batchedInputOrders,   125:         BatchedOrders[] calldata _batchedOutputOrders ```  ## General recommendations ### Variables #### No need to explicitly initialize variables with default values   If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.   As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Instances include:   ``` abstracts\MixinOperatorResolver.sol:36:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts\MixinOperatorResolver.sol:55:        for (uint256 i = 0; i < requiredOperators.length; i++) { FeeSplitter.sol:126:        for (uint256 i = 0; i < accountsLength; i++) { FeeSplitter.sol:148:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:165:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:261:        for (uint256 i = 0; i < shareholders.length; i++) { FeeSplitter.sol:280:        for (uint256 i = 0; i < shareholdersCache.length; i++) { FeeSplitter.sol:318:        for (uint256 i = 0; i < shareholders.length; i++) { NestedFactory.sol:103:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:113:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:153:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:213:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:273:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:291:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:327:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) { NestedFactory.sol:581:        for (uint256 i = 0; i < _batchedOrders.length; i++) { NestedRecords.sol:71:            uint256 tokenIndex = 0; NestedRecords.sol:196:        for (uint256 i = 0; i < tokensCount; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```   I suggest removing explicit initializations for default values.  ### Comparisons ### Amounts should be checked for 0 before calling a transfer Checking non-zero transfer values can avoid an expensive external call and save gas.    Places I suggest adding a non-zero-value check:   ```   FeeSplitter.sol:155:                _tokens[i].safeTransfer(_msgSender(), amount); FeeSplitter.sol:167:            _tokens[i].safeTransfer(_msgSender(), amount); FeeSplitter.sol:182:        _token.safeTransferFrom(_msgSender(), address(this), _amount); FeeSplitter.sol:199:        _token.safeTransferFrom(_msgSender(), address(this), _amount); NestedFactory.sol:134:        _token.safeTransfer(owner(), amount); NestedFactory.sol:467:        _token.safeTransfer(reserveAddr, _amount); NestedFactory.sol:503:            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount); NestedFactory.sol:558:            _token.safeTransfer(_dest, _amount); NestedFactory.sol:574:        _token.safeTransfer(_dest, _amount - feeAmount); NestedReserve.sol:23:        _token.safeTransfer(_recipient, _amount); NestedReserve.sol:30:        _token.safeTransfer(msg.sender, _amount); ```    ### For-Loops #### `++i` costs less gas compared to `i++` `++i` costs less gas compared to `i++` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration)    `i++` increments `i` and returns the initial value of `i`. Which means:      ``` uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ``` uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:   ``` abstracts\MixinOperatorResolver.sol:36:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts\MixinOperatorResolver.sol:55:        for (uint256 i = 0; i < requiredOperators.length; i++) { FeeSplitter.sol:126:        for (uint256 i = 0; i < accountsLength; i++) { FeeSplitter.sol:148:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:165:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:261:        for (uint256 i = 0; i < shareholders.length; i++) { FeeSplitter.sol:280:        for (uint256 i = 0; i < shareholdersCache.length; i++) { FeeSplitter.sol:318:        for (uint256 i = 0; i < shareholders.length; i++) { NestedFactory.sol:103:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:113:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:153:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:213:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:273:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:291:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:327:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) { NestedFactory.sol:581:        for (uint256 i = 0; i < _batchedOrders.length; i++) { NestedRecords.sol:78:                tokenIndex++; NestedRecords.sol:196:        for (uint256 i = 0; i < tokensCount; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```   I suggest using `++i` instead of `i++` to increment the value of an uint variable.  #### Increments can be unchecked In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Instances include:   ``` abstracts\MixinOperatorResolver.sol:36:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts\MixinOperatorResolver.sol:55:        for (uint256 i = 0; i < requiredOperators.length; i++) { FeeSplitter.sol:126:        for (uint256 i = 0; i < accountsLength; i++) { FeeSplitter.sol:148:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:165:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:261:        for (uint256 i = 0; i < shareholders.length; i++) { FeeSplitter.sol:280:        for (uint256 i = 0; i < shareholdersCache.length; i++) { FeeSplitter.sol:318:        for (uint256 i = 0; i < shareholders.length; i++) { NestedFactory.sol:103:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:113:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:153:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:213:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:273:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:291:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:327:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) { NestedFactory.sol:581:        for (uint256 i = 0; i < _batchedOrders.length; i++) { NestedRecords.sol:78:                tokenIndex++; NestedRecords.sol:196:        for (uint256 i = 0; i < tokensCount; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```   The code would go from:      ``` for (uint256 i; i < numIterations; i++) {    // ...   }   ``` to:   ``` for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ``` The risk of overflow is inexistant for a `uint256` here.  #### An array's length should be cached to save gas in for-loops Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead: ``` abstracts\MixinOperatorResolver.sol:36:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts\MixinOperatorResolver.sol:55:        for (uint256 i = 0; i < requiredOperators.length; i++) { FeeSplitter.sol:148:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:165:        for (uint256 i = 0; i < _tokens.length; i++) { FeeSplitter.sol:261:        for (uint256 i = 0; i < shareholders.length; i++) { FeeSplitter.sol:280:        for (uint256 i = 0; i < shareholdersCache.length; i++) { FeeSplitter.sol:318:        for (uint256 i = 0; i < shareholders.length; i++) { NestedFactory.sol:103:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) { NestedFactory.sol:581:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  ### Errors  #### Reduce the size of error messages (Long revert Strings) Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.   Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   Revert strings > 32 bytes are here:   ``` abstracts\OwnableProxyDelegation.sol:56:        require(newOwner != address(0), "Ownable: new owner is the zero address"); operators\ZeroEx\ZeroExOperator.sol:36:        require(amountBought != 0, "ZeroExOperator::performSwap: amountBought cant be zero"); operators\ZeroEx\ZeroExOperator.sol:37:        require(amountSold != 0, "ZeroExOperator::performSwap: amountSold cant be zero"); NestedFactory.sol:444:            require(amounts[1] <= _amountToSpend, "NestedFactory::_safeSubmitOrder: Overspent");  ```  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next.  #### Use Custom Errors instead of Revert Strings to save Gas Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: https://blog.soliditylang.org/2021/04/21/custom-errors/: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:   ``` abstracts\MixinOperatorResolver.sol:76:        require(_foundAddress.implementation != address(0), string(abi.encodePacked("MOR: MISSING_OPERATOR: ", name))); abstracts\MixinOperatorResolver.sol:100:            require(tokens[0] == _outputToken, "OH: INVALID_OUTPUT_TOKEN"); abstracts\MixinOperatorResolver.sol:101:            require(tokens[1] == _inputToken, "OH: INVALID_OUTPUT_TOKEN"); abstracts\OwnableFactoryHandler.sol:21:        require(supportedFactories[msg.sender], "OFH: FORBIDDEN"); abstracts\OwnableFactoryHandler.sol:28:        require(_factory != address(0), "OFH: INVALID_ADDRESS"); abstracts\OwnableFactoryHandler.sol:36:        require(supportedFactories[_factory], "OFH: NOT_SUPPORTED"); abstracts\OwnableProxyDelegation.sol:25:        require(!initialized, "OFP: INITIALIZED"); abstracts\OwnableProxyDelegation.sol:26:        require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, "OFP: FORBIDDEN"); abstracts\OwnableProxyDelegation.sol:40:        require(owner() == _msgSender(), "Ownable: caller is not the owner"); abstracts\OwnableProxyDelegation.sol:56:        require(newOwner != address(0), "Ownable: new owner is the zero address"); operators\Flat\FlatOperator.sol:18:        require(amount != 0, "FO: INVALID_AMOUNT"); operators\ZeroEx\ZeroExOperator.sol:32:        require(success, "ZEO: SWAP_FAILED"); operators\ZeroEx\ZeroExOperator.sol:36:        require(amountBought != 0, "ZeroExOperator::performSwap: amountBought cant be zero"); operators\ZeroEx\ZeroExOperator.sol:37:        require(amountSold != 0, "ZeroExOperator::performSwap: amountSold cant be zero"); FeeSplitter.sol:94:        require(_weth != address(0), "FS: INVALID_ADDRESS"); FeeSplitter.sol:103:        require(msg.sender == weth, "FS: ETH_SENDER_NOT_WETH"); FeeSplitter.sol:111:        require(_weight != 0, "FS: WEIGHT_ZERO"); FeeSplitter.sol:123:        require(accountsLength != 0 && accountsLength == _weights.length, "FS: INPUTS_LENGTH_MUST_MATCH"); FeeSplitter.sol:135:        require(_accountIndex < shareholders.length, "FS: INVALID_ACCOUNT_INDEX"); FeeSplitter.sol:137:        require(totalWeights != 0, "FS: TOTAL_WEIGHTS_ZERO"); FeeSplitter.sol:153:                require(success, "FS: ETH_TRANFER_ERROR"); FeeSplitter.sol:196:        require(_royaltiesTarget != address(0), "FS: INVALID_ROYALTIES_TARGET"); FeeSplitter.sol:306:        require(amountToRelease != 0, "FS: NO_PAYMENT_DUE"); FeeSplitter.sol:316:        require(_weight != 0, "FS: ZERO_WEIGHT"); FeeSplitter.sol:317:        require(_account != address(0), "FS: INVALID_ADDRESS"); FeeSplitter.sol:319:            require(shareholders[i].account != _account, "FS: ALREADY_SHAREHOLDER"); NestedAsset.sol:34:        require(_address == ownerOf(_tokenId), "NA: FORBIDDEN_NOT_OWNER"); NestedAsset.sol:44:        require(_exists(_tokenId), "URI query for nonexistent token"); NestedAsset.sol:78:        require(_exists(_replicatedTokenId) && tokenId != _replicatedTokenId, "NA: INVALID_REPLICATED_TOKEN_ID"); NestedAsset.sol:111:        require(bytes(tokenURI(_tokenId)).length == 0, "NA: TOKEN_URI_IMMUTABLE"); NestedFactory.sol:54:        require( NestedFactory.sol:78:        require(nestedAsset.ownerOf(_nftId) == _msgSender(), "NF: CALLER_NOT_OWNER"); NestedFactory.sol:86:        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), "NF: LOCKED_NFT"); NestedFactory.sol:101:        require(operator != bytes32(""), "NF: INVALID_OPERATOR_NAME"); NestedFactory.sol:104:            require(operatorsCache[i] != operator, "NF: EXISTENT_OPERATOR"); NestedFactory.sol:126:        require(address(_feeSplitter) != address(0), "NF: INVALID_FEE_SPLITTER_ADDRESS"); NestedFactory.sol:148:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:207:        require(_orders.length != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:208:        require(tokensLength == _orders.length, "NF: INPUTS_LENGTH_MUST_MATCH"); NestedFactory.sol:209:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:243:        require(assetTokensLength > _tokenIndex, "NF: INVALID_TOKEN_INDEX"); NestedFactory.sol:245:        require(assetTokensLength > 1, "NF: UNALLOWED_EMPTY_PORTFOLIO"); NestedFactory.sol:246:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:270:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:271:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:288:        require(batchedOrdersLength != 0, "NF: INVALID_MULTI_ORDERS"); NestedFactory.sol:289:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "NF: RESERVE_MISMATCH"); NestedFactory.sol:317:        require(batchLength != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:337:        require(amountSpent <= _inputTokenAmount - feesAmount, "NF: OVERSPENT"); NestedFactory.sol:363:        require(batchLength != 0, "NF: INVALID_ORDERS"); NestedFactory.sol:364:        require(_batchedOrders.amounts.length == batchLength, "NF: INPUTS_LENGTH_MUST_MATCH"); NestedFactory.sol:385:            require(amountSpent <= _inputTokenAmount, "NF: OVERSPENT"); NestedFactory.sol:418:        require(success, "NF: OPERATOR_CALL_FAILED"); NestedFactory.sol:444:            require(amounts[1] <= _amountToSpend, "NestedFactory::_safeSubmitOrder: Overspent"); NestedFactory.sol:489:            require(address(this).balance >= _inputTokenAmount, "NF: INVALID_AMOUNT_IN"); NestedFactory.sol:496:            require( NestedFactory.sol:556:            require(success, "NF: ETH_TRANSFER_ERROR"); NestedFactory.sol:586:        require(msg.value == ethNeeded, "NF: WRONG_MSG_VALUE"); NestedRecords.sol:53:        require(_maxHoldingsCount != 0, "NRC: INVALID_MAX_HOLDINGS"); NestedRecords.sol:92:        require(records[_nftId].holdings[token] != 0, "NRC: HOLDING_INACTIVE"); NestedRecords.sol:119:            require(records[_nftId].reserve == _reserve, "NRC: RESERVE_MISMATCH"); NestedRecords.sol:123:        require(records[_nftId].tokens.length < maxHoldingsCount, "NRC: TOO_MANY_TOKENS"); NestedRecords.sol:124:        require( NestedRecords.sol:140:        require(_timestamp > records[_nftId].lockTimestamp, "NRC: LOCK_PERIOD_CANT_DECREASE"); NestedReserve.sol:22:        require(_recipient != address(0), "NRS: INVALID_ADDRESS"); OperatorResolver.sol:27:        require(_foundOperator.implementation != address(0), reason); OperatorResolver.sol:39:        require(namesLength == destinations.length, "OR: INPUTS_LENGTH_MUST_MATCH"); OperatorResolver.sol:57:        require(names.length == operatorsToImport.length, "OR: INPUTS_LENGTH_MUST_MATCH"); ```  I suggest replacing revert strings with custom errors.  
Gas fee improvement https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L100 there is no need to use extra variable operatorsCache to check if operator exists.   https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L111 In the removeOperator function, no need for this line uint256 operatorsLength = operators.length; Use operators.length directly in the loop  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L177 getAssetTokensLength() function is not called from the contract. If not needed it can removed or should be made external  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L191 Function tokenHoldings() is not called from within the contract. If not needed it can be removed or should be made external  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedAsset.sol#L52 Function originalOwner() is not called from within the contract. If not needed it can be removed or should be made external  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/OperatorResolver.sol#L16 Add empty string check for this function  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/OperatorResolver.sol#L57 If bith names.length and operatorsToImport.length == 0, this check passes. Consider adding empty check to both structures  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L204 Nested _addShare _sendFees calls _addShare But in sendFeesWithRoyalties(), _addShare is called again after _sendFees. This can lead to nested executed. Please consider refactoring this code.
# Lines of code  https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L42-L43   # Vulnerability details  ## Impact The logic related to the `areOperatorsImported` method is incorrect and can cause an operator not to be updated because the owner thinks it is already updated, and a vulnerable or defective one can be used.  ## Proof of Concept The `operators` mapping is made up of a key `bytes32 name` and a value made up of two values: `implementation` and `selector`, both of which identify the contract and function to be called when an operator is invoked.  The `areOperatorsImported` method tries to check if the operators to check already exist, however, the check is not done correctly, since && is used instead of ||.  If the operator with name `A` and value `{implementation=0x27f8d03b3a2196956ed754badc28d73be8830a6e,selector="performSwapVulnerable"}` exists, and the owner try to check if the operator with name `A` and value `{implementation=0x27f8d03b3a2196956ed754badc28d73be8830a6e,selector="performSwapFixed"}` exists, that function will return `true`, and the owner may decide not to import it , producing unexpected errors. Because operators manage the tokens, this error can produce a token lost.  ## Recommended Mitigation Steps Change && by ||    
## Missing token whitelisting puts stakeholders on risk  Contract: https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L146  1. Attacker can call sendFees with a malicious token contract   2. This increases the share balance of malicious token for each stake holder  3. When stakeholders tries to withdraw there share of malicious token using releaseTokens, malicious contract will be called and code written by attacker will be executed (asking for unauthorized approvals, wasting Gas etc)  ## sendFees & sendFeesWithRoyalties not handling ETH token  Contract: https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L175  1. Both sendFees & sendFeesWithRoyalties are not considering if the input _token is ETH as done in releaseTokens  ## Incorrect return message  Contract: https://github.com/code-423n4/2022-02-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L101  1. The require statement incorrectly mentions INVALID_OUTPUT_TOKEN when it should be INVALID_INPUT_TOKEN
## https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol (#L191, #L149, #L166)  1. In sendFeesWithRoyalties, releaseTokens, releaseTokensNoETH function, add check amount!=0  ``` require(amount!=0, "Incorrect amount"); ```  ## https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L76  1. In updateHoldingAmount function, under the while loop, use return instead of break  ``` if (tokens[tokenIndex] == _token) {                     ...                     return;                 } ```  ## https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L317  1.  No need to check require(batchLength != 0, "NF: INVALID_ORDERS"); as this is already checked in all the calling functions like create, _processInputOrders  ## https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L445  1. The condition if (_amountToSpend > amounts[1])  is not required as the parent condition is already checking for require(amounts[1] <= _amountToSpend, "NestedFactory::_safeSubmitOrder: Overspent");
Title: State variables that could be set immutable Severity: GAS  In the following files there are state variables that could be set immutable to save gas.           operator in TestableOperatorCaller.sol         resolver in MixinOperatorResolver.sol         operatorStorage in ZeroExOperator.sol    Title: Unused state variables Severity: GAS  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           TestableMixingOperatorResolver.sol, addressesToCache    Title: Unused declared local variables Severity: GAS  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           TestableOperatorCaller.sol, performSwap, data    Title: Unnecessary array boundaries check when loading an array element twice Severity: GAS       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:               NestedFactory.sol._processOutputOrders - double load of _batchedOrders[i]         NestedFactory.sol._processInputOrders - double load of _batchedOrders[i]    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           FeeSplitter.sol, _tokens, 148         MixinOperatorResolver.sol, requiredOperators, 55         NestedFactory.sol, operatorsCache, 103         NestedFactory.sol, orders._batchedOrders, 369         FeeSplitter.sol, shareholders, 261         FeeSplitter.sol, shareholdersCache, 280         FeeSplitter.sol, shareholders, 318         OperatorResolver.sol, names, 60         FeeSplitter.sol, _tokens, 165         OperatorResolver.sol, destinations, 75         MixinOperatorResolver.sol, requiredOperators, 36         NestedFactory.sol, _batchedOrders, 581    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: NestedFactory.sol, i, 153         change to prefix increment and unchecked: MixinOperatorResolver.sol, i, 55         change to prefix increment and unchecked: NestedFactory.sol, i, 103         change to prefix increment and unchecked: NestedFactory.sol, i, 327         change to prefix increment and unchecked: NestedRecords.sol, i, 196         change to prefix increment and unchecked: FeeSplitter.sol, i, 148         change to prefix increment and unchecked: FeeSplitter.sol, i, 318         change to prefix increment and unchecked: OperatorResolver.sol, i, 40         change to prefix increment and unchecked: OperatorResolver.sol, i, 60         change to prefix increment and unchecked: FeeSplitter.sol, i, 280         change to prefix increment and unchecked: FeeSplitter.sol, i, 165         change to prefix increment and unchecked: FeeSplitter.sol, i, 261         change to prefix increment and unchecked: MixinOperatorResolver.sol, i, 36         change to prefix increment and unchecked: NestedFactory.sol, i, 273         change to prefix increment and unchecked: NestedFactory.sol, i, 213         change to prefix increment and unchecked: NestedFactory.sol, i, 369         change to prefix increment and unchecked: NestedFactory.sol, i, 581         change to prefix increment and unchecked: OperatorResolver.sol, i, 75         change to prefix increment and unchecked: FeeSplitter.sol, i, 126         change to prefix increment and unchecked: NestedFactory.sol, i, 113         change to prefix increment and unchecked: NestedFactory.sol, i, 291    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          MixinOperatorResolver.sol, 36         NestedFactory.sol, 153         OperatorResolver.sol, 75         NestedFactory.sol, 273         OperatorResolver.sol, 60         NestedFactory.sol, 213         FeeSplitter.sol, 318         MixinOperatorResolver.sol, 55         FeeSplitter.sol, 261         NestedFactory.sol, 291         NestedFactory.sol, 113         OperatorResolver.sol, 40         NestedFactory.sol, 369         NestedFactory.sol, 581         FeeSplitter.sol, 126         FeeSplitter.sol, 280         NestedFactory.sol, 103         FeeSplitter.sol, 165         NestedFactory.sol, 327         FeeSplitter.sol, 148         NestedRecords.sol, 196    Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          MixinOperatorResolver.sol, callOperator         NestedAsset.sol, _setTokenURI         ExchangeHelpers.sol, setMaxAllowance         ExchangeHelpers.sol, fillQuote         MixinOperatorResolver.sol, requireAndGetAddress    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           DeflationaryMockERC20.sol, transferFrom         TestableMixingOperatorResolver.sol, resolverOperatorsRequired         NestedRecords.sol, tokenHoldings         NestedAsset.sol, originalOwner         NestedRecords.sol, getAssetTokensLength         NestedRecords.sol, freeHolding         NestedAsset.sol, tokenURI         OwnableProxyDelegation.sol, renounceOwnership         OwnableProxyDelegation.sol, owner         OwnableProxyDelegation.sol, transferOwnership    Title: Unnecessary payable Severity: GAS  The following functions are payable but msg.value isn't used - therefore the function payable state modifier isn't necessary. Payable functions are more gas expensive than others, and it's danger the users if they send ETH by mistake.           ZeroExOperator.sol, performSwap is payable but doesn't use msg.value         FlatOperator.sol, transfer is payable but doesn't use msg.value    Title: Rearrange state variables Severity: GAS  You can change the order of the storage variables to decrease memory uses.  In OwnableProxyDelegation.sol,rearranging the storage fields can optimize to: 2 slots from: 3 slots. The new order of types (you choose the actual variables):         1. bytes32         2. address         3. bool     Title: Short the following require messages Severity: GAS  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: OwnableProxyDelegation.sol, In line 56, Require message length to shorten: 38, The message: Ownable: new owner is the zero address    Title: Unused imports Severity: GAS   In the following files there are contract imports that aren't used Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore)          IFlatOperator.sol, line 3, import "@openzeppelin/contracts/token/ERC20/IERC20.sol";         FlatOperator.sol, line 3, import "@openzeppelin/contracts/token/ERC20/IERC20.sol";         INestedFactory.sol, line 4, import "../NestedReserve.sol";    Title: Unused inheritance Severity: GAS       Some of your contract inherent contracts but aren't use them at all.     We recommend not to inherent those contracts.              NestedAsset.sol; the inherited contracts OwnableFactoryHandler not used         NestedReserve.sol; the inherited contracts OwnableFactoryHandler not used         NestedRecords.sol; the inherited contracts OwnableFactoryHandler not used    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           NestedFactory.sol, 489: change 'balance > 0' to 'balance != 0'    Title: Unnecessary constructor Severity: GAS  The following constructors are empty.      (A similar issue https://github.com/code-423n4/2021-11-fei-findings/issues/12)              TestableMixingOperatorResolver.sol.constructor         NestedAsset.sol.constructor    Title: Unnecessary functions Severity: GAS       The following functions are not used at all. Therefore you can remove them to save deployment gas and improve code clearness.                   MixinOperatorResolver.sol, callOperator         ExchangeHelpers.sol, fillQuote    Title: Unnecessary cast Severity: Gas                IERC20 NestedFactory.sol._transferInputTokens - unnecessary casting IERC20(_inputToken)    Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               NestedAsset.backfillTokenURI (_metadataURI)         ExchangeHelpers.fillQuote (_swapCallData)         NestedAsset._setTokenURI (_metadataURI)         DeflationaryMockERC20.constructor (_name)         NestedAsset.mintWithMetadata (_metadataURI)         MockERC20.constructor (_symbol)         DeflationaryMockERC20.constructor (_symbol)         MockERC20.constructor (_name)    Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               FeeSplitter.sol, _computeShareCount, { return (_amount * _weight) / _totalWeights; }    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               FeeSplitter.sol, _addShareholder         MixinOperatorResolver.sol, requireAndGetAddress         ExchangeHelpers.sol, setMaxAllowance    Title: Check if amount is not zero to save gas Severity: GAS  The following functions could skip other steps if the amount is 0. (A similar issue: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82)           DeflationaryMockERC20.sol, transferFrom         FeeSplitter.sol, sendFees  
 Title: Does not validate the input fee parameter Severity: Low Risk  Some fee parameters of functions are not checked for invalid values. Validate the parameters:                  NestedFactory.constructor (_feeSplitter)         NestedFactory.setFeeSplitter (_feeSplitter)      Title: Solidity compiler versions mismatch Severity: Low Risk  The project is compiled with different versions of solidity, which is not recommended due ti  undefined behaviors as a result of it.             Title: Init function calls an owner function Severity: Low Risk       Init function that calls an onlyOwner function is problematic since sometimes the initializer or the one applies      the constructor isn't necessary the owner of the protocol. And if a contract does it then you might get a situation     that all the onlyOwner functions are blocked since only the factory contract may use them but isn't necessary      support it.                    FeeSplitter.sol.constructor - calls setRoyaltiesWeight         FeeSplitter.sol.constructor - calls setShareholders    Title: Not verified owner Severity: Low Risk       owner param should be validated to make sure the owner address is not address(0).     Otherwise if not given the right input all only owner accessible functions will be unaccessible.                   OwnableProxyDelegation.sol.transferOwnership newOwner         OwnableProxyDelegation.sol.initialize ownerAddr         NestedAsset.sol.burn _owner         NestedAsset.sol.mint _owner         NestedAsset.sol.backfillTokenURI _owner         NestedAsset.sol.mintWithMetadata _owner         OwnableProxyDelegation.sol._setOwner newOwner    Title: Two Steps Verification before Transferring Ownership Severity: Low Risk  The following contracts have a function that allows them an admin to change it to a different address. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked. It is important to have two steps admin change where the first is announcing a pending new admin and the new address should then claim its ownership.  A similar issue was reported in a previous contest and was assigned a severity of medium: [code-423n4/2021-06-realitycards-findings#105](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105)           OwnableProxyDelegation.sol    Title: Missing non reentrancy modifier Severity: Low Risk  The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..          FeeSplitter.sol, updateShareholder is missing a reentrancy modifier         NestedFactory.sol, receive is missing a reentrancy modifier         FeeSplitter.sol, receive is missing a reentrancy modifier         NestedFactory.sol, removeOperator is missing a reentrancy modifier         NestedFactory.sol, addOperator is missing a reentrancy modifier         NestedFactory.sol, setFeeSplitter is missing a reentrancy modifier         FeeSplitter.sol, setShareholders is missing a reentrancy modifier         NestedFactory.sol, unlockTokens is missing a reentrancy modifier         FeeSplitter.sol, setRoyaltiesWeight is missing a reentrancy modifier         NestedFactory.sol, updateLockTimestamp is missing a reentrancy modifier    Title: In the following public update functions no value is returned Severity: Low Risk  In the following functions no value is returned, due to which by default value of return will be 0.  We assumed that after the update you return the latest new value.  (similar issue here: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/85).           ZeroExStorage.sol, updatesSwapTarget         NestedRecords.sol, updateHoldingAmount         NestedFactory.sol, updateLockTimestamp         NestedRecords.sol, updateLockTimestamp         FeeSplitter.sol, updateShareholder    Title: Never used parameters Severity: Low Risk  Those are functions and parameters pairs that the function doesn't use the parameter. In case those functions are external/public this is even worst since the user is required to put value that never used and can misslead him and waste its time.           MockERC20.sol: function constructor parameter _symbol isn't used. (constructor is default)         NestedAsset.sol: function backfillTokenURI parameter _owner isn't used. (backfillTokenURI is external)         TestableMixingOperatorResolver.sol: function constructor parameter _resolver isn't used. (constructor is default)         DeflationaryMockERC20.sol: function constructor parameter _symbol isn't used. (constructor is default)         DeflationaryMockERC20.sol: function constructor parameter _name isn't used. (constructor is default)         TestableOperatorCaller.sol: function performSwap parameter own isn't used. (performSwap is external)         MockERC20.sol: function constructor parameter _name isn't used. (constructor is default)    Title: Missing commenting Severity: Low Risk       The following functions are missing commenting as describe below:              FeeSplitter.sol, _addShareholder (private), parameters _account, _weight not commented         NestedRecords.sol, getAssetTokens (public), @return is missing         FeeSplitter.sol, _releaseToken (private), @return is missing         FeeSplitter.sol, _computeShareCount (private), parameters _amount, _weight, _totalWeights not commented         NestedRecords.sol, getAssetHolding (public), @return is missing         FeeSplitter.sol, _releaseToken (private), parameters _account, _token not commented         FeeSplitter.sol, _computeShareCount (private), @return is missing    Title: Anyone can withdraw others Severity: Low Risk  Anyone can withdraw users shares. Although we think that they are sent to the right address, it is still         1) not the desired behavior         2) can be dangerous if the receiver is a smart contract         3) the receiver may not know someone withdraw him                   NestedFactory.withdraw         NestedReserve.withdraw   Title: Not verified input Severity: Low Risk  external / public functions parameters should be validated to make sure the address is not 0. Otherwise if not given the right input it can mistakenly lead to loss of user funds.              FeeSplitter.sol._addShares _token         FeeSplitter.sol._addShares _account         DeflationaryMockERC20.sol.transferFrom recipient         OwnableFactoryHandler.sol.removeFactory _factory  
