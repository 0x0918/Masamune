# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  `UniswapAnchoredView`'s `PriceUpdated` event is never fired.  ## Impact  Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps  Use it or remove it.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `UniswapConfig.getTokenConfigBySymbolHash` function does not work as `getSymbolHashIndex` returns `0` if there is no config token for that symbol (uninitialized map value), but the outer function implements the non-existence check with `-1`.  The same issue occurs also for:  - `getTokenConfigByCToken` - `getTokenConfigByUnderlying`  ## Impact  When encountering a non-existent token config, it will always return the token config of the **first index** (index 0) which is a valid token config for a completely different token. This leads to wrong oracle prices for the actual token which could in the worst case be used to borrow more tokens at a lower price or borrow more tokens by having a higher collateral value, essentially allowing undercollateralized loans that cannot be liquidated.  ## Recommended Mitigation Steps  Fix the non-existence check.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `transfer` function is used in `Maximillion.sol` to send ETH to an account.  ## Impact  It is performed with a fixed amount of GAS and might fail if GAS costs change in the future or if a smart contract's fallback function handler is complex.  ## Recommended Mitigation Steps  Consider using the lower-level `.call{value: value}` instead and checking its success return value.  
# Handle  paulius.eth   # Vulnerability details  ## Impact contract CompoundLens functions cTokenMetadata and cTokenBalances compare against "bETH" while contract SimplePriceOracle function getUnderlyingPrice compares against "cETH". It is not clear if this SimplePriceOracle will be used in production, probably only for testing, but still would be nice to unify it across all the contracts.  ## Recommended Mitigation Steps Replace "cETH" with "bETH" in SimplePriceOracle function getUnderlyingPrice.  
# Handle  paulius.eth   # Vulnerability details  ## Impact contract CEther fallback function was refactored to be compatible with the Solidity 0.6 version:    /**    * @notice Send Ether to CEther to mint    */   fallback () external payable {       (uint err,) = mintInternal(msg.value);       requireNoError(err, "mint failed");   }  From Solidity 0.6 documentation:  "The unnamed function commonly referred to as “fallback function” was split up into a new fallback function that is defined using the fallback keyword and a receive ether function defined using the receive keyword. If present, the receive ether function is called whenever the call data is empty (whether or not ether is received). This function is implicitly payable. The new fallback function is called when no other function matches (if the receive ether function does not exist then this includes calls with empty call data). You can make this function payable or not. If it is not payable then transactions not matching any other function which send value will revert. You should only need to implement the new fallback function if you are following an upgrade or proxy pattern."  I think in this case "receive" is more suitable as the function is expecting to receive ether and empty call data.  ## Recommended Mitigation Steps Replace "fallback" with "receive".  
# Handle  paulius.eth   # Vulnerability details  ## Impact functions getTokenConfigBySymbolHash, getTokenConfigByCToken and getTokenConfigByUnderlying check returned index against max uint:   index != uint(-1) -1 should indicate that the index is not found, however, a default value for an uninitialized uint is 0, so it is impossible to get -1. What is even weirder is that 0 will be returned for non-existing configs but 0 is a valid index for the 1st config.  ## Recommended Mitigation Steps One of the solutions would be to reserve 0 for a not found index and use it when searching in mappings. Then normal indexes should start from 1. Another solution would be to introduce a new mapping with a boolean value that indicates if this index is initialized or not but this may be a more gas costly way.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The distributeSupplierComp() function has been modified to take in a third parameter which is a boolean distributeAll. But the corresponding NatSpec comments for the function have not been updated to add this new parameter. This could lead to minor confusion where NatSpec is consulted.  ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L1238-L1243   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add @param for distributeAll parameter.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Contracts should be deployed using the same compiler version/flags with which they have been tested. Locking the floating pragma, i.e. by not using ^ in pragma solidity ^0.6.10, ensures that contracts do not accidentally get deployed using an older compiler version with unfixed bugs.  For reference, see https://swcregistry.io/docs/SWC-103   ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapAnchoredView.sol#L3  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapConfig.sol#L3  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapLib.sol#L3   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove ^ in “pragma solidity ^0.6.10” and change it to “pragma solidity 0.6.12” to be consistent with the rest of the contracts.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Six of the seven Comptroller verify functions do nothing. Not sure why their calls in CToken.sol have been uncommented from the original Compound version.  Except redeemVerify(), six other verify functions transferVerify(), mintVerify(), borrowVerify(), repayBorrowVerify(), liquidateBorrowVerify() and seizeVerify() have no logic except accessing state variables to not be marked pure. Calls to these functions were commented out in the original Compound code’s CToken.sol but have been uncommented here.  Given that they do not implement any logic, the protocol should not be making any assumptions about any defence provided from their unimplemented verification logic.  ## Proof of Concept  Dummy functions whose comments say “// Shh - currently unused”:  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L263-L281  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L402-L418  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L450-L474  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L519-L546  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L584-L609  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L638-L656    Uncommented calls from modified code:  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L126  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L560  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L798  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L915  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L1019  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L1090    Commented calls from original Compound code:  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L123-L124  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L558-L559  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L797-L798  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L915-L916  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L1020-L1021  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L1092-L1093    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add logic to implement verification if that is indeed assumed to be implemented but is actually not. Otherwise, comment call sites.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The sweepToken() function in the original Compound code whose specified purpose was to recover accidentally sent ERC20 tokens to contract has been removed.   The original code comment says: “A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock).” This safety measure is helpful given the number/value of accidentally stuck tokens that are sent to contracts by mistake.  Tokens accidentally sent to this contract will be stuck leading to fund loss for sender.  ## Proof of Concept  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CErc20.sol#L112-L120  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CErc20.sol#L109-L121  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Retain this function unless there is a specific reason to remove it here.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level calls call/delegatecall/staticcall return true even if the account called is non-existent (per EVM design). Account existence must be checked prior to calling.  The doTransferOut() function was changed from using a transfer() function (which reverts) to a call() function (which returns a boolean), however there is no account existence check for the destination address to. If it doesn’t exist, for some reason, call will still return true (not throw an exception) and successfully pass the return value check on the next line.  The checked call paths don’t seem vulnerable because they use msg.sender/admin and not a user-controlled address, but this may be a risk if used later in other contexts. Hence rating as low-risk.  For reference, see this related high-risk severity finding from Trail of Bit’s audit of Hermez Network: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CEther.sol#L145-L148  https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls  https://docs.soliditylang.org/en/v0.8.4/control-structures.html#error-handling-assert-require-revert-and-exceptions   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for account-existence before the call() to make this safely extendable to user-controlled address contexts in future.  
# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The _setCompAddress() function in the Comptroller contract does not emit an event when changing the comp address. While this does not impose any security risk, it does hinder a users ability to view any changes made to the comp address through the contract's lifetime.   ## Affected line https://github.com/code-423n4/2021-04-basedloans/blob/main/code/contracts/Comptroller.sol#L1354  ## Recommended Mitigation Steps It is recommended to emit an event indicating the old comp address, and the new comp address to be used when calling the _setCompAddress() function. An example of such an event is `event NewCompAddress(address oldCompAddress, address newCompAddress)`.  
# Handle  gpersoon   # Vulnerability details  ## Impact Some constant values are difficult to read in one time because they have at lot of 0's. Solidity allows _ to separate series of zero's  ## Proof of Concept .\Governance\Blo.sol:    uint public constant totalSupply = 100000000e18; // 100 million BLO .\Governance\GovernorAlpha.sol:    function quorumVotes() public pure returns (uint) { return 4000000e18; } // 4,000,000 = 4% of BLO .\Governance\GovernorAlpha.sol:    function proposalThreshold() public pure returns (uint) { return 1000000e18; } // 1,000,000 = 1% of BLO  ## Tools Used grep  ## Recommended Mitigation Steps Replace   1000000e18 with    1_000_000e18  Replace   4000000e18 with    4_000_000e18  Replace 100000000e18 with  100_000_000e18   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  `UniswapAnchoredView`'s `PriceUpdated` event is never fired.  ## Impact  Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps  Use it or remove it.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `UniswapConfig.getTokenConfigBySymbolHash` function does not work as `getSymbolHashIndex` returns `0` if there is no config token for that symbol (uninitialized map value), but the outer function implements the non-existence check with `-1`.  The same issue occurs also for:  - `getTokenConfigByCToken` - `getTokenConfigByUnderlying`  ## Impact  When encountering a non-existent token config, it will always return the token config of the **first index** (index 0) which is a valid token config for a completely different token. This leads to wrong oracle prices for the actual token which could in the worst case be used to borrow more tokens at a lower price or borrow more tokens by having a higher collateral value, essentially allowing undercollateralized loans that cannot be liquidated.  ## Recommended Mitigation Steps  Fix the non-existence check.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `transfer` function is used in `Maximillion.sol` to send ETH to an account.  ## Impact  It is performed with a fixed amount of GAS and might fail if GAS costs change in the future or if a smart contract's fallback function handler is complex.  ## Recommended Mitigation Steps  Consider using the lower-level `.call{value: value}` instead and checking its success return value.  
# Handle  paulius.eth   # Vulnerability details  ## Impact contract CompoundLens functions cTokenMetadata and cTokenBalances compare against "bETH" while contract SimplePriceOracle function getUnderlyingPrice compares against "cETH". It is not clear if this SimplePriceOracle will be used in production, probably only for testing, but still would be nice to unify it across all the contracts.  ## Recommended Mitigation Steps Replace "cETH" with "bETH" in SimplePriceOracle function getUnderlyingPrice.  
# Handle  paulius.eth   # Vulnerability details  ## Impact contract CEther fallback function was refactored to be compatible with the Solidity 0.6 version:    /**    * @notice Send Ether to CEther to mint    */   fallback () external payable {       (uint err,) = mintInternal(msg.value);       requireNoError(err, "mint failed");   }  From Solidity 0.6 documentation:  "The unnamed function commonly referred to as “fallback function” was split up into a new fallback function that is defined using the fallback keyword and a receive ether function defined using the receive keyword. If present, the receive ether function is called whenever the call data is empty (whether or not ether is received). This function is implicitly payable. The new fallback function is called when no other function matches (if the receive ether function does not exist then this includes calls with empty call data). You can make this function payable or not. If it is not payable then transactions not matching any other function which send value will revert. You should only need to implement the new fallback function if you are following an upgrade or proxy pattern."  I think in this case "receive" is more suitable as the function is expecting to receive ether and empty call data.  ## Recommended Mitigation Steps Replace "fallback" with "receive".  
# Handle  paulius.eth   # Vulnerability details  ## Impact functions getTokenConfigBySymbolHash, getTokenConfigByCToken and getTokenConfigByUnderlying check returned index against max uint:   index != uint(-1) -1 should indicate that the index is not found, however, a default value for an uninitialized uint is 0, so it is impossible to get -1. What is even weirder is that 0 will be returned for non-existing configs but 0 is a valid index for the 1st config.  ## Recommended Mitigation Steps One of the solutions would be to reserve 0 for a not found index and use it when searching in mappings. Then normal indexes should start from 1. Another solution would be to introduce a new mapping with a boolean value that indicates if this index is initialized or not but this may be a more gas costly way.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The distributeSupplierComp() function has been modified to take in a third parameter which is a boolean distributeAll. But the corresponding NatSpec comments for the function have not been updated to add this new parameter. This could lead to minor confusion where NatSpec is consulted.  ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L1238-L1243   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add @param for distributeAll parameter.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Contracts should be deployed using the same compiler version/flags with which they have been tested. Locking the floating pragma, i.e. by not using ^ in pragma solidity ^0.6.10, ensures that contracts do not accidentally get deployed using an older compiler version with unfixed bugs.  For reference, see https://swcregistry.io/docs/SWC-103   ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapAnchoredView.sol#L3  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapConfig.sol#L3  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapLib.sol#L3   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove ^ in “pragma solidity ^0.6.10” and change it to “pragma solidity 0.6.12” to be consistent with the rest of the contracts.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Six of the seven Comptroller verify functions do nothing. Not sure why their calls in CToken.sol have been uncommented from the original Compound version.  Except redeemVerify(), six other verify functions transferVerify(), mintVerify(), borrowVerify(), repayBorrowVerify(), liquidateBorrowVerify() and seizeVerify() have no logic except accessing state variables to not be marked pure. Calls to these functions were commented out in the original Compound code’s CToken.sol but have been uncommented here.  Given that they do not implement any logic, the protocol should not be making any assumptions about any defence provided from their unimplemented verification logic.  ## Proof of Concept  Dummy functions whose comments say “// Shh - currently unused”:  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L263-L281  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L402-L418  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L450-L474  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L519-L546  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L584-L609  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L638-L656    Uncommented calls from modified code:  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L126  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L560  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L798  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L915  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L1019  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L1090    Commented calls from original Compound code:  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L123-L124  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L558-L559  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L797-L798  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L915-L916  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L1020-L1021  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L1092-L1093    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add logic to implement verification if that is indeed assumed to be implemented but is actually not. Otherwise, comment call sites.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The sweepToken() function in the original Compound code whose specified purpose was to recover accidentally sent ERC20 tokens to contract has been removed.   The original code comment says: “A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock).” This safety measure is helpful given the number/value of accidentally stuck tokens that are sent to contracts by mistake.  Tokens accidentally sent to this contract will be stuck leading to fund loss for sender.  ## Proof of Concept  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CErc20.sol#L112-L120  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CErc20.sol#L109-L121  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Retain this function unless there is a specific reason to remove it here.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level calls call/delegatecall/staticcall return true even if the account called is non-existent (per EVM design). Account existence must be checked prior to calling.  The doTransferOut() function was changed from using a transfer() function (which reverts) to a call() function (which returns a boolean), however there is no account existence check for the destination address to. If it doesn’t exist, for some reason, call will still return true (not throw an exception) and successfully pass the return value check on the next line.  The checked call paths don’t seem vulnerable because they use msg.sender/admin and not a user-controlled address, but this may be a risk if used later in other contexts. Hence rating as low-risk.  For reference, see this related high-risk severity finding from Trail of Bit’s audit of Hermez Network: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CEther.sol#L145-L148  https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls  https://docs.soliditylang.org/en/v0.8.4/control-structures.html#error-handling-assert-require-revert-and-exceptions   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for account-existence before the call() to make this safely extendable to user-controlled address contexts in future.  
# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The _setCompAddress() function in the Comptroller contract does not emit an event when changing the comp address. While this does not impose any security risk, it does hinder a users ability to view any changes made to the comp address through the contract's lifetime.   ## Affected line https://github.com/code-423n4/2021-04-basedloans/blob/main/code/contracts/Comptroller.sol#L1354  ## Recommended Mitigation Steps It is recommended to emit an event indicating the old comp address, and the new comp address to be used when calling the _setCompAddress() function. An example of such an event is `event NewCompAddress(address oldCompAddress, address newCompAddress)`.  
# Handle  gpersoon   # Vulnerability details  ## Impact Some constant values are difficult to read in one time because they have at lot of 0's. Solidity allows _ to separate series of zero's  ## Proof of Concept .\Governance\Blo.sol:    uint public constant totalSupply = 100000000e18; // 100 million BLO .\Governance\GovernorAlpha.sol:    function quorumVotes() public pure returns (uint) { return 4000000e18; } // 4,000,000 = 4% of BLO .\Governance\GovernorAlpha.sol:    function proposalThreshold() public pure returns (uint) { return 1000000e18; } // 1,000,000 = 1% of BLO  ## Tools Used grep  ## Recommended Mitigation Steps Replace   1000000e18 with    1_000_000e18  Replace   4000000e18 with    4_000_000e18  Replace 100000000e18 with  100_000_000e18   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  `UniswapAnchoredView`'s `PriceUpdated` event is never fired.  ## Impact  Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps  Use it or remove it.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `UniswapConfig.getTokenConfigBySymbolHash` function does not work as `getSymbolHashIndex` returns `0` if there is no config token for that symbol (uninitialized map value), but the outer function implements the non-existence check with `-1`.  The same issue occurs also for:  - `getTokenConfigByCToken` - `getTokenConfigByUnderlying`  ## Impact  When encountering a non-existent token config, it will always return the token config of the **first index** (index 0) which is a valid token config for a completely different token. This leads to wrong oracle prices for the actual token which could in the worst case be used to borrow more tokens at a lower price or borrow more tokens by having a higher collateral value, essentially allowing undercollateralized loans that cannot be liquidated.  ## Recommended Mitigation Steps  Fix the non-existence check.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `transfer` function is used in `Maximillion.sol` to send ETH to an account.  ## Impact  It is performed with a fixed amount of GAS and might fail if GAS costs change in the future or if a smart contract's fallback function handler is complex.  ## Recommended Mitigation Steps  Consider using the lower-level `.call{value: value}` instead and checking its success return value.  
# Handle  paulius.eth   # Vulnerability details  ## Impact contract CompoundLens functions cTokenMetadata and cTokenBalances compare against "bETH" while contract SimplePriceOracle function getUnderlyingPrice compares against "cETH". It is not clear if this SimplePriceOracle will be used in production, probably only for testing, but still would be nice to unify it across all the contracts.  ## Recommended Mitigation Steps Replace "cETH" with "bETH" in SimplePriceOracle function getUnderlyingPrice.  
# Handle  paulius.eth   # Vulnerability details  ## Impact contract CEther fallback function was refactored to be compatible with the Solidity 0.6 version:    /**    * @notice Send Ether to CEther to mint    */   fallback () external payable {       (uint err,) = mintInternal(msg.value);       requireNoError(err, "mint failed");   }  From Solidity 0.6 documentation:  "The unnamed function commonly referred to as “fallback function” was split up into a new fallback function that is defined using the fallback keyword and a receive ether function defined using the receive keyword. If present, the receive ether function is called whenever the call data is empty (whether or not ether is received). This function is implicitly payable. The new fallback function is called when no other function matches (if the receive ether function does not exist then this includes calls with empty call data). You can make this function payable or not. If it is not payable then transactions not matching any other function which send value will revert. You should only need to implement the new fallback function if you are following an upgrade or proxy pattern."  I think in this case "receive" is more suitable as the function is expecting to receive ether and empty call data.  ## Recommended Mitigation Steps Replace "fallback" with "receive".  
# Handle  paulius.eth   # Vulnerability details  ## Impact functions getTokenConfigBySymbolHash, getTokenConfigByCToken and getTokenConfigByUnderlying check returned index against max uint:   index != uint(-1) -1 should indicate that the index is not found, however, a default value for an uninitialized uint is 0, so it is impossible to get -1. What is even weirder is that 0 will be returned for non-existing configs but 0 is a valid index for the 1st config.  ## Recommended Mitigation Steps One of the solutions would be to reserve 0 for a not found index and use it when searching in mappings. Then normal indexes should start from 1. Another solution would be to introduce a new mapping with a boolean value that indicates if this index is initialized or not but this may be a more gas costly way.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The distributeSupplierComp() function has been modified to take in a third parameter which is a boolean distributeAll. But the corresponding NatSpec comments for the function have not been updated to add this new parameter. This could lead to minor confusion where NatSpec is consulted.  ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L1238-L1243   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add @param for distributeAll parameter.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Contracts should be deployed using the same compiler version/flags with which they have been tested. Locking the floating pragma, i.e. by not using ^ in pragma solidity ^0.6.10, ensures that contracts do not accidentally get deployed using an older compiler version with unfixed bugs.  For reference, see https://swcregistry.io/docs/SWC-103   ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapAnchoredView.sol#L3  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapConfig.sol#L3  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapLib.sol#L3   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove ^ in “pragma solidity ^0.6.10” and change it to “pragma solidity 0.6.12” to be consistent with the rest of the contracts.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Six of the seven Comptroller verify functions do nothing. Not sure why their calls in CToken.sol have been uncommented from the original Compound version.  Except redeemVerify(), six other verify functions transferVerify(), mintVerify(), borrowVerify(), repayBorrowVerify(), liquidateBorrowVerify() and seizeVerify() have no logic except accessing state variables to not be marked pure. Calls to these functions were commented out in the original Compound code’s CToken.sol but have been uncommented here.  Given that they do not implement any logic, the protocol should not be making any assumptions about any defence provided from their unimplemented verification logic.  ## Proof of Concept  Dummy functions whose comments say “// Shh - currently unused”:  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L263-L281  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L402-L418  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L450-L474  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L519-L546  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L584-L609  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L638-L656    Uncommented calls from modified code:  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L126  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L560  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L798  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L915  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L1019  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L1090    Commented calls from original Compound code:  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L123-L124  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L558-L559  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L797-L798  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L915-L916  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L1020-L1021  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L1092-L1093    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add logic to implement verification if that is indeed assumed to be implemented but is actually not. Otherwise, comment call sites.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The sweepToken() function in the original Compound code whose specified purpose was to recover accidentally sent ERC20 tokens to contract has been removed.   The original code comment says: “A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock).” This safety measure is helpful given the number/value of accidentally stuck tokens that are sent to contracts by mistake.  Tokens accidentally sent to this contract will be stuck leading to fund loss for sender.  ## Proof of Concept  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CErc20.sol#L112-L120  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CErc20.sol#L109-L121  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Retain this function unless there is a specific reason to remove it here.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level calls call/delegatecall/staticcall return true even if the account called is non-existent (per EVM design). Account existence must be checked prior to calling.  The doTransferOut() function was changed from using a transfer() function (which reverts) to a call() function (which returns a boolean), however there is no account existence check for the destination address to. If it doesn’t exist, for some reason, call will still return true (not throw an exception) and successfully pass the return value check on the next line.  The checked call paths don’t seem vulnerable because they use msg.sender/admin and not a user-controlled address, but this may be a risk if used later in other contexts. Hence rating as low-risk.  For reference, see this related high-risk severity finding from Trail of Bit’s audit of Hermez Network: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CEther.sol#L145-L148  https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls  https://docs.soliditylang.org/en/v0.8.4/control-structures.html#error-handling-assert-require-revert-and-exceptions   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for account-existence before the call() to make this safely extendable to user-controlled address contexts in future.  
# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The _setCompAddress() function in the Comptroller contract does not emit an event when changing the comp address. While this does not impose any security risk, it does hinder a users ability to view any changes made to the comp address through the contract's lifetime.   ## Affected line https://github.com/code-423n4/2021-04-basedloans/blob/main/code/contracts/Comptroller.sol#L1354  ## Recommended Mitigation Steps It is recommended to emit an event indicating the old comp address, and the new comp address to be used when calling the _setCompAddress() function. An example of such an event is `event NewCompAddress(address oldCompAddress, address newCompAddress)`.  
# Handle  gpersoon   # Vulnerability details  ## Impact Some constant values are difficult to read in one time because they have at lot of 0's. Solidity allows _ to separate series of zero's  ## Proof of Concept .\Governance\Blo.sol:    uint public constant totalSupply = 100000000e18; // 100 million BLO .\Governance\GovernorAlpha.sol:    function quorumVotes() public pure returns (uint) { return 4000000e18; } // 4,000,000 = 4% of BLO .\Governance\GovernorAlpha.sol:    function proposalThreshold() public pure returns (uint) { return 1000000e18; } // 1,000,000 = 1% of BLO  ## Tools Used grep  ## Recommended Mitigation Steps Replace   1000000e18 with    1_000_000e18  Replace   4000000e18 with    4_000_000e18  Replace 100000000e18 with  100_000_000e18   
