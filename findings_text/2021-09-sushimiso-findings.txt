# Handle  hrkrshnn   # Vulnerability details  ## Caching `totalPoints` during `setPoints` method  Instead of constantly writing to the same slot in a for loop, write it once at the end. This would save `100` gas for each iteration of the for loop. (Since [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929), the cost of writing to a dirty storage slot is 100 gas)  ``` diff modified   contracts/Access/PointList.sol @@ -65,6 +65,7 @@ contract PointList is IPointList, MISOAccessControls {     function setPoints(address[] memory _accounts, uint256[] memory _amounts) external override {          require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), "PointList.setPoints: Sender must be operator");          require(_accounts.length != 0, "PointList.setPoints: empty array");          require(_accounts.length == _amounts.length, "PointList.setPoints: incorrect array length"); +        uint totalPointsCache = totalPoints;          for (uint i = 0; i < _accounts.length; i++) {              address account = _accounts[i];              uint256 amount = _amounts[i]; @@ -72,9 +73,10 @@ contract PointList is IPointList, MISOAccessControls {               if (amount != previousPoints) {                  points[account] = amount; -                totalPoints = totalPoints.sub(previousPoints).add(amount); +                totalPointsCache = totalPointsCache.sub(previousPoints).add(amount);                  emit PointsUpdated(account, previousPoints, amount);              }          } +        totalPoints = totalPointsCache;      }  } ```   
# Handle  hrkrshnn   # Vulnerability details  ## Use `calldata` instead of `memory` for function parameters  In some cases, having function arguments in `calldata` instead of `memory` is more optimal.  Consider the following generic example:  ``` solidity contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above example, the dynamic array `arr` has the storage location `memory`. When the function gets called externally, the array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). And during the for loop, `arr[i]` accesses the value in memory using a `mload`. However, for the above example this is inefficient. Consider the following snippet instead:  ``` solidity contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  **Gas savings**: In the former example, the ABI decoding begins with copying value from `calldata` to `memory` in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  *In short*, use `calldata` instead of `memory` if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from `memory` to `calldata` may cause "unimplemented feature error". This can be avoided by using a newer (`0.8.*`) Solidity compiler.  ### (non-exhaustive) List of Examples  1.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/PointList.sol#L64> 2.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/ListFactory.sol#L151> 3.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/ListFactory.sol#L152> 4.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/PointList.sol#L64>    
# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * Misleading comment here (similarly with launcherInfo):   /// @notice Mapping from auction address created through this contract to Auction struct.   mapping(address => Token) public tokenInfo;  * In function deployToken this check should have an error message to indicate the user what's wrong:   require(tokenTemplates[_templateId] != address(0)); something like "MISOTokenFactory: incorrect _templateId". Also a meaningful revert message is missing here as regular user may not understand that token2 decimals should be >= token1 decimals:   require(d2 >= d1);  * There are a few copypasted misleading error messages, e.g. in function setCurrentTemplateId:      require(tokenTemplates[_templateId] != address(0), "MISOMarket: incorrect _templateId");      require(IMisoToken(tokenTemplates[_templateId]).tokenTemplate() == _templateType, "MISOMarket: incorrect _templateType"); should be MISOTokenFactory, not MISOMarket. Here also indicates the wrong location:    require(templateType > 0, "MISOLauncher: Incorrect template code "); You should consider revisiting and fixing them.  * There are hardcoded magic numbers, e.g. in MISOTokenFactory 1000 is indicating 100%. It would make code more readable and maintainable if you extract such numbers as constants.  * There is so much duplicated code across Auction contracts. Consider introducing an abstract BaseAuction (or similar name) contract that has common functions that specific auctions can inherit, e.g. ETH_ADDRESS, marketParticipationAgreement, revertBecauseUserDidNotProvideAgreement, etc.    
# Handle  pauliax   # Vulnerability details  ## Impact No need to check that _startTime < 10000000000 as it is later checked against _endTime which is also < 10000000000 :         require(_startTime < 10000000000, "Crowdsale: enter an unix timestamp in seconds, not miliseconds");         require(_endTime < 10000000000, "Crowdsale: enter an unix timestamp in seconds, not miliseconds");         ...         require(_endTime > _startTime, "Crowdsale: end time must be older than start price");  ## Recommended Mitigation Steps Remove this line:     require(_startTime < 10000000000, "Crowdsale: enter an unix timestamp in seconds, not miliseconds");  
# Handle  pauliax   # Vulnerability details  ## Impact WETH state variable in MISOLauncher is practically useless as it is not used in any meaningful way. Similarly, SECONDS_PER_DAY is not used in PostAuctionLauncher.  ## Recommended Mitigation Steps Consider removing unused variables.  
# Handle  pauliax   # Vulnerability details  ## Impact No need for this line in function initMISOMarket as it gets this value by default:   auctionTemplateId = 0;  ## Recommended Mitigation Steps Consider removing useless initialization.  
# Handle  pauliax   # Vulnerability details  ## Impact function createEscrow first assigns an index for the new isChildEscrow and only then pushes the struct to the array. When first escrow is being created, the array contains 0 elements so escrows.length-1 will underflow and return a max uint value:    isChildEscrow[address(newEscrow)] = Fermenter(true,_templateId,escrows.length-1);    escrows.push(newEscrow);  ## Recommended Mitigation Steps    isChildEscrow[address(newEscrow)] = Fermenter(true,_templateId,escrows.length);    escrows.push(newEscrow);  
# Handle  cmichel   # Vulnerability details  The `DutchAuction._currentPrice()` is computed by multiplying with `priceDrop()`. However, `priceDrop()` already performs a division and the final current price, therefore, loses precision.  Note that `priceDrop()` could even return `0` for ultra-low prices or very long auctions.  Imagine the actual payment per auction token price is `10^-12` => `startPrice` and `endPrice` are set with 18 decimals as ~`10^6`, but for auctions over a year (31,536,000 seconds > `10^6`) it'll then return 0.  ## Impact Precision can be lost leading to less accurate token auction results or even completely breaking the auction if the price is very low and the auctions are very long.  ## Recommended Mitigation Steps Perform all multiplications before divisions:  ```solidity uint256 priceDiff = block.timestamp.sub(uint256(marketInfo.startTime)).mul(     uint256(_marketPrice.startPrice.sub(_marketPrice.minimumPrice))   ) / uint256(_marketInfo.endTime.sub(_marketInfo.startTime)); ```   
# Handle  pauliax   # Vulnerability details  ## Impact function createToken emits TokenInitialized event, however, it does it before actually deploying the token so address(token) will always be empty (0x0):    emit TokenInitialized(address(token), _templateId, _data);    token = deployToken(_templateId, _integratorFeeAccount); This may confuse external consumers of this event.  ## Recommended Mitigation Steps Usually, a good practice is to emit events in the end after all the actions are done.  
# Handle  cmichel   # Vulnerability details  The `DutchAuction.clearingPrice` function can save gas by caching the computed prices instead of recomputing it.  ## Recommended Mitigation Steps Cache the values:  ```solidity function clearingPrice() public view returns (uint256) {     /// @dev If auction successful, return tokenPrice     uint256 _tokenPrice = tokenPrice();     uint256 _currentPrice = priceFunction();     return _tokenPrice > _currentPrice ? _tokenPrice : _currentPrice; } ```   
# Handle  cmichel   # Vulnerability details  The `CrowdSale.initCrowdsale` function checks that the auction token has 18 decimals through `IERC20(_token).decimals() == 18`. This seems to be related to `AUCTION_TOKEN_DECIMALS` and these values should not get ouf of sync.  ## Impact These values can easily get out of sync.  ## Recommended Mitigation Steps Create another named constant and set it to `18` decimals:  ```solidity uint256 private constant AUCTION_TOKEN_DECIMAL_PLACES = 18; uint256 private constant AUCTION_TOKEN_DECIMALS = 10 ** AUCTION_TOKEN_DECIMAL_PLACES; ```   
# Handle  cmichel   # Vulnerability details  Some tokens don't correctly implement the EIP20 standard and their `approve` function returns `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  Calls to `.approve` with user-defined tokens are made in: - `MISOLauncher.createLauncher` - `MISOMarket.createMarket`  ## Impact Tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the mentioned contracts as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin’s `SafeERC20` versions with the `safeApprove` function that handle the return value check as well as non-standard-compliant tokens.  
# Handle  pauliax   # Vulnerability details  ## Impact function lockTokens in contract TokenVault should check that _withdrawer is not empty (0x0) to prevent accidentally locked forever (burned) tokens.  ## Recommended Mitigation Steps require(_withdrawer != address(0));  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Emission of the event AccessControlTemplateAdded(address oldAccessControl, address newAccessControl) has the old and new addresses interchanged which could confuse/trigger offchain monitoring tools or interfaces.   This is of medium severity (instead of low) because it is related to access control template updation and critical to security of all contracts that rely on MISOAccessFactory.  The actual emit is emit AccessControlTemplateAdded(_template, accessControlTemplate); which has the parameter used in the oldAccessControl place instead of being used for the second argument, and vice-versa.  ## Proof of Concept https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/MISOAccessFactory.sol#L36-L37  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/MISOAccessFactory.sol#L100   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Interchange the arguments in the emit.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Market is guaranteed to be finalized by checking and calling finalize if not finalized. So the subsequent require()  by again checking market.finalized() is redundant and can save 2600+ gas by removing the external call. External calls cost 2600 gas after Berlin upgrade.  ## Proof of Concept  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L226-L229  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove the require().  
# Handle  leastwood   # Vulnerability details  ## Impact  If the current template ID is removed from `MISOLauncher.sol`, the function `removeLiquidityLauncherTemplate()` does not accurately reflect this by deleting `currentTemplateId[_templateId]`. This may lead to users actively using a removed template, expecting the `deployLauncher()` function to succeed when it will revert instead.  ## Proof of Concept  https://github.com/sushiswap/miso/blob/master/contracts/MISOLauncher.sol#L323-L334  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider removing `currentTemplateId[_templateId]` if the template to be removed by `removeLiquidityLauncherTemplate()` is the same template.  
# Handle  leastwood   # Vulnerability details  ## Impact  There are several contracts missing SPDX identifiers which correctly license the contract for open source development: `MISOAccessFactory.sol` `MISOAccessControls.sol` `MISOAdminAccess.sol` `PointList.sol` `TokenList.sol` `MISOMasterChef.sol` `CalculationsSushiswap.sol` `MISOHelper.sol` `PairsHelper.sol` `USDC.sol`  ## Proof of Concept  Refer to listed contracts.  ## Tools Used  Compiler warnings  ## Recommended Mitigation Steps  Consider adding `// SPDX-License-Identifier: GPL-3.0-only` to the top of the aforementioned files.  
# Handle  leastwood   # Vulnerability details  ## Impact  `TimelockController.sol` acts as an auxiliary contract to the MISO platform's core contracts. Therefore, this issue is not of high risk as not all users wanting to auction tokens will use this contract for governance behaviour. The `TimelockController.sol` enables a governance framework to enforce a timelock on any proposals, giving users time to exit before a potentially dangerous maintenance operation is applied. However, the `executeBatch()` is vulnerable to reentrancy, enabling privilege escalation for any account with the `EXECUTOR` role to `ADMIN`.  ## Proof of Concept  Bug outlined [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/access/TimelockController.sol#L244-L269). Fix is outlined in this [commit](https://github.com/OpenZeppelin/openzeppelin-contracts/commit/cec4f2ef57495d8b1742d62846da212515d99dd5#diff-8229f9027848871a1706845a5a84fa3e6591445cfac6e16cfb7d652e91e8d395R307).  ## Tools Used  Sourced from publicly disclosed post by [Immnuefi](https://medium.com/immunefi/openzeppelin-bug-fix-postmortem-66d8c89ed166).  ## Recommended Mitigation Steps  Update `Openzeppelin` library to a version containing the commit fixing the bug (mentioned above). Tag `v3.4.2-solc-0.7` in `Openzeppelin`'s Github repository is an example of a compatible library that contains the aforementioned bug fix.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function finalize() of all the auction contracts can be called by everyone before initMarket() is called. This will set status.finalized = true, which will probably not be detected until the auction is over (because it is only used in a few locations).  If this would happen then the auction cannot be finalized again. Also cancelAuction cannot be called.  Luckily the deployment of the auction contracts is done from createMarket in MISOMarket.sol, which directly calls initMarket(). So in practice this won't pose a problem, however future developers or forks might not be aware of this and deploy the contract differently.  ## Proof of Concept https://github.com/sushiswap/miso/blob/master/contracts/Auctions/Crowdsale.sol#L374  function finalize() public nonReentrant {         require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender)              || finalizeTimeExpired(),                         // initially  true             "Crowdsale: sender must be an admin"         );         MarketStatus storage status = marketStatus;         require(!status.finalized, "Crowdsale: already finalized");  // initially status.finalized==false         MarketInfo storage info = marketInfo;         require(auctionEnded(), "Crowdsale: Has not finished yet");   // initially  true          if (auctionSuccessful()) {  // initially  true             /// @dev Successful auction             /// @dev Transfer contributed tokens to wallet.             _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));             /// @dev Transfer unsold tokens to wallet.             uint256 soldTokens = _getTokenAmount(uint256(status.commitmentsTotal));             uint256 unsoldTokens = uint256(info.totalTokens).sub(soldTokens);             if(unsoldTokens > 0) {                 _safeTokenPayment(auctionToken, wallet, unsoldTokens);             }         } else {             /// @dev Failed auction             /// @dev Return auction tokens back to wallet.             _safeTokenPayment(auctionToken, wallet, uint256(info.totalTokens));         }          status.finalized = true;    // will end up here          emit AuctionFinalized();     }  function finalizeTimeExpired() public view returns (bool) {            return uint256(marketInfo.endTime) + 7 days < block.timestamp;  // initially  true (0 + 7 days <  block.timestamp)     }       function auctionSuccessful() public view returns (bool) {         return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal); // initially  true  (0>=0)     }   function auctionEnded() public view returns (bool) {         return block.timestamp > uint256(marketInfo.endTime) ||                              // // initially  true  (block.timestamp>0)         _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens);     }  // https://github.com/sushiswap/miso/blob/master/contracts/MISOMarket.sol#L273 function createMarket(...)     {         newMarket = deployMarket(_templateId, _integratorFeeAccount);         ...         IMisoMarket(newMarket).initMarket(_data);  ## Tools Used  ## Recommended Mitigation Steps In function finalize() add something like:     require(isInitialized(),"Not initialized");   
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose a Crowdsale is successful and enough commitments are made before the marketInfo.endTime. Suppose marketStatus.commitmentsTotal  == marketInfo.totalTokens -1      // note this is an edge case, but can be constructed by an attacker Then the function auctionEnded() returns true Assume auctionSuccessful() is also true (might depend on the config of marketPrice.goal and marketInfo.totalTokens) Then an admin can call finalize() to finalize the Crowdsale. The function finalize distributes the funds and the unsold tokens and sets status.finalized = true so that finalized cannot be called again. Now we have "marketInfo.totalTokens -1" tokens left in the contract  However commitEth() or commitTokens() can still be called (they give no error message that the auction has ended) Then functions call calculateCommitment, which luckily prevent from buying too much, however 1 token can still be bought These functions also call _addCommitment(), which only checks for marketInfo.endTime, which hasn't passed yet.  Now an extra token is sold and the contract has 1 token short. So the last person to withdraw his tokens cannot withdraw them (because you cannot specify how much you want to withdraw)  Also the revenues for the last token cannot be retrieved as finalize() cannot be called again.  ## Proof of Concept https://github.com/sushiswap/miso/blob/master/contracts/Auctions/Crowdsale.sol#L374 ```JS  function finalize() public nonReentrant {         require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender) || finalizeTimeExpired(),"Crowdsale: sender must be an admin"); // can be called by admin         MarketStatus storage status = marketStatus;         require(!status.finalized, "Crowdsale: already finalized");         MarketInfo storage info = marketInfo;         require(auctionEnded(), "Crowdsale: Has not finished yet");    // is true if enough sold, even if this is before marketInfo.endTime          if (auctionSuccessful()) {                       /// @dev Transfer contributed tokens to wallet.             /// @dev Transfer unsold tokens to wallet.         } else {             /// @dev Return auction tokens back to wallet.         }         status.finalized = true;  function auctionEnded() public view returns (bool) {         return block.timestamp > uint256(marketInfo.endTime) ||          _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens); // is true if enough sold, even if this is before marketInfo.endTime     }  function auctionSuccessful() public view returns (bool) {         return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal); }  function commitEth(address payable _beneficiary, bool readAndAgreedToMarketParticipationAgreement ) public payable nonReentrant  {        ...         uint256 ethToTransfer = calculateCommitment(msg.value);        ...        _addCommitment(_beneficiary, ethToTransfer);      function calculateCommitment(uint256 _commitment) public view returns (uint256 committed) { // this prevents buying too much         uint256 tokens = _getTokenAmount(_commitment);         uint256 tokensCommited =_getTokenAmount(uint256(marketStatus.commitmentsTotal));         if ( tokensCommited.add(tokens) > uint256(marketInfo.totalTokens)) {             return _getTokenPrice(uint256(marketInfo.totalTokens).sub(tokensCommited));         }         return _commitment;     }  function _addCommitment(address _addr, uint256 _commitment) internal {         require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), "Crowdsale: outside auction hours"); // doesn't check auctionEnded() nor status.finalized         ...         uint256 newCommitment = commitments[_addr].add(_commitment);         ...         commitments[_addr] = newCommitment;  function withdrawTokens(address payable beneficiary) public   nonReentrant  {             if (auctionSuccessful()) {             ...             uint256 tokensToClaim = tokensClaimable(beneficiary);             ...             claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);             _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);    // will fail is last token is missing         } else {    ## Tools Used  ## Recommended Mitigation Steps In the function _addCommitment, add a check on auctionEnded() or status.finalized  
# Handle  WatchPug   # Vulnerability details  `PostAuctionLauncher.finalize()` can be called by anyone, and it sends tokens directly to the pair pool to mint liquidity, even when the pair pool exists.  An attacker may control the LP price by creating the pool and then call `finalize()` to mint LP token with unfair price (pay huge amounts of tokens and get few amounts of LP token), and then remove the initial liquidity they acquired when creating the pool and takeout huge amounts of tokens.  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L257  ```solidity=216 /**  * @notice Finalizes Token sale and launches LP.  * @return liquidity Number of LPs.  */ function finalize() external nonReentrant returns (uint256 liquidity) {     // GP: Can we remove admin, let anyone can finalise and launch?     // require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), "PostAuction: Sender must be operator");     require(marketConnected(), "PostAuction: Auction must have this launcher address set as the destination wallet");     require(!launcherInfo.launched);      if (!market.finalized()) {         market.finalize();     }     require(market.finalized());      launcherInfo.launched = true;     if (!market.auctionSuccessful() ) {         return 0;     }      /// @dev if the auction is settled in weth, wrap any contract balance      uint256 launcherBalance = address(this).balance;     if (launcherBalance > 0 ) {         IWETH(weth).deposit{value : launcherBalance}();     }          (uint256 token1Amount, uint256 token2Amount) =  getTokenAmounts();      /// @dev cannot start a liquidity pool with no tokens on either side     if (token1Amount == 0 || token2Amount == 0 ) {         return 0;     }      address pair = factory.getPair(address(token1), address(token2));     if(pair == address(0)) {         createPool();     }      /// @dev add liquidity to pool via the pair directly     _safeTransfer(address(token1), tokenPair, token1Amount);     _safeTransfer(address(token2), tokenPair, token2Amount);     liquidity = IUniswapV2Pair(tokenPair).mint(address(this));     launcherInfo.liquidityAdded = BoringMath.to128(uint256(launcherInfo.liquidityAdded).add(liquidity));      /// @dev if unlock time not yet set, add it.     if (launcherInfo.unlock == 0 ) {         launcherInfo.unlock = BoringMath.to64(block.timestamp + uint256(launcherInfo.locktime));     }     emit LiquidityAdded(liquidity); } ```   In line 257, `PostAuctionLauncher` will mint LP with token1Amount and token2Amount. The amounts (token1Amount and token2Amount) are computed according to the auction result, without considering the current price (reserves) of the existing `tokenPair`.  See [PostAuctionLauncher.getTokenAmounts()](https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L268)  `PostAuctionLauncher` will receive an unfairly low amount of lp token because the amounts sent to `tokenPair` didn't match the current price of the pair.  See [UniswapV2Pair.mint(...)](https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/UniswapV2/UniswapV2Pair.sol#L135) ```solidity=135 liquidity = MathUniswap.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); ```  ## Impact  Lose a majority share of the tokens.  ## Proof of Concept  1. The attacker creates LP with 0.0000001 token1 and 1000 token2, receives 0.01 LP token; 2. Call `PostAuctionLauncher.finalize()`. PostAuctionLauncher will mint liquidity with 2000 token1 and 1000 token2 for example, receives only  0.01 LP token; 3. The attacker removes all his LP, receives 1000 token1 (most of which come from PostAuctionLauncher).  ## Recommended Mitigation Steps  To only support tokenPair created by PostAuctionLauncher or check for the token price before mint liquidity.  
# Handle  hrkrshnn   # Vulnerability details  ## Caching `totalPoints` during `setPoints` method  Instead of constantly writing to the same slot in a for loop, write it once at the end. This would save `100` gas for each iteration of the for loop. (Since [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929), the cost of writing to a dirty storage slot is 100 gas)  ``` diff modified   contracts/Access/PointList.sol @@ -65,6 +65,7 @@ contract PointList is IPointList, MISOAccessControls {     function setPoints(address[] memory _accounts, uint256[] memory _amounts) external override {          require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), "PointList.setPoints: Sender must be operator");          require(_accounts.length != 0, "PointList.setPoints: empty array");          require(_accounts.length == _amounts.length, "PointList.setPoints: incorrect array length"); +        uint totalPointsCache = totalPoints;          for (uint i = 0; i < _accounts.length; i++) {              address account = _accounts[i];              uint256 amount = _amounts[i]; @@ -72,9 +73,10 @@ contract PointList is IPointList, MISOAccessControls {               if (amount != previousPoints) {                  points[account] = amount; -                totalPoints = totalPoints.sub(previousPoints).add(amount); +                totalPointsCache = totalPointsCache.sub(previousPoints).add(amount);                  emit PointsUpdated(account, previousPoints, amount);              }          } +        totalPoints = totalPointsCache;      }  } ```   
# Handle  hrkrshnn   # Vulnerability details  ## Use `calldata` instead of `memory` for function parameters  In some cases, having function arguments in `calldata` instead of `memory` is more optimal.  Consider the following generic example:  ``` solidity contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above example, the dynamic array `arr` has the storage location `memory`. When the function gets called externally, the array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). And during the for loop, `arr[i]` accesses the value in memory using a `mload`. However, for the above example this is inefficient. Consider the following snippet instead:  ``` solidity contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  **Gas savings**: In the former example, the ABI decoding begins with copying value from `calldata` to `memory` in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  *In short*, use `calldata` instead of `memory` if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from `memory` to `calldata` may cause "unimplemented feature error". This can be avoided by using a newer (`0.8.*`) Solidity compiler.  ### (non-exhaustive) List of Examples  1.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/PointList.sol#L64> 2.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/ListFactory.sol#L151> 3.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/ListFactory.sol#L152> 4.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/PointList.sol#L64>    
# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * Misleading comment here (similarly with launcherInfo):   /// @notice Mapping from auction address created through this contract to Auction struct.   mapping(address => Token) public tokenInfo;  * In function deployToken this check should have an error message to indicate the user what's wrong:   require(tokenTemplates[_templateId] != address(0)); something like "MISOTokenFactory: incorrect _templateId". Also a meaningful revert message is missing here as regular user may not understand that token2 decimals should be >= token1 decimals:   require(d2 >= d1);  * There are a few copypasted misleading error messages, e.g. in function setCurrentTemplateId:      require(tokenTemplates[_templateId] != address(0), "MISOMarket: incorrect _templateId");      require(IMisoToken(tokenTemplates[_templateId]).tokenTemplate() == _templateType, "MISOMarket: incorrect _templateType"); should be MISOTokenFactory, not MISOMarket. Here also indicates the wrong location:    require(templateType > 0, "MISOLauncher: Incorrect template code "); You should consider revisiting and fixing them.  * There are hardcoded magic numbers, e.g. in MISOTokenFactory 1000 is indicating 100%. It would make code more readable and maintainable if you extract such numbers as constants.  * There is so much duplicated code across Auction contracts. Consider introducing an abstract BaseAuction (or similar name) contract that has common functions that specific auctions can inherit, e.g. ETH_ADDRESS, marketParticipationAgreement, revertBecauseUserDidNotProvideAgreement, etc.    
# Handle  pauliax   # Vulnerability details  ## Impact No need to check that _startTime < 10000000000 as it is later checked against _endTime which is also < 10000000000 :         require(_startTime < 10000000000, "Crowdsale: enter an unix timestamp in seconds, not miliseconds");         require(_endTime < 10000000000, "Crowdsale: enter an unix timestamp in seconds, not miliseconds");         ...         require(_endTime > _startTime, "Crowdsale: end time must be older than start price");  ## Recommended Mitigation Steps Remove this line:     require(_startTime < 10000000000, "Crowdsale: enter an unix timestamp in seconds, not miliseconds");  
# Handle  pauliax   # Vulnerability details  ## Impact WETH state variable in MISOLauncher is practically useless as it is not used in any meaningful way. Similarly, SECONDS_PER_DAY is not used in PostAuctionLauncher.  ## Recommended Mitigation Steps Consider removing unused variables.  
# Handle  pauliax   # Vulnerability details  ## Impact No need for this line in function initMISOMarket as it gets this value by default:   auctionTemplateId = 0;  ## Recommended Mitigation Steps Consider removing useless initialization.  
# Handle  pauliax   # Vulnerability details  ## Impact function createEscrow first assigns an index for the new isChildEscrow and only then pushes the struct to the array. When first escrow is being created, the array contains 0 elements so escrows.length-1 will underflow and return a max uint value:    isChildEscrow[address(newEscrow)] = Fermenter(true,_templateId,escrows.length-1);    escrows.push(newEscrow);  ## Recommended Mitigation Steps    isChildEscrow[address(newEscrow)] = Fermenter(true,_templateId,escrows.length);    escrows.push(newEscrow);  
# Handle  cmichel   # Vulnerability details  The `DutchAuction._currentPrice()` is computed by multiplying with `priceDrop()`. However, `priceDrop()` already performs a division and the final current price, therefore, loses precision.  Note that `priceDrop()` could even return `0` for ultra-low prices or very long auctions.  Imagine the actual payment per auction token price is `10^-12` => `startPrice` and `endPrice` are set with 18 decimals as ~`10^6`, but for auctions over a year (31,536,000 seconds > `10^6`) it'll then return 0.  ## Impact Precision can be lost leading to less accurate token auction results or even completely breaking the auction if the price is very low and the auctions are very long.  ## Recommended Mitigation Steps Perform all multiplications before divisions:  ```solidity uint256 priceDiff = block.timestamp.sub(uint256(marketInfo.startTime)).mul(     uint256(_marketPrice.startPrice.sub(_marketPrice.minimumPrice))   ) / uint256(_marketInfo.endTime.sub(_marketInfo.startTime)); ```   
# Handle  pauliax   # Vulnerability details  ## Impact function createToken emits TokenInitialized event, however, it does it before actually deploying the token so address(token) will always be empty (0x0):    emit TokenInitialized(address(token), _templateId, _data);    token = deployToken(_templateId, _integratorFeeAccount); This may confuse external consumers of this event.  ## Recommended Mitigation Steps Usually, a good practice is to emit events in the end after all the actions are done.  
# Handle  cmichel   # Vulnerability details  The `DutchAuction.clearingPrice` function can save gas by caching the computed prices instead of recomputing it.  ## Recommended Mitigation Steps Cache the values:  ```solidity function clearingPrice() public view returns (uint256) {     /// @dev If auction successful, return tokenPrice     uint256 _tokenPrice = tokenPrice();     uint256 _currentPrice = priceFunction();     return _tokenPrice > _currentPrice ? _tokenPrice : _currentPrice; } ```   
# Handle  cmichel   # Vulnerability details  The `CrowdSale.initCrowdsale` function checks that the auction token has 18 decimals through `IERC20(_token).decimals() == 18`. This seems to be related to `AUCTION_TOKEN_DECIMALS` and these values should not get ouf of sync.  ## Impact These values can easily get out of sync.  ## Recommended Mitigation Steps Create another named constant and set it to `18` decimals:  ```solidity uint256 private constant AUCTION_TOKEN_DECIMAL_PLACES = 18; uint256 private constant AUCTION_TOKEN_DECIMALS = 10 ** AUCTION_TOKEN_DECIMAL_PLACES; ```   
# Handle  cmichel   # Vulnerability details  Some tokens don't correctly implement the EIP20 standard and their `approve` function returns `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  Calls to `.approve` with user-defined tokens are made in: - `MISOLauncher.createLauncher` - `MISOMarket.createMarket`  ## Impact Tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the mentioned contracts as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin’s `SafeERC20` versions with the `safeApprove` function that handle the return value check as well as non-standard-compliant tokens.  
# Handle  pauliax   # Vulnerability details  ## Impact function lockTokens in contract TokenVault should check that _withdrawer is not empty (0x0) to prevent accidentally locked forever (burned) tokens.  ## Recommended Mitigation Steps require(_withdrawer != address(0));  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Emission of the event AccessControlTemplateAdded(address oldAccessControl, address newAccessControl) has the old and new addresses interchanged which could confuse/trigger offchain monitoring tools or interfaces.   This is of medium severity (instead of low) because it is related to access control template updation and critical to security of all contracts that rely on MISOAccessFactory.  The actual emit is emit AccessControlTemplateAdded(_template, accessControlTemplate); which has the parameter used in the oldAccessControl place instead of being used for the second argument, and vice-versa.  ## Proof of Concept https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/MISOAccessFactory.sol#L36-L37  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/MISOAccessFactory.sol#L100   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Interchange the arguments in the emit.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Market is guaranteed to be finalized by checking and calling finalize if not finalized. So the subsequent require()  by again checking market.finalized() is redundant and can save 2600+ gas by removing the external call. External calls cost 2600 gas after Berlin upgrade.  ## Proof of Concept  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L226-L229  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove the require().  
# Handle  leastwood   # Vulnerability details  ## Impact  If the current template ID is removed from `MISOLauncher.sol`, the function `removeLiquidityLauncherTemplate()` does not accurately reflect this by deleting `currentTemplateId[_templateId]`. This may lead to users actively using a removed template, expecting the `deployLauncher()` function to succeed when it will revert instead.  ## Proof of Concept  https://github.com/sushiswap/miso/blob/master/contracts/MISOLauncher.sol#L323-L334  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider removing `currentTemplateId[_templateId]` if the template to be removed by `removeLiquidityLauncherTemplate()` is the same template.  
# Handle  leastwood   # Vulnerability details  ## Impact  There are several contracts missing SPDX identifiers which correctly license the contract for open source development: `MISOAccessFactory.sol` `MISOAccessControls.sol` `MISOAdminAccess.sol` `PointList.sol` `TokenList.sol` `MISOMasterChef.sol` `CalculationsSushiswap.sol` `MISOHelper.sol` `PairsHelper.sol` `USDC.sol`  ## Proof of Concept  Refer to listed contracts.  ## Tools Used  Compiler warnings  ## Recommended Mitigation Steps  Consider adding `// SPDX-License-Identifier: GPL-3.0-only` to the top of the aforementioned files.  
# Handle  leastwood   # Vulnerability details  ## Impact  `TimelockController.sol` acts as an auxiliary contract to the MISO platform's core contracts. Therefore, this issue is not of high risk as not all users wanting to auction tokens will use this contract for governance behaviour. The `TimelockController.sol` enables a governance framework to enforce a timelock on any proposals, giving users time to exit before a potentially dangerous maintenance operation is applied. However, the `executeBatch()` is vulnerable to reentrancy, enabling privilege escalation for any account with the `EXECUTOR` role to `ADMIN`.  ## Proof of Concept  Bug outlined [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/access/TimelockController.sol#L244-L269). Fix is outlined in this [commit](https://github.com/OpenZeppelin/openzeppelin-contracts/commit/cec4f2ef57495d8b1742d62846da212515d99dd5#diff-8229f9027848871a1706845a5a84fa3e6591445cfac6e16cfb7d652e91e8d395R307).  ## Tools Used  Sourced from publicly disclosed post by [Immnuefi](https://medium.com/immunefi/openzeppelin-bug-fix-postmortem-66d8c89ed166).  ## Recommended Mitigation Steps  Update `Openzeppelin` library to a version containing the commit fixing the bug (mentioned above). Tag `v3.4.2-solc-0.7` in `Openzeppelin`'s Github repository is an example of a compatible library that contains the aforementioned bug fix.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function finalize() of all the auction contracts can be called by everyone before initMarket() is called. This will set status.finalized = true, which will probably not be detected until the auction is over (because it is only used in a few locations).  If this would happen then the auction cannot be finalized again. Also cancelAuction cannot be called.  Luckily the deployment of the auction contracts is done from createMarket in MISOMarket.sol, which directly calls initMarket(). So in practice this won't pose a problem, however future developers or forks might not be aware of this and deploy the contract differently.  ## Proof of Concept https://github.com/sushiswap/miso/blob/master/contracts/Auctions/Crowdsale.sol#L374  function finalize() public nonReentrant {         require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender)              || finalizeTimeExpired(),                         // initially  true             "Crowdsale: sender must be an admin"         );         MarketStatus storage status = marketStatus;         require(!status.finalized, "Crowdsale: already finalized");  // initially status.finalized==false         MarketInfo storage info = marketInfo;         require(auctionEnded(), "Crowdsale: Has not finished yet");   // initially  true          if (auctionSuccessful()) {  // initially  true             /// @dev Successful auction             /// @dev Transfer contributed tokens to wallet.             _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));             /// @dev Transfer unsold tokens to wallet.             uint256 soldTokens = _getTokenAmount(uint256(status.commitmentsTotal));             uint256 unsoldTokens = uint256(info.totalTokens).sub(soldTokens);             if(unsoldTokens > 0) {                 _safeTokenPayment(auctionToken, wallet, unsoldTokens);             }         } else {             /// @dev Failed auction             /// @dev Return auction tokens back to wallet.             _safeTokenPayment(auctionToken, wallet, uint256(info.totalTokens));         }          status.finalized = true;    // will end up here          emit AuctionFinalized();     }  function finalizeTimeExpired() public view returns (bool) {            return uint256(marketInfo.endTime) + 7 days < block.timestamp;  // initially  true (0 + 7 days <  block.timestamp)     }       function auctionSuccessful() public view returns (bool) {         return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal); // initially  true  (0>=0)     }   function auctionEnded() public view returns (bool) {         return block.timestamp > uint256(marketInfo.endTime) ||                              // // initially  true  (block.timestamp>0)         _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens);     }  // https://github.com/sushiswap/miso/blob/master/contracts/MISOMarket.sol#L273 function createMarket(...)     {         newMarket = deployMarket(_templateId, _integratorFeeAccount);         ...         IMisoMarket(newMarket).initMarket(_data);  ## Tools Used  ## Recommended Mitigation Steps In function finalize() add something like:     require(isInitialized(),"Not initialized");   
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose a Crowdsale is successful and enough commitments are made before the marketInfo.endTime. Suppose marketStatus.commitmentsTotal  == marketInfo.totalTokens -1      // note this is an edge case, but can be constructed by an attacker Then the function auctionEnded() returns true Assume auctionSuccessful() is also true (might depend on the config of marketPrice.goal and marketInfo.totalTokens) Then an admin can call finalize() to finalize the Crowdsale. The function finalize distributes the funds and the unsold tokens and sets status.finalized = true so that finalized cannot be called again. Now we have "marketInfo.totalTokens -1" tokens left in the contract  However commitEth() or commitTokens() can still be called (they give no error message that the auction has ended) Then functions call calculateCommitment, which luckily prevent from buying too much, however 1 token can still be bought These functions also call _addCommitment(), which only checks for marketInfo.endTime, which hasn't passed yet.  Now an extra token is sold and the contract has 1 token short. So the last person to withdraw his tokens cannot withdraw them (because you cannot specify how much you want to withdraw)  Also the revenues for the last token cannot be retrieved as finalize() cannot be called again.  ## Proof of Concept https://github.com/sushiswap/miso/blob/master/contracts/Auctions/Crowdsale.sol#L374 ```JS  function finalize() public nonReentrant {         require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender) || finalizeTimeExpired(),"Crowdsale: sender must be an admin"); // can be called by admin         MarketStatus storage status = marketStatus;         require(!status.finalized, "Crowdsale: already finalized");         MarketInfo storage info = marketInfo;         require(auctionEnded(), "Crowdsale: Has not finished yet");    // is true if enough sold, even if this is before marketInfo.endTime          if (auctionSuccessful()) {                       /// @dev Transfer contributed tokens to wallet.             /// @dev Transfer unsold tokens to wallet.         } else {             /// @dev Return auction tokens back to wallet.         }         status.finalized = true;  function auctionEnded() public view returns (bool) {         return block.timestamp > uint256(marketInfo.endTime) ||          _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens); // is true if enough sold, even if this is before marketInfo.endTime     }  function auctionSuccessful() public view returns (bool) {         return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal); }  function commitEth(address payable _beneficiary, bool readAndAgreedToMarketParticipationAgreement ) public payable nonReentrant  {        ...         uint256 ethToTransfer = calculateCommitment(msg.value);        ...        _addCommitment(_beneficiary, ethToTransfer);      function calculateCommitment(uint256 _commitment) public view returns (uint256 committed) { // this prevents buying too much         uint256 tokens = _getTokenAmount(_commitment);         uint256 tokensCommited =_getTokenAmount(uint256(marketStatus.commitmentsTotal));         if ( tokensCommited.add(tokens) > uint256(marketInfo.totalTokens)) {             return _getTokenPrice(uint256(marketInfo.totalTokens).sub(tokensCommited));         }         return _commitment;     }  function _addCommitment(address _addr, uint256 _commitment) internal {         require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), "Crowdsale: outside auction hours"); // doesn't check auctionEnded() nor status.finalized         ...         uint256 newCommitment = commitments[_addr].add(_commitment);         ...         commitments[_addr] = newCommitment;  function withdrawTokens(address payable beneficiary) public   nonReentrant  {             if (auctionSuccessful()) {             ...             uint256 tokensToClaim = tokensClaimable(beneficiary);             ...             claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);             _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);    // will fail is last token is missing         } else {    ## Tools Used  ## Recommended Mitigation Steps In the function _addCommitment, add a check on auctionEnded() or status.finalized  
# Handle  WatchPug   # Vulnerability details  `PostAuctionLauncher.finalize()` can be called by anyone, and it sends tokens directly to the pair pool to mint liquidity, even when the pair pool exists.  An attacker may control the LP price by creating the pool and then call `finalize()` to mint LP token with unfair price (pay huge amounts of tokens and get few amounts of LP token), and then remove the initial liquidity they acquired when creating the pool and takeout huge amounts of tokens.  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L257  ```solidity=216 /**  * @notice Finalizes Token sale and launches LP.  * @return liquidity Number of LPs.  */ function finalize() external nonReentrant returns (uint256 liquidity) {     // GP: Can we remove admin, let anyone can finalise and launch?     // require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), "PostAuction: Sender must be operator");     require(marketConnected(), "PostAuction: Auction must have this launcher address set as the destination wallet");     require(!launcherInfo.launched);      if (!market.finalized()) {         market.finalize();     }     require(market.finalized());      launcherInfo.launched = true;     if (!market.auctionSuccessful() ) {         return 0;     }      /// @dev if the auction is settled in weth, wrap any contract balance      uint256 launcherBalance = address(this).balance;     if (launcherBalance > 0 ) {         IWETH(weth).deposit{value : launcherBalance}();     }          (uint256 token1Amount, uint256 token2Amount) =  getTokenAmounts();      /// @dev cannot start a liquidity pool with no tokens on either side     if (token1Amount == 0 || token2Amount == 0 ) {         return 0;     }      address pair = factory.getPair(address(token1), address(token2));     if(pair == address(0)) {         createPool();     }      /// @dev add liquidity to pool via the pair directly     _safeTransfer(address(token1), tokenPair, token1Amount);     _safeTransfer(address(token2), tokenPair, token2Amount);     liquidity = IUniswapV2Pair(tokenPair).mint(address(this));     launcherInfo.liquidityAdded = BoringMath.to128(uint256(launcherInfo.liquidityAdded).add(liquidity));      /// @dev if unlock time not yet set, add it.     if (launcherInfo.unlock == 0 ) {         launcherInfo.unlock = BoringMath.to64(block.timestamp + uint256(launcherInfo.locktime));     }     emit LiquidityAdded(liquidity); } ```   In line 257, `PostAuctionLauncher` will mint LP with token1Amount and token2Amount. The amounts (token1Amount and token2Amount) are computed according to the auction result, without considering the current price (reserves) of the existing `tokenPair`.  See [PostAuctionLauncher.getTokenAmounts()](https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L268)  `PostAuctionLauncher` will receive an unfairly low amount of lp token because the amounts sent to `tokenPair` didn't match the current price of the pair.  See [UniswapV2Pair.mint(...)](https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/UniswapV2/UniswapV2Pair.sol#L135) ```solidity=135 liquidity = MathUniswap.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); ```  ## Impact  Lose a majority share of the tokens.  ## Proof of Concept  1. The attacker creates LP with 0.0000001 token1 and 1000 token2, receives 0.01 LP token; 2. Call `PostAuctionLauncher.finalize()`. PostAuctionLauncher will mint liquidity with 2000 token1 and 1000 token2 for example, receives only  0.01 LP token; 3. The attacker removes all his LP, receives 1000 token1 (most of which come from PostAuctionLauncher).  ## Recommended Mitigation Steps  To only support tokenPair created by PostAuctionLauncher or check for the token price before mint liquidity.  
# Handle  hrkrshnn   # Vulnerability details  ## Caching `totalPoints` during `setPoints` method  Instead of constantly writing to the same slot in a for loop, write it once at the end. This would save `100` gas for each iteration of the for loop. (Since [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929), the cost of writing to a dirty storage slot is 100 gas)  ``` diff modified   contracts/Access/PointList.sol @@ -65,6 +65,7 @@ contract PointList is IPointList, MISOAccessControls {     function setPoints(address[] memory _accounts, uint256[] memory _amounts) external override {          require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), "PointList.setPoints: Sender must be operator");          require(_accounts.length != 0, "PointList.setPoints: empty array");          require(_accounts.length == _amounts.length, "PointList.setPoints: incorrect array length"); +        uint totalPointsCache = totalPoints;          for (uint i = 0; i < _accounts.length; i++) {              address account = _accounts[i];              uint256 amount = _amounts[i]; @@ -72,9 +73,10 @@ contract PointList is IPointList, MISOAccessControls {               if (amount != previousPoints) {                  points[account] = amount; -                totalPoints = totalPoints.sub(previousPoints).add(amount); +                totalPointsCache = totalPointsCache.sub(previousPoints).add(amount);                  emit PointsUpdated(account, previousPoints, amount);              }          } +        totalPoints = totalPointsCache;      }  } ```   
# Handle  hrkrshnn   # Vulnerability details  ## Use `calldata` instead of `memory` for function parameters  In some cases, having function arguments in `calldata` instead of `memory` is more optimal.  Consider the following generic example:  ``` solidity contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above example, the dynamic array `arr` has the storage location `memory`. When the function gets called externally, the array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). And during the for loop, `arr[i]` accesses the value in memory using a `mload`. However, for the above example this is inefficient. Consider the following snippet instead:  ``` solidity contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  **Gas savings**: In the former example, the ABI decoding begins with copying value from `calldata` to `memory` in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  *In short*, use `calldata` instead of `memory` if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from `memory` to `calldata` may cause "unimplemented feature error". This can be avoided by using a newer (`0.8.*`) Solidity compiler.  ### (non-exhaustive) List of Examples  1.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/PointList.sol#L64> 2.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/ListFactory.sol#L151> 3.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/ListFactory.sol#L152> 4.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/PointList.sol#L64>    
# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * Misleading comment here (similarly with launcherInfo):   /// @notice Mapping from auction address created through this contract to Auction struct.   mapping(address => Token) public tokenInfo;  * In function deployToken this check should have an error message to indicate the user what's wrong:   require(tokenTemplates[_templateId] != address(0)); something like "MISOTokenFactory: incorrect _templateId". Also a meaningful revert message is missing here as regular user may not understand that token2 decimals should be >= token1 decimals:   require(d2 >= d1);  * There are a few copypasted misleading error messages, e.g. in function setCurrentTemplateId:      require(tokenTemplates[_templateId] != address(0), "MISOMarket: incorrect _templateId");      require(IMisoToken(tokenTemplates[_templateId]).tokenTemplate() == _templateType, "MISOMarket: incorrect _templateType"); should be MISOTokenFactory, not MISOMarket. Here also indicates the wrong location:    require(templateType > 0, "MISOLauncher: Incorrect template code "); You should consider revisiting and fixing them.  * There are hardcoded magic numbers, e.g. in MISOTokenFactory 1000 is indicating 100%. It would make code more readable and maintainable if you extract such numbers as constants.  * There is so much duplicated code across Auction contracts. Consider introducing an abstract BaseAuction (or similar name) contract that has common functions that specific auctions can inherit, e.g. ETH_ADDRESS, marketParticipationAgreement, revertBecauseUserDidNotProvideAgreement, etc.    
# Handle  pauliax   # Vulnerability details  ## Impact No need to check that _startTime < 10000000000 as it is later checked against _endTime which is also < 10000000000 :         require(_startTime < 10000000000, "Crowdsale: enter an unix timestamp in seconds, not miliseconds");         require(_endTime < 10000000000, "Crowdsale: enter an unix timestamp in seconds, not miliseconds");         ...         require(_endTime > _startTime, "Crowdsale: end time must be older than start price");  ## Recommended Mitigation Steps Remove this line:     require(_startTime < 10000000000, "Crowdsale: enter an unix timestamp in seconds, not miliseconds");  
# Handle  pauliax   # Vulnerability details  ## Impact WETH state variable in MISOLauncher is practically useless as it is not used in any meaningful way. Similarly, SECONDS_PER_DAY is not used in PostAuctionLauncher.  ## Recommended Mitigation Steps Consider removing unused variables.  
# Handle  pauliax   # Vulnerability details  ## Impact No need for this line in function initMISOMarket as it gets this value by default:   auctionTemplateId = 0;  ## Recommended Mitigation Steps Consider removing useless initialization.  
# Handle  pauliax   # Vulnerability details  ## Impact function createEscrow first assigns an index for the new isChildEscrow and only then pushes the struct to the array. When first escrow is being created, the array contains 0 elements so escrows.length-1 will underflow and return a max uint value:    isChildEscrow[address(newEscrow)] = Fermenter(true,_templateId,escrows.length-1);    escrows.push(newEscrow);  ## Recommended Mitigation Steps    isChildEscrow[address(newEscrow)] = Fermenter(true,_templateId,escrows.length);    escrows.push(newEscrow);  
# Handle  cmichel   # Vulnerability details  The `DutchAuction._currentPrice()` is computed by multiplying with `priceDrop()`. However, `priceDrop()` already performs a division and the final current price, therefore, loses precision.  Note that `priceDrop()` could even return `0` for ultra-low prices or very long auctions.  Imagine the actual payment per auction token price is `10^-12` => `startPrice` and `endPrice` are set with 18 decimals as ~`10^6`, but for auctions over a year (31,536,000 seconds > `10^6`) it'll then return 0.  ## Impact Precision can be lost leading to less accurate token auction results or even completely breaking the auction if the price is very low and the auctions are very long.  ## Recommended Mitigation Steps Perform all multiplications before divisions:  ```solidity uint256 priceDiff = block.timestamp.sub(uint256(marketInfo.startTime)).mul(     uint256(_marketPrice.startPrice.sub(_marketPrice.minimumPrice))   ) / uint256(_marketInfo.endTime.sub(_marketInfo.startTime)); ```   
# Handle  pauliax   # Vulnerability details  ## Impact function createToken emits TokenInitialized event, however, it does it before actually deploying the token so address(token) will always be empty (0x0):    emit TokenInitialized(address(token), _templateId, _data);    token = deployToken(_templateId, _integratorFeeAccount); This may confuse external consumers of this event.  ## Recommended Mitigation Steps Usually, a good practice is to emit events in the end after all the actions are done.  
# Handle  cmichel   # Vulnerability details  The `DutchAuction.clearingPrice` function can save gas by caching the computed prices instead of recomputing it.  ## Recommended Mitigation Steps Cache the values:  ```solidity function clearingPrice() public view returns (uint256) {     /// @dev If auction successful, return tokenPrice     uint256 _tokenPrice = tokenPrice();     uint256 _currentPrice = priceFunction();     return _tokenPrice > _currentPrice ? _tokenPrice : _currentPrice; } ```   
# Handle  cmichel   # Vulnerability details  The `CrowdSale.initCrowdsale` function checks that the auction token has 18 decimals through `IERC20(_token).decimals() == 18`. This seems to be related to `AUCTION_TOKEN_DECIMALS` and these values should not get ouf of sync.  ## Impact These values can easily get out of sync.  ## Recommended Mitigation Steps Create another named constant and set it to `18` decimals:  ```solidity uint256 private constant AUCTION_TOKEN_DECIMAL_PLACES = 18; uint256 private constant AUCTION_TOKEN_DECIMALS = 10 ** AUCTION_TOKEN_DECIMAL_PLACES; ```   
# Handle  cmichel   # Vulnerability details  Some tokens don't correctly implement the EIP20 standard and their `approve` function returns `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  Calls to `.approve` with user-defined tokens are made in: - `MISOLauncher.createLauncher` - `MISOMarket.createMarket`  ## Impact Tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the mentioned contracts as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin’s `SafeERC20` versions with the `safeApprove` function that handle the return value check as well as non-standard-compliant tokens.  
# Handle  pauliax   # Vulnerability details  ## Impact function lockTokens in contract TokenVault should check that _withdrawer is not empty (0x0) to prevent accidentally locked forever (burned) tokens.  ## Recommended Mitigation Steps require(_withdrawer != address(0));  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Emission of the event AccessControlTemplateAdded(address oldAccessControl, address newAccessControl) has the old and new addresses interchanged which could confuse/trigger offchain monitoring tools or interfaces.   This is of medium severity (instead of low) because it is related to access control template updation and critical to security of all contracts that rely on MISOAccessFactory.  The actual emit is emit AccessControlTemplateAdded(_template, accessControlTemplate); which has the parameter used in the oldAccessControl place instead of being used for the second argument, and vice-versa.  ## Proof of Concept https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/MISOAccessFactory.sol#L36-L37  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/MISOAccessFactory.sol#L100   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Interchange the arguments in the emit.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Market is guaranteed to be finalized by checking and calling finalize if not finalized. So the subsequent require()  by again checking market.finalized() is redundant and can save 2600+ gas by removing the external call. External calls cost 2600 gas after Berlin upgrade.  ## Proof of Concept  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L226-L229  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove the require().  
# Handle  leastwood   # Vulnerability details  ## Impact  If the current template ID is removed from `MISOLauncher.sol`, the function `removeLiquidityLauncherTemplate()` does not accurately reflect this by deleting `currentTemplateId[_templateId]`. This may lead to users actively using a removed template, expecting the `deployLauncher()` function to succeed when it will revert instead.  ## Proof of Concept  https://github.com/sushiswap/miso/blob/master/contracts/MISOLauncher.sol#L323-L334  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider removing `currentTemplateId[_templateId]` if the template to be removed by `removeLiquidityLauncherTemplate()` is the same template.  
# Handle  leastwood   # Vulnerability details  ## Impact  There are several contracts missing SPDX identifiers which correctly license the contract for open source development: `MISOAccessFactory.sol` `MISOAccessControls.sol` `MISOAdminAccess.sol` `PointList.sol` `TokenList.sol` `MISOMasterChef.sol` `CalculationsSushiswap.sol` `MISOHelper.sol` `PairsHelper.sol` `USDC.sol`  ## Proof of Concept  Refer to listed contracts.  ## Tools Used  Compiler warnings  ## Recommended Mitigation Steps  Consider adding `// SPDX-License-Identifier: GPL-3.0-only` to the top of the aforementioned files.  
# Handle  leastwood   # Vulnerability details  ## Impact  `TimelockController.sol` acts as an auxiliary contract to the MISO platform's core contracts. Therefore, this issue is not of high risk as not all users wanting to auction tokens will use this contract for governance behaviour. The `TimelockController.sol` enables a governance framework to enforce a timelock on any proposals, giving users time to exit before a potentially dangerous maintenance operation is applied. However, the `executeBatch()` is vulnerable to reentrancy, enabling privilege escalation for any account with the `EXECUTOR` role to `ADMIN`.  ## Proof of Concept  Bug outlined [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/access/TimelockController.sol#L244-L269). Fix is outlined in this [commit](https://github.com/OpenZeppelin/openzeppelin-contracts/commit/cec4f2ef57495d8b1742d62846da212515d99dd5#diff-8229f9027848871a1706845a5a84fa3e6591445cfac6e16cfb7d652e91e8d395R307).  ## Tools Used  Sourced from publicly disclosed post by [Immnuefi](https://medium.com/immunefi/openzeppelin-bug-fix-postmortem-66d8c89ed166).  ## Recommended Mitigation Steps  Update `Openzeppelin` library to a version containing the commit fixing the bug (mentioned above). Tag `v3.4.2-solc-0.7` in `Openzeppelin`'s Github repository is an example of a compatible library that contains the aforementioned bug fix.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function finalize() of all the auction contracts can be called by everyone before initMarket() is called. This will set status.finalized = true, which will probably not be detected until the auction is over (because it is only used in a few locations).  If this would happen then the auction cannot be finalized again. Also cancelAuction cannot be called.  Luckily the deployment of the auction contracts is done from createMarket in MISOMarket.sol, which directly calls initMarket(). So in practice this won't pose a problem, however future developers or forks might not be aware of this and deploy the contract differently.  ## Proof of Concept https://github.com/sushiswap/miso/blob/master/contracts/Auctions/Crowdsale.sol#L374  function finalize() public nonReentrant {         require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender)              || finalizeTimeExpired(),                         // initially  true             "Crowdsale: sender must be an admin"         );         MarketStatus storage status = marketStatus;         require(!status.finalized, "Crowdsale: already finalized");  // initially status.finalized==false         MarketInfo storage info = marketInfo;         require(auctionEnded(), "Crowdsale: Has not finished yet");   // initially  true          if (auctionSuccessful()) {  // initially  true             /// @dev Successful auction             /// @dev Transfer contributed tokens to wallet.             _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));             /// @dev Transfer unsold tokens to wallet.             uint256 soldTokens = _getTokenAmount(uint256(status.commitmentsTotal));             uint256 unsoldTokens = uint256(info.totalTokens).sub(soldTokens);             if(unsoldTokens > 0) {                 _safeTokenPayment(auctionToken, wallet, unsoldTokens);             }         } else {             /// @dev Failed auction             /// @dev Return auction tokens back to wallet.             _safeTokenPayment(auctionToken, wallet, uint256(info.totalTokens));         }          status.finalized = true;    // will end up here          emit AuctionFinalized();     }  function finalizeTimeExpired() public view returns (bool) {            return uint256(marketInfo.endTime) + 7 days < block.timestamp;  // initially  true (0 + 7 days <  block.timestamp)     }       function auctionSuccessful() public view returns (bool) {         return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal); // initially  true  (0>=0)     }   function auctionEnded() public view returns (bool) {         return block.timestamp > uint256(marketInfo.endTime) ||                              // // initially  true  (block.timestamp>0)         _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens);     }  // https://github.com/sushiswap/miso/blob/master/contracts/MISOMarket.sol#L273 function createMarket(...)     {         newMarket = deployMarket(_templateId, _integratorFeeAccount);         ...         IMisoMarket(newMarket).initMarket(_data);  ## Tools Used  ## Recommended Mitigation Steps In function finalize() add something like:     require(isInitialized(),"Not initialized");   
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose a Crowdsale is successful and enough commitments are made before the marketInfo.endTime. Suppose marketStatus.commitmentsTotal  == marketInfo.totalTokens -1      // note this is an edge case, but can be constructed by an attacker Then the function auctionEnded() returns true Assume auctionSuccessful() is also true (might depend on the config of marketPrice.goal and marketInfo.totalTokens) Then an admin can call finalize() to finalize the Crowdsale. The function finalize distributes the funds and the unsold tokens and sets status.finalized = true so that finalized cannot be called again. Now we have "marketInfo.totalTokens -1" tokens left in the contract  However commitEth() or commitTokens() can still be called (they give no error message that the auction has ended) Then functions call calculateCommitment, which luckily prevent from buying too much, however 1 token can still be bought These functions also call _addCommitment(), which only checks for marketInfo.endTime, which hasn't passed yet.  Now an extra token is sold and the contract has 1 token short. So the last person to withdraw his tokens cannot withdraw them (because you cannot specify how much you want to withdraw)  Also the revenues for the last token cannot be retrieved as finalize() cannot be called again.  ## Proof of Concept https://github.com/sushiswap/miso/blob/master/contracts/Auctions/Crowdsale.sol#L374 ```JS  function finalize() public nonReentrant {         require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender) || finalizeTimeExpired(),"Crowdsale: sender must be an admin"); // can be called by admin         MarketStatus storage status = marketStatus;         require(!status.finalized, "Crowdsale: already finalized");         MarketInfo storage info = marketInfo;         require(auctionEnded(), "Crowdsale: Has not finished yet");    // is true if enough sold, even if this is before marketInfo.endTime          if (auctionSuccessful()) {                       /// @dev Transfer contributed tokens to wallet.             /// @dev Transfer unsold tokens to wallet.         } else {             /// @dev Return auction tokens back to wallet.         }         status.finalized = true;  function auctionEnded() public view returns (bool) {         return block.timestamp > uint256(marketInfo.endTime) ||          _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens); // is true if enough sold, even if this is before marketInfo.endTime     }  function auctionSuccessful() public view returns (bool) {         return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal); }  function commitEth(address payable _beneficiary, bool readAndAgreedToMarketParticipationAgreement ) public payable nonReentrant  {        ...         uint256 ethToTransfer = calculateCommitment(msg.value);        ...        _addCommitment(_beneficiary, ethToTransfer);      function calculateCommitment(uint256 _commitment) public view returns (uint256 committed) { // this prevents buying too much         uint256 tokens = _getTokenAmount(_commitment);         uint256 tokensCommited =_getTokenAmount(uint256(marketStatus.commitmentsTotal));         if ( tokensCommited.add(tokens) > uint256(marketInfo.totalTokens)) {             return _getTokenPrice(uint256(marketInfo.totalTokens).sub(tokensCommited));         }         return _commitment;     }  function _addCommitment(address _addr, uint256 _commitment) internal {         require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), "Crowdsale: outside auction hours"); // doesn't check auctionEnded() nor status.finalized         ...         uint256 newCommitment = commitments[_addr].add(_commitment);         ...         commitments[_addr] = newCommitment;  function withdrawTokens(address payable beneficiary) public   nonReentrant  {             if (auctionSuccessful()) {             ...             uint256 tokensToClaim = tokensClaimable(beneficiary);             ...             claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);             _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);    // will fail is last token is missing         } else {    ## Tools Used  ## Recommended Mitigation Steps In the function _addCommitment, add a check on auctionEnded() or status.finalized  
# Handle  WatchPug   # Vulnerability details  `PostAuctionLauncher.finalize()` can be called by anyone, and it sends tokens directly to the pair pool to mint liquidity, even when the pair pool exists.  An attacker may control the LP price by creating the pool and then call `finalize()` to mint LP token with unfair price (pay huge amounts of tokens and get few amounts of LP token), and then remove the initial liquidity they acquired when creating the pool and takeout huge amounts of tokens.  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L257  ```solidity=216 /**  * @notice Finalizes Token sale and launches LP.  * @return liquidity Number of LPs.  */ function finalize() external nonReentrant returns (uint256 liquidity) {     // GP: Can we remove admin, let anyone can finalise and launch?     // require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), "PostAuction: Sender must be operator");     require(marketConnected(), "PostAuction: Auction must have this launcher address set as the destination wallet");     require(!launcherInfo.launched);      if (!market.finalized()) {         market.finalize();     }     require(market.finalized());      launcherInfo.launched = true;     if (!market.auctionSuccessful() ) {         return 0;     }      /// @dev if the auction is settled in weth, wrap any contract balance      uint256 launcherBalance = address(this).balance;     if (launcherBalance > 0 ) {         IWETH(weth).deposit{value : launcherBalance}();     }          (uint256 token1Amount, uint256 token2Amount) =  getTokenAmounts();      /// @dev cannot start a liquidity pool with no tokens on either side     if (token1Amount == 0 || token2Amount == 0 ) {         return 0;     }      address pair = factory.getPair(address(token1), address(token2));     if(pair == address(0)) {         createPool();     }      /// @dev add liquidity to pool via the pair directly     _safeTransfer(address(token1), tokenPair, token1Amount);     _safeTransfer(address(token2), tokenPair, token2Amount);     liquidity = IUniswapV2Pair(tokenPair).mint(address(this));     launcherInfo.liquidityAdded = BoringMath.to128(uint256(launcherInfo.liquidityAdded).add(liquidity));      /// @dev if unlock time not yet set, add it.     if (launcherInfo.unlock == 0 ) {         launcherInfo.unlock = BoringMath.to64(block.timestamp + uint256(launcherInfo.locktime));     }     emit LiquidityAdded(liquidity); } ```   In line 257, `PostAuctionLauncher` will mint LP with token1Amount and token2Amount. The amounts (token1Amount and token2Amount) are computed according to the auction result, without considering the current price (reserves) of the existing `tokenPair`.  See [PostAuctionLauncher.getTokenAmounts()](https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L268)  `PostAuctionLauncher` will receive an unfairly low amount of lp token because the amounts sent to `tokenPair` didn't match the current price of the pair.  See [UniswapV2Pair.mint(...)](https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/UniswapV2/UniswapV2Pair.sol#L135) ```solidity=135 liquidity = MathUniswap.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); ```  ## Impact  Lose a majority share of the tokens.  ## Proof of Concept  1. The attacker creates LP with 0.0000001 token1 and 1000 token2, receives 0.01 LP token; 2. Call `PostAuctionLauncher.finalize()`. PostAuctionLauncher will mint liquidity with 2000 token1 and 1000 token2 for example, receives only  0.01 LP token; 3. The attacker removes all his LP, receives 1000 token1 (most of which come from PostAuctionLauncher).  ## Recommended Mitigation Steps  To only support tokenPair created by PostAuctionLauncher or check for the token price before mint liquidity.  
