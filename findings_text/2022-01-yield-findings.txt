# Handle  throttle   # Vulnerability details  ## Impact Price can be stale and can lead to wrong `quoteAmount` return value  ## Proof of Concept Oracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong `quoteAmount` return value ```javascript function _peek(     bytes6 base,     bytes6 quote,     uint256 baseAmount ) private view returns (uint256 quoteAmount, uint256 updateTime) {     ...      (, int256 daiPrice, , , ) = DAI.latestRoundData();     (, int256 usdcPrice, , , ) = USDC.latestRoundData();     (, int256 usdtPrice, , , ) = USDT.latestRoundData();      require(         daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0,         "Chainlink pricefeed reporting 0"     );      ... } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Validate data feed ```javascript function _peek(     bytes6 base,     bytes6 quote,     uint256 baseAmount ) private view returns (uint256 quoteAmount, uint256 updateTime) {     ...     (uint80 roundID, int256 daiPrice, , uint256 timestamp, uint80 answeredInRound) = DAI.latestRoundData();     require(daiPrice > 0, "ChainLink: DAI price <= 0");     require(answeredInRound >= roundID, "ChainLink: Stale price");     require(timestamp > 0, "ChainLink: Round not complete");      (roundID, int256 usdcPrice, , timestamp, answeredInRound) = USDC.latestRoundData();     require(usdcPrice > 0, "ChainLink: USDC price <= 0");     require(answeredInRound >= roundID, "ChainLink: Stale USDC price");     require(timestamp > 0, "ChainLink: USDC round not complete");      (roundID, int256 usdtPrice, , timestamp, answeredInRound) = USDT.latestRoundData();     require(usdtPrice > 0, "ChainLink: USDT price <= 0");     require(answeredInRound >= roundID, "ChainLink: Stale USDT price");     require(timestamp > 0, "ChainLink: USDT round not complete");      ... } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L206-L224  ```solidity function _calcRewardIntegral(     uint256 _index,     address[2] memory _accounts,     uint256[2] memory _balances,     uint256 _supply,     bool _isClaim ) internal {     RewardType storage reward = rewards[_index];      uint256 rewardIntegral = reward.reward_integral;     uint256 rewardRemaining = reward.reward_remaining;      //get difference in balance and remaining rewards     //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed     uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));     if (_supply > 0 && (bal - rewardRemaining) > 0) {         rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);         reward.reward_integral = uint128(rewardIntegral);     } ```  `reward.reward_integral` is `uint128`, if a early user mint (wrap) just `1` Wei of `convexToken`, and make `_supply == 1`, and then tranferring `5e18` of `reward_token` to the contract.  As a result, `reward.reward_integral` can exceed `type(uint128).max` and overflow, causing the rewards distribution to be disrupted.  ### Recommendation  Consider `wrap` a certain amount of initial totalSupply, e.g. `1e8`, and never burn it. And consider using uint256 instead of uint128 for `reward.reward_integral`. Also, consdier lower `1e20` down to `1e12`.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The Cvx3CrvOracle.sol contract has functions that take the baseAmount input parameter but fail to mention or describe this parameter in the function's natspec comments. Issues with comments are low risk based on [Code4rena risk categories](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  The functions missing the baseAmount input parameter in comments include: - [peek()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L59-L66) - [get()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L81-L88) - [_peek()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L102-L109)  ## Recommended Mitigation Steps  Make sure natspec comments include all function input parameters.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The _calcRewardIntegral function casts intermediate reward values from uint256 to uint128 and vice versa several times. Because OpenZeppelin SafeCast is not used, casting from uint256 to uint128 may overflow if a large reward value is being calculate. This overflow could result in users receiving less rewards than they are owed.  ## Proof of Concept  There are 4 uint128 casting operations and 2 uint256 casting operations [in the _calcRewardIntegral function of ConvexStakingWrapper.sol](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L222-L253).  ## Recommended Mitigation Steps  Because reward values are an important part of this protocol, use the OpenZeppelin SafeCast library to prevent unexpected overflows when casting. SafeMath and Solidity 0.8.* handles overflows for basic math operations but not for casting.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L74-L95  ```solidity     function removeVault(bytes12 vaultId, address account) public {         address owner = cauldron.vaults(vaultId).owner;         if (account != owner) {             bytes12[] storage vaults_ = vaults[account];             uint256 vaultsLength = vaults_.length;             bool found;             for (uint256 i = 0; i < vaultsLength; i++) {                 if (vaults_[i] == vaultId) {                     bool isLast = i == vaultsLength - 1;                     if (!isLast) {                         vaults_[i] = vaults_[vaultsLength - 1];                     }                     vaults_.pop();                     found = true;                     emit VaultRemoved(account, vaultId);                     break;                 }             }             require(found, "Vault not found");             vaults[account] = vaults_;         }     } ```  `found` is redundant, we can just use `return` to stop the whole function when the `vault` to be removed is found and removed.  `removeVault()` can be changed to:  ```solidity function removeVault(bytes12 vaultId, address account) public {     address owner = cauldron.vaults(vaultId).owner;     if (account != owner) {         bytes12[] storage vaults_ = vaults[account];         uint256 vaultsLength = vaults_.length;         for (uint256 i = 0; i < vaultsLength; i++) {             if (vaults_[i] == vaultId) {                 bool isLast = i == vaultsLength - 1;                 if (!isLast) {                     vaults_[i] = vaults_[vaultsLength - 1];                 }                 vaults_.pop();                 found = true;                 emit VaultRemoved(account, vaultId);                 return;             }         }         revert("Vault not found");     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L74-L95  ```solidity function removeVault(bytes12 vaultId, address account) public {     address owner = cauldron.vaults(vaultId).owner;     if (account != owner) {         bytes12[] storage vaults_ = vaults[account];         uint256 vaultsLength = vaults_.length;         bool found;         for (uint256 i = 0; i < vaultsLength; i++) {             if (vaults_[i] == vaultId) {                 bool isLast = i == vaultsLength - 1;                 if (!isLast) {                     vaults_[i] = vaults_[vaultsLength - 1];                 }                 vaults_.pop();                 found = true;                 emit VaultRemoved(account, vaultId);                 break;             }         }         require(found, "Vault not found");         vaults[account] = vaults_;     } } ```  At L77, `vaults_` is defined as `vaults[account]`, thus `vaults[account] = vaults_` at L93 is redundant.  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L57-L69  ```solidity function addVault(bytes12 vaultId) external {     address account = cauldron.vaults(vaultId).owner;     require(account != address(0), "No owner for the vault");     bytes12[] storage vaults_ = vaults[account];     uint256 vaultsLength = vaults_.length;      for (uint256 i = 0; i < vaultsLength; i++) {         require(vaults_[i] != vaultId, "Vault already added");     }     vaults_.push(vaultId);     vaults[account] = vaults_;     emit VaultAdded(account, vaultId); } ```  Similarly, L76 is redundant.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_calcCvxIntegral()` function in ConvexStakingWrapper.sol doesn't use the same gas optimization that its sibling function `_calcRewardIntegral()` uses.  ## Proof of Concept  This code is from [the `_calcCvxIntegral()` function](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L154) ``` if (_isClaim || userI < cvxRewardIntegral) {     uint256 receiveable = cvx_claimable_reward[_accounts[u]] +         ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);     if (_isClaim) {         if (receiveable > 0) {             cvx_claimable_reward[_accounts[u]] = 0;             IERC20(cvx).safeTransfer(_accounts[u], receiveable);             bal = bal - (receiveable);         }     } else {         cvx_claimable_reward[_accounts[u]] = receiveable;     }     cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral; } ```  The related code from [the `_calcRewardIntegral()` function](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L206) has the receivable calculation inside the `if (_isClaim)` code branch to save gas if _isClaim is false.  ``` if (_isClaim || userI < rewardIntegral) {     if (_isClaim) {         uint256 receiveable = reward.claimable_reward[_accounts[u]] +             ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);         if (receiveable > 0) {             reward.claimable_reward[_accounts[u]] = 0;             IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);             bal = bal - receiveable;         }     } else {         reward.claimable_reward[_accounts[u]] =             reward.claimable_reward[_accounts[u]] +             ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);     }     reward.reward_integral_for[_accounts[u]] = rewardIntegral; } ```  This optimization would save gas each time `_checkpoint()` is called because `_checkpoint()` sets _isClaim to false and doesn't enter the `if(_isClaim)` branch.   ## Recommended Mitigation Steps  Modify the `_calcCvxIntegral()` function to place the receiveable calculation inside the `if (_isClaim)` code branch.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  1. https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L114-L114  ```solidity uint256 startIndex = rewardsLength - 1; ```  `rewardsLength - 1` will never underflow.  2. https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L82-L85  ```solidity=82 bool isLast = i == vaultsLength - 1; if (!isLast) {     vaults_[i] = vaults_[vaultsLength - 1]; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L54-L55  ```solidity     bool private constant _NOT_ENTERED = false;     bool private constant _ENTERED = true; ```  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L81-L90  ```solidity     modifier nonReentrant() {         // On the first call to nonReentrant, _notEntered will be true         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");         // Any calls to nonReentrant after this point will fail         _status = _ENTERED;         _;         // By storing the original value once again, a refund is triggered (see         // https://eips.ethereum.org/EIPS/eip-2200)         _status = _NOT_ENTERED;     } ```  `SSTORE` from 0 to 1 (or any non-zero value), the cost is 20000; `SSTORE` from 1 to 2 (or any other non-zero value), the cost is 5000.  By storing the original value once again, a refund is triggered (https://eips.ethereum.org/EIPS/eip-2200).  Since refunds are capped to a percentage of the total transaction's gas, it is best to keep them low, to increase the likelihood of the full refund coming into effect.  Therefore, switching between 1, 2 instead of 0, 1 will be more gas efficient.  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/86bd4d73896afcb35a205456e361436701823c7a/contracts/security/ReentrancyGuard.sol#L29-L33  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L106-L111  ```solidity     if (rewardsLength == 0) {         RewardType storage reward = rewards.push();         reward.reward_token = crv;         reward.reward_pool = mainPool;         rewardsLength += 1;     } ```  When `rewardsLength` == `0`,  the new `rewardsLength` will always be 1. Therefore, replacing `+=` with `=` can avoid the unnecessary arithmetic operations and memory reads    ### Recommendation  Change to:  ```solidity     if (rewardsLength == 0) {         RewardType storage reward = rewards.push();         reward.reward_token = crv;         reward.reward_pool = mainPool;         rewardsLength = 1;     } ```  
# Handle  kenzo   # Vulnerability details  The ConvexStakingWrapper that Yield is based on recently published a fix for `earned` function in case the pool is claimed indirectly.  ## Impact Wrong results might be returned from view function `earned`.  ## Proof of Concept This is the fix for earned: [fix commit](https://github.com/convex-eth/platform/commit/9b9dd72bdb822e7f34f241d620cc1f8388bf7d6a#)  ## Recommended Mitigation Steps Apply fix.  
# Handle  leastwood   # Vulnerability details  ## Impact  `ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which: - Approves Ladle to move the tokens. - Transfers the tokens to `ConvexYieldWrapper.sol`. - Wraps/stakes these tokens. - Updates accounting and produces debt tokens within `Ladle.sol`.  `_getDepositedBalance()` takes into consideration the user's total collateral stored in all of their owned vaults. However, as a vault owner, you are allowed to give the vault to another user, move collateral between vaults and add/remove collateral. Therefore, it is possible to manipulate the result of this function by checkpointing one user's balance at a given time, transferring ownership to another user and then create a new checkpoint with this user.   As a result, a user is able to generate protocol yield multiple times over on a single collateral amount. This can be abused to effectively extract all protocol yield.  ## Proof of Concept  Consider the following exploit scenario: - Alice owns a vault which has 100 tokens worth of collateral. - At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards. - Alice then calls `Ladle.give()`, transferring the ownership of the vault to Bob and calls `ConvexYieldWrapper.addVault()`. - Bob is able to call `user_checkpoint()` and effectively update their checkpointed balance. - At this point in time, both Alice and Bob have claim to any yield generated by the protocol, however, there is only one vault instance that holds the underlying collateral.  https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexYieldWrapper.sol#L100-L120 ``` function _getDepositedBalance(address account_) internal view override returns (uint256) {     if (account_ == address(0) || account_ == collateralVault) {         return 0;     }      bytes12[] memory userVault = vaults[account_];      //add up all balances of all vaults registered in the wrapper and owned by the account     uint256 collateral;     DataTypes.Balances memory balance;     uint256 userVaultLength = userVault.length;     for (uint256 i = 0; i < userVaultLength; i++) {         if (cauldron.vaults(userVault[i]).owner == account_) {             balance = cauldron.balances(userVault[i]);             collateral = collateral + balance.ink;         }     }      //add to balance of this token     return _balanceOf[account_] + collateral; } ```  ## Tools Used  Manual code review. Discussion/confirmation with the Yield Protocol team.  ## Recommended Mitigation Steps  Ensure that any change to a vault will correctly checkpoint the previous and new vault owner. The affected actions include but are not limited to; transferring ownership of a vault to a new account, transferring collateral to another vault and adding/removing collateral to/from a vault.  
# Handle  GeekyLumberjack   # Vulnerability details  `uint256[2] memory depositedBalance;` is defined at the beginning of [_checkpointAndClaim](https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L279-L291) only one `depositedBalance` slot is being filed and then the entire array gets passed into `_calcRewardIntegral()` and `_calcCvxIntegral()` along with an array of two `_accounts`. Having only one of the `depositedBalance` and two `_accounts` may cause loss in rewards for the second account. This function is currently only used in `GetReward()` which is passing in a zero address as the second address.   
# Handle  leastwood   # Vulnerability details  ## Impact  `ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which: - Approves Ladle to move the tokens. - Transfers the tokens to `ConvexYieldWrapper.sol`. - Wraps/stakes these tokens. - Updates accounting and produces debt tokens within `Ladle.sol`.  During `wrap()` and `unwrap()` actions, `_checkpoint()` is used to update the rewards for the `from_` and `to_` accounts. However, the [reference](https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract implements a `_beforeTokenTransfer()` function which has been removed from Yield Protocol's custom implementation.  As a result, it is possible to transfer `wCVX` tokens to another account after an initial checkpoint has been made. By manually calling `user_checkpoint()` on the new account, this user is able to update its deposited balance of the new account while the sender's balance is not updated. This can be repeated to effectively replicate a user's deposited balance over any number of accounts. To claim yield generated by the protocol, the user must only make sure that the account calling `getReward()` holds the tokens for the duration of the call.  ## Proof of Concept  The exploit can be outlined through the following steps: - Alice receives 100 `wCVX` tokens from the protocol after wrapping their convex tokens. - At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards. - Alice transfers her tokens to her friend Bob who then manually calls `user_checkpoint()` to update his balance. - Now from the perspective of the protocol, both Alice and Bob have 100 `wCVX` tokens as calculated by the `_getDepositedBalance()` function. - If either Alice or Bob wants to claim rewards, all they need to do is make sure the 100 `wCVX` tokens are in their account upon calling `getReward()`. Afterwards, the tokens can be transferred out.  ## Tools Used  Manual code review. Discussion/confirmation with the Yield Protocol team.  ## Recommended Mitigation Steps  Consider implementing the `_beforeTokenTransfer()` function as shown in the [reference](https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract. However, it is important to ensure the wrapper contract and collateral vaults are excluded from the checkpointing so they are not considered in the rewards calculations.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  L116 of Cvx3CrvOracle enforces for the rest of the function call that `base == ethId <-> quote == cvx3CrvId`  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L116  However on L137 we check both these conditions again.  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L137  We could check just one of these and then rely on the require condition on 116 to enforce the other one. This will prevent us having to SLOAD `ethID` again  ## Recommended Mitigation Steps  Change L137 to `if (base == cvx3CrvId) {`  
# Handle  Dravee   # Vulnerability details  ## Impact AccessControl capabilities aren't used.  ## Proof of Concept In `ConvexStakingWrapper.sol`, `AccessControl` seem superfluous: ``` 7: import "@yield-protocol/utils-v2/contracts/access/AccessControl.sol"; ... 15: contract ConvexStakingWrapper is ERC20, AccessControl { ``` In the original `ConvexStakingWrapper.sol`, this `AccessControl` isn't inherited.   In this contract, I believe role-based capabilities were thought of, but were forgotten or abandonned.  ## Tools Used VS Code  ## Recommended Mitigation Steps Either use the capabilities from `AccessControl`, or delete the import + the inheritance to save gas.  
# Handle  Dravee   # Vulnerability details  ## Impact No protection from reentrancy (besides the gas limit on safeTransfer). Bad practice compared to the original `ConvexStakingWrapper` contract.  ## Proof of Concept The original `ConvexStakingWrapper` contract used the `nonReentrant` modifier on all functions using the `safeTransfer` or `safeTransferFrom` methods: - `deposit`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L337 - `stake`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L352  - `withdraw`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L367 - `withdrawAndUnwrap`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L381  As the current one in the Yield solution is an upgrade, it should follow the same good practices.  ## Tools Used VS Code  ## Recommended Mitigation Steps Use the `nonReentrant` modifier on external functions that end up calling `safeTransfer` or `safeTransferFrom` (`user_checkpoint()` and `getReward()`)  
# Handle  rfa   # Vulnerability details  ## Impact spend at least 6930 more gas on deployment, and spend 40 gas more per call (by using current implementasion)  ## Proof of Concept https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L184 https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L239  the `TransferHelper` lib just used twice in this contract. remove:(line 16) https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L16  and just call `TransferHelper.safeTransfer()` directly at those line.  This method is using almost exact the same gas as if we just copying the `safeTransfer()` and remove the `TransferHelper` lib from the contract. (since we need just 1 function from the lib)    
# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive (~100 gas) compared to MLOADs/MSTOREs (~3 gas). Minimizing them can save gas.  ## Proof of Concept The code is as such (see `@audit-info`): ``` File: Cvx3CrvOracle.sol 110:     function _peek( 111:         bytes6 base, 112:         bytes6 quote, 113:         uint256 baseAmount 114:     ) private view returns (uint256 quoteAmount, uint256 updateTime) { 115:         require( 116:             (base == ethId && quote == cvx3CrvId) || // @audit-info ethId SLOAD 1, cvx3CrvId SLOAD 1 117:                 (base == cvx3CrvId && quote == ethId), // @audit-info ethId SLOAD 2, cvx3CrvId SLOAD 2 118:             "Invalid quote or base" 119:         ); 120:         (, int256 daiPrice, , , ) = DAI.latestRoundData(); 121:         (, int256 usdcPrice, , , ) = USDC.latestRoundData(); 122:         (, int256 usdtPrice, , , ) = USDT.latestRoundData(); 123:  124:         require( 125:             daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0, 126:             "Chainlink pricefeed reporting 0" 127:         ); 128:  129:         // This won't overflow as the max value for int256 is less than the max value for uint256 130:         uint256 minStable = min( 131:             uint256(daiPrice), 132:             min(uint256(usdcPrice), uint256(usdtPrice)) 133:         ); 134:  135:         uint256 price = (threecrv.get_virtual_price() * minStable) / 1e18; 136:  137:         if (base == cvx3CrvId && quote == ethId) { // @audit-info ethId SLOAD 3, cvx3CrvId SLOAD 3 138:             quoteAmount = (baseAmount * price) / 1e18; 139:         } else { 140:             quoteAmount = (baseAmount * 1e18) / price; 141:         } 142:  143:         updateTime = block.timestamp; 144:     } ```  By caching `ethId` and `cvx3CrvId` in memory, it's possible to save 4 SLOADs (~400gas) at the cost of 2 MSTOREs (6 gas) and 4 MLOADs (12 gas)  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `ethId` and `cvx3CrvId` in variables and use these instead  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost due to unnecessary automatic underflow checks.  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers.  When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block.  https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  ## Proof of Concept In `ConvexStakingWrapper.sol:_calcRewardIntegral()`, `bal - rewardRemaining` can't underflow at line 222 as the conditional statement line 221 prevents it: ``` File: ConvexStakingWrapper.sol 221:         if (_supply > 0 && (bal - rewardRemaining) > 0) { 222:             rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply); //@audit-info (bal - rewardRemaining) can't underflow because of above if statement ``` This substraction should get computed inside an `unchecked` block and stored in a variable, which would then be used in the checked calculation for `rewardIntegral`.  ## Tools Used VS Code  ## Recommended Mitigation Steps Uncheck arithmetic operations when the risk of underflow or overflow is already contained by wrapping them in an `unchecked` block    
# Handle  Dravee   # Vulnerability details  ## Impact   Using both named returns and a return statement isn't necessary. Removing unused named return variables can reduce gas usage and improve code clarity. To save gas and improve code quality: consider using only one of those.      ## Proof of Concept   Instances include:   ``` ConvexStakingWrapper.sol:310:    function earned(address _account) external view returns (EarnedData[] memory claimable) { //@audit-info 342: return claimable;  Cvx3CrvOracle.sol:76:        returns (uint256 quoteAmount, uint256 updateTime) //@audit-info 78: return _peek(base.b6(), quote.b6(), baseAmount);  Cvx3CrvOracle.sol:97:        returns (uint256 quoteAmount, uint256 updateTime) //@audit-info 99: return _peek(base.b6(), quote.b6(), baseAmount); ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Remove the unused named returns   
# Handle  Dravee   # Vulnerability details  ## Impact Solidity contracts have contiguous 32 bytes (256 bits) slots used in storage. By arranging the variables, it is possible to minimize the number of slots used within a contract's storage and therefore reduce deployment costs.  ## Proof of Concept In `ConvexStakingWrapper.sol`, the order of variables is this way: ```     uint256 public cvx_reward_integral;     uint256 public cvx_reward_remaining;     mapping(address => uint256) public cvx_reward_integral_for;     mapping(address => uint256) public cvx_claimable_reward;      //constants/immutables     address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);     address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);     address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);     address public curveToken;     address public convexToken;     address public convexPool;     address public collateralVault;     uint256 public convexPoolId;      //rewards     RewardType[] public rewards;      //management     bool public isShutdown;     bool private _status;      bool private constant _NOT_ENTERED = false;     bool private constant _ENTERED = true; ``` `address` type variables are each of 20 bytes size (way less than 32 bytes). However, they here take up a whole 32 bytes slot (they are contiguous). As `bool` type variables are of size 1 byte, there's a slot here that can get saved by moving them closer to an address  ## Recommended Mitigation Steps I suggest the following (see the @audit-info tags for more details about what moved and why): ```     uint256 public cvx_reward_integral;     uint256 public cvx_reward_remaining;     mapping(address => uint256) public cvx_reward_integral_for;     mapping(address => uint256) public cvx_claimable_reward;      //constants/immutables     uint256 public convexPoolId; //@audit-info this moved up to free collateralVault's slot.     address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);     address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);     address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);     address public curveToken;     address public convexToken;     address public convexPool;     address public collateralVault; //@audit-info this got freed from convexPoolId. Slot N is at 20/32 here      //management      bool public isShutdown; //@audit-info this moved up. Slot N is full at 21/32 here      bool private _status; //@audit-info this moved up. Slot N is full at 22/32 here      bool private constant _NOT_ENTERED = false; //@audit-info this moved up but doesn't take a slot as it's constant     bool private constant _ENTERED = true; //@audit-info this moved up but doesn't take a slot as it's constant       //rewards     RewardType[] public rewards; ```    
# Handle  ye0lde   # Vulnerability details  ## Impact Typos  ## Proof of Concept The typos are here:  `vaulId` https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexModule.sol#L14 https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexModule.sol#L25  ## Tools Used VS Code  ## Recommended Mitigation Steps Correct the typos  
# Handle  Funen   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L94-L95  ``` IERC20(curveToken).approve(convexBooster, 0); IERC20(curveToken).approve(convexBooster, type(uint256).max); ```  `curveToken` was called mutiple times, caching it in `memory` , it can cost less gas  
# Handle  0x1f8b   # Vulnerability details  ## Impact owner can change the source without any warning.  ## Proof of Concept The method `Cvx3CrvOracle.setSource` should emit an event in order to be able to detect this call by dapps.  ## Tools Used Manual review  ## Recommended Mitigation Steps Emit an event  
# Handle  robee   # Vulnerability details  The following functions are missing commenting as describe below:              ConvexStakingWrapper.sol, user_checkpoint (external), @return is missing  
# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 115         change to prefix increment and unchecked: ConvexStakingWrapper.sol, u, 172         change to prefix increment and unchecked: ConvexStakingWrapper.sol, u, 227         change to prefix increment and unchecked: ConvexYieldWrapper.sol, i, 111         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 287         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 271         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 315         change to prefix increment and unchecked: ConvexYieldWrapper.sol, i, 63  
# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           ConvexStakingWrapper.sol, variable name: _accounts times: 5 at: _calcRewardIntegral         ConvexStakingWrapper.sol, variable name: _accounts times: 5 at: _calcCvxIntegral  
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).           ConvexModule.sol, line 3, import "@yield-protocol/vault-interfaces/DataTypes.sol";         ConvexStakingWrapper.sol, line 9, import "./interfaces/IConvexDeposits.sol";         ConvexStakingWrapper.sol, line 10, import "./interfaces/ICvx.sol";  
# Handle  throttle   # Vulnerability details  ## Impact Price can be stale and can lead to wrong `quoteAmount` return value  ## Proof of Concept Oracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong `quoteAmount` return value ```javascript function _peek(     bytes6 base,     bytes6 quote,     uint256 baseAmount ) private view returns (uint256 quoteAmount, uint256 updateTime) {     ...      (, int256 daiPrice, , , ) = DAI.latestRoundData();     (, int256 usdcPrice, , , ) = USDC.latestRoundData();     (, int256 usdtPrice, , , ) = USDT.latestRoundData();      require(         daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0,         "Chainlink pricefeed reporting 0"     );      ... } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Validate data feed ```javascript function _peek(     bytes6 base,     bytes6 quote,     uint256 baseAmount ) private view returns (uint256 quoteAmount, uint256 updateTime) {     ...     (uint80 roundID, int256 daiPrice, , uint256 timestamp, uint80 answeredInRound) = DAI.latestRoundData();     require(daiPrice > 0, "ChainLink: DAI price <= 0");     require(answeredInRound >= roundID, "ChainLink: Stale price");     require(timestamp > 0, "ChainLink: Round not complete");      (roundID, int256 usdcPrice, , timestamp, answeredInRound) = USDC.latestRoundData();     require(usdcPrice > 0, "ChainLink: USDC price <= 0");     require(answeredInRound >= roundID, "ChainLink: Stale USDC price");     require(timestamp > 0, "ChainLink: USDC round not complete");      (roundID, int256 usdtPrice, , timestamp, answeredInRound) = USDT.latestRoundData();     require(usdtPrice > 0, "ChainLink: USDT price <= 0");     require(answeredInRound >= roundID, "ChainLink: Stale USDT price");     require(timestamp > 0, "ChainLink: USDT round not complete");      ... } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L206-L224  ```solidity function _calcRewardIntegral(     uint256 _index,     address[2] memory _accounts,     uint256[2] memory _balances,     uint256 _supply,     bool _isClaim ) internal {     RewardType storage reward = rewards[_index];      uint256 rewardIntegral = reward.reward_integral;     uint256 rewardRemaining = reward.reward_remaining;      //get difference in balance and remaining rewards     //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed     uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));     if (_supply > 0 && (bal - rewardRemaining) > 0) {         rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);         reward.reward_integral = uint128(rewardIntegral);     } ```  `reward.reward_integral` is `uint128`, if a early user mint (wrap) just `1` Wei of `convexToken`, and make `_supply == 1`, and then tranferring `5e18` of `reward_token` to the contract.  As a result, `reward.reward_integral` can exceed `type(uint128).max` and overflow, causing the rewards distribution to be disrupted.  ### Recommendation  Consider `wrap` a certain amount of initial totalSupply, e.g. `1e8`, and never burn it. And consider using uint256 instead of uint128 for `reward.reward_integral`. Also, consdier lower `1e20` down to `1e12`.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The Cvx3CrvOracle.sol contract has functions that take the baseAmount input parameter but fail to mention or describe this parameter in the function's natspec comments. Issues with comments are low risk based on [Code4rena risk categories](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  The functions missing the baseAmount input parameter in comments include: - [peek()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L59-L66) - [get()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L81-L88) - [_peek()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L102-L109)  ## Recommended Mitigation Steps  Make sure natspec comments include all function input parameters.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The _calcRewardIntegral function casts intermediate reward values from uint256 to uint128 and vice versa several times. Because OpenZeppelin SafeCast is not used, casting from uint256 to uint128 may overflow if a large reward value is being calculate. This overflow could result in users receiving less rewards than they are owed.  ## Proof of Concept  There are 4 uint128 casting operations and 2 uint256 casting operations [in the _calcRewardIntegral function of ConvexStakingWrapper.sol](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L222-L253).  ## Recommended Mitigation Steps  Because reward values are an important part of this protocol, use the OpenZeppelin SafeCast library to prevent unexpected overflows when casting. SafeMath and Solidity 0.8.* handles overflows for basic math operations but not for casting.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L74-L95  ```solidity     function removeVault(bytes12 vaultId, address account) public {         address owner = cauldron.vaults(vaultId).owner;         if (account != owner) {             bytes12[] storage vaults_ = vaults[account];             uint256 vaultsLength = vaults_.length;             bool found;             for (uint256 i = 0; i < vaultsLength; i++) {                 if (vaults_[i] == vaultId) {                     bool isLast = i == vaultsLength - 1;                     if (!isLast) {                         vaults_[i] = vaults_[vaultsLength - 1];                     }                     vaults_.pop();                     found = true;                     emit VaultRemoved(account, vaultId);                     break;                 }             }             require(found, "Vault not found");             vaults[account] = vaults_;         }     } ```  `found` is redundant, we can just use `return` to stop the whole function when the `vault` to be removed is found and removed.  `removeVault()` can be changed to:  ```solidity function removeVault(bytes12 vaultId, address account) public {     address owner = cauldron.vaults(vaultId).owner;     if (account != owner) {         bytes12[] storage vaults_ = vaults[account];         uint256 vaultsLength = vaults_.length;         for (uint256 i = 0; i < vaultsLength; i++) {             if (vaults_[i] == vaultId) {                 bool isLast = i == vaultsLength - 1;                 if (!isLast) {                     vaults_[i] = vaults_[vaultsLength - 1];                 }                 vaults_.pop();                 found = true;                 emit VaultRemoved(account, vaultId);                 return;             }         }         revert("Vault not found");     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L74-L95  ```solidity function removeVault(bytes12 vaultId, address account) public {     address owner = cauldron.vaults(vaultId).owner;     if (account != owner) {         bytes12[] storage vaults_ = vaults[account];         uint256 vaultsLength = vaults_.length;         bool found;         for (uint256 i = 0; i < vaultsLength; i++) {             if (vaults_[i] == vaultId) {                 bool isLast = i == vaultsLength - 1;                 if (!isLast) {                     vaults_[i] = vaults_[vaultsLength - 1];                 }                 vaults_.pop();                 found = true;                 emit VaultRemoved(account, vaultId);                 break;             }         }         require(found, "Vault not found");         vaults[account] = vaults_;     } } ```  At L77, `vaults_` is defined as `vaults[account]`, thus `vaults[account] = vaults_` at L93 is redundant.  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L57-L69  ```solidity function addVault(bytes12 vaultId) external {     address account = cauldron.vaults(vaultId).owner;     require(account != address(0), "No owner for the vault");     bytes12[] storage vaults_ = vaults[account];     uint256 vaultsLength = vaults_.length;      for (uint256 i = 0; i < vaultsLength; i++) {         require(vaults_[i] != vaultId, "Vault already added");     }     vaults_.push(vaultId);     vaults[account] = vaults_;     emit VaultAdded(account, vaultId); } ```  Similarly, L76 is redundant.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_calcCvxIntegral()` function in ConvexStakingWrapper.sol doesn't use the same gas optimization that its sibling function `_calcRewardIntegral()` uses.  ## Proof of Concept  This code is from [the `_calcCvxIntegral()` function](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L154) ``` if (_isClaim || userI < cvxRewardIntegral) {     uint256 receiveable = cvx_claimable_reward[_accounts[u]] +         ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);     if (_isClaim) {         if (receiveable > 0) {             cvx_claimable_reward[_accounts[u]] = 0;             IERC20(cvx).safeTransfer(_accounts[u], receiveable);             bal = bal - (receiveable);         }     } else {         cvx_claimable_reward[_accounts[u]] = receiveable;     }     cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral; } ```  The related code from [the `_calcRewardIntegral()` function](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L206) has the receivable calculation inside the `if (_isClaim)` code branch to save gas if _isClaim is false.  ``` if (_isClaim || userI < rewardIntegral) {     if (_isClaim) {         uint256 receiveable = reward.claimable_reward[_accounts[u]] +             ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);         if (receiveable > 0) {             reward.claimable_reward[_accounts[u]] = 0;             IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);             bal = bal - receiveable;         }     } else {         reward.claimable_reward[_accounts[u]] =             reward.claimable_reward[_accounts[u]] +             ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);     }     reward.reward_integral_for[_accounts[u]] = rewardIntegral; } ```  This optimization would save gas each time `_checkpoint()` is called because `_checkpoint()` sets _isClaim to false and doesn't enter the `if(_isClaim)` branch.   ## Recommended Mitigation Steps  Modify the `_calcCvxIntegral()` function to place the receiveable calculation inside the `if (_isClaim)` code branch.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  1. https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L114-L114  ```solidity uint256 startIndex = rewardsLength - 1; ```  `rewardsLength - 1` will never underflow.  2. https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L82-L85  ```solidity=82 bool isLast = i == vaultsLength - 1; if (!isLast) {     vaults_[i] = vaults_[vaultsLength - 1]; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L54-L55  ```solidity     bool private constant _NOT_ENTERED = false;     bool private constant _ENTERED = true; ```  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L81-L90  ```solidity     modifier nonReentrant() {         // On the first call to nonReentrant, _notEntered will be true         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");         // Any calls to nonReentrant after this point will fail         _status = _ENTERED;         _;         // By storing the original value once again, a refund is triggered (see         // https://eips.ethereum.org/EIPS/eip-2200)         _status = _NOT_ENTERED;     } ```  `SSTORE` from 0 to 1 (or any non-zero value), the cost is 20000; `SSTORE` from 1 to 2 (or any other non-zero value), the cost is 5000.  By storing the original value once again, a refund is triggered (https://eips.ethereum.org/EIPS/eip-2200).  Since refunds are capped to a percentage of the total transaction's gas, it is best to keep them low, to increase the likelihood of the full refund coming into effect.  Therefore, switching between 1, 2 instead of 0, 1 will be more gas efficient.  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/86bd4d73896afcb35a205456e361436701823c7a/contracts/security/ReentrancyGuard.sol#L29-L33  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L106-L111  ```solidity     if (rewardsLength == 0) {         RewardType storage reward = rewards.push();         reward.reward_token = crv;         reward.reward_pool = mainPool;         rewardsLength += 1;     } ```  When `rewardsLength` == `0`,  the new `rewardsLength` will always be 1. Therefore, replacing `+=` with `=` can avoid the unnecessary arithmetic operations and memory reads    ### Recommendation  Change to:  ```solidity     if (rewardsLength == 0) {         RewardType storage reward = rewards.push();         reward.reward_token = crv;         reward.reward_pool = mainPool;         rewardsLength = 1;     } ```  
# Handle  kenzo   # Vulnerability details  The ConvexStakingWrapper that Yield is based on recently published a fix for `earned` function in case the pool is claimed indirectly.  ## Impact Wrong results might be returned from view function `earned`.  ## Proof of Concept This is the fix for earned: [fix commit](https://github.com/convex-eth/platform/commit/9b9dd72bdb822e7f34f241d620cc1f8388bf7d6a#)  ## Recommended Mitigation Steps Apply fix.  
# Handle  leastwood   # Vulnerability details  ## Impact  `ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which: - Approves Ladle to move the tokens. - Transfers the tokens to `ConvexYieldWrapper.sol`. - Wraps/stakes these tokens. - Updates accounting and produces debt tokens within `Ladle.sol`.  `_getDepositedBalance()` takes into consideration the user's total collateral stored in all of their owned vaults. However, as a vault owner, you are allowed to give the vault to another user, move collateral between vaults and add/remove collateral. Therefore, it is possible to manipulate the result of this function by checkpointing one user's balance at a given time, transferring ownership to another user and then create a new checkpoint with this user.   As a result, a user is able to generate protocol yield multiple times over on a single collateral amount. This can be abused to effectively extract all protocol yield.  ## Proof of Concept  Consider the following exploit scenario: - Alice owns a vault which has 100 tokens worth of collateral. - At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards. - Alice then calls `Ladle.give()`, transferring the ownership of the vault to Bob and calls `ConvexYieldWrapper.addVault()`. - Bob is able to call `user_checkpoint()` and effectively update their checkpointed balance. - At this point in time, both Alice and Bob have claim to any yield generated by the protocol, however, there is only one vault instance that holds the underlying collateral.  https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexYieldWrapper.sol#L100-L120 ``` function _getDepositedBalance(address account_) internal view override returns (uint256) {     if (account_ == address(0) || account_ == collateralVault) {         return 0;     }      bytes12[] memory userVault = vaults[account_];      //add up all balances of all vaults registered in the wrapper and owned by the account     uint256 collateral;     DataTypes.Balances memory balance;     uint256 userVaultLength = userVault.length;     for (uint256 i = 0; i < userVaultLength; i++) {         if (cauldron.vaults(userVault[i]).owner == account_) {             balance = cauldron.balances(userVault[i]);             collateral = collateral + balance.ink;         }     }      //add to balance of this token     return _balanceOf[account_] + collateral; } ```  ## Tools Used  Manual code review. Discussion/confirmation with the Yield Protocol team.  ## Recommended Mitigation Steps  Ensure that any change to a vault will correctly checkpoint the previous and new vault owner. The affected actions include but are not limited to; transferring ownership of a vault to a new account, transferring collateral to another vault and adding/removing collateral to/from a vault.  
# Handle  GeekyLumberjack   # Vulnerability details  `uint256[2] memory depositedBalance;` is defined at the beginning of [_checkpointAndClaim](https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L279-L291) only one `depositedBalance` slot is being filed and then the entire array gets passed into `_calcRewardIntegral()` and `_calcCvxIntegral()` along with an array of two `_accounts`. Having only one of the `depositedBalance` and two `_accounts` may cause loss in rewards for the second account. This function is currently only used in `GetReward()` which is passing in a zero address as the second address.   
# Handle  leastwood   # Vulnerability details  ## Impact  `ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which: - Approves Ladle to move the tokens. - Transfers the tokens to `ConvexYieldWrapper.sol`. - Wraps/stakes these tokens. - Updates accounting and produces debt tokens within `Ladle.sol`.  During `wrap()` and `unwrap()` actions, `_checkpoint()` is used to update the rewards for the `from_` and `to_` accounts. However, the [reference](https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract implements a `_beforeTokenTransfer()` function which has been removed from Yield Protocol's custom implementation.  As a result, it is possible to transfer `wCVX` tokens to another account after an initial checkpoint has been made. By manually calling `user_checkpoint()` on the new account, this user is able to update its deposited balance of the new account while the sender's balance is not updated. This can be repeated to effectively replicate a user's deposited balance over any number of accounts. To claim yield generated by the protocol, the user must only make sure that the account calling `getReward()` holds the tokens for the duration of the call.  ## Proof of Concept  The exploit can be outlined through the following steps: - Alice receives 100 `wCVX` tokens from the protocol after wrapping their convex tokens. - At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards. - Alice transfers her tokens to her friend Bob who then manually calls `user_checkpoint()` to update his balance. - Now from the perspective of the protocol, both Alice and Bob have 100 `wCVX` tokens as calculated by the `_getDepositedBalance()` function. - If either Alice or Bob wants to claim rewards, all they need to do is make sure the 100 `wCVX` tokens are in their account upon calling `getReward()`. Afterwards, the tokens can be transferred out.  ## Tools Used  Manual code review. Discussion/confirmation with the Yield Protocol team.  ## Recommended Mitigation Steps  Consider implementing the `_beforeTokenTransfer()` function as shown in the [reference](https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract. However, it is important to ensure the wrapper contract and collateral vaults are excluded from the checkpointing so they are not considered in the rewards calculations.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  L116 of Cvx3CrvOracle enforces for the rest of the function call that `base == ethId <-> quote == cvx3CrvId`  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L116  However on L137 we check both these conditions again.  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L137  We could check just one of these and then rely on the require condition on 116 to enforce the other one. This will prevent us having to SLOAD `ethID` again  ## Recommended Mitigation Steps  Change L137 to `if (base == cvx3CrvId) {`  
# Handle  Dravee   # Vulnerability details  ## Impact AccessControl capabilities aren't used.  ## Proof of Concept In `ConvexStakingWrapper.sol`, `AccessControl` seem superfluous: ``` 7: import "@yield-protocol/utils-v2/contracts/access/AccessControl.sol"; ... 15: contract ConvexStakingWrapper is ERC20, AccessControl { ``` In the original `ConvexStakingWrapper.sol`, this `AccessControl` isn't inherited.   In this contract, I believe role-based capabilities were thought of, but were forgotten or abandonned.  ## Tools Used VS Code  ## Recommended Mitigation Steps Either use the capabilities from `AccessControl`, or delete the import + the inheritance to save gas.  
# Handle  Dravee   # Vulnerability details  ## Impact No protection from reentrancy (besides the gas limit on safeTransfer). Bad practice compared to the original `ConvexStakingWrapper` contract.  ## Proof of Concept The original `ConvexStakingWrapper` contract used the `nonReentrant` modifier on all functions using the `safeTransfer` or `safeTransferFrom` methods: - `deposit`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L337 - `stake`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L352  - `withdraw`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L367 - `withdrawAndUnwrap`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L381  As the current one in the Yield solution is an upgrade, it should follow the same good practices.  ## Tools Used VS Code  ## Recommended Mitigation Steps Use the `nonReentrant` modifier on external functions that end up calling `safeTransfer` or `safeTransferFrom` (`user_checkpoint()` and `getReward()`)  
# Handle  rfa   # Vulnerability details  ## Impact spend at least 6930 more gas on deployment, and spend 40 gas more per call (by using current implementasion)  ## Proof of Concept https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L184 https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L239  the `TransferHelper` lib just used twice in this contract. remove:(line 16) https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L16  and just call `TransferHelper.safeTransfer()` directly at those line.  This method is using almost exact the same gas as if we just copying the `safeTransfer()` and remove the `TransferHelper` lib from the contract. (since we need just 1 function from the lib)    
# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive (~100 gas) compared to MLOADs/MSTOREs (~3 gas). Minimizing them can save gas.  ## Proof of Concept The code is as such (see `@audit-info`): ``` File: Cvx3CrvOracle.sol 110:     function _peek( 111:         bytes6 base, 112:         bytes6 quote, 113:         uint256 baseAmount 114:     ) private view returns (uint256 quoteAmount, uint256 updateTime) { 115:         require( 116:             (base == ethId && quote == cvx3CrvId) || // @audit-info ethId SLOAD 1, cvx3CrvId SLOAD 1 117:                 (base == cvx3CrvId && quote == ethId), // @audit-info ethId SLOAD 2, cvx3CrvId SLOAD 2 118:             "Invalid quote or base" 119:         ); 120:         (, int256 daiPrice, , , ) = DAI.latestRoundData(); 121:         (, int256 usdcPrice, , , ) = USDC.latestRoundData(); 122:         (, int256 usdtPrice, , , ) = USDT.latestRoundData(); 123:  124:         require( 125:             daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0, 126:             "Chainlink pricefeed reporting 0" 127:         ); 128:  129:         // This won't overflow as the max value for int256 is less than the max value for uint256 130:         uint256 minStable = min( 131:             uint256(daiPrice), 132:             min(uint256(usdcPrice), uint256(usdtPrice)) 133:         ); 134:  135:         uint256 price = (threecrv.get_virtual_price() * minStable) / 1e18; 136:  137:         if (base == cvx3CrvId && quote == ethId) { // @audit-info ethId SLOAD 3, cvx3CrvId SLOAD 3 138:             quoteAmount = (baseAmount * price) / 1e18; 139:         } else { 140:             quoteAmount = (baseAmount * 1e18) / price; 141:         } 142:  143:         updateTime = block.timestamp; 144:     } ```  By caching `ethId` and `cvx3CrvId` in memory, it's possible to save 4 SLOADs (~400gas) at the cost of 2 MSTOREs (6 gas) and 4 MLOADs (12 gas)  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `ethId` and `cvx3CrvId` in variables and use these instead  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost due to unnecessary automatic underflow checks.  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers.  When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block.  https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  ## Proof of Concept In `ConvexStakingWrapper.sol:_calcRewardIntegral()`, `bal - rewardRemaining` can't underflow at line 222 as the conditional statement line 221 prevents it: ``` File: ConvexStakingWrapper.sol 221:         if (_supply > 0 && (bal - rewardRemaining) > 0) { 222:             rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply); //@audit-info (bal - rewardRemaining) can't underflow because of above if statement ``` This substraction should get computed inside an `unchecked` block and stored in a variable, which would then be used in the checked calculation for `rewardIntegral`.  ## Tools Used VS Code  ## Recommended Mitigation Steps Uncheck arithmetic operations when the risk of underflow or overflow is already contained by wrapping them in an `unchecked` block    
# Handle  Dravee   # Vulnerability details  ## Impact   Using both named returns and a return statement isn't necessary. Removing unused named return variables can reduce gas usage and improve code clarity. To save gas and improve code quality: consider using only one of those.      ## Proof of Concept   Instances include:   ``` ConvexStakingWrapper.sol:310:    function earned(address _account) external view returns (EarnedData[] memory claimable) { //@audit-info 342: return claimable;  Cvx3CrvOracle.sol:76:        returns (uint256 quoteAmount, uint256 updateTime) //@audit-info 78: return _peek(base.b6(), quote.b6(), baseAmount);  Cvx3CrvOracle.sol:97:        returns (uint256 quoteAmount, uint256 updateTime) //@audit-info 99: return _peek(base.b6(), quote.b6(), baseAmount); ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Remove the unused named returns   
# Handle  Dravee   # Vulnerability details  ## Impact Solidity contracts have contiguous 32 bytes (256 bits) slots used in storage. By arranging the variables, it is possible to minimize the number of slots used within a contract's storage and therefore reduce deployment costs.  ## Proof of Concept In `ConvexStakingWrapper.sol`, the order of variables is this way: ```     uint256 public cvx_reward_integral;     uint256 public cvx_reward_remaining;     mapping(address => uint256) public cvx_reward_integral_for;     mapping(address => uint256) public cvx_claimable_reward;      //constants/immutables     address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);     address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);     address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);     address public curveToken;     address public convexToken;     address public convexPool;     address public collateralVault;     uint256 public convexPoolId;      //rewards     RewardType[] public rewards;      //management     bool public isShutdown;     bool private _status;      bool private constant _NOT_ENTERED = false;     bool private constant _ENTERED = true; ``` `address` type variables are each of 20 bytes size (way less than 32 bytes). However, they here take up a whole 32 bytes slot (they are contiguous). As `bool` type variables are of size 1 byte, there's a slot here that can get saved by moving them closer to an address  ## Recommended Mitigation Steps I suggest the following (see the @audit-info tags for more details about what moved and why): ```     uint256 public cvx_reward_integral;     uint256 public cvx_reward_remaining;     mapping(address => uint256) public cvx_reward_integral_for;     mapping(address => uint256) public cvx_claimable_reward;      //constants/immutables     uint256 public convexPoolId; //@audit-info this moved up to free collateralVault's slot.     address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);     address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);     address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);     address public curveToken;     address public convexToken;     address public convexPool;     address public collateralVault; //@audit-info this got freed from convexPoolId. Slot N is at 20/32 here      //management      bool public isShutdown; //@audit-info this moved up. Slot N is full at 21/32 here      bool private _status; //@audit-info this moved up. Slot N is full at 22/32 here      bool private constant _NOT_ENTERED = false; //@audit-info this moved up but doesn't take a slot as it's constant     bool private constant _ENTERED = true; //@audit-info this moved up but doesn't take a slot as it's constant       //rewards     RewardType[] public rewards; ```    
# Handle  ye0lde   # Vulnerability details  ## Impact Typos  ## Proof of Concept The typos are here:  `vaulId` https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexModule.sol#L14 https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexModule.sol#L25  ## Tools Used VS Code  ## Recommended Mitigation Steps Correct the typos  
# Handle  Funen   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L94-L95  ``` IERC20(curveToken).approve(convexBooster, 0); IERC20(curveToken).approve(convexBooster, type(uint256).max); ```  `curveToken` was called mutiple times, caching it in `memory` , it can cost less gas  
# Handle  0x1f8b   # Vulnerability details  ## Impact owner can change the source without any warning.  ## Proof of Concept The method `Cvx3CrvOracle.setSource` should emit an event in order to be able to detect this call by dapps.  ## Tools Used Manual review  ## Recommended Mitigation Steps Emit an event  
# Handle  robee   # Vulnerability details  The following functions are missing commenting as describe below:              ConvexStakingWrapper.sol, user_checkpoint (external), @return is missing  
# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 115         change to prefix increment and unchecked: ConvexStakingWrapper.sol, u, 172         change to prefix increment and unchecked: ConvexStakingWrapper.sol, u, 227         change to prefix increment and unchecked: ConvexYieldWrapper.sol, i, 111         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 287         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 271         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 315         change to prefix increment and unchecked: ConvexYieldWrapper.sol, i, 63  
# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           ConvexStakingWrapper.sol, variable name: _accounts times: 5 at: _calcRewardIntegral         ConvexStakingWrapper.sol, variable name: _accounts times: 5 at: _calcCvxIntegral  
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).           ConvexModule.sol, line 3, import "@yield-protocol/vault-interfaces/DataTypes.sol";         ConvexStakingWrapper.sol, line 9, import "./interfaces/IConvexDeposits.sol";         ConvexStakingWrapper.sol, line 10, import "./interfaces/ICvx.sol";  
# Handle  throttle   # Vulnerability details  ## Impact Price can be stale and can lead to wrong `quoteAmount` return value  ## Proof of Concept Oracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong `quoteAmount` return value ```javascript function _peek(     bytes6 base,     bytes6 quote,     uint256 baseAmount ) private view returns (uint256 quoteAmount, uint256 updateTime) {     ...      (, int256 daiPrice, , , ) = DAI.latestRoundData();     (, int256 usdcPrice, , , ) = USDC.latestRoundData();     (, int256 usdtPrice, , , ) = USDT.latestRoundData();      require(         daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0,         "Chainlink pricefeed reporting 0"     );      ... } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Validate data feed ```javascript function _peek(     bytes6 base,     bytes6 quote,     uint256 baseAmount ) private view returns (uint256 quoteAmount, uint256 updateTime) {     ...     (uint80 roundID, int256 daiPrice, , uint256 timestamp, uint80 answeredInRound) = DAI.latestRoundData();     require(daiPrice > 0, "ChainLink: DAI price <= 0");     require(answeredInRound >= roundID, "ChainLink: Stale price");     require(timestamp > 0, "ChainLink: Round not complete");      (roundID, int256 usdcPrice, , timestamp, answeredInRound) = USDC.latestRoundData();     require(usdcPrice > 0, "ChainLink: USDC price <= 0");     require(answeredInRound >= roundID, "ChainLink: Stale USDC price");     require(timestamp > 0, "ChainLink: USDC round not complete");      (roundID, int256 usdtPrice, , timestamp, answeredInRound) = USDT.latestRoundData();     require(usdtPrice > 0, "ChainLink: USDT price <= 0");     require(answeredInRound >= roundID, "ChainLink: Stale USDT price");     require(timestamp > 0, "ChainLink: USDT round not complete");      ... } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L206-L224  ```solidity function _calcRewardIntegral(     uint256 _index,     address[2] memory _accounts,     uint256[2] memory _balances,     uint256 _supply,     bool _isClaim ) internal {     RewardType storage reward = rewards[_index];      uint256 rewardIntegral = reward.reward_integral;     uint256 rewardRemaining = reward.reward_remaining;      //get difference in balance and remaining rewards     //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed     uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));     if (_supply > 0 && (bal - rewardRemaining) > 0) {         rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);         reward.reward_integral = uint128(rewardIntegral);     } ```  `reward.reward_integral` is `uint128`, if a early user mint (wrap) just `1` Wei of `convexToken`, and make `_supply == 1`, and then tranferring `5e18` of `reward_token` to the contract.  As a result, `reward.reward_integral` can exceed `type(uint128).max` and overflow, causing the rewards distribution to be disrupted.  ### Recommendation  Consider `wrap` a certain amount of initial totalSupply, e.g. `1e8`, and never burn it. And consider using uint256 instead of uint128 for `reward.reward_integral`. Also, consdier lower `1e20` down to `1e12`.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The Cvx3CrvOracle.sol contract has functions that take the baseAmount input parameter but fail to mention or describe this parameter in the function's natspec comments. Issues with comments are low risk based on [Code4rena risk categories](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  The functions missing the baseAmount input parameter in comments include: - [peek()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L59-L66) - [get()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L81-L88) - [_peek()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L102-L109)  ## Recommended Mitigation Steps  Make sure natspec comments include all function input parameters.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The _calcRewardIntegral function casts intermediate reward values from uint256 to uint128 and vice versa several times. Because OpenZeppelin SafeCast is not used, casting from uint256 to uint128 may overflow if a large reward value is being calculate. This overflow could result in users receiving less rewards than they are owed.  ## Proof of Concept  There are 4 uint128 casting operations and 2 uint256 casting operations [in the _calcRewardIntegral function of ConvexStakingWrapper.sol](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L222-L253).  ## Recommended Mitigation Steps  Because reward values are an important part of this protocol, use the OpenZeppelin SafeCast library to prevent unexpected overflows when casting. SafeMath and Solidity 0.8.* handles overflows for basic math operations but not for casting.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L74-L95  ```solidity     function removeVault(bytes12 vaultId, address account) public {         address owner = cauldron.vaults(vaultId).owner;         if (account != owner) {             bytes12[] storage vaults_ = vaults[account];             uint256 vaultsLength = vaults_.length;             bool found;             for (uint256 i = 0; i < vaultsLength; i++) {                 if (vaults_[i] == vaultId) {                     bool isLast = i == vaultsLength - 1;                     if (!isLast) {                         vaults_[i] = vaults_[vaultsLength - 1];                     }                     vaults_.pop();                     found = true;                     emit VaultRemoved(account, vaultId);                     break;                 }             }             require(found, "Vault not found");             vaults[account] = vaults_;         }     } ```  `found` is redundant, we can just use `return` to stop the whole function when the `vault` to be removed is found and removed.  `removeVault()` can be changed to:  ```solidity function removeVault(bytes12 vaultId, address account) public {     address owner = cauldron.vaults(vaultId).owner;     if (account != owner) {         bytes12[] storage vaults_ = vaults[account];         uint256 vaultsLength = vaults_.length;         for (uint256 i = 0; i < vaultsLength; i++) {             if (vaults_[i] == vaultId) {                 bool isLast = i == vaultsLength - 1;                 if (!isLast) {                     vaults_[i] = vaults_[vaultsLength - 1];                 }                 vaults_.pop();                 found = true;                 emit VaultRemoved(account, vaultId);                 return;             }         }         revert("Vault not found");     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L74-L95  ```solidity function removeVault(bytes12 vaultId, address account) public {     address owner = cauldron.vaults(vaultId).owner;     if (account != owner) {         bytes12[] storage vaults_ = vaults[account];         uint256 vaultsLength = vaults_.length;         bool found;         for (uint256 i = 0; i < vaultsLength; i++) {             if (vaults_[i] == vaultId) {                 bool isLast = i == vaultsLength - 1;                 if (!isLast) {                     vaults_[i] = vaults_[vaultsLength - 1];                 }                 vaults_.pop();                 found = true;                 emit VaultRemoved(account, vaultId);                 break;             }         }         require(found, "Vault not found");         vaults[account] = vaults_;     } } ```  At L77, `vaults_` is defined as `vaults[account]`, thus `vaults[account] = vaults_` at L93 is redundant.  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L57-L69  ```solidity function addVault(bytes12 vaultId) external {     address account = cauldron.vaults(vaultId).owner;     require(account != address(0), "No owner for the vault");     bytes12[] storage vaults_ = vaults[account];     uint256 vaultsLength = vaults_.length;      for (uint256 i = 0; i < vaultsLength; i++) {         require(vaults_[i] != vaultId, "Vault already added");     }     vaults_.push(vaultId);     vaults[account] = vaults_;     emit VaultAdded(account, vaultId); } ```  Similarly, L76 is redundant.  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_calcCvxIntegral()` function in ConvexStakingWrapper.sol doesn't use the same gas optimization that its sibling function `_calcRewardIntegral()` uses.  ## Proof of Concept  This code is from [the `_calcCvxIntegral()` function](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L154) ``` if (_isClaim || userI < cvxRewardIntegral) {     uint256 receiveable = cvx_claimable_reward[_accounts[u]] +         ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);     if (_isClaim) {         if (receiveable > 0) {             cvx_claimable_reward[_accounts[u]] = 0;             IERC20(cvx).safeTransfer(_accounts[u], receiveable);             bal = bal - (receiveable);         }     } else {         cvx_claimable_reward[_accounts[u]] = receiveable;     }     cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral; } ```  The related code from [the `_calcRewardIntegral()` function](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L206) has the receivable calculation inside the `if (_isClaim)` code branch to save gas if _isClaim is false.  ``` if (_isClaim || userI < rewardIntegral) {     if (_isClaim) {         uint256 receiveable = reward.claimable_reward[_accounts[u]] +             ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);         if (receiveable > 0) {             reward.claimable_reward[_accounts[u]] = 0;             IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);             bal = bal - receiveable;         }     } else {         reward.claimable_reward[_accounts[u]] =             reward.claimable_reward[_accounts[u]] +             ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);     }     reward.reward_integral_for[_accounts[u]] = rewardIntegral; } ```  This optimization would save gas each time `_checkpoint()` is called because `_checkpoint()` sets _isClaim to false and doesn't enter the `if(_isClaim)` branch.   ## Recommended Mitigation Steps  Modify the `_calcCvxIntegral()` function to place the receiveable calculation inside the `if (_isClaim)` code branch.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  1. https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L114-L114  ```solidity uint256 startIndex = rewardsLength - 1; ```  `rewardsLength - 1` will never underflow.  2. https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L82-L85  ```solidity=82 bool isLast = i == vaultsLength - 1; if (!isLast) {     vaults_[i] = vaults_[vaultsLength - 1]; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L54-L55  ```solidity     bool private constant _NOT_ENTERED = false;     bool private constant _ENTERED = true; ```  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L81-L90  ```solidity     modifier nonReentrant() {         // On the first call to nonReentrant, _notEntered will be true         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");         // Any calls to nonReentrant after this point will fail         _status = _ENTERED;         _;         // By storing the original value once again, a refund is triggered (see         // https://eips.ethereum.org/EIPS/eip-2200)         _status = _NOT_ENTERED;     } ```  `SSTORE` from 0 to 1 (or any non-zero value), the cost is 20000; `SSTORE` from 1 to 2 (or any other non-zero value), the cost is 5000.  By storing the original value once again, a refund is triggered (https://eips.ethereum.org/EIPS/eip-2200).  Since refunds are capped to a percentage of the total transaction's gas, it is best to keep them low, to increase the likelihood of the full refund coming into effect.  Therefore, switching between 1, 2 instead of 0, 1 will be more gas efficient.  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/86bd4d73896afcb35a205456e361436701823c7a/contracts/security/ReentrancyGuard.sol#L29-L33  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L106-L111  ```solidity     if (rewardsLength == 0) {         RewardType storage reward = rewards.push();         reward.reward_token = crv;         reward.reward_pool = mainPool;         rewardsLength += 1;     } ```  When `rewardsLength` == `0`,  the new `rewardsLength` will always be 1. Therefore, replacing `+=` with `=` can avoid the unnecessary arithmetic operations and memory reads    ### Recommendation  Change to:  ```solidity     if (rewardsLength == 0) {         RewardType storage reward = rewards.push();         reward.reward_token = crv;         reward.reward_pool = mainPool;         rewardsLength = 1;     } ```  
# Handle  kenzo   # Vulnerability details  The ConvexStakingWrapper that Yield is based on recently published a fix for `earned` function in case the pool is claimed indirectly.  ## Impact Wrong results might be returned from view function `earned`.  ## Proof of Concept This is the fix for earned: [fix commit](https://github.com/convex-eth/platform/commit/9b9dd72bdb822e7f34f241d620cc1f8388bf7d6a#)  ## Recommended Mitigation Steps Apply fix.  
# Handle  leastwood   # Vulnerability details  ## Impact  `ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which: - Approves Ladle to move the tokens. - Transfers the tokens to `ConvexYieldWrapper.sol`. - Wraps/stakes these tokens. - Updates accounting and produces debt tokens within `Ladle.sol`.  `_getDepositedBalance()` takes into consideration the user's total collateral stored in all of their owned vaults. However, as a vault owner, you are allowed to give the vault to another user, move collateral between vaults and add/remove collateral. Therefore, it is possible to manipulate the result of this function by checkpointing one user's balance at a given time, transferring ownership to another user and then create a new checkpoint with this user.   As a result, a user is able to generate protocol yield multiple times over on a single collateral amount. This can be abused to effectively extract all protocol yield.  ## Proof of Concept  Consider the following exploit scenario: - Alice owns a vault which has 100 tokens worth of collateral. - At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards. - Alice then calls `Ladle.give()`, transferring the ownership of the vault to Bob and calls `ConvexYieldWrapper.addVault()`. - Bob is able to call `user_checkpoint()` and effectively update their checkpointed balance. - At this point in time, both Alice and Bob have claim to any yield generated by the protocol, however, there is only one vault instance that holds the underlying collateral.  https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexYieldWrapper.sol#L100-L120 ``` function _getDepositedBalance(address account_) internal view override returns (uint256) {     if (account_ == address(0) || account_ == collateralVault) {         return 0;     }      bytes12[] memory userVault = vaults[account_];      //add up all balances of all vaults registered in the wrapper and owned by the account     uint256 collateral;     DataTypes.Balances memory balance;     uint256 userVaultLength = userVault.length;     for (uint256 i = 0; i < userVaultLength; i++) {         if (cauldron.vaults(userVault[i]).owner == account_) {             balance = cauldron.balances(userVault[i]);             collateral = collateral + balance.ink;         }     }      //add to balance of this token     return _balanceOf[account_] + collateral; } ```  ## Tools Used  Manual code review. Discussion/confirmation with the Yield Protocol team.  ## Recommended Mitigation Steps  Ensure that any change to a vault will correctly checkpoint the previous and new vault owner. The affected actions include but are not limited to; transferring ownership of a vault to a new account, transferring collateral to another vault and adding/removing collateral to/from a vault.  
# Handle  GeekyLumberjack   # Vulnerability details  `uint256[2] memory depositedBalance;` is defined at the beginning of [_checkpointAndClaim](https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L279-L291) only one `depositedBalance` slot is being filed and then the entire array gets passed into `_calcRewardIntegral()` and `_calcCvxIntegral()` along with an array of two `_accounts`. Having only one of the `depositedBalance` and two `_accounts` may cause loss in rewards for the second account. This function is currently only used in `GetReward()` which is passing in a zero address as the second address.   
# Handle  leastwood   # Vulnerability details  ## Impact  `ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which: - Approves Ladle to move the tokens. - Transfers the tokens to `ConvexYieldWrapper.sol`. - Wraps/stakes these tokens. - Updates accounting and produces debt tokens within `Ladle.sol`.  During `wrap()` and `unwrap()` actions, `_checkpoint()` is used to update the rewards for the `from_` and `to_` accounts. However, the [reference](https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract implements a `_beforeTokenTransfer()` function which has been removed from Yield Protocol's custom implementation.  As a result, it is possible to transfer `wCVX` tokens to another account after an initial checkpoint has been made. By manually calling `user_checkpoint()` on the new account, this user is able to update its deposited balance of the new account while the sender's balance is not updated. This can be repeated to effectively replicate a user's deposited balance over any number of accounts. To claim yield generated by the protocol, the user must only make sure that the account calling `getReward()` holds the tokens for the duration of the call.  ## Proof of Concept  The exploit can be outlined through the following steps: - Alice receives 100 `wCVX` tokens from the protocol after wrapping their convex tokens. - At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards. - Alice transfers her tokens to her friend Bob who then manually calls `user_checkpoint()` to update his balance. - Now from the perspective of the protocol, both Alice and Bob have 100 `wCVX` tokens as calculated by the `_getDepositedBalance()` function. - If either Alice or Bob wants to claim rewards, all they need to do is make sure the 100 `wCVX` tokens are in their account upon calling `getReward()`. Afterwards, the tokens can be transferred out.  ## Tools Used  Manual code review. Discussion/confirmation with the Yield Protocol team.  ## Recommended Mitigation Steps  Consider implementing the `_beforeTokenTransfer()` function as shown in the [reference](https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract. However, it is important to ensure the wrapper contract and collateral vaults are excluded from the checkpointing so they are not considered in the rewards calculations.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  L116 of Cvx3CrvOracle enforces for the rest of the function call that `base == ethId <-> quote == cvx3CrvId`  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L116  However on L137 we check both these conditions again.  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L137  We could check just one of these and then rely on the require condition on 116 to enforce the other one. This will prevent us having to SLOAD `ethID` again  ## Recommended Mitigation Steps  Change L137 to `if (base == cvx3CrvId) {`  
# Handle  Dravee   # Vulnerability details  ## Impact AccessControl capabilities aren't used.  ## Proof of Concept In `ConvexStakingWrapper.sol`, `AccessControl` seem superfluous: ``` 7: import "@yield-protocol/utils-v2/contracts/access/AccessControl.sol"; ... 15: contract ConvexStakingWrapper is ERC20, AccessControl { ``` In the original `ConvexStakingWrapper.sol`, this `AccessControl` isn't inherited.   In this contract, I believe role-based capabilities were thought of, but were forgotten or abandonned.  ## Tools Used VS Code  ## Recommended Mitigation Steps Either use the capabilities from `AccessControl`, or delete the import + the inheritance to save gas.  
# Handle  Dravee   # Vulnerability details  ## Impact No protection from reentrancy (besides the gas limit on safeTransfer). Bad practice compared to the original `ConvexStakingWrapper` contract.  ## Proof of Concept The original `ConvexStakingWrapper` contract used the `nonReentrant` modifier on all functions using the `safeTransfer` or `safeTransferFrom` methods: - `deposit`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L337 - `stake`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L352  - `withdraw`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L367 - `withdrawAndUnwrap`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L381  As the current one in the Yield solution is an upgrade, it should follow the same good practices.  ## Tools Used VS Code  ## Recommended Mitigation Steps Use the `nonReentrant` modifier on external functions that end up calling `safeTransfer` or `safeTransferFrom` (`user_checkpoint()` and `getReward()`)  
# Handle  rfa   # Vulnerability details  ## Impact spend at least 6930 more gas on deployment, and spend 40 gas more per call (by using current implementasion)  ## Proof of Concept https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L184 https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L239  the `TransferHelper` lib just used twice in this contract. remove:(line 16) https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L16  and just call `TransferHelper.safeTransfer()` directly at those line.  This method is using almost exact the same gas as if we just copying the `safeTransfer()` and remove the `TransferHelper` lib from the contract. (since we need just 1 function from the lib)    
# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive (~100 gas) compared to MLOADs/MSTOREs (~3 gas). Minimizing them can save gas.  ## Proof of Concept The code is as such (see `@audit-info`): ``` File: Cvx3CrvOracle.sol 110:     function _peek( 111:         bytes6 base, 112:         bytes6 quote, 113:         uint256 baseAmount 114:     ) private view returns (uint256 quoteAmount, uint256 updateTime) { 115:         require( 116:             (base == ethId && quote == cvx3CrvId) || // @audit-info ethId SLOAD 1, cvx3CrvId SLOAD 1 117:                 (base == cvx3CrvId && quote == ethId), // @audit-info ethId SLOAD 2, cvx3CrvId SLOAD 2 118:             "Invalid quote or base" 119:         ); 120:         (, int256 daiPrice, , , ) = DAI.latestRoundData(); 121:         (, int256 usdcPrice, , , ) = USDC.latestRoundData(); 122:         (, int256 usdtPrice, , , ) = USDT.latestRoundData(); 123:  124:         require( 125:             daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0, 126:             "Chainlink pricefeed reporting 0" 127:         ); 128:  129:         // This won't overflow as the max value for int256 is less than the max value for uint256 130:         uint256 minStable = min( 131:             uint256(daiPrice), 132:             min(uint256(usdcPrice), uint256(usdtPrice)) 133:         ); 134:  135:         uint256 price = (threecrv.get_virtual_price() * minStable) / 1e18; 136:  137:         if (base == cvx3CrvId && quote == ethId) { // @audit-info ethId SLOAD 3, cvx3CrvId SLOAD 3 138:             quoteAmount = (baseAmount * price) / 1e18; 139:         } else { 140:             quoteAmount = (baseAmount * 1e18) / price; 141:         } 142:  143:         updateTime = block.timestamp; 144:     } ```  By caching `ethId` and `cvx3CrvId` in memory, it's possible to save 4 SLOADs (~400gas) at the cost of 2 MSTOREs (6 gas) and 4 MLOADs (12 gas)  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `ethId` and `cvx3CrvId` in variables and use these instead  
# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost due to unnecessary automatic underflow checks.  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers.  When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block.  https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  ## Proof of Concept In `ConvexStakingWrapper.sol:_calcRewardIntegral()`, `bal - rewardRemaining` can't underflow at line 222 as the conditional statement line 221 prevents it: ``` File: ConvexStakingWrapper.sol 221:         if (_supply > 0 && (bal - rewardRemaining) > 0) { 222:             rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply); //@audit-info (bal - rewardRemaining) can't underflow because of above if statement ``` This substraction should get computed inside an `unchecked` block and stored in a variable, which would then be used in the checked calculation for `rewardIntegral`.  ## Tools Used VS Code  ## Recommended Mitigation Steps Uncheck arithmetic operations when the risk of underflow or overflow is already contained by wrapping them in an `unchecked` block    
# Handle  Dravee   # Vulnerability details  ## Impact   Using both named returns and a return statement isn't necessary. Removing unused named return variables can reduce gas usage and improve code clarity. To save gas and improve code quality: consider using only one of those.      ## Proof of Concept   Instances include:   ``` ConvexStakingWrapper.sol:310:    function earned(address _account) external view returns (EarnedData[] memory claimable) { //@audit-info 342: return claimable;  Cvx3CrvOracle.sol:76:        returns (uint256 quoteAmount, uint256 updateTime) //@audit-info 78: return _peek(base.b6(), quote.b6(), baseAmount);  Cvx3CrvOracle.sol:97:        returns (uint256 quoteAmount, uint256 updateTime) //@audit-info 99: return _peek(base.b6(), quote.b6(), baseAmount); ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Remove the unused named returns   
# Handle  Dravee   # Vulnerability details  ## Impact Solidity contracts have contiguous 32 bytes (256 bits) slots used in storage. By arranging the variables, it is possible to minimize the number of slots used within a contract's storage and therefore reduce deployment costs.  ## Proof of Concept In `ConvexStakingWrapper.sol`, the order of variables is this way: ```     uint256 public cvx_reward_integral;     uint256 public cvx_reward_remaining;     mapping(address => uint256) public cvx_reward_integral_for;     mapping(address => uint256) public cvx_claimable_reward;      //constants/immutables     address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);     address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);     address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);     address public curveToken;     address public convexToken;     address public convexPool;     address public collateralVault;     uint256 public convexPoolId;      //rewards     RewardType[] public rewards;      //management     bool public isShutdown;     bool private _status;      bool private constant _NOT_ENTERED = false;     bool private constant _ENTERED = true; ``` `address` type variables are each of 20 bytes size (way less than 32 bytes). However, they here take up a whole 32 bytes slot (they are contiguous). As `bool` type variables are of size 1 byte, there's a slot here that can get saved by moving them closer to an address  ## Recommended Mitigation Steps I suggest the following (see the @audit-info tags for more details about what moved and why): ```     uint256 public cvx_reward_integral;     uint256 public cvx_reward_remaining;     mapping(address => uint256) public cvx_reward_integral_for;     mapping(address => uint256) public cvx_claimable_reward;      //constants/immutables     uint256 public convexPoolId; //@audit-info this moved up to free collateralVault's slot.     address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);     address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);     address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);     address public curveToken;     address public convexToken;     address public convexPool;     address public collateralVault; //@audit-info this got freed from convexPoolId. Slot N is at 20/32 here      //management      bool public isShutdown; //@audit-info this moved up. Slot N is full at 21/32 here      bool private _status; //@audit-info this moved up. Slot N is full at 22/32 here      bool private constant _NOT_ENTERED = false; //@audit-info this moved up but doesn't take a slot as it's constant     bool private constant _ENTERED = true; //@audit-info this moved up but doesn't take a slot as it's constant       //rewards     RewardType[] public rewards; ```    
# Handle  ye0lde   # Vulnerability details  ## Impact Typos  ## Proof of Concept The typos are here:  `vaulId` https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexModule.sol#L14 https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexModule.sol#L25  ## Tools Used VS Code  ## Recommended Mitigation Steps Correct the typos  
# Handle  Funen   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L94-L95  ``` IERC20(curveToken).approve(convexBooster, 0); IERC20(curveToken).approve(convexBooster, type(uint256).max); ```  `curveToken` was called mutiple times, caching it in `memory` , it can cost less gas  
# Handle  0x1f8b   # Vulnerability details  ## Impact owner can change the source without any warning.  ## Proof of Concept The method `Cvx3CrvOracle.setSource` should emit an event in order to be able to detect this call by dapps.  ## Tools Used Manual review  ## Recommended Mitigation Steps Emit an event  
# Handle  robee   # Vulnerability details  The following functions are missing commenting as describe below:              ConvexStakingWrapper.sol, user_checkpoint (external), @return is missing  
# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 115         change to prefix increment and unchecked: ConvexStakingWrapper.sol, u, 172         change to prefix increment and unchecked: ConvexStakingWrapper.sol, u, 227         change to prefix increment and unchecked: ConvexYieldWrapper.sol, i, 111         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 287         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 271         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 315         change to prefix increment and unchecked: ConvexYieldWrapper.sol, i, 63  
# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           ConvexStakingWrapper.sol, variable name: _accounts times: 5 at: _calcRewardIntegral         ConvexStakingWrapper.sol, variable name: _accounts times: 5 at: _calcCvxIntegral  
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).           ConvexModule.sol, line 3, import "@yield-protocol/vault-interfaces/DataTypes.sol";         ConvexStakingWrapper.sol, line 9, import "./interfaces/IConvexDeposits.sol";         ConvexStakingWrapper.sol, line 10, import "./interfaces/ICvx.sol";  
