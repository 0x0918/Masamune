# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L204-L219   # Vulnerability details  ## Description   purchase() in GroupBuy faciilitates the purchasing of an NFT after enough contributions were gathered. Another report titled *"Attacker can steal the amount collected so far in the GroupBuy for NFT purchase*" describes a high impact bug in purchase. It is advised to read that first for context.  Additionally, purchase() is vulnerable to a re-entrancy exploit which can be *chained* or *not chained* to the \_market issue to steal *the entire* ETH stored in GroupBuy, rather than being capped to `minReservePrices[_poolId] * filledQuantities[_poolId]`.   Attacker may take control of execution using this call: ``` // Executes purchase order transaction through market buyer contract and deploys new vault address vault = IMarketBuyer(_market).execute{value: _price}(_purchaseOrder); ``` It could occur either by exploiting the unvalidated \_market vulnerability , or by abusing an existing market that uses a user address in \_purchaseOrder.   There is no re-entrancy protection in purchase() call: ``` function purchase(     uint256 _poolId,     address _market,     address _nftContract,     uint256 _tokenId,     uint256 _price,     bytes memory _purchaseOrder,     bytes32[] memory _purchaseProof ) external { ```  \_verifyUnsuccessfulState() needs to not revert for purchase call. It checks the pool.success flag: `if (pool.success || block.timestamp > pool.terminationPeriod) revert InvalidState();`  However, success is only set as the last thing in purchase(): ```     // Stores mapping value of poolId to newly deployed vault     poolToVault[_poolId] = vault;     // Sets pool state to successful     poolInfo[_poolId].success = true;     // Emits event for purchasing NFT at given price     emit Purchase(_poolId, vault, _nftContract, _tokenId, _price); } ```  Therefore, attacker can re-enter purchase() function multiple times, each time extracting the maximum allowed price. If attacker uses the controlled \_market exploit, the function will return the current NFT owner, so when all the functions unwind they will keep setting success to true and exit nicely.  ## Impact  GroupBuy can be drained of all ETH.  ## Proof of Concept  1. GroupBuy holds 1500 ETH, from various bids 2. maximum allowed price (`minReservePrices[_poolId] * filledQuantities[_poolId]`) is 50 * 20 = 1000 ETH 3. purchase(1000 ETH) is called  1. GroupBuy sends attacker 1000 ETH and calls execute()   1. execute() calls purchase(500ETH)    1. GroupBuy sends attacker 500 ETH and calls execute()     1. execute returns NFT owner address    2. GroupBuy sees returned address is NFT owner. Marks success and returns   2. execute returns NFT owner address  2. GroupBuy sees returned address is NFT owner. Marks success and returns 4. Attacker is left with 1500 ETH. Previous exploit alone can only net 1000ETH. Additionally, this exploit can be chained to any trusted MarketBuyer which passes control to user for purchasing and storing in vault, and then returns a valid vault.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Add a re-entrancy guard to purchase() function. Also, change success variable before performing external contract calls.
# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L83   # Vulnerability details  ## Description  createPool() in GroupBuy.sol creates a new contribution pool around an NFT. It specifies a target \_initialPrice as minimum amount of ETH the NFT will cost, and \_totalSupply which is the number of Raes to be minted on purchase success.  minBidPrices is calculated from the two numbers. All future bids must be at least minBidPrices. It is assumed that if the totalSupply of Raes is filled up, the group will collect the initialPrice. ``` // Calculates minimum bid price based on initial price of NFT and desired total supply minBidPrices[currentId] = _initialPrice / _totalSupply; ```  The issue is that division rounding error will make minBidPrices too low. Therefore, when all Raes are minted using minBidPrices price: minBidPrices[currentId] * \_totalSupply != \_initialPrice   Therefore, not enough money has been collected to fund the purchase. It can be assumed that most people will use minBidPrices to drive the price they will choose. Therefore, even after discovering that the Group has not raised enough after filling the supply pool, it will be very hard to get everyone to top up the contribution by a bit. This is because the settled price which is collected from all contributions is minReservePrices, which is always the minimum price deposited.  Code in contribute that updates minReservePrices: ``` // Updates minimum reserve price if filled quantity amount is greater than 0 if (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId); ```   The check in purchase() that we don't charge more than minReservePrices from each contribution: ``` if (_price > minReservePrices[_poolId] * filledQuantities[_poolId])     revert InvalidPurchase(); ```  We can see an important contract functionality is not working as expected which will impair NFT purchases.  ## Impact  GroupBuys that are completely filled still don't raise stated target amount  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Round the minBidPrices up, rather than down. It will ensure enough funds are collected.
# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L204   # Vulnerability details  ## Description  purchase() in GroupBuy.sol executes the purchase call for the group. After safety checks, the NFT is bought with \_market's execute() function. Supposedly it deploys a vault which owns the NFT. The code makes sure the vault is the new owner of the NFT and exits. ``` // Executes purchase order transaction through market buyer contract and deploys new vault address vault = IMarketBuyer(_market).execute{value: _price}(_purchaseOrder); // Checks if NFT contract supports ERC165 and interface ID of ERC721 tokens if (ERC165Checker.supportsInterface(_nftContract, _INTERFACE_ID_ERC721)) {     // Verifes vault is owner of ERC-721 token     if (IERC721(_nftContract).ownerOf(_tokenId) != vault) revert UnsuccessfulPurchase(); } else {     // Verifies vault is owner of CryptoPunk token     if (ICryptoPunk(_nftContract).punkIndexToAddress(_tokenId) != vault)         revert UnsuccessfulPurchase(); }  // Stores mapping value of poolId to newly deployed vault poolToVault[_poolId] = vault; // Sets pool state to successful poolInfo[_poolId].success = true; // Emits event for purchasing NFT at given price emit Purchase(_poolId, vault, _nftContract, _tokenId, _price); ```  The issue is that \_market user-supplied variable is not validated at all. Attacker can pass their malicious contract, which uses the passed funds to buy the NFT and store it in attacker's wallet. It will return the NFT-holding wallet so the checks will pass. As a result, attacker has the NFT while they could have contributed nothing to the GroupBuy. Attacker can also just steal the supplied ETH and return the current address which holds the NFT.  ## Impact  Attacker can steal the amount collected so far in the GroupBuy for NFT purchase.  ## Proof of Concept  1. Group assembles and raises funds to buy NFT X 2. Attacker calls purchase() and supplies their malicious contract in \_market, as described. 3. Attacker receives raised funds totalling  `minReservePrices[_poolId] * filledQuantities[_poolId]`, as checked in line 182.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  \_market should be whitelisted, or supplied in createPool stage and able to be scrutinized.
# Lines of code  LOC: https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L301   # Vulnerability details  ## Description  In GroupBuy module, users can call contribute to get a piece of the NFT pie. There are two stages in transforming the msg.value to holdings in the NFT.Â   1. filling at any price(supply is not yet saturated) ``` uint256 fillAtAnyPriceQuantity = remainingSupply < _quantity ? remainingSupply : _quantity; // Checks if quantity amount being filled is greater than 0 if (fillAtAnyPriceQuantity > 0) {     // Inserts bid into end of queue     bidPriorityQueues[_poolId].insert(msg.sender, _price, fillAtAnyPriceQuantity);     // Increments total amount of filled quantities     filledQuantities[_poolId] += fillAtAnyPriceQuantity; } ```  2. Trim out lower price offers to make room for current higher offer. ``` // Calculates unfilled quantity amount based on desired quantity and actual filled quantity amount uint256 unfilledQuantity = _quantity - fillAtAnyPriceQuantity; // Processes bids in queue to recalculate unfilled quantity amount unfilledQuantity = processBidsInQueue(_poolId, unfilledQuantity, _price); ```  The while loop in `processBidsInQueue` will keep removing existing bids with lower price and create new queue entries for currently processed bid. When it reached a bid with a higher price than msg.sender's price, it will break: ``` while (quantity > 0) {     // Retrieves lowest bid in queue     Bid storage lowestBid = bidPriorityQueues[_poolId].getMin();     // Breaks out of while loop if given price is less than than lowest bid price     if (_price < lowestBid.price) {         break;     } ```  The issue is that when `_price  == lowestBid.price`, we don't break and current bid will kick out older bid, as can be seen here:  ``` // Decrements given quantity amount from lowest bid quantity lowestBid.quantity -= quantity; // Calculates partial contribution of bid by quantity amount and price uint256 contribution = quantity * lowestBid.price; // Decrements partial contribution amount of lowest bid from total and user contributions totalContributions[_poolId] -= contribution; userContributions[_poolId][lowestBid.owner] -= contribution; // Increments pending balance of lowest bid owner pendingBalances[lowestBid.owner] += contribution; // Inserts new bid with given quantity amount into proper position of queue bidPriorityQueues[_poolId].insert(msg.sender, _price, quantity); ```  The described behavior goes against what the docs [describe](https://github.com/code-423n4/2022-12-tessera#step-3-other-users-deposit-funds-to-pool-filtering) will happen when two equal priced bids collide.  ## Impact  Earlier bidders get cut out of future NFT holdings by bidders specifying the same price.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Change the < to <= in the if condition: ``` if (_price <= lowestBid.price) {     break; } ```
# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L295 https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L232   # Vulnerability details  ## Description  In OptimisticListingOpensea, there are several functions which update pendingBalances of a proposer: 1. list() 2. cash() 3. propose()  Unfortunately, in list() and cash() the = operator is used instead of += when writing the new pendingBalances. For example: ``` function cash(address _vault, bytes32[] calldata _burnProof) external {     // Reverts if vault is not registered     (address token, uint256 id) = _verifyVault(_vault);     // Reverts if active listing has not been settled     Listing storage activeListing = activeListings[_vault];     // Reverts if listing has not been sold     if (!_verifySale(_vault)) {         revert NotSold();     } else if (activeListing.collateral != 0) {         uint256 collateral = activeListing.collateral;         activeListing.collateral = 0;         // Sets collateral amount to pending balances for withdrawal         pendingBalances[_vault][activeListing.proposer] = collateral;     }  ... ```  pendingBalances is not guaranteed to be zero. There could be funds from previous proposals which are not yet collected. Propose updates pendingBalance correctly: ``` // Sets collateral amount to pending balances for withdrawal pendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral; ```  So, when propose is followed by another propose(), the pendingBalance is updated correctly, but in cash and list we don't account for pre-existing balance. This issue would manifest even after the fix suggested in the issue "User can send a proposal and instantly take back their collateral" because reject functions would increment the pendingBalance and then it would be overriden.  ## Impact  User loses collateral converted to pendingBalance when cash() or list() is called  ## Proof of Concept  1. User calls propose() and gets pendingBalance = x 2. User calls propose() with an improved proposal and gets pendingBalance = 1.5x 3. proposal is successfull and the listing purchased the NFT 4. cash() is called to convert the Raes to ETH amount from the sell. pendingBalance is overridden by the current "collateral"  value. pendingBalance = 0.5x 5. User loses x collateral value which is stuck in the contract  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Change the = operator to += in list() and cash().
# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L428   # Vulnerability details  ## Description  \_constructOrder is called in propose(), OptimisticListingSeaport.sol. It fills the order params stored in proposedListings[_vault].  ``` {     orderParams.offerer = _vault;     orderParams.startTime = block.timestamp;     // order doesn't expire in human time scales and needs explicit cancellations     orderParams.endTime = type(uint256).max;     orderParams.zone = zone;     // 0: no partial fills, anyone can execute     orderParams.orderType = OrderType.FULL_OPEN;     orderParams.conduitKey = conduitKey;     // 1 Consideration for the listing itself + 1 consideration for the fees     orderParams.totalOriginalConsiderationItems = 3; } ```  Importantly, it updates the order hash associated with the vault: `vaultOrderHash[_vault] = _getOrderHash(orderParams, counter);`  There is only one other use of `vaultOrderHash`, in \_verifySale().  ``` function _verifySale(address _vault) internal view returns (bool status) {     (bool isValidated, bool isCancelled, uint256 totalFilled, uint256 totalSize) = ISeaport(         seaport     ).getOrderStatus(vaultOrderHash[_vault]);     if (isValidated && !isCancelled && totalFilled > 0 && totalFilled == totalSize) {         status = true;     } } ``` This function gets order information from the order hash, and makes sure the order is completely fulfilled.  After NFT sell has completed, cash() is used to distribute income ETH: ``` function cash(address _vault, bytes32[] calldata _burnProof) external {     // Reverts if vault is not registered     (address token, uint256 id) = _verifyVault(_vault);     // Reverts if active listing has not been settled     Listing storage activeListing = activeListings[_vault];     // Reverts if listing has not been sold    // -------------- _verifySale MUST BE TRUE ---------     if (!_verifySale(_vault)) {         revert NotSold();     } else if (activeListing.collateral != 0) {         uint256 collateral = activeListing.collateral;         activeListing.collateral = 0;         // Sets collateral amount to pending balances for withdrawal         pendingBalances[_vault][activeListing.proposer] = collateral;     } ```  As long as sale is not complete, cash() can't be called as highlighted. The issue is that `vaultOrderHash[_vault]` is not protected during the lifetime of an active proposal. If another proposal is proposed and then the sell using active proposal takes place, cash() will keep reverting. Funds are stuck in listing contract.  We can try to be clever and call propose() again with the same parameters to create an identical orderID, which will make `vaultOrderHash[_vault]` fine again and allow cash() to go through. But order params contain block.timestamp which will certainly be different which will make the hash different.   ## Impact  Funds are permanently stuck in OptimisticListingSeaport.sol contract if active proposal is executed after new proposal is pending.  ## Proof of Concept  1. User A calls propose(), setting proposedListing. vaultOrderHash=X 2. PROPOSAL_PERIOD passes , list is called promoting the listing to activeListing. 3. Another user, malicious or innocent, proposes another proposal. vaultOrderHash=Y 4. Sell goes down due to OpenSea validation confirmed on activeListing. 5. \_verifySale will never return true because we can never got vaultOrderHash to be X 6. cash() is bricked. Money is stuck in contract.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Keep the order hash in the Listing structure rather than a single one per vault.
# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L209   # Vulnerability details  ## Description  sendEthOrWeth() is used in several locations in OptimisticListingSeaport: 1. rejectProposal - sent to proposer 2. rejectActive - sent to proposer 3. cash - sent to msg.sender  This is the implementation of sendEthOrWeth: ``` function _attemptETHTransfer(address _to, uint256 _value) internal returns (bool success) {     // Here increase the gas limit a reasonable amount above the default, and try     // to send ETH to the recipient.     // NOTE: This might allow the recipient to attempt a limited reentrancy attack.     (success, ) = _to.call{value: _value, gas: 30000}(""); } /// @notice Sends eth or weth to an address /// @param _to Address to send to /// @param _value Amount to send function _sendEthOrWeth(address _to, uint256 _value) internal {     if (!_attemptETHTransfer(_to, _value)) {         WETH(WETH_ADDRESS).deposit{value: _value}();         WETH(WETH_ADDRESS).transfer(_to, _value);     } } ```  The issue is that the receive could be a contract that does not have a fallback function. In this scenario, \_attemptETHTransfer will fail and WETH would be transferred to the contract. It is likely that it bricks those funds for the contract as there is no reason it would support interaction with WETH tokens.   It can be reasonably assumed that developers will develop contracts which will interact with OptimisticListingSeaport using proposals. They are not warned and are likely to suffer losses.  ## Impact  Loss of ETH for proposer when it is a contract that doesn't have fallback function.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Either enforce that proposer is an EOA or take in a recipient address for ETH transfers.
# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L299-L319   # Vulnerability details  The README states `If two users place bids at the same price but with different quantities, the queue will pull from the bid with a higher quantity first`, but the data-structure used for implementing this logic, is not used properly and essentially has its data corrupted when a large bid that is the current minimum bid, is split into two parts, so that a more favorable price can be used for a fraction of the large bid. The underlying issue is that one of the tree nodes is modified, without re-shuffling that node's location in the tree.  ## Impact The minimum bid as told by the priority queue will be wrong, leading to the wrong bids being allowed to withdraw their funds, and being kicked out of the fraction of bids that are used to buy the NFT.  ## Proof of Concept The priority queue using a binary tree within an array to [efficiently navigate and find the current minimum based on a node and it children](https://algs4.cs.princeton.edu/24pq/). The sorting of the nodes in the tree is based, in part, on the quantity in the case where two bids have the same price: ```solidity // File: src/lib/MinPriorityQueue.sol : MinPriorityQueue.isGreater()   #1  111        function isGreater( 112            Queue storage self, 113            uint256 i, 114            uint256 j 115        ) private view returns (bool) { 116            Bid memory bidI = self.bidIdToBidMap[self.bidIdList[i]]; 117            Bid memory bidJ = self.bidIdToBidMap[self.bidIdList[j]]; 118 @>         if (bidI.price == bidJ.price) { 119 @>             return bidI.quantity <= bidJ.quantity; 120            } 121            return bidI.price > bidJ.price; 122:       } ``` https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol#L111-L122  The algorithm of the binary tree only works when the nodes are properly sorted. The sorting is corrupted when a node is modified, without removing it from the tree and re-inserting it:  ```solidity // File: src/modules/GroupBuy.sol : GroupBuy.processBidsInQueue()   #2  299                Bid storage lowestBid = bidPriorityQueues[_poolId].getMin(); 300                // Breaks out of while loop if given price is less than than lowest bid price 301                if (_price < lowestBid.price) { 302                    break; 303                } 304     305                uint256 lowestBidQuantity = lowestBid.quantity; 306                // Checks if lowest bid quantity amount is greater than given quantity amount 307                if (lowestBidQuantity > quantity) { 308                    // Decrements given quantity amount from lowest bid quantity 309 @>                 lowestBid.quantity -= quantity; 310                    // Calculates partial contribution of bid by quantity amount and price 311                    uint256 contribution = quantity * lowestBid.price; 312     313                    // Decrements partial contribution amount of lowest bid from total and user contributions 314                    totalContributions[_poolId] -= contribution; 315                    userContributions[_poolId][lowestBid.owner] -= contribution; 316                    // Increments pending balance of lowest bid owner 317                    pendingBalances[lowestBid.owner] += contribution; 318     319:                   // Inserts new bid with given quantity amount into proper position of queue ``` https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L299-L319  Let's say that the tree looks like this:  ```             A:(p:100,q:10)             /             \        B:(p:100,q:10)  C:(<whatever>)        /           \ D:(whatever)   E:(whatever)   ```  If A is modified so that q (quantity) goes from 10 to 5, B should now be at the root of the tree, since it has the larger size, and would be considered the smaller node. When another node is added, say, `F:(p:100,q:6)`, the algorithm will see that F has a larger size than A, and so A will be popped out as the min, even though B should have been. All nodes that are under B (which may be a lot of the nodes if they all entered at the same price/quantity) essentially become invisible under various scenarios, which means the users that own those bids will not be able to withdraw their funds, even if they really are the lowest bid that deserves to be pushed out of the queue. Note that the swimming up that is done for `F` will not re-shuffle `B` since, according to the algorithm, `F` will start as a child of `C`, and `B` is not in the list of parent nodes of `C`.   ## Tools Used Code inspection  ## Recommended Mitigation Steps When modifying nodes of the tree, remove them first, then re-add them after modification 
# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L114-L150 https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L301-L303   # Vulnerability details  If a user contributes funds after there is no more supply left, and they don't provide a price higher than the current minimum bid, they will be unable to withdraw their funds while the NFT remains unbought.  ## Impact Ether becomes stuck until and unless the NFT is bought, which may never happen  ## Proof of Concept When making a contribution, the user calls the `payable` `contribute()` function. If the supply has already been filled (`fillAtAnyPriceQuantity` is zero), the bid isn't inserted into the queue, so the new bid is not tracked anywhere. When the function reaches `processBidsInQueue()`...: ```solidity // File: src/modules/GroupBuy.sol : GroupBuy.contribute()   #1  99         function contribute( 100            uint256 _poolId, 101            uint256 _quantity, 102            uint256 _price 103 @>     ) public payable { 104            // Reverts if pool ID is not valid 105            _verifyPool(_poolId); 106            // Reverts if NFT has already been purchased OR termination period has passed 107            (, uint48 totalSupply, , , ) = _verifyUnsuccessfulState(_poolId); 108            // Reverts if ether contribution amount per Rae is less than minimum bid price per Rae 109            if (msg.value < _quantity * minBidPrices[_poolId] || _quantity == 0) 110                revert InvalidContribution(); 111            // Reverts if ether payment amount is not equal to total amount being contributed 112            if (msg.value != _quantity * _price) revert InvalidPayment(); 113     114            // Updates user and pool contribution amounts 115            userContributions[_poolId][msg.sender] += msg.value; 116            totalContributions[_poolId] += msg.value; 117     118            // Calculates remaining supply based on total possible supply and current filled quantity amount 119            uint256 remainingSupply = totalSupply - filledQuantities[_poolId]; 120            // Calculates quantity amount being filled at any price 121            uint256 fillAtAnyPriceQuantity = remainingSupply < _quantity ? remainingSupply : _quantity; 122     123            // Checks if quantity amount being filled is greater than 0 124 @>         if (fillAtAnyPriceQuantity > 0) { 125                // Inserts bid into end of queue 126                bidPriorityQueues[_poolId].insert(msg.sender, _price, fillAtAnyPriceQuantity); 127                // Increments total amount of filled quantities 128                filledQuantities[_poolId] += fillAtAnyPriceQuantity; 129            } 130     131            // Calculates unfilled quantity amount based on desired quantity and actual filled quantity amount 132            uint256 unfilledQuantity = _quantity - fillAtAnyPriceQuantity; 133            // Processes bids in queue to recalculate unfilled quantity amount 134 @>         unfilledQuantity = processBidsInQueue(_poolId, unfilledQuantity, _price); 135     136            // Recalculates filled quantity amount based on updated unfilled quantity amount 137            uint256 filledQuantity = _quantity - unfilledQuantity; 138            // Updates minimum reserve price if filled quantity amount is greater than 0 139            if (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId); 140     141            // Emits event for contributing ether to pool based on desired quantity amount and price per Rae 142            emit Contribute( 143                _poolId, 144                msg.sender, 145                msg.value, 146                _quantity, 147                _price, 148                minReservePrices[_poolId] 149            ); 150:       } ``` https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L99-L150  ...if the price isn't higher than the lowest bid, the while loop is broken out of, with `pendingBalances` having never been updated, and the function does not revert: ```solidity // File: src/modules/GroupBuy.sol : GroupBuy.processBidsInQueue()   #2  291        function processBidsInQueue( 292            uint256 _poolId, 293            uint256 _quantity, 294            uint256 _price 295        ) private returns (uint256 quantity) { 296            quantity = _quantity; 297            while (quantity > 0) { 298                // Retrieves lowest bid in queue 299                Bid storage lowestBid = bidPriorityQueues[_poolId].getMin(); 300                // Breaks out of while loop if given price is less than than lowest bid price 301 @>             if (_price < lowestBid.price) { 302 @>                 break; 303 @>             } 304     305                uint256 lowestBidQuantity = lowestBid.quantity; 306                // Checks if lowest bid quantity amount is greater than given quantity amount 307                if (lowestBidQuantity > quantity) { 308                    // Decrements given quantity amount from lowest bid quantity 309                    lowestBid.quantity -= quantity; 310                    // Calculates partial contribution of bid by quantity amount and price 311                    uint256 contribution = quantity * lowestBid.price; 312     313:                   // Decrements partial contribution amount of lowest bid from total and user contributions ``` https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L291-L313  In order for a user to get funds back, the amount must have been stored in `pendingBalances`, and since this is never done, all funds contributed during the `contribute()` call become property of the `GroupBuy` contract, with the user being unable to withdraw...: ```solidity // File: src/modules/GroupBuy.sol : GroupBuy.withdrawBalance()   #3  274        function withdrawBalance() public { 275            // Reverts if caller balance is insufficient 276 @>         uint256 balance = pendingBalances[msg.sender]; 277 @>         if (balance == 0) revert InsufficientBalance(); 278     279            // Resets pending balance amount 280            delete pendingBalances[msg.sender]; 281     282            // Transfers pending ether balance to caller 283            payable(msg.sender).call{value: balance}(""); 284:       } ``` https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L274-L284  ...until the order has gone through, and they can `claim()` excess funds, but there likely won't be any, due to the separate MEV bug I raised: ```solidity // File: src/modules/GroupBuy.sol : GroupBuy.contribution   #4  228        function claim(uint256 _poolId, bytes32[] calldata _mintProof) external { 229            // Reverts if pool ID is not valid 230            _verifyPool(_poolId); 231            // Reverts if purchase has not been made AND termination period has not passed 232            (, , , bool success, ) = _verifySuccessfulState(_poolId); 233            // Reverts if contribution balance of user is insufficient 234 @>         uint256 contribution = userContributions[_poolId][msg.sender]; 235            if (contribution == 0) revert InsufficientBalance(); 236     237            // Deletes user contribution from storage 238            delete userContributions[_poolId][msg.sender]; ``` https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L228-L244   ## Tools Used Code inspection  ## Recommended Mitigation Steps `revert()` if the price is lower than the min bid, and the queue is already full 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tessera-findings/blob/main/data/IllIllI-Q.md).
# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L112-L116   # Vulnerability details  ## Impact  The only check on a new proposal is that it is priced lower than the existing proposal. It does not constrain on the `_collateral` supplied (except it will revert in _verifyBalance if set to 0). Anyone can block normal proposal creation by creating a proposal with lower price but _collateral == 1. When a high total supply is used, the price of each Rae is negligible and enable an attacker to DOS the protocol.  This violated the `prevent a user from holding a vault hostage and never letting the piece be reasonably bought` requirement.  ## Proof of Concept  For any proposal, an attacker can deny it with _collateral = 1 and _price = price - 1  If he do not want the NFT to be sold, he can reject the proposal himself, reseting the contract state.  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L112-L116  ```solidity         // Reverts if price per token is not lower than both the proposed and active listings         if (             _pricePerToken >= proposedListing.pricePerToken ||             _pricePerToken >= activeListings[_vault].pricePerToken         ) revert NotLower(); ```  Add this test to OptimisticListingSeaport.t.sol:  ```     function testProposeRevertLowerTotalValue() public {         uint256 _collateral = 100;         uint256 _price = 100;         // setup         testPropose(_collateral, _price);         lowerPrice = pricePerToken - 1;         // execute         vm.expectRevert();         _propose(eve, vault, 1, lowerPrice, offer);         // expect         _assertListing(eve, 1, lowerPrice, block.timestamp);         _assertTokenBalance(eve, token, tokenId, eveTokenBalance - 1);     } ``` [FAIL. Reason: Call did not revert as expected]   ## Tools Used  Foundry  ## Recommended Mitigation Steps  Require the total value of the new collateral be greater than the previous. This however still allow a Rae holder with sufficiently large holding to block proposal by creating a new proposal and immediately reject it himself. 
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tessera-findings/blob/main/data/gzeon-G.md).
# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/seaport/modules/OptimisticListingSeaport.sol#L126   # Vulnerability details  ## Impact In `OptimisticListingSeaport.propose`, `pendingBalances` is set to the collateral. The purpose of this is that the proposer of a previous proposal can withdraw his collateral afterwards. However, this is done on the storage variable `proposedListing` after the new listing is already set: ```solidity _setListing(proposedListing, msg.sender, _collateral, _pricePerToken, block.timestamp);  // Sets collateral amount to pending balances for withdrawal pendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral; ``` Because of that, it will actually set `pendingBalances` of the new proposer. Therefore, the old proposer loses his collateral and the new one can make proposals for free.  ## Proof Of Concept ```diff --- a/test/seaport/OptimisticListingSeaport.t.sol +++ b/test/seaport/OptimisticListingSeaport.t.sol @@ -379,8 +379,11 @@ contract OptimisticListingSeaportTest is SeaportTestUtil {      /// ===== LIST =====      /// ================      function testList(uint256 _collateral, uint256 _price) public {          // setup          testPropose(_collateral, _price); +        assertEq(optimistic.pendingBalances(vault, bob), 0);          _increaseTime(PROPOSAL_PERIOD);          _collateral = _boundCollateral(_collateral, bobTokenBalance);          _price = _boundPrice(_price); ``` This test fails and `optimistic.pendingBalances(vault, bob)` is equal to `_collateral`.  ## Recommended Mitigation Steps Run `pendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral;` before the `_setListing` call, in which case the above PoC no longer works.
# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L455 https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L478   # Vulnerability details  ## Impact The functions `_verifyUnsuccessfulState` and `_verifySuccessfulState` should always have a differing behavior with regards to reversion, i.e. when one does not revert, the other should revert. In one condition, this is not true. Namely, when we have `pool.success == false` and `block.timestamp == pool.terminationPeriod`, this check within `_verifyUnsuccessfulState` is `false`: ```solidity if (pool.success || block.timestamp > pool.terminationPeriod) revert InvalidState(); ``` Similarly, this check within `_verifySuccessfulState` is also `false`: ```solidity if (!pool.success && block.timestamp < pool.terminationPeriod) revert InvalidState(); ``` Because this breaks a fundamental invariant of the contract, there are probably multiple ways to exploit it.  One way an attacker can exploit is by calling `claim` (to get his contribution back completely), bidding again with a higher value than his previous contributions (to get his contributions back again).  ## Proof Of Concept Let's assume we are at timestamp `pool.terminationPeriod`. Attacker Charlie has performed the lowest bid with quantity 10 and price 1 ETH. He calls `claim` to get his 10 ETH back. Now, he calls `contribute` with a quantity of 10 and a price of 2 ETH. Because this bid is higher than his previous one (which was the lowest one), his `pendingBalances` is set to 10 ETH (for the deleted entries) and his `userContributions` is set to 20 ETH (for this new contribution). He can now call `claim` again to get back his 20 ETH in `userContributions`, but also the 10 ETH in `pendingBalances`. Like that, he has stolen 10 ETH (and could use this attack pattern to drain the whole contract).  ## Recommended Mitigation Steps Change `<` in `_verifySuccessfulState` to `<=`.
# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L242   # Vulnerability details  ## Impact The `purchase` function does not require that an NFT is bought for exactly `minReservePrices[_poolId] * filledQuantities[_poolId]`, the price is only not allowed to be greater: ```solidity if (_price > minReservePrices[_poolId] * filledQuantities[_poolId])             revert InvalidPurchase(); ``` This makes sense because it is not sensible to pay more when the purchase also succeeds with a smaller amount. However, the logic within `claim` does assume that the NFT was bought for `minReservePrices[_poolId]`. It decreases from `contribution` the quantity times the reserve price for all bids: ```solidity contribution -= quantity * reservePrice; ``` Only the remaining amount is reimbursed to the user, which can lead to a loss of funds.  ## Proof Of Concept Let's say that `filledQuantities[_poolId] = 100` and `minReservePrices[_poolId]` (i.e., the lowest bid) was 1 ETH. However, it was possible to buy the NFT for only 50 ETH. When a user has contributed 20 * 1 ETH, he does not get anything back when calling `claim`, although only 10 ETH (0.5 ETH * 20) of his contributions were used to buy the NFT. The overall loss of funds for all contributors is 50 ETH.  ## Recommended Mitigation Steps Set `minReservePrices[_poolId]` to `_price / filledQuantities[_poolId]` after a purchase.
# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L265 https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L283   # Vulnerability details  ## Impact Both usages of `call` do not check if the transfer of ETH was succesful: ```solidity payable(msg.sender).call{value: contribution}(""); ... payable(msg.sender).call{value: balance}(""); ``` This can become very problematic when the recipient is a smart contract that reverts (for instance, temporarily) in its `receive` function. Then, `GroupBuy` still assumes that this ETH was transferred out and sets the balance to 0 or deletes `userContributions[_poolId][msg.sender]`, although no ETH was transferred. This leads to a loss of funds for the recipient.  ## Proof Of Concept We assume that the recipient is a smart contract that performs some logic in its `receive` function. For instance, it can be a nice feature for some people to automatically convert all incoming ETH into another token using an AMM. However, it can happen that the used AMM has too little liquidity at the moment or the slippage of a swap would be too high, leading to a revert in the receing contract. In such a scenario, the `GroupBuy` contract still thinks that the call was succesful, leading to lost funds for the recipient.  ## Recommended Mitigation Steps `require` that the call was succesful.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tessera-findings/blob/main/data/Lambda-Q.md).
