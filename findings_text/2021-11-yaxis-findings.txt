# Handle  ye0lde   # Vulnerability details  ## Impact  Using existing local variables instead of reading state variables will save gas by converting SLOADs to MLOADs.   ## Proof of Concept  newTransmutationPeriod can be used here instead of TRANSMUTATION_PERIOD : https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Transmuter.sol#L194  TRANSMUTATION_PERIOD is named like a constant when it is actually an updatable state variable.  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Use the local variable instead of the state variable. Rename TRANSMUTATION_PERIOD appropriately.  
# Handle  pauliax   # Vulnerability details  ## Impact Contract Transmuter inherits a functionality of the Context contract of OpenZeppelin: ```solidity   contract Transmuter is Context ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol Context is designed to be used with Ethereum Gas Station Network (GSN), thus it encourages to use _msgSender() instead of msg.sender.  ## Recommended Mitigation Steps Consider replacing msg.sender with _msgSender() or getting rid of Context inheritance to save some gas if you don't actually need it.   
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept `L839-L843` is as follow: ```             AlchemistVault.Data storage _activeVault = _vaults.last();             (uint256 _withdrawAmount, uint256 _decreasedValue) = _activeVault.withdraw(                 _recipient,                 _remainingAmount             ); ``` It can be replaced by following code block, since there is no reason to save it to memory. ```             (uint256 _withdrawAmount, uint256 _decreasedValue) = _vaults.last().withdraw(                 _recipient,                 _remainingAmount             ); ``` ## Tools Used Manual analysis  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept There is no need to cache calculation steps between the return values. `L98-L122` is as follows: ```         uint256 _endingBalance = _token.balanceOf(_recipient);         uint256 _withdrawnAmount = _token.balanceOf(_recipient).sub(_startingBalance);          uint256 _endingTotalValue = _self.totalValue();         uint256 _decreasedValue = _startingTotalValue.sub(_endingTotalValue); ```  Which can be replaced by following code to save gas:  ```         uint256 _withdrawnAmount = _token.balanceOf(_recipient).sub(_startingBalance);          uint256 _decreasedValue = _startingTotalValue.sub(_self.totalValue()); ```  ## Tools Used  Manual analysis  
# Handle  gzeon   # Vulnerability details  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L630 The line can be rewritten as  `_remainingAmount = _remainingAmount.add(_borrowFeeAmount);`  to reduce a storage write. Alternatively use a memory variable to preserve code readability.   
# Handle  xxxxx   # Vulnerability details  ## Impact The unnecessary code can be removed to reduce contract size.  ## Proof of Concept In the contract "Alchemist.sol" the function "_expectCaller" is never used.   ## Tools Used Remix solidity 0.6.12 ## Recommended Mitigation Steps The function "_expectCaller(address _expectedCaller)" can be removed.  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept Current implementation has two if statements, but actually the same logic can be coded with only one if statement. Since `_unclaimedYield == 0` is a special case of `_unclaimedYield < _currentTotalDebt` and does not require any extra code.  ```   function getUpdatedTotalDebt(Data storage _self, Context storage _ctx) internal view returns (uint256) {     uint256 _unclaimedYield = _self.getEarnedYield(_ctx);     uint256 _currentTotalDebt = _self.totalDebt;      if (_unclaimedYield < _currentTotalDebt) {       return _currentTotalDebt - _unclaimedYield;     }     else {       return 0;     }   } ``` ## Tools Used Manual analysis  
# Handle  0x0x0x   # Vulnerability details  ## Concept The current code is: ```   function update(Data storage _self, Context storage _ctx) internal {     uint256 _earnedYield = _self.getEarnedYield(_ctx);     if (_earnedYield > _self.totalDebt) {       uint256 _currentTotalDebt = _self.totalDebt;       _self.totalDebt = 0;       _self.totalCredit = _earnedYield.sub(_currentTotalDebt);     } else {       _self.totalDebt = _self.totalDebt.sub(_earnedYield);     }     _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;   } ``` We cache _self.totalDebt, but it is not required, since we can use it before we change it. This code block can be replaced with: ```   function update(Data storage _self, Context storage _ctx) internal {     uint256 _earnedYield = _self.getEarnedYield(_ctx);     if (_earnedYield > _self.totalDebt) {       _self.totalCredit = _earnedYield.sub(_self.totalDebt);       _self.totalDebt = 0;     } else {       _self.totalDebt = _self.totalDebt.sub(_earnedYield);     }     _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;   } ``` By doing so, we don't cache `_self.totalDebt` just to use it once.  
# Handle  gzeon   # Vulnerability details  ## Impact `onlyAdmin` of YaxisVaultAdapter.sol is only used in `withdraw`, it is advised to inline the function to save some gas without losing readability.   ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L37  
# Handle  cmichel   # Vulnerability details  The `updateAccount` function should capture the latest distributed yield to the Transmuter (stored in `buffer`) and therefore work with the latest `totalDividendPoints` variable. This variable is updated when running a phase distribution with `runPhasedDistribution`.  Unlike all other function that call `updateAccount`, the `unstake` function does not first run a `runPhasedDistribution` modifer to distribute the latest yield.  ## Impact Users that unstake lose out on some yield by not having their alTokens transmuted.  ## Recommended Mitigation Steps Call `runPhasedDistribution` in `unstake` before the `updateAccount` call, as in `stake` or `transmute`.  
# Handle  WatchPug   # Vulnerability details  In `Alchemist.sol#mint()`, when `borrowFee > 0`, `_cdp.totalDebt` will be written 2 times. Combing them into one storage write can save gas.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L611-L645  ```solidity function mint(uint256 _amount)     external     nonReentrant     noContractAllowed     onPriceCheck     expectInitialized {     CDP.Data storage _cdp = _cdps[msg.sender];     _cdp.update(_ctx);      uint256 _totalCredit = _cdp.totalCredit;      if (_totalCredit < _amount) {         uint256 _remainingAmount = _amount.sub(_totalCredit);          if (borrowFee > 0) {             uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(                 PERCENT_RESOLUTION             );             _cdp.totalDebt = _cdp.totalDebt.add(_borrowFeeAmount);             xtoken.mint(rewards, _borrowFeeAmount);         }         _cdp.totalDebt = _cdp.totalDebt.add(_remainingAmount);         _cdp.totalCredit = 0;          _cdp.checkHealth(_ctx, 'Alchemist: Loan-to-value ratio breached');     } else {         _cdp.totalCredit = _totalCredit.sub(_amount);     }      xtoken.mint(msg.sender, _amount);     if (_amount >= flushActivator) {         flushActiveVault();     } } ```  ### Recommendation  Change to:  ```solidity function mint(uint256 _amount)     external     nonReentrant     noContractAllowed     onPriceCheck     expectInitialized {     CDP.Data storage _cdp = _cdps[msg.sender];     _cdp.update(_ctx);      uint256 _totalCredit = _cdp.totalCredit;     uint256 _totalDebt = _cdp.totalDebt;      if (_totalCredit < _amount) {         uint256 _remainingAmount = _amount.sub(_totalCredit);          if (borrowFee > 0) {             uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(                 PERCENT_RESOLUTION             );             _totalDebt = _totalDebt.add(_borrowFeeAmount);             xtoken.mint(rewards, _borrowFeeAmount);         }         _cdp.totalDebt = _totalDebt.add(_remainingAmount);         _cdp.totalCredit = 0;          _cdp.checkHealth(_ctx, 'Alchemist: Loan-to-value ratio breached');     } else {         _cdp.totalCredit = _totalCredit.sub(_amount);     }      xtoken.mint(msg.sender, _amount);     if (_amount >= flushActivator) {         flushActiveVault();     } } ```  
# Handle  WatchPug   # Vulnerability details  Across the functions in `YaxisVaultAdapter.sol`, `vault.getToken()` is called many times, each one will cost a significant amount of gas due to external call.  Given that the result of `vault.getToken()` will never change, create an immutable variable named `token` in the contract and replace `vault.getToken()` with `token` can save gas.  `vault.getLPToken()` is a similar situation, it can also be cached as an immutable variable.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L45-L45  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L70-L70  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L76-L76  
# Handle  WatchPug   # Vulnerability details  The actual token withdrawn from `vault.withdraw()` will most certainly less than the `_amount`, due to precision loss in `_tokensToShares()` and `vault.withdraw()`.  As a result, `IDetailedERC20(_token).safeTransfer(_recipient, _amount)` will revert due to insufficant balance.  Based on the simulation we ran, it will fail `99.99%` of the time unless the pps == 1e18.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L68-L72  ```solidity=68 function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {     vault.withdraw(_tokensToShares(_amount));     address _token = vault.getToken();     IDetailedERC20(_token).safeTransfer(_recipient, _amount); } ```  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/Vault.sol#L181-L187  ```solidity function withdraw(     uint256 _shares )     public     override {     uint256 _amount = (balance().mul(_shares)).div(IERC20(address(vaultToken)).totalSupply()); ```  ### Recommendation  Change to:  ```solidity=68 function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {     address _token = vault.getToken();     uint256 beforeBalance = IDetailedERC20(_token).balanceOf(address(this));          vault.withdraw(_tokensToShares(_amount));      IDetailedERC20(_token).safeTransfer(         _recipient,         IDetailedERC20(_token).balanceOf(address(this)) - beforeBalance     ); } ```  
# Handle  WatchPug   # Vulnerability details  or the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L623-L637  ```solidity=623 if (_totalCredit < _amount) {     uint256 _remainingAmount = _amount.sub(_totalCredit);     // ... } ```  `_amount - _totalCredit` will never underflow.  ### Recommendation  Change to:  ```solidity=623 if (_totalCredit < _amount) {     uint256 _remainingAmount = _amount - _totalCredit;     // ... } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L23-L27  ```solidity=23 /// @dev The vault that the adapter is wrapping.     IVault public vault;      /// @dev The address which has admin control over this contract.     address public admin; ```  `vault` and `admin` will never change, use immutable variable instead of storage variable can save gas.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Transmuter.sol#L55-L56  ```solidity address public AlToken; address public Token; ```  `AlToken` and `Token` can also be changed to `immutable`.  https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L114-L122  ```solidity=114 /// @dev The token that this contract is using as the parent asset. IMintableERC20 public token;  /// @dev The token that this contract is using as the child asset. IMintableERC20 public xtoken; ```  `token` and `xtoken` can also be changed to `immutable`.  ### Recommendation  Change to:  ```solidity /// @dev The vault that the adapter is wrapping. IVault public immutable vault;  /// @dev The address which has admin control over this contract. address public immutable admin;  constructor(IVault _vault, address _admin) public {     vault = _vault;     admin = _admin;     address _token = _vault.getToken();     IDetailedERC20(_token).safeApprove(address(_vault), uint256(-1)); } ```  
# Handle  pmerkleplant   # Vulnerability details  The functions `AlToken::setBlacklist` and `AlToken::pauseAlchemist` in `v3/alchemix` state in their docs: "This function reverts, if the caller does not have the admin role".  However, the functions revert if the caller does not have the **sentinel** role.  See [lines 93-98](https://github.com/code-423n4/2021-11-yaxis/blob/main/contracts/v3/alchemix/AlToken.sol#L93).  
# Handle  0x0x0x   # Vulnerability details  ## Impact The change of `pegMinimum` is crucial for the funcionality of the contract. Users should be informed about the changes. Furthermore, when `pegMinimum` is set to be maximum of `uin256`, functions such as `mint`, `liquidate` and `repay` cannot be used. Therefore, the change of `pegMinimum` should be emitted to create a safe environment for users.   ## Tools Used Manual analysis ## Recommended Mitigation Steps Emit the changes. Furthermore, it would be better if for such a change users get notified beforehand with a mechanism such as Timelock.  
# Handle  0x0x0x   # Vulnerability details  ## Impact `Alchemist.sol#acceptGovernance`(L216-225) is: ```     function acceptGovernance() external {         require(msg.sender == _pendingGovernance, 'sender is not pendingGovernance');         address _pendingGovernance = pendingGovernance;         governance = _pendingGovernance;          emit GovernanceUpdated(_pendingGovernance);     } ``` It can be replaced with following code to save gas: ```     function acceptGovernance() external {         address _pendingGovernance = pendingGovernance;         require(msg.sender == _pendingGovernance, 'sender is not pendingGovernance');         governance = _pendingGovernance;          emit GovernanceUpdated(_pendingGovernance);     } ``` ## Tools Used  Manual analysis  
# Handle  TimmyToes   # Vulnerability details  ## Impact Including unused libraries could potentially use up gas and certainly makes the code more difficult to understand, hindering developer integrations/poor confused security auditors.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L19 https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YearnVaultAdapter.sol#L19 The contract does not use FixedPointMath and compiles with these lines removed.  ## Recommended Mitigation Steps Remove line 10,19 from each contract (FixedPointMath lines). I'd also prefer the removal of  import "hardhat/console.sol"; but this is not having any impact and is just to tidy and shorten the files.  
# Handle  TimmyToes   # Vulnerability details  ## Impact Potential increased financial loss during security incident.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L611 Consider a critical incident where a vault is being drained or in danger of being drained due to a vulnerability within the vault or its strategies. At this stage, you want to trigger emergency exit and users want to withdraw their funds and repay/liquidate to enable the withdrawal of funds. However, minting against debt does not seem like a desirable behaviour at this time. It only seems to enable unaware users to get themselves into trouble by locking up their funds, or allow an attacker to do more damage.  ## Recommended Mitigation Steps Convert emergency exit check to a modifier, award wardens who made that suggestion, and then apply that modifier here.  Alternatively, it is possible that the team might want to allow minting against credit: users minting against credit would effectively be cashing out their rewards. This might be seen as desirable during emergency exit, or it might be seen as a potential extra source of risk. If this is desired, then the emergency exit check could be placed at line 624 with a modified message, instructing users to only use credit.  
# Handle  TimmyToes   # Vulnerability details  ## Impact Gas saving on deployment. Guaranteed consistency, especially if making the same check across multiple functions (and I'm about to suggest that you might want to check this more). Increased functionality of inheriting contracts. Improved readability and code organisation. Basically, every reason that modifiers exist in the first place.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L457 https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L489  ## Tools Used  ## Recommended Mitigation Steps Convert emergency exit check to modifier.   
# Handle  TimmyToes   # Vulnerability details  ## Impact The event emitted is for the updating of a different fee (the harvest fee). This could cause potential issues for any system wishing to integrate with yAxis and wishing to monitor changes to the system and potentially react to them. Such a system could record the wrong harvest  fee and would be unaware of updates to the borrow fee.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L299 Is the same as line 284  ## Recommended Mitigation Steps Create a new event: event BorrowFeeUpdated(uint256 borrowfee); and call it on line 299 instead of HarvestFeeUpdated   
# Handle  TimmyToes   # Vulnerability details  ## Impact Developers wishing to interact with yAxis will find it harder to do so.  ## Proof of Concept Lines 138 of Alchemist.sol /// @dev The percent of each profitable harvest that will go to the rewards contract. This comment is incorrect. The borrow fee is charged on mint against debt, not harvest.  ## Recommended Mitigation Steps Edit the comment.   
# Handle  TimmyToes   # Vulnerability details  ## Impact Developers wishing to interact with yAxis will find it harder to do so.  ## Proof of Concept Lines 157-8 of Alchemist.sol    /// @dev A mapping of all of the user CDPs. If a user wishes to have multiple CDPs they will have to either     /// create a new address or set up a proxy contract that interfaces with this contract. A proxy contract is not an option as most of the functions in the Alchemist contract have a noContractAllowed  modifier.  ## Recommended Mitigation Steps Edit the comment to remove the proxy suggestion.   
# Handle  tqts   # Vulnerability details  ## Impact An event is called without the emit keyword  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L100  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the 'emit' keyword in the event emission.  
# Handle  tqts   # Vulnerability details  ## Impact Double calculation of the same value in mint()  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L69  ## Tools Used Manual review  ## Recommended Mitigation Steps The _total variable in line 66 is defined as _amount + hasMinted(msg.sender). Line 69 needs that value again but recalculates it again instead of using the stored one. Replace line 69 with hasMinted(msg.sender) = _total  
# Handle  tqts   # Vulnerability details  ## Impact Gas saved when a paused user calls mint()  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L68  ## Tools Used Manual review  ## Recommended Mitigation Steps Check for the paused condition before checking for the ceiling condition. If the user is paused, the function reverts earlier, saving gas.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Using existing local variables instead of reading state variables will save gas by converting SLOADs to MLOADs.   ## Proof of Concept  newTransmutationPeriod can be used here instead of TRANSMUTATION_PERIOD : https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Transmuter.sol#L194  TRANSMUTATION_PERIOD is named like a constant when it is actually an updatable state variable.  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Use the local variable instead of the state variable. Rename TRANSMUTATION_PERIOD appropriately.  
# Handle  pauliax   # Vulnerability details  ## Impact Contract Transmuter inherits a functionality of the Context contract of OpenZeppelin: ```solidity   contract Transmuter is Context ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol Context is designed to be used with Ethereum Gas Station Network (GSN), thus it encourages to use _msgSender() instead of msg.sender.  ## Recommended Mitigation Steps Consider replacing msg.sender with _msgSender() or getting rid of Context inheritance to save some gas if you don't actually need it.   
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept `L839-L843` is as follow: ```             AlchemistVault.Data storage _activeVault = _vaults.last();             (uint256 _withdrawAmount, uint256 _decreasedValue) = _activeVault.withdraw(                 _recipient,                 _remainingAmount             ); ``` It can be replaced by following code block, since there is no reason to save it to memory. ```             (uint256 _withdrawAmount, uint256 _decreasedValue) = _vaults.last().withdraw(                 _recipient,                 _remainingAmount             ); ``` ## Tools Used Manual analysis  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept There is no need to cache calculation steps between the return values. `L98-L122` is as follows: ```         uint256 _endingBalance = _token.balanceOf(_recipient);         uint256 _withdrawnAmount = _token.balanceOf(_recipient).sub(_startingBalance);          uint256 _endingTotalValue = _self.totalValue();         uint256 _decreasedValue = _startingTotalValue.sub(_endingTotalValue); ```  Which can be replaced by following code to save gas:  ```         uint256 _withdrawnAmount = _token.balanceOf(_recipient).sub(_startingBalance);          uint256 _decreasedValue = _startingTotalValue.sub(_self.totalValue()); ```  ## Tools Used  Manual analysis  
# Handle  gzeon   # Vulnerability details  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L630 The line can be rewritten as  `_remainingAmount = _remainingAmount.add(_borrowFeeAmount);`  to reduce a storage write. Alternatively use a memory variable to preserve code readability.   
# Handle  xxxxx   # Vulnerability details  ## Impact The unnecessary code can be removed to reduce contract size.  ## Proof of Concept In the contract "Alchemist.sol" the function "_expectCaller" is never used.   ## Tools Used Remix solidity 0.6.12 ## Recommended Mitigation Steps The function "_expectCaller(address _expectedCaller)" can be removed.  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept Current implementation has two if statements, but actually the same logic can be coded with only one if statement. Since `_unclaimedYield == 0` is a special case of `_unclaimedYield < _currentTotalDebt` and does not require any extra code.  ```   function getUpdatedTotalDebt(Data storage _self, Context storage _ctx) internal view returns (uint256) {     uint256 _unclaimedYield = _self.getEarnedYield(_ctx);     uint256 _currentTotalDebt = _self.totalDebt;      if (_unclaimedYield < _currentTotalDebt) {       return _currentTotalDebt - _unclaimedYield;     }     else {       return 0;     }   } ``` ## Tools Used Manual analysis  
# Handle  0x0x0x   # Vulnerability details  ## Concept The current code is: ```   function update(Data storage _self, Context storage _ctx) internal {     uint256 _earnedYield = _self.getEarnedYield(_ctx);     if (_earnedYield > _self.totalDebt) {       uint256 _currentTotalDebt = _self.totalDebt;       _self.totalDebt = 0;       _self.totalCredit = _earnedYield.sub(_currentTotalDebt);     } else {       _self.totalDebt = _self.totalDebt.sub(_earnedYield);     }     _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;   } ``` We cache _self.totalDebt, but it is not required, since we can use it before we change it. This code block can be replaced with: ```   function update(Data storage _self, Context storage _ctx) internal {     uint256 _earnedYield = _self.getEarnedYield(_ctx);     if (_earnedYield > _self.totalDebt) {       _self.totalCredit = _earnedYield.sub(_self.totalDebt);       _self.totalDebt = 0;     } else {       _self.totalDebt = _self.totalDebt.sub(_earnedYield);     }     _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;   } ``` By doing so, we don't cache `_self.totalDebt` just to use it once.  
# Handle  gzeon   # Vulnerability details  ## Impact `onlyAdmin` of YaxisVaultAdapter.sol is only used in `withdraw`, it is advised to inline the function to save some gas without losing readability.   ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L37  
# Handle  cmichel   # Vulnerability details  The `updateAccount` function should capture the latest distributed yield to the Transmuter (stored in `buffer`) and therefore work with the latest `totalDividendPoints` variable. This variable is updated when running a phase distribution with `runPhasedDistribution`.  Unlike all other function that call `updateAccount`, the `unstake` function does not first run a `runPhasedDistribution` modifer to distribute the latest yield.  ## Impact Users that unstake lose out on some yield by not having their alTokens transmuted.  ## Recommended Mitigation Steps Call `runPhasedDistribution` in `unstake` before the `updateAccount` call, as in `stake` or `transmute`.  
# Handle  WatchPug   # Vulnerability details  In `Alchemist.sol#mint()`, when `borrowFee > 0`, `_cdp.totalDebt` will be written 2 times. Combing them into one storage write can save gas.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L611-L645  ```solidity function mint(uint256 _amount)     external     nonReentrant     noContractAllowed     onPriceCheck     expectInitialized {     CDP.Data storage _cdp = _cdps[msg.sender];     _cdp.update(_ctx);      uint256 _totalCredit = _cdp.totalCredit;      if (_totalCredit < _amount) {         uint256 _remainingAmount = _amount.sub(_totalCredit);          if (borrowFee > 0) {             uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(                 PERCENT_RESOLUTION             );             _cdp.totalDebt = _cdp.totalDebt.add(_borrowFeeAmount);             xtoken.mint(rewards, _borrowFeeAmount);         }         _cdp.totalDebt = _cdp.totalDebt.add(_remainingAmount);         _cdp.totalCredit = 0;          _cdp.checkHealth(_ctx, 'Alchemist: Loan-to-value ratio breached');     } else {         _cdp.totalCredit = _totalCredit.sub(_amount);     }      xtoken.mint(msg.sender, _amount);     if (_amount >= flushActivator) {         flushActiveVault();     } } ```  ### Recommendation  Change to:  ```solidity function mint(uint256 _amount)     external     nonReentrant     noContractAllowed     onPriceCheck     expectInitialized {     CDP.Data storage _cdp = _cdps[msg.sender];     _cdp.update(_ctx);      uint256 _totalCredit = _cdp.totalCredit;     uint256 _totalDebt = _cdp.totalDebt;      if (_totalCredit < _amount) {         uint256 _remainingAmount = _amount.sub(_totalCredit);          if (borrowFee > 0) {             uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(                 PERCENT_RESOLUTION             );             _totalDebt = _totalDebt.add(_borrowFeeAmount);             xtoken.mint(rewards, _borrowFeeAmount);         }         _cdp.totalDebt = _totalDebt.add(_remainingAmount);         _cdp.totalCredit = 0;          _cdp.checkHealth(_ctx, 'Alchemist: Loan-to-value ratio breached');     } else {         _cdp.totalCredit = _totalCredit.sub(_amount);     }      xtoken.mint(msg.sender, _amount);     if (_amount >= flushActivator) {         flushActiveVault();     } } ```  
# Handle  WatchPug   # Vulnerability details  Across the functions in `YaxisVaultAdapter.sol`, `vault.getToken()` is called many times, each one will cost a significant amount of gas due to external call.  Given that the result of `vault.getToken()` will never change, create an immutable variable named `token` in the contract and replace `vault.getToken()` with `token` can save gas.  `vault.getLPToken()` is a similar situation, it can also be cached as an immutable variable.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L45-L45  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L70-L70  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L76-L76  
# Handle  WatchPug   # Vulnerability details  The actual token withdrawn from `vault.withdraw()` will most certainly less than the `_amount`, due to precision loss in `_tokensToShares()` and `vault.withdraw()`.  As a result, `IDetailedERC20(_token).safeTransfer(_recipient, _amount)` will revert due to insufficant balance.  Based on the simulation we ran, it will fail `99.99%` of the time unless the pps == 1e18.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L68-L72  ```solidity=68 function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {     vault.withdraw(_tokensToShares(_amount));     address _token = vault.getToken();     IDetailedERC20(_token).safeTransfer(_recipient, _amount); } ```  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/Vault.sol#L181-L187  ```solidity function withdraw(     uint256 _shares )     public     override {     uint256 _amount = (balance().mul(_shares)).div(IERC20(address(vaultToken)).totalSupply()); ```  ### Recommendation  Change to:  ```solidity=68 function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {     address _token = vault.getToken();     uint256 beforeBalance = IDetailedERC20(_token).balanceOf(address(this));          vault.withdraw(_tokensToShares(_amount));      IDetailedERC20(_token).safeTransfer(         _recipient,         IDetailedERC20(_token).balanceOf(address(this)) - beforeBalance     ); } ```  
# Handle  WatchPug   # Vulnerability details  or the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L623-L637  ```solidity=623 if (_totalCredit < _amount) {     uint256 _remainingAmount = _amount.sub(_totalCredit);     // ... } ```  `_amount - _totalCredit` will never underflow.  ### Recommendation  Change to:  ```solidity=623 if (_totalCredit < _amount) {     uint256 _remainingAmount = _amount - _totalCredit;     // ... } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L23-L27  ```solidity=23 /// @dev The vault that the adapter is wrapping.     IVault public vault;      /// @dev The address which has admin control over this contract.     address public admin; ```  `vault` and `admin` will never change, use immutable variable instead of storage variable can save gas.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Transmuter.sol#L55-L56  ```solidity address public AlToken; address public Token; ```  `AlToken` and `Token` can also be changed to `immutable`.  https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L114-L122  ```solidity=114 /// @dev The token that this contract is using as the parent asset. IMintableERC20 public token;  /// @dev The token that this contract is using as the child asset. IMintableERC20 public xtoken; ```  `token` and `xtoken` can also be changed to `immutable`.  ### Recommendation  Change to:  ```solidity /// @dev The vault that the adapter is wrapping. IVault public immutable vault;  /// @dev The address which has admin control over this contract. address public immutable admin;  constructor(IVault _vault, address _admin) public {     vault = _vault;     admin = _admin;     address _token = _vault.getToken();     IDetailedERC20(_token).safeApprove(address(_vault), uint256(-1)); } ```  
# Handle  pmerkleplant   # Vulnerability details  The functions `AlToken::setBlacklist` and `AlToken::pauseAlchemist` in `v3/alchemix` state in their docs: "This function reverts, if the caller does not have the admin role".  However, the functions revert if the caller does not have the **sentinel** role.  See [lines 93-98](https://github.com/code-423n4/2021-11-yaxis/blob/main/contracts/v3/alchemix/AlToken.sol#L93).  
# Handle  0x0x0x   # Vulnerability details  ## Impact The change of `pegMinimum` is crucial for the funcionality of the contract. Users should be informed about the changes. Furthermore, when `pegMinimum` is set to be maximum of `uin256`, functions such as `mint`, `liquidate` and `repay` cannot be used. Therefore, the change of `pegMinimum` should be emitted to create a safe environment for users.   ## Tools Used Manual analysis ## Recommended Mitigation Steps Emit the changes. Furthermore, it would be better if for such a change users get notified beforehand with a mechanism such as Timelock.  
# Handle  0x0x0x   # Vulnerability details  ## Impact `Alchemist.sol#acceptGovernance`(L216-225) is: ```     function acceptGovernance() external {         require(msg.sender == _pendingGovernance, 'sender is not pendingGovernance');         address _pendingGovernance = pendingGovernance;         governance = _pendingGovernance;          emit GovernanceUpdated(_pendingGovernance);     } ``` It can be replaced with following code to save gas: ```     function acceptGovernance() external {         address _pendingGovernance = pendingGovernance;         require(msg.sender == _pendingGovernance, 'sender is not pendingGovernance');         governance = _pendingGovernance;          emit GovernanceUpdated(_pendingGovernance);     } ``` ## Tools Used  Manual analysis  
# Handle  TimmyToes   # Vulnerability details  ## Impact Including unused libraries could potentially use up gas and certainly makes the code more difficult to understand, hindering developer integrations/poor confused security auditors.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L19 https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YearnVaultAdapter.sol#L19 The contract does not use FixedPointMath and compiles with these lines removed.  ## Recommended Mitigation Steps Remove line 10,19 from each contract (FixedPointMath lines). I'd also prefer the removal of  import "hardhat/console.sol"; but this is not having any impact and is just to tidy and shorten the files.  
# Handle  TimmyToes   # Vulnerability details  ## Impact Potential increased financial loss during security incident.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L611 Consider a critical incident where a vault is being drained or in danger of being drained due to a vulnerability within the vault or its strategies. At this stage, you want to trigger emergency exit and users want to withdraw their funds and repay/liquidate to enable the withdrawal of funds. However, minting against debt does not seem like a desirable behaviour at this time. It only seems to enable unaware users to get themselves into trouble by locking up their funds, or allow an attacker to do more damage.  ## Recommended Mitigation Steps Convert emergency exit check to a modifier, award wardens who made that suggestion, and then apply that modifier here.  Alternatively, it is possible that the team might want to allow minting against credit: users minting against credit would effectively be cashing out their rewards. This might be seen as desirable during emergency exit, or it might be seen as a potential extra source of risk. If this is desired, then the emergency exit check could be placed at line 624 with a modified message, instructing users to only use credit.  
# Handle  TimmyToes   # Vulnerability details  ## Impact Gas saving on deployment. Guaranteed consistency, especially if making the same check across multiple functions (and I'm about to suggest that you might want to check this more). Increased functionality of inheriting contracts. Improved readability and code organisation. Basically, every reason that modifiers exist in the first place.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L457 https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L489  ## Tools Used  ## Recommended Mitigation Steps Convert emergency exit check to modifier.   
# Handle  TimmyToes   # Vulnerability details  ## Impact The event emitted is for the updating of a different fee (the harvest fee). This could cause potential issues for any system wishing to integrate with yAxis and wishing to monitor changes to the system and potentially react to them. Such a system could record the wrong harvest  fee and would be unaware of updates to the borrow fee.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L299 Is the same as line 284  ## Recommended Mitigation Steps Create a new event: event BorrowFeeUpdated(uint256 borrowfee); and call it on line 299 instead of HarvestFeeUpdated   
# Handle  TimmyToes   # Vulnerability details  ## Impact Developers wishing to interact with yAxis will find it harder to do so.  ## Proof of Concept Lines 138 of Alchemist.sol /// @dev The percent of each profitable harvest that will go to the rewards contract. This comment is incorrect. The borrow fee is charged on mint against debt, not harvest.  ## Recommended Mitigation Steps Edit the comment.   
# Handle  TimmyToes   # Vulnerability details  ## Impact Developers wishing to interact with yAxis will find it harder to do so.  ## Proof of Concept Lines 157-8 of Alchemist.sol    /// @dev A mapping of all of the user CDPs. If a user wishes to have multiple CDPs they will have to either     /// create a new address or set up a proxy contract that interfaces with this contract. A proxy contract is not an option as most of the functions in the Alchemist contract have a noContractAllowed  modifier.  ## Recommended Mitigation Steps Edit the comment to remove the proxy suggestion.   
# Handle  tqts   # Vulnerability details  ## Impact An event is called without the emit keyword  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L100  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the 'emit' keyword in the event emission.  
# Handle  tqts   # Vulnerability details  ## Impact Double calculation of the same value in mint()  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L69  ## Tools Used Manual review  ## Recommended Mitigation Steps The _total variable in line 66 is defined as _amount + hasMinted(msg.sender). Line 69 needs that value again but recalculates it again instead of using the stored one. Replace line 69 with hasMinted(msg.sender) = _total  
# Handle  tqts   # Vulnerability details  ## Impact Gas saved when a paused user calls mint()  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L68  ## Tools Used Manual review  ## Recommended Mitigation Steps Check for the paused condition before checking for the ceiling condition. If the user is paused, the function reverts earlier, saving gas.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Using existing local variables instead of reading state variables will save gas by converting SLOADs to MLOADs.   ## Proof of Concept  newTransmutationPeriod can be used here instead of TRANSMUTATION_PERIOD : https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Transmuter.sol#L194  TRANSMUTATION_PERIOD is named like a constant when it is actually an updatable state variable.  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Use the local variable instead of the state variable. Rename TRANSMUTATION_PERIOD appropriately.  
# Handle  pauliax   # Vulnerability details  ## Impact Contract Transmuter inherits a functionality of the Context contract of OpenZeppelin: ```solidity   contract Transmuter is Context ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol Context is designed to be used with Ethereum Gas Station Network (GSN), thus it encourages to use _msgSender() instead of msg.sender.  ## Recommended Mitigation Steps Consider replacing msg.sender with _msgSender() or getting rid of Context inheritance to save some gas if you don't actually need it.   
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept `L839-L843` is as follow: ```             AlchemistVault.Data storage _activeVault = _vaults.last();             (uint256 _withdrawAmount, uint256 _decreasedValue) = _activeVault.withdraw(                 _recipient,                 _remainingAmount             ); ``` It can be replaced by following code block, since there is no reason to save it to memory. ```             (uint256 _withdrawAmount, uint256 _decreasedValue) = _vaults.last().withdraw(                 _recipient,                 _remainingAmount             ); ``` ## Tools Used Manual analysis  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept There is no need to cache calculation steps between the return values. `L98-L122` is as follows: ```         uint256 _endingBalance = _token.balanceOf(_recipient);         uint256 _withdrawnAmount = _token.balanceOf(_recipient).sub(_startingBalance);          uint256 _endingTotalValue = _self.totalValue();         uint256 _decreasedValue = _startingTotalValue.sub(_endingTotalValue); ```  Which can be replaced by following code to save gas:  ```         uint256 _withdrawnAmount = _token.balanceOf(_recipient).sub(_startingBalance);          uint256 _decreasedValue = _startingTotalValue.sub(_self.totalValue()); ```  ## Tools Used  Manual analysis  
# Handle  gzeon   # Vulnerability details  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L630 The line can be rewritten as  `_remainingAmount = _remainingAmount.add(_borrowFeeAmount);`  to reduce a storage write. Alternatively use a memory variable to preserve code readability.   
# Handle  xxxxx   # Vulnerability details  ## Impact The unnecessary code can be removed to reduce contract size.  ## Proof of Concept In the contract "Alchemist.sol" the function "_expectCaller" is never used.   ## Tools Used Remix solidity 0.6.12 ## Recommended Mitigation Steps The function "_expectCaller(address _expectedCaller)" can be removed.  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept Current implementation has two if statements, but actually the same logic can be coded with only one if statement. Since `_unclaimedYield == 0` is a special case of `_unclaimedYield < _currentTotalDebt` and does not require any extra code.  ```   function getUpdatedTotalDebt(Data storage _self, Context storage _ctx) internal view returns (uint256) {     uint256 _unclaimedYield = _self.getEarnedYield(_ctx);     uint256 _currentTotalDebt = _self.totalDebt;      if (_unclaimedYield < _currentTotalDebt) {       return _currentTotalDebt - _unclaimedYield;     }     else {       return 0;     }   } ``` ## Tools Used Manual analysis  
# Handle  0x0x0x   # Vulnerability details  ## Concept The current code is: ```   function update(Data storage _self, Context storage _ctx) internal {     uint256 _earnedYield = _self.getEarnedYield(_ctx);     if (_earnedYield > _self.totalDebt) {       uint256 _currentTotalDebt = _self.totalDebt;       _self.totalDebt = 0;       _self.totalCredit = _earnedYield.sub(_currentTotalDebt);     } else {       _self.totalDebt = _self.totalDebt.sub(_earnedYield);     }     _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;   } ``` We cache _self.totalDebt, but it is not required, since we can use it before we change it. This code block can be replaced with: ```   function update(Data storage _self, Context storage _ctx) internal {     uint256 _earnedYield = _self.getEarnedYield(_ctx);     if (_earnedYield > _self.totalDebt) {       _self.totalCredit = _earnedYield.sub(_self.totalDebt);       _self.totalDebt = 0;     } else {       _self.totalDebt = _self.totalDebt.sub(_earnedYield);     }     _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;   } ``` By doing so, we don't cache `_self.totalDebt` just to use it once.  
# Handle  gzeon   # Vulnerability details  ## Impact `onlyAdmin` of YaxisVaultAdapter.sol is only used in `withdraw`, it is advised to inline the function to save some gas without losing readability.   ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L37  
# Handle  cmichel   # Vulnerability details  The `updateAccount` function should capture the latest distributed yield to the Transmuter (stored in `buffer`) and therefore work with the latest `totalDividendPoints` variable. This variable is updated when running a phase distribution with `runPhasedDistribution`.  Unlike all other function that call `updateAccount`, the `unstake` function does not first run a `runPhasedDistribution` modifer to distribute the latest yield.  ## Impact Users that unstake lose out on some yield by not having their alTokens transmuted.  ## Recommended Mitigation Steps Call `runPhasedDistribution` in `unstake` before the `updateAccount` call, as in `stake` or `transmute`.  
# Handle  WatchPug   # Vulnerability details  In `Alchemist.sol#mint()`, when `borrowFee > 0`, `_cdp.totalDebt` will be written 2 times. Combing them into one storage write can save gas.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L611-L645  ```solidity function mint(uint256 _amount)     external     nonReentrant     noContractAllowed     onPriceCheck     expectInitialized {     CDP.Data storage _cdp = _cdps[msg.sender];     _cdp.update(_ctx);      uint256 _totalCredit = _cdp.totalCredit;      if (_totalCredit < _amount) {         uint256 _remainingAmount = _amount.sub(_totalCredit);          if (borrowFee > 0) {             uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(                 PERCENT_RESOLUTION             );             _cdp.totalDebt = _cdp.totalDebt.add(_borrowFeeAmount);             xtoken.mint(rewards, _borrowFeeAmount);         }         _cdp.totalDebt = _cdp.totalDebt.add(_remainingAmount);         _cdp.totalCredit = 0;          _cdp.checkHealth(_ctx, 'Alchemist: Loan-to-value ratio breached');     } else {         _cdp.totalCredit = _totalCredit.sub(_amount);     }      xtoken.mint(msg.sender, _amount);     if (_amount >= flushActivator) {         flushActiveVault();     } } ```  ### Recommendation  Change to:  ```solidity function mint(uint256 _amount)     external     nonReentrant     noContractAllowed     onPriceCheck     expectInitialized {     CDP.Data storage _cdp = _cdps[msg.sender];     _cdp.update(_ctx);      uint256 _totalCredit = _cdp.totalCredit;     uint256 _totalDebt = _cdp.totalDebt;      if (_totalCredit < _amount) {         uint256 _remainingAmount = _amount.sub(_totalCredit);          if (borrowFee > 0) {             uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(                 PERCENT_RESOLUTION             );             _totalDebt = _totalDebt.add(_borrowFeeAmount);             xtoken.mint(rewards, _borrowFeeAmount);         }         _cdp.totalDebt = _totalDebt.add(_remainingAmount);         _cdp.totalCredit = 0;          _cdp.checkHealth(_ctx, 'Alchemist: Loan-to-value ratio breached');     } else {         _cdp.totalCredit = _totalCredit.sub(_amount);     }      xtoken.mint(msg.sender, _amount);     if (_amount >= flushActivator) {         flushActiveVault();     } } ```  
# Handle  WatchPug   # Vulnerability details  Across the functions in `YaxisVaultAdapter.sol`, `vault.getToken()` is called many times, each one will cost a significant amount of gas due to external call.  Given that the result of `vault.getToken()` will never change, create an immutable variable named `token` in the contract and replace `vault.getToken()` with `token` can save gas.  `vault.getLPToken()` is a similar situation, it can also be cached as an immutable variable.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L45-L45  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L70-L70  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L76-L76  
# Handle  WatchPug   # Vulnerability details  The actual token withdrawn from `vault.withdraw()` will most certainly less than the `_amount`, due to precision loss in `_tokensToShares()` and `vault.withdraw()`.  As a result, `IDetailedERC20(_token).safeTransfer(_recipient, _amount)` will revert due to insufficant balance.  Based on the simulation we ran, it will fail `99.99%` of the time unless the pps == 1e18.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L68-L72  ```solidity=68 function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {     vault.withdraw(_tokensToShares(_amount));     address _token = vault.getToken();     IDetailedERC20(_token).safeTransfer(_recipient, _amount); } ```  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/Vault.sol#L181-L187  ```solidity function withdraw(     uint256 _shares )     public     override {     uint256 _amount = (balance().mul(_shares)).div(IERC20(address(vaultToken)).totalSupply()); ```  ### Recommendation  Change to:  ```solidity=68 function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {     address _token = vault.getToken();     uint256 beforeBalance = IDetailedERC20(_token).balanceOf(address(this));          vault.withdraw(_tokensToShares(_amount));      IDetailedERC20(_token).safeTransfer(         _recipient,         IDetailedERC20(_token).balanceOf(address(this)) - beforeBalance     ); } ```  
# Handle  WatchPug   # Vulnerability details  or the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L623-L637  ```solidity=623 if (_totalCredit < _amount) {     uint256 _remainingAmount = _amount.sub(_totalCredit);     // ... } ```  `_amount - _totalCredit` will never underflow.  ### Recommendation  Change to:  ```solidity=623 if (_totalCredit < _amount) {     uint256 _remainingAmount = _amount - _totalCredit;     // ... } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L23-L27  ```solidity=23 /// @dev The vault that the adapter is wrapping.     IVault public vault;      /// @dev The address which has admin control over this contract.     address public admin; ```  `vault` and `admin` will never change, use immutable variable instead of storage variable can save gas.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Transmuter.sol#L55-L56  ```solidity address public AlToken; address public Token; ```  `AlToken` and `Token` can also be changed to `immutable`.  https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L114-L122  ```solidity=114 /// @dev The token that this contract is using as the parent asset. IMintableERC20 public token;  /// @dev The token that this contract is using as the child asset. IMintableERC20 public xtoken; ```  `token` and `xtoken` can also be changed to `immutable`.  ### Recommendation  Change to:  ```solidity /// @dev The vault that the adapter is wrapping. IVault public immutable vault;  /// @dev The address which has admin control over this contract. address public immutable admin;  constructor(IVault _vault, address _admin) public {     vault = _vault;     admin = _admin;     address _token = _vault.getToken();     IDetailedERC20(_token).safeApprove(address(_vault), uint256(-1)); } ```  
# Handle  pmerkleplant   # Vulnerability details  The functions `AlToken::setBlacklist` and `AlToken::pauseAlchemist` in `v3/alchemix` state in their docs: "This function reverts, if the caller does not have the admin role".  However, the functions revert if the caller does not have the **sentinel** role.  See [lines 93-98](https://github.com/code-423n4/2021-11-yaxis/blob/main/contracts/v3/alchemix/AlToken.sol#L93).  
# Handle  0x0x0x   # Vulnerability details  ## Impact The change of `pegMinimum` is crucial for the funcionality of the contract. Users should be informed about the changes. Furthermore, when `pegMinimum` is set to be maximum of `uin256`, functions such as `mint`, `liquidate` and `repay` cannot be used. Therefore, the change of `pegMinimum` should be emitted to create a safe environment for users.   ## Tools Used Manual analysis ## Recommended Mitigation Steps Emit the changes. Furthermore, it would be better if for such a change users get notified beforehand with a mechanism such as Timelock.  
# Handle  0x0x0x   # Vulnerability details  ## Impact `Alchemist.sol#acceptGovernance`(L216-225) is: ```     function acceptGovernance() external {         require(msg.sender == _pendingGovernance, 'sender is not pendingGovernance');         address _pendingGovernance = pendingGovernance;         governance = _pendingGovernance;          emit GovernanceUpdated(_pendingGovernance);     } ``` It can be replaced with following code to save gas: ```     function acceptGovernance() external {         address _pendingGovernance = pendingGovernance;         require(msg.sender == _pendingGovernance, 'sender is not pendingGovernance');         governance = _pendingGovernance;          emit GovernanceUpdated(_pendingGovernance);     } ``` ## Tools Used  Manual analysis  
# Handle  TimmyToes   # Vulnerability details  ## Impact Including unused libraries could potentially use up gas and certainly makes the code more difficult to understand, hindering developer integrations/poor confused security auditors.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L19 https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YearnVaultAdapter.sol#L19 The contract does not use FixedPointMath and compiles with these lines removed.  ## Recommended Mitigation Steps Remove line 10,19 from each contract (FixedPointMath lines). I'd also prefer the removal of  import "hardhat/console.sol"; but this is not having any impact and is just to tidy and shorten the files.  
# Handle  TimmyToes   # Vulnerability details  ## Impact Potential increased financial loss during security incident.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L611 Consider a critical incident where a vault is being drained or in danger of being drained due to a vulnerability within the vault or its strategies. At this stage, you want to trigger emergency exit and users want to withdraw their funds and repay/liquidate to enable the withdrawal of funds. However, minting against debt does not seem like a desirable behaviour at this time. It only seems to enable unaware users to get themselves into trouble by locking up their funds, or allow an attacker to do more damage.  ## Recommended Mitigation Steps Convert emergency exit check to a modifier, award wardens who made that suggestion, and then apply that modifier here.  Alternatively, it is possible that the team might want to allow minting against credit: users minting against credit would effectively be cashing out their rewards. This might be seen as desirable during emergency exit, or it might be seen as a potential extra source of risk. If this is desired, then the emergency exit check could be placed at line 624 with a modified message, instructing users to only use credit.  
# Handle  TimmyToes   # Vulnerability details  ## Impact Gas saving on deployment. Guaranteed consistency, especially if making the same check across multiple functions (and I'm about to suggest that you might want to check this more). Increased functionality of inheriting contracts. Improved readability and code organisation. Basically, every reason that modifiers exist in the first place.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L457 https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L489  ## Tools Used  ## Recommended Mitigation Steps Convert emergency exit check to modifier.   
# Handle  TimmyToes   # Vulnerability details  ## Impact The event emitted is for the updating of a different fee (the harvest fee). This could cause potential issues for any system wishing to integrate with yAxis and wishing to monitor changes to the system and potentially react to them. Such a system could record the wrong harvest  fee and would be unaware of updates to the borrow fee.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L299 Is the same as line 284  ## Recommended Mitigation Steps Create a new event: event BorrowFeeUpdated(uint256 borrowfee); and call it on line 299 instead of HarvestFeeUpdated   
# Handle  TimmyToes   # Vulnerability details  ## Impact Developers wishing to interact with yAxis will find it harder to do so.  ## Proof of Concept Lines 138 of Alchemist.sol /// @dev The percent of each profitable harvest that will go to the rewards contract. This comment is incorrect. The borrow fee is charged on mint against debt, not harvest.  ## Recommended Mitigation Steps Edit the comment.   
# Handle  TimmyToes   # Vulnerability details  ## Impact Developers wishing to interact with yAxis will find it harder to do so.  ## Proof of Concept Lines 157-8 of Alchemist.sol    /// @dev A mapping of all of the user CDPs. If a user wishes to have multiple CDPs they will have to either     /// create a new address or set up a proxy contract that interfaces with this contract. A proxy contract is not an option as most of the functions in the Alchemist contract have a noContractAllowed  modifier.  ## Recommended Mitigation Steps Edit the comment to remove the proxy suggestion.   
# Handle  tqts   # Vulnerability details  ## Impact An event is called without the emit keyword  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L100  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the 'emit' keyword in the event emission.  
# Handle  tqts   # Vulnerability details  ## Impact Double calculation of the same value in mint()  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L69  ## Tools Used Manual review  ## Recommended Mitigation Steps The _total variable in line 66 is defined as _amount + hasMinted(msg.sender). Line 69 needs that value again but recalculates it again instead of using the stored one. Replace line 69 with hasMinted(msg.sender) = _total  
# Handle  tqts   # Vulnerability details  ## Impact Gas saved when a paused user calls mint()  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L68  ## Tools Used Manual review  ## Recommended Mitigation Steps Check for the paused condition before checking for the ceiling condition. If the user is paused, the function reverts earlier, saving gas.  
