# Handle  shw   # Vulnerability details  ## Impact  The `withdrawSingleByLiquidity` function of `LifeGuard3Pool` calls `buoy.singleStableToUsd` to calculate the return USD amount, which internally calls `_stableToUsd` with the `deposit` parameter set to `true`. A more accurate calculation is to set the `deposit` parameter to `false` since this action is a withdrawal. A similar issue exists in the function `calcProtocolWithdraw` of `Allocation`, where the current strategy's USD is calculated by `buoy.singleStableToUsd`.  ## Proof of Concept  Referenced code: [LifeGuard3Pool.sol#L226](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/LifeGuard3Pool.sol#L226) [Buoy3Pool.sol#L122](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L122) [Allocation.sol#L142](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Allocation.sol#L142)  ## Recommended Mitigation Steps  Consider adding a new boolean parameter, `deposit`, to the `singleStableToUsd` function of `Buoy3Pool` to indicate whether the action is a deposit or not, as that in the `stableToUsd` and `stableToLp` functions.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The two `BaseVaultAdaptor.calculateShare` functions computes `share = amount.mul(uint256(10)**decimals).div(sharePrice)`  ```solidity uint256 sharePrice = _getVaultSharePrice(); // amount is in "token" decimals, share should be in "vault" decimals share = amount.mul(uint256(10)**decimals).div(sharePrice); ```  This assumes that the `sharePrice` is always in _token_ decimals and that _token_ decimals is the same as _vault_ decimals.  This both happens to be the case for Yearn vaults, but will not necessarily be the case for other protocols. As this functionality is in the `BaseVaultAdaptor` and not in the specific `VaultAdaptorYearnV2_032`, consider generalizing the conversion.  ## Impact Integrating a token where the token or price is reported in a different precision will lead to potential losses as more shares are computed.  ## Recommended Mitigation Steps The conversion seems highly protocol specific, `calculateShare` should be an abstract function like `_getVaultSharePrice`, that is implemented in the specific adaptors.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The Chainlink API (`latestAnswer`) used in the `Buoy3Pool` oracle wrappers is deprecated:  > This API is deprecated. Please see API Reference for the latest Price Feed API. [Chainlink Docs](https://docs.chain.link/docs/deprecated-aggregatorinterface-api-reference/#latestanswer)  ## Impact It seems like the old API can return stale data. Checks similar to that of the new API using `latestTimestamp` and `latestRoundare` are needed. This could lead to stale prices according to the Chainlink documentation: * [under current notifications: "if answeredInRound < roundId could indicate stale data."](https://docs.chain.link/docs/developer-communications#current-notifications) * [under historical price data: "A timestamp with zero value means the round is not complete and should not be used."](https://docs.chain.link/docs/historical-price-data#solidity)  ## Recommended Mitigation Steps Add the recommended checks: ```solidity (     uint80 roundID,     int256 price,     ,     uint256 timeStamp,     uint80 answeredInRound ) = chainlink.latestRoundData(); require(     timeStamp != 0,     “ChainlinkOracle::getLatestAnswer: round is not complete” ); require(     answeredInRound >= roundID,     “ChainlinkOracle::getLatestAnswer: stale data” ); require(price != 0, "Chainlink Malfunction”); ```  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `safetyCheck` function has several issues that impact how precise the checks are:  1. only checks if the `a/b` and `a/c` ratios are within `BASIS_POINTS`. By transitivity `b/c` is only within `2 * BASIS_POINTS` if `a/b` and `a/c` are in range. For a more precise check whether both USDC and USDT are within range, `b/c` must be checked as well.  2. If `a/b` is within range, this does not imply that `b/a` is within range. > "inverted ratios, a/b bs b/a, while producing different results should both reflect the same change in any one of the two underlying assets, but in opposite directions"  Example: `lastRatio = 1.0` `ratio: a = 1.0, b = 0.8` => `a/b = 1.25`, `b/a = 0.8` If `a/b` was used with a 20% range, it'd be out of range, but `b/a` is in range.  3. The natspec for the function states that it checks Curve and an external oracle, but no external oracle calls are checked, both `_ratio` and `lastRatio` are only from Curve. Only `_updateRatios` checks the oracle.  ## Recommended Mitigation Steps In addition, check if `b/c` is within `BASIS_POINTS`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `Allocaiton.calcProtocolExposureDelta` should break out of the loop to save gas after `protocolExposedDeltaUsd` is set.  ```solidity if (protocolExposedDeltaUsd == 0 && protocolExposure[i] > sysState.rebalanceThreshold) {     // ...Calculate the delta between exposure and target     uint256 target = sysState.rebalanceThreshold.sub(sysState.targetBuffer);     protocolExposedDeltaUsd = protocolExposure[i].sub(target).mul(sysState.totalCurrentAssetsUsd).div(         PERCENTAGE_DECIMAL_FACTOR     );     protocolExposedIndex = i;     // @audit break here } ```  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `WithdrawHandler.withdrawByStablecoin` incorrectly uses the `lpAmount` instead of the `minAmount` in the check.  ```solidity require(lpAmount > 0, "!minAmount"); ```  ## Recommended Mitigation Steps Use `minAmount > 0` if trying to check for `!minAmount` or use a different error message for an invalid LP amount.  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact Detailed description of the impact of this finding. See Constants.sol, where you use 10**DECIMALS: https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/Constants.sol#L7  VS  FixedContracts.sol, where you use 1E6: https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/FixedContracts.sol#L13  While both expressions result in the same values, I recommend picking one to avoid potential confusion     
# Handle  pauliax   # Vulnerability details  ## Impact function setBigFishThreshold should require that _percent is not above PERCENTAGE_DECIMAL_FACTOR if it is not intended to have it over 100%.  ## Recommended Mitigation Steps require _percent <= PERCENTAGE_DECIMAL_FACTOR  
# Handle  pauliax   # Vulnerability details  ## Impact contract LifeGuard3Pool has unused events: LogHealhCheckUpdate, LogNewEmergencyWithdrawal. Interfaces IHarvest and IStake are not used. contract Buoy3Pool has unused variable TIME_LIMIT and a variable that is only initialized but never used: lpToken.  Style issue: BASIS_POINTS all caps indicate it should be a constant, however, an owner can change it by calling function setBasisPointsLmit.  ## Recommended Mitigation Steps Make use of this code or remove it.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The distributeStrategyGainLoss() function distributes any gains or losses generated from a harvest and is expected to be called only by valid protocol vault adaptors. It is an externally visible function and the access control is indirectly enforced on msg.sender by checking that vaultIndexes[msg.sender] is a valid index range 1-4. However the operator used in the require() is || instead of &&, which allows an arbitrary msg.sender, i.e. attacker, to bypass the check.  Scenario: An arbitrary non-vault address calling this function will get an index of 0 because of default mapping value in vaultIndexes[msg.sender] which will fail the > 0 check but pass the <= N_COINS + 1 check (N_COINS = 3) because 0 <= 4 which will allow control to go past this check. Furthermore, on L362, index=0 will underflow the -1 decrement (due to lack of SafeMath.sub and use of < 0.8.0 solc) and index will be set to (uint256_MAX - 1). This will allow execution to proceed to the else part of conditional meant for curve LP vault. Therefore, this will allow any random address to call this function with arbitrary values of gain/loss and distribute arbitrary gain/loss appearing to come from Curve vault.   ## Proof of Concept  The attack control flow: -> Controller.distributeStrategyGainLoss(ARBITRARY_HIGH_VALUE_OF_GAIN, 0) -> index = 0 passes check for the index <= N_COINS + 1 part of predicate on L357 in Controller.sol -> index = uint256_MAX after L362 -> gainUsd = ibuoy.lpToUsd(ARBITRARY_HIGH_VALUE_OF_GAIN); on L371 in Controller.sol -> ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward); on L376 in Controller.sol -> (gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward); on L254 in PnL.sol -> performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR); on L186 of PnL.sol ->  gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus); on L256 in PnL.sol  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L355  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L356-L357  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L362  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L370-L371  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L376  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pnl/PnL.sol#L253-L258  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change || to && in require() on L357 of Controller.sol to prevent arbitrary addresses from going past this check. Or consider explicit access control for the authorized vault adaptors.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  vaultIndexes is uninitialized and it's unclear what 10000 signifies here. investDelta return value is also ignored at call site. If this is an indication of missed/incorrect logic, then it's risky. If not, removing will help readability/maintainability.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L166  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L155  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate any missing logic or else remove unused code.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  BaseVaultAdaptor contains logic that is “built on top of any vault in order for it to function with Gro protocol.” One of such functions is the migrate() function which is onlyOwner and takes an address parameter which allows owner to migrate vault’s entire balance at any time to that address. This is extremely risky because it gives an opportunity for, at least a perception of, rug-pull by a disgruntled/malicious owner/dev to the protocol users/community. This could also be dangerous if triggered accidentally especially by an EOA owner address or maliciously via compromised keys.  Scenario1: Protocol launches and starts accumulating TVL. A savvy user analyzes source and shares the presence of this migrate() function as potential owner rug-pull vector. Users withdraw funds and protocol reputation takes a hit.  Scenario 2: Protocol launches and hits 100MM TVL. A disgruntled dev/owner migrates vault assets to their address and drains the protocol.  Scenario 3: Protocol launches and hits 100MM TVL. Owner EOA keys get compromised and attacker migrates vault assets to their address and drains the protocol.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L294-L302  See similar concern on migrate() functionality in ShibaSwap recently: Yearn dev https://twitter.com/bantg/status/1412370758987354116 https://twitter.com/bantg/status/1412388385663164425 Others https://twitter.com/valentinmihov/status/1412352490918625280 https://twitter.com/shegenerates/status/1412642215537545218   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate the need for this function and avoid/mitigate risk appropriately.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Error strings used in require checks should accurately reflect the failing condition. Use of informative/accurate error messages helps troubleshoot exceptional conditions during transaction failures or unexpected behavior. Otherwise, it can be misleading and waste crucial time during exploits or emergency conditions.   While the codebase has this correct in most places, there are a few places where there appears to be a copy/paste error:  Example 1: require(msg.sender == withdrawHandler || msg.sender == insurance, "depositStable: !depositHandler");  The error string should indicate “!withdrawHandler/insurance” instead of “!depositHandler”  Example 2: require(msg.sender == _controller().insurance(), "withdraw: !withdrawHandler/insurance");  The error string should only indicate “!insurance” instead of “!withdrawHandler/insurance”  ## Proof of Concept  For reference, see Note 2 in OpenZeppelin's Audit of Compound Governor Bravo: https://blog.openzeppelin.com/compound-governor-bravo-audit/  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L206-L211  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L228  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L162  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L285  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L405   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check/fix error strings.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The addSafeAddress()  takes an address and adds it to a “safe list". This is used in eoaOnly() to give exemption to safe addresses that are trusted smart contracts, when all other smart contacts are prevented from protocol interaction. The stated purpose is to allow only such partner/trusted smart contract integrations (project rep mentioned Argent wallet as the only one for now but that may change) an exemption from potential flash loan threats. But if there a safe listed integration that needs to be later disabled, it cannot be done. The protocol will have to rely on other measures (outside the scope of this contest) to prevent flash loan manipulations which are specified as an area of critical concern.  Scenario: A trusted integration/partner address is added to safe list. But that wallet/protocol/DApp is later manipulated (by project, its users or an attacker) to somehow launch a flash loan attack on the protocol. However, its address cannot be removed from the safe list and the protocol cannot prevent flash loan manipulations from that source because of its exemption. Contract/project will have to be redeployed.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L171-L174  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L176-L178  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L266-L272   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change addSafeAddress() to isSafeAddress() with an additional bool parameter to allow both enabling/disabling of safe addresses.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Controller setWithdrawHandler() is missing a zero-address check and event parameter for _emergencyHandler which is the more critical (used rarely but in an emergency incident-response that is always time-critical ) of the two addresses.  Scenario: setWithdrawHandler() is accidentally called with _emergencyHandler = 0 address. Without a check or an event here, this error goes unnoticed (unless caught in the event from WithdrawHandler::setDependencies). There is an emergency triggered after which withdrawals are attempted via the emergencyHandler but they fail because of the zero address. The correct non-zero emergencyHandler has to be set again. Valuable time is lost and funds are lost.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L105-L110  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L129  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L158   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address check and event parameter for _emergencyHandler  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Missing emits for declared events indicate potentially missing logic, redundant declarations or reduced off-chain monitoring capabilities.  Scenario: For example, the event LogFlashSwitchUpdated is missing an emit in Controller. Based on the name, this is presumably related to flash loans being enabled/disabled which could have significant security implications. Or the (misspelled) LogHealhCheckUpdate which is presumably related to a health check logic that is missing in LifeGuard.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L83  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L48  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L61  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L62  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate if logic is missing and add logic+emit or remove event.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The Controller contract is arguably the most critical contract in the project for access control management (it has 17 onlyOwner functions). Given that it is derived from Ownable, the ownership management of this contract (also Whitelist and Controllable) defaults to Ownable’s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  The same applies to the changing of controller’s address in contracts deriving from Controllable using setController().  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the onlyOwner() functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing onlyOwner() function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.   ## Proof of Concept  See similar High Risk severity finding from Trail-of-Bits Audit of Hermez: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  See similar Medium Risk severity finding from Trail-of-Bits Audit of Uniswap V3: https://github.com/Uniswap/uniswap-v3-core/blob/main/audits/tob/audit.pdf  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b9e2c7896d899de9960f2b3d17ca04d5beb79e8a/contracts/access/Ownable.sol#L46-L64  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L38  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L101  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L105  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L112  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L137  And many other onlyOwner functions such as setController():  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/Controllable.sol#L35-L40   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Override the inherited methods to null functions and use separate functions for a two-step address change: 1) Approve a new address as a pendingOwner 2) A transaction from the pendingOwner address claims the pending ownership change. This mitigates risk because if an incorrect address is used in step (1) then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.  Also, consider adding a time-delay for such sensitive actions. And at a minimum, use a multisig owner address and not an EOA.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There is no input validation on _feeToken in constructor to check if it's referring to a valid index (only USDT=2 makes sense) in the stablecoins similar to the check in setFeeToken(), which cannot be done here because the controller variable is only set later in setDependencies(). Also, given that it is set to true and that only USDT has this capability, the constructor should really check if this value is 2 and nothing else.  Also, setFeeToken() should only allow an index of 2 for now.  Scenario: Incorrectly using a _feeToken value other than 2 will cause an unnecessary balance check because of the presumed transfer fees for that token which does not exist.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L56  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L68-L75   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for _feeToken == 2 in constructor or set+check it using setFeeToken() later. Given that it is only USDT which may have fees, consider hardcoding this assumption instead of making it flexible and leaving room for error, because this is not something that applies to DAI or USDC. The entire codebase currently assumes the presence of only these three tokens in the protocol anyway.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The for loop in investSingle() can be removed in favor of simpler logic to calculate k [k = N_COINS - (i + j)], which will save some gas in the deposit flow.   ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L317-L326   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace L317 to L323 with: ``` uint256 inBalance = inAmounts[N_COINS - (i + j)]; if (inBalance > 0) {       _exchange(inBalance, int128(k), int128(i)); } ```  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In LifeGuard3Pool (LG) deposit(), lp token balance is determined for the crv3pool.add_liquidity() call. Given that LG does not hold any lp tokens between txs, there is no need to determine and subtract lp token balance before and after the curve add liquidity call. Removing the call on L204 will save at least 2600+2100=4700 gas from the external call.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L204-L206  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the call on L204 and just get the balance on L206 without any subtraction.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In LG setDependencies(), the code to approve withdrawHandler to pull from lifeguard is repeated twice, once to set it to 0 allowance if the withdrawHandler is != 0 and then unconditionally to set it MAX. Given that this is the only function that sets withdrawHandler, the first set of 0 approvals seem to be redundant given the unconditional approvals that follow. Removing this can save some gas although we don’t expect this to be called often.  The redundant logic could be for the case where the withdrawHandler is updated and the old handler is given an approval of 0 and the new one MAX.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L78-L89   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate code and remove logic if redundant. If this is present to handle withdrawHandler updates then ignore this recommendation.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The investDelta return variable from function getVaultDeltaForDeposit() is ignored at the only call-site in DepositHandler. Removing it can save some gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L144-L152  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L171-L175  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L193   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unused return value or add logic to use it at caller.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The minAmount <= amount check in _prepareForWithdrawalSingle() is an unnecessary check because the same check has already passed in both lg.withdrawSingleByLiquidity and lg.withdrawSingleByExchange. And there is no logic that changes the checked parameters between the earlier checks and this one.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L361  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L224  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L268   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unnecessary check.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  For public functions, the input parameters are copied to memory automatically which costs gas. If a function is only called externally, making its visibility as external will save gas because external function’s parameters are not copied into memory and are instead read from calldata directly. If a function is called only from with that contract or derived contracts, making it internal/private can further reduce gas costs because the expensive calls are converted into cheaper jumps.   ## Proof of Concept  The only callers of eoaOnly() are external contracts DepositHandler and WithdrawHandler. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L268 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L112 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L211 The only caller of calcSystemTargetDelta() is Insurance. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Allocation.sol#L62-L63 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L213 The only caller of calcVaultTargetDelta() is Insurance. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Allocation.sol#L92-L93 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L432 validGTokenDecrease() can be made private just like validGTokenIncrease because it is only called from within Controller. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L448 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L248   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility from public to external/private where possible.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In isValidBigFish(), the calculation of gvt and pard assets by making an external call to PnL.calcPnL() is required only if the amount is >= bigFishAbsoluteThreshold.   Impact: Moving this logic for calculation of `assets` to the else part where it is required will save gas due to the external pnl call (2600 call + 2*2100 SLOADs for state variable reads in calcPnL()) for the sardine flow, where this is not required.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L250-L258  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pnl/PnL.sol#L144-L146   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move logic to else part instead of doing it before the conditional as shown below: ```         if (amount < bigFishAbsoluteThreshold) {             return false;         } else if (amount > assets) {             return true;         } else {             (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();             uint256 assets = pwrdAssets.add(gvtAssets);             return amount > assets.mul(bigFishThreshold).div(PERCENTAGE_DECIMAL_FACTOR);         } ```  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Unnecessary zero-address check for account in addReferral() because it is always msg.sender (can never be 0) in the only call site from DepositHandler::depositGToken(). Removing this check can save a little gas in the critical deposit flow.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L202  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L115  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unnecessary zero-address check.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Moving declarations of state variables that take < 32 Bytes next to each other will allow combining them in the same storage slot and potentially save gas from combined SSTOREs depending on store patterns.  Impact: Moving emergencyState bool right next to preventSmartContracts bool will conserve a storage slot and may save gas.  ## Proof of Concept  See reference: https://mudit.blog/solidity-gas-optimization-tips/ and https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L54  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L44   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Moving declarations of state variables that take < 32 Bytes next to each other. E.g.: booleans next to each other or address types.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The feeToken logic is to account for tokens that may charge transfer fees and therefore require balance checks before/after transfers. For now, the only token that is programmed to potentially do so (in future, not currently) is USDT (neither DAI/USDC have this capability).  Impact: While this flexible future-proof logic is good design, this costs 3 SLOADs = 3*2100 = 6300 gas for reading the state variable feeToken 3 times (different index each time i.e. costs 2100, not 100) while the only token programmed for transfer fees is USDT (which has never charged fees). 2100 gas + two external token balance calls for USDT (2600*2 = 5200 gas + balance gas costs) >= total of 7300 gas for USDT and 4200 gas for other two tokens is perhaps expensive to support this future-proofing logic. However, from a security-perspective, it might be safer to leave this in here for USDT but remove checking for other two.  ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L145-L149  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L163-L167  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate removing it completely or hardcoding logic only for USDT index=2 to save gas.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase. Successive SLOADs cost 100 gas. Memory stores/loads (MSTOREs/MLOADs) cost only 3 gas. Therefore, by caching repeatedly read state variables in local variables within a function, one can save >=100 gas.  ## Proof of Concept  * Caching ctrl address in a local variable will save 300 gas because it is SLOADed 4 times now in this critical deposit flow. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L112 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L115 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L119 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L121  * Caching lg address state variable in a local variable outside the loop can save 1100 gas by avoiding 4 unnecessary SLOADs per loop iteration (4*3 = 12 but one SLOAD is hoisted out of the loop = 11 extra SLOADS at 100 gas = 1100 gas). https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L147-L151  * Caching buoy address state variable in the function beginning can save 100 gas from an extra SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L174-L176  * Caching insurance address in function beginning can save 100 gas from an unnecessary SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L193 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L198  * Caching lg address in function beginning can save 100 gas from an unnecessary SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L197 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L199  * Hoisting buoy state variable out of the loop and caching it in a local variable will save 300 gas from 3 unnecessary SLOADs. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L181  * Caching buoy in a local variable will save 100 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L212 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L219  * Caching ctrl in a local variable at the function beginning and using that in the rest of this function will save 4 unnecessary SLOADs i.e. 400 gas in this function. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L211 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L221 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L226 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L236 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L260 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L264  * Hoisting buoy out of the loop and caching in a local variable will save 3 unnecessary SLOADs and so 300 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L329  * Caching lg in a local variable will save 100 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L356 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L357  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache repeatedly read state variables (especially those within a loop) in local variables at an appropriate part of the function (preferably the beginning) and use them instead of state variables. Converting SLOADs to MLOADs reduces gas from 100 to 3.  
# Handle  a_delamo   # Vulnerability details  ## Impact  The methods `_stableToUsd` and `_stableToLp`  in the`Buoy3Pool.sol` contract is duplicating the array unnecessarily and costing gas to the users.  ``` function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit)     internal     view     returns (uint256)   {     require(tokenAmounts.length == N_COINS, "deposit: !length");     uint256[N_COINS] memory _tokenAmounts;     for (uint256 i = 0; i < N_COINS; i++) {       _tokenAmounts[i] = tokenAmounts[i];     }     uint256 lpAmount = curvePool.calc_token_amount(_tokenAmounts, deposit);     return _lpToUsd(lpAmount);   }    function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit)     internal     view     returns (uint256)   {     require(tokenAmounts.length == N_COINS, "deposit: !length");     uint256[N_COINS] memory _tokenAmounts;     for (uint256 i = 0; i < N_COINS; i++) {       _tokenAmounts[i] = tokenAmounts[i];     }     return curvePool.calc_token_amount(_tokenAmounts, deposit);   } ```  
# Handle  gpersoon   # Vulnerability details  ## Impact The variable BASIS_POINTS in Buoy3Pool.sol is written in capitals, which is the naming convention for constants. However BASIS_POINTS isn't a constant, because it is updated in setBasisPointsLmit This is confusing when reading the code.  ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L30 uint256 public BASIS_POINTS = 20;   function setBasisPointsLmit(uint256 newLimit) external onlyOwner {         uint256 oldLimit = BASIS_POINTS;         BASIS_POINTS = newLimit;         emit LogNewBasisPointLimit(oldLimit, newLimit);     }  ## Tools Used  ## Recommended Mitigation Steps Change BASIS_POINTS  to something like: basisPoints   
# Handle  gpersoon   # Vulnerability details  ## Impact calcProtocolExposureDelta should probably stop executing once it has found the first occurrence where exposure > threshold. (as is also indicated in the comment).  The current code also works (due to the check protocolExposedDeltaUsd == 0), however inserting a break statement at the end of the "if" is more logical and saves a bit of gas.  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Allocation.sol#L286 ///     By defenition, only one protocol can exceed exposure in the current setup. ...  function calcProtocolExposureDelta(uint256[] memory protocolExposure, SystemState memory sysState) private pure        returns (uint256 protocolExposedDeltaUsd, uint256 protocolExposedIndex)     {         for (uint256 i = 0; i < protocolExposure.length; i++) {             // If the exposure is greater than the rebalance threshold...             if (protocolExposedDeltaUsd == 0 && protocolExposure[i] > sysState.rebalanceThreshold) {                 // ...Calculate the delta between exposure and target                 uint256 target = sysState.rebalanceThreshold.sub(sysState.targetBuffer);                 protocolExposedDeltaUsd = protocolExposure[i].sub(target).mul(sysState.totalCurrentAssetsUsd).div(                     PERCENTAGE_DECIMAL_FACTOR                 );                 protocolExposedIndex = i;                     // probably put a break here             }         }     }  ## Tools Used  ## Recommended Mitigation Steps Add a break statement at the end of the if  
# Handle  gpersoon   # Vulnerability details  ## Impact In several functions of BaseVaultAdaptor a value is stored in the variable amount at the end of the function. However this variable is never used afterwards so the storage is unnecessary and just uses gas.  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/vaults/BaseVaultAdaptor.sol#L165     function withdraw(uint256 amount) external override {      ..         if (!_withdrawFromAdapter(amount, msg.sender)) {             amount = _withdraw(calculateShare(amount), msg.sender);      function withdraw(uint256 amount, address recipient) external override {     ...         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdraw(calculateShare(amount), recipient);      function withdrawToAdapter(uint256 amount) external onlyOwner {         amount = _withdraw(calculateShare(amount), address(this));     }      function withdrawByStrategyOrder( ..         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdrawByStrategyOrder(calculateShare(amount), recipient, reversed);      function withdrawByStrategyIndex(    ...         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdrawByStrategyIndex(calculateShare(amount), recipient, strategyIndex);   ## Tools Used  ## Recommended Mitigation Steps Replace   amount = _withdraw***(...); with    _withdraw***(...);  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _stableToUsd and _stableToLp check that the size of the input array is right. However because that parameter definition also contains the length (e.g. [N_COINS] ), it is already checked by solidity.  So checking it again is not necessary. Note: if this would be necessary than it should also be done at the other functions that have an input parameter with  [N_COINS], see at Proof of concept.  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L174     function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {         require(tokenAmounts.length == N_COINS, "deposit: !length");     ...      function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {         require(tokenAmounts.length == N_COINS, "deposit: !length");       ..  Other functions with a [N_COINS] parameter: .\Controller.sol:    function distributeCurveAssets(uint256 amount, uint256[N_COINS] memory delta) external onlyWhitelist { .\DepositHandler.sol:    function _invest(uint256[N_COINS] memory _inAmounts, uint256 roughUsd) internal returns (uint256 dollarAmount) { .\DepositHandler.sol:    function roughUsd(uint256[N_COINS] memory inAmounts) private view returns (uint256 usdAmount) { .\WithdrawHandler.sol:    function withdrawAllBalanced(bool pwrd, uint256[N_COINS] calldata minAmounts) external override { .\insurance\Exposure.sol:    function getUnifiedAssets(address[N_COINS] calldata vaults) .\insurance\Exposure.sol:    function calculateStableCoinExposure(uint256[N_COINS] memory directlyExposure, uint256 curveExposure) .\insurance\Insurance.sol:    function calculateWithdrawalAmountsOnPartVaults(uint256 amount, address[N_COINS] memory vaults) .\insurance\Insurance.sol:    function calculateWithdrawalAmountsOnAllVaults(uint256 amount, address[N_COINS] memory vaults) .\pools\LifeGuard3Pool.sol:    function distributeCurveVault(uint256 amount, uint256[N_COINS] memory delta) .\pools\LifeGuard3Pool.sol:    function invest(uint256 depositAmount, uint256[N_COINS] calldata delta) .\pools\LifeGuard3Pool.sol:    function _withdrawUnbalanced(uint256 inAmount, uint256[N_COINS] memory delta) private { .\pools\oracle\Buoy3Pool.sol:    function stableToUsd(uint256[N_COINS] calldata inAmounts, bool deposit) external view override returns (uint256) { .\pools\oracle\Buoy3Pool.sol:    function stableToLp(uint256[N_COINS] calldata tokenAmounts, bool deposit) external view override returns (uint256) {  ## Tools Used  ## Recommended Mitigation Steps Remove : require(tokenAmounts.length == N_COINS, "deposit: !length");  
# Handle  gpersoon   # Vulnerability details  ## Impact There are several hardcodes values that could very well be replaced with constants. For example: - 10**18 - 5E17 - 10000  - 10**4 - 3 (N_COINS) This will make the code more readable and easier to maintain  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/DepositHandler.sol#L206  function roughUsd(uint256[N_COINS] memory inAmounts) private view returns (uint256 usdAmount) {      ..            usdAmount = usdAmount.add(inAmounts[i].mul(10**18).div(getDecimal(i)));  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/tokens/GToken.sol#L24 abstract contract GToken is GERC20, Constants, Whitelist, IToken {     uint256 public constant BASE = DEFAULT_DECIMALS_FACTOR;   function applyFactor(   ....      if (diff >= 5E17) {  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/vaults/yearnv2/v032/VaultAdaptorYearnV2_032.sol#L107 function updateStrategiesDebtRatio(uint256[] memory ratios) internal override {         ..         require(ratioTotal <= 10**4, "The total of ratios is more than 10000");  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/Controller.sol#L317  function emergency(uint256 coin) external onlyWhitelist { ...        percent = 10000;  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Insurance.sol#L144  function getVaultDeltaForDeposit(uint256 amount) ....   investDelta[vaultIndexes[0]] = 10000;   .\common\StructDefinitions.sol:    uint256[3] vaultCurrentAssets; .\common\StructDefinitions.sol:    uint256[3] vaultCurrentAssetsUsd; .\common\StructDefinitions.sol:    uint256[3] stablePercents; .\common\StructDefinitions.sol:    uint256[3] stablecoinExposure; .\common\StructDefinitions.sol:    uint256[3] protocolWithdrawalUsd; .\common\StructDefinitions.sol:    uint256[3] swapInAmounts; .\common\StructDefinitions.sol:    uint256[3] swapInAmountsUsd; .\common\StructDefinitions.sol:    uint256[3] swapOutPercents; .\common\StructDefinitions.sol:    uint256[3] vaultsTargetUsd; .\interfaces\IBuoy.sol:    function stableToUsd(uint256[3] calldata inAmount, bool deposit) external view returns (uint256); .\interfaces\IBuoy.sol:    function stableToLp(uint256[3] calldata inAmount, bool deposit) external view returns (uint256); .\interfaces\IController.sol:    function stablecoins() external view returns (address[3] memory); .\interfaces\IController.sol:    function vaults() external view returns (address[3] memory); .\interfaces\ICurve.sol:    function calc_token_amount(uint256[3] calldata inAmounts, bool deposit) external view returns (uint256); .\interfaces\ICurve.sol:    function add_liquidity(uint256[3] calldata uamounts, uint256 min_mint_amount) external; .\interfaces\ICurve.sol:    function remove_liquidity(uint256 amount, uint256[3] calldata min_uamounts) external; .\interfaces\ICurve.sol:    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount) external; .\interfaces\IDepositHandler.sol:        uint256[3] calldata inAmounts, .\interfaces\IDepositHandler.sol:        uint256[3] calldata inAmounts, .\interfaces\IExposure.sol:    function getUnifiedAssets(address[3] calldata vaults) .\interfaces\IExposure.sol:        returns (uint256 unifiedTotalAssets, uint256[3] memory unifiedAssets); .\interfaces\IExposure.sol:        uint256[3] calldata unifiedAssets, .\interfaces\IExposure.sol:        uint256[3] calldata targetPercents .\interfaces\IExposure.sol:    ) external pure returns (uint256[3] memory vaultIndexes); .\interfaces\IExposure.sol:        uint256[3] calldata targets, .\interfaces\IExposure.sol:        address[3] calldata vaults, .\interfaces\IExposure.sol:    ) external view returns (uint256[3] memory); .\interfaces\IInsurance.sol:    function calculateDepositDeltasOnAllVaults() external view returns (uint256[3] memory); .\interfaces\IInsurance.sol:    function getDelta(uint256 withdrawUsd) external view returns (uint256[3] memory delta); .\interfaces\IInsurance.sol:            uint256[3] memory, .\interfaces\IInsurance.sol:            uint256[3] memory, .\interfaces\IInsurance.sol:    function sortVaultsByDelta(bool bigFirst) external view returns (uint256[3] memory vaultIndexes); .\interfaces\ILifeGuard.sol:    function getAssets() external view returns (uint256[3] memory); .\interfaces\ILifeGuard.sol:    function distributeCurveVault(uint256 amount, uint256[3] memory delta) external returns (uint256[3] memory); .\interfaces\ILifeGuard.sol:    function invest(uint256 whaleDepositAmount, uint256[3] calldata delta) external returns (uint256 dollarAmount); .\interfaces\ILifeGuard.sol:        uint256[3] calldata inAmounts, .\interfaces\IWithdrawHandler.sol:        uint256[3] calldata minAmounts .\interfaces\IWithdrawHandler.sol:    function withdrawAllBalanced(bool pwrd, uint256[3] calldata minAmounts) external; .\pools\oracle\Buoy3Pool.sol:    function getTokenRatios(uint256 i) private view returns (uint256[3] memory _ratios) { .\pools\oracle\Buoy3Pool.sol:        uint256[3] memory _prices; .\pools\oracle\Buoy3Pool.sol:        for (uint256 j = 0; j < 3; j++) {   ## Tools Used  ## Recommended Mitigation Steps Do the following replacements - 10**18 ==> DEFAULT_DECIMALS_FACTOR - 5E17 ==> DEFAULT_DECIMALS_FACTOR /2 or BASE/2 - 10000 ==> PERCENTAGE_DECIMAL_FACTOR - 10**4 ==> PERCENTAGE_DECIMAL_FACTOR - 3 ==> N_COINS  
# Handle  gpersoon   # Vulnerability details  ## Impact There are a few underflows that are converted via a typecast afterwards to the expected value. If solidity 0.8.x would be used, then the code would revert. int256(a-b)  where a and b are uint, For example if a=1 and b=2 then the intermediate result would be uint(-1) == 2**256-1 int256(-x) where x is a uint. For example if x=1 then the intermediate result would be uint(-1) == 2**256-1 Its better not to have underflows by using the appropriate typecasts. This is especially relevant when moving to solidity 0.8.x  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178 function sortVaultsByDelta(..) ..         for (uint256 i = 0; i < N_COINS; i++) {             // Get difference between vault current assets and vault target             int256 delta = int256(unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)); // underflow in intermediate result  //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pnl/PnL.sol#L112  function decreaseGTokenLastAmount(bool pwrd, uint256 dollarAmount, uint256 bonus)... ..  emit LogNewGtokenChange(pwrd, int256(-dollarAmount)); // underflow in intermediate result  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L87  function safetyCheck() external view override returns (bool) {       ...             _ratio = abs(int256(_ratio - lastRatio[i])); // underflow in intermediate result    ## Tools Used  ## Recommended Mitigation Steps replace int256(a-b) with int256(a)-int256(b) replace int256(-x)   with -int256(x)   
# Handle  gpersoon   # Vulnerability details  ## Impact The function setWithdrawHandler allows the setting of withdrawHandler and emergencyHandler. However emergencyHandler isn't checked for 0 (like the withdrawHandler ) The value of the emergencyHandler is also not emitted (like the withdrawHandler )  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/Controller.sol#L105  function setWithdrawHandler(address _withdrawHandler, address _emergencyHandler) external onlyOwner {         require(_withdrawHandler != address(0), "setWithdrawHandler: 0x");         withdrawHandler = _withdrawHandler;         emergencyHandler = _emergencyHandler;         emit LogNewWithdrawHandler(_withdrawHandler);     }  ## Tools Used  ## Recommended Mitigation Steps Add something like:         require(_emergencyHandler!= address(0), "setEmergencyHandler: 0x");         event LogNewEmergencyHandler(address tokens);         emit LogNewEmergencyHandler(_emergencyHandler);  
# Handle  gpersoon   # Vulnerability details  ## Impact The function sortVaultsByDelta doesn't always work as expected. Suppose all the delta's are positive, and delta1 >= delta2 >= delta3 > 0 Then maxIndex = 0 And (delta < minDelta (==0) ) is never true, so minIndex = 0  Then (assuming bigFirst==true): vaultIndexes[0] = maxIndex = 0 vaultIndexes[2] = minIndex = 0 vaultIndexes[1] = N_COINS - maxIndex - minIndex = 3-0-0 = 3  This is clearly not what is wanted, all vaultIndexes should be different and should be in the range [0..2] This is due to the fact that maxDelta and minDelta are initialized with the value 0. This all could results in withdrawing from the wrong vaults and reverts (because vaultIndexes[1]  is out of range).  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178 function sortVaultsByDelta(bool bigFirst,uint256 unifiedTotalAssets,uint256[N_COINS] calldata unifiedAssets,uint256[N_COINS] calldata targetPercents) external pure override returns (uint256[N_COINS] memory vaultIndexes) {         uint256 maxIndex;         uint256 minIndex;         int256 maxDelta;         int256 minDelta;         for (uint256 i = 0; i < N_COINS; i++) {             // Get difference between vault current assets and vault target             int256 delta = int256(                 unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)             );             // Establish order             if (delta > maxDelta) {                 maxDelta = delta;                 maxIndex = i;             } else if (delta < minDelta) {                 minDelta = delta;                 minIndex = i;             }         }         if (bigFirst) {             vaultIndexes[0] = maxIndex;             vaultIndexes[2] = minIndex;         } else {             vaultIndexes[0] = minIndex;             vaultIndexes[2] = maxIndex;         }         vaultIndexes[1] = N_COINS - maxIndex - minIndex;     }  ## Tools Used  ## Recommended Mitigation Steps Initialize maxDelta and minDelta:         int256 maxDelta = -2**255; // or type(int256).min when using a newer solidity version         int256 minDelta  = 2**255; // or type(int256).max when using a newer solidity version Check maxIndex and minIndex are not the same require (maxIndex != minIndex);  
# Handle  shw   # Vulnerability details  ## Impact  The `withdrawSingleByLiquidity` function of `LifeGuard3Pool` calls `buoy.singleStableToUsd` to calculate the return USD amount, which internally calls `_stableToUsd` with the `deposit` parameter set to `true`. A more accurate calculation is to set the `deposit` parameter to `false` since this action is a withdrawal. A similar issue exists in the function `calcProtocolWithdraw` of `Allocation`, where the current strategy's USD is calculated by `buoy.singleStableToUsd`.  ## Proof of Concept  Referenced code: [LifeGuard3Pool.sol#L226](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/LifeGuard3Pool.sol#L226) [Buoy3Pool.sol#L122](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L122) [Allocation.sol#L142](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Allocation.sol#L142)  ## Recommended Mitigation Steps  Consider adding a new boolean parameter, `deposit`, to the `singleStableToUsd` function of `Buoy3Pool` to indicate whether the action is a deposit or not, as that in the `stableToUsd` and `stableToLp` functions.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The two `BaseVaultAdaptor.calculateShare` functions computes `share = amount.mul(uint256(10)**decimals).div(sharePrice)`  ```solidity uint256 sharePrice = _getVaultSharePrice(); // amount is in "token" decimals, share should be in "vault" decimals share = amount.mul(uint256(10)**decimals).div(sharePrice); ```  This assumes that the `sharePrice` is always in _token_ decimals and that _token_ decimals is the same as _vault_ decimals.  This both happens to be the case for Yearn vaults, but will not necessarily be the case for other protocols. As this functionality is in the `BaseVaultAdaptor` and not in the specific `VaultAdaptorYearnV2_032`, consider generalizing the conversion.  ## Impact Integrating a token where the token or price is reported in a different precision will lead to potential losses as more shares are computed.  ## Recommended Mitigation Steps The conversion seems highly protocol specific, `calculateShare` should be an abstract function like `_getVaultSharePrice`, that is implemented in the specific adaptors.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The Chainlink API (`latestAnswer`) used in the `Buoy3Pool` oracle wrappers is deprecated:  > This API is deprecated. Please see API Reference for the latest Price Feed API. [Chainlink Docs](https://docs.chain.link/docs/deprecated-aggregatorinterface-api-reference/#latestanswer)  ## Impact It seems like the old API can return stale data. Checks similar to that of the new API using `latestTimestamp` and `latestRoundare` are needed. This could lead to stale prices according to the Chainlink documentation: * [under current notifications: "if answeredInRound < roundId could indicate stale data."](https://docs.chain.link/docs/developer-communications#current-notifications) * [under historical price data: "A timestamp with zero value means the round is not complete and should not be used."](https://docs.chain.link/docs/historical-price-data#solidity)  ## Recommended Mitigation Steps Add the recommended checks: ```solidity (     uint80 roundID,     int256 price,     ,     uint256 timeStamp,     uint80 answeredInRound ) = chainlink.latestRoundData(); require(     timeStamp != 0,     “ChainlinkOracle::getLatestAnswer: round is not complete” ); require(     answeredInRound >= roundID,     “ChainlinkOracle::getLatestAnswer: stale data” ); require(price != 0, "Chainlink Malfunction”); ```  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `safetyCheck` function has several issues that impact how precise the checks are:  1. only checks if the `a/b` and `a/c` ratios are within `BASIS_POINTS`. By transitivity `b/c` is only within `2 * BASIS_POINTS` if `a/b` and `a/c` are in range. For a more precise check whether both USDC and USDT are within range, `b/c` must be checked as well.  2. If `a/b` is within range, this does not imply that `b/a` is within range. > "inverted ratios, a/b bs b/a, while producing different results should both reflect the same change in any one of the two underlying assets, but in opposite directions"  Example: `lastRatio = 1.0` `ratio: a = 1.0, b = 0.8` => `a/b = 1.25`, `b/a = 0.8` If `a/b` was used with a 20% range, it'd be out of range, but `b/a` is in range.  3. The natspec for the function states that it checks Curve and an external oracle, but no external oracle calls are checked, both `_ratio` and `lastRatio` are only from Curve. Only `_updateRatios` checks the oracle.  ## Recommended Mitigation Steps In addition, check if `b/c` is within `BASIS_POINTS`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `Allocaiton.calcProtocolExposureDelta` should break out of the loop to save gas after `protocolExposedDeltaUsd` is set.  ```solidity if (protocolExposedDeltaUsd == 0 && protocolExposure[i] > sysState.rebalanceThreshold) {     // ...Calculate the delta between exposure and target     uint256 target = sysState.rebalanceThreshold.sub(sysState.targetBuffer);     protocolExposedDeltaUsd = protocolExposure[i].sub(target).mul(sysState.totalCurrentAssetsUsd).div(         PERCENTAGE_DECIMAL_FACTOR     );     protocolExposedIndex = i;     // @audit break here } ```  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `WithdrawHandler.withdrawByStablecoin` incorrectly uses the `lpAmount` instead of the `minAmount` in the check.  ```solidity require(lpAmount > 0, "!minAmount"); ```  ## Recommended Mitigation Steps Use `minAmount > 0` if trying to check for `!minAmount` or use a different error message for an invalid LP amount.  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact Detailed description of the impact of this finding. See Constants.sol, where you use 10**DECIMALS: https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/Constants.sol#L7  VS  FixedContracts.sol, where you use 1E6: https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/FixedContracts.sol#L13  While both expressions result in the same values, I recommend picking one to avoid potential confusion     
# Handle  pauliax   # Vulnerability details  ## Impact function setBigFishThreshold should require that _percent is not above PERCENTAGE_DECIMAL_FACTOR if it is not intended to have it over 100%.  ## Recommended Mitigation Steps require _percent <= PERCENTAGE_DECIMAL_FACTOR  
# Handle  pauliax   # Vulnerability details  ## Impact contract LifeGuard3Pool has unused events: LogHealhCheckUpdate, LogNewEmergencyWithdrawal. Interfaces IHarvest and IStake are not used. contract Buoy3Pool has unused variable TIME_LIMIT and a variable that is only initialized but never used: lpToken.  Style issue: BASIS_POINTS all caps indicate it should be a constant, however, an owner can change it by calling function setBasisPointsLmit.  ## Recommended Mitigation Steps Make use of this code or remove it.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The distributeStrategyGainLoss() function distributes any gains or losses generated from a harvest and is expected to be called only by valid protocol vault adaptors. It is an externally visible function and the access control is indirectly enforced on msg.sender by checking that vaultIndexes[msg.sender] is a valid index range 1-4. However the operator used in the require() is || instead of &&, which allows an arbitrary msg.sender, i.e. attacker, to bypass the check.  Scenario: An arbitrary non-vault address calling this function will get an index of 0 because of default mapping value in vaultIndexes[msg.sender] which will fail the > 0 check but pass the <= N_COINS + 1 check (N_COINS = 3) because 0 <= 4 which will allow control to go past this check. Furthermore, on L362, index=0 will underflow the -1 decrement (due to lack of SafeMath.sub and use of < 0.8.0 solc) and index will be set to (uint256_MAX - 1). This will allow execution to proceed to the else part of conditional meant for curve LP vault. Therefore, this will allow any random address to call this function with arbitrary values of gain/loss and distribute arbitrary gain/loss appearing to come from Curve vault.   ## Proof of Concept  The attack control flow: -> Controller.distributeStrategyGainLoss(ARBITRARY_HIGH_VALUE_OF_GAIN, 0) -> index = 0 passes check for the index <= N_COINS + 1 part of predicate on L357 in Controller.sol -> index = uint256_MAX after L362 -> gainUsd = ibuoy.lpToUsd(ARBITRARY_HIGH_VALUE_OF_GAIN); on L371 in Controller.sol -> ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward); on L376 in Controller.sol -> (gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward); on L254 in PnL.sol -> performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR); on L186 of PnL.sol ->  gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus); on L256 in PnL.sol  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L355  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L356-L357  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L362  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L370-L371  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L376  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pnl/PnL.sol#L253-L258  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change || to && in require() on L357 of Controller.sol to prevent arbitrary addresses from going past this check. Or consider explicit access control for the authorized vault adaptors.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  vaultIndexes is uninitialized and it's unclear what 10000 signifies here. investDelta return value is also ignored at call site. If this is an indication of missed/incorrect logic, then it's risky. If not, removing will help readability/maintainability.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L166  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L155  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate any missing logic or else remove unused code.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  BaseVaultAdaptor contains logic that is “built on top of any vault in order for it to function with Gro protocol.” One of such functions is the migrate() function which is onlyOwner and takes an address parameter which allows owner to migrate vault’s entire balance at any time to that address. This is extremely risky because it gives an opportunity for, at least a perception of, rug-pull by a disgruntled/malicious owner/dev to the protocol users/community. This could also be dangerous if triggered accidentally especially by an EOA owner address or maliciously via compromised keys.  Scenario1: Protocol launches and starts accumulating TVL. A savvy user analyzes source and shares the presence of this migrate() function as potential owner rug-pull vector. Users withdraw funds and protocol reputation takes a hit.  Scenario 2: Protocol launches and hits 100MM TVL. A disgruntled dev/owner migrates vault assets to their address and drains the protocol.  Scenario 3: Protocol launches and hits 100MM TVL. Owner EOA keys get compromised and attacker migrates vault assets to their address and drains the protocol.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L294-L302  See similar concern on migrate() functionality in ShibaSwap recently: Yearn dev https://twitter.com/bantg/status/1412370758987354116 https://twitter.com/bantg/status/1412388385663164425 Others https://twitter.com/valentinmihov/status/1412352490918625280 https://twitter.com/shegenerates/status/1412642215537545218   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate the need for this function and avoid/mitigate risk appropriately.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Error strings used in require checks should accurately reflect the failing condition. Use of informative/accurate error messages helps troubleshoot exceptional conditions during transaction failures or unexpected behavior. Otherwise, it can be misleading and waste crucial time during exploits or emergency conditions.   While the codebase has this correct in most places, there are a few places where there appears to be a copy/paste error:  Example 1: require(msg.sender == withdrawHandler || msg.sender == insurance, "depositStable: !depositHandler");  The error string should indicate “!withdrawHandler/insurance” instead of “!depositHandler”  Example 2: require(msg.sender == _controller().insurance(), "withdraw: !withdrawHandler/insurance");  The error string should only indicate “!insurance” instead of “!withdrawHandler/insurance”  ## Proof of Concept  For reference, see Note 2 in OpenZeppelin's Audit of Compound Governor Bravo: https://blog.openzeppelin.com/compound-governor-bravo-audit/  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L206-L211  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L228  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L162  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L285  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L405   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check/fix error strings.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The addSafeAddress()  takes an address and adds it to a “safe list". This is used in eoaOnly() to give exemption to safe addresses that are trusted smart contracts, when all other smart contacts are prevented from protocol interaction. The stated purpose is to allow only such partner/trusted smart contract integrations (project rep mentioned Argent wallet as the only one for now but that may change) an exemption from potential flash loan threats. But if there a safe listed integration that needs to be later disabled, it cannot be done. The protocol will have to rely on other measures (outside the scope of this contest) to prevent flash loan manipulations which are specified as an area of critical concern.  Scenario: A trusted integration/partner address is added to safe list. But that wallet/protocol/DApp is later manipulated (by project, its users or an attacker) to somehow launch a flash loan attack on the protocol. However, its address cannot be removed from the safe list and the protocol cannot prevent flash loan manipulations from that source because of its exemption. Contract/project will have to be redeployed.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L171-L174  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L176-L178  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L266-L272   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change addSafeAddress() to isSafeAddress() with an additional bool parameter to allow both enabling/disabling of safe addresses.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Controller setWithdrawHandler() is missing a zero-address check and event parameter for _emergencyHandler which is the more critical (used rarely but in an emergency incident-response that is always time-critical ) of the two addresses.  Scenario: setWithdrawHandler() is accidentally called with _emergencyHandler = 0 address. Without a check or an event here, this error goes unnoticed (unless caught in the event from WithdrawHandler::setDependencies). There is an emergency triggered after which withdrawals are attempted via the emergencyHandler but they fail because of the zero address. The correct non-zero emergencyHandler has to be set again. Valuable time is lost and funds are lost.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L105-L110  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L129  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L158   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address check and event parameter for _emergencyHandler  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Missing emits for declared events indicate potentially missing logic, redundant declarations or reduced off-chain monitoring capabilities.  Scenario: For example, the event LogFlashSwitchUpdated is missing an emit in Controller. Based on the name, this is presumably related to flash loans being enabled/disabled which could have significant security implications. Or the (misspelled) LogHealhCheckUpdate which is presumably related to a health check logic that is missing in LifeGuard.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L83  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L48  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L61  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L62  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate if logic is missing and add logic+emit or remove event.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The Controller contract is arguably the most critical contract in the project for access control management (it has 17 onlyOwner functions). Given that it is derived from Ownable, the ownership management of this contract (also Whitelist and Controllable) defaults to Ownable’s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  The same applies to the changing of controller’s address in contracts deriving from Controllable using setController().  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the onlyOwner() functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing onlyOwner() function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.   ## Proof of Concept  See similar High Risk severity finding from Trail-of-Bits Audit of Hermez: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  See similar Medium Risk severity finding from Trail-of-Bits Audit of Uniswap V3: https://github.com/Uniswap/uniswap-v3-core/blob/main/audits/tob/audit.pdf  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b9e2c7896d899de9960f2b3d17ca04d5beb79e8a/contracts/access/Ownable.sol#L46-L64  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L38  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L101  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L105  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L112  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L137  And many other onlyOwner functions such as setController():  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/Controllable.sol#L35-L40   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Override the inherited methods to null functions and use separate functions for a two-step address change: 1) Approve a new address as a pendingOwner 2) A transaction from the pendingOwner address claims the pending ownership change. This mitigates risk because if an incorrect address is used in step (1) then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.  Also, consider adding a time-delay for such sensitive actions. And at a minimum, use a multisig owner address and not an EOA.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There is no input validation on _feeToken in constructor to check if it's referring to a valid index (only USDT=2 makes sense) in the stablecoins similar to the check in setFeeToken(), which cannot be done here because the controller variable is only set later in setDependencies(). Also, given that it is set to true and that only USDT has this capability, the constructor should really check if this value is 2 and nothing else.  Also, setFeeToken() should only allow an index of 2 for now.  Scenario: Incorrectly using a _feeToken value other than 2 will cause an unnecessary balance check because of the presumed transfer fees for that token which does not exist.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L56  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L68-L75   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for _feeToken == 2 in constructor or set+check it using setFeeToken() later. Given that it is only USDT which may have fees, consider hardcoding this assumption instead of making it flexible and leaving room for error, because this is not something that applies to DAI or USDC. The entire codebase currently assumes the presence of only these three tokens in the protocol anyway.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The for loop in investSingle() can be removed in favor of simpler logic to calculate k [k = N_COINS - (i + j)], which will save some gas in the deposit flow.   ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L317-L326   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace L317 to L323 with: ``` uint256 inBalance = inAmounts[N_COINS - (i + j)]; if (inBalance > 0) {       _exchange(inBalance, int128(k), int128(i)); } ```  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In LifeGuard3Pool (LG) deposit(), lp token balance is determined for the crv3pool.add_liquidity() call. Given that LG does not hold any lp tokens between txs, there is no need to determine and subtract lp token balance before and after the curve add liquidity call. Removing the call on L204 will save at least 2600+2100=4700 gas from the external call.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L204-L206  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the call on L204 and just get the balance on L206 without any subtraction.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In LG setDependencies(), the code to approve withdrawHandler to pull from lifeguard is repeated twice, once to set it to 0 allowance if the withdrawHandler is != 0 and then unconditionally to set it MAX. Given that this is the only function that sets withdrawHandler, the first set of 0 approvals seem to be redundant given the unconditional approvals that follow. Removing this can save some gas although we don’t expect this to be called often.  The redundant logic could be for the case where the withdrawHandler is updated and the old handler is given an approval of 0 and the new one MAX.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L78-L89   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate code and remove logic if redundant. If this is present to handle withdrawHandler updates then ignore this recommendation.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The investDelta return variable from function getVaultDeltaForDeposit() is ignored at the only call-site in DepositHandler. Removing it can save some gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L144-L152  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L171-L175  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L193   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unused return value or add logic to use it at caller.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The minAmount <= amount check in _prepareForWithdrawalSingle() is an unnecessary check because the same check has already passed in both lg.withdrawSingleByLiquidity and lg.withdrawSingleByExchange. And there is no logic that changes the checked parameters between the earlier checks and this one.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L361  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L224  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L268   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unnecessary check.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  For public functions, the input parameters are copied to memory automatically which costs gas. If a function is only called externally, making its visibility as external will save gas because external function’s parameters are not copied into memory and are instead read from calldata directly. If a function is called only from with that contract or derived contracts, making it internal/private can further reduce gas costs because the expensive calls are converted into cheaper jumps.   ## Proof of Concept  The only callers of eoaOnly() are external contracts DepositHandler and WithdrawHandler. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L268 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L112 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L211 The only caller of calcSystemTargetDelta() is Insurance. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Allocation.sol#L62-L63 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L213 The only caller of calcVaultTargetDelta() is Insurance. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Allocation.sol#L92-L93 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L432 validGTokenDecrease() can be made private just like validGTokenIncrease because it is only called from within Controller. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L448 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L248   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility from public to external/private where possible.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In isValidBigFish(), the calculation of gvt and pard assets by making an external call to PnL.calcPnL() is required only if the amount is >= bigFishAbsoluteThreshold.   Impact: Moving this logic for calculation of `assets` to the else part where it is required will save gas due to the external pnl call (2600 call + 2*2100 SLOADs for state variable reads in calcPnL()) for the sardine flow, where this is not required.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L250-L258  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pnl/PnL.sol#L144-L146   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move logic to else part instead of doing it before the conditional as shown below: ```         if (amount < bigFishAbsoluteThreshold) {             return false;         } else if (amount > assets) {             return true;         } else {             (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();             uint256 assets = pwrdAssets.add(gvtAssets);             return amount > assets.mul(bigFishThreshold).div(PERCENTAGE_DECIMAL_FACTOR);         } ```  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Unnecessary zero-address check for account in addReferral() because it is always msg.sender (can never be 0) in the only call site from DepositHandler::depositGToken(). Removing this check can save a little gas in the critical deposit flow.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L202  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L115  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unnecessary zero-address check.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Moving declarations of state variables that take < 32 Bytes next to each other will allow combining them in the same storage slot and potentially save gas from combined SSTOREs depending on store patterns.  Impact: Moving emergencyState bool right next to preventSmartContracts bool will conserve a storage slot and may save gas.  ## Proof of Concept  See reference: https://mudit.blog/solidity-gas-optimization-tips/ and https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L54  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L44   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Moving declarations of state variables that take < 32 Bytes next to each other. E.g.: booleans next to each other or address types.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The feeToken logic is to account for tokens that may charge transfer fees and therefore require balance checks before/after transfers. For now, the only token that is programmed to potentially do so (in future, not currently) is USDT (neither DAI/USDC have this capability).  Impact: While this flexible future-proof logic is good design, this costs 3 SLOADs = 3*2100 = 6300 gas for reading the state variable feeToken 3 times (different index each time i.e. costs 2100, not 100) while the only token programmed for transfer fees is USDT (which has never charged fees). 2100 gas + two external token balance calls for USDT (2600*2 = 5200 gas + balance gas costs) >= total of 7300 gas for USDT and 4200 gas for other two tokens is perhaps expensive to support this future-proofing logic. However, from a security-perspective, it might be safer to leave this in here for USDT but remove checking for other two.  ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L145-L149  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L163-L167  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate removing it completely or hardcoding logic only for USDT index=2 to save gas.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase. Successive SLOADs cost 100 gas. Memory stores/loads (MSTOREs/MLOADs) cost only 3 gas. Therefore, by caching repeatedly read state variables in local variables within a function, one can save >=100 gas.  ## Proof of Concept  * Caching ctrl address in a local variable will save 300 gas because it is SLOADed 4 times now in this critical deposit flow. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L112 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L115 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L119 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L121  * Caching lg address state variable in a local variable outside the loop can save 1100 gas by avoiding 4 unnecessary SLOADs per loop iteration (4*3 = 12 but one SLOAD is hoisted out of the loop = 11 extra SLOADS at 100 gas = 1100 gas). https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L147-L151  * Caching buoy address state variable in the function beginning can save 100 gas from an extra SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L174-L176  * Caching insurance address in function beginning can save 100 gas from an unnecessary SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L193 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L198  * Caching lg address in function beginning can save 100 gas from an unnecessary SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L197 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L199  * Hoisting buoy state variable out of the loop and caching it in a local variable will save 300 gas from 3 unnecessary SLOADs. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L181  * Caching buoy in a local variable will save 100 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L212 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L219  * Caching ctrl in a local variable at the function beginning and using that in the rest of this function will save 4 unnecessary SLOADs i.e. 400 gas in this function. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L211 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L221 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L226 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L236 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L260 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L264  * Hoisting buoy out of the loop and caching in a local variable will save 3 unnecessary SLOADs and so 300 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L329  * Caching lg in a local variable will save 100 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L356 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L357  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache repeatedly read state variables (especially those within a loop) in local variables at an appropriate part of the function (preferably the beginning) and use them instead of state variables. Converting SLOADs to MLOADs reduces gas from 100 to 3.  
# Handle  a_delamo   # Vulnerability details  ## Impact  The methods `_stableToUsd` and `_stableToLp`  in the`Buoy3Pool.sol` contract is duplicating the array unnecessarily and costing gas to the users.  ``` function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit)     internal     view     returns (uint256)   {     require(tokenAmounts.length == N_COINS, "deposit: !length");     uint256[N_COINS] memory _tokenAmounts;     for (uint256 i = 0; i < N_COINS; i++) {       _tokenAmounts[i] = tokenAmounts[i];     }     uint256 lpAmount = curvePool.calc_token_amount(_tokenAmounts, deposit);     return _lpToUsd(lpAmount);   }    function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit)     internal     view     returns (uint256)   {     require(tokenAmounts.length == N_COINS, "deposit: !length");     uint256[N_COINS] memory _tokenAmounts;     for (uint256 i = 0; i < N_COINS; i++) {       _tokenAmounts[i] = tokenAmounts[i];     }     return curvePool.calc_token_amount(_tokenAmounts, deposit);   } ```  
# Handle  gpersoon   # Vulnerability details  ## Impact The variable BASIS_POINTS in Buoy3Pool.sol is written in capitals, which is the naming convention for constants. However BASIS_POINTS isn't a constant, because it is updated in setBasisPointsLmit This is confusing when reading the code.  ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L30 uint256 public BASIS_POINTS = 20;   function setBasisPointsLmit(uint256 newLimit) external onlyOwner {         uint256 oldLimit = BASIS_POINTS;         BASIS_POINTS = newLimit;         emit LogNewBasisPointLimit(oldLimit, newLimit);     }  ## Tools Used  ## Recommended Mitigation Steps Change BASIS_POINTS  to something like: basisPoints   
# Handle  gpersoon   # Vulnerability details  ## Impact calcProtocolExposureDelta should probably stop executing once it has found the first occurrence where exposure > threshold. (as is also indicated in the comment).  The current code also works (due to the check protocolExposedDeltaUsd == 0), however inserting a break statement at the end of the "if" is more logical and saves a bit of gas.  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Allocation.sol#L286 ///     By defenition, only one protocol can exceed exposure in the current setup. ...  function calcProtocolExposureDelta(uint256[] memory protocolExposure, SystemState memory sysState) private pure        returns (uint256 protocolExposedDeltaUsd, uint256 protocolExposedIndex)     {         for (uint256 i = 0; i < protocolExposure.length; i++) {             // If the exposure is greater than the rebalance threshold...             if (protocolExposedDeltaUsd == 0 && protocolExposure[i] > sysState.rebalanceThreshold) {                 // ...Calculate the delta between exposure and target                 uint256 target = sysState.rebalanceThreshold.sub(sysState.targetBuffer);                 protocolExposedDeltaUsd = protocolExposure[i].sub(target).mul(sysState.totalCurrentAssetsUsd).div(                     PERCENTAGE_DECIMAL_FACTOR                 );                 protocolExposedIndex = i;                     // probably put a break here             }         }     }  ## Tools Used  ## Recommended Mitigation Steps Add a break statement at the end of the if  
# Handle  gpersoon   # Vulnerability details  ## Impact In several functions of BaseVaultAdaptor a value is stored in the variable amount at the end of the function. However this variable is never used afterwards so the storage is unnecessary and just uses gas.  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/vaults/BaseVaultAdaptor.sol#L165     function withdraw(uint256 amount) external override {      ..         if (!_withdrawFromAdapter(amount, msg.sender)) {             amount = _withdraw(calculateShare(amount), msg.sender);      function withdraw(uint256 amount, address recipient) external override {     ...         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdraw(calculateShare(amount), recipient);      function withdrawToAdapter(uint256 amount) external onlyOwner {         amount = _withdraw(calculateShare(amount), address(this));     }      function withdrawByStrategyOrder( ..         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdrawByStrategyOrder(calculateShare(amount), recipient, reversed);      function withdrawByStrategyIndex(    ...         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdrawByStrategyIndex(calculateShare(amount), recipient, strategyIndex);   ## Tools Used  ## Recommended Mitigation Steps Replace   amount = _withdraw***(...); with    _withdraw***(...);  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _stableToUsd and _stableToLp check that the size of the input array is right. However because that parameter definition also contains the length (e.g. [N_COINS] ), it is already checked by solidity.  So checking it again is not necessary. Note: if this would be necessary than it should also be done at the other functions that have an input parameter with  [N_COINS], see at Proof of concept.  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L174     function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {         require(tokenAmounts.length == N_COINS, "deposit: !length");     ...      function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {         require(tokenAmounts.length == N_COINS, "deposit: !length");       ..  Other functions with a [N_COINS] parameter: .\Controller.sol:    function distributeCurveAssets(uint256 amount, uint256[N_COINS] memory delta) external onlyWhitelist { .\DepositHandler.sol:    function _invest(uint256[N_COINS] memory _inAmounts, uint256 roughUsd) internal returns (uint256 dollarAmount) { .\DepositHandler.sol:    function roughUsd(uint256[N_COINS] memory inAmounts) private view returns (uint256 usdAmount) { .\WithdrawHandler.sol:    function withdrawAllBalanced(bool pwrd, uint256[N_COINS] calldata minAmounts) external override { .\insurance\Exposure.sol:    function getUnifiedAssets(address[N_COINS] calldata vaults) .\insurance\Exposure.sol:    function calculateStableCoinExposure(uint256[N_COINS] memory directlyExposure, uint256 curveExposure) .\insurance\Insurance.sol:    function calculateWithdrawalAmountsOnPartVaults(uint256 amount, address[N_COINS] memory vaults) .\insurance\Insurance.sol:    function calculateWithdrawalAmountsOnAllVaults(uint256 amount, address[N_COINS] memory vaults) .\pools\LifeGuard3Pool.sol:    function distributeCurveVault(uint256 amount, uint256[N_COINS] memory delta) .\pools\LifeGuard3Pool.sol:    function invest(uint256 depositAmount, uint256[N_COINS] calldata delta) .\pools\LifeGuard3Pool.sol:    function _withdrawUnbalanced(uint256 inAmount, uint256[N_COINS] memory delta) private { .\pools\oracle\Buoy3Pool.sol:    function stableToUsd(uint256[N_COINS] calldata inAmounts, bool deposit) external view override returns (uint256) { .\pools\oracle\Buoy3Pool.sol:    function stableToLp(uint256[N_COINS] calldata tokenAmounts, bool deposit) external view override returns (uint256) {  ## Tools Used  ## Recommended Mitigation Steps Remove : require(tokenAmounts.length == N_COINS, "deposit: !length");  
# Handle  gpersoon   # Vulnerability details  ## Impact There are several hardcodes values that could very well be replaced with constants. For example: - 10**18 - 5E17 - 10000  - 10**4 - 3 (N_COINS) This will make the code more readable and easier to maintain  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/DepositHandler.sol#L206  function roughUsd(uint256[N_COINS] memory inAmounts) private view returns (uint256 usdAmount) {      ..            usdAmount = usdAmount.add(inAmounts[i].mul(10**18).div(getDecimal(i)));  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/tokens/GToken.sol#L24 abstract contract GToken is GERC20, Constants, Whitelist, IToken {     uint256 public constant BASE = DEFAULT_DECIMALS_FACTOR;   function applyFactor(   ....      if (diff >= 5E17) {  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/vaults/yearnv2/v032/VaultAdaptorYearnV2_032.sol#L107 function updateStrategiesDebtRatio(uint256[] memory ratios) internal override {         ..         require(ratioTotal <= 10**4, "The total of ratios is more than 10000");  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/Controller.sol#L317  function emergency(uint256 coin) external onlyWhitelist { ...        percent = 10000;  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Insurance.sol#L144  function getVaultDeltaForDeposit(uint256 amount) ....   investDelta[vaultIndexes[0]] = 10000;   .\common\StructDefinitions.sol:    uint256[3] vaultCurrentAssets; .\common\StructDefinitions.sol:    uint256[3] vaultCurrentAssetsUsd; .\common\StructDefinitions.sol:    uint256[3] stablePercents; .\common\StructDefinitions.sol:    uint256[3] stablecoinExposure; .\common\StructDefinitions.sol:    uint256[3] protocolWithdrawalUsd; .\common\StructDefinitions.sol:    uint256[3] swapInAmounts; .\common\StructDefinitions.sol:    uint256[3] swapInAmountsUsd; .\common\StructDefinitions.sol:    uint256[3] swapOutPercents; .\common\StructDefinitions.sol:    uint256[3] vaultsTargetUsd; .\interfaces\IBuoy.sol:    function stableToUsd(uint256[3] calldata inAmount, bool deposit) external view returns (uint256); .\interfaces\IBuoy.sol:    function stableToLp(uint256[3] calldata inAmount, bool deposit) external view returns (uint256); .\interfaces\IController.sol:    function stablecoins() external view returns (address[3] memory); .\interfaces\IController.sol:    function vaults() external view returns (address[3] memory); .\interfaces\ICurve.sol:    function calc_token_amount(uint256[3] calldata inAmounts, bool deposit) external view returns (uint256); .\interfaces\ICurve.sol:    function add_liquidity(uint256[3] calldata uamounts, uint256 min_mint_amount) external; .\interfaces\ICurve.sol:    function remove_liquidity(uint256 amount, uint256[3] calldata min_uamounts) external; .\interfaces\ICurve.sol:    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount) external; .\interfaces\IDepositHandler.sol:        uint256[3] calldata inAmounts, .\interfaces\IDepositHandler.sol:        uint256[3] calldata inAmounts, .\interfaces\IExposure.sol:    function getUnifiedAssets(address[3] calldata vaults) .\interfaces\IExposure.sol:        returns (uint256 unifiedTotalAssets, uint256[3] memory unifiedAssets); .\interfaces\IExposure.sol:        uint256[3] calldata unifiedAssets, .\interfaces\IExposure.sol:        uint256[3] calldata targetPercents .\interfaces\IExposure.sol:    ) external pure returns (uint256[3] memory vaultIndexes); .\interfaces\IExposure.sol:        uint256[3] calldata targets, .\interfaces\IExposure.sol:        address[3] calldata vaults, .\interfaces\IExposure.sol:    ) external view returns (uint256[3] memory); .\interfaces\IInsurance.sol:    function calculateDepositDeltasOnAllVaults() external view returns (uint256[3] memory); .\interfaces\IInsurance.sol:    function getDelta(uint256 withdrawUsd) external view returns (uint256[3] memory delta); .\interfaces\IInsurance.sol:            uint256[3] memory, .\interfaces\IInsurance.sol:            uint256[3] memory, .\interfaces\IInsurance.sol:    function sortVaultsByDelta(bool bigFirst) external view returns (uint256[3] memory vaultIndexes); .\interfaces\ILifeGuard.sol:    function getAssets() external view returns (uint256[3] memory); .\interfaces\ILifeGuard.sol:    function distributeCurveVault(uint256 amount, uint256[3] memory delta) external returns (uint256[3] memory); .\interfaces\ILifeGuard.sol:    function invest(uint256 whaleDepositAmount, uint256[3] calldata delta) external returns (uint256 dollarAmount); .\interfaces\ILifeGuard.sol:        uint256[3] calldata inAmounts, .\interfaces\IWithdrawHandler.sol:        uint256[3] calldata minAmounts .\interfaces\IWithdrawHandler.sol:    function withdrawAllBalanced(bool pwrd, uint256[3] calldata minAmounts) external; .\pools\oracle\Buoy3Pool.sol:    function getTokenRatios(uint256 i) private view returns (uint256[3] memory _ratios) { .\pools\oracle\Buoy3Pool.sol:        uint256[3] memory _prices; .\pools\oracle\Buoy3Pool.sol:        for (uint256 j = 0; j < 3; j++) {   ## Tools Used  ## Recommended Mitigation Steps Do the following replacements - 10**18 ==> DEFAULT_DECIMALS_FACTOR - 5E17 ==> DEFAULT_DECIMALS_FACTOR /2 or BASE/2 - 10000 ==> PERCENTAGE_DECIMAL_FACTOR - 10**4 ==> PERCENTAGE_DECIMAL_FACTOR - 3 ==> N_COINS  
# Handle  gpersoon   # Vulnerability details  ## Impact There are a few underflows that are converted via a typecast afterwards to the expected value. If solidity 0.8.x would be used, then the code would revert. int256(a-b)  where a and b are uint, For example if a=1 and b=2 then the intermediate result would be uint(-1) == 2**256-1 int256(-x) where x is a uint. For example if x=1 then the intermediate result would be uint(-1) == 2**256-1 Its better not to have underflows by using the appropriate typecasts. This is especially relevant when moving to solidity 0.8.x  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178 function sortVaultsByDelta(..) ..         for (uint256 i = 0; i < N_COINS; i++) {             // Get difference between vault current assets and vault target             int256 delta = int256(unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)); // underflow in intermediate result  //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pnl/PnL.sol#L112  function decreaseGTokenLastAmount(bool pwrd, uint256 dollarAmount, uint256 bonus)... ..  emit LogNewGtokenChange(pwrd, int256(-dollarAmount)); // underflow in intermediate result  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L87  function safetyCheck() external view override returns (bool) {       ...             _ratio = abs(int256(_ratio - lastRatio[i])); // underflow in intermediate result    ## Tools Used  ## Recommended Mitigation Steps replace int256(a-b) with int256(a)-int256(b) replace int256(-x)   with -int256(x)   
# Handle  gpersoon   # Vulnerability details  ## Impact The function setWithdrawHandler allows the setting of withdrawHandler and emergencyHandler. However emergencyHandler isn't checked for 0 (like the withdrawHandler ) The value of the emergencyHandler is also not emitted (like the withdrawHandler )  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/Controller.sol#L105  function setWithdrawHandler(address _withdrawHandler, address _emergencyHandler) external onlyOwner {         require(_withdrawHandler != address(0), "setWithdrawHandler: 0x");         withdrawHandler = _withdrawHandler;         emergencyHandler = _emergencyHandler;         emit LogNewWithdrawHandler(_withdrawHandler);     }  ## Tools Used  ## Recommended Mitigation Steps Add something like:         require(_emergencyHandler!= address(0), "setEmergencyHandler: 0x");         event LogNewEmergencyHandler(address tokens);         emit LogNewEmergencyHandler(_emergencyHandler);  
# Handle  gpersoon   # Vulnerability details  ## Impact The function sortVaultsByDelta doesn't always work as expected. Suppose all the delta's are positive, and delta1 >= delta2 >= delta3 > 0 Then maxIndex = 0 And (delta < minDelta (==0) ) is never true, so minIndex = 0  Then (assuming bigFirst==true): vaultIndexes[0] = maxIndex = 0 vaultIndexes[2] = minIndex = 0 vaultIndexes[1] = N_COINS - maxIndex - minIndex = 3-0-0 = 3  This is clearly not what is wanted, all vaultIndexes should be different and should be in the range [0..2] This is due to the fact that maxDelta and minDelta are initialized with the value 0. This all could results in withdrawing from the wrong vaults and reverts (because vaultIndexes[1]  is out of range).  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178 function sortVaultsByDelta(bool bigFirst,uint256 unifiedTotalAssets,uint256[N_COINS] calldata unifiedAssets,uint256[N_COINS] calldata targetPercents) external pure override returns (uint256[N_COINS] memory vaultIndexes) {         uint256 maxIndex;         uint256 minIndex;         int256 maxDelta;         int256 minDelta;         for (uint256 i = 0; i < N_COINS; i++) {             // Get difference between vault current assets and vault target             int256 delta = int256(                 unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)             );             // Establish order             if (delta > maxDelta) {                 maxDelta = delta;                 maxIndex = i;             } else if (delta < minDelta) {                 minDelta = delta;                 minIndex = i;             }         }         if (bigFirst) {             vaultIndexes[0] = maxIndex;             vaultIndexes[2] = minIndex;         } else {             vaultIndexes[0] = minIndex;             vaultIndexes[2] = maxIndex;         }         vaultIndexes[1] = N_COINS - maxIndex - minIndex;     }  ## Tools Used  ## Recommended Mitigation Steps Initialize maxDelta and minDelta:         int256 maxDelta = -2**255; // or type(int256).min when using a newer solidity version         int256 minDelta  = 2**255; // or type(int256).max when using a newer solidity version Check maxIndex and minIndex are not the same require (maxIndex != minIndex);  
# Handle  shw   # Vulnerability details  ## Impact  The `withdrawSingleByLiquidity` function of `LifeGuard3Pool` calls `buoy.singleStableToUsd` to calculate the return USD amount, which internally calls `_stableToUsd` with the `deposit` parameter set to `true`. A more accurate calculation is to set the `deposit` parameter to `false` since this action is a withdrawal. A similar issue exists in the function `calcProtocolWithdraw` of `Allocation`, where the current strategy's USD is calculated by `buoy.singleStableToUsd`.  ## Proof of Concept  Referenced code: [LifeGuard3Pool.sol#L226](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/LifeGuard3Pool.sol#L226) [Buoy3Pool.sol#L122](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L122) [Allocation.sol#L142](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Allocation.sol#L142)  ## Recommended Mitigation Steps  Consider adding a new boolean parameter, `deposit`, to the `singleStableToUsd` function of `Buoy3Pool` to indicate whether the action is a deposit or not, as that in the `stableToUsd` and `stableToLp` functions.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The two `BaseVaultAdaptor.calculateShare` functions computes `share = amount.mul(uint256(10)**decimals).div(sharePrice)`  ```solidity uint256 sharePrice = _getVaultSharePrice(); // amount is in "token" decimals, share should be in "vault" decimals share = amount.mul(uint256(10)**decimals).div(sharePrice); ```  This assumes that the `sharePrice` is always in _token_ decimals and that _token_ decimals is the same as _vault_ decimals.  This both happens to be the case for Yearn vaults, but will not necessarily be the case for other protocols. As this functionality is in the `BaseVaultAdaptor` and not in the specific `VaultAdaptorYearnV2_032`, consider generalizing the conversion.  ## Impact Integrating a token where the token or price is reported in a different precision will lead to potential losses as more shares are computed.  ## Recommended Mitigation Steps The conversion seems highly protocol specific, `calculateShare` should be an abstract function like `_getVaultSharePrice`, that is implemented in the specific adaptors.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The Chainlink API (`latestAnswer`) used in the `Buoy3Pool` oracle wrappers is deprecated:  > This API is deprecated. Please see API Reference for the latest Price Feed API. [Chainlink Docs](https://docs.chain.link/docs/deprecated-aggregatorinterface-api-reference/#latestanswer)  ## Impact It seems like the old API can return stale data. Checks similar to that of the new API using `latestTimestamp` and `latestRoundare` are needed. This could lead to stale prices according to the Chainlink documentation: * [under current notifications: "if answeredInRound < roundId could indicate stale data."](https://docs.chain.link/docs/developer-communications#current-notifications) * [under historical price data: "A timestamp with zero value means the round is not complete and should not be used."](https://docs.chain.link/docs/historical-price-data#solidity)  ## Recommended Mitigation Steps Add the recommended checks: ```solidity (     uint80 roundID,     int256 price,     ,     uint256 timeStamp,     uint80 answeredInRound ) = chainlink.latestRoundData(); require(     timeStamp != 0,     “ChainlinkOracle::getLatestAnswer: round is not complete” ); require(     answeredInRound >= roundID,     “ChainlinkOracle::getLatestAnswer: stale data” ); require(price != 0, "Chainlink Malfunction”); ```  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `safetyCheck` function has several issues that impact how precise the checks are:  1. only checks if the `a/b` and `a/c` ratios are within `BASIS_POINTS`. By transitivity `b/c` is only within `2 * BASIS_POINTS` if `a/b` and `a/c` are in range. For a more precise check whether both USDC and USDT are within range, `b/c` must be checked as well.  2. If `a/b` is within range, this does not imply that `b/a` is within range. > "inverted ratios, a/b bs b/a, while producing different results should both reflect the same change in any one of the two underlying assets, but in opposite directions"  Example: `lastRatio = 1.0` `ratio: a = 1.0, b = 0.8` => `a/b = 1.25`, `b/a = 0.8` If `a/b` was used with a 20% range, it'd be out of range, but `b/a` is in range.  3. The natspec for the function states that it checks Curve and an external oracle, but no external oracle calls are checked, both `_ratio` and `lastRatio` are only from Curve. Only `_updateRatios` checks the oracle.  ## Recommended Mitigation Steps In addition, check if `b/c` is within `BASIS_POINTS`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `Allocaiton.calcProtocolExposureDelta` should break out of the loop to save gas after `protocolExposedDeltaUsd` is set.  ```solidity if (protocolExposedDeltaUsd == 0 && protocolExposure[i] > sysState.rebalanceThreshold) {     // ...Calculate the delta between exposure and target     uint256 target = sysState.rebalanceThreshold.sub(sysState.targetBuffer);     protocolExposedDeltaUsd = protocolExposure[i].sub(target).mul(sysState.totalCurrentAssetsUsd).div(         PERCENTAGE_DECIMAL_FACTOR     );     protocolExposedIndex = i;     // @audit break here } ```  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `WithdrawHandler.withdrawByStablecoin` incorrectly uses the `lpAmount` instead of the `minAmount` in the check.  ```solidity require(lpAmount > 0, "!minAmount"); ```  ## Recommended Mitigation Steps Use `minAmount > 0` if trying to check for `!minAmount` or use a different error message for an invalid LP amount.  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact Detailed description of the impact of this finding. See Constants.sol, where you use 10**DECIMALS: https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/Constants.sol#L7  VS  FixedContracts.sol, where you use 1E6: https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/FixedContracts.sol#L13  While both expressions result in the same values, I recommend picking one to avoid potential confusion     
# Handle  pauliax   # Vulnerability details  ## Impact function setBigFishThreshold should require that _percent is not above PERCENTAGE_DECIMAL_FACTOR if it is not intended to have it over 100%.  ## Recommended Mitigation Steps require _percent <= PERCENTAGE_DECIMAL_FACTOR  
# Handle  pauliax   # Vulnerability details  ## Impact contract LifeGuard3Pool has unused events: LogHealhCheckUpdate, LogNewEmergencyWithdrawal. Interfaces IHarvest and IStake are not used. contract Buoy3Pool has unused variable TIME_LIMIT and a variable that is only initialized but never used: lpToken.  Style issue: BASIS_POINTS all caps indicate it should be a constant, however, an owner can change it by calling function setBasisPointsLmit.  ## Recommended Mitigation Steps Make use of this code or remove it.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The distributeStrategyGainLoss() function distributes any gains or losses generated from a harvest and is expected to be called only by valid protocol vault adaptors. It is an externally visible function and the access control is indirectly enforced on msg.sender by checking that vaultIndexes[msg.sender] is a valid index range 1-4. However the operator used in the require() is || instead of &&, which allows an arbitrary msg.sender, i.e. attacker, to bypass the check.  Scenario: An arbitrary non-vault address calling this function will get an index of 0 because of default mapping value in vaultIndexes[msg.sender] which will fail the > 0 check but pass the <= N_COINS + 1 check (N_COINS = 3) because 0 <= 4 which will allow control to go past this check. Furthermore, on L362, index=0 will underflow the -1 decrement (due to lack of SafeMath.sub and use of < 0.8.0 solc) and index will be set to (uint256_MAX - 1). This will allow execution to proceed to the else part of conditional meant for curve LP vault. Therefore, this will allow any random address to call this function with arbitrary values of gain/loss and distribute arbitrary gain/loss appearing to come from Curve vault.   ## Proof of Concept  The attack control flow: -> Controller.distributeStrategyGainLoss(ARBITRARY_HIGH_VALUE_OF_GAIN, 0) -> index = 0 passes check for the index <= N_COINS + 1 part of predicate on L357 in Controller.sol -> index = uint256_MAX after L362 -> gainUsd = ibuoy.lpToUsd(ARBITRARY_HIGH_VALUE_OF_GAIN); on L371 in Controller.sol -> ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward); on L376 in Controller.sol -> (gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward); on L254 in PnL.sol -> performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR); on L186 of PnL.sol ->  gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus); on L256 in PnL.sol  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L355  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L356-L357  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L362  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L370-L371  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L376  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pnl/PnL.sol#L253-L258  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change || to && in require() on L357 of Controller.sol to prevent arbitrary addresses from going past this check. Or consider explicit access control for the authorized vault adaptors.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  vaultIndexes is uninitialized and it's unclear what 10000 signifies here. investDelta return value is also ignored at call site. If this is an indication of missed/incorrect logic, then it's risky. If not, removing will help readability/maintainability.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L166  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L155  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate any missing logic or else remove unused code.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  BaseVaultAdaptor contains logic that is “built on top of any vault in order for it to function with Gro protocol.” One of such functions is the migrate() function which is onlyOwner and takes an address parameter which allows owner to migrate vault’s entire balance at any time to that address. This is extremely risky because it gives an opportunity for, at least a perception of, rug-pull by a disgruntled/malicious owner/dev to the protocol users/community. This could also be dangerous if triggered accidentally especially by an EOA owner address or maliciously via compromised keys.  Scenario1: Protocol launches and starts accumulating TVL. A savvy user analyzes source and shares the presence of this migrate() function as potential owner rug-pull vector. Users withdraw funds and protocol reputation takes a hit.  Scenario 2: Protocol launches and hits 100MM TVL. A disgruntled dev/owner migrates vault assets to their address and drains the protocol.  Scenario 3: Protocol launches and hits 100MM TVL. Owner EOA keys get compromised and attacker migrates vault assets to their address and drains the protocol.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L294-L302  See similar concern on migrate() functionality in ShibaSwap recently: Yearn dev https://twitter.com/bantg/status/1412370758987354116 https://twitter.com/bantg/status/1412388385663164425 Others https://twitter.com/valentinmihov/status/1412352490918625280 https://twitter.com/shegenerates/status/1412642215537545218   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate the need for this function and avoid/mitigate risk appropriately.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Error strings used in require checks should accurately reflect the failing condition. Use of informative/accurate error messages helps troubleshoot exceptional conditions during transaction failures or unexpected behavior. Otherwise, it can be misleading and waste crucial time during exploits or emergency conditions.   While the codebase has this correct in most places, there are a few places where there appears to be a copy/paste error:  Example 1: require(msg.sender == withdrawHandler || msg.sender == insurance, "depositStable: !depositHandler");  The error string should indicate “!withdrawHandler/insurance” instead of “!depositHandler”  Example 2: require(msg.sender == _controller().insurance(), "withdraw: !withdrawHandler/insurance");  The error string should only indicate “!insurance” instead of “!withdrawHandler/insurance”  ## Proof of Concept  For reference, see Note 2 in OpenZeppelin's Audit of Compound Governor Bravo: https://blog.openzeppelin.com/compound-governor-bravo-audit/  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L206-L211  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L228  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L162  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L285  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L405   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check/fix error strings.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The addSafeAddress()  takes an address and adds it to a “safe list". This is used in eoaOnly() to give exemption to safe addresses that are trusted smart contracts, when all other smart contacts are prevented from protocol interaction. The stated purpose is to allow only such partner/trusted smart contract integrations (project rep mentioned Argent wallet as the only one for now but that may change) an exemption from potential flash loan threats. But if there a safe listed integration that needs to be later disabled, it cannot be done. The protocol will have to rely on other measures (outside the scope of this contest) to prevent flash loan manipulations which are specified as an area of critical concern.  Scenario: A trusted integration/partner address is added to safe list. But that wallet/protocol/DApp is later manipulated (by project, its users or an attacker) to somehow launch a flash loan attack on the protocol. However, its address cannot be removed from the safe list and the protocol cannot prevent flash loan manipulations from that source because of its exemption. Contract/project will have to be redeployed.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L171-L174  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L176-L178  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L266-L272   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change addSafeAddress() to isSafeAddress() with an additional bool parameter to allow both enabling/disabling of safe addresses.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Controller setWithdrawHandler() is missing a zero-address check and event parameter for _emergencyHandler which is the more critical (used rarely but in an emergency incident-response that is always time-critical ) of the two addresses.  Scenario: setWithdrawHandler() is accidentally called with _emergencyHandler = 0 address. Without a check or an event here, this error goes unnoticed (unless caught in the event from WithdrawHandler::setDependencies). There is an emergency triggered after which withdrawals are attempted via the emergencyHandler but they fail because of the zero address. The correct non-zero emergencyHandler has to be set again. Valuable time is lost and funds are lost.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L105-L110  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L129  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L158   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address check and event parameter for _emergencyHandler  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Missing emits for declared events indicate potentially missing logic, redundant declarations or reduced off-chain monitoring capabilities.  Scenario: For example, the event LogFlashSwitchUpdated is missing an emit in Controller. Based on the name, this is presumably related to flash loans being enabled/disabled which could have significant security implications. Or the (misspelled) LogHealhCheckUpdate which is presumably related to a health check logic that is missing in LifeGuard.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L83  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L48  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L61  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L62  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate if logic is missing and add logic+emit or remove event.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The Controller contract is arguably the most critical contract in the project for access control management (it has 17 onlyOwner functions). Given that it is derived from Ownable, the ownership management of this contract (also Whitelist and Controllable) defaults to Ownable’s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  The same applies to the changing of controller’s address in contracts deriving from Controllable using setController().  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the onlyOwner() functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing onlyOwner() function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.   ## Proof of Concept  See similar High Risk severity finding from Trail-of-Bits Audit of Hermez: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  See similar Medium Risk severity finding from Trail-of-Bits Audit of Uniswap V3: https://github.com/Uniswap/uniswap-v3-core/blob/main/audits/tob/audit.pdf  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b9e2c7896d899de9960f2b3d17ca04d5beb79e8a/contracts/access/Ownable.sol#L46-L64  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L38  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L101  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L105  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L112  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L137  And many other onlyOwner functions such as setController():  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/Controllable.sol#L35-L40   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Override the inherited methods to null functions and use separate functions for a two-step address change: 1) Approve a new address as a pendingOwner 2) A transaction from the pendingOwner address claims the pending ownership change. This mitigates risk because if an incorrect address is used in step (1) then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.  Also, consider adding a time-delay for such sensitive actions. And at a minimum, use a multisig owner address and not an EOA.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There is no input validation on _feeToken in constructor to check if it's referring to a valid index (only USDT=2 makes sense) in the stablecoins similar to the check in setFeeToken(), which cannot be done here because the controller variable is only set later in setDependencies(). Also, given that it is set to true and that only USDT has this capability, the constructor should really check if this value is 2 and nothing else.  Also, setFeeToken() should only allow an index of 2 for now.  Scenario: Incorrectly using a _feeToken value other than 2 will cause an unnecessary balance check because of the presumed transfer fees for that token which does not exist.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L56  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L68-L75   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for _feeToken == 2 in constructor or set+check it using setFeeToken() later. Given that it is only USDT which may have fees, consider hardcoding this assumption instead of making it flexible and leaving room for error, because this is not something that applies to DAI or USDC. The entire codebase currently assumes the presence of only these three tokens in the protocol anyway.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The for loop in investSingle() can be removed in favor of simpler logic to calculate k [k = N_COINS - (i + j)], which will save some gas in the deposit flow.   ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L317-L326   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace L317 to L323 with: ``` uint256 inBalance = inAmounts[N_COINS - (i + j)]; if (inBalance > 0) {       _exchange(inBalance, int128(k), int128(i)); } ```  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In LifeGuard3Pool (LG) deposit(), lp token balance is determined for the crv3pool.add_liquidity() call. Given that LG does not hold any lp tokens between txs, there is no need to determine and subtract lp token balance before and after the curve add liquidity call. Removing the call on L204 will save at least 2600+2100=4700 gas from the external call.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L204-L206  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the call on L204 and just get the balance on L206 without any subtraction.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In LG setDependencies(), the code to approve withdrawHandler to pull from lifeguard is repeated twice, once to set it to 0 allowance if the withdrawHandler is != 0 and then unconditionally to set it MAX. Given that this is the only function that sets withdrawHandler, the first set of 0 approvals seem to be redundant given the unconditional approvals that follow. Removing this can save some gas although we don’t expect this to be called often.  The redundant logic could be for the case where the withdrawHandler is updated and the old handler is given an approval of 0 and the new one MAX.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L78-L89   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate code and remove logic if redundant. If this is present to handle withdrawHandler updates then ignore this recommendation.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The investDelta return variable from function getVaultDeltaForDeposit() is ignored at the only call-site in DepositHandler. Removing it can save some gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L144-L152  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L171-L175  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L193   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unused return value or add logic to use it at caller.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The minAmount <= amount check in _prepareForWithdrawalSingle() is an unnecessary check because the same check has already passed in both lg.withdrawSingleByLiquidity and lg.withdrawSingleByExchange. And there is no logic that changes the checked parameters between the earlier checks and this one.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L361  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L224  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L268   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unnecessary check.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  For public functions, the input parameters are copied to memory automatically which costs gas. If a function is only called externally, making its visibility as external will save gas because external function’s parameters are not copied into memory and are instead read from calldata directly. If a function is called only from with that contract or derived contracts, making it internal/private can further reduce gas costs because the expensive calls are converted into cheaper jumps.   ## Proof of Concept  The only callers of eoaOnly() are external contracts DepositHandler and WithdrawHandler. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L268 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L112 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L211 The only caller of calcSystemTargetDelta() is Insurance. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Allocation.sol#L62-L63 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L213 The only caller of calcVaultTargetDelta() is Insurance. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Allocation.sol#L92-L93 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L432 validGTokenDecrease() can be made private just like validGTokenIncrease because it is only called from within Controller. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L448 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L248   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility from public to external/private where possible.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In isValidBigFish(), the calculation of gvt and pard assets by making an external call to PnL.calcPnL() is required only if the amount is >= bigFishAbsoluteThreshold.   Impact: Moving this logic for calculation of `assets` to the else part where it is required will save gas due to the external pnl call (2600 call + 2*2100 SLOADs for state variable reads in calcPnL()) for the sardine flow, where this is not required.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L250-L258  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pnl/PnL.sol#L144-L146   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move logic to else part instead of doing it before the conditional as shown below: ```         if (amount < bigFishAbsoluteThreshold) {             return false;         } else if (amount > assets) {             return true;         } else {             (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();             uint256 assets = pwrdAssets.add(gvtAssets);             return amount > assets.mul(bigFishThreshold).div(PERCENTAGE_DECIMAL_FACTOR);         } ```  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Unnecessary zero-address check for account in addReferral() because it is always msg.sender (can never be 0) in the only call site from DepositHandler::depositGToken(). Removing this check can save a little gas in the critical deposit flow.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L202  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L115  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unnecessary zero-address check.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Moving declarations of state variables that take < 32 Bytes next to each other will allow combining them in the same storage slot and potentially save gas from combined SSTOREs depending on store patterns.  Impact: Moving emergencyState bool right next to preventSmartContracts bool will conserve a storage slot and may save gas.  ## Proof of Concept  See reference: https://mudit.blog/solidity-gas-optimization-tips/ and https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L54  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L44   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Moving declarations of state variables that take < 32 Bytes next to each other. E.g.: booleans next to each other or address types.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The feeToken logic is to account for tokens that may charge transfer fees and therefore require balance checks before/after transfers. For now, the only token that is programmed to potentially do so (in future, not currently) is USDT (neither DAI/USDC have this capability).  Impact: While this flexible future-proof logic is good design, this costs 3 SLOADs = 3*2100 = 6300 gas for reading the state variable feeToken 3 times (different index each time i.e. costs 2100, not 100) while the only token programmed for transfer fees is USDT (which has never charged fees). 2100 gas + two external token balance calls for USDT (2600*2 = 5200 gas + balance gas costs) >= total of 7300 gas for USDT and 4200 gas for other two tokens is perhaps expensive to support this future-proofing logic. However, from a security-perspective, it might be safer to leave this in here for USDT but remove checking for other two.  ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L145-L149  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L163-L167  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate removing it completely or hardcoding logic only for USDT index=2 to save gas.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase. Successive SLOADs cost 100 gas. Memory stores/loads (MSTOREs/MLOADs) cost only 3 gas. Therefore, by caching repeatedly read state variables in local variables within a function, one can save >=100 gas.  ## Proof of Concept  * Caching ctrl address in a local variable will save 300 gas because it is SLOADed 4 times now in this critical deposit flow. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L112 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L115 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L119 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L121  * Caching lg address state variable in a local variable outside the loop can save 1100 gas by avoiding 4 unnecessary SLOADs per loop iteration (4*3 = 12 but one SLOAD is hoisted out of the loop = 11 extra SLOADS at 100 gas = 1100 gas). https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L147-L151  * Caching buoy address state variable in the function beginning can save 100 gas from an extra SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L174-L176  * Caching insurance address in function beginning can save 100 gas from an unnecessary SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L193 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L198  * Caching lg address in function beginning can save 100 gas from an unnecessary SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L197 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L199  * Hoisting buoy state variable out of the loop and caching it in a local variable will save 300 gas from 3 unnecessary SLOADs. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L181  * Caching buoy in a local variable will save 100 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L212 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L219  * Caching ctrl in a local variable at the function beginning and using that in the rest of this function will save 4 unnecessary SLOADs i.e. 400 gas in this function. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L211 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L221 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L226 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L236 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L260 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L264  * Hoisting buoy out of the loop and caching in a local variable will save 3 unnecessary SLOADs and so 300 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L329  * Caching lg in a local variable will save 100 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L356 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L357  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache repeatedly read state variables (especially those within a loop) in local variables at an appropriate part of the function (preferably the beginning) and use them instead of state variables. Converting SLOADs to MLOADs reduces gas from 100 to 3.  
# Handle  a_delamo   # Vulnerability details  ## Impact  The methods `_stableToUsd` and `_stableToLp`  in the`Buoy3Pool.sol` contract is duplicating the array unnecessarily and costing gas to the users.  ``` function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit)     internal     view     returns (uint256)   {     require(tokenAmounts.length == N_COINS, "deposit: !length");     uint256[N_COINS] memory _tokenAmounts;     for (uint256 i = 0; i < N_COINS; i++) {       _tokenAmounts[i] = tokenAmounts[i];     }     uint256 lpAmount = curvePool.calc_token_amount(_tokenAmounts, deposit);     return _lpToUsd(lpAmount);   }    function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit)     internal     view     returns (uint256)   {     require(tokenAmounts.length == N_COINS, "deposit: !length");     uint256[N_COINS] memory _tokenAmounts;     for (uint256 i = 0; i < N_COINS; i++) {       _tokenAmounts[i] = tokenAmounts[i];     }     return curvePool.calc_token_amount(_tokenAmounts, deposit);   } ```  
# Handle  gpersoon   # Vulnerability details  ## Impact The variable BASIS_POINTS in Buoy3Pool.sol is written in capitals, which is the naming convention for constants. However BASIS_POINTS isn't a constant, because it is updated in setBasisPointsLmit This is confusing when reading the code.  ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L30 uint256 public BASIS_POINTS = 20;   function setBasisPointsLmit(uint256 newLimit) external onlyOwner {         uint256 oldLimit = BASIS_POINTS;         BASIS_POINTS = newLimit;         emit LogNewBasisPointLimit(oldLimit, newLimit);     }  ## Tools Used  ## Recommended Mitigation Steps Change BASIS_POINTS  to something like: basisPoints   
# Handle  gpersoon   # Vulnerability details  ## Impact calcProtocolExposureDelta should probably stop executing once it has found the first occurrence where exposure > threshold. (as is also indicated in the comment).  The current code also works (due to the check protocolExposedDeltaUsd == 0), however inserting a break statement at the end of the "if" is more logical and saves a bit of gas.  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Allocation.sol#L286 ///     By defenition, only one protocol can exceed exposure in the current setup. ...  function calcProtocolExposureDelta(uint256[] memory protocolExposure, SystemState memory sysState) private pure        returns (uint256 protocolExposedDeltaUsd, uint256 protocolExposedIndex)     {         for (uint256 i = 0; i < protocolExposure.length; i++) {             // If the exposure is greater than the rebalance threshold...             if (protocolExposedDeltaUsd == 0 && protocolExposure[i] > sysState.rebalanceThreshold) {                 // ...Calculate the delta between exposure and target                 uint256 target = sysState.rebalanceThreshold.sub(sysState.targetBuffer);                 protocolExposedDeltaUsd = protocolExposure[i].sub(target).mul(sysState.totalCurrentAssetsUsd).div(                     PERCENTAGE_DECIMAL_FACTOR                 );                 protocolExposedIndex = i;                     // probably put a break here             }         }     }  ## Tools Used  ## Recommended Mitigation Steps Add a break statement at the end of the if  
# Handle  gpersoon   # Vulnerability details  ## Impact In several functions of BaseVaultAdaptor a value is stored in the variable amount at the end of the function. However this variable is never used afterwards so the storage is unnecessary and just uses gas.  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/vaults/BaseVaultAdaptor.sol#L165     function withdraw(uint256 amount) external override {      ..         if (!_withdrawFromAdapter(amount, msg.sender)) {             amount = _withdraw(calculateShare(amount), msg.sender);      function withdraw(uint256 amount, address recipient) external override {     ...         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdraw(calculateShare(amount), recipient);      function withdrawToAdapter(uint256 amount) external onlyOwner {         amount = _withdraw(calculateShare(amount), address(this));     }      function withdrawByStrategyOrder( ..         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdrawByStrategyOrder(calculateShare(amount), recipient, reversed);      function withdrawByStrategyIndex(    ...         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdrawByStrategyIndex(calculateShare(amount), recipient, strategyIndex);   ## Tools Used  ## Recommended Mitigation Steps Replace   amount = _withdraw***(...); with    _withdraw***(...);  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _stableToUsd and _stableToLp check that the size of the input array is right. However because that parameter definition also contains the length (e.g. [N_COINS] ), it is already checked by solidity.  So checking it again is not necessary. Note: if this would be necessary than it should also be done at the other functions that have an input parameter with  [N_COINS], see at Proof of concept.  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L174     function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {         require(tokenAmounts.length == N_COINS, "deposit: !length");     ...      function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {         require(tokenAmounts.length == N_COINS, "deposit: !length");       ..  Other functions with a [N_COINS] parameter: .\Controller.sol:    function distributeCurveAssets(uint256 amount, uint256[N_COINS] memory delta) external onlyWhitelist { .\DepositHandler.sol:    function _invest(uint256[N_COINS] memory _inAmounts, uint256 roughUsd) internal returns (uint256 dollarAmount) { .\DepositHandler.sol:    function roughUsd(uint256[N_COINS] memory inAmounts) private view returns (uint256 usdAmount) { .\WithdrawHandler.sol:    function withdrawAllBalanced(bool pwrd, uint256[N_COINS] calldata minAmounts) external override { .\insurance\Exposure.sol:    function getUnifiedAssets(address[N_COINS] calldata vaults) .\insurance\Exposure.sol:    function calculateStableCoinExposure(uint256[N_COINS] memory directlyExposure, uint256 curveExposure) .\insurance\Insurance.sol:    function calculateWithdrawalAmountsOnPartVaults(uint256 amount, address[N_COINS] memory vaults) .\insurance\Insurance.sol:    function calculateWithdrawalAmountsOnAllVaults(uint256 amount, address[N_COINS] memory vaults) .\pools\LifeGuard3Pool.sol:    function distributeCurveVault(uint256 amount, uint256[N_COINS] memory delta) .\pools\LifeGuard3Pool.sol:    function invest(uint256 depositAmount, uint256[N_COINS] calldata delta) .\pools\LifeGuard3Pool.sol:    function _withdrawUnbalanced(uint256 inAmount, uint256[N_COINS] memory delta) private { .\pools\oracle\Buoy3Pool.sol:    function stableToUsd(uint256[N_COINS] calldata inAmounts, bool deposit) external view override returns (uint256) { .\pools\oracle\Buoy3Pool.sol:    function stableToLp(uint256[N_COINS] calldata tokenAmounts, bool deposit) external view override returns (uint256) {  ## Tools Used  ## Recommended Mitigation Steps Remove : require(tokenAmounts.length == N_COINS, "deposit: !length");  
# Handle  gpersoon   # Vulnerability details  ## Impact There are several hardcodes values that could very well be replaced with constants. For example: - 10**18 - 5E17 - 10000  - 10**4 - 3 (N_COINS) This will make the code more readable and easier to maintain  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/DepositHandler.sol#L206  function roughUsd(uint256[N_COINS] memory inAmounts) private view returns (uint256 usdAmount) {      ..            usdAmount = usdAmount.add(inAmounts[i].mul(10**18).div(getDecimal(i)));  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/tokens/GToken.sol#L24 abstract contract GToken is GERC20, Constants, Whitelist, IToken {     uint256 public constant BASE = DEFAULT_DECIMALS_FACTOR;   function applyFactor(   ....      if (diff >= 5E17) {  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/vaults/yearnv2/v032/VaultAdaptorYearnV2_032.sol#L107 function updateStrategiesDebtRatio(uint256[] memory ratios) internal override {         ..         require(ratioTotal <= 10**4, "The total of ratios is more than 10000");  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/Controller.sol#L317  function emergency(uint256 coin) external onlyWhitelist { ...        percent = 10000;  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Insurance.sol#L144  function getVaultDeltaForDeposit(uint256 amount) ....   investDelta[vaultIndexes[0]] = 10000;   .\common\StructDefinitions.sol:    uint256[3] vaultCurrentAssets; .\common\StructDefinitions.sol:    uint256[3] vaultCurrentAssetsUsd; .\common\StructDefinitions.sol:    uint256[3] stablePercents; .\common\StructDefinitions.sol:    uint256[3] stablecoinExposure; .\common\StructDefinitions.sol:    uint256[3] protocolWithdrawalUsd; .\common\StructDefinitions.sol:    uint256[3] swapInAmounts; .\common\StructDefinitions.sol:    uint256[3] swapInAmountsUsd; .\common\StructDefinitions.sol:    uint256[3] swapOutPercents; .\common\StructDefinitions.sol:    uint256[3] vaultsTargetUsd; .\interfaces\IBuoy.sol:    function stableToUsd(uint256[3] calldata inAmount, bool deposit) external view returns (uint256); .\interfaces\IBuoy.sol:    function stableToLp(uint256[3] calldata inAmount, bool deposit) external view returns (uint256); .\interfaces\IController.sol:    function stablecoins() external view returns (address[3] memory); .\interfaces\IController.sol:    function vaults() external view returns (address[3] memory); .\interfaces\ICurve.sol:    function calc_token_amount(uint256[3] calldata inAmounts, bool deposit) external view returns (uint256); .\interfaces\ICurve.sol:    function add_liquidity(uint256[3] calldata uamounts, uint256 min_mint_amount) external; .\interfaces\ICurve.sol:    function remove_liquidity(uint256 amount, uint256[3] calldata min_uamounts) external; .\interfaces\ICurve.sol:    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount) external; .\interfaces\IDepositHandler.sol:        uint256[3] calldata inAmounts, .\interfaces\IDepositHandler.sol:        uint256[3] calldata inAmounts, .\interfaces\IExposure.sol:    function getUnifiedAssets(address[3] calldata vaults) .\interfaces\IExposure.sol:        returns (uint256 unifiedTotalAssets, uint256[3] memory unifiedAssets); .\interfaces\IExposure.sol:        uint256[3] calldata unifiedAssets, .\interfaces\IExposure.sol:        uint256[3] calldata targetPercents .\interfaces\IExposure.sol:    ) external pure returns (uint256[3] memory vaultIndexes); .\interfaces\IExposure.sol:        uint256[3] calldata targets, .\interfaces\IExposure.sol:        address[3] calldata vaults, .\interfaces\IExposure.sol:    ) external view returns (uint256[3] memory); .\interfaces\IInsurance.sol:    function calculateDepositDeltasOnAllVaults() external view returns (uint256[3] memory); .\interfaces\IInsurance.sol:    function getDelta(uint256 withdrawUsd) external view returns (uint256[3] memory delta); .\interfaces\IInsurance.sol:            uint256[3] memory, .\interfaces\IInsurance.sol:            uint256[3] memory, .\interfaces\IInsurance.sol:    function sortVaultsByDelta(bool bigFirst) external view returns (uint256[3] memory vaultIndexes); .\interfaces\ILifeGuard.sol:    function getAssets() external view returns (uint256[3] memory); .\interfaces\ILifeGuard.sol:    function distributeCurveVault(uint256 amount, uint256[3] memory delta) external returns (uint256[3] memory); .\interfaces\ILifeGuard.sol:    function invest(uint256 whaleDepositAmount, uint256[3] calldata delta) external returns (uint256 dollarAmount); .\interfaces\ILifeGuard.sol:        uint256[3] calldata inAmounts, .\interfaces\IWithdrawHandler.sol:        uint256[3] calldata minAmounts .\interfaces\IWithdrawHandler.sol:    function withdrawAllBalanced(bool pwrd, uint256[3] calldata minAmounts) external; .\pools\oracle\Buoy3Pool.sol:    function getTokenRatios(uint256 i) private view returns (uint256[3] memory _ratios) { .\pools\oracle\Buoy3Pool.sol:        uint256[3] memory _prices; .\pools\oracle\Buoy3Pool.sol:        for (uint256 j = 0; j < 3; j++) {   ## Tools Used  ## Recommended Mitigation Steps Do the following replacements - 10**18 ==> DEFAULT_DECIMALS_FACTOR - 5E17 ==> DEFAULT_DECIMALS_FACTOR /2 or BASE/2 - 10000 ==> PERCENTAGE_DECIMAL_FACTOR - 10**4 ==> PERCENTAGE_DECIMAL_FACTOR - 3 ==> N_COINS  
# Handle  gpersoon   # Vulnerability details  ## Impact There are a few underflows that are converted via a typecast afterwards to the expected value. If solidity 0.8.x would be used, then the code would revert. int256(a-b)  where a and b are uint, For example if a=1 and b=2 then the intermediate result would be uint(-1) == 2**256-1 int256(-x) where x is a uint. For example if x=1 then the intermediate result would be uint(-1) == 2**256-1 Its better not to have underflows by using the appropriate typecasts. This is especially relevant when moving to solidity 0.8.x  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178 function sortVaultsByDelta(..) ..         for (uint256 i = 0; i < N_COINS; i++) {             // Get difference between vault current assets and vault target             int256 delta = int256(unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)); // underflow in intermediate result  //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pnl/PnL.sol#L112  function decreaseGTokenLastAmount(bool pwrd, uint256 dollarAmount, uint256 bonus)... ..  emit LogNewGtokenChange(pwrd, int256(-dollarAmount)); // underflow in intermediate result  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L87  function safetyCheck() external view override returns (bool) {       ...             _ratio = abs(int256(_ratio - lastRatio[i])); // underflow in intermediate result    ## Tools Used  ## Recommended Mitigation Steps replace int256(a-b) with int256(a)-int256(b) replace int256(-x)   with -int256(x)   
# Handle  gpersoon   # Vulnerability details  ## Impact The function setWithdrawHandler allows the setting of withdrawHandler and emergencyHandler. However emergencyHandler isn't checked for 0 (like the withdrawHandler ) The value of the emergencyHandler is also not emitted (like the withdrawHandler )  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/Controller.sol#L105  function setWithdrawHandler(address _withdrawHandler, address _emergencyHandler) external onlyOwner {         require(_withdrawHandler != address(0), "setWithdrawHandler: 0x");         withdrawHandler = _withdrawHandler;         emergencyHandler = _emergencyHandler;         emit LogNewWithdrawHandler(_withdrawHandler);     }  ## Tools Used  ## Recommended Mitigation Steps Add something like:         require(_emergencyHandler!= address(0), "setEmergencyHandler: 0x");         event LogNewEmergencyHandler(address tokens);         emit LogNewEmergencyHandler(_emergencyHandler);  
# Handle  gpersoon   # Vulnerability details  ## Impact The function sortVaultsByDelta doesn't always work as expected. Suppose all the delta's are positive, and delta1 >= delta2 >= delta3 > 0 Then maxIndex = 0 And (delta < minDelta (==0) ) is never true, so minIndex = 0  Then (assuming bigFirst==true): vaultIndexes[0] = maxIndex = 0 vaultIndexes[2] = minIndex = 0 vaultIndexes[1] = N_COINS - maxIndex - minIndex = 3-0-0 = 3  This is clearly not what is wanted, all vaultIndexes should be different and should be in the range [0..2] This is due to the fact that maxDelta and minDelta are initialized with the value 0. This all could results in withdrawing from the wrong vaults and reverts (because vaultIndexes[1]  is out of range).  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178 function sortVaultsByDelta(bool bigFirst,uint256 unifiedTotalAssets,uint256[N_COINS] calldata unifiedAssets,uint256[N_COINS] calldata targetPercents) external pure override returns (uint256[N_COINS] memory vaultIndexes) {         uint256 maxIndex;         uint256 minIndex;         int256 maxDelta;         int256 minDelta;         for (uint256 i = 0; i < N_COINS; i++) {             // Get difference between vault current assets and vault target             int256 delta = int256(                 unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)             );             // Establish order             if (delta > maxDelta) {                 maxDelta = delta;                 maxIndex = i;             } else if (delta < minDelta) {                 minDelta = delta;                 minIndex = i;             }         }         if (bigFirst) {             vaultIndexes[0] = maxIndex;             vaultIndexes[2] = minIndex;         } else {             vaultIndexes[0] = minIndex;             vaultIndexes[2] = maxIndex;         }         vaultIndexes[1] = N_COINS - maxIndex - minIndex;     }  ## Tools Used  ## Recommended Mitigation Steps Initialize maxDelta and minDelta:         int256 maxDelta = -2**255; // or type(int256).min when using a newer solidity version         int256 minDelta  = 2**255; // or type(int256).max when using a newer solidity version Check maxIndex and minIndex are not the same require (maxIndex != minIndex);  
