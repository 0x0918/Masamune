# QA Report  **Table of Contents:**  - [QA Report](#qa-report)   - [Global remarks](#global-remarks)   - [File: TimeswapConvenience.sol](#file-timeswapconveniencesol)     - [receive()](#receive)       - [The require statement should have a revert string](#the-require-statement-should-have-a-revert-string)     - [functions timeswapMintCallback() / timeswapLendCallback() / timeswapBorrowCallback() / timeswapPayCallback()](#functions-timeswapmintcallback--timeswaplendcallback--timeswapborrowcallback--timeswappaycallback)       - [A duplicated piece of code should be refactored as a function](#a-duplicated-piece-of-code-should-be-refactored-as-a-function)  ## Global remarks  1. `TimeswapConvenience.sol:receive()` is missing a friendly revert string. 2. For maintainability and readability: duplicated code should be avoided  ## File: TimeswapConvenience.sol  ### receive()  #### The require statement should have a revert string  Here, a friendly message should exist for users to understand what went wrong:  ```jsx File: TimeswapConvenience.sol 74:     receive() external payable { 75:         require(msg.sender == address(weth)); 76:     } ```  This is the only require statement in the whole solution that misses a revert string. This is especially important IMHO as `receive()` is a callback, not a function, and therefore it might be harder to guess why the transaction reverted here.  ### functions timeswapMintCallback() / timeswapLendCallback() / timeswapBorrowCallback() / timeswapPayCallback()  #### A duplicated piece of code should be refactored as a function  Those 4 functions are using a refactorable piece of code:  ```jsx File: TimeswapConvenience.sol 549:     function timeswapMintCallback( 550:         uint256 assetIn, 551:         uint112 collateralIn, 552:         bytes calldata data 553:     ) external override { 554:         (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode( 555:             data, 556:             (IERC20, IERC20, address, address) 557:         ); 558:         IPair pair = factory.getPair(asset, collateral); 559:  560:         require(msg.sender == address(pair), 'E701'); 561:  562:         IWETH _weth = weth; 563:  564:         if (assetFrom == address(this)) { 565:             _weth.deposit{value: assetIn}(); 566:             asset.safeTransfer(pair, assetIn); 567:         } else { 568:             asset.safeTransferFrom(assetFrom, pair, assetIn); 569:         } 570:  571:         if (collateralFrom == address(this)) { 572:             _weth.deposit{value: collateralIn}(); 573:             collateral.safeTransfer(pair, collateralIn); 574:         } else { 575:             collateral.safeTransferFrom(collateralFrom, pair, collateralIn); 576:         } 577:     } 578:  579:     /// @inheritdoc ITimeswapLendCallback 580:     function timeswapLendCallback(uint256 assetIn, bytes calldata data) external override {  581:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 582:         IPair pair = factory.getPair(asset, collateral); 583:  584:         require(msg.sender == address(pair), 'E701'); 585:  586:         if (from == address(this)) { 587:             weth.deposit{value: assetIn}(); 588:             asset.safeTransfer(pair, assetIn); 589:         } else { 590:             asset.safeTransferFrom(from, pair, assetIn); 591:         } 592:     } 593:  594:     /// @inheritdoc ITimeswapBorrowCallback 595:     function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external override { 596:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 597:         IPair pair = factory.getPair(asset, collateral); 598:         require(msg.sender == address(pair), 'E701'); 599:         if (from == address(this)) { 600:             weth.deposit{value: collateralIn}(); 601:             collateral.safeTransfer(pair, collateralIn); 602:         } else { 603:             collateral.safeTransferFrom(from, pair, collateralIn); 604:         } 605:     } 606:  607:     /// @inheritdoc ITimeswapPayCallback 608:     function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override { 609:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 610:  611:         IPair pair = factory.getPair(asset, collateral); 612:         require(msg.sender == address(pair), 'E701'); 613:  614:         if (from == address(this)) { 615:             weth.deposit{value: assetIn}(); 616:             asset.safeTransfer(pair, assetIn); 617:         } else { 618:             asset.safeTransferFrom(from, pair, assetIn); 619:         } 620:     } ```  For maintainability and readability, I suggest creating a private function (here `_timeswapCallback`) and using it as such:  ```jsx File: TimeswapConvenience.sol 549:     function timeswapMintCallback(  550:         uint256 assetIn, 551:         uint112 collateralIn, 552:         bytes calldata data 553:     ) external override { 554:         (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode( 555:             data, 556:             (IERC20, IERC20, address, address) 557:         ); 558:         IPair pair = factory.getPair(asset, collateral); 559:         _timeswapCallback(asset, pair, assetFrom, assetIn, data); 560:         _timeswapCallback(asset, pair, collateralFrom, collateralIn, data); 561:     } 562:  563:     /// @inheritdoc ITimeswapLendCallback 564:     function timeswapLendCallback(uint256 assetIn, bytes calldata data) external override {  565:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 566:         IPair pair = factory.getPair(asset, collateral); 567:         _timeswapCallback(asset, pair, from, assetIn, data); 568:     } 569:  570:     /// @inheritdoc ITimeswapBorrowCallback 571:     function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external override { 572:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 573:         IPair pair = factory.getPair(asset, collateral); 574:         _timeswapCallback(asset, pair, from, collateralIn, data); 575:     } 576:  577:     /// @inheritdoc ITimeswapPayCallback 578:     function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override { 579:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 580:         IPair pair = factory.getPair(asset, collateral); 581:         _timeswapCallback(asset, pair, from, assetIn, data); 582:     } 583:  584:     function _timeswapCallback(IERC20 asset, IIPair pair, address from, uint256 assetOrCollateralIn) private { 585:         require(msg.sender == address(pair), 'E701'); 586:         if (from == address(this)) { 587:             weth.deposit{value: assetOrCollateralIn}(); 588:             asset.safeTransfer(pair, assetOrCollateralIn); 589:         } else { 590:             asset.safeTransferFrom(from, pair, assetOrCollateralIn); 591:         } 592:     } ```  Names and arguments can be changed according to the sponsor's preference, this is simply a suggestion. Here, `pair` was evaluated outside of `_timeswapCallback()` and passed as an argument to save gas (1 extra external call). The original piece of code `L562: IWETH _weth = weth;` is also unnecessary as the state variable is immutable. 
