## Low  ### Prefer two step ownership transfers  Vault owners may transfer ownership of a vault contract in a single step by calling `transferOwnership`:  [`Vault#transferOwnership`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93-L97)  ```solidity     function transferOwnership(address _newOwner) external {         if (owner != msg.sender) revert NotOwner(owner, msg.sender);         owner = _newOwner;         emit TransferOwnership(msg.sender, _newOwner);     } ```  Similarly, the `FERC1155` controller may be transferred in a single step:  [`FERC1155#transferController`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L228-L236)  ```solidity      function transferController(address _newController)         external         onlyController     {         if (_newController == address(0)) revert ZeroAddress();         _controller = _newController;         emit ControllerTransferred(_newController);     } ```  If the owner/controller is accidentally transferred to an incorrect address, ownership of these contracts may be permanently lost.  Consider introducing a mechanism for two-step ownership transfers.  ### Missing array length validations  [`Vault#install`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73-L82) assumes that the `_selectors` and `_plugins` arrays are of equal length, but does not validate that they are equal.  ```solidity     function install(bytes4[] memory _selectors, address[] memory _plugins)         external     {         if (owner != msg.sender) revert NotOwner(owner, msg.sender);         uint256 length = _selectors.length;         for (uint256 i = 0; i < length; i++) {             methods[_selectors[i]] = _plugins[i];         }         emit InstallPlugin(_selectors, _plugins);     } ```  Unlike batch token transfers, there is a more limited impact hereâ€”in the worst case, the user can call this function again to add the accidentally omitted plugin.   ### Gas reserve cannot be increased  Vaults define a `MIN_GAS_RESERVE` constant used to calculate the gas stipend used in [`Vault#_execute`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L128). If future gas costs increase, this stipend may be insufficient. Consider allowing the contract owner to increase the value of this parameter.  ## Informational  ## Solidity optimizer bugs in versions 0.8.13 and 0.8.14  Solidity versions 0.8.13 and 0.8.14 are vulnerable to an [optimizer bug](https://blog.soliditylang.org/2022/06/15/inline-assembly-memory-side-effects-bug/) related to inline assembly. Solidity 0.8.15 has been released with a fix.  This bug only occurs under very specific conditions: the legacy optimizer must be enabled rather than the IR pipeline (true for this project's current project configuration), and the affected assembly blocks must not refer to any local Solidity variables. Inline assembly used here, in Solmate, and in OpenZeppelin does not appear vulnerable. However, it's worth being aware of this vulnerability. Consider upgrading to Solidity 0.8.15.  ## QA  Your project `README` is a great high level intro to the core concepts in Fractional V2, but I'd encourage you to expand on this documentation. Including some worked examples of how components are intended to fit together would be really helpful, especially since Fractional intends to be an open, extensible hyperstructure.  I think it would be especially helpful to clarify how protocol components fit together in two broad scenarios: 1) "normal" users creating new vaults through the Fractional UI and 2) "power" users configuring vaults at a low level and creating new modules to extend the protocol.  For example, I was quite surprised to see that a vault owner can execute arbitrary calls that might bypass modules until I understood that vaults are not usually configured with EOA owners. This wasn't clear from reading the docs and my mental model of the protocol was wrong.  There are some very cool patterns in place in this codebase that others may want to adopt or build on!  ### Use `address.code.length`  [`Vault#_execute`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L119-L124) uses inline assembly to check that the target is a valid contract:  ```solidity         // Check that the target is a valid contract         uint256 codeSize;         assembly {             codeSize := extcodesize(_target)         }         if (codeSize == 0) revert TargetInvalid(_target); ```  In Solidity version `0.8.1` and later, `address.code.length` can be used to access code size. this is equivalent to the assembly version above, but more concise.  Suggestion:  ```solidity         if (_target.code.length == 0) revert TargetInvalid(_target); ```  ### Missing events A number of state changing functions do not emit corresponding events. Consider emitting events from these functions.  - [`Migration#propose`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72) - [`Migration#join`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L105) - [`Migration#leave`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L141) - [`Migration#commit`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L179) - [`Migration#withdrawContribution`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L292) - [`FERC1155#royaltyInfo`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L241)  ### Misnamed constants  There are a handful of typos, misnamings, and inconsistencies in the constants used for functions implemented in assembly.  [`Transfer#ERC1155_SAFE_TRANSFER_FROM_signature`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Transfer.sol#L51-L53) has a trailing lowercase word, unlike other constants.  ```solidity uint256 constant ERC1155_SAFE_TRANSFER_FROM_signature = (     0xf242432a00000000000000000000000000000000000000000000000000000000 ); ```  The [`Transfer#TOKEN_TRANSFER_GENERTIC_`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Transfer.sol#L120-L129) constants should be `TOKEN_TRANSFER_GENERIC`.  ```solidity uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIGNATURE = (     0xf486bc8700000000000000000000000000000000000000000000000000000000 ); uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR = 0x00; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TOKEN_PTR = 0x04; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_FROM_PTR = 0x24; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TO_PTR = 0x44; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_ID_PTR = 0x64; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_AMOUNT_PTR = 0x84; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_LENGTH = 0xa4; // 4 + 32 * 5 == 164 ```  Finally, [`Memory#EIGHT_BYTES`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Memory.sol#L18-L19) is actually `FOUR_BYTES`.  ```solidity uint256 constant EIGHT_BYTES = 0x04; ```  This is pretty confusing when used in [`Transfer#ERC1155BatchTransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L474-L491), since the implementation is correct, but the offsets appear to be wrong:  ```solidity     function ERC1155BatchTransferFrom(         address, /*_token*/         address, /*_from*/         address, /*_to*/         uint256[] calldata, /*_ids*/         uint256[] calldata /*_amounts*/     ) external {         // Utilize assembly to perform an optimized ERC1155 batch transfer.         assembly {             // Write the function selector             // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)             mstore(                 ERC1155_BATCH_TRANSFER_FROM_OFFSET,                 ERC1155_SAFE_BATCH_TRANSFER_FROM_SIGNATURE             )              // Retrieve the token from calldata.             let token := calldataload(EIGHT_BYTES)              // If the token has no code, revert.             if iszero(extcodesize(token)) {                 mstore(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_SIGNATURE)                 mstore(NO_CONTRACT_ERROR_TOKEN_PTR, token)                 revert(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_LENGTH)             }              // Get the total number of supplied ids.             let idsLength := calldataload(                 add(EIGHT_BYTES, ERC1155_BATCH_TRANSFER_IDS_LENGTH_OFFSET)             )               // Rest of function omitted here...     } ```  ### Incorrect comments  The transfer in [`Buyout.sol#withdrawERC20`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L333-L334) is an ERC20 transfer, not an ERC721:  ```solidity         // Executes transfer of ERC721 token to caller         IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof); ```  ### Unused imports - `IERC20` in [`Migration.sol`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L5)
