# Handle  leastwood   # Vulnerability details  ## Impact  The `_decreaseUserTwab()` function is used to decrease an account's TWAB balance when Ticket tokens are transferred between users or delegated to other users. If the amount to decrease exceeds the account's TWAB balance, the function will revert. However, this message does not fully reflect the function's behaviour.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol#L364  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the aforementioned revert message to correctly the function behaviour instead of a generic message.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `awardExternalERC721()` function uses solidity's try and catch statement to ensure a single tokenId cannot deny function execution. If the try statement fails, an `ErrorAwardingExternalERC721` event is emitted with the relevant error, however, the failed tokenId is not removed from the list of tokenIds emitted at the end of function execution. As a result, the `AwardedExternalERC721` is emitted with the entire list of tokenIds, regardless of failure.  An off-chain script or user could therefore be tricked into thinking an ERC721 tokenId was successfully awarded.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L250-L270  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider emitting only successfully transferred tokenIds in the `AwardedExternalERC721` event.  
# Handle  leastwood   # Vulnerability details  ## Impact  There are a couple of typos found within the `Reserve.sol` contract.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/Reserve.sol#L20 https://github.com/pooltogether/v4-core/blob/master/contracts/Reserve.sol#L21  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the typo in `Reserve.sol:L20` from `speicific` to `specific` and the typo in `Reserve.sol:L21` from `determininstially` to `deterministically`.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `_canAwardExternal()` function is used to prevent the `onlyPrizeStrategy` role from moving a yield source's deposit tokens. However, the `YieldSourcePrizePool.sol` contract only restricts the movement of tokens from the `yieldSource` address instead of the actual deposit token. As a result, the `onlyOwner` role could escalate its role by calling `PrizePool.setPrizeStrategy()` and setting the prize strategy to its own address. Once it has taken over this role, they could effectively transfer out the yield source's deposit tokens, thereby draining the contract.   This is in direct contrast to PoolTogether's ethos, whereby their docs state that the multisig account used to represent the `onlyOwner` role has no custody over deposited assets.  ## Proof of Concept  https://v4.docs.pooltogether.com/protocol/reference/launch-architecture#progressive-decentralization https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/YieldSourcePrizePool.sol#L55-L57 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L329-L343 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L228-L236 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L300-L302  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the `YieldSourcePrizePool._canAwardExternal()` function to restrict the prize strategy from withdrawing `yieldSource.depositToken()` instead.  
# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * function controllerBurnFrom could also skip _approve decrease if the current approval is uint max (unlimited).  * hardcoded number 1000 in PrizeSplit could be extracted to a constant variable to improve readability and maintainability.  
# Handle  pauliax   # Vulnerability details  ## Impact You can save some gas by using the 'unchecked' keyword to avoid redundant arithmetic checks when an underflow/overflow cannot happen. For example, here:   while (_prizeSplits.length > newPrizeSplitsLength) {     uint256 _index = _prizeSplits.length - 1; or here:         require(_accountDetails.balance >= _amount, _revertMessage);         ...         accountDetails.balance = _accountDetails.balance - _amount;  ## Recommended Mitigation Steps Consider applying 'unchecked' keyword where overflows/underflows are not possible.  
# Handle  pauliax   # Vulnerability details  ## Impact There are imports that are not necessary. They will increase the size of deployment with no real benefit. Consider removing them to save some gas.  Examples of such imports are: in contract DrawBuffer imported twice: import "./interfaces/IDrawBeacon.sol";  in contract DrawCalculator: import "./libraries/DrawRingBufferLib.sol"; import "./PrizeDistributor.sol";  in contract PrizeDistributor: import "./interfaces/IDrawBeacon.sol";  ## Recommended Mitigation Steps Consider removing imports that are not actually used in the contract.  
# Handle  pauliax   # Vulnerability details  ## Impact If you want to save some gas you can get rid of _getPrizeSplitAmount and calculate the split directly in _distributePrizeSplits as this function is internal and is only called once so there is no actual need for reusability here and removing this extra call will make the execution cheaper.  ## Recommended Mitigation Steps Consider moving the logic of _getPrizeSplitAmount  directly to _distributePrizeSplits.  
# Handle  pauliax   # Vulnerability details  ## Impact 'immutable' greatly reduces gas costs. There are variables that do not change so they can be marked as immutable to greatly improve the gas costs.  Examples of such variables are:  yieldSource in YieldSourcePrizePool.  prizePool in PrizeSplitStrategy.  controller in ControlledToken.  ## Recommended Mitigation Steps Consider applying immutable keyword to the variables that are assigned only once.  
# Handle  pauliax   # Vulnerability details  ## Impact Low-level calls like staticcall return true even if the account called is non-existent (per EVM design) so this hack in YieldSourcePrizePool constructor will not work in certain cases:         // A hack to determine whether it's an actual yield source         (bool succeeded, ) = address(_yieldSource).staticcall(             abi.encodePacked(_yieldSource.depositToken.selector)         );  You can try to pass an EOA address and see that it will return true.  ## Recommended Mitigation Steps Account existence must be checked prior to calling. A similar issue was submitted in a previous contest and assigned a severity of low, you can find more details here: https://github.com/code-423n4/2021-04-basedloans-findings/issues/16  
# Handle  pauliax   # Vulnerability details  ## Impact function calculateNextBeaconPeriodStartTime accepts _time as a type of uint256 but later explicitly casts it to uint64. While this function is not used internally, it behaves incorrectly when passed a value that uint64 does not hold (for such values it will return a max value of uint64). I don't see a reason why you can't directly accept uint64 here.  ## Recommended Mitigation Steps Change parameter type to uint64.  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-strategy/PrizeSplit.sol#L135-L136  ```solidity PrizeSplitConfig memory split = _prizeSplits[index]; _tempTotalPercentage = _tempTotalPercentage + split.percentage; ```  Only `percentage` of the `PrizeSplitConfig` struct is accessed, however, the current implementation created a memory variable that will load `_prizeSplits[index]` and copy to memory, this is unnecessary and gas inefficient.  ### Recommendation  Change to:  ```solidity _tempTotalPercentage = _tempTotalPercentage + split.percentage; ```  
# Handle  WatchPug   # Vulnerability details  ## Adding unchecked directive can save gas  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  1. `PrizePool.sol#award()`  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L210-L225  ```solidity function award(address _to, uint256 _amount) external override onlyPrizeStrategy {     if (_amount == 0) {         return;     }      uint256 currentAwardBalance = _currentAwardBalance;      require(_amount <= currentAwardBalance, "PrizePool/award-exceeds-avail");     _currentAwardBalance = currentAwardBalance - _amount;      ITicket _ticket = ticket;      _mint(_to, _amount, _ticket);      emit Awarded(_to, _ticket, _amount); } ```  `currentAwardBalance - _amount;` will never underflow.   2. `PrizeDistributor.sol#claim()`  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/PrizeDistributor.sol#L74-L77  ```solidity if (payout > oldPayout) {     payoutDiff = payout - oldPayout;     _setDrawPayoutBalanceOf(_user, drawId, payout); } ```  `payout - oldPayout` will never underflow.  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L361-L368  ```solidity function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {     ITicket _ticket = ticket;     uint256 _balanceCap = balanceCap;      if (_balanceCap == type(uint256).max) return true;      return (_ticket.balanceOf(_user) + _amount <= _balanceCap); } ```  `ITicket _ticket = ticket;` is redundant, removing it will also avoid a `sload` if returned when `_balanceCap == type(uint256).max`.  ### Recommendation  Change to:  ```solidity function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {      uint256 _balanceCap = balanceCap;      if (_balanceCap == type(uint256).max) return true;      return (ticket.balanceOf(_user) + _amount <= _balanceCap); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L284-L297  ```solidity function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {     address _ticketAddress = address(_ticket);      require(_ticketAddress != address(0), "PrizePool/ticket-not-zero-address"); ... ```  `_ticketAddress` is unnecessary as it's being used only once.  ### Recommendation  Change to:  ```solidity function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {     require(address(_ticket) != address(0), "PrizePool/ticket-not-zero-address"); ... ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-strategy/PrizeSplitStrategy.sol#L51-L61  ```solidity function distribute() external override returns (uint256) {     uint256 prize = prizePool.captureAwardBalance();      if (prize == 0) return 0;      _distributePrizeSplits(prize);      emit Distributed(prize);      return prize; } ```  Based on the context, the value of the parameter of the `Distributed` event should be the distributed prize amount, which can be calculated based on the return value of `_distributePrizeSplits`.  ### Recommendation  Change to:  ```solidity  event Distributed(uint256 totalPrizeCaptured, uint256 totalPrizeDistributed);  function distribute() external override returns (uint256) {     uint256 prize = prizePool.captureAwardBalance();      if (prize == 0) return 0;      uint remainingPrize = _distributePrizeSplits(prize);      emit Distributed(prize, prize - remainingPrize);      return prize; } ```  
# Handle  WatchPug   # Vulnerability details  The formula of the number of prizes for a degree per the document: https://v4.docs.pooltogether.com/protocol/concepts/prize-distribution/#splitting-the-prizes is: ``` Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) - (2^bit range)^(degree-2) - ... ``` Should be changed to: ``` Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) ``` or ``` Number of prizes for a degree = 2^(bit range * degree) - 2^(bit range * (degree-1)) ```  ### Impact  Per the document:  > prize for a degree = total prize * degree percentage / number of prizes for a degree  Due to the miscalculation of `number of prizes for a degree`, it will be smaller than expected, as a result, `prize for a degree` will be larger than expected. Making the protocol giving out more prizes than designed.  ### Proof  > We will use `f(bitRange, degree)` to represent `numberOfPrizesForDegree(bitRangeSize, degree)`.  #### Proof: (method 1)  ```tex 2 ^ {bitRange \times n} = f(bitRange, n) + f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) f(bitRange, n) = 2 ^ {bitRange \times n} - ( f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) ) f(bitRange, n) = 2 ^ {bitRange \times n} - f(bitRange, n-1) - ( f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )  Because:  2 ^ {bitRange \times (n-1)} = f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) 2 ^ {bitRange \times (n-1)} - f(bitRange, n-1) = f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)  Therefore:  f(bitRange, n) = 2 ^ {bitRange \times n} - f(bitRange, n-1) - ( 2 ^ {bitRange \times (n-1)} - f(bitRange, n-1) ) f(bitRange, n) = 2 ^ {bitRange \times n} - f(bitRange, n-1) - 2 ^ {bitRange \times (n-1)} + f(bitRange, n-1) f(bitRange, n) = 2 ^ {bitRange \times n} - 2 ^ {bitRange \times (n-1)} ```  Because `2^x = 1 << x`  Therefore, when `n > 0`:  ``` f(bitRange, n) = ( 1 << bitRange * n ) - ( 1 << bitRange * (n - 1) ) ```  QED.  #### Proof: (method 2)  By definition, `degree n` is constructed by 3 chunks:  -  The first N numbers, must equal the matching numbers. Number of possible values: `1`; -  The N-th number, must not equal the N-th matching number. Number of possible values: `2^bitRange - 1` -  From N (not include) until the end. Number of possible values: `2 ^ (bitRange * (n-1))`  Therefore, total `numberOfPrizesForDegree` will be:  ```tex f(bitRange, n) = (2 ^ {bitRange} - 1) \times 2 ^ {bitRange \times (n - 1)} f(bitRange, n) = 2 ^ {bitRange} \times 2 ^ {bitRange \times (n - 1)} - 2 ^ {bitRange \times (n - 1)} f(bitRange, n) = 2 ^ {bitRange + bitRange \times (n - 1)} - 2 ^ {bitRange \times (n - 1)} f(bitRange, n) = 2 ^ {bitRange + bitRange \times n - bitRange} - 2 ^ {bitRange \times (n - 1)} f(bitRange, n) = 2 ^ {bitRange \times n} - 2 ^ {bitRange \times (n - 1)} ```  QED.  ### Recommendation  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/DrawCalculator.sol#L423-L431   ```solidity=412{423-431} /**     * @notice Calculates the number of prizes for a given prizeDistributionIndex     * @param _bitRangeSize Bit range size for Draw     * @param _prizeTierIndex Index of the prize tier array to calculate     * @return returns the fraction of the total prize (base 1e18)     */ function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)     internal     pure     returns (uint256) {     uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);     uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;      while (_prizeTierIndex > 0) {         numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);         _prizeTierIndex--;     }      return numberOfPrizesForIndex; } ```  L423-431 should change to:  ```solidity if (_prizeTierIndex > 0) {     return ( 1 << _bitRangeSize * _prizeTierIndex ) - ( 1 << _bitRangeSize * (_prizeTierIndex - 1) ); } else {     return 1; } ```  BTW, the comment on L416 is wrong:  - seems like it's copied from _calculatePrizeTierFraction() - plus, it's not base 1e18 but base 1e9  
# Handle  cmichel   # Vulnerability details  The `PrizePool.captureAwardBalance` function always sets `_currentAwardBalance = currentAwardBalance` where `currentAwardBalance = currentAwardBalance + unaccountedPrizeBalance = currentAwardBalance + totalInterest - currentAwardBalance = totalInterest`.  Save a checked math addition by just setting `_currentAwardBalance = totalInterest` immediately.  
# Handle  cmichel   # Vulnerability details  The `PrizePool` defines `using SafeERC20 for IERC721;` which means the `SafeERC20.safeTransferFrom` function will be used in `awardExternalERC721`. However, this function is just a wrapper for `contract.transferFrom` with a return-value and success check.  Thus this call actually calls `ERC721.transferFrom` instead of `ERC721.safeTransferFrom` and does not call the important `onERC721Received` check for contracts.  ## Impact ERC721s can be awarded to contracts that don't know how to handle it and they can get stuck.  ## Recommended Mitigation Steps Remove the `using SafeERC20 for IERC721;` line.   
# Handle  cmichel   # Vulnerability details  The `Reserve` does not correctly use ring buffers to get the oldest / newest elements if the array is full (observations larger than cardinality) in which case it should wrap around.  `getReserveAccumulatedBetween` always picks `reserveAccumulators[_cardinality - 1]`. `_checkpoint` tries to write to `reserveAccumulators[cardinality++]` which will break once `cardinality` reaches `MAX_CARDINALITY`.  The `TwabLib` library has a correct `oldestTwab/newestTwab` implementation using the `RingBufferLib` that wraps around if needed.  ## Impact Anyone can send 1 wei to the reserve and call `checkpoint` on it until the `MAX_CARDINALITY` is reached. Afterwards, trying to write any new checkpoints will fail as `_checkpoint` now tries to write to `cardinality=MAX_CARDINALITY+1` which is out of bounds of the `reserveAccumulators`.  The reserve is broken and cannot withdraw funds anymore. The gas costs for such an attack are very high and would take ~7 years if writing every block, making it probably not worth fixing.  ## Recommended Mitigation Steps Correctly implement the ring buffer usage like in `TwabLib`.   
# Handle  cmichel   # Vulnerability details  The `_calculatePrizeTierFraction` docs say "returns the fraction of the total prize (base 1e18)", but it's base 1e9. Code seems to be correct.  
# Handle  cmichel   # Vulnerability details  In `DrawCalculator._createBitMasks`, the bit masks can just be created by shifting the previous (potentially already shifted) masks by the bit range. It saves on multiplications and, for me, this is also more intuitive than the current algorithm.  Some pseudocode: ```solidity function _createBitMasks(IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution)     internal     pure     returns (uint256[] memory) {     uint256[] memory masks = new uint256[](_prizeDistribution.matchCardinality);     uint256 _bitRangeMaskValue = (2**_prizeDistribution.bitRangeSize) - 1; // get a decimal representation of bitRangeSize, for example 0xF for bitRangeSize = 4      if(_prizeDistribution.matchCardinality == 0) return masks;      masks[0] = _bitRangeMaskValue;     for (uint8 maskIndex = 1; maskIndex < _prizeDistribution.matchCardinality; maskIndex++) {         // shift by the "size" of the bit mask each time, 0xF, 0xF0, 0xF00, 0xF000, etc.         masks[maskIndex] = masks[maskIndex - 1] << _prizeDistribution.bitRangeSize;     }      return masks; } ```  
# Handle  cmichel   # Vulnerability details  If all masks match the `DrawCalculator._calculateTierIndex` function returns `masksLength - numberOfMatches` but it will always be zero at this point as `masksLength == numberOfMatches`. So just returning zero here would lead to saving a checked subtraction.  
# Handle  cmichel   # Vulnerability details  Description: `safeApprove` is now deprecated, see [this comment](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38).  ## Impact When using one of these unsupported tokens, all transactions revert and the protocol cannot be used.  ## Recommended Mitigation Steps As per OpenZepplin documentation “whenever possible, use `safeIncreaseAllowance` and `safeDecreaseAllowance` instead”.   
# Handle  gpersoon   # Vulnerability details  ## Impact In the contract PrizeSplit.sol, uint8 is used in a few places. This limits the addressable size of _prizeSplits.  In practice you would probably not split prizes in more than 256 ways, but checking for this is safer.  ## Proof of Concept https://github.com/pooltogether/v4-core/blob/master/contracts/prize-strategy/PrizeSplit.sol#L86-L87  function setPrizeSplit(PrizeSplitConfig memory _prizeSplit, uint8 _prizeSplitIndex)  https://github.com/pooltogether/v4-core/blob/master/contracts/prize-strategy/PrizeSplit.sol#L130-L140  for (uint8 index = 0; index < prizeSplitsLength; index++) {  ## Tools Used  ## Recommended Mitigation Steps Add the following  to function setPrizeSplits:    require(newPrizeSplitsLength <= type(uint8).max))  or replace uint8 with uint256 in PrizeSplit.sol   
# Handle  gpersoon   # Vulnerability details  ## Impact I've found some gas improvements for _transferTwab, see below.  ## Proof of Concept https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol#L296-L313  ## Tools Used  ## Recommended Mitigation Steps   function _transferTwab(address _from, address _to, uint256 _amount) internal {         if (_from==_to) return; // no need to transfer if both are the same         if (_from != address(0)) {             _decreaseUserTwab(_from, _amount);             if (_to == address(0)) _decreaseTotalSupplyTwab(_amount);         }                 if (_to != address(0)) {                     _increaseUserTwab(_to, _amount);             if (_from == address(0)) _increaseTotalSupplyTwab(_amount);         }     }  
# Handle  ye0lde   # Vulnerability details  ## Impact  Gas savings and code clarity  ## Proof of Concept  PrizePool.sol: https://github.com/pooltogether/v4-core/blob/35b00f710db422a6193131b7dc2de5202dc4677c/contracts/prize-pool/PrizePool.sol#L383-L387  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Replace this https://github.com/pooltogether/v4-core/blob/35b00f710db422a6193131b7dc2de5202dc4677c/contracts/prize-pool/PrizePool.sol#L383-L387 with <code> return (ticket == _controlledToken)  </code>  
# Handle  pants   # Vulnerability details  At lines 197,199 PrizeDistributionHistory for example, the value _prizeDistribution.distributions[index] is read twice from memory instead of caching it as a local variable distributions_index = _prizeDistribution.distributions[index]; and using it instead.  Same at DrawCalculator.sol at lines 312, 315, 319 (here _picks[index] is read 3 times)   
# Handle  leastwood   # Vulnerability details  ## Impact  The `_decreaseUserTwab()` function is used to decrease an account's TWAB balance when Ticket tokens are transferred between users or delegated to other users. If the amount to decrease exceeds the account's TWAB balance, the function will revert. However, this message does not fully reflect the function's behaviour.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol#L364  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the aforementioned revert message to correctly the function behaviour instead of a generic message.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `awardExternalERC721()` function uses solidity's try and catch statement to ensure a single tokenId cannot deny function execution. If the try statement fails, an `ErrorAwardingExternalERC721` event is emitted with the relevant error, however, the failed tokenId is not removed from the list of tokenIds emitted at the end of function execution. As a result, the `AwardedExternalERC721` is emitted with the entire list of tokenIds, regardless of failure.  An off-chain script or user could therefore be tricked into thinking an ERC721 tokenId was successfully awarded.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L250-L270  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider emitting only successfully transferred tokenIds in the `AwardedExternalERC721` event.  
# Handle  leastwood   # Vulnerability details  ## Impact  There are a couple of typos found within the `Reserve.sol` contract.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/Reserve.sol#L20 https://github.com/pooltogether/v4-core/blob/master/contracts/Reserve.sol#L21  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the typo in `Reserve.sol:L20` from `speicific` to `specific` and the typo in `Reserve.sol:L21` from `determininstially` to `deterministically`.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `_canAwardExternal()` function is used to prevent the `onlyPrizeStrategy` role from moving a yield source's deposit tokens. However, the `YieldSourcePrizePool.sol` contract only restricts the movement of tokens from the `yieldSource` address instead of the actual deposit token. As a result, the `onlyOwner` role could escalate its role by calling `PrizePool.setPrizeStrategy()` and setting the prize strategy to its own address. Once it has taken over this role, they could effectively transfer out the yield source's deposit tokens, thereby draining the contract.   This is in direct contrast to PoolTogether's ethos, whereby their docs state that the multisig account used to represent the `onlyOwner` role has no custody over deposited assets.  ## Proof of Concept  https://v4.docs.pooltogether.com/protocol/reference/launch-architecture#progressive-decentralization https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/YieldSourcePrizePool.sol#L55-L57 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L329-L343 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L228-L236 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L300-L302  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the `YieldSourcePrizePool._canAwardExternal()` function to restrict the prize strategy from withdrawing `yieldSource.depositToken()` instead.  
# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * function controllerBurnFrom could also skip _approve decrease if the current approval is uint max (unlimited).  * hardcoded number 1000 in PrizeSplit could be extracted to a constant variable to improve readability and maintainability.  
# Handle  pauliax   # Vulnerability details  ## Impact You can save some gas by using the 'unchecked' keyword to avoid redundant arithmetic checks when an underflow/overflow cannot happen. For example, here:   while (_prizeSplits.length > newPrizeSplitsLength) {     uint256 _index = _prizeSplits.length - 1; or here:         require(_accountDetails.balance >= _amount, _revertMessage);         ...         accountDetails.balance = _accountDetails.balance - _amount;  ## Recommended Mitigation Steps Consider applying 'unchecked' keyword where overflows/underflows are not possible.  
# Handle  pauliax   # Vulnerability details  ## Impact There are imports that are not necessary. They will increase the size of deployment with no real benefit. Consider removing them to save some gas.  Examples of such imports are: in contract DrawBuffer imported twice: import "./interfaces/IDrawBeacon.sol";  in contract DrawCalculator: import "./libraries/DrawRingBufferLib.sol"; import "./PrizeDistributor.sol";  in contract PrizeDistributor: import "./interfaces/IDrawBeacon.sol";  ## Recommended Mitigation Steps Consider removing imports that are not actually used in the contract.  
# Handle  pauliax   # Vulnerability details  ## Impact If you want to save some gas you can get rid of _getPrizeSplitAmount and calculate the split directly in _distributePrizeSplits as this function is internal and is only called once so there is no actual need for reusability here and removing this extra call will make the execution cheaper.  ## Recommended Mitigation Steps Consider moving the logic of _getPrizeSplitAmount  directly to _distributePrizeSplits.  
# Handle  pauliax   # Vulnerability details  ## Impact 'immutable' greatly reduces gas costs. There are variables that do not change so they can be marked as immutable to greatly improve the gas costs.  Examples of such variables are:  yieldSource in YieldSourcePrizePool.  prizePool in PrizeSplitStrategy.  controller in ControlledToken.  ## Recommended Mitigation Steps Consider applying immutable keyword to the variables that are assigned only once.  
# Handle  pauliax   # Vulnerability details  ## Impact Low-level calls like staticcall return true even if the account called is non-existent (per EVM design) so this hack in YieldSourcePrizePool constructor will not work in certain cases:         // A hack to determine whether it's an actual yield source         (bool succeeded, ) = address(_yieldSource).staticcall(             abi.encodePacked(_yieldSource.depositToken.selector)         );  You can try to pass an EOA address and see that it will return true.  ## Recommended Mitigation Steps Account existence must be checked prior to calling. A similar issue was submitted in a previous contest and assigned a severity of low, you can find more details here: https://github.com/code-423n4/2021-04-basedloans-findings/issues/16  
# Handle  pauliax   # Vulnerability details  ## Impact function calculateNextBeaconPeriodStartTime accepts _time as a type of uint256 but later explicitly casts it to uint64. While this function is not used internally, it behaves incorrectly when passed a value that uint64 does not hold (for such values it will return a max value of uint64). I don't see a reason why you can't directly accept uint64 here.  ## Recommended Mitigation Steps Change parameter type to uint64.  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-strategy/PrizeSplit.sol#L135-L136  ```solidity PrizeSplitConfig memory split = _prizeSplits[index]; _tempTotalPercentage = _tempTotalPercentage + split.percentage; ```  Only `percentage` of the `PrizeSplitConfig` struct is accessed, however, the current implementation created a memory variable that will load `_prizeSplits[index]` and copy to memory, this is unnecessary and gas inefficient.  ### Recommendation  Change to:  ```solidity _tempTotalPercentage = _tempTotalPercentage + split.percentage; ```  
# Handle  WatchPug   # Vulnerability details  ## Adding unchecked directive can save gas  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  1. `PrizePool.sol#award()`  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L210-L225  ```solidity function award(address _to, uint256 _amount) external override onlyPrizeStrategy {     if (_amount == 0) {         return;     }      uint256 currentAwardBalance = _currentAwardBalance;      require(_amount <= currentAwardBalance, "PrizePool/award-exceeds-avail");     _currentAwardBalance = currentAwardBalance - _amount;      ITicket _ticket = ticket;      _mint(_to, _amount, _ticket);      emit Awarded(_to, _ticket, _amount); } ```  `currentAwardBalance - _amount;` will never underflow.   2. `PrizeDistributor.sol#claim()`  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/PrizeDistributor.sol#L74-L77  ```solidity if (payout > oldPayout) {     payoutDiff = payout - oldPayout;     _setDrawPayoutBalanceOf(_user, drawId, payout); } ```  `payout - oldPayout` will never underflow.  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L361-L368  ```solidity function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {     ITicket _ticket = ticket;     uint256 _balanceCap = balanceCap;      if (_balanceCap == type(uint256).max) return true;      return (_ticket.balanceOf(_user) + _amount <= _balanceCap); } ```  `ITicket _ticket = ticket;` is redundant, removing it will also avoid a `sload` if returned when `_balanceCap == type(uint256).max`.  ### Recommendation  Change to:  ```solidity function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {      uint256 _balanceCap = balanceCap;      if (_balanceCap == type(uint256).max) return true;      return (ticket.balanceOf(_user) + _amount <= _balanceCap); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L284-L297  ```solidity function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {     address _ticketAddress = address(_ticket);      require(_ticketAddress != address(0), "PrizePool/ticket-not-zero-address"); ... ```  `_ticketAddress` is unnecessary as it's being used only once.  ### Recommendation  Change to:  ```solidity function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {     require(address(_ticket) != address(0), "PrizePool/ticket-not-zero-address"); ... ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-strategy/PrizeSplitStrategy.sol#L51-L61  ```solidity function distribute() external override returns (uint256) {     uint256 prize = prizePool.captureAwardBalance();      if (prize == 0) return 0;      _distributePrizeSplits(prize);      emit Distributed(prize);      return prize; } ```  Based on the context, the value of the parameter of the `Distributed` event should be the distributed prize amount, which can be calculated based on the return value of `_distributePrizeSplits`.  ### Recommendation  Change to:  ```solidity  event Distributed(uint256 totalPrizeCaptured, uint256 totalPrizeDistributed);  function distribute() external override returns (uint256) {     uint256 prize = prizePool.captureAwardBalance();      if (prize == 0) return 0;      uint remainingPrize = _distributePrizeSplits(prize);      emit Distributed(prize, prize - remainingPrize);      return prize; } ```  
# Handle  WatchPug   # Vulnerability details  The formula of the number of prizes for a degree per the document: https://v4.docs.pooltogether.com/protocol/concepts/prize-distribution/#splitting-the-prizes is: ``` Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) - (2^bit range)^(degree-2) - ... ``` Should be changed to: ``` Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) ``` or ``` Number of prizes for a degree = 2^(bit range * degree) - 2^(bit range * (degree-1)) ```  ### Impact  Per the document:  > prize for a degree = total prize * degree percentage / number of prizes for a degree  Due to the miscalculation of `number of prizes for a degree`, it will be smaller than expected, as a result, `prize for a degree` will be larger than expected. Making the protocol giving out more prizes than designed.  ### Proof  > We will use `f(bitRange, degree)` to represent `numberOfPrizesForDegree(bitRangeSize, degree)`.  #### Proof: (method 1)  ```tex 2 ^ {bitRange \times n} = f(bitRange, n) + f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) f(bitRange, n) = 2 ^ {bitRange \times n} - ( f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) ) f(bitRange, n) = 2 ^ {bitRange \times n} - f(bitRange, n-1) - ( f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )  Because:  2 ^ {bitRange \times (n-1)} = f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) 2 ^ {bitRange \times (n-1)} - f(bitRange, n-1) = f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)  Therefore:  f(bitRange, n) = 2 ^ {bitRange \times n} - f(bitRange, n-1) - ( 2 ^ {bitRange \times (n-1)} - f(bitRange, n-1) ) f(bitRange, n) = 2 ^ {bitRange \times n} - f(bitRange, n-1) - 2 ^ {bitRange \times (n-1)} + f(bitRange, n-1) f(bitRange, n) = 2 ^ {bitRange \times n} - 2 ^ {bitRange \times (n-1)} ```  Because `2^x = 1 << x`  Therefore, when `n > 0`:  ``` f(bitRange, n) = ( 1 << bitRange * n ) - ( 1 << bitRange * (n - 1) ) ```  QED.  #### Proof: (method 2)  By definition, `degree n` is constructed by 3 chunks:  -  The first N numbers, must equal the matching numbers. Number of possible values: `1`; -  The N-th number, must not equal the N-th matching number. Number of possible values: `2^bitRange - 1` -  From N (not include) until the end. Number of possible values: `2 ^ (bitRange * (n-1))`  Therefore, total `numberOfPrizesForDegree` will be:  ```tex f(bitRange, n) = (2 ^ {bitRange} - 1) \times 2 ^ {bitRange \times (n - 1)} f(bitRange, n) = 2 ^ {bitRange} \times 2 ^ {bitRange \times (n - 1)} - 2 ^ {bitRange \times (n - 1)} f(bitRange, n) = 2 ^ {bitRange + bitRange \times (n - 1)} - 2 ^ {bitRange \times (n - 1)} f(bitRange, n) = 2 ^ {bitRange + bitRange \times n - bitRange} - 2 ^ {bitRange \times (n - 1)} f(bitRange, n) = 2 ^ {bitRange \times n} - 2 ^ {bitRange \times (n - 1)} ```  QED.  ### Recommendation  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/DrawCalculator.sol#L423-L431   ```solidity=412{423-431} /**     * @notice Calculates the number of prizes for a given prizeDistributionIndex     * @param _bitRangeSize Bit range size for Draw     * @param _prizeTierIndex Index of the prize tier array to calculate     * @return returns the fraction of the total prize (base 1e18)     */ function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)     internal     pure     returns (uint256) {     uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);     uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;      while (_prizeTierIndex > 0) {         numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);         _prizeTierIndex--;     }      return numberOfPrizesForIndex; } ```  L423-431 should change to:  ```solidity if (_prizeTierIndex > 0) {     return ( 1 << _bitRangeSize * _prizeTierIndex ) - ( 1 << _bitRangeSize * (_prizeTierIndex - 1) ); } else {     return 1; } ```  BTW, the comment on L416 is wrong:  - seems like it's copied from _calculatePrizeTierFraction() - plus, it's not base 1e18 but base 1e9  
# Handle  cmichel   # Vulnerability details  The `PrizePool.captureAwardBalance` function always sets `_currentAwardBalance = currentAwardBalance` where `currentAwardBalance = currentAwardBalance + unaccountedPrizeBalance = currentAwardBalance + totalInterest - currentAwardBalance = totalInterest`.  Save a checked math addition by just setting `_currentAwardBalance = totalInterest` immediately.  
# Handle  cmichel   # Vulnerability details  The `PrizePool` defines `using SafeERC20 for IERC721;` which means the `SafeERC20.safeTransferFrom` function will be used in `awardExternalERC721`. However, this function is just a wrapper for `contract.transferFrom` with a return-value and success check.  Thus this call actually calls `ERC721.transferFrom` instead of `ERC721.safeTransferFrom` and does not call the important `onERC721Received` check for contracts.  ## Impact ERC721s can be awarded to contracts that don't know how to handle it and they can get stuck.  ## Recommended Mitigation Steps Remove the `using SafeERC20 for IERC721;` line.   
# Handle  cmichel   # Vulnerability details  The `Reserve` does not correctly use ring buffers to get the oldest / newest elements if the array is full (observations larger than cardinality) in which case it should wrap around.  `getReserveAccumulatedBetween` always picks `reserveAccumulators[_cardinality - 1]`. `_checkpoint` tries to write to `reserveAccumulators[cardinality++]` which will break once `cardinality` reaches `MAX_CARDINALITY`.  The `TwabLib` library has a correct `oldestTwab/newestTwab` implementation using the `RingBufferLib` that wraps around if needed.  ## Impact Anyone can send 1 wei to the reserve and call `checkpoint` on it until the `MAX_CARDINALITY` is reached. Afterwards, trying to write any new checkpoints will fail as `_checkpoint` now tries to write to `cardinality=MAX_CARDINALITY+1` which is out of bounds of the `reserveAccumulators`.  The reserve is broken and cannot withdraw funds anymore. The gas costs for such an attack are very high and would take ~7 years if writing every block, making it probably not worth fixing.  ## Recommended Mitigation Steps Correctly implement the ring buffer usage like in `TwabLib`.   
# Handle  cmichel   # Vulnerability details  The `_calculatePrizeTierFraction` docs say "returns the fraction of the total prize (base 1e18)", but it's base 1e9. Code seems to be correct.  
# Handle  cmichel   # Vulnerability details  In `DrawCalculator._createBitMasks`, the bit masks can just be created by shifting the previous (potentially already shifted) masks by the bit range. It saves on multiplications and, for me, this is also more intuitive than the current algorithm.  Some pseudocode: ```solidity function _createBitMasks(IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution)     internal     pure     returns (uint256[] memory) {     uint256[] memory masks = new uint256[](_prizeDistribution.matchCardinality);     uint256 _bitRangeMaskValue = (2**_prizeDistribution.bitRangeSize) - 1; // get a decimal representation of bitRangeSize, for example 0xF for bitRangeSize = 4      if(_prizeDistribution.matchCardinality == 0) return masks;      masks[0] = _bitRangeMaskValue;     for (uint8 maskIndex = 1; maskIndex < _prizeDistribution.matchCardinality; maskIndex++) {         // shift by the "size" of the bit mask each time, 0xF, 0xF0, 0xF00, 0xF000, etc.         masks[maskIndex] = masks[maskIndex - 1] << _prizeDistribution.bitRangeSize;     }      return masks; } ```  
# Handle  cmichel   # Vulnerability details  If all masks match the `DrawCalculator._calculateTierIndex` function returns `masksLength - numberOfMatches` but it will always be zero at this point as `masksLength == numberOfMatches`. So just returning zero here would lead to saving a checked subtraction.  
# Handle  cmichel   # Vulnerability details  Description: `safeApprove` is now deprecated, see [this comment](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38).  ## Impact When using one of these unsupported tokens, all transactions revert and the protocol cannot be used.  ## Recommended Mitigation Steps As per OpenZepplin documentation “whenever possible, use `safeIncreaseAllowance` and `safeDecreaseAllowance` instead”.   
# Handle  gpersoon   # Vulnerability details  ## Impact In the contract PrizeSplit.sol, uint8 is used in a few places. This limits the addressable size of _prizeSplits.  In practice you would probably not split prizes in more than 256 ways, but checking for this is safer.  ## Proof of Concept https://github.com/pooltogether/v4-core/blob/master/contracts/prize-strategy/PrizeSplit.sol#L86-L87  function setPrizeSplit(PrizeSplitConfig memory _prizeSplit, uint8 _prizeSplitIndex)  https://github.com/pooltogether/v4-core/blob/master/contracts/prize-strategy/PrizeSplit.sol#L130-L140  for (uint8 index = 0; index < prizeSplitsLength; index++) {  ## Tools Used  ## Recommended Mitigation Steps Add the following  to function setPrizeSplits:    require(newPrizeSplitsLength <= type(uint8).max))  or replace uint8 with uint256 in PrizeSplit.sol   
# Handle  gpersoon   # Vulnerability details  ## Impact I've found some gas improvements for _transferTwab, see below.  ## Proof of Concept https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol#L296-L313  ## Tools Used  ## Recommended Mitigation Steps   function _transferTwab(address _from, address _to, uint256 _amount) internal {         if (_from==_to) return; // no need to transfer if both are the same         if (_from != address(0)) {             _decreaseUserTwab(_from, _amount);             if (_to == address(0)) _decreaseTotalSupplyTwab(_amount);         }                 if (_to != address(0)) {                     _increaseUserTwab(_to, _amount);             if (_from == address(0)) _increaseTotalSupplyTwab(_amount);         }     }  
# Handle  ye0lde   # Vulnerability details  ## Impact  Gas savings and code clarity  ## Proof of Concept  PrizePool.sol: https://github.com/pooltogether/v4-core/blob/35b00f710db422a6193131b7dc2de5202dc4677c/contracts/prize-pool/PrizePool.sol#L383-L387  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Replace this https://github.com/pooltogether/v4-core/blob/35b00f710db422a6193131b7dc2de5202dc4677c/contracts/prize-pool/PrizePool.sol#L383-L387 with <code> return (ticket == _controlledToken)  </code>  
# Handle  pants   # Vulnerability details  At lines 197,199 PrizeDistributionHistory for example, the value _prizeDistribution.distributions[index] is read twice from memory instead of caching it as a local variable distributions_index = _prizeDistribution.distributions[index]; and using it instead.  Same at DrawCalculator.sol at lines 312, 315, 319 (here _picks[index] is read 3 times)   
# Handle  leastwood   # Vulnerability details  ## Impact  The `_decreaseUserTwab()` function is used to decrease an account's TWAB balance when Ticket tokens are transferred between users or delegated to other users. If the amount to decrease exceeds the account's TWAB balance, the function will revert. However, this message does not fully reflect the function's behaviour.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol#L364  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the aforementioned revert message to correctly the function behaviour instead of a generic message.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `awardExternalERC721()` function uses solidity's try and catch statement to ensure a single tokenId cannot deny function execution. If the try statement fails, an `ErrorAwardingExternalERC721` event is emitted with the relevant error, however, the failed tokenId is not removed from the list of tokenIds emitted at the end of function execution. As a result, the `AwardedExternalERC721` is emitted with the entire list of tokenIds, regardless of failure.  An off-chain script or user could therefore be tricked into thinking an ERC721 tokenId was successfully awarded.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L250-L270  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider emitting only successfully transferred tokenIds in the `AwardedExternalERC721` event.  
# Handle  leastwood   # Vulnerability details  ## Impact  There are a couple of typos found within the `Reserve.sol` contract.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/Reserve.sol#L20 https://github.com/pooltogether/v4-core/blob/master/contracts/Reserve.sol#L21  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the typo in `Reserve.sol:L20` from `speicific` to `specific` and the typo in `Reserve.sol:L21` from `determininstially` to `deterministically`.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `_canAwardExternal()` function is used to prevent the `onlyPrizeStrategy` role from moving a yield source's deposit tokens. However, the `YieldSourcePrizePool.sol` contract only restricts the movement of tokens from the `yieldSource` address instead of the actual deposit token. As a result, the `onlyOwner` role could escalate its role by calling `PrizePool.setPrizeStrategy()` and setting the prize strategy to its own address. Once it has taken over this role, they could effectively transfer out the yield source's deposit tokens, thereby draining the contract.   This is in direct contrast to PoolTogether's ethos, whereby their docs state that the multisig account used to represent the `onlyOwner` role has no custody over deposited assets.  ## Proof of Concept  https://v4.docs.pooltogether.com/protocol/reference/launch-architecture#progressive-decentralization https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/YieldSourcePrizePool.sol#L55-L57 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L329-L343 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L228-L236 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L300-L302  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the `YieldSourcePrizePool._canAwardExternal()` function to restrict the prize strategy from withdrawing `yieldSource.depositToken()` instead.  
# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * function controllerBurnFrom could also skip _approve decrease if the current approval is uint max (unlimited).  * hardcoded number 1000 in PrizeSplit could be extracted to a constant variable to improve readability and maintainability.  
# Handle  pauliax   # Vulnerability details  ## Impact You can save some gas by using the 'unchecked' keyword to avoid redundant arithmetic checks when an underflow/overflow cannot happen. For example, here:   while (_prizeSplits.length > newPrizeSplitsLength) {     uint256 _index = _prizeSplits.length - 1; or here:         require(_accountDetails.balance >= _amount, _revertMessage);         ...         accountDetails.balance = _accountDetails.balance - _amount;  ## Recommended Mitigation Steps Consider applying 'unchecked' keyword where overflows/underflows are not possible.  
# Handle  pauliax   # Vulnerability details  ## Impact There are imports that are not necessary. They will increase the size of deployment with no real benefit. Consider removing them to save some gas.  Examples of such imports are: in contract DrawBuffer imported twice: import "./interfaces/IDrawBeacon.sol";  in contract DrawCalculator: import "./libraries/DrawRingBufferLib.sol"; import "./PrizeDistributor.sol";  in contract PrizeDistributor: import "./interfaces/IDrawBeacon.sol";  ## Recommended Mitigation Steps Consider removing imports that are not actually used in the contract.  
# Handle  pauliax   # Vulnerability details  ## Impact If you want to save some gas you can get rid of _getPrizeSplitAmount and calculate the split directly in _distributePrizeSplits as this function is internal and is only called once so there is no actual need for reusability here and removing this extra call will make the execution cheaper.  ## Recommended Mitigation Steps Consider moving the logic of _getPrizeSplitAmount  directly to _distributePrizeSplits.  
# Handle  pauliax   # Vulnerability details  ## Impact 'immutable' greatly reduces gas costs. There are variables that do not change so they can be marked as immutable to greatly improve the gas costs.  Examples of such variables are:  yieldSource in YieldSourcePrizePool.  prizePool in PrizeSplitStrategy.  controller in ControlledToken.  ## Recommended Mitigation Steps Consider applying immutable keyword to the variables that are assigned only once.  
# Handle  pauliax   # Vulnerability details  ## Impact Low-level calls like staticcall return true even if the account called is non-existent (per EVM design) so this hack in YieldSourcePrizePool constructor will not work in certain cases:         // A hack to determine whether it's an actual yield source         (bool succeeded, ) = address(_yieldSource).staticcall(             abi.encodePacked(_yieldSource.depositToken.selector)         );  You can try to pass an EOA address and see that it will return true.  ## Recommended Mitigation Steps Account existence must be checked prior to calling. A similar issue was submitted in a previous contest and assigned a severity of low, you can find more details here: https://github.com/code-423n4/2021-04-basedloans-findings/issues/16  
# Handle  pauliax   # Vulnerability details  ## Impact function calculateNextBeaconPeriodStartTime accepts _time as a type of uint256 but later explicitly casts it to uint64. While this function is not used internally, it behaves incorrectly when passed a value that uint64 does not hold (for such values it will return a max value of uint64). I don't see a reason why you can't directly accept uint64 here.  ## Recommended Mitigation Steps Change parameter type to uint64.  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-strategy/PrizeSplit.sol#L135-L136  ```solidity PrizeSplitConfig memory split = _prizeSplits[index]; _tempTotalPercentage = _tempTotalPercentage + split.percentage; ```  Only `percentage` of the `PrizeSplitConfig` struct is accessed, however, the current implementation created a memory variable that will load `_prizeSplits[index]` and copy to memory, this is unnecessary and gas inefficient.  ### Recommendation  Change to:  ```solidity _tempTotalPercentage = _tempTotalPercentage + split.percentage; ```  
# Handle  WatchPug   # Vulnerability details  ## Adding unchecked directive can save gas  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  1. `PrizePool.sol#award()`  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L210-L225  ```solidity function award(address _to, uint256 _amount) external override onlyPrizeStrategy {     if (_amount == 0) {         return;     }      uint256 currentAwardBalance = _currentAwardBalance;      require(_amount <= currentAwardBalance, "PrizePool/award-exceeds-avail");     _currentAwardBalance = currentAwardBalance - _amount;      ITicket _ticket = ticket;      _mint(_to, _amount, _ticket);      emit Awarded(_to, _ticket, _amount); } ```  `currentAwardBalance - _amount;` will never underflow.   2. `PrizeDistributor.sol#claim()`  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/PrizeDistributor.sol#L74-L77  ```solidity if (payout > oldPayout) {     payoutDiff = payout - oldPayout;     _setDrawPayoutBalanceOf(_user, drawId, payout); } ```  `payout - oldPayout` will never underflow.  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L361-L368  ```solidity function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {     ITicket _ticket = ticket;     uint256 _balanceCap = balanceCap;      if (_balanceCap == type(uint256).max) return true;      return (_ticket.balanceOf(_user) + _amount <= _balanceCap); } ```  `ITicket _ticket = ticket;` is redundant, removing it will also avoid a `sload` if returned when `_balanceCap == type(uint256).max`.  ### Recommendation  Change to:  ```solidity function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {      uint256 _balanceCap = balanceCap;      if (_balanceCap == type(uint256).max) return true;      return (ticket.balanceOf(_user) + _amount <= _balanceCap); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L284-L297  ```solidity function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {     address _ticketAddress = address(_ticket);      require(_ticketAddress != address(0), "PrizePool/ticket-not-zero-address"); ... ```  `_ticketAddress` is unnecessary as it's being used only once.  ### Recommendation  Change to:  ```solidity function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {     require(address(_ticket) != address(0), "PrizePool/ticket-not-zero-address"); ... ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-strategy/PrizeSplitStrategy.sol#L51-L61  ```solidity function distribute() external override returns (uint256) {     uint256 prize = prizePool.captureAwardBalance();      if (prize == 0) return 0;      _distributePrizeSplits(prize);      emit Distributed(prize);      return prize; } ```  Based on the context, the value of the parameter of the `Distributed` event should be the distributed prize amount, which can be calculated based on the return value of `_distributePrizeSplits`.  ### Recommendation  Change to:  ```solidity  event Distributed(uint256 totalPrizeCaptured, uint256 totalPrizeDistributed);  function distribute() external override returns (uint256) {     uint256 prize = prizePool.captureAwardBalance();      if (prize == 0) return 0;      uint remainingPrize = _distributePrizeSplits(prize);      emit Distributed(prize, prize - remainingPrize);      return prize; } ```  
# Handle  WatchPug   # Vulnerability details  The formula of the number of prizes for a degree per the document: https://v4.docs.pooltogether.com/protocol/concepts/prize-distribution/#splitting-the-prizes is: ``` Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) - (2^bit range)^(degree-2) - ... ``` Should be changed to: ``` Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) ``` or ``` Number of prizes for a degree = 2^(bit range * degree) - 2^(bit range * (degree-1)) ```  ### Impact  Per the document:  > prize for a degree = total prize * degree percentage / number of prizes for a degree  Due to the miscalculation of `number of prizes for a degree`, it will be smaller than expected, as a result, `prize for a degree` will be larger than expected. Making the protocol giving out more prizes than designed.  ### Proof  > We will use `f(bitRange, degree)` to represent `numberOfPrizesForDegree(bitRangeSize, degree)`.  #### Proof: (method 1)  ```tex 2 ^ {bitRange \times n} = f(bitRange, n) + f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) f(bitRange, n) = 2 ^ {bitRange \times n} - ( f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) ) f(bitRange, n) = 2 ^ {bitRange \times n} - f(bitRange, n-1) - ( f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )  Because:  2 ^ {bitRange \times (n-1)} = f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) 2 ^ {bitRange \times (n-1)} - f(bitRange, n-1) = f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)  Therefore:  f(bitRange, n) = 2 ^ {bitRange \times n} - f(bitRange, n-1) - ( 2 ^ {bitRange \times (n-1)} - f(bitRange, n-1) ) f(bitRange, n) = 2 ^ {bitRange \times n} - f(bitRange, n-1) - 2 ^ {bitRange \times (n-1)} + f(bitRange, n-1) f(bitRange, n) = 2 ^ {bitRange \times n} - 2 ^ {bitRange \times (n-1)} ```  Because `2^x = 1 << x`  Therefore, when `n > 0`:  ``` f(bitRange, n) = ( 1 << bitRange * n ) - ( 1 << bitRange * (n - 1) ) ```  QED.  #### Proof: (method 2)  By definition, `degree n` is constructed by 3 chunks:  -  The first N numbers, must equal the matching numbers. Number of possible values: `1`; -  The N-th number, must not equal the N-th matching number. Number of possible values: `2^bitRange - 1` -  From N (not include) until the end. Number of possible values: `2 ^ (bitRange * (n-1))`  Therefore, total `numberOfPrizesForDegree` will be:  ```tex f(bitRange, n) = (2 ^ {bitRange} - 1) \times 2 ^ {bitRange \times (n - 1)} f(bitRange, n) = 2 ^ {bitRange} \times 2 ^ {bitRange \times (n - 1)} - 2 ^ {bitRange \times (n - 1)} f(bitRange, n) = 2 ^ {bitRange + bitRange \times (n - 1)} - 2 ^ {bitRange \times (n - 1)} f(bitRange, n) = 2 ^ {bitRange + bitRange \times n - bitRange} - 2 ^ {bitRange \times (n - 1)} f(bitRange, n) = 2 ^ {bitRange \times n} - 2 ^ {bitRange \times (n - 1)} ```  QED.  ### Recommendation  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/DrawCalculator.sol#L423-L431   ```solidity=412{423-431} /**     * @notice Calculates the number of prizes for a given prizeDistributionIndex     * @param _bitRangeSize Bit range size for Draw     * @param _prizeTierIndex Index of the prize tier array to calculate     * @return returns the fraction of the total prize (base 1e18)     */ function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)     internal     pure     returns (uint256) {     uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);     uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;      while (_prizeTierIndex > 0) {         numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);         _prizeTierIndex--;     }      return numberOfPrizesForIndex; } ```  L423-431 should change to:  ```solidity if (_prizeTierIndex > 0) {     return ( 1 << _bitRangeSize * _prizeTierIndex ) - ( 1 << _bitRangeSize * (_prizeTierIndex - 1) ); } else {     return 1; } ```  BTW, the comment on L416 is wrong:  - seems like it's copied from _calculatePrizeTierFraction() - plus, it's not base 1e18 but base 1e9  
# Handle  cmichel   # Vulnerability details  The `PrizePool.captureAwardBalance` function always sets `_currentAwardBalance = currentAwardBalance` where `currentAwardBalance = currentAwardBalance + unaccountedPrizeBalance = currentAwardBalance + totalInterest - currentAwardBalance = totalInterest`.  Save a checked math addition by just setting `_currentAwardBalance = totalInterest` immediately.  
# Handle  cmichel   # Vulnerability details  The `PrizePool` defines `using SafeERC20 for IERC721;` which means the `SafeERC20.safeTransferFrom` function will be used in `awardExternalERC721`. However, this function is just a wrapper for `contract.transferFrom` with a return-value and success check.  Thus this call actually calls `ERC721.transferFrom` instead of `ERC721.safeTransferFrom` and does not call the important `onERC721Received` check for contracts.  ## Impact ERC721s can be awarded to contracts that don't know how to handle it and they can get stuck.  ## Recommended Mitigation Steps Remove the `using SafeERC20 for IERC721;` line.   
# Handle  cmichel   # Vulnerability details  The `Reserve` does not correctly use ring buffers to get the oldest / newest elements if the array is full (observations larger than cardinality) in which case it should wrap around.  `getReserveAccumulatedBetween` always picks `reserveAccumulators[_cardinality - 1]`. `_checkpoint` tries to write to `reserveAccumulators[cardinality++]` which will break once `cardinality` reaches `MAX_CARDINALITY`.  The `TwabLib` library has a correct `oldestTwab/newestTwab` implementation using the `RingBufferLib` that wraps around if needed.  ## Impact Anyone can send 1 wei to the reserve and call `checkpoint` on it until the `MAX_CARDINALITY` is reached. Afterwards, trying to write any new checkpoints will fail as `_checkpoint` now tries to write to `cardinality=MAX_CARDINALITY+1` which is out of bounds of the `reserveAccumulators`.  The reserve is broken and cannot withdraw funds anymore. The gas costs for such an attack are very high and would take ~7 years if writing every block, making it probably not worth fixing.  ## Recommended Mitigation Steps Correctly implement the ring buffer usage like in `TwabLib`.   
# Handle  cmichel   # Vulnerability details  The `_calculatePrizeTierFraction` docs say "returns the fraction of the total prize (base 1e18)", but it's base 1e9. Code seems to be correct.  
# Handle  cmichel   # Vulnerability details  In `DrawCalculator._createBitMasks`, the bit masks can just be created by shifting the previous (potentially already shifted) masks by the bit range. It saves on multiplications and, for me, this is also more intuitive than the current algorithm.  Some pseudocode: ```solidity function _createBitMasks(IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution)     internal     pure     returns (uint256[] memory) {     uint256[] memory masks = new uint256[](_prizeDistribution.matchCardinality);     uint256 _bitRangeMaskValue = (2**_prizeDistribution.bitRangeSize) - 1; // get a decimal representation of bitRangeSize, for example 0xF for bitRangeSize = 4      if(_prizeDistribution.matchCardinality == 0) return masks;      masks[0] = _bitRangeMaskValue;     for (uint8 maskIndex = 1; maskIndex < _prizeDistribution.matchCardinality; maskIndex++) {         // shift by the "size" of the bit mask each time, 0xF, 0xF0, 0xF00, 0xF000, etc.         masks[maskIndex] = masks[maskIndex - 1] << _prizeDistribution.bitRangeSize;     }      return masks; } ```  
# Handle  cmichel   # Vulnerability details  If all masks match the `DrawCalculator._calculateTierIndex` function returns `masksLength - numberOfMatches` but it will always be zero at this point as `masksLength == numberOfMatches`. So just returning zero here would lead to saving a checked subtraction.  
# Handle  cmichel   # Vulnerability details  Description: `safeApprove` is now deprecated, see [this comment](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38).  ## Impact When using one of these unsupported tokens, all transactions revert and the protocol cannot be used.  ## Recommended Mitigation Steps As per OpenZepplin documentation “whenever possible, use `safeIncreaseAllowance` and `safeDecreaseAllowance` instead”.   
# Handle  gpersoon   # Vulnerability details  ## Impact In the contract PrizeSplit.sol, uint8 is used in a few places. This limits the addressable size of _prizeSplits.  In practice you would probably not split prizes in more than 256 ways, but checking for this is safer.  ## Proof of Concept https://github.com/pooltogether/v4-core/blob/master/contracts/prize-strategy/PrizeSplit.sol#L86-L87  function setPrizeSplit(PrizeSplitConfig memory _prizeSplit, uint8 _prizeSplitIndex)  https://github.com/pooltogether/v4-core/blob/master/contracts/prize-strategy/PrizeSplit.sol#L130-L140  for (uint8 index = 0; index < prizeSplitsLength; index++) {  ## Tools Used  ## Recommended Mitigation Steps Add the following  to function setPrizeSplits:    require(newPrizeSplitsLength <= type(uint8).max))  or replace uint8 with uint256 in PrizeSplit.sol   
# Handle  gpersoon   # Vulnerability details  ## Impact I've found some gas improvements for _transferTwab, see below.  ## Proof of Concept https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol#L296-L313  ## Tools Used  ## Recommended Mitigation Steps   function _transferTwab(address _from, address _to, uint256 _amount) internal {         if (_from==_to) return; // no need to transfer if both are the same         if (_from != address(0)) {             _decreaseUserTwab(_from, _amount);             if (_to == address(0)) _decreaseTotalSupplyTwab(_amount);         }                 if (_to != address(0)) {                     _increaseUserTwab(_to, _amount);             if (_from == address(0)) _increaseTotalSupplyTwab(_amount);         }     }  
# Handle  ye0lde   # Vulnerability details  ## Impact  Gas savings and code clarity  ## Proof of Concept  PrizePool.sol: https://github.com/pooltogether/v4-core/blob/35b00f710db422a6193131b7dc2de5202dc4677c/contracts/prize-pool/PrizePool.sol#L383-L387  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Replace this https://github.com/pooltogether/v4-core/blob/35b00f710db422a6193131b7dc2de5202dc4677c/contracts/prize-pool/PrizePool.sol#L383-L387 with <code> return (ticket == _controlledToken)  </code>  
# Handle  pants   # Vulnerability details  At lines 197,199 PrizeDistributionHistory for example, the value _prizeDistribution.distributions[index] is read twice from memory instead of caching it as a local variable distributions_index = _prizeDistribution.distributions[index]; and using it instead.  Same at DrawCalculator.sol at lines 312, 315, 319 (here _picks[index] is read 3 times)   
