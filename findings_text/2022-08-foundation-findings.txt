# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L207   # Vulnerability details  # Malicious Creator can steal from collectors upon minting with a custom NFT contract  In the case of a fixed price sale where `nftContract` is a custom NFT contract that adheres to `INFTDropCollectionMint`, a malicious creator can set a malicious implementation of `INFTDropCollectionMint.mintCountTo()` that would result in collectors calling this function losing funds without receiving the expected amount of NFTs.  ## Impact  Medium   ## Proof Of Concept  Here is a [foundry test](https://gist.github.com/joestakey/4b13c7ae6029332da6eaf63b9d2a38bd) that shows a fixed price sale with a malicious NFT contract, where a collector pays for 10 NFTs while only receiving one. It can be described as follow:  - A creator creates a malicious `nftContract` with `mintCountTo` minting only one NFT per call, regardless of the value of `count`  - The creator calls `NFTDropMarketFixedPriceSale.createFixedPriceSale()` to create a sale for `nftContract`, with `limit` set to `15`.  - Bob is monitoring the `CreateFixedPriceSale` event. Upon noticing `CreateFixedPriceSale(customERC721, Alice, price, limit)`, he calls `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale(customERC721, count == 10,)`. He pays the price of `count = 10` NFTs, but because of the logic in `mintCountTo`, only receives one NFT.  Note that `mintCountTo` can be implemented in many malicious ways, this is only one example. Another implementation could simply return `firstTokenId` without performing any minting.  ## Tools Used  Manual Analysis, Foundry  ## Mitigation  The problem here lies in the implementation of `INFTDropCollectionMint(nftContract).mintCountTo()`. You could add an additional check in `NFTDropMarketFixedPriceSale.mintCountTo()` using `ERC721(nftContract).balanceOf()`.   ```diff + uint256 balanceBefore = IERC721(nftContract).balanceOf(msg.sender); 207:     firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender); + uint256 balanceAfter = IERC721(nftContract).balanceOf(msg.sender); + require(balanceAfter == balanceBefore + count, "minting failed") ``` 
# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274 https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187   # Vulnerability details  ## Impact When calling the following `_mint` or `mintCountTo` function for minting an NFT of a NFT collection or NFT drop collection, the OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function is used to mint the NFT to a receiver. If such receiver is a contract that does not support the ERC721 protocol, the NFT will be locked and cannot be retrieved.  https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274 ```   function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {     require(bytes(tokenCID).length != 0, "NFTCollection: tokenCID is required");     require(!cidToMinted[tokenCID], "NFTCollection: NFT was already minted");     unchecked {       // Number of tokens cannot overflow 256 bits.       tokenId = ++latestTokenId;       require(maxTokenId == 0 || tokenId <= maxTokenId, "NFTCollection: Max token count has already been minted");       cidToMinted[tokenCID] = true;       _tokenCIDs[tokenId] = tokenCID;       _mint(msg.sender, tokenId);       emit Minted(msg.sender, tokenId, tokenCID, tokenCID);     }   } ```  https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187 ```   function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {     require(count != 0, "NFTDropCollection: `count` must be greater than 0");      unchecked {       // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits       firstTokenId = latestTokenId + 1;     }     latestTokenId = latestTokenId + count;     require(latestTokenId <= maxTokenId, "NFTDropCollection: Exceeds max tokenId");      for (uint256 i = firstTokenId; i <= latestTokenId; ) {       _mint(to, i);       unchecked {         ++i;       }     }   } ```  For reference, [OpenZeppelin's documentation for `_mint`](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721-_mint-address-uint256-) states: "Usage of this method is discouraged, use _safeMint whenever possible".  ## Proof of Concept The following steps can occur when minting an NFT of a NFT collection or NFT drop collection. 1. The [`_mint`](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274) or [`mintCountTo`](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187) function is called with `msg.sender` or the `to` input corresponding to a contract. 2. The OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function is called with `msg.sender` or `to` used in Step 1 as the receiver address. 3. Since calling the OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function does not execute the same contract's [`_checkOnERC721Received`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L400-L422) function, it is unknown if the receiving contract inherits from the `IERC721ReceiverUpgradeable` interface and implements the `onERC721Received` function or not. It is possible that the receiving contract does not support the ERC721 protocol, which causes the minted NFT to be locked.  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L271 can be changed to the following code. ``` _safeMint(msg.sender, tokenId); ```  Also, https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L182 can be changed to the following code. ``` _safeMint(to, i); ```
# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L130   # Vulnerability details  ## Impact  Selling a NFT with `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale` distributes the revenue from the sale to various recipients with the `MarketFees._distributeFunds` function.  Recipients:  - NFT creator(s) - NFT seller - Protocol - Buy referrer (optional)  It is possible to have multiple NFT creators. Sale revenue will be distributed to each NFT creator address. Revenue distribution is done by calling `SendValueWithFallbackWithdraw._sendValueWithFallbackWithdraw` and providing an appropriate gas limit to prevent consuming too much gas. For the revenue distribution to the seller, protocol and the buy referrer, a gas limit of `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20_000` is used. However, for the creators, a limit of `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000` is used. This higher amount of gas is used if `PercentSplitETH` is used as a recipient.  A maximum of `MAX_ROYALTY_RECIPIENTS = 5` NFT creator recipients are allowed.  For example, a once honest NFT collection and its 5 royalty creator recipients could turn "malicious" and could "steal" gas from NFT buyers on each NFT sale and therefore grief NFT sales. On each NFT sell, the 5 creator recipients (smart contracts) could consume the full amount of `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000` forwarded gas. Totalling `5 * 210_000 = 1_050_000` gas. With a gas price of e.g. `20 gwei`, this equals to additional gas costs of `21_000_000 gwei = 0.028156 eth`, with a `ETH` price of `2000`, this would total to ~`56.31 $` additional costs.  ## Proof of Concept  [mixins/shared/MarketFees.sol#L130](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L130)  ```solidity /**   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.   */ function _distributeFunds(   address nftContract,   uint256 tokenId,   address payable seller,   uint256 price,   address payable buyReferrer )   internal   returns (     uint256 totalFees,     uint256 creatorRev,     uint256 sellerRev   ) {   address payable[] memory creatorRecipients;   uint256[] memory creatorShares;    uint256 buyReferrerFee;   (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(     nftContract,     tokenId,     seller,     price,     buyReferrer   );    // Pay the creator(s)   unchecked {     for (uint256 i = 0; i < creatorRecipients.length; ++i) {       _sendValueWithFallbackWithdraw(         creatorRecipients[i],         creatorShares[i],         SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS // @audit-info A higher amount of gas is forwarded to creator recipients       );       // Sum the total creator rev from shares       // creatorShares is in ETH so creatorRev will not overflow here.       creatorRev += creatorShares[i];     }   }    // Pay the seller   _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);    // Pay the protocol fee   _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);    // Pay the buy referrer fee   if (buyReferrerFee != 0) {     _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);     emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);     unchecked {       // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events       totalFees += buyReferrerFee;     }   } } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider only providing a higher amount of gas (`SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS`) for the first creator recipient. For all following creator recipients, only forward the reduced amount of gas `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT`. 
# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L299-L301   # Vulnerability details  ## Impact Wrong return of `cretorShares` and `creatorRecipients` can make real royalties party can't gain the revenue of sale.    ## Proof of concept  Function `getFees()` firstly [call](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L422-L430) to function `internalGetImmutableRoyalties` to get the list of `creatorRecipients` and `creatorShares` if the `nftContract` define ERC2981 royalties.  ```solidity= try implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (   address payable[] memory _recipients,   uint256[] memory _splitPerRecipientInBasisPoints ) {   (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints); } catch // solhint-disable-next-line no-empty-blocks {   // Fall through } ``` ----- In the [1st priority](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L236-L255) it check the `nftContract` define the function `royaltyInfo` or not. If yes, it get the return value `receiver` and `royaltyAmount`. In some manifold contracts of erc2981, it `return (address(this), 0)` when royalties are not defined. So we ignore it when the `royaltyAmount = 0`  ```solidity=   try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (     address receiver,     uint256 royaltyAmount   ) {     // Manifold contracts return (address(this), 0) when royalties are not defined     // - so ignore results when the amount is 0     if (royaltyAmount > 0) {       recipients = new address payable[](1);       recipients[0] = payable(receiver);       splitPerRecipientInBasisPoints = new uint256[](1);       // The split amount is assumed to be 100% when only 1 recipient is returned       return (recipients, splitPerRecipientInBasisPoints);     } ``` ---- In the same sense, the [3rd priority](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L297-L312) (it can reach to 3rd priority when function `internalGetImmutableRoyalies` fail to return some royalties) should check same as the 1st priority with the `royaltyRegistry.getRoyaltyLookupAddress`. But the 3rd priority forget to check the case when `royaltyAmount == 0`.  ```solidity=   try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (     address receiver,     uint256 /* royaltyAmount */   ) {     recipients = new address payable[](1);     recipients[0] = payable(receiver);     splitPerRecipientInBasisPoints = new uint256[](1);     // The split amount is assumed to be 100% when only 1 recipient is returned     return (recipients, splitPerRecipientInBasisPoints);   }  ``` It will make [function](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L98) `_distributeFunds()` transfer to wrong `creatorRecipients` (for example erc2981 return `(address(this), 0)`, market will transfer creator revenue to `address(this)` - market contract, and make the fund freeze in contract forever).  This case just happen when * `nftContract` doesn't have any support for royalties info  * `overrideContract` which was fetched from`royaltyRegistry.getRoyaltyLookupAddress(nftContract)` implements both function `getRoyalties` and `royaltyInfo` but doesn't support `royaltyInfo` by returning `(address(this), 0)`.   ## Tools Used Manual review     ## Recommended Mitigation Steps Add check if `royaltyAmount > 0` or not in 3rd priority  
# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/7d6392498e8f3b8cdc22beb582188ffb3ed25790/contracts/mixins/shared/MarketFees.sol#L128   # Vulnerability details  ## Impact `royaltyInfo`, `getRoyalties`, or `getFeeRecipients` may return `address(0)` as the recipient address. While the value 0 is correctly handled for the royalties itself, it is not for the address. In such a case, the ETH amount will be sent to `address(0)`, i.e. it is burned and lost.  ## Recommended Mitigation Steps In your logic for determining the recipients, treat `address(0)` as if no recipient was returned such that the other priorities / methods take over.
# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L207   # Vulnerability details  # Malicious Creator can steal from collectors upon minting with a custom NFT contract  In the case of a fixed price sale where `nftContract` is a custom NFT contract that adheres to `INFTDropCollectionMint`, a malicious creator can set a malicious implementation of `INFTDropCollectionMint.mintCountTo()` that would result in collectors calling this function losing funds without receiving the expected amount of NFTs.  ## Impact  Medium   ## Proof Of Concept  Here is a [foundry test](https://gist.github.com/joestakey/4b13c7ae6029332da6eaf63b9d2a38bd) that shows a fixed price sale with a malicious NFT contract, where a collector pays for 10 NFTs while only receiving one. It can be described as follow:  - A creator creates a malicious `nftContract` with `mintCountTo` minting only one NFT per call, regardless of the value of `count`  - The creator calls `NFTDropMarketFixedPriceSale.createFixedPriceSale()` to create a sale for `nftContract`, with `limit` set to `15`.  - Bob is monitoring the `CreateFixedPriceSale` event. Upon noticing `CreateFixedPriceSale(customERC721, Alice, price, limit)`, he calls `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale(customERC721, count == 10,)`. He pays the price of `count = 10` NFTs, but because of the logic in `mintCountTo`, only receives one NFT.  Note that `mintCountTo` can be implemented in many malicious ways, this is only one example. Another implementation could simply return `firstTokenId` without performing any minting.  ## Tools Used  Manual Analysis, Foundry  ## Mitigation  The problem here lies in the implementation of `INFTDropCollectionMint(nftContract).mintCountTo()`. You could add an additional check in `NFTDropMarketFixedPriceSale.mintCountTo()` using `ERC721(nftContract).balanceOf()`.   ```diff + uint256 balanceBefore = IERC721(nftContract).balanceOf(msg.sender); 207:     firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender); + uint256 balanceAfter = IERC721(nftContract).balanceOf(msg.sender); + require(balanceAfter == balanceBefore + count, "minting failed") ``` 
# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274 https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187   # Vulnerability details  ## Impact When calling the following `_mint` or `mintCountTo` function for minting an NFT of a NFT collection or NFT drop collection, the OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function is used to mint the NFT to a receiver. If such receiver is a contract that does not support the ERC721 protocol, the NFT will be locked and cannot be retrieved.  https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274 ```   function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {     require(bytes(tokenCID).length != 0, "NFTCollection: tokenCID is required");     require(!cidToMinted[tokenCID], "NFTCollection: NFT was already minted");     unchecked {       // Number of tokens cannot overflow 256 bits.       tokenId = ++latestTokenId;       require(maxTokenId == 0 || tokenId <= maxTokenId, "NFTCollection: Max token count has already been minted");       cidToMinted[tokenCID] = true;       _tokenCIDs[tokenId] = tokenCID;       _mint(msg.sender, tokenId);       emit Minted(msg.sender, tokenId, tokenCID, tokenCID);     }   } ```  https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187 ```   function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {     require(count != 0, "NFTDropCollection: `count` must be greater than 0");      unchecked {       // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits       firstTokenId = latestTokenId + 1;     }     latestTokenId = latestTokenId + count;     require(latestTokenId <= maxTokenId, "NFTDropCollection: Exceeds max tokenId");      for (uint256 i = firstTokenId; i <= latestTokenId; ) {       _mint(to, i);       unchecked {         ++i;       }     }   } ```  For reference, [OpenZeppelin's documentation for `_mint`](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721-_mint-address-uint256-) states: "Usage of this method is discouraged, use _safeMint whenever possible".  ## Proof of Concept The following steps can occur when minting an NFT of a NFT collection or NFT drop collection. 1. The [`_mint`](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274) or [`mintCountTo`](https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187) function is called with `msg.sender` or the `to` input corresponding to a contract. 2. The OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function is called with `msg.sender` or `to` used in Step 1 as the receiver address. 3. Since calling the OpenZeppelin's `ERC721Upgradeable` contract's [`_mint`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function does not execute the same contract's [`_checkOnERC721Received`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L400-L422) function, it is unknown if the receiving contract inherits from the `IERC721ReceiverUpgradeable` interface and implements the `onERC721Received` function or not. It is possible that the receiving contract does not support the ERC721 protocol, which causes the minted NFT to be locked.  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L271 can be changed to the following code. ``` _safeMint(msg.sender, tokenId); ```  Also, https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L182 can be changed to the following code. ``` _safeMint(to, i); ```
# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L130   # Vulnerability details  ## Impact  Selling a NFT with `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale` distributes the revenue from the sale to various recipients with the `MarketFees._distributeFunds` function.  Recipients:  - NFT creator(s) - NFT seller - Protocol - Buy referrer (optional)  It is possible to have multiple NFT creators. Sale revenue will be distributed to each NFT creator address. Revenue distribution is done by calling `SendValueWithFallbackWithdraw._sendValueWithFallbackWithdraw` and providing an appropriate gas limit to prevent consuming too much gas. For the revenue distribution to the seller, protocol and the buy referrer, a gas limit of `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20_000` is used. However, for the creators, a limit of `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000` is used. This higher amount of gas is used if `PercentSplitETH` is used as a recipient.  A maximum of `MAX_ROYALTY_RECIPIENTS = 5` NFT creator recipients are allowed.  For example, a once honest NFT collection and its 5 royalty creator recipients could turn "malicious" and could "steal" gas from NFT buyers on each NFT sale and therefore grief NFT sales. On each NFT sell, the 5 creator recipients (smart contracts) could consume the full amount of `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000` forwarded gas. Totalling `5 * 210_000 = 1_050_000` gas. With a gas price of e.g. `20 gwei`, this equals to additional gas costs of `21_000_000 gwei = 0.028156 eth`, with a `ETH` price of `2000`, this would total to ~`56.31 $` additional costs.  ## Proof of Concept  [mixins/shared/MarketFees.sol#L130](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L130)  ```solidity /**   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.   */ function _distributeFunds(   address nftContract,   uint256 tokenId,   address payable seller,   uint256 price,   address payable buyReferrer )   internal   returns (     uint256 totalFees,     uint256 creatorRev,     uint256 sellerRev   ) {   address payable[] memory creatorRecipients;   uint256[] memory creatorShares;    uint256 buyReferrerFee;   (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(     nftContract,     tokenId,     seller,     price,     buyReferrer   );    // Pay the creator(s)   unchecked {     for (uint256 i = 0; i < creatorRecipients.length; ++i) {       _sendValueWithFallbackWithdraw(         creatorRecipients[i],         creatorShares[i],         SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS // @audit-info A higher amount of gas is forwarded to creator recipients       );       // Sum the total creator rev from shares       // creatorShares is in ETH so creatorRev will not overflow here.       creatorRev += creatorShares[i];     }   }    // Pay the seller   _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);    // Pay the protocol fee   _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);    // Pay the buy referrer fee   if (buyReferrerFee != 0) {     _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);     emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);     unchecked {       // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events       totalFees += buyReferrerFee;     }   } } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider only providing a higher amount of gas (`SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS`) for the first creator recipient. For all following creator recipients, only forward the reduced amount of gas `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT`. 
# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L299-L301   # Vulnerability details  ## Impact Wrong return of `cretorShares` and `creatorRecipients` can make real royalties party can't gain the revenue of sale.    ## Proof of concept  Function `getFees()` firstly [call](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L422-L430) to function `internalGetImmutableRoyalties` to get the list of `creatorRecipients` and `creatorShares` if the `nftContract` define ERC2981 royalties.  ```solidity= try implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (   address payable[] memory _recipients,   uint256[] memory _splitPerRecipientInBasisPoints ) {   (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints); } catch // solhint-disable-next-line no-empty-blocks {   // Fall through } ``` ----- In the [1st priority](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L236-L255) it check the `nftContract` define the function `royaltyInfo` or not. If yes, it get the return value `receiver` and `royaltyAmount`. In some manifold contracts of erc2981, it `return (address(this), 0)` when royalties are not defined. So we ignore it when the `royaltyAmount = 0`  ```solidity=   try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (     address receiver,     uint256 royaltyAmount   ) {     // Manifold contracts return (address(this), 0) when royalties are not defined     // - so ignore results when the amount is 0     if (royaltyAmount > 0) {       recipients = new address payable[](1);       recipients[0] = payable(receiver);       splitPerRecipientInBasisPoints = new uint256[](1);       // The split amount is assumed to be 100% when only 1 recipient is returned       return (recipients, splitPerRecipientInBasisPoints);     } ``` ---- In the same sense, the [3rd priority](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L297-L312) (it can reach to 3rd priority when function `internalGetImmutableRoyalies` fail to return some royalties) should check same as the 1st priority with the `royaltyRegistry.getRoyaltyLookupAddress`. But the 3rd priority forget to check the case when `royaltyAmount == 0`.  ```solidity=   try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (     address receiver,     uint256 /* royaltyAmount */   ) {     recipients = new address payable[](1);     recipients[0] = payable(receiver);     splitPerRecipientInBasisPoints = new uint256[](1);     // The split amount is assumed to be 100% when only 1 recipient is returned     return (recipients, splitPerRecipientInBasisPoints);   }  ``` It will make [function](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L98) `_distributeFunds()` transfer to wrong `creatorRecipients` (for example erc2981 return `(address(this), 0)`, market will transfer creator revenue to `address(this)` - market contract, and make the fund freeze in contract forever).  This case just happen when * `nftContract` doesn't have any support for royalties info  * `overrideContract` which was fetched from`royaltyRegistry.getRoyaltyLookupAddress(nftContract)` implements both function `getRoyalties` and `royaltyInfo` but doesn't support `royaltyInfo` by returning `(address(this), 0)`.   ## Tools Used Manual review     ## Recommended Mitigation Steps Add check if `royaltyAmount > 0` or not in 3rd priority  
# Lines of code  https://github.com/code-423n4/2022-08-foundation/blob/7d6392498e8f3b8cdc22beb582188ffb3ed25790/contracts/mixins/shared/MarketFees.sol#L128   # Vulnerability details  ## Impact `royaltyInfo`, `getRoyalties`, or `getFeeRecipients` may return `address(0)` as the recipient address. While the value 0 is correctly handled for the royalties itself, it is not for the address. In such a case, the ETH amount will be sent to `address(0)`, i.e. it is burned and lost.  ## Recommended Mitigation Steps In your logic for determining the recipients, treat `address(0)` as if no recipient was returned such that the other priorities / methods take over.
