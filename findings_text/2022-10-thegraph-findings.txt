# Lines of code  https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/gateway/L2GraphTokenGateway.sol#L70   # Vulnerability details  ## Description  L2GraphTokenGateway uses the onlyL1Counterpart modifier to make sure finalizeInboundTransfer is only called from L1GraphTokenGateway. Its implementation is:  ```Solidity modifier onlyL1Counterpart() {         require(             msg.sender == AddressAliasHelper.applyL1ToL2Alias(l1Counterpart),             "ONLY_COUNTERPART_GATEWAY"         );         _;     } ```  It uses applyL1ToL2Alias defined as:  ``` uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);      /// @notice Utility function that converts the address in the L1 that submitted a tx to     /// the inbox to the msg.sender viewed in the L2     /// @param l1Address the address in the L1 that triggered the tx to L2     /// @return l2Address L2 address as viewed in msg.sender     function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {         l2Address = address(uint160(l1Address) + offset);     } ```  This behavior matches with how Arbitrum augments the sender's address to L2. The issue is that I've spoken with the team and they are [planning](https://github.com/graphprotocol/contracts/pull/725) an upgrade from Solidity 0.7.6 to 0.8.0. Their proposed [changes](https://github.com/graphprotocol/contracts/blob/c4d3cb56cb4032dbb3a0f1b7535b5d94ccf86222/contracts/arbitrum/AddressAliasHelper.sol) will break this function, because under 0.8.0, this line has a ~ 1/15 chance to overflow:  `l2Address = address(uint160(l1Address) + offset);`  Interestingly, the sum intentionally wraps around using the uint160 type to return a correct address, but this wrapping will overflow in 0.8.0  ## Impact  There is a ~6.5% chance that finalizeInboundTransfer will not work.  ## Proof of Concept  l1Address is L1GraphTokenGateway, suppose its address is 0xF000000000000000000000000000000000000000.  Then 0xF000000000000000000000000000000000000000 + 0x1111000000000000000000000000000000001111 > UINT160_MAX , meaning overflow.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Wrap the calculation in an unchecked block, which will make it behave correctly.
# Lines of code  https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/gateway/L2GraphTokenGateway.sol#L87 https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/token/L2GraphToken.sol#L48 https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/L1GraphTokenGateway.sol#L99 https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/BridgeEscrow.sol#L20   # Vulnerability details  ## Impact  initialize function in L2GraphToken.sol, BridgeEscrow.sol, L2GraphTokenGateway.sol, L1GraphTokenGateway.sol   can be invoked multiple times from the implementation contract.  this means a compromised implementation can reinitialize the contract above and   become the owner to complete the privilege escalation then drain the user's fund.  Usually in Upgradeable contract, a initialize function is protected by the modifier  ```solidity  initializer ```  to make sure the contract can only be initialized once.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  1. The implementation contract is compromised,  2. The attacker reinitialize the BridgeEscrow contract  ```     function initialize(address _controller) external onlyImpl {         Managed._initialize(_controller);     } ```  the onlyGovernor modifier's result depends on the controller because  ```solidity     function _onlyGovernor() internal view {         require(msg.sender == controller.getGovernor(), "Caller must be Controller governor");     } ```  3. The attacker have the governor access to the BridgeEscrow,   4. The attack can call the approve function to approve malicious contract   ```solidity      function approveAll(address _spender) external onlyGovernor {         graphToken().approve(_spender, type(uint256).max);     } ```  5. The attack can drain all the GRT token from the BridgeEscrow.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the project use the modifier   ```solidity  initializer ```  to protect the initialize function from being reinitiated  ```solidity    function initialize(address _owner) external onlyImpl initializer  { ``` 
# Lines of code  https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/gateway/L2GraphTokenGateway.sol#L70   # Vulnerability details  ## Description  L2GraphTokenGateway uses the onlyL1Counterpart modifier to make sure finalizeInboundTransfer is only called from L1GraphTokenGateway. Its implementation is:  ```Solidity modifier onlyL1Counterpart() {         require(             msg.sender == AddressAliasHelper.applyL1ToL2Alias(l1Counterpart),             "ONLY_COUNTERPART_GATEWAY"         );         _;     } ```  It uses applyL1ToL2Alias defined as:  ``` uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);      /// @notice Utility function that converts the address in the L1 that submitted a tx to     /// the inbox to the msg.sender viewed in the L2     /// @param l1Address the address in the L1 that triggered the tx to L2     /// @return l2Address L2 address as viewed in msg.sender     function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {         l2Address = address(uint160(l1Address) + offset);     } ```  This behavior matches with how Arbitrum augments the sender's address to L2. The issue is that I've spoken with the team and they are [planning](https://github.com/graphprotocol/contracts/pull/725) an upgrade from Solidity 0.7.6 to 0.8.0. Their proposed [changes](https://github.com/graphprotocol/contracts/blob/c4d3cb56cb4032dbb3a0f1b7535b5d94ccf86222/contracts/arbitrum/AddressAliasHelper.sol) will break this function, because under 0.8.0, this line has a ~ 1/15 chance to overflow:  `l2Address = address(uint160(l1Address) + offset);`  Interestingly, the sum intentionally wraps around using the uint160 type to return a correct address, but this wrapping will overflow in 0.8.0  ## Impact  There is a ~6.5% chance that finalizeInboundTransfer will not work.  ## Proof of Concept  l1Address is L1GraphTokenGateway, suppose its address is 0xF000000000000000000000000000000000000000.  Then 0xF000000000000000000000000000000000000000 + 0x1111000000000000000000000000000000001111 > UINT160_MAX , meaning overflow.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Wrap the calculation in an unchecked block, which will make it behave correctly.
# Lines of code  https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/gateway/L2GraphTokenGateway.sol#L87 https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/token/L2GraphToken.sol#L48 https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/L1GraphTokenGateway.sol#L99 https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/BridgeEscrow.sol#L20   # Vulnerability details  ## Impact  initialize function in L2GraphToken.sol, BridgeEscrow.sol, L2GraphTokenGateway.sol, L1GraphTokenGateway.sol   can be invoked multiple times from the implementation contract.  this means a compromised implementation can reinitialize the contract above and   become the owner to complete the privilege escalation then drain the user's fund.  Usually in Upgradeable contract, a initialize function is protected by the modifier  ```solidity  initializer ```  to make sure the contract can only be initialized once.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  1. The implementation contract is compromised,  2. The attacker reinitialize the BridgeEscrow contract  ```     function initialize(address _controller) external onlyImpl {         Managed._initialize(_controller);     } ```  the onlyGovernor modifier's result depends on the controller because  ```solidity     function _onlyGovernor() internal view {         require(msg.sender == controller.getGovernor(), "Caller must be Controller governor");     } ```  3. The attacker have the governor access to the BridgeEscrow,   4. The attack can call the approve function to approve malicious contract   ```solidity      function approveAll(address _spender) external onlyGovernor {         graphToken().approve(_spender, type(uint256).max);     } ```  5. The attack can drain all the GRT token from the BridgeEscrow.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the project use the modifier   ```solidity  initializer ```  to protect the initialize function from being reinitiated  ```solidity    function initialize(address _owner) external onlyImpl initializer  { ``` 
