# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63   # Vulnerability details  ## Impact The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.  ## Proof of Concept In `Pair.add()`, the amount of LP token minted is calculated as ```solidity function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {     uint256 lpTokenSupply = lpToken.totalSupply();     if (lpTokenSupply > 0) {         // calculate amount of lp tokens as a fraction of existing reserves         uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();         uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();         return Math.min(baseTokenShare, fractionalTokenShare);     } else {         // if there is no liquidity then init         return Math.sqrt(baseTokenAmount * fractionalTokenAmount);     } } ```  An attacker can exploit using these steps 1. Create and add `1 wei baseToken - 1 wei quoteToken` to the pair. At this moment, attacker is minted `1 wei LP token` because `sqrt(1 * 1) = 1` 2. Transfer large amount of `baseToken` and `quoteToken` directly to the pair, such as `1e9 baseToken - 1e9 quoteToken`. Since no new LP token is minted, `1 wei LP token` worths `1e9 baseToken - 1e9 quoteToken`. 3. Normal users add liquidity to pool will receive `0` LP token if they add less than `1e9` token because of rounding division. ```solidity baseTokenShare = (X * 1) / 1e9; fractionalTokenShare = (Y * 1) / 1e9; ```   ## Tools Used Manual Review  ## Recommended Mitigation Steps - [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `lpTokenSupply == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. - In `add()`, ensure the number of LP tokens to be minted is non-zero: ```solidity require(lpTokenAmount != 0, "No LP minted"); ```  
# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L421-L423   # Vulnerability details  ## Impact Liquidity providers may lose a portion of provided liquidity in either of the pair tokens. While the `minLpTokenAmount` protects from slippage when adding liquidity, it doesn't protect from providing liquidity at different K. ## Proof of Concept The `Pair` contract is designed to receive liquidity from liquidity providers ([Pair.sol#L63](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63)). First liquidity provider in a pool may provide arbitrary token amounts and set the initial price ([Pair.sol#L425-L426](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L425-L426)), but all other liquidity providers must provide liquidity proportionally to current pool reserves ([Pair.sol#L420-L423](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L420-L423)). Since a pool is made of two tokens and liquidity is provided in both tokens, there's a possibility for a discrepancy: token amounts may be provided in different proportions. When this happens, the smaller of the proportions is chosen to calculate the amount of LP tokens minted ([Pair.sol#L420-L423](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L420-L423)): ```solidity // calculate amount of lp tokens as a fraction of existing reserves uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves(); uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves(); return Math.min(baseTokenShare, fractionalTokenShare); ```  As a result, the difference in proportions will create an excess of tokens that won't be redeemable for the amount of LP tokens minted. The excess of tokens gets, basically, donated to the pool: it'll be shared among all liquidity providers of the pool. While the `minLpTokenAmount` argument of the `add` function ([Pair.sol#L63](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63)) allows liquidity providers to set the minimal amount of LP tokens they want to receive, it doesn't allow them to minimize the disproportion of token amounts or avoid it at all.  ```solidity // test/Pair/unit.Add.t.sol  function testLockOfFunds_AUDIT() public {     address alice = address(0x31337);     address bob = address(0x12345);     vm.label(alice, "alice");     vm.label(bob, "bob");      deal(address(usd), alice, 100e18, true);     deal(address(usd), bob, 100e18, true);     deal(address(p), alice, 100e18, true);     deal(address(p), bob, 100e18, true);      // Alice is the first liquidity provider.     vm.startPrank(alice);     usd.approve(address(p), type(uint256).max);     p.add(10 ether, 10 ether, 0);     vm.stopPrank();      // Bob provides liquidity to the pool and sets the minimal LP amount.     // The token amounts are deposited in different proportions, thus the smaller     // one will be chosen to calculate the amount of LP tokens Bob will receive.     vm.startPrank(bob);     usd.approve(address(p), type(uint256).max);     uint256 minLPAmount = 1e18;     uint256 bobLPAmount = p.add(1.2 ether, 1 ether, minLPAmount);     vm.stopPrank();      // Bob has received the minimal LP amount he wanted.     assertEq(bobLPAmount, minLPAmount);      // However, after removing all his liquidity from the pool...     (uint256 bobUSDBefore, uint256 bobFracBefore) = (usd.balanceOf(bob), p.balanceOf(bob));     vm.prank(bob);     p.remove(minLPAmount, 0, 0);     (uint256 bobUSDAfter, uint256 bobFracAfter) = (usd.balanceOf(bob), p.balanceOf(bob));      // ... Bob received less USD than he deposited.     assertEq(bobUSDAfter - bobUSDBefore, 1.018181818181818181 ether);     assertEq(bobFracAfter - bobFracBefore, 1.000000000000000000 ether); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps In the `add` function, consider calculating optimal token amounts based on the amounts specified by user, current pool reserves, and the minimal LP tokens amount specified by user. As a reference, consider this piece from the Uniswap V2 Router: [UniswapV2Router02.sol#L45-L60](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L45-L60).
# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L398-L400   # Vulnerability details  In order to guarantee the contract does not become insolvent, incoming assets should be rounded up, while outgoing assets should be rounded down.   The function `buyQuote()` calculates the amount of base tokens required to buy a given amount of fractional tokens. However, this function rounds down the required amount, which is in favor of the buyer (i.e. he/she has to provide less base tokens for the amount of receiving fractional tokens.   Depending on the amount of current token reserves and the amount of fractional tokens the user wishes to buy, it might be possible to receive free fractional tokens.  Assume the following reserve state:   - base token reserve: 0,1 WBTC (=`1e7`) - fractional token reserve: 10.000.000 (=`1e25`)  The user wishes to buy 0,9 fractional tokens (=`9e17`). Then, the function `buyQuote()` will calculate the amount of base tokens as follows:   `(9e17 * 1000 * 1e7) / ((1e25 - 9e17) * 997) = 0,903`  As division in Solidity will round down, the amount results in `0` amount of base tokens required (WBTC) to buy 0,9 fractional tokens.   ## Impact  Using the example above, 0,9 fractional tokens is a really small amount (`0,1 BTC / 1e7 = +- $0,00017`). Moreover, if the user keeps repeating this attack, the fractional token reserve becomes smaller, which will result in a buyQuote amount of >1, after which the tokens will not be free anymore.   Additionally, as the contract incorporates a fee of 30bps, it will likely not be insolvent. The downside would be the LP holder, which will receive a fee of less than 30bps. Hence, the impact is rated as medium.  ## Tool Used  Manual Review  ## Recommended Mitigation Steps  For incoming assets, it’s recommended to round up the required amount. We could use solmate’s `FixedPointMathLib` library to calculate the quote and round up. This way the required amount will always at least be 1 wei:  ```solidity function buyQuote(uint256 outputAmount) public view returns (uint256) {   return mulDivUp(outputAmount * 1000, baseTokenReserves(), (fractionalTokenReserves() - outputAmount) * 997); } ```
# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L387-L392   # Vulnerability details  ## Impact The `price()` function is expected to return the price of one fractional tokens, represented in base tokens, to 18 decimals of precision. This is laid out clearly in the comments:  > /// @notice The current price of one fractional token in base tokens with 18 decimals of precision. /// @dev Calculated by dividing the base token reserves by the fractional token reserves. /// @return price The price of one fractional token in base tokens * 1e18.  However, the formula incorrectly calculates the price to be represented in whatever number of decimals the base token is in. Since there are many common base tokens (such as USDC) that will have fewer than 18 decimals, this will create a large mismatch between expected prices and the prices that result from the function.  ## Proof of Concept  Prices are calculated with the following formula, where `ONE = 1e18`:  ```solidity return (_baseTokenReserves() * ONE) / fractionalTokenReserves(); ```  We know that `fractionalTokenReserves` will always be represented in 18 decimals. This means that the `ONE` and the  `fractionalTokenReserves` will cancel each other out, and we are left with the `baseTokenReserves` number of decimals for the final price.  As an example: - We have $1000 USDC in reserves, which at 6 decimals is 1e9 - We have 1000 fractional tokens in reserve, which at 18 decimals is 1e21 - The price calculation is `1e9 * 1e18 / 1e21 = 1e6` - While the value should be 1 token, the 1e6 will be interpreted as just 1/1e12 tokens if we expect the price to be in 1e18  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  The formula should use the decimals value of the `baseToken` to ensure that the decimals of the resulting price ends up with 18 decimals as expected:  ```solidity return (_baseTokenReserves() * 10 ** (36 - ERC20(baseToken).decimals()) / fractionalTokenReserves(); ```  This will multiple `baseTokenReserves` by 1e18, and then additionally by the gap between 1e18 and its own decimals count, which will result in the correct decimals value for the outputted price.
# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63   # Vulnerability details  ## Impact The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.  ## Proof of Concept In `Pair.add()`, the amount of LP token minted is calculated as ```solidity function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {     uint256 lpTokenSupply = lpToken.totalSupply();     if (lpTokenSupply > 0) {         // calculate amount of lp tokens as a fraction of existing reserves         uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();         uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();         return Math.min(baseTokenShare, fractionalTokenShare);     } else {         // if there is no liquidity then init         return Math.sqrt(baseTokenAmount * fractionalTokenAmount);     } } ```  An attacker can exploit using these steps 1. Create and add `1 wei baseToken - 1 wei quoteToken` to the pair. At this moment, attacker is minted `1 wei LP token` because `sqrt(1 * 1) = 1` 2. Transfer large amount of `baseToken` and `quoteToken` directly to the pair, such as `1e9 baseToken - 1e9 quoteToken`. Since no new LP token is minted, `1 wei LP token` worths `1e9 baseToken - 1e9 quoteToken`. 3. Normal users add liquidity to pool will receive `0` LP token if they add less than `1e9` token because of rounding division. ```solidity baseTokenShare = (X * 1) / 1e9; fractionalTokenShare = (Y * 1) / 1e9; ```   ## Tools Used Manual Review  ## Recommended Mitigation Steps - [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `lpTokenSupply == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. - In `add()`, ensure the number of LP tokens to be minted is non-zero: ```solidity require(lpTokenAmount != 0, "No LP minted"); ```  
# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L421-L423   # Vulnerability details  ## Impact Liquidity providers may lose a portion of provided liquidity in either of the pair tokens. While the `minLpTokenAmount` protects from slippage when adding liquidity, it doesn't protect from providing liquidity at different K. ## Proof of Concept The `Pair` contract is designed to receive liquidity from liquidity providers ([Pair.sol#L63](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63)). First liquidity provider in a pool may provide arbitrary token amounts and set the initial price ([Pair.sol#L425-L426](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L425-L426)), but all other liquidity providers must provide liquidity proportionally to current pool reserves ([Pair.sol#L420-L423](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L420-L423)). Since a pool is made of two tokens and liquidity is provided in both tokens, there's a possibility for a discrepancy: token amounts may be provided in different proportions. When this happens, the smaller of the proportions is chosen to calculate the amount of LP tokens minted ([Pair.sol#L420-L423](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L420-L423)): ```solidity // calculate amount of lp tokens as a fraction of existing reserves uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves(); uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves(); return Math.min(baseTokenShare, fractionalTokenShare); ```  As a result, the difference in proportions will create an excess of tokens that won't be redeemable for the amount of LP tokens minted. The excess of tokens gets, basically, donated to the pool: it'll be shared among all liquidity providers of the pool. While the `minLpTokenAmount` argument of the `add` function ([Pair.sol#L63](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63)) allows liquidity providers to set the minimal amount of LP tokens they want to receive, it doesn't allow them to minimize the disproportion of token amounts or avoid it at all.  ```solidity // test/Pair/unit.Add.t.sol  function testLockOfFunds_AUDIT() public {     address alice = address(0x31337);     address bob = address(0x12345);     vm.label(alice, "alice");     vm.label(bob, "bob");      deal(address(usd), alice, 100e18, true);     deal(address(usd), bob, 100e18, true);     deal(address(p), alice, 100e18, true);     deal(address(p), bob, 100e18, true);      // Alice is the first liquidity provider.     vm.startPrank(alice);     usd.approve(address(p), type(uint256).max);     p.add(10 ether, 10 ether, 0);     vm.stopPrank();      // Bob provides liquidity to the pool and sets the minimal LP amount.     // The token amounts are deposited in different proportions, thus the smaller     // one will be chosen to calculate the amount of LP tokens Bob will receive.     vm.startPrank(bob);     usd.approve(address(p), type(uint256).max);     uint256 minLPAmount = 1e18;     uint256 bobLPAmount = p.add(1.2 ether, 1 ether, minLPAmount);     vm.stopPrank();      // Bob has received the minimal LP amount he wanted.     assertEq(bobLPAmount, minLPAmount);      // However, after removing all his liquidity from the pool...     (uint256 bobUSDBefore, uint256 bobFracBefore) = (usd.balanceOf(bob), p.balanceOf(bob));     vm.prank(bob);     p.remove(minLPAmount, 0, 0);     (uint256 bobUSDAfter, uint256 bobFracAfter) = (usd.balanceOf(bob), p.balanceOf(bob));      // ... Bob received less USD than he deposited.     assertEq(bobUSDAfter - bobUSDBefore, 1.018181818181818181 ether);     assertEq(bobFracAfter - bobFracBefore, 1.000000000000000000 ether); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps In the `add` function, consider calculating optimal token amounts based on the amounts specified by user, current pool reserves, and the minimal LP tokens amount specified by user. As a reference, consider this piece from the Uniswap V2 Router: [UniswapV2Router02.sol#L45-L60](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L45-L60).
# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L398-L400   # Vulnerability details  In order to guarantee the contract does not become insolvent, incoming assets should be rounded up, while outgoing assets should be rounded down.   The function `buyQuote()` calculates the amount of base tokens required to buy a given amount of fractional tokens. However, this function rounds down the required amount, which is in favor of the buyer (i.e. he/she has to provide less base tokens for the amount of receiving fractional tokens.   Depending on the amount of current token reserves and the amount of fractional tokens the user wishes to buy, it might be possible to receive free fractional tokens.  Assume the following reserve state:   - base token reserve: 0,1 WBTC (=`1e7`) - fractional token reserve: 10.000.000 (=`1e25`)  The user wishes to buy 0,9 fractional tokens (=`9e17`). Then, the function `buyQuote()` will calculate the amount of base tokens as follows:   `(9e17 * 1000 * 1e7) / ((1e25 - 9e17) * 997) = 0,903`  As division in Solidity will round down, the amount results in `0` amount of base tokens required (WBTC) to buy 0,9 fractional tokens.   ## Impact  Using the example above, 0,9 fractional tokens is a really small amount (`0,1 BTC / 1e7 = +- $0,00017`). Moreover, if the user keeps repeating this attack, the fractional token reserve becomes smaller, which will result in a buyQuote amount of >1, after which the tokens will not be free anymore.   Additionally, as the contract incorporates a fee of 30bps, it will likely not be insolvent. The downside would be the LP holder, which will receive a fee of less than 30bps. Hence, the impact is rated as medium.  ## Tool Used  Manual Review  ## Recommended Mitigation Steps  For incoming assets, it’s recommended to round up the required amount. We could use solmate’s `FixedPointMathLib` library to calculate the quote and round up. This way the required amount will always at least be 1 wei:  ```solidity function buyQuote(uint256 outputAmount) public view returns (uint256) {   return mulDivUp(outputAmount * 1000, baseTokenReserves(), (fractionalTokenReserves() - outputAmount) * 997); } ```
# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L387-L392   # Vulnerability details  ## Impact The `price()` function is expected to return the price of one fractional tokens, represented in base tokens, to 18 decimals of precision. This is laid out clearly in the comments:  > /// @notice The current price of one fractional token in base tokens with 18 decimals of precision. /// @dev Calculated by dividing the base token reserves by the fractional token reserves. /// @return price The price of one fractional token in base tokens * 1e18.  However, the formula incorrectly calculates the price to be represented in whatever number of decimals the base token is in. Since there are many common base tokens (such as USDC) that will have fewer than 18 decimals, this will create a large mismatch between expected prices and the prices that result from the function.  ## Proof of Concept  Prices are calculated with the following formula, where `ONE = 1e18`:  ```solidity return (_baseTokenReserves() * ONE) / fractionalTokenReserves(); ```  We know that `fractionalTokenReserves` will always be represented in 18 decimals. This means that the `ONE` and the  `fractionalTokenReserves` will cancel each other out, and we are left with the `baseTokenReserves` number of decimals for the final price.  As an example: - We have $1000 USDC in reserves, which at 6 decimals is 1e9 - We have 1000 fractional tokens in reserve, which at 18 decimals is 1e21 - The price calculation is `1e9 * 1e18 / 1e21 = 1e6` - While the value should be 1 token, the 1e6 will be interpreted as just 1/1e12 tokens if we expect the price to be in 1e18  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  The formula should use the decimals value of the `baseToken` to ensure that the decimals of the resulting price ends up with 18 decimals as expected:  ```solidity return (_baseTokenReserves() * 10 ** (36 - ERC20(baseToken).decimals()) / fractionalTokenReserves(); ```  This will multiple `baseTokenReserves` by 1e18, and then additionally by the gap between 1e18 and its own decimals count, which will result in the correct decimals value for the outputted price.
