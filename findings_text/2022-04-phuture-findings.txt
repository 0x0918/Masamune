# Lines of code  https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PriceOracle.sol#L62   # Vulnerability details  https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PriceOracle.sol#L62  ```solidity (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) = address(pair).currentCumulativePrices(); ```  Because the Solidity version used by the current implementation of `UniswapV2OracleLibrary.sol` is `>=0.8.7`, and there are some breaking changes in Solidity v0.8.0:  > Arithmetic operations revert on underflow and overflow.   Ref: https://docs.soliditylang.org/en/v0.8.13/080-breaking-changes.html#silent-changes-of-the-semantics  While in `UniswapV2OracleLibrary.sol`, subtraction overflow is desired at `blockTimestamp - blockTimestampLast` in `currentCumulativePrices()`:  https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L25-L33  ```solidity if (blockTimestampLast != blockTimestamp) {     // subtraction overflow is desired     uint32 timeElapsed = blockTimestamp - blockTimestampLast;     // addition overflow is desired     // counterfactual     price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;     // counterfactual     price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed; } ```  In another word, `Uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary` only works at solidity < `0.8.0`.  As a result, when `price0Cumulative` or `price1Cumulative` is big enough, `currentCumulativePrices` will revert due to overflow.  ### Impact  Since the overflow is desired in the original version, and it's broken because of using Solidity version >0.8. The `UniswapV2PriceOracle` contract will break when the desired overflow happens, and further breaks other parts of the system that relies on `UniswapV2PriceOracle`.  ### Recommendation  Note: this recommended fix requires a fork of the library contract provided by Uniswap.  Change to:  ```solidity if (blockTimestampLast != blockTimestamp) {     unchecked {         // subtraction overflow is desired         uint32 timeElapsed = blockTimestamp - blockTimestampLast;         // addition overflow is desired         // counterfactual         price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;         // counterfactual         price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;     } } ```  
# Lines of code  https://github.com/code-423n4/2022-04-phuture/tree/main/contracts/IndexLogic.sol#L115   # Vulnerability details   There are ERC20 tokens that charge fee for every transfer() / transferFrom().  Vault.sol#addValue() assumes that the received amount is the same as the transfer amount,  and uses it to calculate attributions, balance amounts, etc.  But, the actual transferred amount can be lower for those tokens. Therefore it's recommended to use the balance change before and after the transfer instead of the amount. This way you also support the tokens with transfer fee - that are popular.           https://github.com/code-423n4/2022-04-phuture/tree/main/contracts/IndexLogic.sol#L115  
# Lines of code   https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ManagedIndexReweightingLogic.sol#L32 https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/interfaces/IIndexRegistry.sol#L19   # Vulnerability details  ## Impact The list of assets won't be changed after reweight because of reverted tx   ## Proof of Concept  ```require(_updatedAssets.length <= IIndexRegistry(registry).maxComponents())``` when [reweight](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ManagedIndexReweightingLogic.sol#L32) is not true, because as in the [doc](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/interfaces/IIndexRegistry.sol#L19),  ```maxComponent``` is the maximum assets for an index, but ```_updatedAssets``` also contain the assets that you want to remove. So the comparision make no sense  ## Tools Used manual review   ## Recommended Mitigation Steps Require ```assets.length() <= IIndexRegistry(registry).maxComponents()``` at the end of function instead    
# Lines of code  https://github.com/code-423n4/2022-04-phuture/blob/main/contracts/ChainlinkPriceOracle.sol#L83-L84   # Vulnerability details  ## Impact On ChainlinkPriceOracle.sol, we are using latestRoundData, but there is no check if the return value indicates stale data. ```         (, int basePrice, , , ) = baseAggregator.latestRoundData();         (, int quotePrice, , , ) = assetInfo.aggregator.latestRoundData(); ``` This could lead to stale prices according to the Chainlink documentation:  https://docs.chain.link/docs/historical-price-data/#historical-rounds https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round ## Proof of Concept https://github.com/code-423n4/2022-04-phuture/blob/main/contracts/ChainlinkPriceOracle.sol#L83-L84 ## Tools Used None ## Recommended Mitigation Steps Consider adding missing checks for stale data.  For example: ```     (uint80 baseRoundID, int256 basePrice, , uint256 baseTimestamp, uint80 BaseAnsweredInRound) = baseAggregator.latestRoundData();     (uint80 quoteRoundID, int256 quotePrice, , uint256 quoteTimestamp, uint80 quoteAnsweredInRound) = assetInfo.aggregator.latestRoundData();     require(BaseAnsweredInRound >= baseRoundID && quoteAnsweredInRound >=  quoteRoundID, "Stale price");     require(baseTimestamp != 0 && quoteTimestamp != 0 ,"Round not complete");     require(basePrice > 0 && quotePrice > 0,"Chainlink answer reporting 0"); ```  
# Lines of code  https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PriceOracle.sol#L62   # Vulnerability details  https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PriceOracle.sol#L62  ```solidity (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) = address(pair).currentCumulativePrices(); ```  Because the Solidity version used by the current implementation of `UniswapV2OracleLibrary.sol` is `>=0.8.7`, and there are some breaking changes in Solidity v0.8.0:  > Arithmetic operations revert on underflow and overflow.   Ref: https://docs.soliditylang.org/en/v0.8.13/080-breaking-changes.html#silent-changes-of-the-semantics  While in `UniswapV2OracleLibrary.sol`, subtraction overflow is desired at `blockTimestamp - blockTimestampLast` in `currentCumulativePrices()`:  https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L25-L33  ```solidity if (blockTimestampLast != blockTimestamp) {     // subtraction overflow is desired     uint32 timeElapsed = blockTimestamp - blockTimestampLast;     // addition overflow is desired     // counterfactual     price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;     // counterfactual     price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed; } ```  In another word, `Uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary` only works at solidity < `0.8.0`.  As a result, when `price0Cumulative` or `price1Cumulative` is big enough, `currentCumulativePrices` will revert due to overflow.  ### Impact  Since the overflow is desired in the original version, and it's broken because of using Solidity version >0.8. The `UniswapV2PriceOracle` contract will break when the desired overflow happens, and further breaks other parts of the system that relies on `UniswapV2PriceOracle`.  ### Recommendation  Note: this recommended fix requires a fork of the library contract provided by Uniswap.  Change to:  ```solidity if (blockTimestampLast != blockTimestamp) {     unchecked {         // subtraction overflow is desired         uint32 timeElapsed = blockTimestamp - blockTimestampLast;         // addition overflow is desired         // counterfactual         price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;         // counterfactual         price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;     } } ```  
# Lines of code  https://github.com/code-423n4/2022-04-phuture/tree/main/contracts/IndexLogic.sol#L115   # Vulnerability details   There are ERC20 tokens that charge fee for every transfer() / transferFrom().  Vault.sol#addValue() assumes that the received amount is the same as the transfer amount,  and uses it to calculate attributions, balance amounts, etc.  But, the actual transferred amount can be lower for those tokens. Therefore it's recommended to use the balance change before and after the transfer instead of the amount. This way you also support the tokens with transfer fee - that are popular.           https://github.com/code-423n4/2022-04-phuture/tree/main/contracts/IndexLogic.sol#L115  
# Lines of code   https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ManagedIndexReweightingLogic.sol#L32 https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/interfaces/IIndexRegistry.sol#L19   # Vulnerability details  ## Impact The list of assets won't be changed after reweight because of reverted tx   ## Proof of Concept  ```require(_updatedAssets.length <= IIndexRegistry(registry).maxComponents())``` when [reweight](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ManagedIndexReweightingLogic.sol#L32) is not true, because as in the [doc](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/interfaces/IIndexRegistry.sol#L19),  ```maxComponent``` is the maximum assets for an index, but ```_updatedAssets``` also contain the assets that you want to remove. So the comparision make no sense  ## Tools Used manual review   ## Recommended Mitigation Steps Require ```assets.length() <= IIndexRegistry(registry).maxComponents()``` at the end of function instead    
# Lines of code  https://github.com/code-423n4/2022-04-phuture/blob/main/contracts/ChainlinkPriceOracle.sol#L83-L84   # Vulnerability details  ## Impact On ChainlinkPriceOracle.sol, we are using latestRoundData, but there is no check if the return value indicates stale data. ```         (, int basePrice, , , ) = baseAggregator.latestRoundData();         (, int quotePrice, , , ) = assetInfo.aggregator.latestRoundData(); ``` This could lead to stale prices according to the Chainlink documentation:  https://docs.chain.link/docs/historical-price-data/#historical-rounds https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round ## Proof of Concept https://github.com/code-423n4/2022-04-phuture/blob/main/contracts/ChainlinkPriceOracle.sol#L83-L84 ## Tools Used None ## Recommended Mitigation Steps Consider adding missing checks for stale data.  For example: ```     (uint80 baseRoundID, int256 basePrice, , uint256 baseTimestamp, uint80 BaseAnsweredInRound) = baseAggregator.latestRoundData();     (uint80 quoteRoundID, int256 quotePrice, , uint256 quoteTimestamp, uint80 quoteAnsweredInRound) = assetInfo.aggregator.latestRoundData();     require(BaseAnsweredInRound >= baseRoundID && quoteAnsweredInRound >=  quoteRoundID, "Stale price");     require(baseTimestamp != 0 && quoteTimestamp != 0 ,"Round not complete");     require(basePrice > 0 && quotePrice > 0,"Chainlink answer reporting 0"); ```  
