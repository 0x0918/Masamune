# Handle  broccolirob   # Vulnerability details   A malicious "publisher" can create a basket proposal that mixes real ERC20 tokens with a malicious ERC20 token containing a reentrancy callback in it's `approve()` method. When the `initialize()` method is called on the newly cloned `Basket` contract, a method called `approveUnderlying(address(auction))` is called, which would trigger the reentrancy, call `initialize()` again, passing in altered critical values such as `auction` and `factory`, and then removes its self from `proposal.tokens` and `proposal.weights` so it doesn't appear in the token list to basket users.  https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L44-L61  ## Impact `Auction` and `Factory` can be set to custom implementations that do malicious things. Since all baskets and auctions are clones with their own addresses, this fact would be difficult for users to detect. `Auction` controls ibRatio, which a malicious version could send back a manipulated value to `Basket`, allowing the malicious "publisher" to burn basket tokens till all users underlying tokens are drained.  ## Tools Used Manual review and Hardhat.  ## Recommended Mitigation Steps Since `Basket` inherits from `ERC20Upgradeable` the `initializer` modifier should be available and therefore used here. It has an `inititializing` variable that would prevent this kind of reentrancy attack.  
# Handle  0x0x0x   # Vulnerability details  When factory changes `auctionMultiplier` or `auctionDecrement` profitability of bonded auctions change. There is no protection against this behaviour. Furthermore, factory owners can decide to get all tokens from baskets where they are bonded for the auction.  ## Proof of concept  1- Factory owners call `bondForRebalance` for an auction.  2- Factory owners sets `auctionMultiplier` as 0 and `auctionDecrement` as maximum value  3- `settleAuction` is called. `newRatio = 0`, since `a = b = 0`. All tokens can be withdrawn with this call, since `tokensNeeded = 0`.  ## Extra notes  Furthermore, even the factory owners does not try to scam users. In case `auctionMultiplier` or `auctionDecrement` is changed, all current `auctionBonder` from `Auctions` can only call `settleAuction` with different constraints. Because of different constraints, users/bonder will lose/gain funds.  ## Mitigation step  Save `auctionDecrement` and `auctionMultiplier` to global variables in `Auction.sol`, when `startAuction` is called.  
# Handle  0x0x0x   # Vulnerability details  The function is implemented as follows:  ``` function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {         uint256 startSupply = totalSupply();         handleFees(startSupply);         _burn(msg.sender, amount);          uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);         ibRatio = newIbRatio;          emit NewIBRatio(newIbRatio);         emit Burned(msg.sender, amount);     } ```  When `handleFees` is called, `totalSupply` and `ibRatio` changes accordingly, but for `newIbRatio` calculation tokens minted in `handleFees` is not included. Therefore, `ibRatio` is calculated higher than it should be. This is dangerous, since last withdrawing user(s) lose their funds with this operation. In case this miscalculation happens more than once, `newIbRatio` will increase the miscalculation even faster and can result in serious amount of funds missing. At each time `auctionBurn` is called, at least 1 day (auction duration) of fees result in this miscalculation. Furthermore, all critical logic of this contract is based on `ibRatio`, this behaviour can create serious miscalculations.   ## Mitigation step  Rather than  `uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);`  A practical solution to this problem is calculating `newIbRatio` as follows:  ``` uint256 supply = totalSupply(); uint256 newIbRatio = ibRatio * (supply + amount) / supply; ```  
# Handle  gzeon   # Vulnerability details  ## Impact Since tokenName is user supplied and can be duplicated, it is better to emit proposal id instead.  https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Factory.sol#L91 ```         emit BasketLicenseProposed(msg.sender, tokenName); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Auction.sol#L97-L102  ```solidity=97     uint256 a = factory.auctionMultiplier() * basket.ibRatio();     uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();     uint256 newRatio = a - b;      (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();     require(newRatio >= minIbRatio); ```  In the current implementation, `newRatio` is calculated and compared with `minIbRatio` in `settleAuction()`.  However, if `newRatio` is less than `minIbRatio`, `settleAuction()` will always fail and there is no way for the bonder to cancel and get a refund.  ### PoC  Given:  - `bondPercentDiv` = 400 - `basketToken.totalSupply` = 40,000 - `factory.auctionMultiplier` = 2 - `factory.auctionDecrement` = 10,000 - `basket.ibRatio` = 1e18 - p`endingWeights.minIbRatio` = 1.9 * 1e18  1. Alice called `bondForRebalance()` `2,000` blocks after the auction started, paid `100` basketToken for the bond; 2. Alice tries to `settleAuction()`, it will always fail because `newRatio < minIbRatio`; - a = 2 * 1e18 - b = 0.2 * 1e18 - newRatio = 1.8 * 1e18; 3. Bob calls `bondBurn()` one day after, `100` basketToken from Alice will been burned.  ### Recommendation  Move the `minIbRatio` check to `bondForRebalance()`:  ```solidity=58 function bondForRebalance() public override {         require(auctionOngoing);         require(!hasBonded);          bondTimestamp = block.timestamp;         bondBlock = block.number;          uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();         require(newRatio >= minIbRatio);          IERC20 basketToken = IERC20(address(basket));         bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();         basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);         hasBonded = true;         auctionBonder = msg.sender;          emit Bonded(msg.sender, bondAmount);     } ```  
# Handle  Ruhum   # Vulnerability details  ## Impact The `settleAuction()` function allows someone to settle the auction by transferring funds in a way that the new pending index is fulfilled. As a reward, they are able to take out as many tokens as they want as long as the pending index is fulfilled after that. The function verifies that the basket has received everything it wanted using the following logic: ```sol         for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` The attack vector here is to manipulate `tokensNeeded` to be 0. That way we can drain the basket completely without the function reverting.  For that, we manipulate `newRatio` to be 0 then the whole thing will be 0. `newRatio` is defined as: ```sol         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ``` There's 1 value the attacker controls, `bondBlock`. That value is the block in which the `bondForRebalance()` function was triggered. So the goal is to get `newRatio` to be 0. With the base settings of the contract:  - auctionMultiplier == 2 - ibRatio == 1e18 - BASE == 1e18 - auctionDecrement == 10000  `bondBlock` has to be `auctionStart + 20000`. Meaning, the `bondForRebalance()` function has to be triggered exactly 20000 blocks after the action was started. That would be around 3 1/2 days after auction start.  At that point, `newRatio` is 0, and thus `tokensNeeded` is 0. The only thing left to do is to call `settleAuction()` and pass the basket's tokens and balance as the output tokens and weight.  ## Proof of Concept Here's a test implementing the above scenario as a test. You can add it to `Auction.test.js`.:  ```js       it.only("should allow me to steal funds", async() => {         // start an auction         let NEW_UNI_WEIGHT = "2400000000000000000";         let NEW_COMP_WEIGHT = "2000000000000000000";         let NEW_AAVE_WEIGHT = "400000000000000000";          await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address],              [NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;         await increaseTime(60 * 60 * 24)         await increaseTime(60 * 60 * 24)         await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address],            [NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;          let auctionAddr = await basket.auction();         let auction = AuctionImpl.attach(auctionAddr);          ethers.provider.getBlockNumber();         // increase the block number for `bondBlock - auctionStart` to be 20000.         // When that's the case, the result of `newRatio` in `settleAuction()`          // is `0`. And that means `tokensNeeded` is 0. Which means,         // we can take out all the tokens we want using the `outputTokens` array         // without having to worry about basket's balance at the end.         // The math changes depending on the settings of the factory contract or the         // Basket contract. But, the gist is that you try to get newRatio to be 0.         // The only values you can control as a attacker is the bondBlock after the auction         // was started.         for (let i = 0; i < 20000; i++) {           await hre.network.provider.send("evm_mine")         }         await basket.approve(auction.address, '5000000000000000');         await expect(auction.bondForRebalance()).to.be.ok;         await expect(auction.settleAuction([], [], [], [UNI.address, AAVE.address], ["200720000000000000", "200120000000000000"])).to.be.ok;       }); ```  Again, this test uses the base values. The math changes when the settings change. But, it should always be possible to trigger this attack. The gap between auction start and bonding just changes.  ## Tools Used manual analysis  ## Recommended Mitigation Steps - Verify that `newRatio != 0`  
# Handle  kenzo   # Vulnerability details  `handleFees` does not update `lastFee` if `startSupply == 0`. This means that wrongly, extra fee tokens would be minted once the basket is resupplied and `handleFees` is called again.  ## Impact Loss of user funds. The extra minting of fee tokens comes on the expense of the regular basket token owners, which upon withdrawal would get less underlying than their true share, due to the dilution of their tokens' value.  ## Proof of Concept Scenario: - All basket token holders are burning their tokens. The last burn would set totalSupply to 0. - After 1 day, somebody mints basket tokens. `handleFees` would be called upon mint, and would just return since totalSupply == 0. Note: It does not update `lastFee`. ``` } else if (startSupply == 0) {             return; ``` https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L136:#L137 - The next block, somebody else mints a token. Now `handleFees` will be called and will calculate the fees according to the current supply and the time diff between now and `lastFee`: ``` uint256 timeDiff = (block.timestamp - lastFee); ``` https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L139 But as we saw, `lastFee` wasn't updated in the previous step. `lastFee` is still the time of 1 day before - when the last person burned his tokens and the basket supply was 0. So now the basket will mint fees as if a whole day has passed since the last calculation, but actually it only needs to calculate the fees for the last block, since only then we had tokens in the basket.  ## Recommended Mitigation Steps Set `lastFee = block.timestamp` if `startSupply == 0`.  
# Handle  neslinesli93   # Vulnerability details  ## Impact The `initialized` variable has its visibility set to `public`, while it should be private. The reason is that any contract that inherits from `Auction.sol` or `Basket.sol` may reset the value for  the `initialized` variable  ## Recommended Mitigation Steps Reduce `initialized` visibility to `private` in both contracs  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact The fee calculation on L141 is wrong. It should only get divided by BASE and not (BASE - feePct)  ## Proof of Concept This shows dividing only by BASE is correct: Assumptions:  - BASE is 1e18 accordign to the code - timeDiff is exactly ONE_YEAR (for easier calculations) - startSupply is 1e18 (exactly one basket token, also represents 100% in fee terms) - licenseFee is 1e15 (0.1%) If we calculate the fee of one whole year and startSupply is one token (1e18, equal to 100%), the fee should be exactly the licenseFee  (1e15, 0.1%),  uint256 timeDiff = ONE_YEAR;  uint256 feePct = timeDiff * licenseFee / ONE_YEAR; => therefore we have: feePct = licenseFee which is 1e15 (0.1%) according to our assumptions uint256 fee = startSupply * feePct / BASE; // only divide by BASE => insert values => fee = 1e18 * licenseFee  / 1e18 = licenseFee    This shows the math is wrong:  Assumptions:  - BASE is 1e18 according to the code - timeDiff is exactly ONE_YEAR (for easier calculations) - startSupply is 1e18 (exactly one basket token, also represents 100% in fee terms) - licenseFee is 1e15 (0.1%) If we calculate the fee of one whole year and startSupply is one token (1e18, equal to 100%), the fee should be exactly the licenseFee  (1e15, 0.1%), but the fee is bigger than that.   uint256 timeDiff = ONE_YEAR;  uint256 feePct = timeDiff * licenseFee / ONE_YEAR; => therefore we have: feePct = licenseFee which is 1e15 (0.1%) according to our assumptions  uint256 fee = startSupply * feePct / (BASE - feePct); insert the values => fee = 1e18 * 1e15 / (1e18 - 1e15) => (factor out 1e15) => fee = 1e15 * 1e18 / (1e15 * ( 1e3 - 1) => (cancel 1e15) => 1e18 / ( 1e3 - 1)  math: if we increase the divisor but the dividend stays the same we get a smaller number e.g. (1 / (2-1)) is bigger than (1 / 2) apply this here => 1e18 / ( 1e3 - 1) > 1e18 / 1e3 => 1e18 / ( 1e3 - 1) > 1e15  this shows that the fee is higher than 1e15   https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L133 https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L141  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps - only divide by BASE  
# Handle  gpersoon   # Vulnerability details  ## Impact Most of the public functions have an emit, however in function publishNewIndex(), there is no emit for the "killauction" part. It might be useful to have an emit there too.  ## Proof of Concept https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L216-L244  ```JS  function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {    ...             } else {                 auction.killAuction();                 pendingWeights.tokens = _tokens;                 pendingWeights.weights = _weights;                 pendingWeights.timestamp = block.timestamp;                 pendingWeights.minIbRatio = _minIbRatio;                // no emit             } ```  ## Tools Used  ## Recommended Mitigation Steps Possibly add an emit in the "killauction" part   
# Handle  broccolirob   # Vulnerability details   A malicious "publisher" can create a basket proposal that mixes real ERC20 tokens with a malicious ERC20 token containing a reentrancy callback in it's `approve()` method. When the `initialize()` method is called on the newly cloned `Basket` contract, a method called `approveUnderlying(address(auction))` is called, which would trigger the reentrancy, call `initialize()` again, passing in altered critical values such as `auction` and `factory`, and then removes its self from `proposal.tokens` and `proposal.weights` so it doesn't appear in the token list to basket users.  https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L44-L61  ## Impact `Auction` and `Factory` can be set to custom implementations that do malicious things. Since all baskets and auctions are clones with their own addresses, this fact would be difficult for users to detect. `Auction` controls ibRatio, which a malicious version could send back a manipulated value to `Basket`, allowing the malicious "publisher" to burn basket tokens till all users underlying tokens are drained.  ## Tools Used Manual review and Hardhat.  ## Recommended Mitigation Steps Since `Basket` inherits from `ERC20Upgradeable` the `initializer` modifier should be available and therefore used here. It has an `inititializing` variable that would prevent this kind of reentrancy attack.  
# Handle  0x0x0x   # Vulnerability details  When factory changes `auctionMultiplier` or `auctionDecrement` profitability of bonded auctions change. There is no protection against this behaviour. Furthermore, factory owners can decide to get all tokens from baskets where they are bonded for the auction.  ## Proof of concept  1- Factory owners call `bondForRebalance` for an auction.  2- Factory owners sets `auctionMultiplier` as 0 and `auctionDecrement` as maximum value  3- `settleAuction` is called. `newRatio = 0`, since `a = b = 0`. All tokens can be withdrawn with this call, since `tokensNeeded = 0`.  ## Extra notes  Furthermore, even the factory owners does not try to scam users. In case `auctionMultiplier` or `auctionDecrement` is changed, all current `auctionBonder` from `Auctions` can only call `settleAuction` with different constraints. Because of different constraints, users/bonder will lose/gain funds.  ## Mitigation step  Save `auctionDecrement` and `auctionMultiplier` to global variables in `Auction.sol`, when `startAuction` is called.  
# Handle  0x0x0x   # Vulnerability details  The function is implemented as follows:  ``` function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {         uint256 startSupply = totalSupply();         handleFees(startSupply);         _burn(msg.sender, amount);          uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);         ibRatio = newIbRatio;          emit NewIBRatio(newIbRatio);         emit Burned(msg.sender, amount);     } ```  When `handleFees` is called, `totalSupply` and `ibRatio` changes accordingly, but for `newIbRatio` calculation tokens minted in `handleFees` is not included. Therefore, `ibRatio` is calculated higher than it should be. This is dangerous, since last withdrawing user(s) lose their funds with this operation. In case this miscalculation happens more than once, `newIbRatio` will increase the miscalculation even faster and can result in serious amount of funds missing. At each time `auctionBurn` is called, at least 1 day (auction duration) of fees result in this miscalculation. Furthermore, all critical logic of this contract is based on `ibRatio`, this behaviour can create serious miscalculations.   ## Mitigation step  Rather than  `uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);`  A practical solution to this problem is calculating `newIbRatio` as follows:  ``` uint256 supply = totalSupply(); uint256 newIbRatio = ibRatio * (supply + amount) / supply; ```  
# Handle  gzeon   # Vulnerability details  ## Impact Since tokenName is user supplied and can be duplicated, it is better to emit proposal id instead.  https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Factory.sol#L91 ```         emit BasketLicenseProposed(msg.sender, tokenName); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Auction.sol#L97-L102  ```solidity=97     uint256 a = factory.auctionMultiplier() * basket.ibRatio();     uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();     uint256 newRatio = a - b;      (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();     require(newRatio >= minIbRatio); ```  In the current implementation, `newRatio` is calculated and compared with `minIbRatio` in `settleAuction()`.  However, if `newRatio` is less than `minIbRatio`, `settleAuction()` will always fail and there is no way for the bonder to cancel and get a refund.  ### PoC  Given:  - `bondPercentDiv` = 400 - `basketToken.totalSupply` = 40,000 - `factory.auctionMultiplier` = 2 - `factory.auctionDecrement` = 10,000 - `basket.ibRatio` = 1e18 - p`endingWeights.minIbRatio` = 1.9 * 1e18  1. Alice called `bondForRebalance()` `2,000` blocks after the auction started, paid `100` basketToken for the bond; 2. Alice tries to `settleAuction()`, it will always fail because `newRatio < minIbRatio`; - a = 2 * 1e18 - b = 0.2 * 1e18 - newRatio = 1.8 * 1e18; 3. Bob calls `bondBurn()` one day after, `100` basketToken from Alice will been burned.  ### Recommendation  Move the `minIbRatio` check to `bondForRebalance()`:  ```solidity=58 function bondForRebalance() public override {         require(auctionOngoing);         require(!hasBonded);          bondTimestamp = block.timestamp;         bondBlock = block.number;          uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();         require(newRatio >= minIbRatio);          IERC20 basketToken = IERC20(address(basket));         bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();         basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);         hasBonded = true;         auctionBonder = msg.sender;          emit Bonded(msg.sender, bondAmount);     } ```  
# Handle  Ruhum   # Vulnerability details  ## Impact The `settleAuction()` function allows someone to settle the auction by transferring funds in a way that the new pending index is fulfilled. As a reward, they are able to take out as many tokens as they want as long as the pending index is fulfilled after that. The function verifies that the basket has received everything it wanted using the following logic: ```sol         for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` The attack vector here is to manipulate `tokensNeeded` to be 0. That way we can drain the basket completely without the function reverting.  For that, we manipulate `newRatio` to be 0 then the whole thing will be 0. `newRatio` is defined as: ```sol         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ``` There's 1 value the attacker controls, `bondBlock`. That value is the block in which the `bondForRebalance()` function was triggered. So the goal is to get `newRatio` to be 0. With the base settings of the contract:  - auctionMultiplier == 2 - ibRatio == 1e18 - BASE == 1e18 - auctionDecrement == 10000  `bondBlock` has to be `auctionStart + 20000`. Meaning, the `bondForRebalance()` function has to be triggered exactly 20000 blocks after the action was started. That would be around 3 1/2 days after auction start.  At that point, `newRatio` is 0, and thus `tokensNeeded` is 0. The only thing left to do is to call `settleAuction()` and pass the basket's tokens and balance as the output tokens and weight.  ## Proof of Concept Here's a test implementing the above scenario as a test. You can add it to `Auction.test.js`.:  ```js       it.only("should allow me to steal funds", async() => {         // start an auction         let NEW_UNI_WEIGHT = "2400000000000000000";         let NEW_COMP_WEIGHT = "2000000000000000000";         let NEW_AAVE_WEIGHT = "400000000000000000";          await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address],              [NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;         await increaseTime(60 * 60 * 24)         await increaseTime(60 * 60 * 24)         await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address],            [NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;          let auctionAddr = await basket.auction();         let auction = AuctionImpl.attach(auctionAddr);          ethers.provider.getBlockNumber();         // increase the block number for `bondBlock - auctionStart` to be 20000.         // When that's the case, the result of `newRatio` in `settleAuction()`          // is `0`. And that means `tokensNeeded` is 0. Which means,         // we can take out all the tokens we want using the `outputTokens` array         // without having to worry about basket's balance at the end.         // The math changes depending on the settings of the factory contract or the         // Basket contract. But, the gist is that you try to get newRatio to be 0.         // The only values you can control as a attacker is the bondBlock after the auction         // was started.         for (let i = 0; i < 20000; i++) {           await hre.network.provider.send("evm_mine")         }         await basket.approve(auction.address, '5000000000000000');         await expect(auction.bondForRebalance()).to.be.ok;         await expect(auction.settleAuction([], [], [], [UNI.address, AAVE.address], ["200720000000000000", "200120000000000000"])).to.be.ok;       }); ```  Again, this test uses the base values. The math changes when the settings change. But, it should always be possible to trigger this attack. The gap between auction start and bonding just changes.  ## Tools Used manual analysis  ## Recommended Mitigation Steps - Verify that `newRatio != 0`  
# Handle  kenzo   # Vulnerability details  `handleFees` does not update `lastFee` if `startSupply == 0`. This means that wrongly, extra fee tokens would be minted once the basket is resupplied and `handleFees` is called again.  ## Impact Loss of user funds. The extra minting of fee tokens comes on the expense of the regular basket token owners, which upon withdrawal would get less underlying than their true share, due to the dilution of their tokens' value.  ## Proof of Concept Scenario: - All basket token holders are burning their tokens. The last burn would set totalSupply to 0. - After 1 day, somebody mints basket tokens. `handleFees` would be called upon mint, and would just return since totalSupply == 0. Note: It does not update `lastFee`. ``` } else if (startSupply == 0) {             return; ``` https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L136:#L137 - The next block, somebody else mints a token. Now `handleFees` will be called and will calculate the fees according to the current supply and the time diff between now and `lastFee`: ``` uint256 timeDiff = (block.timestamp - lastFee); ``` https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L139 But as we saw, `lastFee` wasn't updated in the previous step. `lastFee` is still the time of 1 day before - when the last person burned his tokens and the basket supply was 0. So now the basket will mint fees as if a whole day has passed since the last calculation, but actually it only needs to calculate the fees for the last block, since only then we had tokens in the basket.  ## Recommended Mitigation Steps Set `lastFee = block.timestamp` if `startSupply == 0`.  
# Handle  neslinesli93   # Vulnerability details  ## Impact The `initialized` variable has its visibility set to `public`, while it should be private. The reason is that any contract that inherits from `Auction.sol` or `Basket.sol` may reset the value for  the `initialized` variable  ## Recommended Mitigation Steps Reduce `initialized` visibility to `private` in both contracs  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact The fee calculation on L141 is wrong. It should only get divided by BASE and not (BASE - feePct)  ## Proof of Concept This shows dividing only by BASE is correct: Assumptions:  - BASE is 1e18 accordign to the code - timeDiff is exactly ONE_YEAR (for easier calculations) - startSupply is 1e18 (exactly one basket token, also represents 100% in fee terms) - licenseFee is 1e15 (0.1%) If we calculate the fee of one whole year and startSupply is one token (1e18, equal to 100%), the fee should be exactly the licenseFee  (1e15, 0.1%),  uint256 timeDiff = ONE_YEAR;  uint256 feePct = timeDiff * licenseFee / ONE_YEAR; => therefore we have: feePct = licenseFee which is 1e15 (0.1%) according to our assumptions uint256 fee = startSupply * feePct / BASE; // only divide by BASE => insert values => fee = 1e18 * licenseFee  / 1e18 = licenseFee    This shows the math is wrong:  Assumptions:  - BASE is 1e18 according to the code - timeDiff is exactly ONE_YEAR (for easier calculations) - startSupply is 1e18 (exactly one basket token, also represents 100% in fee terms) - licenseFee is 1e15 (0.1%) If we calculate the fee of one whole year and startSupply is one token (1e18, equal to 100%), the fee should be exactly the licenseFee  (1e15, 0.1%), but the fee is bigger than that.   uint256 timeDiff = ONE_YEAR;  uint256 feePct = timeDiff * licenseFee / ONE_YEAR; => therefore we have: feePct = licenseFee which is 1e15 (0.1%) according to our assumptions  uint256 fee = startSupply * feePct / (BASE - feePct); insert the values => fee = 1e18 * 1e15 / (1e18 - 1e15) => (factor out 1e15) => fee = 1e15 * 1e18 / (1e15 * ( 1e3 - 1) => (cancel 1e15) => 1e18 / ( 1e3 - 1)  math: if we increase the divisor but the dividend stays the same we get a smaller number e.g. (1 / (2-1)) is bigger than (1 / 2) apply this here => 1e18 / ( 1e3 - 1) > 1e18 / 1e3 => 1e18 / ( 1e3 - 1) > 1e15  this shows that the fee is higher than 1e15   https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L133 https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L141  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps - only divide by BASE  
# Handle  gpersoon   # Vulnerability details  ## Impact Most of the public functions have an emit, however in function publishNewIndex(), there is no emit for the "killauction" part. It might be useful to have an emit there too.  ## Proof of Concept https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L216-L244  ```JS  function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {    ...             } else {                 auction.killAuction();                 pendingWeights.tokens = _tokens;                 pendingWeights.weights = _weights;                 pendingWeights.timestamp = block.timestamp;                 pendingWeights.minIbRatio = _minIbRatio;                // no emit             } ```  ## Tools Used  ## Recommended Mitigation Steps Possibly add an emit in the "killauction" part   
# Handle  broccolirob   # Vulnerability details   A malicious "publisher" can create a basket proposal that mixes real ERC20 tokens with a malicious ERC20 token containing a reentrancy callback in it's `approve()` method. When the `initialize()` method is called on the newly cloned `Basket` contract, a method called `approveUnderlying(address(auction))` is called, which would trigger the reentrancy, call `initialize()` again, passing in altered critical values such as `auction` and `factory`, and then removes its self from `proposal.tokens` and `proposal.weights` so it doesn't appear in the token list to basket users.  https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L44-L61  ## Impact `Auction` and `Factory` can be set to custom implementations that do malicious things. Since all baskets and auctions are clones with their own addresses, this fact would be difficult for users to detect. `Auction` controls ibRatio, which a malicious version could send back a manipulated value to `Basket`, allowing the malicious "publisher" to burn basket tokens till all users underlying tokens are drained.  ## Tools Used Manual review and Hardhat.  ## Recommended Mitigation Steps Since `Basket` inherits from `ERC20Upgradeable` the `initializer` modifier should be available and therefore used here. It has an `inititializing` variable that would prevent this kind of reentrancy attack.  
# Handle  0x0x0x   # Vulnerability details  When factory changes `auctionMultiplier` or `auctionDecrement` profitability of bonded auctions change. There is no protection against this behaviour. Furthermore, factory owners can decide to get all tokens from baskets where they are bonded for the auction.  ## Proof of concept  1- Factory owners call `bondForRebalance` for an auction.  2- Factory owners sets `auctionMultiplier` as 0 and `auctionDecrement` as maximum value  3- `settleAuction` is called. `newRatio = 0`, since `a = b = 0`. All tokens can be withdrawn with this call, since `tokensNeeded = 0`.  ## Extra notes  Furthermore, even the factory owners does not try to scam users. In case `auctionMultiplier` or `auctionDecrement` is changed, all current `auctionBonder` from `Auctions` can only call `settleAuction` with different constraints. Because of different constraints, users/bonder will lose/gain funds.  ## Mitigation step  Save `auctionDecrement` and `auctionMultiplier` to global variables in `Auction.sol`, when `startAuction` is called.  
# Handle  0x0x0x   # Vulnerability details  The function is implemented as follows:  ``` function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {         uint256 startSupply = totalSupply();         handleFees(startSupply);         _burn(msg.sender, amount);          uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);         ibRatio = newIbRatio;          emit NewIBRatio(newIbRatio);         emit Burned(msg.sender, amount);     } ```  When `handleFees` is called, `totalSupply` and `ibRatio` changes accordingly, but for `newIbRatio` calculation tokens minted in `handleFees` is not included. Therefore, `ibRatio` is calculated higher than it should be. This is dangerous, since last withdrawing user(s) lose their funds with this operation. In case this miscalculation happens more than once, `newIbRatio` will increase the miscalculation even faster and can result in serious amount of funds missing. At each time `auctionBurn` is called, at least 1 day (auction duration) of fees result in this miscalculation. Furthermore, all critical logic of this contract is based on `ibRatio`, this behaviour can create serious miscalculations.   ## Mitigation step  Rather than  `uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);`  A practical solution to this problem is calculating `newIbRatio` as follows:  ``` uint256 supply = totalSupply(); uint256 newIbRatio = ibRatio * (supply + amount) / supply; ```  
# Handle  gzeon   # Vulnerability details  ## Impact Since tokenName is user supplied and can be duplicated, it is better to emit proposal id instead.  https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Factory.sol#L91 ```         emit BasketLicenseProposed(msg.sender, tokenName); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Auction.sol#L97-L102  ```solidity=97     uint256 a = factory.auctionMultiplier() * basket.ibRatio();     uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();     uint256 newRatio = a - b;      (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();     require(newRatio >= minIbRatio); ```  In the current implementation, `newRatio` is calculated and compared with `minIbRatio` in `settleAuction()`.  However, if `newRatio` is less than `minIbRatio`, `settleAuction()` will always fail and there is no way for the bonder to cancel and get a refund.  ### PoC  Given:  - `bondPercentDiv` = 400 - `basketToken.totalSupply` = 40,000 - `factory.auctionMultiplier` = 2 - `factory.auctionDecrement` = 10,000 - `basket.ibRatio` = 1e18 - p`endingWeights.minIbRatio` = 1.9 * 1e18  1. Alice called `bondForRebalance()` `2,000` blocks after the auction started, paid `100` basketToken for the bond; 2. Alice tries to `settleAuction()`, it will always fail because `newRatio < minIbRatio`; - a = 2 * 1e18 - b = 0.2 * 1e18 - newRatio = 1.8 * 1e18; 3. Bob calls `bondBurn()` one day after, `100` basketToken from Alice will been burned.  ### Recommendation  Move the `minIbRatio` check to `bondForRebalance()`:  ```solidity=58 function bondForRebalance() public override {         require(auctionOngoing);         require(!hasBonded);          bondTimestamp = block.timestamp;         bondBlock = block.number;          uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();         require(newRatio >= minIbRatio);          IERC20 basketToken = IERC20(address(basket));         bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();         basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);         hasBonded = true;         auctionBonder = msg.sender;          emit Bonded(msg.sender, bondAmount);     } ```  
# Handle  Ruhum   # Vulnerability details  ## Impact The `settleAuction()` function allows someone to settle the auction by transferring funds in a way that the new pending index is fulfilled. As a reward, they are able to take out as many tokens as they want as long as the pending index is fulfilled after that. The function verifies that the basket has received everything it wanted using the following logic: ```sol         for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` The attack vector here is to manipulate `tokensNeeded` to be 0. That way we can drain the basket completely without the function reverting.  For that, we manipulate `newRatio` to be 0 then the whole thing will be 0. `newRatio` is defined as: ```sol         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ``` There's 1 value the attacker controls, `bondBlock`. That value is the block in which the `bondForRebalance()` function was triggered. So the goal is to get `newRatio` to be 0. With the base settings of the contract:  - auctionMultiplier == 2 - ibRatio == 1e18 - BASE == 1e18 - auctionDecrement == 10000  `bondBlock` has to be `auctionStart + 20000`. Meaning, the `bondForRebalance()` function has to be triggered exactly 20000 blocks after the action was started. That would be around 3 1/2 days after auction start.  At that point, `newRatio` is 0, and thus `tokensNeeded` is 0. The only thing left to do is to call `settleAuction()` and pass the basket's tokens and balance as the output tokens and weight.  ## Proof of Concept Here's a test implementing the above scenario as a test. You can add it to `Auction.test.js`.:  ```js       it.only("should allow me to steal funds", async() => {         // start an auction         let NEW_UNI_WEIGHT = "2400000000000000000";         let NEW_COMP_WEIGHT = "2000000000000000000";         let NEW_AAVE_WEIGHT = "400000000000000000";          await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address],              [NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;         await increaseTime(60 * 60 * 24)         await increaseTime(60 * 60 * 24)         await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address],            [NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;          let auctionAddr = await basket.auction();         let auction = AuctionImpl.attach(auctionAddr);          ethers.provider.getBlockNumber();         // increase the block number for `bondBlock - auctionStart` to be 20000.         // When that's the case, the result of `newRatio` in `settleAuction()`          // is `0`. And that means `tokensNeeded` is 0. Which means,         // we can take out all the tokens we want using the `outputTokens` array         // without having to worry about basket's balance at the end.         // The math changes depending on the settings of the factory contract or the         // Basket contract. But, the gist is that you try to get newRatio to be 0.         // The only values you can control as a attacker is the bondBlock after the auction         // was started.         for (let i = 0; i < 20000; i++) {           await hre.network.provider.send("evm_mine")         }         await basket.approve(auction.address, '5000000000000000');         await expect(auction.bondForRebalance()).to.be.ok;         await expect(auction.settleAuction([], [], [], [UNI.address, AAVE.address], ["200720000000000000", "200120000000000000"])).to.be.ok;       }); ```  Again, this test uses the base values. The math changes when the settings change. But, it should always be possible to trigger this attack. The gap between auction start and bonding just changes.  ## Tools Used manual analysis  ## Recommended Mitigation Steps - Verify that `newRatio != 0`  
# Handle  kenzo   # Vulnerability details  `handleFees` does not update `lastFee` if `startSupply == 0`. This means that wrongly, extra fee tokens would be minted once the basket is resupplied and `handleFees` is called again.  ## Impact Loss of user funds. The extra minting of fee tokens comes on the expense of the regular basket token owners, which upon withdrawal would get less underlying than their true share, due to the dilution of their tokens' value.  ## Proof of Concept Scenario: - All basket token holders are burning their tokens. The last burn would set totalSupply to 0. - After 1 day, somebody mints basket tokens. `handleFees` would be called upon mint, and would just return since totalSupply == 0. Note: It does not update `lastFee`. ``` } else if (startSupply == 0) {             return; ``` https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L136:#L137 - The next block, somebody else mints a token. Now `handleFees` will be called and will calculate the fees according to the current supply and the time diff between now and `lastFee`: ``` uint256 timeDiff = (block.timestamp - lastFee); ``` https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L139 But as we saw, `lastFee` wasn't updated in the previous step. `lastFee` is still the time of 1 day before - when the last person burned his tokens and the basket supply was 0. So now the basket will mint fees as if a whole day has passed since the last calculation, but actually it only needs to calculate the fees for the last block, since only then we had tokens in the basket.  ## Recommended Mitigation Steps Set `lastFee = block.timestamp` if `startSupply == 0`.  
# Handle  neslinesli93   # Vulnerability details  ## Impact The `initialized` variable has its visibility set to `public`, while it should be private. The reason is that any contract that inherits from `Auction.sol` or `Basket.sol` may reset the value for  the `initialized` variable  ## Recommended Mitigation Steps Reduce `initialized` visibility to `private` in both contracs  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact The fee calculation on L141 is wrong. It should only get divided by BASE and not (BASE - feePct)  ## Proof of Concept This shows dividing only by BASE is correct: Assumptions:  - BASE is 1e18 accordign to the code - timeDiff is exactly ONE_YEAR (for easier calculations) - startSupply is 1e18 (exactly one basket token, also represents 100% in fee terms) - licenseFee is 1e15 (0.1%) If we calculate the fee of one whole year and startSupply is one token (1e18, equal to 100%), the fee should be exactly the licenseFee  (1e15, 0.1%),  uint256 timeDiff = ONE_YEAR;  uint256 feePct = timeDiff * licenseFee / ONE_YEAR; => therefore we have: feePct = licenseFee which is 1e15 (0.1%) according to our assumptions uint256 fee = startSupply * feePct / BASE; // only divide by BASE => insert values => fee = 1e18 * licenseFee  / 1e18 = licenseFee    This shows the math is wrong:  Assumptions:  - BASE is 1e18 according to the code - timeDiff is exactly ONE_YEAR (for easier calculations) - startSupply is 1e18 (exactly one basket token, also represents 100% in fee terms) - licenseFee is 1e15 (0.1%) If we calculate the fee of one whole year and startSupply is one token (1e18, equal to 100%), the fee should be exactly the licenseFee  (1e15, 0.1%), but the fee is bigger than that.   uint256 timeDiff = ONE_YEAR;  uint256 feePct = timeDiff * licenseFee / ONE_YEAR; => therefore we have: feePct = licenseFee which is 1e15 (0.1%) according to our assumptions  uint256 fee = startSupply * feePct / (BASE - feePct); insert the values => fee = 1e18 * 1e15 / (1e18 - 1e15) => (factor out 1e15) => fee = 1e15 * 1e18 / (1e15 * ( 1e3 - 1) => (cancel 1e15) => 1e18 / ( 1e3 - 1)  math: if we increase the divisor but the dividend stays the same we get a smaller number e.g. (1 / (2-1)) is bigger than (1 / 2) apply this here => 1e18 / ( 1e3 - 1) > 1e18 / 1e3 => 1e18 / ( 1e3 - 1) > 1e15  this shows that the fee is higher than 1e15   https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L133 https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L141  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps - only divide by BASE  
# Handle  gpersoon   # Vulnerability details  ## Impact Most of the public functions have an emit, however in function publishNewIndex(), there is no emit for the "killauction" part. It might be useful to have an emit there too.  ## Proof of Concept https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L216-L244  ```JS  function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {    ...             } else {                 auction.killAuction();                 pendingWeights.tokens = _tokens;                 pendingWeights.weights = _weights;                 pendingWeights.timestamp = block.timestamp;                 pendingWeights.minIbRatio = _minIbRatio;                // no emit             } ```  ## Tools Used  ## Recommended Mitigation Steps Possibly add an emit in the "killauction" part   
