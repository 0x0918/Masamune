# Handle  leastwood   # Vulnerability details  ## Impact  The `Timelock` struct is used to reference the `releaseTimestamp` and vested `amount` for each vesting. These values can likely be safely stored as `uint64` and `uint192` values respectively, enabling the struct to be stored within a single slot instead of two slots.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L32-L35  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider updating `releaseTimestamp` to `uint64` and `amount` to `uint192` within the `Timelock` struct. It might be worthwhile performing sanity checks when storing these values by using OpenZeppelin's safe math and safe cast libraries.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `claim()` function asserts that the claimable amount is strictly less than `benTotal` for a given user. However, this does not take into account previously claimed tokens, hence the `require` does not accurately depict its intended behaviour.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L197  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider updating this `require` statement to account for already claimed tokens. This could look like the following: `require(amount.add(benClaimed[msg.sender]) <= benTotal[msg.sender], "Cannot withdraw more than total vested amount");`  
# Handle  pauliax   # Vulnerability details  ## Impact  function burnEtherForMember should validate that the address of the member is not empty (0x0) to prevent accidental burns.   When adding an investor distribution (function addInvestor) should validate that the total amount is not above the investors_supply. but then you also need to store the total amount that is already assigned to investors.   function modifyInvestor should validate that _investor != _new, otherwise it will delete the investor unless this is an expected feature.   function claimExact should validate that _value > 0 to prevent useless claims.  
# Handle  pauliax   # Vulnerability details  ## Impact function _recordBurn does not really need this parameter of address _payer as it is always equal to msg.sender.   Consider replacing: function _recordBurn(address _payer, ... emit Burn(_payer, ...  with: function _recordBurn(... emit Burn(msg.sender, ...   
# Handle  pauliax   # Vulnerability details  ## Impact functions validate and modifyInvestor do not need nonReentrant modifier as they do not execute any external calls where you can hook up to re-enter.   
# Handle  pauliax   # Vulnerability details  ## Impact Member total_tokens in both structs Airdrop and Investors is practically not used and is a duplicate of the amount so you can remove it to save some storage. Also, gas efficiency can be improved by tightly packing the struct. Struct variables are stored in 32 bytes each so you can group smaller types to occupy less storage, e.g. airdropBalances which are later translated to the amount in Airdrop struct (10**18) can be stored in a smaller version of uint as we know all the exact values at compile time.   
# Handle  pauliax   # Vulnerability details  ## Impact When revoking the user, there is no need to iterrate over all his timelocks again and calculate the total amount as it should already be stored in a benTotal[_addr] mapping:   uint256 locked = 0;   for (uint256 i = 0; i < timelocks[_addr].length; i++) {       locked = locked.add(timelocks[_addr][i].amount);   }   
# Handle  pauliax   # Vulnerability details  ## Impact function claim can save gas and eliminate duplicate storage access and math operations by caching claimableAmount and re-using it later when setting the benClaimed.   before:   uint256 amount = _claimableAmount(msg.sender).sub(benClaimed[msg.sender]);   ...   benClaimed[msg.sender] = benClaimed[msg.sender].add(amount);  after:   uint256 claimableAmount = _claimableAmount(msg.sender);   uint256 amount = claimableAmount.sub(benClaimed[msg.sender]);   ...   benClaimed[msg.sender] = claimableAmount;  Also, it looks strange that in function revoke the amount is checked with 'assert': assert(amount <= benTotal[_addr]); but in function claim 'require' is used: require(amount <= benTotal[msg.sender], "Cannot withdraw more than total vested amount");  In both places probably 'assert' should be used as it is checking a scenario that should never happen under normal circumstances.   
# Handle  pauliax   # Vulnerability details  ## Impact This check in function modifyInvestor is not neccessary:   require(_investor != address(0), "Invalid old address");  as empty address cannot be added in function addInvestor and later this check will fail:   require(investors[_investor].amount != 0);  
# Handle  pauliax   # Vulnerability details  ## Impact Contracts use assert() instead of require() in multiple places. Assert is recommended to be used to check for internal errors, or to check invariants.  In your case, I think these validations could better use 'require' as they are likely to be triggered: assert(claimable > 0); assert(airdrop[msg.sender].amount - claimable != 0); assert(block.timestamp - startEpochTime <= RATE_TIME); assert(block.timestamp - initTime >= YEAR * 5);  A similar issue was submitted in a previous contest and was assigned a severity of low: https://github.com/code-423n4/2021-06-realitycards-findings/issues/83  ## Recommended Mitigation Steps Consider replacing 'assert' with 'require' in the cases mentioned above.  
# Handle  pauliax   # Vulnerability details  ## Impact burnAddress is hardcoded to 0x03Df4ADDfB568b338f6a0266f30458045bbEFbF2. I see this address is a Gnosis safe multisig. So the eth is not actually burned even though I expected the burn by looking at the code. This confusion happens because the codebase was adopted from Vader protocol but with no actual intention of burning.  ## Recommended Mitigation Steps To reduce this confusion and improve the readability of the codebase you should either rename the burn variables and functions or leave it as it is but comment and document the actual mechanics of the sale.   
# Handle  pauliax   # Vulnerability details  ## Impact function _recordBurn should validate that _eth > 0. Now it is possible to spam this function with 0 eth burns and fictitiously increase member statistics.  I have previously reported this issue in a Vader's contest. You can read find details here: https://github.com/code-423n4/2021-04-vader-findings/issues/269  ## Recommended Mitigation Steps Handle case when _eth = 0 in function _recordBurn.  
# Handle  pauliax   # Vulnerability details  ## Impact There is no reason for the function vest to be 'payable' as it does not handle ether in any way and there is no way to rescue it later in case someone accidentally sends it.  ## Recommended Mitigation Steps Remove 'payable' from the vest function.  
# Handle  defsec   # Vulnerability details  ## Impact  Using the unchecked keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen. E.g. 'unchecked' can be applied in the following lines of code since there are require statements before to ensure the arithmetic operations would not cause an integer underflow or overflow.  ## Proof of Concept  1. Review the all contracts and add unchecked keyword where overflow is not possible.  "https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L579"  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider applying 'unchecked' keyword where overflows/underflows are not possible.    
# Handle  JMukesh   # Vulnerability details  ## Impact bool _iskilled  state variable can be packed with one of the address state variable like {token , owner}  which will save on slot of memory  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/core-contracts/contracts/sol/BTCPoolDelegator.sol#L55  https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/core-contracts/contracts/sol/USDPoolDelegator.sol#L51   ## Tools Used  manual review  ## Recommended Mitigation Steps   
# Handle  JMukesh   # Vulnerability details  ## Impact wrong operator used in checking the fees, adminfee, withdrawfee instead of      require(_fee < SwapUtils.MAX_SWAP_FEE, "_fee exceeds maximum");       _fee < = SwapUtils.Max_Swap_Fee , should be there same with adminfee & withdrawfee becuase in using <= it does not exceed the max value     ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/customswap/contracts/Swap.sol#L192   ## Tools Used manual review  ## Recommended Mitigation Steps use correct operator to check the value  
# Handle  WatchPug   # Vulnerability details  Based on the context, the `tokenPrecisionMultipliers` used in price calculation should be calculated in realtime based on `initialTargetPrice`, `futureTargetPrice`, `futureTargetPriceTime` and current time, just like `getA()` and `getA2()`.  However, in the current implementation, `tokenPrecisionMultipliers` used in price calculation is the stored value, it will only be changed when the owner called `rampTargetPrice()` and `stopRampTargetPrice()`.  As a result, the `targetPrice` set by the owner will not be effective until another `targetPrice` is being set or `stopRampTargetPrice()` is called.  ### Recommendation  Consider adding `Swap.targetPrice` and changing the `_xp()` at L661 from:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L661-L667  ```solidity=661 function _xp(Swap storage self, uint256[] memory balances)     internal     view     returns (uint256[] memory) {     return _xp(balances, self.tokenPrecisionMultipliers); } ```  To:  ```solidity=661 function _xp(Swap storage self, uint256[] memory balances)     internal     view     returns (uint256[] memory) {     uint256[2] memory tokenPrecisionMultipliers = self.tokenPrecisionMultipliers;     tokenPrecisionMultipliers[0] = self.targetPrice.originalPrecisionMultipliers[0].mul(_getTargetPricePrecise(self)).div(WEI_UNIT)     return _xp(balances, tokenPrecisionMultipliers); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/AirdropDistribution.sol#L525-L525 ```solidity=525 require(airdrop[msg.sender].amount != 0); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/AirdropDistribution.sol#L561-L561 ```solidity=561 require(airdrop[msg.sender].amount >= claimable); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/InvestorDistribution.sol#L100-L100 ```solidity=100 require(investors[_investor].amount != 0); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/InvestorDistribution.sol#L126-L126 ```solidity=126 require(investors[msg.sender].amount - claimable != 0); ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/Vesting.sol#L184-L184  ```solidity=184     benVested[_addr][1] = partial_sum; ```  `benVested[_addr][1]` is never used in the contract and the sum of partial claimable vesting is changing every second. Removing it can save gas.  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1163-L1270  - `self.lpToken.totalSupply()` can be cached.  
# Handle  WatchPug   # Vulnerability details  The current design requires the number of pooledTokens to be 2, therefore `pooledTokens.length` can be replaced with literal `2` to save ~100 gas from each storage read (`SLOAD` after Berlin).  Instances include:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1027-L1027  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1068-L1068  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1082-L1082  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1169-L1169  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1230-L1230  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1332-L1334  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1369-L1369  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1421-L1421  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1447-L1447  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1471-L1471  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/Swap.sol#L336-L336  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/Swap.sol#L295-L295  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L620-L623  ```solidity=620 function getD(Swap storage self) internal view returns (uint256) {     uint256 a = determineA(self, _xp(self));            // determine the correct A     return getD(_xp(self), a); } ```  `a` is unnecessary as it's being used only once. The result of `_xp(self)` can be cached to avoid calling it twice.  ### Recommendation  Change to:  ```solidity=620 function getD(Swap storage self) internal view returns (uint256) {     uint256[] memory xp = _xp(self);     return getD(xp, determineA(self, xp)); } ```  
# Handle  WatchPug   # Vulnerability details  There are 4 events with the parameter `lpTokenSupply` in `SwapUtils.sol`, but the value of `lpTokenSupply` is not consistent.  For the event `RemoveLiquidityOne`, `lpTokenSupply` is post burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1349-L1349  ```solidity=1349 emit RemoveLiquidity(msg.sender, amounts, self.lpToken.totalSupply()); ```  For the event `RemoveLiquidityOne`, `lpTokenSupply` is pre burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1368-L1368  For the event `removeLiquidityImbalance`, `lpTokenSupply` is post burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1475-L1481  For the event `AddLiquidity`, `lpTokenSupply` is post mint:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1261-L1267  ### Recommendation  Given that 3 out of the 4 events are using updated `totalSupply` as `lpTokenSupply`, consider changing `RemoveLiquidityOne` to post burn `totalSupply`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1362-L1375  ```solidity=1362 function removeLiquidityOneToken(     Swap storage self,     uint256 tokenAmount,     uint8 tokenIndex,     uint256 minAmount ) external returns (uint256) {     uint256 totalSupply = self.lpToken.totalSupply();     uint256 numTokens = self.pooledTokens.length;     require(         tokenAmount <= self.lpToken.balanceOf(msg.sender),         ">LP.balanceOf"     );     require(tokenIndex < numTokens, "Token not found");  ```  The external call to get the `totalSupply` of the `lpToken` can be done later to avoid unnecessary code execution when the check of `tokenAmount` and `tokenIndex` does not pass.  
# Handle  WatchPug   # Vulnerability details  `getYD()` already `require(tokenIndex < numTokens, "...")`, so the check in `getYDC()` is redundant.  Removing it will make the code simpler and save some gas.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L477-L502  ```solidity=477 function getYDC(     Swap storage self,     uint256 a,     uint8 tokenIndex,     uint256[] memory xp,     uint256 d ) internal view returns (uint256) {     uint256 numTokens = xp.length;     require(tokenIndex < numTokens, "Token not found");      // calculate y     uint256 y = getYD(a, tokenIndex, xp, d);     // ... } ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L522-L557 ```solidity=522 function getYD(     uint256 a,     uint8 tokenIndex,     uint256[] memory xp,     uint256 d ) internal pure returns (uint256) {     uint256 numTokens = xp.length;     require(tokenIndex < numTokens, "Token not found");     // ... } ```   ### Recommendation  Remove the redundant code.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1710-L1714  ```solidity=1710 /**      * @notice Stops ramping Target price immediately. Once this function is called, rampTargetPrce()      * cannot be called for another 24 hours      * @param self TargetPrice struct to update      */ ```  `rampTargetPrce` should be `rampTargetPrice`.  
# Handle  WatchPug   # Vulnerability details  The parameter names of event `RampTargetPrice` should be the same as the struct `TargetPrice` for consistency.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L61-L78  ```solidity=61 event RampTargetPrice(     uint256 oldTargetPrice,     uint256 newTargetPrice,     uint256 initialTime,     uint256 futureTime ); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L117-L124  ```solidity=117{120-121} struct TargetPrice {     uint256 initialTargetPrice;     uint256 futureTargetPrice;     uint256 initialTargetPriceTime;     uint256 futureTargetPriceTime;          uint256[2] originalPrecisionMultipliers; } ```  ### Recommendation  Consider changing to:  ```solidity event RampTargetPrice(     uint256 oldTargetPrice,     uint256 newTargetPrice,     uint256 initialTargetPriceTime,     uint256 futureTargetPriceTime ); ```  
# Handle  WatchPug   # Vulnerability details  `transferredDx` is unnecessary, it can be replaced with `dx`.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1098-L1123  ```solidity=1098{1119-1123} function swap(     Swap storage self,     uint8 tokenIndexFrom,     uint8 tokenIndexTo,     uint256 dx,     uint256 minDy ) external returns (uint256) {     require(         dx <= self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender),         "Cannot swap more than you own"     );      // Transfer tokens first to see if a fee was charged on transfer     uint256 beforeBalance =         self.pooledTokens[tokenIndexFrom].balanceOf(address(this));     self.pooledTokens[tokenIndexFrom].safeTransferFrom(         msg.sender,         address(this),         dx     );      // Use the actual transferred amount for AMM math     uint256 transferredDx =         self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(             beforeBalance         );     // ... ```  ### Recommendation  Change to:  ```solidity // Use the actual transferred amount for AMM math uint256 dx =     self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(         beforeBalance     ); // ... ```  
# Handle  cmichel   # Vulnerability details  The `AirdropDistribution.claimExact` and `InvestorDistribution.claimExact` functions check that `msg.sender != address(0)`.  This is always true, nobody has the private key of the zero address and it cannot be spoofed. This check can be removed.  
# Handle  cmichel   # Vulnerability details  The `Swap.constructor` checks if both arrays `_pooledTokens` and `decimals` are of length two, but then does another check if these arrays have the same length.  ```solidity require(     _pooledTokens.length == decimals.length,     "_pooledTokens decimals mismatch" ); ```  This check will always be true as it has been checked that both arrays are of length two.  
# Handle  cmichel   # Vulnerability details  The protocol uses two amplifier values A1 and A2 for the swap, depending on the target price, see `SwapUtils.determineA`. The swap curve is therefore a join of two different curves at the target price. When doing a trade that crosses the target price, it should first perform the trade partially with A1 up to the target price, and then the rest of the trade order with A2.  However, the `SwapUtils.swap / _calculateSwap` function does not do this, it only uses the "new A", see `getYC` step 5.  ```solidity // 5. Check if we switched A's during the swap if (aNew == a){     // We have used the correct A     return y; } else {    // We have switched A's, do it again with the new A     return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d); } ```  ## Impact Trades that cross the target price and would lead to a new amplifier being used are not split up and use the new amplifier for the _entire trade_. This can lead to a worse (better) average execution price than manually splitting the trade into two transactions, first up to but below the target price, and a second one with the rest of the trader order size, using both A1 and A2 values.  In the worst case, it could even be possible to make the entire trade with one amplifier and then sell the swap result again using the other amplifier making a profit.  ## Recommended Mitigation Steps Trades that lead to a change in amplifier value need to be split up into two trades using both amplifiers to correctly calculate the swap result.   
# Handle  cmichel   # Vulnerability details  The `BasicSale` contract uses a `secondsPerDay` value of `84200` but one day has `86400` seconds.  ## Impact The `secondsPerDay` does not reflect seconds per day.  ## Recommended Mitigation Steps Change the value.  
# Handle  cmichel   # Vulnerability details  The `BasicSale` contract includes ERC20 code like `_balances`, `_allowances` storage variables and `Transfer`, `Approval` events. This code is never used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `Swap.setAdminFee`: The `newAdminFee` should be validated the same way as in the constructor - `Swap.setSwapFee`: The `newSwapFee` should be validated the same way as in the constructor - `Swap.setDefaultWithdrawFee`: The `newWithdrawFee` should be validated the same way as in the constructor  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  jonah1005   # Vulnerability details  # Stop ramp target price would create huge arbitrage space. ## Impact `stopRampTargetPrice` would set the `tokenPrecisionMultipliers` to `originalPrecisionMultipliers[0].mul(currentTargetPrice).div(WEI_UNIT);` Once the `tokenPrecisionMultipliers` is changed, the price in the AMM pool would change. Arbitrager can sandwich `stopRampTargetPrice` to gain profit.  Assume the decision is made in the DAO, an attacker can set up the bot once the proposal to `stopRampTargetPrice` has passed. I consider this is a medium-risk issue.  ## Proof of Concept The `precisionMultiplier` is set here: [Swap.sol#L661-L666](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L661-L666)  We can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue. ```solidity     function setPrecisionMultiplier(uint256 multipliers) external {         swapStorage.tokenPrecisionMultipliers[0] = multipliers;      } ```  ```python print(swap.functions.getVirtualPrice().call()) swap.functions.setPrecisionMultiplier(2).transact() print(swap.functions.getVirtualPrice().call())  # output log: #     1000000000000000000 #     1499889859738721606 ``` ## Tools Used None ## Recommended Mitigation Steps Dealing with the target price with multiplier precision seems clever as we can reuse most of the existing code. However, the precision multiplier should be an immutable parameter. Changing it after the pool is setup would create multiple issues. This function could be implemented in a safer way IMHO.  A quick fix I would come up with is to ramp the `tokenPrecisionMultipliers` as the `aPrecise` is ramped. As the `tokenPrecision` is slowly increased/decreased, the arbitrage space would be slower and the profit would (probably) distribute evenly to lpers.  Please refer to `_getAPreceise`'s implementation [SwapUtils.sol#L227-L250](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L227-L250)  
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive operations  ## Proof of Concept  getD, getY, getYD functions calculate mul(d).div(xp[i].mul(numTokens) within the token cycles https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L538 https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L588 https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L861  d, numTokens are constant there, so the divisions are redundant.  ## Recommended Mitigation Steps  Introduce (d / numTokens) variable and simplify the multiplication  Now: uint256 c = d; ... for (uint256 i = 0; i < numTokens; i++) {   if (i != tokenIndex) {     s = s.add(xp[i]);     c = c.mul(d).div(xp[i].mul(numTokens));  To be: uint256 c = d; uint256 d_num = d.div(numTokens); ... for (uint256 i = 0; i < numTokens; i++) {   if (i != tokenIndex) {     s = s.add(xp[i]);     c = c.mul(d_num).div(xp[i]);  
# Handle  Meta0xNull   # Vulnerability details  ## Impact revoke() Does Not Check Zero Address for _addr  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L104-L105  more...  ## Tools Used Manual Review  ## Recommended Mitigation Steps Check _addr for Zero Address  
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive operations  ## Proof of Concept  SwapUtils.calculateTokenAmount's 'deposit' bool variable is checked on each iteration, while one check is enough https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1031  ## Recommended Mitigation Steps  It's recommended to separate the cycles:  Now: for (uint256 i = 0; i < numTokens; i++) {   if (deposit) {     balances1[i] = balances1[i].add(amounts[i]);   } else {     balances1[i] = balances1[i].sub(       amounts[i],       "Cannot withdraw more than available"     );   } }  To be: if (deposit) {   for (uint256 i = 0; i < numTokens; i++) {    balances1[i] = balances1[i].add(amounts[i]);   } } else {   for (uint256 i = 0; i < numTokens; i++) {    balances1[i] = balances1[i].sub(      amounts[i],      "Cannot withdraw more than available"    );   } }   
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive external function calls  ## Proof of Concept  SwapUtils's addLiquidity function calls LP token totalSupply() several times: 6 code occurrences, one is in cycle. The very last occurrency should be kept as it is, the first 5 of them should be replaced with memory variable as the supply changes only once when LP mint() is called at the end of the function. https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1163  ## Recommended Mitigation Steps  Code update:  Now: if (self.lpToken.totalSupply() != 0) { ...  To be: uint256 lpTotalSupply = self.lpToken.totalSupply(); // storage read and function call if (lpTotalSupply != 0) { ...  
# Handle  Meta0xNull   # Vulnerability details  ## Impact Verify Airdrop Address Holders On Chain by Spending Gas is Unnecessary and probably cost a lot after adding up everyone cost.  ## Recommended At UI Frontend, wallet eg. Metamask allow UI to Verify Address Holders Without Spending Any Gas.  
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive storage reads  ## Proof of Concept  SwapUtils's getVirtualPrice repetitively calls _xp(self), which reads storage https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L705  ## Recommended Mitigation Steps  Now: uint256 a = determineA(self, _xp(self)); uint256 d = getD(_xp(self), a);  To be: uint256[] memory xP = _xp(self.balances, self.tokenPrecisionMultipliers); uint256 d = getD(xP, determineA(self, xP));  
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive storage reads and function calls  ## Proof of Concept  SwapUtils's removeLiquidityImbalance does multiple _xp(self) calls, which can be saved to memory when balances don't change inbetween executions https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1415  ## Recommended Mitigation Steps  Now: uint256[] memory balances1 = self.balances; v.preciseA = determineA(self, _xp(self)); v.d0 = getD(_xp(self), v.preciseA); ... v.d1 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1))); ... v.d2 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1)));  To be: uint256[] memory balances1 = self.balances; uint256[] memory tokenPM = self.tokenPrecisionMultipliers; // doesn't change, save and reuse uint256[] memory xP = _xp(balances1, tokenPM); // We already copied self.balances, no need to reread storage v.d0 = getD(xP, determineA(self, xP)); // v.preciseA isn't used elsewhere and can be dropped ... xP = _xp(balances1, tokenPM); // balances1 was modified, recomputing v.d1 = getD(xP, determineA(self, xP)); ... xP = _xp(balances1, tokenPM); // balances1 was modified, recomputing v.d2 = getD(xP, determineA(self, xP));  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent due to excessive storage reads  ## Proof of Concept  SwapUtils's swap: saving self.pooledTokens[tokenIndexFrom], which do not change, to memory and reusing will reduce gas costs. https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1098  ## Recommended Mitigation Steps  Now: self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender)... ... uint256 beforeBalance = self.pooledTokens[tokenIndexFrom].balanceOf(address(this)); self.pooledTokens[tokenIndexFrom].safeTransferFrom( ... uint256 transferredDx = self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(beforeBalance); To be: IERC20 memory fromToken = self.pooledTokens[tokenIndexFrom]; fromToken.balanceOf(msg.sender)... ... uint256 beforeBalance = fromToken.balanceOf(address(this)); fromToken.safeTransferFrom( ... uint256 transferredDx = fromToken.balanceOf(address(this)).sub(beforeBalance);  
# Handle  hyh   # Vulnerability details  ## Proof of Concept  The only usage is in _claimableAmount function and can be rewritten with one uint256 storage variable. https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L183 benVested cannot be used to get current state as it is updated only during claim() and revoke() calls and calcClaimableAmount() to be used instead.  The timelocks totals and benTotal cannot differ as timelocks are updated and deleted in vest() and revoke() functions only correspondingly, while there benTotal is updated with very same amount without any additional conditions. https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L91 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L128  This way the 's <= benTotal[_addr]' check is redundant and to be removed.  ## Impact  's <= benTotal[_addr]' check can be dangerous: the totals and benTotal cannot differ, while if there would be such a possibility, various attacks might be possible, for example a griefing one, when claim() always fails because of this check, and so on.  I.e. now benVested can be simplified and check is not needed, while if there would be such a situation when it is needed, simple check as it is cannot be sufficient, and some code redesign should be done instead.  ## Recommended Mitigation Steps  Code update: Now: mapping(address => uint256[2]) public benVested; ... uint256 completely_vested = 0; uint256 partial_sum = 0; ... completely_vested = completely_vested.add(timelocks[_addr][i].amount); ... partial_sum = partial_sum.add(claimable); ... benVested[_addr][0] = benVested[_addr][0].add(completely_vested); benVested[_addr][1] = partial_sum; uint256 s = benVested[_addr][0].add(partial_sum); assert(s <= benTotal[_addr]); return s;  To be: mapping(address => uint256) public benVested; ... uint256 currently_vested = 0; ... currently_vested = currently_vested.add(timelocks[_addr][i].amount); ... currently_vested = currently_vested.add(claimable); ... uint256 s = benVested[_addr].add(currently_vested); benVested[_addr] = s; return s;  Also, cleaning in revoke() simplifies to benVested[_addr] = 0; https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L127  
# Handle  jonah1005   # Vulnerability details  ## Impact There's a feature of `virtualPrice` that is monotonically increasing regardless of the market. This function is heavily used in multiple protocols. e.g.(curve metapool, mim, ...) This is not held in the current implementation of customSwap since `customPrecisionMultipliers` can be changed by changing the target price.  There're two issues here: The meaning of `virtualPrice` would be vague. This may damage the lp providers as the protocol that adopts it may be hacked.  I consider this is a medium-risk issue.  ## Proof of Concept We can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue. ```solidity     function setPrecisionMultiplier(uint256 multipliers) external {         swapStorage.tokenPrecisionMultipliers[0] = multipliers;      } ```  ```python     print(swap.functions.getVirtualPrice().call())     swap.functions.setPrecisionMultiplier(2).transact()     print(swap.functions.getVirtualPrice().call())  # output log: #   1000000000000000000 #   1499889859738721606 ``` ## Tools Used None ## Recommended Mitigation Steps Dealing with the target price with multiplier precision seems clever as we can reuse most of the existing code. However, the precision multiplier should be an immutable parameter. Changing it after the pool is set up would create multiple issues. This function could be implemented in a safer way IMHO.  The quick fix would be to remove the `getVirtualPrice` function. I can't come up with a safe way if other protocol wants to use this function.   
# Handle  jonah1005   # Vulnerability details  ## Impact CustomPrecisionMultipliers are set in the constructor: ```solidity         customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).div(10 ** 18); ``` `originalPrecisionMultipliers` equal to 1 if the token's decimal = 18. The targe price could only be an integer.  If the target price is bigger than 10**18, the user can deposit and trade in the pool. Though, the functionality would be far from the spec.  If the target price is set to be smaller than 10**18, the pool would be broken and all funds would be stuck.  I consider this is a high-risk issue.   ## Proof of Concept Please refer to the implementation. [Swap.sol#L184-L187](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L184-L187)  We can also trigger the bug by setting a pool with target price = 0.5. (0.5 * 10**18) ## Tools Used None ## Recommended Mitigation Steps I recommend providing extra 10**18 in both multipliers. ```solidity         customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).mul(10**18).div(10 ** 18);         customPrecisionMultipliers[1] = targetPriceStorage.originalPrecisionMultipliers[1].mul(10**18); ``` The customswap only supports two tokens in a pool, there's should be enough space. Recommend the devs to go through the trade-off saddle finance has paid to support multiple tokens. The code could be more clean and efficient if the pools' not support multiple tokens.   
# Handle  pants   # Vulnerability details  If data can fit into 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. On the MarketPlace.sol contract, string memory variable can be replaced with bytes32 array. That will save gas on the contract.  An example is revert messages. For example look at line 32 of PublicSale.sol.  
# Handle  pants   # Vulnerability details  On L158 of swap.sol, you use a uint8 as the for loop variable:  Due to how the EVM natively works on 256 numbers, using a 8 bit number here introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage  
# Handle  pants   # Vulnerability details  You import "import "./hardhat/console.sol";" and all uses are commented. You should also comment the import. SwapUtils line 9  
# Handle  mics   # Vulnerability details  Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  (non-exhaustive) List of Examples: SwapUtils line 639 USDPoolDelegator line 53 Swap.sol line 135   
# Handle  mics   # Vulnerability details  You could use the variable d instead of defining a new variable y at line 548 of SwapUtils.sol  
# Handle  mics   # Vulnerability details  Missing revert messages in the following places:  1.  ETHPoolDelegator line 67 2.  BTCPoolDelegator line 67 3.  USDPoolDelegator lines 55, 56  
# Handle  mics   # Vulnerability details  safeApprove is now deprecated, see the link below. https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38.  This appears for example in line 499 of AirdropDistribution.sol.  we recommend as in OpenZepplin documentation “whenever possible, use safeIncreaseAllowance and safeDecreaseAllowance instead”.     
# Handle  pmerkleplant   # Vulnerability details  Constants should be written in UPPER_CASE, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#constants).  Constants breaking this convention:  - `decimals` in `tge/contracts/PublicSale.sol` - `coin` in `tge/contracts/PublicSale.sol` - `secondsPerDay` in `tge/contracts/PublicSale.sol` - `firstEra` in `tge/contracts/PublicSale.sol`  
# Handle  pmerkleplant   # Vulnerability details  Contract `Vesting` in `vesting/contracts/Vesting.sol` should inherit from the interface `IVesting` in `vesting/contracts/interfaces/IVesting.sol` as the contract implements the interface.  
# Handle  pmerkleplant   # Vulnerability details  Functions should be written in mixedCase, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#function-names).  Functions breaking this convention:  - Function `_available_supply` in `vesting/contracts/AidropDistribution.sol` - Function `available_supply` in `vesting/contracts/AidropDistribution.sol` - Function `_available_supply` in `vesting/contracts/InvestorDistribution.sol` - Function `available_supply` in `vesting/contracts/InvestorDistribution.sol` - Function `dev_rugpull` in `vesting/contracts/InvestorDistribution.sol`  
# Handle  pmerkleplant   # Vulnerability details  Events should be written in CapWords, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#event-names).  Events breaking this convention:  - `updateMiningParameters` in `vesting/contracts/AidropDistribution.sol` - `updateMiningParameters` in `vesting/contracts/InvestorDistribution.sol`  
# Handle  pmerkleplant   # Vulnerability details  Removing unused variables saves gas and increases code clarity.  Following variables are unused and can be removed:  - `Hour` in `vesting/contracts/AidropDistribution.sol` - `Day` in `vesting/contracts/AirdropDistribution.sol` - `Hour` in `vesting/contracts/InvestorDistribution.sol` - `Day` in `vesting/contracts/InvestorDistribution.sol` - `_balance` in `tge/contracts/PublicSale.sol` - `_allowance` in `tge/contracts/PublicSale.sol`  
# Handle  loop   # Vulnerability details  `AirDropDistribution.sol` and `InvestorDistribution.sol` import the `safeERC20` library but make use of the normal ERC20 `transfer` function rather than `safeTransfer`. Considering this is called on the BOOT token there is likely no need for it to be `safeTransfer`. However, since the library is not used there is no need for it to be imported.   ## Proof of Concept - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L12 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L12  Transfer calls: - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L542 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L567  - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L132 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L156 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L207  
# Handle  jonah1005   # Vulnerability details  ## Impact When a user provides imbalanced liquidity, the fee is calculated according to the ideal balance. In saddle finance, the optimal balance should be the same ratio as in the Pool.  Take, for example, if there's 10000 USD and 10000 DAI in the saddle's USD/DAI pool, the user should get the optimal lp if he provides lp with ratio = 1.  However, if the customSwap pool is created with a target price = 2. The user would get 2 times more lp if he deposits DAI. [SwapUtils.sol#L1227-L1245](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1227-L1245) The current implementation does not calculates ideal balance correctly.  If the target price is set to be 10, the ideal balance deviates by 10. The fee deviates a lot. I consider this is a high-risk issues.  ## Proof of Concept We can observe the issue if we initiates two pools DAI/LINK pool and set the target price to be 4.  For the first pool, we deposit more dai. ```python     swap = deploy_contract('Swap'          [dai.address, link.address], [18, 18], 'lp', 'lp', 1, 85, 10**7, 0, 0, 4* 10**18)     link.functions.approve(swap.address, deposit_amount).transact()     dai.functions.approve(swap.address, deposit_amount).transact()     previous_lp = lptoken.functions.balanceOf(user).call()     swap.functions.addLiquidity([deposit_amount, deposit_amount // 10], 10, 10**18).transact()     post_lp = lptoken.functions.balanceOf(user).call()     print('get lp', post_lp - previous_lp) ```  For the second pool, one we deposit more dai. ```python     swap = deploy_contract('Swap'          [dai.address, link.address], [18, 18], 'lp', 'lp', 1, 85, 10**7, 0, 0, 4* 10**18)     link.functions.approve(swap.address, deposit_amount).transact()     dai.functions.approve(swap.address, deposit_amount).transact()     previous_lp = lptoken.functions.balanceOf(user).call()     swap.functions.addLiquidity([deposit_amount, deposit_amount // 10], 10, 10**18).transact()     post_lp = lptoken.functions.balanceOf(user).call()     print('get lp', post_lp - previous_lp) ```  We can get roughly 4x more lp in the first case ## Tools Used None ## Recommended Mitigation Steps  The current implementation uses `self.balances`  https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1231-L1236 ```soliditiy             for (uint256 i = 0; i < self.pooledTokens.length; i++) {                 uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);                 fees[i] = feePerToken                     .mul(idealBalance.difference(newBalances[i]))                     .div(FEE_DENOMINATOR);                 self.balances[i] = newBalances[i].sub(                     fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)                 );                 newBalances[i] = newBalances[i].sub(fees[i]);             } ```  Replaces `self.balances` with `_xp(self, newBalances)` would be a simple fix. I consider the team can take balance's weighted pool as a reference. [WeightedMath.sol#L149-L179](https://github.com/balancer-labs/balancer-v2-monorepo/blob/7ff72a23bae6ce0eb5b134953cc7d5b79a19d099/pkg/pool-weighted/contracts/WeightedMath.sol#L149-L179)  
# Handle  0v3rf10w   # Vulnerability details  ## Impact Multiple Reentrancy  ## Proof of Concept Reentrancy in BasicSale.receive() (tge/contracts/PublicSale.sol#148-156)  Reentrancy in BasicSale.burnEtherForMember(address) (tge/contracts/PublicSale.sol#158-166)   State variables written after the external call(s) in all above.  ## Tools Used Manual  ## Recommended Mitigation Steps  
# Handle  0v3rf10w   # Vulnerability details  ## Impact Missing Zero address check  ## Proof of Concept BasicSale.constructor(IERC20,IERC721,IVesting,uint256,uint256,uint256,uint256,address)._burnAddress (tge/contracts/PublicSale.sol#112)  lacks a zero-check on :- burnAddress = _burnAddress (tge/contracts/PublicSale.sol#137)  ## Tools Used Manual  ## Recommended Mitigation Steps Check that the address is zero   
# Handle  0v3rf10w   # Vulnerability details  ## Impact Unchecked low-level calls  ## Proof of Concept Unchecked cases at 2 places :- BasicSale.receive() (2021-11-bootfinance/tge/contracts/PublicSale.sol#148-156) ignores return value by burnAddress.call{value: msg.value}() (2021-11-bootfinance/tge/contracts/PublicSale.sol#154)  BasicSale.burnEtherForMember(address) (2021-11-bootfinance/tge/contracts/PublicSale.sol#158-166) ignores return value by burnAddress.call{value: msg.value}() (2021-11-bootfinance/tge/contracts/PublicSale.sol#164)   ## Tools Used Manual  ## Recommended Mitigation Steps The return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low level is used to prevent blocking operations, consider logging failed calls.  
# Handle  jonah1005   # Vulnerability details  ## Impact The sanity checks in `rampTargetPrice` are broken [SwapUtils.sol#L1571-L1581](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1571-L1581) ```solidity         if (futureTargetPricePrecise < initialTargetPricePrecise) {             require(                 futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,                 "futureTargetPrice_ is too small"             );         } else {             require(                 futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),                 "futureTargetPrice_ is too large"             );         } ``` If `futureTargetPricePrecise` is smaller than `initialTargetPricePrecise` 0.01 of `futureTargetPricePrecise` would never larger than `initialTargetPricePrecise`.  Admin would not be able to ramp the target price. As it's one of the most important features of the customswap, I consider this is a high-risk issue  ## Proof of Concept Here's a web3.py script to demo that it's not possible to change the target price even by 1 wei. ```python     p1, p2, _, _ =swap.functions.targetPriceStorage().call()     future = w3.eth.getBlock(w3.eth.block_number)['timestamp'] + 200 * 24 * 3600      # futureTargetPrice_ is too small     swap.functions.rampTargetPrice(p1 -1, future).transact()     # futureTargetPrice_ is too large     swap.functions.rampTargetPrice(p1 + 1, future).transact() ``` ## Tools Used None ## Recommended Mitigation Steps  Would it be something like: ```solidity         if (futureTargetPricePrecise < initialTargetPricePrecise) {             require(                 futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE + WEI_UNIT).div(WEI_UNIT) >= initialTargetPricePrecise,                 "futureTargetPrice_ is too small"             );         } else {             require(                 futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE + WEI_UNIT).div(WEI_UNIT),                 "futureTargetPrice_ is too large"             );         } ``` I believe the dev would spot this mistake if there's a more relaxed timeline.  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact  I'm not sure why some of this code is commented out.   It could point to items that are not done or need redesigning, be a mistake, or just be testing overhead.   ## Proof of Concept The commented out code is here:  Unclear: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L27 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L76  Obviously Test related: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L187  Guarded launch: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L42-L49 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L201-L204 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L235-L237  ## Tools Used VS Code  ## Recommended Mitigation Steps Review and remove or resolve/document the commented out lines if needed.  
# Handle  pants   # Vulnerability details  ## Impact In BTCPoolDelegator contract, address state variables `future_owner` in lines 51 and bool state variable `is_killed` in line 55 should be placed one after another. solidity keep storage in 32 bytes slot and can optimize multiple variables that are less than 32 bytes. address is 20 bytes and bool is 1 byte, so it can be placed in one storage slot instead of two.  ## Proof of Concept Tested it on Remix, saves 50 gas per transaction  ## Recommended Mitigation Steps change ``` 50    uint256 public future_admin_fee; 51    address public future_owner; 52 53    uint256 kill_deadline; 54    uint256 constant kill_deadline_dt = 2 * 30 * 86400; 54    bool is_killed; ``` to ``` 50    uint256 public future_admin_fee; 51    uint256 constant kill_deadline_dt = 2 * 30 * 86400; 52 53    uint256 kill_deadline; 54    address public future_owner; 54    bool is_killed; ```  
# Handle  Reigada   # Vulnerability details  ## Impact The contract BasicSale contains a fallback function and a burnEtherForMember() function with exactly the same implementation. These 2 functions do the following call: _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);  The _recordBurn function contains the following if block: if (mapEraDay_MemberUnits[_era][_day][_member] == 0) {                              // If hasn't contributed to this Day yet     mapMemberEra_Days[_member][_era].push(_day);                                    // Add it     mapEraDay_MemberCount[_era][_day] += 1;                                         // Count member     mapEraDay_Members[_era][_day].push(_member);                                    // Add member }  What does this mean? If a user performs multiple calls to the contract sending 0 ether as msg.value, the if block will be entered and a new key will be pushed to the mapping. Luckily the cost of an addition to or a read from a mapping does not change with the number of keys mapped. But this would totally mess the function getDaysContributedForEra output. Currently this function is only used as a view function, and not used by the smart contract itself. But it's a risk for future implementations that may make use of it.  ## Proof of Concept >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0xd65ffecd5052314bc09f616461ff6aa9efeb857151c0339dc15653fb90ebb91f   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 0   Transaction confirmed   Block: 13577879   Gas used: 117368 (1.75%)  <Transaction '0xd65ffecd5052314bc09f616461ff6aa9efeb857151c0339dc15653fb90ebb91f'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 1  >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0x0a48f89c1266af2c3eea5cdcec93dae76e4ed2a0936e53e8713d669989b88b19   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 1   Transaction confirmed   Block: 13577880   Gas used: 91568 (1.36%)  <Transaction '0x0a48f89c1266af2c3eea5cdcec93dae76e4ed2a0936e53e8713d669989b88b19'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 2  >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0xeb85e31664eb1578f54daba1be112f9533948d0e2414510874ed55fbb3a9a9e0   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 2   Transaction confirmed   Block: 13577881   Gas used: 91568 (1.36%)  <Transaction '0xeb85e31664eb1578f54daba1be112f9533948d0e2414510874ed55fbb3a9a9e0'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 3  ## Tools Used Manual testing  ## Recommended Mitigation Steps Add the following require statement to the fallback and the burnEtherForMember() functions: require(msg.value > 0, "Some ether should be sent")  
# Handle  Reigada   # Vulnerability details  ## Impact As we can see in the contracts AirdropDistribution and InvestorDistribution, they both have the following approve() call: mainToken.approve(address(vestLock), 2**256-1); https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L499 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L80  This is necessary because both contracts transfer tokens to the vesting contract by calling its vest() function: https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L544 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L569 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L134 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L158  The code of the vest() function in the Vesting contract performs a transfer from msg.sender to Vesting contract address -> vestingToken.transferFrom(msg.sender, address(this), _amount); https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L95  Same is done in the BasicSale contract: https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSale.sol#L225  The problem is that this contract is missing the approve() call. For that reason, the contract is totally useless as the function _withdrawShare() will always revert with the following message: revert reason: ERC20: transfer amount exceeds allowance. This means that all the mainToken sent to the contract would be stuck there forever. No way to retrieve them.  How this issue was not detected in the testing phase? Very simple. The mock used by the team has an empty vest() function that performs no transfer call. https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/helper/MockVesting.sol#L10  ## Proof of Concept See below Brownie's custom output: Calling -> publicsale.withdrawShare(1, 1, {'from': user2}) Transaction sent: 0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 5   BasicSale.withdrawShare confirmed (ERC20: transfer amount exceeds allowance)   Block: 13577532   Gas used: 323334 (4.81%)  Call trace for '0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde': Initial call cost  [21344 gas] BasicSale.withdrawShare  0:3724  [16114 / -193010 gas] ├── BasicSale._withdrawShare  111:1109  [8643 / 63957 gas] │   ├── BasicSale._updateEmission  116:405  [53294 / 55739 gas] │   │   └── BasicSale.getDayEmission  233:248  [2445 gas] │   ├── BasicSale._processWithdrawal  437:993  [-7726 / -616 gas] │   │   ├── BasicSale.getEmissionShare  484:859  [4956 / 6919 gas] │   │   │   │ │   │   │   └── MockERC20.balanceOf  [STATICCALL]  616:738  [1963 gas] │   │   │           ├── address: mockerc20.address │   │   │           ├── input arguments: │   │   │           │   └── account: publicsale.address │   │   │           └── return value: 100000000000000000000 │   │   │ │   │   └── SafeMath.sub  924:984  [191 gas] │   └── SafeMath.sub  1040:1100  [191 gas] │ ├── MockERC20.transfer  [CALL]  1269:1554  [1115 / 30109 gas] │   │   ├── address: mockerc20.address │   │   ├── value: 0 │   │   ├── input arguments: │   │   │   ├── recipient: user2.address │   │   │   └── amount: 27272727272727272727 │   │   └── return value: True │   │ │   └── ERC20.transfer  1366:1534  [50 / 28994 gas] │       └── ERC20._transfer  1374:1526  [28944 gas] └── Vesting.vest  [CALL]  1705:3712  [-330491 / -303190 gas]     │   ├── address: vesting.address     │   ├── value: 0     │   ├── input arguments:     │   │   ├── _beneficiary: user2.address     │   │   ├── _amount: 63636363636363636363     │   │   └── _isRevocable: 0     │   └── revert reason: ERC20: transfer amount exceeds allowance <-------------     │     ├── SafeMath.add  1855:1883  [94 gas]     ├── SafeMath.add  3182:3210  [94 gas]     ├── SafeMath.add  3236:3264  [94 gas]     │     └── MockERC20.transferFrom  [CALL]  3341:3700  [99923 / 27019 gas]         │   ├── address: mockerc20.address         │   ├── value: 0         │   ├── input arguments:         │   │   ├── sender: publicsale.address         │   │   ├── recipient: vesting.address         │   │   └── amount: 63636363636363636363         │   └── revert reason: ERC20: transfer amount exceeds allowance         │         └── ERC20.transferFrom  3465:3700  [-97648 / -72904 gas]             └── ERC20._transfer  3473:3625  [24744 gas]  ## Tools Used Manual testing  ## Recommended Mitigation Steps The following approve() call should be added in the constructor of the BasicSale contract: mainToken.approve(address(vestLock), 2**256-1);  
# Handle  0x0x0x   # Vulnerability details  ## Impact Gas optimization  ## Proof of Concept  On Swap.sol at L190 and L191, it is checked that whether _a and _a2 is bigger equal to 0. Since they are both uint256, this condition is always satisfied. Therefore, those conditions are not required.  ## Tools Used  Manual analysis  
# Handle  gpersoon   # Vulnerability details  ## Impact Anyone can call the function vest() of Vesting.sol, for example with a smail "_amount" of tokens, for any _beneficiary.  The function overwrites the value of benRevocable[_beneficiary], effectively erasing any previous value.  So you can set any _beneficiary to Revocable. Although revoke() is only callable by the owner, this is circumventing the entire mechanism of benRevocable.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L73-L98  function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable whenNotPaused {         ...         if(_isRevocable == 0){             benRevocable[_beneficiary] = [false,false];  // just overwrites the value         }         else if(_isRevocable == 1){             benRevocable[_beneficiary] = [true,false]; // just overwrites the value         }        ## Tools Used  ## Recommended Mitigation Steps Whitelist the calling of vest() Or check if values for benRevocable are already set.   
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you are an investor and want to claim the last part of your claimable tokens (or your entire set of claimable tokens if you haven't claimed anything yet). Then you call the function claim() of InvestorDistribution.sol, which has the following statement: "require(investors[msg.sender].amount - claimable != 0);" This statement will prevent you from claiming your tokens because it will stop execution.  Note: with the function claimExact() it is possible to claim the last part.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/InvestorDistribution.sol#L113-L128  function claim() external nonReentrant { ...         require(investors[msg.sender].amount - claimable != 0);         investors[msg.sender].amount -= claimable;  ## Tools Used  ## Recommended Mitigation Steps Remove the require statement.   
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you are eligible for the last part of your airdrop (or your entire airdrop if you haven't claimed anything yet). Then you call the function claim() of AirdropDistribution.sol, which has the following statement: "assert(airdrop[msg.sender].amount - claimable != 0);" This statement will prevent you from claiming your airdrop because it will stop execution.  Note: with the function claimExact() it is possible to claim the last part.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L522-L536  function claim() external nonReentrant {        ..         assert(airdrop[msg.sender].amount - claimable != 0);         airdrop[msg.sender].amount -= claimable;  ## Tools Used  ## Recommended Mitigation Steps Remove the assert statement. Also add the following to validate() , to prevent claiming the airdrop again:       require(validated[msg.sender]== 0, "Already validated.");  
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose someone claims the last part of his airdrop via claimExact() of AirdropDistribution.sol Then airdrop[msg.sender].amount will be set to 0.  Suppose you then call validate() again.  The check "airdrop[msg.sender].amount == 0" will allow you to continue, because amount has just be set to 0. In the next part of the function, airdrop[msg.sender] is overwritten with fresh values and airdrop[msg.sender].claimed will be reset to 0.  Now you can claim your airdrop again (as long as there are tokens present in the contract)  Note: The function claim() prevents this from happening via "assert(airdrop[msg.sender].amount - claimable != 0);", which has its own problems, see other reported issues.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L555-L563  function claimExact(uint256 _value) external nonReentrant {         require(msg.sender != address(0));         require(airdrop[msg.sender].amount != 0);                  uint256 avail = _available_supply();         uint256 claimable = avail * airdrop[msg.sender].fraction / 10**18; //         if (airdrop[msg.sender].claimed != 0){             claimable -= airdrop[msg.sender].claimed;         }          require(airdrop[msg.sender].amount >= claimable); // amount can be equal to claimable         require(_value <= claimable);                       // _value can be equal to claimable         airdrop[msg.sender].amount -= _value;      // amount will be set to 0 with the last claim   // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L504-L517 function validate() external nonReentrant {         ...         require(airdrop[msg.sender].amount == 0, "Already validated.");         ...              Airdrop memory newAirdrop = Airdrop(airdroppable, 0, airdroppable, 10**18 * airdroppable / airdrop_supply);              airdrop[msg.sender] = newAirdrop;              validated[msg.sender] = 1;   // this is set, but isn't checked on entry of this function  ## Tools Used  ## Recommended Mitigation Steps Add the following to validate() :         require(validated[msg.sender]== 0, "Already validated.");  
# Handle  JMukesh   # Vulnerability details  ## Impact Event should be emitted after sensitive action like setting fees, admin_fees otherwise it will be difficult track offchain fees changes  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L57  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L58  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L53  ## Tools Used  manual review ## Recommended Mitigation Steps  event should be emitted after the sensitive action  
# Handle  JMukesh   # Vulnerability details  ## Impact due to lack of checking admin_fee, it can be greater than max_admin_fee  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L57  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L58  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L53  ## Tools Used  manual review  ## Recommended Mitigation Steps  add input validation for admin_fee  
# Handle  nathaniel   # Vulnerability details  ## Impact Inconsistency between the `claim()` function and `claimExact()` function, in that `claimExact` does not check the claimable amount. In the scenario where claimable = 0, and `investors[msg.sender].claimed != 0` then it will attempt to underflow. If `_amount` is 0, then it could potentially reach the `vestLock.vest()` function, where it will then revert with the inaccurate message "amount must be positive" which doesn't reflect the underlying issue.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L145 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L121 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L75  ## Tools Used manual review   ## Recommended Mitigation Steps Add `require(claimable > 0)`  
# Handle  nathaniel   # Vulnerability details  ## Impact `amount` in the `Investors` struct is vague. It would be assumed to be the invested amount, however this amount decreases when the beneficiary claims. A more appropriate name could be `unclaimed_amount`. `claimable_to_send` is not appropriate name in the `claimExact()` function, as it is not the claimable total, instead `exact_claim_to_send` would make more sense. ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L24 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L155   
# Handle  nathaniel   # Vulnerability details  ## Impact Functions include `updateEmission(), dev_rugpull(), setAdmin(), revoke() ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L185 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L203 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L212 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L104  
# Handle  nathaniel   # Vulnerability details  ## Impact The timelocks for any *beneficiary* are unbounded, and can be vested by someone who is not the *beneficiary*. When the array becomes significantly big enough, the vestments will no longer be claimable for the *beneficiary*.  The `vest()` function in Vesting.sol does not check the *beneficiary*, hence anyone can vest for anyone else, pushing a new timelock to the `timelocks[_beneficiary]`. The `_claimableAmount()` function (used by `claim()` function), then loops through the `timelocks[_beneficiary]` to determine the amount to be claimed. A malicious actor can easy repeatedly call the `vest()` function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable.  The malicious actor could do this to each *beneficiary*, locking up all the vestments.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L81 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L195 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L148  ## Tools Used Manual code review  ## Recommended Mitigation Steps - Create a minimum on the vestment amounts, such that it won't be feasible for a malicious actor to create a large amount of vestments. - Restrict the vestment contribution of a *beneficiary* where `require(beneficiary == msg.sender)`  
# Handle  ye0lde   # Vulnerability details  ## Impact  Code clarity  ## Proof of Concept  The function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L291-L298  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to simplify:    <code>     function getDayEmission() public view returns (uint) {            return (remainingSupply > emission ? emission : remainingSupply);     } </code>  
# Handle  ye0lde   # Vulnerability details  ## Impact  Cache Reference To State Variables "currentDay, currentEra, emission" in _updateEmission (PublicSale.sol)  Caching the references to "currentDay, currentEra, emission" will decrease gas usage.   ## Proof of Concept  The variables "currentDay, currentEra, emission" are referenced 20 times in function "_updateEmission" here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L247-L276  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to cache those variables:    <code>  function _updateEmission() private {         uint _now = block.timestamp;                                                                                      // Find now()         if (_now >= nextDayTime) {                                                                                         // If time passed the next Day time                  uint256 _currentDay = currentDay;             uint256 _currentEra = currentEra;             uint256 _emission = emission;              if (remainingSupply > _emission) {                 remainingSupply -= _emission;                                                              }             else {                 remainingSupply = 0;                                                                     }             if (_currentDay >= daysPerEra) {                                                                                 // If time passed the next Era time                 _currentEra += 1; _currentDay = 0;                                                                        // Increment Era, reset Day                 nextEraTime = _now + (secondsPerDay * daysPerEra);                                          // Set next Era time                 _emission = getNextEraEmission();                                                                        // Get correct emission                 mapEra_Emission[currentEra] = _emission;                                                           // Map emission to Era                 emit NewEra(_currentEra, _emission, nextEraTime, totalBurnt);                            // Emit Event             }             _currentDay += 1;                                                                                                     // Increment Day             nextDayTime = _now + secondsPerDay;                                                                  // Set next Day time             _emission = getDayEmission();                                                                                // Check daily Dmission             mapEraDay_EmissionRemaining[_currentEra][_currentDay] = _emission;               // Map emission to Day             uint _era = _currentEra;             uint _day = _currentDay - 1;             if (_currentDay == 1) {                 // new era                 _era = _currentEra - 1;                 _day = daysPerEra;             }              currentDay = _currentDay;             currentEra = _currentEra;             emission = _emission;                 emit NewDay(_currentEra, _currentDay, nextDayTime, mapEraDay_Units[_era][_day], mapEraDay_MemberCount[_era][_day]);         }     } </code>   
# Handle  Reigada   # Vulnerability details  ## Impact In the Vesting contract, the function revoke() sends the vested tokens to the beneficiary and the remaining tokens that are not vested yet are sent to the multisig address. It makes no sense to allow calling this function once the address has already vested the 100% of the tokens (after 1 year in this case -> uint256 _unlockTimestamp = block.timestamp.add(unixYear);).  Basically in this case the function revoke() would behave like a claim() function but doing some extra checks which waste gas (gas paid by the owner of the contract instead of the beneficiary address) and also emitting an extra event -> https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L123  For that reason, it is recommended to add a require statement that handles this case:  uint256 index = timelocks[_addr].length - 1; require (block.timestamp < timelocks[_addr][index].releaseTimestamp, 'Account fully vested');  ## Tools Used Manual testing  ## Recommended Mitigation Steps It is recommended to add a require statement that handles this case in the Vesting.revoke() function:  uint256 index = timelocks[_addr].length - 1; require (block.timestamp < timelocks[_addr][index].releaseTimestamp, 'Account fully vested');  
# Handle  Reigada   # Vulnerability details  ## Impact There is an unnecessary require statement in vesting.claim() -> https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L197  This check is already done in https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L186  ## Tools Used Manual testing  ## Recommended Mitigation Steps Remove the require statement in the claim() function as it is totally unnecessary. The check is already performed in the function _claimableAmount(address _addr).  
# Handle  Reigada   # Vulnerability details  ## Impact In the contract Vesting, function vest(), the parameter _isRevocable is declared as an uint256 when it is used as a boolean.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L77  ## Tools Used Manual review  ## Recommended Mitigation Steps Declare the parameter _isRevocable as a bool.  
# Handle  Ruhum   # Vulnerability details  ## Impact With version 4.x of the ERC20 token, the `approve()` function returns a boolean indicating whether it was successful or not.  https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#IERC20-approve-address-uint256-  Best practice is to either check the return value or use `safeApprove()` / `safeIncreaseAllowance()` which will revert if the operation was unsuccessful  https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#SafeERC20-safeApprove-contract-IERC20-address-uint256-  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L499  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L80  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps use `safeApprove()` or `safeIncreaseAllowance()`  
# Handle  Reigada   # Vulnerability details  ## Impact In both airdrop contracts: AirdropDistribution and InvestorDistribution, once all the participants have claimed their tokens, some will remain in the contract due to some imprecision in the calculations. There is no function that allows to substract them which means that those tokens will remain stuck in the contracts forever.  I have made the test with just 5 participants: user2, user3, user4, user5 & user6.  uint256[5] airdropBalances =     [     4032000,     4032000,     4032000,     4032000,     4032000     ];  >>> 4032000 * 5 20160000  Initially 20160000 tokens were transferred to the contract  mockToken.transfer(airdropdist.address, 20160000000000000000000000)  After 260 weeks, these were the results:  ----------------> mockToken.balanceOf(airdropdist.address) -> 2842805668532461833600 <-----------------  mockToken.balanceOf(user2) -> 1209429431659888052289865 vesting.benTotal(user2.address) -> 2822002007206405455343415 mockToken.balanceOf(user3) -> 1209429431659888052289984 vesting.benTotal(user3.address) -> 2822002007206405455343296 mockToken.balanceOf(user4) -> 1209429431659888052289984 vesting.benTotal(user4.address) -> 2822002007206405455343296 mockToken.balanceOf(user5) -> 1209429431659888052289984 vesting.benTotal(user5.address) -> 2822002007206405455343296 mockToken.balanceOf(user6) -> 1209429431659888052289984 vesting.benTotal(user6.address) -> 2822002007206405455343296  As we can see above 2842 tokens remain in the contract and there is no way to retrieve them.  ## Tools Used Manual testing / brownie  ## Recommended Mitigation Steps Add an onlyOwner function that allows to retrieve all the remaining tokens once all the participants of the airdrop have claimed the whole amount of their rewards.  
# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details On the `AirdropDistribution.sol`, the `airdrop_supply` ([line 462](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L462)) value is set to be `20160000`. However, adding all the `airdropBalances` does show that the value should be `20159997` instead.   ## Impact This does cause some operations on the contract to mislead in the results. This is more noticed on bigger airdropped accounts.  ## Proof of Concept Adding all the `airdropBalances` values do show the difference.  ## Tools Used Manual code review  ## Recommended Mitigation Steps The `airdrop_supply` should be reflecting the actual airdropped balance without misleading the total amount. Change the value to `20159997`.  
# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details On the `claim` function ([line 524](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L524))  of the `AirdropDistribution.sol` contract, the `validated` check is redundant. The flag is only set when the `validate` function is called. Once validated, the amount will always be different than zero, meaning that the check is not necessary.  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps The check could be removed for gas optimization.  
# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details The `_available_supply` and `available_supply` functions on the `AirdropDistribution` (lines [601](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L601) and [607](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L607)) do contain the exact same code.  Furthermore, the `assert` check inside those functions should be changed to a require statement since the check is not an invariant and gas refund should take place if the check fails ([SWC-110](https://swcregistry.io/docs/SWC-110)).  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps The `available_supply` and `_available_supply` functions should be combined into a single public function (public functions can be used internally without any extra gas) or have the public function call the internal implementation and use the private implementation in the contract.  The `assert` check in the `available_supply` function should be changed to a require statement since the check is not an invariant.  
# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details The `InvestorDistribution` ([InvestorDistribution.sol](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol)) contract does contain some statements that could be removed to optimize the gas usage.  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps - Variable set on [Line 77](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L77) can be removed since the implicit value is already zero - On lines 106 and 107 ([here](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L106-L107)), the statement could be changed to a single line containing `delete investors[_investor]`.  
# Handle  PranavG   # Vulnerability details  ## Impact State variables that never change can be declared constant. This can greatly reduce gas costs. Examples : airdrop_supply in AirdropDistribution.sol(#462) investors_supply in InvestorDistribution.sol(#33)  unixYear in Vesting.sol(#30)  ## Recommended Mitigation Steps Add the constant keyword for state variables whose value never change.  
# Handle  PranavG   # Vulnerability details  ## Impact MathUtils.sol has unused import at line #5: import "@openzeppelin/contracts/math/SafeMath.sol"; The import is not used in any way.   ## Recommended Mitigation Steps Remove it to improve readability of the code.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Tokens are locked for 1 day less than specified in spec.  ## Proof of Concept  The vesting period is calculated here in `unixYear`  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L30  This results in a lockup of 364 days rather than the expected 365.  ## Recommended Mitigation Steps  Replace line with `uint256 constant private unixYear = 365 days;`   
# Handle  pants   # Vulnerability details  The function `GaugeController.commit_transfer_ownership()` emits `CommitOwnership` events when the future admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `CommitOwnership` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new future admin is different than the old one.  
# Handle  pants   # Vulnerability details  The function `GaugeController.apply_transfer_ownership()` emits `ApplyOwnership` events when the admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `ApplyOwnership` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new admin is different than the old one.  
# Handle  pants   # Vulnerability details  The function `GaugeController.__init__()` (the constructor) sets the initial admin, but it doesn't emit an appropriate `ApplyOwnership` event.  ## Impact The users won't know who's the initial admin by searching for the first `ApplyOwnership` event, although they should be able to.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit this event.  
# Handle  pants   # Vulnerability details  The function `MainToken.__init__()` (the constructor) sets the initial admin, but it doesn't emit an appropriate `SetAdmin` event.  ## Impact The users won't know who's the initial admin by searching for the first `SetAdmin` event, although they should be able to.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit this event.  
# Handle  pants   # Vulnerability details  The function `LPToken.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  
# Handle  pants   # Vulnerability details  The function `LPToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  
# Handle  pants   # Vulnerability details  The functions `LPToken.transfer()` and `LPToken.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  
# Handle  pants   # Vulnerability details  The function `LPToken.set_minter()` doesn't check that `_minter` doesn't equal zero before it sets it as the new minter.  ## Impact This function can be invoked by mistake with the zero address as `_minter`, causing the system to lose its minter forever, without the option to set a new minter.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Check that `_minter` doesn't equal zero before setting it as the new minter.  
# Handle  pants   # Vulnerability details  The function `LPToken.__init__()` (the constructor) emits `Transfer` events when the amount minted for `msg.sender` is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the amount minted for `msg.sender` is not zero.  
# Handle  pants   # Vulnerability details  The function `MainToken.__init__()` (the constructor) emits `Transfer` events when the amount minted for `msg.sender` is zero. This is always the case, as the value of the constant `INITIAL_SUPPLY` is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the amount minted for `msg.sender` is not zero.  
# Handle  pants   # Vulnerability details  The function `MainToken.set_mint_multisig()` doesn't check that `_minting_multisig` doesn't equal zero before it sets it as the new `minting_multisig`.  ## Impact This function can be invoked by mistake with the zero address as `_minting_multisig`, causing the system to lose its `minting_multisig` forever, without the option to set a new `minting_multisig`.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Check that `_minting_multisig` doesn't equal zero before setting it as the new `minting_multisig`.  
# Handle  pants   # Vulnerability details  The function `MainToken.set_mint_multisig()` emits `SetMintMultisig` events when `minting_multisig` hasn't changed, and left as it was before that transaction.  ## Impact There is no reason to emit these `SetMintMultisig` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new `minting_multisig` is different than the old one.  
# Handle  pants   # Vulnerability details  The function `MainToken.set_admin()` emits `SetAdmin` events when the admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `SetAdmin` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new admin is different than the old one.  
# Handle  pants   # Vulnerability details  The function `MainToken.set_minter()` emits `SetMinter` events when the minter hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `SetMinter` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new minter is different than the old one.  
# Handle  pants   # Vulnerability details  The function `MainToken.burn()` emits `Transfer` events when the burned amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the burned amount is not zero.  
# Handle  pants   # Vulnerability details  The functions `MainToken.mint()` and `MainToken.mint_dev()` emit `Transfer` events when the minted amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the minted amount is not zero.  
# Handle  pants   # Vulnerability details  The function `MainToken.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  
# Handle  pants   # Vulnerability details  The function `MainToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  
# Handle  pants   # Vulnerability details  The functions `MainToken.transfer()` and `MainToken.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  
# Handle  pants   # Vulnerability details  The function `PoolGauge.withdraw()` emits `Withdraw` events when the withdrawn amount is zero.  ## Impact There is no reason to emit these `Withdraw` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the withdrawn amount is not zero.  
# Handle  pants   # Vulnerability details  The function `PoolGauge.deposit()` emits `Deposit` events when the deposited amount is zero.  ## Impact There is no reason to emit these `Deposit` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the deposited amount is not zero.  
# Handle  pants   # Vulnerability details  The function `PoolGauge.withdraw()` doesn't have to execute these lines of code when `_value` equals zero: ``` _balance: uint256 = self.balanceOf[msg.sender] - _value _supply: uint256 = self.totalSupply - _value self.balanceOf[msg.sender] = _balance self.totalSupply = _supply  self._update_liquidity_limit(msg.sender, _balance, _supply)  assert ERC20(self.lp_token).transfer(msg.sender, _value) ```  ## Impact There is no reason to execute these lines of code if `_value` equals zero because they won't affect the system. An identical optimization is already implemented in `PoolGauge.deposit()`.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Execute these lines of code only if `_value` doesn't equal zero.  
# Handle  pants   # Vulnerability details  The function `Token.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  
# Handle  pants   # Vulnerability details  The function `Token.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  
# Handle  pants   # Vulnerability details  The functions `Token.transfer()` and `Token.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  
# Handle  pants   # Vulnerability details  The functions `USDPoolDelegator.balances()`, `USDPoolDelegator.coins()` and `USDPoolDelegator.underlying_coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` / `_underlying_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceeds the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` / `_underlying_coins` array bounds.  
# Handle  pants   # Vulnerability details  The functions `ETHPoolDelegator.balances()` and `ETHPoolDelegator.coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceeds the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` array bounds.  
# Handle  pants   # Vulnerability details  The functions `BTCPoolDelegator.balances()` and `BTCPoolDelegator.coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` array bounds.  
# Handle  defsec   # Vulnerability details  ## Impact  The current ownership transfer process involves the current owner calling Swap.transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier.  ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L30" 2. The contract has many onlyOwner function. 3. The contract is inherited from the Ownable which includes transferOwnership.  ## Tools Used  None  ## Recommended Mitigation Steps  Implement zero address check and Consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.  
# Handle  Reigada   # Vulnerability details  ## Impact The if statement in _updateEmission() can be removed as the condition is already checked in updateEmission() https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L596 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L186  ## Proof of Concept     function _updateEmission() private {         if (block.timestamp >= startEpochTime + RATE_TIME) {             miningEpoch += 1;             startEpochTime = startEpochTime.add(RATE_TIME);             startEpochSupply = startEpochSupply.add(rate.mul(RATE_TIME));              if (miningEpoch < INITIAL_RATE_EPOCH_CUTTOF) {                 rate = rate.mul(EPOCH_INFLATION).div(100000);             }             else {                 rate = 0;             }             emit updateMiningParameters(block.timestamp, rate, startEpochSupply);         }     }      //Update emission to be called at every step change to update emission inflation     function updateEmission() public {         require(block.timestamp >= startEpochTime + RATE_TIME, "Too soon"); // Condition already checked here         _updateEmission();     }  ## Tools Used Manual testing  ## Recommended Mitigation Steps Remove the if condition in the _updateEmission() private function  
# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been seen maxVesting amount is disabled. However, there is no maximum and minimum vesting amount defined. Users can vest small amount. For the protocol liquditiy calculation maximum and minimum threshold should be defined.   ## Proof of Concept  1. Navigate to the following contract.  """ https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L76 """  2. Vesting amount didnt check.  ## Tools Used  Review  ## Recommended Mitigation Steps  It is suggested to check maximum/minimum vesting amount on the contract.   
# Handle  Reigada   # Vulnerability details  ## Impact Multiple calls to transferFrom and transfer are frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of “false” is returned. It’s important to check this. If you don’t, in this concrete case, some airdrop eligible participants could be left without their tokens. It is also a best practice to check this.  ## Proof of Concept AirdropDistributionMock.sol:132:        mainToken.transfer(msg.sender, claimable_to_send); AirdropDistributionMock.sol:157:        mainToken.transfer(msg.sender, claimable_to_send); AirdropDistribution.sol:542:        mainToken.transfer(msg.sender, claimable_to_send); AirdropDistribution.sol:567:        mainToken.transfer(msg.sender, claimable_to_send);  InvestorDistribution.sol:132:        mainToken.transfer(msg.sender, claimable_to_send); InvestorDistribution.sol:156:        mainToken.transfer(msg.sender, claimable_to_send); InvestorDistribution.sol:207:        mainToken.transfer(msg.sender, bal);  Vesting.sol:95:        vestingToken.transferFrom(msg.sender, address(this), _amount);  PublicSale.sol:224:            mainToken.transfer(_member, v_value);   ## Tools Used Manual testing  ## Recommended Mitigation Steps Check the result of transferFrom and transfer. Although if this is done, the contracts will not be compatible with non standard ERC20 tokens like USDT. For that reason, I would rather recommend making use of SafeERC20 library: safeTransfer and safeTransferFrom.  
# Handle  defsec   # Vulnerability details  ## Impact  Using newer compiler versions and the optimizer gives gas optimizations and additional safety checks are available for free.  The advantages of versions 0.8.* over <0.8.0 are:  - Safemath by default from 0.8.0 (can be more gas efficient than library based safemath.) - Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls. - Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs. - Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.    ## Proof of Concept  1. The contest repository contracts contain pragma 0.6.12^. The contracts pragma version should be updated to 0.8.4.  (https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol ) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L3) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/MathUtils.sol#L3) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSale.sol#L2) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSaleBatchWithdraw.sol#L2)  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to upgrade pragma to at least 0.8.4.  
# Handle  ye0lde   # Vulnerability details  ## Impact  getEmissionShare Can Be Rewritten To Be More Efficient (PublicSale.sol)  The "else" and returning 0, can be eliminated.  The existing but unused named return variable "value" can be used instead of a return statement. These changes reduce gas and improve code clarity.  ## Proof of Concept  The getEmissionShare function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L231-L245  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>     function getEmissionShare(uint era, uint day, address member) public view returns (uint value) {           uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units                  if (memberUnits != 0) {             uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units             uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];     // Get emission remaining for Day             uint balance = mainToken.balanceOf(address(this));             if (emissionRemaining > balance) {                 emissionRemaining = balance;                                                // In case less than required emission             }             value = (emissionRemaining * memberUnits) / totalUnits;         // Calculate share         }     }    </code>  
# Handle  ye0lde   # Vulnerability details  ## Impact  _processWithdrawal Can Be Rewritten To Be More Efficient (PublicSale.sol)  The "else", the setting of "value to 0", and the return statement can be eliminated to reduce gas and improve code clarity.  ## Proof of Concept  The _processWithdrawal function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L212-L229  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>     function _processWithdrawal (uint _era, uint _day, address _member) private returns (uint value) {           uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member]; // Get Member Units                  if (memberUnits != 0) {             value = getEmissionShare(_era, _day, _member);          // Get the emission Share for Member             mapEraDay_MemberUnits[_era][_day][_member] = 0;  // Set to 0 since it will be withdrawn             mapEraDay_UnitsRemaining[_era][_day] = mapEraDay_UnitsRemaining[_era][_day].sub(memberUnits);  // Decrement Member Units             mapEraDay_EmissionRemaining[_era][_day] = mapEraDay_EmissionRemaining[_era][_day].sub(value);  // Decrement emission             totalEmitted += value;                                                 // Add to Total Emitted             uint256 v_value = value * 3 / 10;                                 // Transfer 30%, lock the rest in vesting contract                          mainToken.transfer(_member, v_value);                      // ERC20 transfer function             vestLock.vest(_member, value - v_value, 0);             emit Withdrawal(msg.sender, _member, _era, _day, value, mapEraDay_EmissionRemaining[_era][_day]);         }     } </code>  
# Handle  ye0lde   # Vulnerability details  ## Impact  The "else if", the second call to _processWithdrawal, and the return statement can be eliminated to reduce gas and improve code clarity.  ## Proof of Concept  The _withdrawShare function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L201-L210  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>  function _withdrawShare (uint _era, uint _day, address _member) private returns (uint value) {  _updateEmission();    if (_era < currentEra ||                                                          // Allow if in previous Era                                                                          (_era == currentEra && _day < currentDay)) {                // or current Era and previous day    value = _processWithdrawal(_era, _day, _member);   // Process Withdrawal      }   } </code>  
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L187 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L194 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L231  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named returns  
# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L149-L150 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/SwapUtils.sol#L1625 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/SwapUtils.sol#L1679  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L105 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L194-L197  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L152 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L162  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.    
# Handle  ye0lde   # Vulnerability details  ## Impact  The "else if(_isRevocable == 1)" is not needed and can be removed to save gas and improve code clarity.  ## Proof of Concept  The "_isRevocable" variable is guaranteed to be 0 or 1 here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L77  But it is treated like it can have some other value here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L83-L88  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Rewrite these lines https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L83-L88 to <code>  benRevocable[_beneficiary] = (_isRevocable == 0) ? [false,false] : [true,false]; </code>  
# Handle  pants   # Vulnerability details  Since no contract inherent from SwapUtils all internal functions could be set private. For example  getD could be set private to save gas.  
# Handle  pants   # Vulnerability details  optimizing for loops by caching memory array length, instead of calling it every time.  For example at Swap.sol at time 158 you should have  uint8 len = _pooledTokens.length and in the next line define the forloop with stop condition of  i<len  This appears in many places in the code. At some places you did cached the array length correctly.   
# Handle  pants   # Vulnerability details  When double reading a variable from memory the gas efficient way is to cache it and use the cached value.   For example in line 537, 538 of SwapUtils.sol you have two accesses to xp[i]. You can save xp[i] as local variable and then use it instead at the second time.  
# Handle  pants   # Vulnerability details  An admin can (by mistake maybe) addInvestor with address that already exists. This way its funds are locked in the system and cannot be withdrawn, even by the admin.    
# Handle  pants   # Vulnerability details  In InvestorDistribution line 103 you read investors[_investor] multiple times (only at this function investors[_investor] is read 6 times). You could cache the value and call the cached value instead. Investors x = investors[_investor]; And then use x.amount, x.claimed, etc.  
# Handle  pants   # Vulnerability details  In InvestorDistribution you generally use uint256 for every quantity, although 256 bits are much more than necessary. For example for Investor structure you can change all to uint128, and for every normal use it will not affect and save gas.  
# Handle  pants   # Vulnerability details  In InvestorDistribution at line 19 you have      using SafeMath for uint256;  although you use solidity >0.8.0 therefore you don't need to use safeMath for uint256  
# Handle  tqts   # Vulnerability details  ## Impact Several references to storage can be cached to save significant amounts of gas.  ## Proof of Concept File lines are stated in Mitigation Steps.  ## Tools Used Manual review   ## Recommended Mitigation Steps  #### In function calculateWithdrawOneTokenDY (L406) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, so one SLOAD is saved.  #### In function _calculateRemoveLiquidity (L953) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, one of those as condition in a for loop, so at least _pooledTokensLength SLOADS are saved.  #### In function _feePerToken (L1080) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, so one SLOAD is saved.  #### In function swap (L1098) ``` IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom]; ``` The value is used 4 times, so 3 SLOADs are saved. However, this causes a stack too deep error in line 1129. To mitigate this, replace lines 1129-1132 for: ``` uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);         dyAdminFee = dyAdminFee.div(self.tokenPrecisionMultipliers[tokenIndexTo]); ```  #### In function addLiquidity (L1163) ``` uint256 _pooledTokensLength = self.pooledTokens.length; uint256 _lpTokenTotalSupply = self.lpToken.totalSupply(); ``` _pooledTokensLength is used 4 times. 3 SLOADs saved. _lpTokenTotalSupply is used 6 times, however the one in line 1266 is called after a mint() so it's not the same value and thus can't be replaced. 4 SLOADs saved.  #### In function _updateUserWithdrawFee (L1290) ``` uint256 _withdrawFee = self.defaultWithdrawFee; ``` The value is used 3 times, so 2 SLOADs are saved.  #### In function removeLiquidityImbalance (L1415) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used 5 times, twice as a for condition, so at least 2 + _pooledTokensLength SLOADs are saved.  
# Handle  jah   # Vulnerability details  ## Impact  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). If you explicitly initialize it with its default value, you are just wasting gas. ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L77 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L77 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L66  https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6  ## Tools Used Manual analysis  ## Recommended Mitigation Steps  
# Handle  tqts   # Vulnerability details  ## Impact According to the comment in line 148 of Swap.sol, the function checks for _pooledTokens and precisions parameters, however, the require at line 151 is redundant, as it will pass if both previous checks passed.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L151  ## Tools Used  ## Recommended Mitigation Steps Remove the require, or change it to validate the correct precision parameters.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs + risk of accidental changes to values expected to be fixed.  ## Proof of Concept  Several contracts contain variables which are set at deploy time and never changed again. For example see `PublicSale.sol`  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L70-L81  Since solidity 0.6.5, variables can be marked `immutable` which avoids the need for SLOADs when reading these variables - decreasing gas costs and protecting against accidentally modifying these variables.  https://blog.soliditylang.org/2020/05/13/immutable-keyword/#:~:text=With%20version%200.6.,time%20of%20a%20deployed%20contract.  ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  Inspect all contracts for variables which are set once and then never modified, apply `immutable` keyword and adjust constructors to not read these values (instead use passed parameters)  
# Handle  leastwood   # Vulnerability details  ## Impact  The `Timelock` struct is used to reference the `releaseTimestamp` and vested `amount` for each vesting. These values can likely be safely stored as `uint64` and `uint192` values respectively, enabling the struct to be stored within a single slot instead of two slots.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L32-L35  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider updating `releaseTimestamp` to `uint64` and `amount` to `uint192` within the `Timelock` struct. It might be worthwhile performing sanity checks when storing these values by using OpenZeppelin's safe math and safe cast libraries.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `claim()` function asserts that the claimable amount is strictly less than `benTotal` for a given user. However, this does not take into account previously claimed tokens, hence the `require` does not accurately depict its intended behaviour.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L197  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider updating this `require` statement to account for already claimed tokens. This could look like the following: `require(amount.add(benClaimed[msg.sender]) <= benTotal[msg.sender], "Cannot withdraw more than total vested amount");`  
# Handle  pauliax   # Vulnerability details  ## Impact  function burnEtherForMember should validate that the address of the member is not empty (0x0) to prevent accidental burns.   When adding an investor distribution (function addInvestor) should validate that the total amount is not above the investors_supply. but then you also need to store the total amount that is already assigned to investors.   function modifyInvestor should validate that _investor != _new, otherwise it will delete the investor unless this is an expected feature.   function claimExact should validate that _value > 0 to prevent useless claims.  
# Handle  pauliax   # Vulnerability details  ## Impact function _recordBurn does not really need this parameter of address _payer as it is always equal to msg.sender.   Consider replacing: function _recordBurn(address _payer, ... emit Burn(_payer, ...  with: function _recordBurn(... emit Burn(msg.sender, ...   
# Handle  pauliax   # Vulnerability details  ## Impact functions validate and modifyInvestor do not need nonReentrant modifier as they do not execute any external calls where you can hook up to re-enter.   
# Handle  pauliax   # Vulnerability details  ## Impact Member total_tokens in both structs Airdrop and Investors is practically not used and is a duplicate of the amount so you can remove it to save some storage. Also, gas efficiency can be improved by tightly packing the struct. Struct variables are stored in 32 bytes each so you can group smaller types to occupy less storage, e.g. airdropBalances which are later translated to the amount in Airdrop struct (10**18) can be stored in a smaller version of uint as we know all the exact values at compile time.   
# Handle  pauliax   # Vulnerability details  ## Impact When revoking the user, there is no need to iterrate over all his timelocks again and calculate the total amount as it should already be stored in a benTotal[_addr] mapping:   uint256 locked = 0;   for (uint256 i = 0; i < timelocks[_addr].length; i++) {       locked = locked.add(timelocks[_addr][i].amount);   }   
# Handle  pauliax   # Vulnerability details  ## Impact function claim can save gas and eliminate duplicate storage access and math operations by caching claimableAmount and re-using it later when setting the benClaimed.   before:   uint256 amount = _claimableAmount(msg.sender).sub(benClaimed[msg.sender]);   ...   benClaimed[msg.sender] = benClaimed[msg.sender].add(amount);  after:   uint256 claimableAmount = _claimableAmount(msg.sender);   uint256 amount = claimableAmount.sub(benClaimed[msg.sender]);   ...   benClaimed[msg.sender] = claimableAmount;  Also, it looks strange that in function revoke the amount is checked with 'assert': assert(amount <= benTotal[_addr]); but in function claim 'require' is used: require(amount <= benTotal[msg.sender], "Cannot withdraw more than total vested amount");  In both places probably 'assert' should be used as it is checking a scenario that should never happen under normal circumstances.   
# Handle  pauliax   # Vulnerability details  ## Impact This check in function modifyInvestor is not neccessary:   require(_investor != address(0), "Invalid old address");  as empty address cannot be added in function addInvestor and later this check will fail:   require(investors[_investor].amount != 0);  
# Handle  pauliax   # Vulnerability details  ## Impact Contracts use assert() instead of require() in multiple places. Assert is recommended to be used to check for internal errors, or to check invariants.  In your case, I think these validations could better use 'require' as they are likely to be triggered: assert(claimable > 0); assert(airdrop[msg.sender].amount - claimable != 0); assert(block.timestamp - startEpochTime <= RATE_TIME); assert(block.timestamp - initTime >= YEAR * 5);  A similar issue was submitted in a previous contest and was assigned a severity of low: https://github.com/code-423n4/2021-06-realitycards-findings/issues/83  ## Recommended Mitigation Steps Consider replacing 'assert' with 'require' in the cases mentioned above.  
# Handle  pauliax   # Vulnerability details  ## Impact burnAddress is hardcoded to 0x03Df4ADDfB568b338f6a0266f30458045bbEFbF2. I see this address is a Gnosis safe multisig. So the eth is not actually burned even though I expected the burn by looking at the code. This confusion happens because the codebase was adopted from Vader protocol but with no actual intention of burning.  ## Recommended Mitigation Steps To reduce this confusion and improve the readability of the codebase you should either rename the burn variables and functions or leave it as it is but comment and document the actual mechanics of the sale.   
# Handle  pauliax   # Vulnerability details  ## Impact function _recordBurn should validate that _eth > 0. Now it is possible to spam this function with 0 eth burns and fictitiously increase member statistics.  I have previously reported this issue in a Vader's contest. You can read find details here: https://github.com/code-423n4/2021-04-vader-findings/issues/269  ## Recommended Mitigation Steps Handle case when _eth = 0 in function _recordBurn.  
# Handle  pauliax   # Vulnerability details  ## Impact There is no reason for the function vest to be 'payable' as it does not handle ether in any way and there is no way to rescue it later in case someone accidentally sends it.  ## Recommended Mitigation Steps Remove 'payable' from the vest function.  
# Handle  defsec   # Vulnerability details  ## Impact  Using the unchecked keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen. E.g. 'unchecked' can be applied in the following lines of code since there are require statements before to ensure the arithmetic operations would not cause an integer underflow or overflow.  ## Proof of Concept  1. Review the all contracts and add unchecked keyword where overflow is not possible.  "https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L579"  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider applying 'unchecked' keyword where overflows/underflows are not possible.    
# Handle  JMukesh   # Vulnerability details  ## Impact bool _iskilled  state variable can be packed with one of the address state variable like {token , owner}  which will save on slot of memory  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/core-contracts/contracts/sol/BTCPoolDelegator.sol#L55  https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/core-contracts/contracts/sol/USDPoolDelegator.sol#L51   ## Tools Used  manual review  ## Recommended Mitigation Steps   
# Handle  JMukesh   # Vulnerability details  ## Impact wrong operator used in checking the fees, adminfee, withdrawfee instead of      require(_fee < SwapUtils.MAX_SWAP_FEE, "_fee exceeds maximum");       _fee < = SwapUtils.Max_Swap_Fee , should be there same with adminfee & withdrawfee becuase in using <= it does not exceed the max value     ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/customswap/contracts/Swap.sol#L192   ## Tools Used manual review  ## Recommended Mitigation Steps use correct operator to check the value  
# Handle  WatchPug   # Vulnerability details  Based on the context, the `tokenPrecisionMultipliers` used in price calculation should be calculated in realtime based on `initialTargetPrice`, `futureTargetPrice`, `futureTargetPriceTime` and current time, just like `getA()` and `getA2()`.  However, in the current implementation, `tokenPrecisionMultipliers` used in price calculation is the stored value, it will only be changed when the owner called `rampTargetPrice()` and `stopRampTargetPrice()`.  As a result, the `targetPrice` set by the owner will not be effective until another `targetPrice` is being set or `stopRampTargetPrice()` is called.  ### Recommendation  Consider adding `Swap.targetPrice` and changing the `_xp()` at L661 from:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L661-L667  ```solidity=661 function _xp(Swap storage self, uint256[] memory balances)     internal     view     returns (uint256[] memory) {     return _xp(balances, self.tokenPrecisionMultipliers); } ```  To:  ```solidity=661 function _xp(Swap storage self, uint256[] memory balances)     internal     view     returns (uint256[] memory) {     uint256[2] memory tokenPrecisionMultipliers = self.tokenPrecisionMultipliers;     tokenPrecisionMultipliers[0] = self.targetPrice.originalPrecisionMultipliers[0].mul(_getTargetPricePrecise(self)).div(WEI_UNIT)     return _xp(balances, tokenPrecisionMultipliers); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/AirdropDistribution.sol#L525-L525 ```solidity=525 require(airdrop[msg.sender].amount != 0); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/AirdropDistribution.sol#L561-L561 ```solidity=561 require(airdrop[msg.sender].amount >= claimable); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/InvestorDistribution.sol#L100-L100 ```solidity=100 require(investors[_investor].amount != 0); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/InvestorDistribution.sol#L126-L126 ```solidity=126 require(investors[msg.sender].amount - claimable != 0); ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/Vesting.sol#L184-L184  ```solidity=184     benVested[_addr][1] = partial_sum; ```  `benVested[_addr][1]` is never used in the contract and the sum of partial claimable vesting is changing every second. Removing it can save gas.  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1163-L1270  - `self.lpToken.totalSupply()` can be cached.  
# Handle  WatchPug   # Vulnerability details  The current design requires the number of pooledTokens to be 2, therefore `pooledTokens.length` can be replaced with literal `2` to save ~100 gas from each storage read (`SLOAD` after Berlin).  Instances include:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1027-L1027  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1068-L1068  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1082-L1082  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1169-L1169  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1230-L1230  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1332-L1334  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1369-L1369  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1421-L1421  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1447-L1447  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1471-L1471  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/Swap.sol#L336-L336  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/Swap.sol#L295-L295  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L620-L623  ```solidity=620 function getD(Swap storage self) internal view returns (uint256) {     uint256 a = determineA(self, _xp(self));            // determine the correct A     return getD(_xp(self), a); } ```  `a` is unnecessary as it's being used only once. The result of `_xp(self)` can be cached to avoid calling it twice.  ### Recommendation  Change to:  ```solidity=620 function getD(Swap storage self) internal view returns (uint256) {     uint256[] memory xp = _xp(self);     return getD(xp, determineA(self, xp)); } ```  
# Handle  WatchPug   # Vulnerability details  There are 4 events with the parameter `lpTokenSupply` in `SwapUtils.sol`, but the value of `lpTokenSupply` is not consistent.  For the event `RemoveLiquidityOne`, `lpTokenSupply` is post burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1349-L1349  ```solidity=1349 emit RemoveLiquidity(msg.sender, amounts, self.lpToken.totalSupply()); ```  For the event `RemoveLiquidityOne`, `lpTokenSupply` is pre burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1368-L1368  For the event `removeLiquidityImbalance`, `lpTokenSupply` is post burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1475-L1481  For the event `AddLiquidity`, `lpTokenSupply` is post mint:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1261-L1267  ### Recommendation  Given that 3 out of the 4 events are using updated `totalSupply` as `lpTokenSupply`, consider changing `RemoveLiquidityOne` to post burn `totalSupply`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1362-L1375  ```solidity=1362 function removeLiquidityOneToken(     Swap storage self,     uint256 tokenAmount,     uint8 tokenIndex,     uint256 minAmount ) external returns (uint256) {     uint256 totalSupply = self.lpToken.totalSupply();     uint256 numTokens = self.pooledTokens.length;     require(         tokenAmount <= self.lpToken.balanceOf(msg.sender),         ">LP.balanceOf"     );     require(tokenIndex < numTokens, "Token not found");  ```  The external call to get the `totalSupply` of the `lpToken` can be done later to avoid unnecessary code execution when the check of `tokenAmount` and `tokenIndex` does not pass.  
# Handle  WatchPug   # Vulnerability details  `getYD()` already `require(tokenIndex < numTokens, "...")`, so the check in `getYDC()` is redundant.  Removing it will make the code simpler and save some gas.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L477-L502  ```solidity=477 function getYDC(     Swap storage self,     uint256 a,     uint8 tokenIndex,     uint256[] memory xp,     uint256 d ) internal view returns (uint256) {     uint256 numTokens = xp.length;     require(tokenIndex < numTokens, "Token not found");      // calculate y     uint256 y = getYD(a, tokenIndex, xp, d);     // ... } ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L522-L557 ```solidity=522 function getYD(     uint256 a,     uint8 tokenIndex,     uint256[] memory xp,     uint256 d ) internal pure returns (uint256) {     uint256 numTokens = xp.length;     require(tokenIndex < numTokens, "Token not found");     // ... } ```   ### Recommendation  Remove the redundant code.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1710-L1714  ```solidity=1710 /**      * @notice Stops ramping Target price immediately. Once this function is called, rampTargetPrce()      * cannot be called for another 24 hours      * @param self TargetPrice struct to update      */ ```  `rampTargetPrce` should be `rampTargetPrice`.  
# Handle  WatchPug   # Vulnerability details  The parameter names of event `RampTargetPrice` should be the same as the struct `TargetPrice` for consistency.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L61-L78  ```solidity=61 event RampTargetPrice(     uint256 oldTargetPrice,     uint256 newTargetPrice,     uint256 initialTime,     uint256 futureTime ); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L117-L124  ```solidity=117{120-121} struct TargetPrice {     uint256 initialTargetPrice;     uint256 futureTargetPrice;     uint256 initialTargetPriceTime;     uint256 futureTargetPriceTime;          uint256[2] originalPrecisionMultipliers; } ```  ### Recommendation  Consider changing to:  ```solidity event RampTargetPrice(     uint256 oldTargetPrice,     uint256 newTargetPrice,     uint256 initialTargetPriceTime,     uint256 futureTargetPriceTime ); ```  
# Handle  WatchPug   # Vulnerability details  `transferredDx` is unnecessary, it can be replaced with `dx`.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1098-L1123  ```solidity=1098{1119-1123} function swap(     Swap storage self,     uint8 tokenIndexFrom,     uint8 tokenIndexTo,     uint256 dx,     uint256 minDy ) external returns (uint256) {     require(         dx <= self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender),         "Cannot swap more than you own"     );      // Transfer tokens first to see if a fee was charged on transfer     uint256 beforeBalance =         self.pooledTokens[tokenIndexFrom].balanceOf(address(this));     self.pooledTokens[tokenIndexFrom].safeTransferFrom(         msg.sender,         address(this),         dx     );      // Use the actual transferred amount for AMM math     uint256 transferredDx =         self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(             beforeBalance         );     // ... ```  ### Recommendation  Change to:  ```solidity // Use the actual transferred amount for AMM math uint256 dx =     self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(         beforeBalance     ); // ... ```  
# Handle  cmichel   # Vulnerability details  The `AirdropDistribution.claimExact` and `InvestorDistribution.claimExact` functions check that `msg.sender != address(0)`.  This is always true, nobody has the private key of the zero address and it cannot be spoofed. This check can be removed.  
# Handle  cmichel   # Vulnerability details  The `Swap.constructor` checks if both arrays `_pooledTokens` and `decimals` are of length two, but then does another check if these arrays have the same length.  ```solidity require(     _pooledTokens.length == decimals.length,     "_pooledTokens decimals mismatch" ); ```  This check will always be true as it has been checked that both arrays are of length two.  
# Handle  cmichel   # Vulnerability details  The protocol uses two amplifier values A1 and A2 for the swap, depending on the target price, see `SwapUtils.determineA`. The swap curve is therefore a join of two different curves at the target price. When doing a trade that crosses the target price, it should first perform the trade partially with A1 up to the target price, and then the rest of the trade order with A2.  However, the `SwapUtils.swap / _calculateSwap` function does not do this, it only uses the "new A", see `getYC` step 5.  ```solidity // 5. Check if we switched A's during the swap if (aNew == a){     // We have used the correct A     return y; } else {    // We have switched A's, do it again with the new A     return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d); } ```  ## Impact Trades that cross the target price and would lead to a new amplifier being used are not split up and use the new amplifier for the _entire trade_. This can lead to a worse (better) average execution price than manually splitting the trade into two transactions, first up to but below the target price, and a second one with the rest of the trader order size, using both A1 and A2 values.  In the worst case, it could even be possible to make the entire trade with one amplifier and then sell the swap result again using the other amplifier making a profit.  ## Recommended Mitigation Steps Trades that lead to a change in amplifier value need to be split up into two trades using both amplifiers to correctly calculate the swap result.   
# Handle  cmichel   # Vulnerability details  The `BasicSale` contract uses a `secondsPerDay` value of `84200` but one day has `86400` seconds.  ## Impact The `secondsPerDay` does not reflect seconds per day.  ## Recommended Mitigation Steps Change the value.  
# Handle  cmichel   # Vulnerability details  The `BasicSale` contract includes ERC20 code like `_balances`, `_allowances` storage variables and `Transfer`, `Approval` events. This code is never used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `Swap.setAdminFee`: The `newAdminFee` should be validated the same way as in the constructor - `Swap.setSwapFee`: The `newSwapFee` should be validated the same way as in the constructor - `Swap.setDefaultWithdrawFee`: The `newWithdrawFee` should be validated the same way as in the constructor  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  jonah1005   # Vulnerability details  # Stop ramp target price would create huge arbitrage space. ## Impact `stopRampTargetPrice` would set the `tokenPrecisionMultipliers` to `originalPrecisionMultipliers[0].mul(currentTargetPrice).div(WEI_UNIT);` Once the `tokenPrecisionMultipliers` is changed, the price in the AMM pool would change. Arbitrager can sandwich `stopRampTargetPrice` to gain profit.  Assume the decision is made in the DAO, an attacker can set up the bot once the proposal to `stopRampTargetPrice` has passed. I consider this is a medium-risk issue.  ## Proof of Concept The `precisionMultiplier` is set here: [Swap.sol#L661-L666](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L661-L666)  We can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue. ```solidity     function setPrecisionMultiplier(uint256 multipliers) external {         swapStorage.tokenPrecisionMultipliers[0] = multipliers;      } ```  ```python print(swap.functions.getVirtualPrice().call()) swap.functions.setPrecisionMultiplier(2).transact() print(swap.functions.getVirtualPrice().call())  # output log: #     1000000000000000000 #     1499889859738721606 ``` ## Tools Used None ## Recommended Mitigation Steps Dealing with the target price with multiplier precision seems clever as we can reuse most of the existing code. However, the precision multiplier should be an immutable parameter. Changing it after the pool is setup would create multiple issues. This function could be implemented in a safer way IMHO.  A quick fix I would come up with is to ramp the `tokenPrecisionMultipliers` as the `aPrecise` is ramped. As the `tokenPrecision` is slowly increased/decreased, the arbitrage space would be slower and the profit would (probably) distribute evenly to lpers.  Please refer to `_getAPreceise`'s implementation [SwapUtils.sol#L227-L250](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L227-L250)  
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive operations  ## Proof of Concept  getD, getY, getYD functions calculate mul(d).div(xp[i].mul(numTokens) within the token cycles https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L538 https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L588 https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L861  d, numTokens are constant there, so the divisions are redundant.  ## Recommended Mitigation Steps  Introduce (d / numTokens) variable and simplify the multiplication  Now: uint256 c = d; ... for (uint256 i = 0; i < numTokens; i++) {   if (i != tokenIndex) {     s = s.add(xp[i]);     c = c.mul(d).div(xp[i].mul(numTokens));  To be: uint256 c = d; uint256 d_num = d.div(numTokens); ... for (uint256 i = 0; i < numTokens; i++) {   if (i != tokenIndex) {     s = s.add(xp[i]);     c = c.mul(d_num).div(xp[i]);  
# Handle  Meta0xNull   # Vulnerability details  ## Impact revoke() Does Not Check Zero Address for _addr  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L104-L105  more...  ## Tools Used Manual Review  ## Recommended Mitigation Steps Check _addr for Zero Address  
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive operations  ## Proof of Concept  SwapUtils.calculateTokenAmount's 'deposit' bool variable is checked on each iteration, while one check is enough https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1031  ## Recommended Mitigation Steps  It's recommended to separate the cycles:  Now: for (uint256 i = 0; i < numTokens; i++) {   if (deposit) {     balances1[i] = balances1[i].add(amounts[i]);   } else {     balances1[i] = balances1[i].sub(       amounts[i],       "Cannot withdraw more than available"     );   } }  To be: if (deposit) {   for (uint256 i = 0; i < numTokens; i++) {    balances1[i] = balances1[i].add(amounts[i]);   } } else {   for (uint256 i = 0; i < numTokens; i++) {    balances1[i] = balances1[i].sub(      amounts[i],      "Cannot withdraw more than available"    );   } }   
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive external function calls  ## Proof of Concept  SwapUtils's addLiquidity function calls LP token totalSupply() several times: 6 code occurrences, one is in cycle. The very last occurrency should be kept as it is, the first 5 of them should be replaced with memory variable as the supply changes only once when LP mint() is called at the end of the function. https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1163  ## Recommended Mitigation Steps  Code update:  Now: if (self.lpToken.totalSupply() != 0) { ...  To be: uint256 lpTotalSupply = self.lpToken.totalSupply(); // storage read and function call if (lpTotalSupply != 0) { ...  
# Handle  Meta0xNull   # Vulnerability details  ## Impact Verify Airdrop Address Holders On Chain by Spending Gas is Unnecessary and probably cost a lot after adding up everyone cost.  ## Recommended At UI Frontend, wallet eg. Metamask allow UI to Verify Address Holders Without Spending Any Gas.  
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive storage reads  ## Proof of Concept  SwapUtils's getVirtualPrice repetitively calls _xp(self), which reads storage https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L705  ## Recommended Mitigation Steps  Now: uint256 a = determineA(self, _xp(self)); uint256 d = getD(_xp(self), a);  To be: uint256[] memory xP = _xp(self.balances, self.tokenPrecisionMultipliers); uint256 d = getD(xP, determineA(self, xP));  
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive storage reads and function calls  ## Proof of Concept  SwapUtils's removeLiquidityImbalance does multiple _xp(self) calls, which can be saved to memory when balances don't change inbetween executions https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1415  ## Recommended Mitigation Steps  Now: uint256[] memory balances1 = self.balances; v.preciseA = determineA(self, _xp(self)); v.d0 = getD(_xp(self), v.preciseA); ... v.d1 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1))); ... v.d2 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1)));  To be: uint256[] memory balances1 = self.balances; uint256[] memory tokenPM = self.tokenPrecisionMultipliers; // doesn't change, save and reuse uint256[] memory xP = _xp(balances1, tokenPM); // We already copied self.balances, no need to reread storage v.d0 = getD(xP, determineA(self, xP)); // v.preciseA isn't used elsewhere and can be dropped ... xP = _xp(balances1, tokenPM); // balances1 was modified, recomputing v.d1 = getD(xP, determineA(self, xP)); ... xP = _xp(balances1, tokenPM); // balances1 was modified, recomputing v.d2 = getD(xP, determineA(self, xP));  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent due to excessive storage reads  ## Proof of Concept  SwapUtils's swap: saving self.pooledTokens[tokenIndexFrom], which do not change, to memory and reusing will reduce gas costs. https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1098  ## Recommended Mitigation Steps  Now: self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender)... ... uint256 beforeBalance = self.pooledTokens[tokenIndexFrom].balanceOf(address(this)); self.pooledTokens[tokenIndexFrom].safeTransferFrom( ... uint256 transferredDx = self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(beforeBalance); To be: IERC20 memory fromToken = self.pooledTokens[tokenIndexFrom]; fromToken.balanceOf(msg.sender)... ... uint256 beforeBalance = fromToken.balanceOf(address(this)); fromToken.safeTransferFrom( ... uint256 transferredDx = fromToken.balanceOf(address(this)).sub(beforeBalance);  
# Handle  hyh   # Vulnerability details  ## Proof of Concept  The only usage is in _claimableAmount function and can be rewritten with one uint256 storage variable. https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L183 benVested cannot be used to get current state as it is updated only during claim() and revoke() calls and calcClaimableAmount() to be used instead.  The timelocks totals and benTotal cannot differ as timelocks are updated and deleted in vest() and revoke() functions only correspondingly, while there benTotal is updated with very same amount without any additional conditions. https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L91 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L128  This way the 's <= benTotal[_addr]' check is redundant and to be removed.  ## Impact  's <= benTotal[_addr]' check can be dangerous: the totals and benTotal cannot differ, while if there would be such a possibility, various attacks might be possible, for example a griefing one, when claim() always fails because of this check, and so on.  I.e. now benVested can be simplified and check is not needed, while if there would be such a situation when it is needed, simple check as it is cannot be sufficient, and some code redesign should be done instead.  ## Recommended Mitigation Steps  Code update: Now: mapping(address => uint256[2]) public benVested; ... uint256 completely_vested = 0; uint256 partial_sum = 0; ... completely_vested = completely_vested.add(timelocks[_addr][i].amount); ... partial_sum = partial_sum.add(claimable); ... benVested[_addr][0] = benVested[_addr][0].add(completely_vested); benVested[_addr][1] = partial_sum; uint256 s = benVested[_addr][0].add(partial_sum); assert(s <= benTotal[_addr]); return s;  To be: mapping(address => uint256) public benVested; ... uint256 currently_vested = 0; ... currently_vested = currently_vested.add(timelocks[_addr][i].amount); ... currently_vested = currently_vested.add(claimable); ... uint256 s = benVested[_addr].add(currently_vested); benVested[_addr] = s; return s;  Also, cleaning in revoke() simplifies to benVested[_addr] = 0; https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L127  
# Handle  jonah1005   # Vulnerability details  ## Impact There's a feature of `virtualPrice` that is monotonically increasing regardless of the market. This function is heavily used in multiple protocols. e.g.(curve metapool, mim, ...) This is not held in the current implementation of customSwap since `customPrecisionMultipliers` can be changed by changing the target price.  There're two issues here: The meaning of `virtualPrice` would be vague. This may damage the lp providers as the protocol that adopts it may be hacked.  I consider this is a medium-risk issue.  ## Proof of Concept We can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue. ```solidity     function setPrecisionMultiplier(uint256 multipliers) external {         swapStorage.tokenPrecisionMultipliers[0] = multipliers;      } ```  ```python     print(swap.functions.getVirtualPrice().call())     swap.functions.setPrecisionMultiplier(2).transact()     print(swap.functions.getVirtualPrice().call())  # output log: #   1000000000000000000 #   1499889859738721606 ``` ## Tools Used None ## Recommended Mitigation Steps Dealing with the target price with multiplier precision seems clever as we can reuse most of the existing code. However, the precision multiplier should be an immutable parameter. Changing it after the pool is set up would create multiple issues. This function could be implemented in a safer way IMHO.  The quick fix would be to remove the `getVirtualPrice` function. I can't come up with a safe way if other protocol wants to use this function.   
# Handle  jonah1005   # Vulnerability details  ## Impact CustomPrecisionMultipliers are set in the constructor: ```solidity         customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).div(10 ** 18); ``` `originalPrecisionMultipliers` equal to 1 if the token's decimal = 18. The targe price could only be an integer.  If the target price is bigger than 10**18, the user can deposit and trade in the pool. Though, the functionality would be far from the spec.  If the target price is set to be smaller than 10**18, the pool would be broken and all funds would be stuck.  I consider this is a high-risk issue.   ## Proof of Concept Please refer to the implementation. [Swap.sol#L184-L187](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L184-L187)  We can also trigger the bug by setting a pool with target price = 0.5. (0.5 * 10**18) ## Tools Used None ## Recommended Mitigation Steps I recommend providing extra 10**18 in both multipliers. ```solidity         customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).mul(10**18).div(10 ** 18);         customPrecisionMultipliers[1] = targetPriceStorage.originalPrecisionMultipliers[1].mul(10**18); ``` The customswap only supports two tokens in a pool, there's should be enough space. Recommend the devs to go through the trade-off saddle finance has paid to support multiple tokens. The code could be more clean and efficient if the pools' not support multiple tokens.   
# Handle  pants   # Vulnerability details  If data can fit into 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. On the MarketPlace.sol contract, string memory variable can be replaced with bytes32 array. That will save gas on the contract.  An example is revert messages. For example look at line 32 of PublicSale.sol.  
# Handle  pants   # Vulnerability details  On L158 of swap.sol, you use a uint8 as the for loop variable:  Due to how the EVM natively works on 256 numbers, using a 8 bit number here introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage  
# Handle  pants   # Vulnerability details  You import "import "./hardhat/console.sol";" and all uses are commented. You should also comment the import. SwapUtils line 9  
# Handle  mics   # Vulnerability details  Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  (non-exhaustive) List of Examples: SwapUtils line 639 USDPoolDelegator line 53 Swap.sol line 135   
# Handle  mics   # Vulnerability details  You could use the variable d instead of defining a new variable y at line 548 of SwapUtils.sol  
# Handle  mics   # Vulnerability details  Missing revert messages in the following places:  1.  ETHPoolDelegator line 67 2.  BTCPoolDelegator line 67 3.  USDPoolDelegator lines 55, 56  
# Handle  mics   # Vulnerability details  safeApprove is now deprecated, see the link below. https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38.  This appears for example in line 499 of AirdropDistribution.sol.  we recommend as in OpenZepplin documentation “whenever possible, use safeIncreaseAllowance and safeDecreaseAllowance instead”.     
# Handle  pmerkleplant   # Vulnerability details  Constants should be written in UPPER_CASE, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#constants).  Constants breaking this convention:  - `decimals` in `tge/contracts/PublicSale.sol` - `coin` in `tge/contracts/PublicSale.sol` - `secondsPerDay` in `tge/contracts/PublicSale.sol` - `firstEra` in `tge/contracts/PublicSale.sol`  
# Handle  pmerkleplant   # Vulnerability details  Contract `Vesting` in `vesting/contracts/Vesting.sol` should inherit from the interface `IVesting` in `vesting/contracts/interfaces/IVesting.sol` as the contract implements the interface.  
# Handle  pmerkleplant   # Vulnerability details  Functions should be written in mixedCase, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#function-names).  Functions breaking this convention:  - Function `_available_supply` in `vesting/contracts/AidropDistribution.sol` - Function `available_supply` in `vesting/contracts/AidropDistribution.sol` - Function `_available_supply` in `vesting/contracts/InvestorDistribution.sol` - Function `available_supply` in `vesting/contracts/InvestorDistribution.sol` - Function `dev_rugpull` in `vesting/contracts/InvestorDistribution.sol`  
# Handle  pmerkleplant   # Vulnerability details  Events should be written in CapWords, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#event-names).  Events breaking this convention:  - `updateMiningParameters` in `vesting/contracts/AidropDistribution.sol` - `updateMiningParameters` in `vesting/contracts/InvestorDistribution.sol`  
# Handle  pmerkleplant   # Vulnerability details  Removing unused variables saves gas and increases code clarity.  Following variables are unused and can be removed:  - `Hour` in `vesting/contracts/AidropDistribution.sol` - `Day` in `vesting/contracts/AirdropDistribution.sol` - `Hour` in `vesting/contracts/InvestorDistribution.sol` - `Day` in `vesting/contracts/InvestorDistribution.sol` - `_balance` in `tge/contracts/PublicSale.sol` - `_allowance` in `tge/contracts/PublicSale.sol`  
# Handle  loop   # Vulnerability details  `AirDropDistribution.sol` and `InvestorDistribution.sol` import the `safeERC20` library but make use of the normal ERC20 `transfer` function rather than `safeTransfer`. Considering this is called on the BOOT token there is likely no need for it to be `safeTransfer`. However, since the library is not used there is no need for it to be imported.   ## Proof of Concept - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L12 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L12  Transfer calls: - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L542 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L567  - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L132 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L156 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L207  
# Handle  jonah1005   # Vulnerability details  ## Impact When a user provides imbalanced liquidity, the fee is calculated according to the ideal balance. In saddle finance, the optimal balance should be the same ratio as in the Pool.  Take, for example, if there's 10000 USD and 10000 DAI in the saddle's USD/DAI pool, the user should get the optimal lp if he provides lp with ratio = 1.  However, if the customSwap pool is created with a target price = 2. The user would get 2 times more lp if he deposits DAI. [SwapUtils.sol#L1227-L1245](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1227-L1245) The current implementation does not calculates ideal balance correctly.  If the target price is set to be 10, the ideal balance deviates by 10. The fee deviates a lot. I consider this is a high-risk issues.  ## Proof of Concept We can observe the issue if we initiates two pools DAI/LINK pool and set the target price to be 4.  For the first pool, we deposit more dai. ```python     swap = deploy_contract('Swap'          [dai.address, link.address], [18, 18], 'lp', 'lp', 1, 85, 10**7, 0, 0, 4* 10**18)     link.functions.approve(swap.address, deposit_amount).transact()     dai.functions.approve(swap.address, deposit_amount).transact()     previous_lp = lptoken.functions.balanceOf(user).call()     swap.functions.addLiquidity([deposit_amount, deposit_amount // 10], 10, 10**18).transact()     post_lp = lptoken.functions.balanceOf(user).call()     print('get lp', post_lp - previous_lp) ```  For the second pool, one we deposit more dai. ```python     swap = deploy_contract('Swap'          [dai.address, link.address], [18, 18], 'lp', 'lp', 1, 85, 10**7, 0, 0, 4* 10**18)     link.functions.approve(swap.address, deposit_amount).transact()     dai.functions.approve(swap.address, deposit_amount).transact()     previous_lp = lptoken.functions.balanceOf(user).call()     swap.functions.addLiquidity([deposit_amount, deposit_amount // 10], 10, 10**18).transact()     post_lp = lptoken.functions.balanceOf(user).call()     print('get lp', post_lp - previous_lp) ```  We can get roughly 4x more lp in the first case ## Tools Used None ## Recommended Mitigation Steps  The current implementation uses `self.balances`  https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1231-L1236 ```soliditiy             for (uint256 i = 0; i < self.pooledTokens.length; i++) {                 uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);                 fees[i] = feePerToken                     .mul(idealBalance.difference(newBalances[i]))                     .div(FEE_DENOMINATOR);                 self.balances[i] = newBalances[i].sub(                     fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)                 );                 newBalances[i] = newBalances[i].sub(fees[i]);             } ```  Replaces `self.balances` with `_xp(self, newBalances)` would be a simple fix. I consider the team can take balance's weighted pool as a reference. [WeightedMath.sol#L149-L179](https://github.com/balancer-labs/balancer-v2-monorepo/blob/7ff72a23bae6ce0eb5b134953cc7d5b79a19d099/pkg/pool-weighted/contracts/WeightedMath.sol#L149-L179)  
# Handle  0v3rf10w   # Vulnerability details  ## Impact Multiple Reentrancy  ## Proof of Concept Reentrancy in BasicSale.receive() (tge/contracts/PublicSale.sol#148-156)  Reentrancy in BasicSale.burnEtherForMember(address) (tge/contracts/PublicSale.sol#158-166)   State variables written after the external call(s) in all above.  ## Tools Used Manual  ## Recommended Mitigation Steps  
# Handle  0v3rf10w   # Vulnerability details  ## Impact Missing Zero address check  ## Proof of Concept BasicSale.constructor(IERC20,IERC721,IVesting,uint256,uint256,uint256,uint256,address)._burnAddress (tge/contracts/PublicSale.sol#112)  lacks a zero-check on :- burnAddress = _burnAddress (tge/contracts/PublicSale.sol#137)  ## Tools Used Manual  ## Recommended Mitigation Steps Check that the address is zero   
# Handle  0v3rf10w   # Vulnerability details  ## Impact Unchecked low-level calls  ## Proof of Concept Unchecked cases at 2 places :- BasicSale.receive() (2021-11-bootfinance/tge/contracts/PublicSale.sol#148-156) ignores return value by burnAddress.call{value: msg.value}() (2021-11-bootfinance/tge/contracts/PublicSale.sol#154)  BasicSale.burnEtherForMember(address) (2021-11-bootfinance/tge/contracts/PublicSale.sol#158-166) ignores return value by burnAddress.call{value: msg.value}() (2021-11-bootfinance/tge/contracts/PublicSale.sol#164)   ## Tools Used Manual  ## Recommended Mitigation Steps The return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low level is used to prevent blocking operations, consider logging failed calls.  
# Handle  jonah1005   # Vulnerability details  ## Impact The sanity checks in `rampTargetPrice` are broken [SwapUtils.sol#L1571-L1581](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1571-L1581) ```solidity         if (futureTargetPricePrecise < initialTargetPricePrecise) {             require(                 futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,                 "futureTargetPrice_ is too small"             );         } else {             require(                 futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),                 "futureTargetPrice_ is too large"             );         } ``` If `futureTargetPricePrecise` is smaller than `initialTargetPricePrecise` 0.01 of `futureTargetPricePrecise` would never larger than `initialTargetPricePrecise`.  Admin would not be able to ramp the target price. As it's one of the most important features of the customswap, I consider this is a high-risk issue  ## Proof of Concept Here's a web3.py script to demo that it's not possible to change the target price even by 1 wei. ```python     p1, p2, _, _ =swap.functions.targetPriceStorage().call()     future = w3.eth.getBlock(w3.eth.block_number)['timestamp'] + 200 * 24 * 3600      # futureTargetPrice_ is too small     swap.functions.rampTargetPrice(p1 -1, future).transact()     # futureTargetPrice_ is too large     swap.functions.rampTargetPrice(p1 + 1, future).transact() ``` ## Tools Used None ## Recommended Mitigation Steps  Would it be something like: ```solidity         if (futureTargetPricePrecise < initialTargetPricePrecise) {             require(                 futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE + WEI_UNIT).div(WEI_UNIT) >= initialTargetPricePrecise,                 "futureTargetPrice_ is too small"             );         } else {             require(                 futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE + WEI_UNIT).div(WEI_UNIT),                 "futureTargetPrice_ is too large"             );         } ``` I believe the dev would spot this mistake if there's a more relaxed timeline.  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact  I'm not sure why some of this code is commented out.   It could point to items that are not done or need redesigning, be a mistake, or just be testing overhead.   ## Proof of Concept The commented out code is here:  Unclear: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L27 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L76  Obviously Test related: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L187  Guarded launch: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L42-L49 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L201-L204 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L235-L237  ## Tools Used VS Code  ## Recommended Mitigation Steps Review and remove or resolve/document the commented out lines if needed.  
# Handle  pants   # Vulnerability details  ## Impact In BTCPoolDelegator contract, address state variables `future_owner` in lines 51 and bool state variable `is_killed` in line 55 should be placed one after another. solidity keep storage in 32 bytes slot and can optimize multiple variables that are less than 32 bytes. address is 20 bytes and bool is 1 byte, so it can be placed in one storage slot instead of two.  ## Proof of Concept Tested it on Remix, saves 50 gas per transaction  ## Recommended Mitigation Steps change ``` 50    uint256 public future_admin_fee; 51    address public future_owner; 52 53    uint256 kill_deadline; 54    uint256 constant kill_deadline_dt = 2 * 30 * 86400; 54    bool is_killed; ``` to ``` 50    uint256 public future_admin_fee; 51    uint256 constant kill_deadline_dt = 2 * 30 * 86400; 52 53    uint256 kill_deadline; 54    address public future_owner; 54    bool is_killed; ```  
# Handle  Reigada   # Vulnerability details  ## Impact The contract BasicSale contains a fallback function and a burnEtherForMember() function with exactly the same implementation. These 2 functions do the following call: _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);  The _recordBurn function contains the following if block: if (mapEraDay_MemberUnits[_era][_day][_member] == 0) {                              // If hasn't contributed to this Day yet     mapMemberEra_Days[_member][_era].push(_day);                                    // Add it     mapEraDay_MemberCount[_era][_day] += 1;                                         // Count member     mapEraDay_Members[_era][_day].push(_member);                                    // Add member }  What does this mean? If a user performs multiple calls to the contract sending 0 ether as msg.value, the if block will be entered and a new key will be pushed to the mapping. Luckily the cost of an addition to or a read from a mapping does not change with the number of keys mapped. But this would totally mess the function getDaysContributedForEra output. Currently this function is only used as a view function, and not used by the smart contract itself. But it's a risk for future implementations that may make use of it.  ## Proof of Concept >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0xd65ffecd5052314bc09f616461ff6aa9efeb857151c0339dc15653fb90ebb91f   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 0   Transaction confirmed   Block: 13577879   Gas used: 117368 (1.75%)  <Transaction '0xd65ffecd5052314bc09f616461ff6aa9efeb857151c0339dc15653fb90ebb91f'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 1  >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0x0a48f89c1266af2c3eea5cdcec93dae76e4ed2a0936e53e8713d669989b88b19   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 1   Transaction confirmed   Block: 13577880   Gas used: 91568 (1.36%)  <Transaction '0x0a48f89c1266af2c3eea5cdcec93dae76e4ed2a0936e53e8713d669989b88b19'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 2  >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0xeb85e31664eb1578f54daba1be112f9533948d0e2414510874ed55fbb3a9a9e0   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 2   Transaction confirmed   Block: 13577881   Gas used: 91568 (1.36%)  <Transaction '0xeb85e31664eb1578f54daba1be112f9533948d0e2414510874ed55fbb3a9a9e0'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 3  ## Tools Used Manual testing  ## Recommended Mitigation Steps Add the following require statement to the fallback and the burnEtherForMember() functions: require(msg.value > 0, "Some ether should be sent")  
# Handle  Reigada   # Vulnerability details  ## Impact As we can see in the contracts AirdropDistribution and InvestorDistribution, they both have the following approve() call: mainToken.approve(address(vestLock), 2**256-1); https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L499 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L80  This is necessary because both contracts transfer tokens to the vesting contract by calling its vest() function: https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L544 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L569 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L134 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L158  The code of the vest() function in the Vesting contract performs a transfer from msg.sender to Vesting contract address -> vestingToken.transferFrom(msg.sender, address(this), _amount); https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L95  Same is done in the BasicSale contract: https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSale.sol#L225  The problem is that this contract is missing the approve() call. For that reason, the contract is totally useless as the function _withdrawShare() will always revert with the following message: revert reason: ERC20: transfer amount exceeds allowance. This means that all the mainToken sent to the contract would be stuck there forever. No way to retrieve them.  How this issue was not detected in the testing phase? Very simple. The mock used by the team has an empty vest() function that performs no transfer call. https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/helper/MockVesting.sol#L10  ## Proof of Concept See below Brownie's custom output: Calling -> publicsale.withdrawShare(1, 1, {'from': user2}) Transaction sent: 0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 5   BasicSale.withdrawShare confirmed (ERC20: transfer amount exceeds allowance)   Block: 13577532   Gas used: 323334 (4.81%)  Call trace for '0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde': Initial call cost  [21344 gas] BasicSale.withdrawShare  0:3724  [16114 / -193010 gas] ├── BasicSale._withdrawShare  111:1109  [8643 / 63957 gas] │   ├── BasicSale._updateEmission  116:405  [53294 / 55739 gas] │   │   └── BasicSale.getDayEmission  233:248  [2445 gas] │   ├── BasicSale._processWithdrawal  437:993  [-7726 / -616 gas] │   │   ├── BasicSale.getEmissionShare  484:859  [4956 / 6919 gas] │   │   │   │ │   │   │   └── MockERC20.balanceOf  [STATICCALL]  616:738  [1963 gas] │   │   │           ├── address: mockerc20.address │   │   │           ├── input arguments: │   │   │           │   └── account: publicsale.address │   │   │           └── return value: 100000000000000000000 │   │   │ │   │   └── SafeMath.sub  924:984  [191 gas] │   └── SafeMath.sub  1040:1100  [191 gas] │ ├── MockERC20.transfer  [CALL]  1269:1554  [1115 / 30109 gas] │   │   ├── address: mockerc20.address │   │   ├── value: 0 │   │   ├── input arguments: │   │   │   ├── recipient: user2.address │   │   │   └── amount: 27272727272727272727 │   │   └── return value: True │   │ │   └── ERC20.transfer  1366:1534  [50 / 28994 gas] │       └── ERC20._transfer  1374:1526  [28944 gas] └── Vesting.vest  [CALL]  1705:3712  [-330491 / -303190 gas]     │   ├── address: vesting.address     │   ├── value: 0     │   ├── input arguments:     │   │   ├── _beneficiary: user2.address     │   │   ├── _amount: 63636363636363636363     │   │   └── _isRevocable: 0     │   └── revert reason: ERC20: transfer amount exceeds allowance <-------------     │     ├── SafeMath.add  1855:1883  [94 gas]     ├── SafeMath.add  3182:3210  [94 gas]     ├── SafeMath.add  3236:3264  [94 gas]     │     └── MockERC20.transferFrom  [CALL]  3341:3700  [99923 / 27019 gas]         │   ├── address: mockerc20.address         │   ├── value: 0         │   ├── input arguments:         │   │   ├── sender: publicsale.address         │   │   ├── recipient: vesting.address         │   │   └── amount: 63636363636363636363         │   └── revert reason: ERC20: transfer amount exceeds allowance         │         └── ERC20.transferFrom  3465:3700  [-97648 / -72904 gas]             └── ERC20._transfer  3473:3625  [24744 gas]  ## Tools Used Manual testing  ## Recommended Mitigation Steps The following approve() call should be added in the constructor of the BasicSale contract: mainToken.approve(address(vestLock), 2**256-1);  
# Handle  0x0x0x   # Vulnerability details  ## Impact Gas optimization  ## Proof of Concept  On Swap.sol at L190 and L191, it is checked that whether _a and _a2 is bigger equal to 0. Since they are both uint256, this condition is always satisfied. Therefore, those conditions are not required.  ## Tools Used  Manual analysis  
# Handle  gpersoon   # Vulnerability details  ## Impact Anyone can call the function vest() of Vesting.sol, for example with a smail "_amount" of tokens, for any _beneficiary.  The function overwrites the value of benRevocable[_beneficiary], effectively erasing any previous value.  So you can set any _beneficiary to Revocable. Although revoke() is only callable by the owner, this is circumventing the entire mechanism of benRevocable.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L73-L98  function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable whenNotPaused {         ...         if(_isRevocable == 0){             benRevocable[_beneficiary] = [false,false];  // just overwrites the value         }         else if(_isRevocable == 1){             benRevocable[_beneficiary] = [true,false]; // just overwrites the value         }        ## Tools Used  ## Recommended Mitigation Steps Whitelist the calling of vest() Or check if values for benRevocable are already set.   
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you are an investor and want to claim the last part of your claimable tokens (or your entire set of claimable tokens if you haven't claimed anything yet). Then you call the function claim() of InvestorDistribution.sol, which has the following statement: "require(investors[msg.sender].amount - claimable != 0);" This statement will prevent you from claiming your tokens because it will stop execution.  Note: with the function claimExact() it is possible to claim the last part.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/InvestorDistribution.sol#L113-L128  function claim() external nonReentrant { ...         require(investors[msg.sender].amount - claimable != 0);         investors[msg.sender].amount -= claimable;  ## Tools Used  ## Recommended Mitigation Steps Remove the require statement.   
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you are eligible for the last part of your airdrop (or your entire airdrop if you haven't claimed anything yet). Then you call the function claim() of AirdropDistribution.sol, which has the following statement: "assert(airdrop[msg.sender].amount - claimable != 0);" This statement will prevent you from claiming your airdrop because it will stop execution.  Note: with the function claimExact() it is possible to claim the last part.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L522-L536  function claim() external nonReentrant {        ..         assert(airdrop[msg.sender].amount - claimable != 0);         airdrop[msg.sender].amount -= claimable;  ## Tools Used  ## Recommended Mitigation Steps Remove the assert statement. Also add the following to validate() , to prevent claiming the airdrop again:       require(validated[msg.sender]== 0, "Already validated.");  
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose someone claims the last part of his airdrop via claimExact() of AirdropDistribution.sol Then airdrop[msg.sender].amount will be set to 0.  Suppose you then call validate() again.  The check "airdrop[msg.sender].amount == 0" will allow you to continue, because amount has just be set to 0. In the next part of the function, airdrop[msg.sender] is overwritten with fresh values and airdrop[msg.sender].claimed will be reset to 0.  Now you can claim your airdrop again (as long as there are tokens present in the contract)  Note: The function claim() prevents this from happening via "assert(airdrop[msg.sender].amount - claimable != 0);", which has its own problems, see other reported issues.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L555-L563  function claimExact(uint256 _value) external nonReentrant {         require(msg.sender != address(0));         require(airdrop[msg.sender].amount != 0);                  uint256 avail = _available_supply();         uint256 claimable = avail * airdrop[msg.sender].fraction / 10**18; //         if (airdrop[msg.sender].claimed != 0){             claimable -= airdrop[msg.sender].claimed;         }          require(airdrop[msg.sender].amount >= claimable); // amount can be equal to claimable         require(_value <= claimable);                       // _value can be equal to claimable         airdrop[msg.sender].amount -= _value;      // amount will be set to 0 with the last claim   // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L504-L517 function validate() external nonReentrant {         ...         require(airdrop[msg.sender].amount == 0, "Already validated.");         ...              Airdrop memory newAirdrop = Airdrop(airdroppable, 0, airdroppable, 10**18 * airdroppable / airdrop_supply);              airdrop[msg.sender] = newAirdrop;              validated[msg.sender] = 1;   // this is set, but isn't checked on entry of this function  ## Tools Used  ## Recommended Mitigation Steps Add the following to validate() :         require(validated[msg.sender]== 0, "Already validated.");  
# Handle  JMukesh   # Vulnerability details  ## Impact Event should be emitted after sensitive action like setting fees, admin_fees otherwise it will be difficult track offchain fees changes  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L57  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L58  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L53  ## Tools Used  manual review ## Recommended Mitigation Steps  event should be emitted after the sensitive action  
# Handle  JMukesh   # Vulnerability details  ## Impact due to lack of checking admin_fee, it can be greater than max_admin_fee  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L57  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L58  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L53  ## Tools Used  manual review  ## Recommended Mitigation Steps  add input validation for admin_fee  
# Handle  nathaniel   # Vulnerability details  ## Impact Inconsistency between the `claim()` function and `claimExact()` function, in that `claimExact` does not check the claimable amount. In the scenario where claimable = 0, and `investors[msg.sender].claimed != 0` then it will attempt to underflow. If `_amount` is 0, then it could potentially reach the `vestLock.vest()` function, where it will then revert with the inaccurate message "amount must be positive" which doesn't reflect the underlying issue.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L145 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L121 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L75  ## Tools Used manual review   ## Recommended Mitigation Steps Add `require(claimable > 0)`  
# Handle  nathaniel   # Vulnerability details  ## Impact `amount` in the `Investors` struct is vague. It would be assumed to be the invested amount, however this amount decreases when the beneficiary claims. A more appropriate name could be `unclaimed_amount`. `claimable_to_send` is not appropriate name in the `claimExact()` function, as it is not the claimable total, instead `exact_claim_to_send` would make more sense. ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L24 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L155   
# Handle  nathaniel   # Vulnerability details  ## Impact Functions include `updateEmission(), dev_rugpull(), setAdmin(), revoke() ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L185 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L203 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L212 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L104  
# Handle  nathaniel   # Vulnerability details  ## Impact The timelocks for any *beneficiary* are unbounded, and can be vested by someone who is not the *beneficiary*. When the array becomes significantly big enough, the vestments will no longer be claimable for the *beneficiary*.  The `vest()` function in Vesting.sol does not check the *beneficiary*, hence anyone can vest for anyone else, pushing a new timelock to the `timelocks[_beneficiary]`. The `_claimableAmount()` function (used by `claim()` function), then loops through the `timelocks[_beneficiary]` to determine the amount to be claimed. A malicious actor can easy repeatedly call the `vest()` function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable.  The malicious actor could do this to each *beneficiary*, locking up all the vestments.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L81 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L195 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L148  ## Tools Used Manual code review  ## Recommended Mitigation Steps - Create a minimum on the vestment amounts, such that it won't be feasible for a malicious actor to create a large amount of vestments. - Restrict the vestment contribution of a *beneficiary* where `require(beneficiary == msg.sender)`  
# Handle  ye0lde   # Vulnerability details  ## Impact  Code clarity  ## Proof of Concept  The function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L291-L298  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to simplify:    <code>     function getDayEmission() public view returns (uint) {            return (remainingSupply > emission ? emission : remainingSupply);     } </code>  
# Handle  ye0lde   # Vulnerability details  ## Impact  Cache Reference To State Variables "currentDay, currentEra, emission" in _updateEmission (PublicSale.sol)  Caching the references to "currentDay, currentEra, emission" will decrease gas usage.   ## Proof of Concept  The variables "currentDay, currentEra, emission" are referenced 20 times in function "_updateEmission" here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L247-L276  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to cache those variables:    <code>  function _updateEmission() private {         uint _now = block.timestamp;                                                                                      // Find now()         if (_now >= nextDayTime) {                                                                                         // If time passed the next Day time                  uint256 _currentDay = currentDay;             uint256 _currentEra = currentEra;             uint256 _emission = emission;              if (remainingSupply > _emission) {                 remainingSupply -= _emission;                                                              }             else {                 remainingSupply = 0;                                                                     }             if (_currentDay >= daysPerEra) {                                                                                 // If time passed the next Era time                 _currentEra += 1; _currentDay = 0;                                                                        // Increment Era, reset Day                 nextEraTime = _now + (secondsPerDay * daysPerEra);                                          // Set next Era time                 _emission = getNextEraEmission();                                                                        // Get correct emission                 mapEra_Emission[currentEra] = _emission;                                                           // Map emission to Era                 emit NewEra(_currentEra, _emission, nextEraTime, totalBurnt);                            // Emit Event             }             _currentDay += 1;                                                                                                     // Increment Day             nextDayTime = _now + secondsPerDay;                                                                  // Set next Day time             _emission = getDayEmission();                                                                                // Check daily Dmission             mapEraDay_EmissionRemaining[_currentEra][_currentDay] = _emission;               // Map emission to Day             uint _era = _currentEra;             uint _day = _currentDay - 1;             if (_currentDay == 1) {                 // new era                 _era = _currentEra - 1;                 _day = daysPerEra;             }              currentDay = _currentDay;             currentEra = _currentEra;             emission = _emission;                 emit NewDay(_currentEra, _currentDay, nextDayTime, mapEraDay_Units[_era][_day], mapEraDay_MemberCount[_era][_day]);         }     } </code>   
# Handle  Reigada   # Vulnerability details  ## Impact In the Vesting contract, the function revoke() sends the vested tokens to the beneficiary and the remaining tokens that are not vested yet are sent to the multisig address. It makes no sense to allow calling this function once the address has already vested the 100% of the tokens (after 1 year in this case -> uint256 _unlockTimestamp = block.timestamp.add(unixYear);).  Basically in this case the function revoke() would behave like a claim() function but doing some extra checks which waste gas (gas paid by the owner of the contract instead of the beneficiary address) and also emitting an extra event -> https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L123  For that reason, it is recommended to add a require statement that handles this case:  uint256 index = timelocks[_addr].length - 1; require (block.timestamp < timelocks[_addr][index].releaseTimestamp, 'Account fully vested');  ## Tools Used Manual testing  ## Recommended Mitigation Steps It is recommended to add a require statement that handles this case in the Vesting.revoke() function:  uint256 index = timelocks[_addr].length - 1; require (block.timestamp < timelocks[_addr][index].releaseTimestamp, 'Account fully vested');  
# Handle  Reigada   # Vulnerability details  ## Impact There is an unnecessary require statement in vesting.claim() -> https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L197  This check is already done in https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L186  ## Tools Used Manual testing  ## Recommended Mitigation Steps Remove the require statement in the claim() function as it is totally unnecessary. The check is already performed in the function _claimableAmount(address _addr).  
# Handle  Reigada   # Vulnerability details  ## Impact In the contract Vesting, function vest(), the parameter _isRevocable is declared as an uint256 when it is used as a boolean.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L77  ## Tools Used Manual review  ## Recommended Mitigation Steps Declare the parameter _isRevocable as a bool.  
# Handle  Ruhum   # Vulnerability details  ## Impact With version 4.x of the ERC20 token, the `approve()` function returns a boolean indicating whether it was successful or not.  https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#IERC20-approve-address-uint256-  Best practice is to either check the return value or use `safeApprove()` / `safeIncreaseAllowance()` which will revert if the operation was unsuccessful  https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#SafeERC20-safeApprove-contract-IERC20-address-uint256-  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L499  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L80  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps use `safeApprove()` or `safeIncreaseAllowance()`  
# Handle  Reigada   # Vulnerability details  ## Impact In both airdrop contracts: AirdropDistribution and InvestorDistribution, once all the participants have claimed their tokens, some will remain in the contract due to some imprecision in the calculations. There is no function that allows to substract them which means that those tokens will remain stuck in the contracts forever.  I have made the test with just 5 participants: user2, user3, user4, user5 & user6.  uint256[5] airdropBalances =     [     4032000,     4032000,     4032000,     4032000,     4032000     ];  >>> 4032000 * 5 20160000  Initially 20160000 tokens were transferred to the contract  mockToken.transfer(airdropdist.address, 20160000000000000000000000)  After 260 weeks, these were the results:  ----------------> mockToken.balanceOf(airdropdist.address) -> 2842805668532461833600 <-----------------  mockToken.balanceOf(user2) -> 1209429431659888052289865 vesting.benTotal(user2.address) -> 2822002007206405455343415 mockToken.balanceOf(user3) -> 1209429431659888052289984 vesting.benTotal(user3.address) -> 2822002007206405455343296 mockToken.balanceOf(user4) -> 1209429431659888052289984 vesting.benTotal(user4.address) -> 2822002007206405455343296 mockToken.balanceOf(user5) -> 1209429431659888052289984 vesting.benTotal(user5.address) -> 2822002007206405455343296 mockToken.balanceOf(user6) -> 1209429431659888052289984 vesting.benTotal(user6.address) -> 2822002007206405455343296  As we can see above 2842 tokens remain in the contract and there is no way to retrieve them.  ## Tools Used Manual testing / brownie  ## Recommended Mitigation Steps Add an onlyOwner function that allows to retrieve all the remaining tokens once all the participants of the airdrop have claimed the whole amount of their rewards.  
# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details On the `AirdropDistribution.sol`, the `airdrop_supply` ([line 462](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L462)) value is set to be `20160000`. However, adding all the `airdropBalances` does show that the value should be `20159997` instead.   ## Impact This does cause some operations on the contract to mislead in the results. This is more noticed on bigger airdropped accounts.  ## Proof of Concept Adding all the `airdropBalances` values do show the difference.  ## Tools Used Manual code review  ## Recommended Mitigation Steps The `airdrop_supply` should be reflecting the actual airdropped balance without misleading the total amount. Change the value to `20159997`.  
# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details On the `claim` function ([line 524](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L524))  of the `AirdropDistribution.sol` contract, the `validated` check is redundant. The flag is only set when the `validate` function is called. Once validated, the amount will always be different than zero, meaning that the check is not necessary.  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps The check could be removed for gas optimization.  
# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details The `_available_supply` and `available_supply` functions on the `AirdropDistribution` (lines [601](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L601) and [607](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L607)) do contain the exact same code.  Furthermore, the `assert` check inside those functions should be changed to a require statement since the check is not an invariant and gas refund should take place if the check fails ([SWC-110](https://swcregistry.io/docs/SWC-110)).  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps The `available_supply` and `_available_supply` functions should be combined into a single public function (public functions can be used internally without any extra gas) or have the public function call the internal implementation and use the private implementation in the contract.  The `assert` check in the `available_supply` function should be changed to a require statement since the check is not an invariant.  
# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details The `InvestorDistribution` ([InvestorDistribution.sol](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol)) contract does contain some statements that could be removed to optimize the gas usage.  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps - Variable set on [Line 77](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L77) can be removed since the implicit value is already zero - On lines 106 and 107 ([here](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L106-L107)), the statement could be changed to a single line containing `delete investors[_investor]`.  
# Handle  PranavG   # Vulnerability details  ## Impact State variables that never change can be declared constant. This can greatly reduce gas costs. Examples : airdrop_supply in AirdropDistribution.sol(#462) investors_supply in InvestorDistribution.sol(#33)  unixYear in Vesting.sol(#30)  ## Recommended Mitigation Steps Add the constant keyword for state variables whose value never change.  
# Handle  PranavG   # Vulnerability details  ## Impact MathUtils.sol has unused import at line #5: import "@openzeppelin/contracts/math/SafeMath.sol"; The import is not used in any way.   ## Recommended Mitigation Steps Remove it to improve readability of the code.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Tokens are locked for 1 day less than specified in spec.  ## Proof of Concept  The vesting period is calculated here in `unixYear`  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L30  This results in a lockup of 364 days rather than the expected 365.  ## Recommended Mitigation Steps  Replace line with `uint256 constant private unixYear = 365 days;`   
# Handle  pants   # Vulnerability details  The function `GaugeController.commit_transfer_ownership()` emits `CommitOwnership` events when the future admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `CommitOwnership` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new future admin is different than the old one.  
# Handle  pants   # Vulnerability details  The function `GaugeController.apply_transfer_ownership()` emits `ApplyOwnership` events when the admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `ApplyOwnership` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new admin is different than the old one.  
# Handle  pants   # Vulnerability details  The function `GaugeController.__init__()` (the constructor) sets the initial admin, but it doesn't emit an appropriate `ApplyOwnership` event.  ## Impact The users won't know who's the initial admin by searching for the first `ApplyOwnership` event, although they should be able to.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit this event.  
# Handle  pants   # Vulnerability details  The function `MainToken.__init__()` (the constructor) sets the initial admin, but it doesn't emit an appropriate `SetAdmin` event.  ## Impact The users won't know who's the initial admin by searching for the first `SetAdmin` event, although they should be able to.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit this event.  
# Handle  pants   # Vulnerability details  The function `LPToken.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  
# Handle  pants   # Vulnerability details  The function `LPToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  
# Handle  pants   # Vulnerability details  The functions `LPToken.transfer()` and `LPToken.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  
# Handle  pants   # Vulnerability details  The function `LPToken.set_minter()` doesn't check that `_minter` doesn't equal zero before it sets it as the new minter.  ## Impact This function can be invoked by mistake with the zero address as `_minter`, causing the system to lose its minter forever, without the option to set a new minter.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Check that `_minter` doesn't equal zero before setting it as the new minter.  
# Handle  pants   # Vulnerability details  The function `LPToken.__init__()` (the constructor) emits `Transfer` events when the amount minted for `msg.sender` is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the amount minted for `msg.sender` is not zero.  
# Handle  pants   # Vulnerability details  The function `MainToken.__init__()` (the constructor) emits `Transfer` events when the amount minted for `msg.sender` is zero. This is always the case, as the value of the constant `INITIAL_SUPPLY` is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the amount minted for `msg.sender` is not zero.  
# Handle  pants   # Vulnerability details  The function `MainToken.set_mint_multisig()` doesn't check that `_minting_multisig` doesn't equal zero before it sets it as the new `minting_multisig`.  ## Impact This function can be invoked by mistake with the zero address as `_minting_multisig`, causing the system to lose its `minting_multisig` forever, without the option to set a new `minting_multisig`.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Check that `_minting_multisig` doesn't equal zero before setting it as the new `minting_multisig`.  
# Handle  pants   # Vulnerability details  The function `MainToken.set_mint_multisig()` emits `SetMintMultisig` events when `minting_multisig` hasn't changed, and left as it was before that transaction.  ## Impact There is no reason to emit these `SetMintMultisig` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new `minting_multisig` is different than the old one.  
# Handle  pants   # Vulnerability details  The function `MainToken.set_admin()` emits `SetAdmin` events when the admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `SetAdmin` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new admin is different than the old one.  
# Handle  pants   # Vulnerability details  The function `MainToken.set_minter()` emits `SetMinter` events when the minter hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `SetMinter` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new minter is different than the old one.  
# Handle  pants   # Vulnerability details  The function `MainToken.burn()` emits `Transfer` events when the burned amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the burned amount is not zero.  
# Handle  pants   # Vulnerability details  The functions `MainToken.mint()` and `MainToken.mint_dev()` emit `Transfer` events when the minted amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the minted amount is not zero.  
# Handle  pants   # Vulnerability details  The function `MainToken.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  
# Handle  pants   # Vulnerability details  The function `MainToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  
# Handle  pants   # Vulnerability details  The functions `MainToken.transfer()` and `MainToken.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  
# Handle  pants   # Vulnerability details  The function `PoolGauge.withdraw()` emits `Withdraw` events when the withdrawn amount is zero.  ## Impact There is no reason to emit these `Withdraw` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the withdrawn amount is not zero.  
# Handle  pants   # Vulnerability details  The function `PoolGauge.deposit()` emits `Deposit` events when the deposited amount is zero.  ## Impact There is no reason to emit these `Deposit` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the deposited amount is not zero.  
# Handle  pants   # Vulnerability details  The function `PoolGauge.withdraw()` doesn't have to execute these lines of code when `_value` equals zero: ``` _balance: uint256 = self.balanceOf[msg.sender] - _value _supply: uint256 = self.totalSupply - _value self.balanceOf[msg.sender] = _balance self.totalSupply = _supply  self._update_liquidity_limit(msg.sender, _balance, _supply)  assert ERC20(self.lp_token).transfer(msg.sender, _value) ```  ## Impact There is no reason to execute these lines of code if `_value` equals zero because they won't affect the system. An identical optimization is already implemented in `PoolGauge.deposit()`.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Execute these lines of code only if `_value` doesn't equal zero.  
# Handle  pants   # Vulnerability details  The function `Token.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  
# Handle  pants   # Vulnerability details  The function `Token.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  
# Handle  pants   # Vulnerability details  The functions `Token.transfer()` and `Token.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  
# Handle  pants   # Vulnerability details  The functions `USDPoolDelegator.balances()`, `USDPoolDelegator.coins()` and `USDPoolDelegator.underlying_coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` / `_underlying_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceeds the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` / `_underlying_coins` array bounds.  
# Handle  pants   # Vulnerability details  The functions `ETHPoolDelegator.balances()` and `ETHPoolDelegator.coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceeds the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` array bounds.  
# Handle  pants   # Vulnerability details  The functions `BTCPoolDelegator.balances()` and `BTCPoolDelegator.coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` array bounds.  
# Handle  defsec   # Vulnerability details  ## Impact  The current ownership transfer process involves the current owner calling Swap.transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier.  ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L30" 2. The contract has many onlyOwner function. 3. The contract is inherited from the Ownable which includes transferOwnership.  ## Tools Used  None  ## Recommended Mitigation Steps  Implement zero address check and Consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.  
# Handle  Reigada   # Vulnerability details  ## Impact The if statement in _updateEmission() can be removed as the condition is already checked in updateEmission() https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L596 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L186  ## Proof of Concept     function _updateEmission() private {         if (block.timestamp >= startEpochTime + RATE_TIME) {             miningEpoch += 1;             startEpochTime = startEpochTime.add(RATE_TIME);             startEpochSupply = startEpochSupply.add(rate.mul(RATE_TIME));              if (miningEpoch < INITIAL_RATE_EPOCH_CUTTOF) {                 rate = rate.mul(EPOCH_INFLATION).div(100000);             }             else {                 rate = 0;             }             emit updateMiningParameters(block.timestamp, rate, startEpochSupply);         }     }      //Update emission to be called at every step change to update emission inflation     function updateEmission() public {         require(block.timestamp >= startEpochTime + RATE_TIME, "Too soon"); // Condition already checked here         _updateEmission();     }  ## Tools Used Manual testing  ## Recommended Mitigation Steps Remove the if condition in the _updateEmission() private function  
# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been seen maxVesting amount is disabled. However, there is no maximum and minimum vesting amount defined. Users can vest small amount. For the protocol liquditiy calculation maximum and minimum threshold should be defined.   ## Proof of Concept  1. Navigate to the following contract.  """ https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L76 """  2. Vesting amount didnt check.  ## Tools Used  Review  ## Recommended Mitigation Steps  It is suggested to check maximum/minimum vesting amount on the contract.   
# Handle  Reigada   # Vulnerability details  ## Impact Multiple calls to transferFrom and transfer are frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of “false” is returned. It’s important to check this. If you don’t, in this concrete case, some airdrop eligible participants could be left without their tokens. It is also a best practice to check this.  ## Proof of Concept AirdropDistributionMock.sol:132:        mainToken.transfer(msg.sender, claimable_to_send); AirdropDistributionMock.sol:157:        mainToken.transfer(msg.sender, claimable_to_send); AirdropDistribution.sol:542:        mainToken.transfer(msg.sender, claimable_to_send); AirdropDistribution.sol:567:        mainToken.transfer(msg.sender, claimable_to_send);  InvestorDistribution.sol:132:        mainToken.transfer(msg.sender, claimable_to_send); InvestorDistribution.sol:156:        mainToken.transfer(msg.sender, claimable_to_send); InvestorDistribution.sol:207:        mainToken.transfer(msg.sender, bal);  Vesting.sol:95:        vestingToken.transferFrom(msg.sender, address(this), _amount);  PublicSale.sol:224:            mainToken.transfer(_member, v_value);   ## Tools Used Manual testing  ## Recommended Mitigation Steps Check the result of transferFrom and transfer. Although if this is done, the contracts will not be compatible with non standard ERC20 tokens like USDT. For that reason, I would rather recommend making use of SafeERC20 library: safeTransfer and safeTransferFrom.  
# Handle  defsec   # Vulnerability details  ## Impact  Using newer compiler versions and the optimizer gives gas optimizations and additional safety checks are available for free.  The advantages of versions 0.8.* over <0.8.0 are:  - Safemath by default from 0.8.0 (can be more gas efficient than library based safemath.) - Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls. - Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs. - Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.    ## Proof of Concept  1. The contest repository contracts contain pragma 0.6.12^. The contracts pragma version should be updated to 0.8.4.  (https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol ) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L3) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/MathUtils.sol#L3) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSale.sol#L2) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSaleBatchWithdraw.sol#L2)  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to upgrade pragma to at least 0.8.4.  
# Handle  ye0lde   # Vulnerability details  ## Impact  getEmissionShare Can Be Rewritten To Be More Efficient (PublicSale.sol)  The "else" and returning 0, can be eliminated.  The existing but unused named return variable "value" can be used instead of a return statement. These changes reduce gas and improve code clarity.  ## Proof of Concept  The getEmissionShare function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L231-L245  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>     function getEmissionShare(uint era, uint day, address member) public view returns (uint value) {           uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units                  if (memberUnits != 0) {             uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units             uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];     // Get emission remaining for Day             uint balance = mainToken.balanceOf(address(this));             if (emissionRemaining > balance) {                 emissionRemaining = balance;                                                // In case less than required emission             }             value = (emissionRemaining * memberUnits) / totalUnits;         // Calculate share         }     }    </code>  
# Handle  ye0lde   # Vulnerability details  ## Impact  _processWithdrawal Can Be Rewritten To Be More Efficient (PublicSale.sol)  The "else", the setting of "value to 0", and the return statement can be eliminated to reduce gas and improve code clarity.  ## Proof of Concept  The _processWithdrawal function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L212-L229  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>     function _processWithdrawal (uint _era, uint _day, address _member) private returns (uint value) {           uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member]; // Get Member Units                  if (memberUnits != 0) {             value = getEmissionShare(_era, _day, _member);          // Get the emission Share for Member             mapEraDay_MemberUnits[_era][_day][_member] = 0;  // Set to 0 since it will be withdrawn             mapEraDay_UnitsRemaining[_era][_day] = mapEraDay_UnitsRemaining[_era][_day].sub(memberUnits);  // Decrement Member Units             mapEraDay_EmissionRemaining[_era][_day] = mapEraDay_EmissionRemaining[_era][_day].sub(value);  // Decrement emission             totalEmitted += value;                                                 // Add to Total Emitted             uint256 v_value = value * 3 / 10;                                 // Transfer 30%, lock the rest in vesting contract                          mainToken.transfer(_member, v_value);                      // ERC20 transfer function             vestLock.vest(_member, value - v_value, 0);             emit Withdrawal(msg.sender, _member, _era, _day, value, mapEraDay_EmissionRemaining[_era][_day]);         }     } </code>  
# Handle  ye0lde   # Vulnerability details  ## Impact  The "else if", the second call to _processWithdrawal, and the return statement can be eliminated to reduce gas and improve code clarity.  ## Proof of Concept  The _withdrawShare function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L201-L210  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>  function _withdrawShare (uint _era, uint _day, address _member) private returns (uint value) {  _updateEmission();    if (_era < currentEra ||                                                          // Allow if in previous Era                                                                          (_era == currentEra && _day < currentDay)) {                // or current Era and previous day    value = _processWithdrawal(_era, _day, _member);   // Process Withdrawal      }   } </code>  
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L187 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L194 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L231  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named returns  
# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L149-L150 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/SwapUtils.sol#L1625 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/SwapUtils.sol#L1679  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L105 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L194-L197  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L152 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L162  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.    
# Handle  ye0lde   # Vulnerability details  ## Impact  The "else if(_isRevocable == 1)" is not needed and can be removed to save gas and improve code clarity.  ## Proof of Concept  The "_isRevocable" variable is guaranteed to be 0 or 1 here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L77  But it is treated like it can have some other value here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L83-L88  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Rewrite these lines https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L83-L88 to <code>  benRevocable[_beneficiary] = (_isRevocable == 0) ? [false,false] : [true,false]; </code>  
# Handle  pants   # Vulnerability details  Since no contract inherent from SwapUtils all internal functions could be set private. For example  getD could be set private to save gas.  
# Handle  pants   # Vulnerability details  optimizing for loops by caching memory array length, instead of calling it every time.  For example at Swap.sol at time 158 you should have  uint8 len = _pooledTokens.length and in the next line define the forloop with stop condition of  i<len  This appears in many places in the code. At some places you did cached the array length correctly.   
# Handle  pants   # Vulnerability details  When double reading a variable from memory the gas efficient way is to cache it and use the cached value.   For example in line 537, 538 of SwapUtils.sol you have two accesses to xp[i]. You can save xp[i] as local variable and then use it instead at the second time.  
# Handle  pants   # Vulnerability details  An admin can (by mistake maybe) addInvestor with address that already exists. This way its funds are locked in the system and cannot be withdrawn, even by the admin.    
# Handle  pants   # Vulnerability details  In InvestorDistribution line 103 you read investors[_investor] multiple times (only at this function investors[_investor] is read 6 times). You could cache the value and call the cached value instead. Investors x = investors[_investor]; And then use x.amount, x.claimed, etc.  
# Handle  pants   # Vulnerability details  In InvestorDistribution you generally use uint256 for every quantity, although 256 bits are much more than necessary. For example for Investor structure you can change all to uint128, and for every normal use it will not affect and save gas.  
# Handle  pants   # Vulnerability details  In InvestorDistribution at line 19 you have      using SafeMath for uint256;  although you use solidity >0.8.0 therefore you don't need to use safeMath for uint256  
# Handle  tqts   # Vulnerability details  ## Impact Several references to storage can be cached to save significant amounts of gas.  ## Proof of Concept File lines are stated in Mitigation Steps.  ## Tools Used Manual review   ## Recommended Mitigation Steps  #### In function calculateWithdrawOneTokenDY (L406) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, so one SLOAD is saved.  #### In function _calculateRemoveLiquidity (L953) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, one of those as condition in a for loop, so at least _pooledTokensLength SLOADS are saved.  #### In function _feePerToken (L1080) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, so one SLOAD is saved.  #### In function swap (L1098) ``` IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom]; ``` The value is used 4 times, so 3 SLOADs are saved. However, this causes a stack too deep error in line 1129. To mitigate this, replace lines 1129-1132 for: ``` uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);         dyAdminFee = dyAdminFee.div(self.tokenPrecisionMultipliers[tokenIndexTo]); ```  #### In function addLiquidity (L1163) ``` uint256 _pooledTokensLength = self.pooledTokens.length; uint256 _lpTokenTotalSupply = self.lpToken.totalSupply(); ``` _pooledTokensLength is used 4 times. 3 SLOADs saved. _lpTokenTotalSupply is used 6 times, however the one in line 1266 is called after a mint() so it's not the same value and thus can't be replaced. 4 SLOADs saved.  #### In function _updateUserWithdrawFee (L1290) ``` uint256 _withdrawFee = self.defaultWithdrawFee; ``` The value is used 3 times, so 2 SLOADs are saved.  #### In function removeLiquidityImbalance (L1415) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used 5 times, twice as a for condition, so at least 2 + _pooledTokensLength SLOADs are saved.  
# Handle  jah   # Vulnerability details  ## Impact  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). If you explicitly initialize it with its default value, you are just wasting gas. ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L77 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L77 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L66  https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6  ## Tools Used Manual analysis  ## Recommended Mitigation Steps  
# Handle  tqts   # Vulnerability details  ## Impact According to the comment in line 148 of Swap.sol, the function checks for _pooledTokens and precisions parameters, however, the require at line 151 is redundant, as it will pass if both previous checks passed.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L151  ## Tools Used  ## Recommended Mitigation Steps Remove the require, or change it to validate the correct precision parameters.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs + risk of accidental changes to values expected to be fixed.  ## Proof of Concept  Several contracts contain variables which are set at deploy time and never changed again. For example see `PublicSale.sol`  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L70-L81  Since solidity 0.6.5, variables can be marked `immutable` which avoids the need for SLOADs when reading these variables - decreasing gas costs and protecting against accidentally modifying these variables.  https://blog.soliditylang.org/2020/05/13/immutable-keyword/#:~:text=With%20version%200.6.,time%20of%20a%20deployed%20contract.  ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  Inspect all contracts for variables which are set once and then never modified, apply `immutable` keyword and adjust constructors to not read these values (instead use passed parameters)  
# Handle  leastwood   # Vulnerability details  ## Impact  The `Timelock` struct is used to reference the `releaseTimestamp` and vested `amount` for each vesting. These values can likely be safely stored as `uint64` and `uint192` values respectively, enabling the struct to be stored within a single slot instead of two slots.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L32-L35  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider updating `releaseTimestamp` to `uint64` and `amount` to `uint192` within the `Timelock` struct. It might be worthwhile performing sanity checks when storing these values by using OpenZeppelin's safe math and safe cast libraries.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `claim()` function asserts that the claimable amount is strictly less than `benTotal` for a given user. However, this does not take into account previously claimed tokens, hence the `require` does not accurately depict its intended behaviour.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L197  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider updating this `require` statement to account for already claimed tokens. This could look like the following: `require(amount.add(benClaimed[msg.sender]) <= benTotal[msg.sender], "Cannot withdraw more than total vested amount");`  
# Handle  pauliax   # Vulnerability details  ## Impact  function burnEtherForMember should validate that the address of the member is not empty (0x0) to prevent accidental burns.   When adding an investor distribution (function addInvestor) should validate that the total amount is not above the investors_supply. but then you also need to store the total amount that is already assigned to investors.   function modifyInvestor should validate that _investor != _new, otherwise it will delete the investor unless this is an expected feature.   function claimExact should validate that _value > 0 to prevent useless claims.  
# Handle  pauliax   # Vulnerability details  ## Impact function _recordBurn does not really need this parameter of address _payer as it is always equal to msg.sender.   Consider replacing: function _recordBurn(address _payer, ... emit Burn(_payer, ...  with: function _recordBurn(... emit Burn(msg.sender, ...   
# Handle  pauliax   # Vulnerability details  ## Impact functions validate and modifyInvestor do not need nonReentrant modifier as they do not execute any external calls where you can hook up to re-enter.   
# Handle  pauliax   # Vulnerability details  ## Impact Member total_tokens in both structs Airdrop and Investors is practically not used and is a duplicate of the amount so you can remove it to save some storage. Also, gas efficiency can be improved by tightly packing the struct. Struct variables are stored in 32 bytes each so you can group smaller types to occupy less storage, e.g. airdropBalances which are later translated to the amount in Airdrop struct (10**18) can be stored in a smaller version of uint as we know all the exact values at compile time.   
# Handle  pauliax   # Vulnerability details  ## Impact When revoking the user, there is no need to iterrate over all his timelocks again and calculate the total amount as it should already be stored in a benTotal[_addr] mapping:   uint256 locked = 0;   for (uint256 i = 0; i < timelocks[_addr].length; i++) {       locked = locked.add(timelocks[_addr][i].amount);   }   
# Handle  pauliax   # Vulnerability details  ## Impact function claim can save gas and eliminate duplicate storage access and math operations by caching claimableAmount and re-using it later when setting the benClaimed.   before:   uint256 amount = _claimableAmount(msg.sender).sub(benClaimed[msg.sender]);   ...   benClaimed[msg.sender] = benClaimed[msg.sender].add(amount);  after:   uint256 claimableAmount = _claimableAmount(msg.sender);   uint256 amount = claimableAmount.sub(benClaimed[msg.sender]);   ...   benClaimed[msg.sender] = claimableAmount;  Also, it looks strange that in function revoke the amount is checked with 'assert': assert(amount <= benTotal[_addr]); but in function claim 'require' is used: require(amount <= benTotal[msg.sender], "Cannot withdraw more than total vested amount");  In both places probably 'assert' should be used as it is checking a scenario that should never happen under normal circumstances.   
# Handle  pauliax   # Vulnerability details  ## Impact This check in function modifyInvestor is not neccessary:   require(_investor != address(0), "Invalid old address");  as empty address cannot be added in function addInvestor and later this check will fail:   require(investors[_investor].amount != 0);  
# Handle  pauliax   # Vulnerability details  ## Impact Contracts use assert() instead of require() in multiple places. Assert is recommended to be used to check for internal errors, or to check invariants.  In your case, I think these validations could better use 'require' as they are likely to be triggered: assert(claimable > 0); assert(airdrop[msg.sender].amount - claimable != 0); assert(block.timestamp - startEpochTime <= RATE_TIME); assert(block.timestamp - initTime >= YEAR * 5);  A similar issue was submitted in a previous contest and was assigned a severity of low: https://github.com/code-423n4/2021-06-realitycards-findings/issues/83  ## Recommended Mitigation Steps Consider replacing 'assert' with 'require' in the cases mentioned above.  
# Handle  pauliax   # Vulnerability details  ## Impact burnAddress is hardcoded to 0x03Df4ADDfB568b338f6a0266f30458045bbEFbF2. I see this address is a Gnosis safe multisig. So the eth is not actually burned even though I expected the burn by looking at the code. This confusion happens because the codebase was adopted from Vader protocol but with no actual intention of burning.  ## Recommended Mitigation Steps To reduce this confusion and improve the readability of the codebase you should either rename the burn variables and functions or leave it as it is but comment and document the actual mechanics of the sale.   
# Handle  pauliax   # Vulnerability details  ## Impact function _recordBurn should validate that _eth > 0. Now it is possible to spam this function with 0 eth burns and fictitiously increase member statistics.  I have previously reported this issue in a Vader's contest. You can read find details here: https://github.com/code-423n4/2021-04-vader-findings/issues/269  ## Recommended Mitigation Steps Handle case when _eth = 0 in function _recordBurn.  
# Handle  pauliax   # Vulnerability details  ## Impact There is no reason for the function vest to be 'payable' as it does not handle ether in any way and there is no way to rescue it later in case someone accidentally sends it.  ## Recommended Mitigation Steps Remove 'payable' from the vest function.  
# Handle  defsec   # Vulnerability details  ## Impact  Using the unchecked keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen. E.g. 'unchecked' can be applied in the following lines of code since there are require statements before to ensure the arithmetic operations would not cause an integer underflow or overflow.  ## Proof of Concept  1. Review the all contracts and add unchecked keyword where overflow is not possible.  "https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L579"  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider applying 'unchecked' keyword where overflows/underflows are not possible.    
# Handle  JMukesh   # Vulnerability details  ## Impact bool _iskilled  state variable can be packed with one of the address state variable like {token , owner}  which will save on slot of memory  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/core-contracts/contracts/sol/BTCPoolDelegator.sol#L55  https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/core-contracts/contracts/sol/USDPoolDelegator.sol#L51   ## Tools Used  manual review  ## Recommended Mitigation Steps   
# Handle  JMukesh   # Vulnerability details  ## Impact wrong operator used in checking the fees, adminfee, withdrawfee instead of      require(_fee < SwapUtils.MAX_SWAP_FEE, "_fee exceeds maximum");       _fee < = SwapUtils.Max_Swap_Fee , should be there same with adminfee & withdrawfee becuase in using <= it does not exceed the max value     ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/customswap/contracts/Swap.sol#L192   ## Tools Used manual review  ## Recommended Mitigation Steps use correct operator to check the value  
# Handle  WatchPug   # Vulnerability details  Based on the context, the `tokenPrecisionMultipliers` used in price calculation should be calculated in realtime based on `initialTargetPrice`, `futureTargetPrice`, `futureTargetPriceTime` and current time, just like `getA()` and `getA2()`.  However, in the current implementation, `tokenPrecisionMultipliers` used in price calculation is the stored value, it will only be changed when the owner called `rampTargetPrice()` and `stopRampTargetPrice()`.  As a result, the `targetPrice` set by the owner will not be effective until another `targetPrice` is being set or `stopRampTargetPrice()` is called.  ### Recommendation  Consider adding `Swap.targetPrice` and changing the `_xp()` at L661 from:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L661-L667  ```solidity=661 function _xp(Swap storage self, uint256[] memory balances)     internal     view     returns (uint256[] memory) {     return _xp(balances, self.tokenPrecisionMultipliers); } ```  To:  ```solidity=661 function _xp(Swap storage self, uint256[] memory balances)     internal     view     returns (uint256[] memory) {     uint256[2] memory tokenPrecisionMultipliers = self.tokenPrecisionMultipliers;     tokenPrecisionMultipliers[0] = self.targetPrice.originalPrecisionMultipliers[0].mul(_getTargetPricePrecise(self)).div(WEI_UNIT)     return _xp(balances, tokenPrecisionMultipliers); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/AirdropDistribution.sol#L525-L525 ```solidity=525 require(airdrop[msg.sender].amount != 0); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/AirdropDistribution.sol#L561-L561 ```solidity=561 require(airdrop[msg.sender].amount >= claimable); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/InvestorDistribution.sol#L100-L100 ```solidity=100 require(investors[_investor].amount != 0); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/InvestorDistribution.sol#L126-L126 ```solidity=126 require(investors[msg.sender].amount - claimable != 0); ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/Vesting.sol#L184-L184  ```solidity=184     benVested[_addr][1] = partial_sum; ```  `benVested[_addr][1]` is never used in the contract and the sum of partial claimable vesting is changing every second. Removing it can save gas.  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1163-L1270  - `self.lpToken.totalSupply()` can be cached.  
# Handle  WatchPug   # Vulnerability details  The current design requires the number of pooledTokens to be 2, therefore `pooledTokens.length` can be replaced with literal `2` to save ~100 gas from each storage read (`SLOAD` after Berlin).  Instances include:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1027-L1027  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1068-L1068  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1082-L1082  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1169-L1169  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1230-L1230  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1332-L1334  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1369-L1369  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1421-L1421  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1447-L1447  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1471-L1471  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/Swap.sol#L336-L336  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/Swap.sol#L295-L295  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L620-L623  ```solidity=620 function getD(Swap storage self) internal view returns (uint256) {     uint256 a = determineA(self, _xp(self));            // determine the correct A     return getD(_xp(self), a); } ```  `a` is unnecessary as it's being used only once. The result of `_xp(self)` can be cached to avoid calling it twice.  ### Recommendation  Change to:  ```solidity=620 function getD(Swap storage self) internal view returns (uint256) {     uint256[] memory xp = _xp(self);     return getD(xp, determineA(self, xp)); } ```  
# Handle  WatchPug   # Vulnerability details  There are 4 events with the parameter `lpTokenSupply` in `SwapUtils.sol`, but the value of `lpTokenSupply` is not consistent.  For the event `RemoveLiquidityOne`, `lpTokenSupply` is post burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1349-L1349  ```solidity=1349 emit RemoveLiquidity(msg.sender, amounts, self.lpToken.totalSupply()); ```  For the event `RemoveLiquidityOne`, `lpTokenSupply` is pre burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1368-L1368  For the event `removeLiquidityImbalance`, `lpTokenSupply` is post burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1475-L1481  For the event `AddLiquidity`, `lpTokenSupply` is post mint:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1261-L1267  ### Recommendation  Given that 3 out of the 4 events are using updated `totalSupply` as `lpTokenSupply`, consider changing `RemoveLiquidityOne` to post burn `totalSupply`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1362-L1375  ```solidity=1362 function removeLiquidityOneToken(     Swap storage self,     uint256 tokenAmount,     uint8 tokenIndex,     uint256 minAmount ) external returns (uint256) {     uint256 totalSupply = self.lpToken.totalSupply();     uint256 numTokens = self.pooledTokens.length;     require(         tokenAmount <= self.lpToken.balanceOf(msg.sender),         ">LP.balanceOf"     );     require(tokenIndex < numTokens, "Token not found");  ```  The external call to get the `totalSupply` of the `lpToken` can be done later to avoid unnecessary code execution when the check of `tokenAmount` and `tokenIndex` does not pass.  
# Handle  WatchPug   # Vulnerability details  `getYD()` already `require(tokenIndex < numTokens, "...")`, so the check in `getYDC()` is redundant.  Removing it will make the code simpler and save some gas.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L477-L502  ```solidity=477 function getYDC(     Swap storage self,     uint256 a,     uint8 tokenIndex,     uint256[] memory xp,     uint256 d ) internal view returns (uint256) {     uint256 numTokens = xp.length;     require(tokenIndex < numTokens, "Token not found");      // calculate y     uint256 y = getYD(a, tokenIndex, xp, d);     // ... } ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L522-L557 ```solidity=522 function getYD(     uint256 a,     uint8 tokenIndex,     uint256[] memory xp,     uint256 d ) internal pure returns (uint256) {     uint256 numTokens = xp.length;     require(tokenIndex < numTokens, "Token not found");     // ... } ```   ### Recommendation  Remove the redundant code.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1710-L1714  ```solidity=1710 /**      * @notice Stops ramping Target price immediately. Once this function is called, rampTargetPrce()      * cannot be called for another 24 hours      * @param self TargetPrice struct to update      */ ```  `rampTargetPrce` should be `rampTargetPrice`.  
# Handle  WatchPug   # Vulnerability details  The parameter names of event `RampTargetPrice` should be the same as the struct `TargetPrice` for consistency.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L61-L78  ```solidity=61 event RampTargetPrice(     uint256 oldTargetPrice,     uint256 newTargetPrice,     uint256 initialTime,     uint256 futureTime ); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L117-L124  ```solidity=117{120-121} struct TargetPrice {     uint256 initialTargetPrice;     uint256 futureTargetPrice;     uint256 initialTargetPriceTime;     uint256 futureTargetPriceTime;          uint256[2] originalPrecisionMultipliers; } ```  ### Recommendation  Consider changing to:  ```solidity event RampTargetPrice(     uint256 oldTargetPrice,     uint256 newTargetPrice,     uint256 initialTargetPriceTime,     uint256 futureTargetPriceTime ); ```  
# Handle  WatchPug   # Vulnerability details  `transferredDx` is unnecessary, it can be replaced with `dx`.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1098-L1123  ```solidity=1098{1119-1123} function swap(     Swap storage self,     uint8 tokenIndexFrom,     uint8 tokenIndexTo,     uint256 dx,     uint256 minDy ) external returns (uint256) {     require(         dx <= self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender),         "Cannot swap more than you own"     );      // Transfer tokens first to see if a fee was charged on transfer     uint256 beforeBalance =         self.pooledTokens[tokenIndexFrom].balanceOf(address(this));     self.pooledTokens[tokenIndexFrom].safeTransferFrom(         msg.sender,         address(this),         dx     );      // Use the actual transferred amount for AMM math     uint256 transferredDx =         self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(             beforeBalance         );     // ... ```  ### Recommendation  Change to:  ```solidity // Use the actual transferred amount for AMM math uint256 dx =     self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(         beforeBalance     ); // ... ```  
# Handle  cmichel   # Vulnerability details  The `AirdropDistribution.claimExact` and `InvestorDistribution.claimExact` functions check that `msg.sender != address(0)`.  This is always true, nobody has the private key of the zero address and it cannot be spoofed. This check can be removed.  
# Handle  cmichel   # Vulnerability details  The `Swap.constructor` checks if both arrays `_pooledTokens` and `decimals` are of length two, but then does another check if these arrays have the same length.  ```solidity require(     _pooledTokens.length == decimals.length,     "_pooledTokens decimals mismatch" ); ```  This check will always be true as it has been checked that both arrays are of length two.  
# Handle  cmichel   # Vulnerability details  The protocol uses two amplifier values A1 and A2 for the swap, depending on the target price, see `SwapUtils.determineA`. The swap curve is therefore a join of two different curves at the target price. When doing a trade that crosses the target price, it should first perform the trade partially with A1 up to the target price, and then the rest of the trade order with A2.  However, the `SwapUtils.swap / _calculateSwap` function does not do this, it only uses the "new A", see `getYC` step 5.  ```solidity // 5. Check if we switched A's during the swap if (aNew == a){     // We have used the correct A     return y; } else {    // We have switched A's, do it again with the new A     return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d); } ```  ## Impact Trades that cross the target price and would lead to a new amplifier being used are not split up and use the new amplifier for the _entire trade_. This can lead to a worse (better) average execution price than manually splitting the trade into two transactions, first up to but below the target price, and a second one with the rest of the trader order size, using both A1 and A2 values.  In the worst case, it could even be possible to make the entire trade with one amplifier and then sell the swap result again using the other amplifier making a profit.  ## Recommended Mitigation Steps Trades that lead to a change in amplifier value need to be split up into two trades using both amplifiers to correctly calculate the swap result.   
# Handle  cmichel   # Vulnerability details  The `BasicSale` contract uses a `secondsPerDay` value of `84200` but one day has `86400` seconds.  ## Impact The `secondsPerDay` does not reflect seconds per day.  ## Recommended Mitigation Steps Change the value.  
# Handle  cmichel   # Vulnerability details  The `BasicSale` contract includes ERC20 code like `_balances`, `_allowances` storage variables and `Transfer`, `Approval` events. This code is never used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `Swap.setAdminFee`: The `newAdminFee` should be validated the same way as in the constructor - `Swap.setSwapFee`: The `newSwapFee` should be validated the same way as in the constructor - `Swap.setDefaultWithdrawFee`: The `newWithdrawFee` should be validated the same way as in the constructor  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  jonah1005   # Vulnerability details  # Stop ramp target price would create huge arbitrage space. ## Impact `stopRampTargetPrice` would set the `tokenPrecisionMultipliers` to `originalPrecisionMultipliers[0].mul(currentTargetPrice).div(WEI_UNIT);` Once the `tokenPrecisionMultipliers` is changed, the price in the AMM pool would change. Arbitrager can sandwich `stopRampTargetPrice` to gain profit.  Assume the decision is made in the DAO, an attacker can set up the bot once the proposal to `stopRampTargetPrice` has passed. I consider this is a medium-risk issue.  ## Proof of Concept The `precisionMultiplier` is set here: [Swap.sol#L661-L666](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L661-L666)  We can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue. ```solidity     function setPrecisionMultiplier(uint256 multipliers) external {         swapStorage.tokenPrecisionMultipliers[0] = multipliers;      } ```  ```python print(swap.functions.getVirtualPrice().call()) swap.functions.setPrecisionMultiplier(2).transact() print(swap.functions.getVirtualPrice().call())  # output log: #     1000000000000000000 #     1499889859738721606 ``` ## Tools Used None ## Recommended Mitigation Steps Dealing with the target price with multiplier precision seems clever as we can reuse most of the existing code. However, the precision multiplier should be an immutable parameter. Changing it after the pool is setup would create multiple issues. This function could be implemented in a safer way IMHO.  A quick fix I would come up with is to ramp the `tokenPrecisionMultipliers` as the `aPrecise` is ramped. As the `tokenPrecision` is slowly increased/decreased, the arbitrage space would be slower and the profit would (probably) distribute evenly to lpers.  Please refer to `_getAPreceise`'s implementation [SwapUtils.sol#L227-L250](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L227-L250)  
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive operations  ## Proof of Concept  getD, getY, getYD functions calculate mul(d).div(xp[i].mul(numTokens) within the token cycles https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L538 https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L588 https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L861  d, numTokens are constant there, so the divisions are redundant.  ## Recommended Mitigation Steps  Introduce (d / numTokens) variable and simplify the multiplication  Now: uint256 c = d; ... for (uint256 i = 0; i < numTokens; i++) {   if (i != tokenIndex) {     s = s.add(xp[i]);     c = c.mul(d).div(xp[i].mul(numTokens));  To be: uint256 c = d; uint256 d_num = d.div(numTokens); ... for (uint256 i = 0; i < numTokens; i++) {   if (i != tokenIndex) {     s = s.add(xp[i]);     c = c.mul(d_num).div(xp[i]);  
# Handle  Meta0xNull   # Vulnerability details  ## Impact revoke() Does Not Check Zero Address for _addr  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L104-L105  more...  ## Tools Used Manual Review  ## Recommended Mitigation Steps Check _addr for Zero Address  
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive operations  ## Proof of Concept  SwapUtils.calculateTokenAmount's 'deposit' bool variable is checked on each iteration, while one check is enough https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1031  ## Recommended Mitigation Steps  It's recommended to separate the cycles:  Now: for (uint256 i = 0; i < numTokens; i++) {   if (deposit) {     balances1[i] = balances1[i].add(amounts[i]);   } else {     balances1[i] = balances1[i].sub(       amounts[i],       "Cannot withdraw more than available"     );   } }  To be: if (deposit) {   for (uint256 i = 0; i < numTokens; i++) {    balances1[i] = balances1[i].add(amounts[i]);   } } else {   for (uint256 i = 0; i < numTokens; i++) {    balances1[i] = balances1[i].sub(      amounts[i],      "Cannot withdraw more than available"    );   } }   
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive external function calls  ## Proof of Concept  SwapUtils's addLiquidity function calls LP token totalSupply() several times: 6 code occurrences, one is in cycle. The very last occurrency should be kept as it is, the first 5 of them should be replaced with memory variable as the supply changes only once when LP mint() is called at the end of the function. https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1163  ## Recommended Mitigation Steps  Code update:  Now: if (self.lpToken.totalSupply() != 0) { ...  To be: uint256 lpTotalSupply = self.lpToken.totalSupply(); // storage read and function call if (lpTotalSupply != 0) { ...  
# Handle  Meta0xNull   # Vulnerability details  ## Impact Verify Airdrop Address Holders On Chain by Spending Gas is Unnecessary and probably cost a lot after adding up everyone cost.  ## Recommended At UI Frontend, wallet eg. Metamask allow UI to Verify Address Holders Without Spending Any Gas.  
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive storage reads  ## Proof of Concept  SwapUtils's getVirtualPrice repetitively calls _xp(self), which reads storage https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L705  ## Recommended Mitigation Steps  Now: uint256 a = determineA(self, _xp(self)); uint256 d = getD(_xp(self), a);  To be: uint256[] memory xP = _xp(self.balances, self.tokenPrecisionMultipliers); uint256 d = getD(xP, determineA(self, xP));  
# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive storage reads and function calls  ## Proof of Concept  SwapUtils's removeLiquidityImbalance does multiple _xp(self) calls, which can be saved to memory when balances don't change inbetween executions https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1415  ## Recommended Mitigation Steps  Now: uint256[] memory balances1 = self.balances; v.preciseA = determineA(self, _xp(self)); v.d0 = getD(_xp(self), v.preciseA); ... v.d1 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1))); ... v.d2 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1)));  To be: uint256[] memory balances1 = self.balances; uint256[] memory tokenPM = self.tokenPrecisionMultipliers; // doesn't change, save and reuse uint256[] memory xP = _xp(balances1, tokenPM); // We already copied self.balances, no need to reread storage v.d0 = getD(xP, determineA(self, xP)); // v.preciseA isn't used elsewhere and can be dropped ... xP = _xp(balances1, tokenPM); // balances1 was modified, recomputing v.d1 = getD(xP, determineA(self, xP)); ... xP = _xp(balances1, tokenPM); // balances1 was modified, recomputing v.d2 = getD(xP, determineA(self, xP));  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent due to excessive storage reads  ## Proof of Concept  SwapUtils's swap: saving self.pooledTokens[tokenIndexFrom], which do not change, to memory and reusing will reduce gas costs. https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1098  ## Recommended Mitigation Steps  Now: self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender)... ... uint256 beforeBalance = self.pooledTokens[tokenIndexFrom].balanceOf(address(this)); self.pooledTokens[tokenIndexFrom].safeTransferFrom( ... uint256 transferredDx = self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(beforeBalance); To be: IERC20 memory fromToken = self.pooledTokens[tokenIndexFrom]; fromToken.balanceOf(msg.sender)... ... uint256 beforeBalance = fromToken.balanceOf(address(this)); fromToken.safeTransferFrom( ... uint256 transferredDx = fromToken.balanceOf(address(this)).sub(beforeBalance);  
# Handle  hyh   # Vulnerability details  ## Proof of Concept  The only usage is in _claimableAmount function and can be rewritten with one uint256 storage variable. https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L183 benVested cannot be used to get current state as it is updated only during claim() and revoke() calls and calcClaimableAmount() to be used instead.  The timelocks totals and benTotal cannot differ as timelocks are updated and deleted in vest() and revoke() functions only correspondingly, while there benTotal is updated with very same amount without any additional conditions. https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L91 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L128  This way the 's <= benTotal[_addr]' check is redundant and to be removed.  ## Impact  's <= benTotal[_addr]' check can be dangerous: the totals and benTotal cannot differ, while if there would be such a possibility, various attacks might be possible, for example a griefing one, when claim() always fails because of this check, and so on.  I.e. now benVested can be simplified and check is not needed, while if there would be such a situation when it is needed, simple check as it is cannot be sufficient, and some code redesign should be done instead.  ## Recommended Mitigation Steps  Code update: Now: mapping(address => uint256[2]) public benVested; ... uint256 completely_vested = 0; uint256 partial_sum = 0; ... completely_vested = completely_vested.add(timelocks[_addr][i].amount); ... partial_sum = partial_sum.add(claimable); ... benVested[_addr][0] = benVested[_addr][0].add(completely_vested); benVested[_addr][1] = partial_sum; uint256 s = benVested[_addr][0].add(partial_sum); assert(s <= benTotal[_addr]); return s;  To be: mapping(address => uint256) public benVested; ... uint256 currently_vested = 0; ... currently_vested = currently_vested.add(timelocks[_addr][i].amount); ... currently_vested = currently_vested.add(claimable); ... uint256 s = benVested[_addr].add(currently_vested); benVested[_addr] = s; return s;  Also, cleaning in revoke() simplifies to benVested[_addr] = 0; https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L127  
# Handle  jonah1005   # Vulnerability details  ## Impact There's a feature of `virtualPrice` that is monotonically increasing regardless of the market. This function is heavily used in multiple protocols. e.g.(curve metapool, mim, ...) This is not held in the current implementation of customSwap since `customPrecisionMultipliers` can be changed by changing the target price.  There're two issues here: The meaning of `virtualPrice` would be vague. This may damage the lp providers as the protocol that adopts it may be hacked.  I consider this is a medium-risk issue.  ## Proof of Concept We can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue. ```solidity     function setPrecisionMultiplier(uint256 multipliers) external {         swapStorage.tokenPrecisionMultipliers[0] = multipliers;      } ```  ```python     print(swap.functions.getVirtualPrice().call())     swap.functions.setPrecisionMultiplier(2).transact()     print(swap.functions.getVirtualPrice().call())  # output log: #   1000000000000000000 #   1499889859738721606 ``` ## Tools Used None ## Recommended Mitigation Steps Dealing with the target price with multiplier precision seems clever as we can reuse most of the existing code. However, the precision multiplier should be an immutable parameter. Changing it after the pool is set up would create multiple issues. This function could be implemented in a safer way IMHO.  The quick fix would be to remove the `getVirtualPrice` function. I can't come up with a safe way if other protocol wants to use this function.   
# Handle  jonah1005   # Vulnerability details  ## Impact CustomPrecisionMultipliers are set in the constructor: ```solidity         customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).div(10 ** 18); ``` `originalPrecisionMultipliers` equal to 1 if the token's decimal = 18. The targe price could only be an integer.  If the target price is bigger than 10**18, the user can deposit and trade in the pool. Though, the functionality would be far from the spec.  If the target price is set to be smaller than 10**18, the pool would be broken and all funds would be stuck.  I consider this is a high-risk issue.   ## Proof of Concept Please refer to the implementation. [Swap.sol#L184-L187](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L184-L187)  We can also trigger the bug by setting a pool with target price = 0.5. (0.5 * 10**18) ## Tools Used None ## Recommended Mitigation Steps I recommend providing extra 10**18 in both multipliers. ```solidity         customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).mul(10**18).div(10 ** 18);         customPrecisionMultipliers[1] = targetPriceStorage.originalPrecisionMultipliers[1].mul(10**18); ``` The customswap only supports two tokens in a pool, there's should be enough space. Recommend the devs to go through the trade-off saddle finance has paid to support multiple tokens. The code could be more clean and efficient if the pools' not support multiple tokens.   
# Handle  pants   # Vulnerability details  If data can fit into 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. On the MarketPlace.sol contract, string memory variable can be replaced with bytes32 array. That will save gas on the contract.  An example is revert messages. For example look at line 32 of PublicSale.sol.  
# Handle  pants   # Vulnerability details  On L158 of swap.sol, you use a uint8 as the for loop variable:  Due to how the EVM natively works on 256 numbers, using a 8 bit number here introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage  
# Handle  pants   # Vulnerability details  You import "import "./hardhat/console.sol";" and all uses are commented. You should also comment the import. SwapUtils line 9  
# Handle  mics   # Vulnerability details  Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  (non-exhaustive) List of Examples: SwapUtils line 639 USDPoolDelegator line 53 Swap.sol line 135   
# Handle  mics   # Vulnerability details  You could use the variable d instead of defining a new variable y at line 548 of SwapUtils.sol  
# Handle  mics   # Vulnerability details  Missing revert messages in the following places:  1.  ETHPoolDelegator line 67 2.  BTCPoolDelegator line 67 3.  USDPoolDelegator lines 55, 56  
# Handle  mics   # Vulnerability details  safeApprove is now deprecated, see the link below. https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38.  This appears for example in line 499 of AirdropDistribution.sol.  we recommend as in OpenZepplin documentation “whenever possible, use safeIncreaseAllowance and safeDecreaseAllowance instead”.     
# Handle  pmerkleplant   # Vulnerability details  Constants should be written in UPPER_CASE, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#constants).  Constants breaking this convention:  - `decimals` in `tge/contracts/PublicSale.sol` - `coin` in `tge/contracts/PublicSale.sol` - `secondsPerDay` in `tge/contracts/PublicSale.sol` - `firstEra` in `tge/contracts/PublicSale.sol`  
# Handle  pmerkleplant   # Vulnerability details  Contract `Vesting` in `vesting/contracts/Vesting.sol` should inherit from the interface `IVesting` in `vesting/contracts/interfaces/IVesting.sol` as the contract implements the interface.  
# Handle  pmerkleplant   # Vulnerability details  Functions should be written in mixedCase, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#function-names).  Functions breaking this convention:  - Function `_available_supply` in `vesting/contracts/AidropDistribution.sol` - Function `available_supply` in `vesting/contracts/AidropDistribution.sol` - Function `_available_supply` in `vesting/contracts/InvestorDistribution.sol` - Function `available_supply` in `vesting/contracts/InvestorDistribution.sol` - Function `dev_rugpull` in `vesting/contracts/InvestorDistribution.sol`  
# Handle  pmerkleplant   # Vulnerability details  Events should be written in CapWords, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#event-names).  Events breaking this convention:  - `updateMiningParameters` in `vesting/contracts/AidropDistribution.sol` - `updateMiningParameters` in `vesting/contracts/InvestorDistribution.sol`  
# Handle  pmerkleplant   # Vulnerability details  Removing unused variables saves gas and increases code clarity.  Following variables are unused and can be removed:  - `Hour` in `vesting/contracts/AidropDistribution.sol` - `Day` in `vesting/contracts/AirdropDistribution.sol` - `Hour` in `vesting/contracts/InvestorDistribution.sol` - `Day` in `vesting/contracts/InvestorDistribution.sol` - `_balance` in `tge/contracts/PublicSale.sol` - `_allowance` in `tge/contracts/PublicSale.sol`  
# Handle  loop   # Vulnerability details  `AirDropDistribution.sol` and `InvestorDistribution.sol` import the `safeERC20` library but make use of the normal ERC20 `transfer` function rather than `safeTransfer`. Considering this is called on the BOOT token there is likely no need for it to be `safeTransfer`. However, since the library is not used there is no need for it to be imported.   ## Proof of Concept - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L12 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L12  Transfer calls: - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L542 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L567  - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L132 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L156 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L207  
# Handle  jonah1005   # Vulnerability details  ## Impact When a user provides imbalanced liquidity, the fee is calculated according to the ideal balance. In saddle finance, the optimal balance should be the same ratio as in the Pool.  Take, for example, if there's 10000 USD and 10000 DAI in the saddle's USD/DAI pool, the user should get the optimal lp if he provides lp with ratio = 1.  However, if the customSwap pool is created with a target price = 2. The user would get 2 times more lp if he deposits DAI. [SwapUtils.sol#L1227-L1245](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1227-L1245) The current implementation does not calculates ideal balance correctly.  If the target price is set to be 10, the ideal balance deviates by 10. The fee deviates a lot. I consider this is a high-risk issues.  ## Proof of Concept We can observe the issue if we initiates two pools DAI/LINK pool and set the target price to be 4.  For the first pool, we deposit more dai. ```python     swap = deploy_contract('Swap'          [dai.address, link.address], [18, 18], 'lp', 'lp', 1, 85, 10**7, 0, 0, 4* 10**18)     link.functions.approve(swap.address, deposit_amount).transact()     dai.functions.approve(swap.address, deposit_amount).transact()     previous_lp = lptoken.functions.balanceOf(user).call()     swap.functions.addLiquidity([deposit_amount, deposit_amount // 10], 10, 10**18).transact()     post_lp = lptoken.functions.balanceOf(user).call()     print('get lp', post_lp - previous_lp) ```  For the second pool, one we deposit more dai. ```python     swap = deploy_contract('Swap'          [dai.address, link.address], [18, 18], 'lp', 'lp', 1, 85, 10**7, 0, 0, 4* 10**18)     link.functions.approve(swap.address, deposit_amount).transact()     dai.functions.approve(swap.address, deposit_amount).transact()     previous_lp = lptoken.functions.balanceOf(user).call()     swap.functions.addLiquidity([deposit_amount, deposit_amount // 10], 10, 10**18).transact()     post_lp = lptoken.functions.balanceOf(user).call()     print('get lp', post_lp - previous_lp) ```  We can get roughly 4x more lp in the first case ## Tools Used None ## Recommended Mitigation Steps  The current implementation uses `self.balances`  https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1231-L1236 ```soliditiy             for (uint256 i = 0; i < self.pooledTokens.length; i++) {                 uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);                 fees[i] = feePerToken                     .mul(idealBalance.difference(newBalances[i]))                     .div(FEE_DENOMINATOR);                 self.balances[i] = newBalances[i].sub(                     fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)                 );                 newBalances[i] = newBalances[i].sub(fees[i]);             } ```  Replaces `self.balances` with `_xp(self, newBalances)` would be a simple fix. I consider the team can take balance's weighted pool as a reference. [WeightedMath.sol#L149-L179](https://github.com/balancer-labs/balancer-v2-monorepo/blob/7ff72a23bae6ce0eb5b134953cc7d5b79a19d099/pkg/pool-weighted/contracts/WeightedMath.sol#L149-L179)  
# Handle  0v3rf10w   # Vulnerability details  ## Impact Multiple Reentrancy  ## Proof of Concept Reentrancy in BasicSale.receive() (tge/contracts/PublicSale.sol#148-156)  Reentrancy in BasicSale.burnEtherForMember(address) (tge/contracts/PublicSale.sol#158-166)   State variables written after the external call(s) in all above.  ## Tools Used Manual  ## Recommended Mitigation Steps  
# Handle  0v3rf10w   # Vulnerability details  ## Impact Missing Zero address check  ## Proof of Concept BasicSale.constructor(IERC20,IERC721,IVesting,uint256,uint256,uint256,uint256,address)._burnAddress (tge/contracts/PublicSale.sol#112)  lacks a zero-check on :- burnAddress = _burnAddress (tge/contracts/PublicSale.sol#137)  ## Tools Used Manual  ## Recommended Mitigation Steps Check that the address is zero   
# Handle  0v3rf10w   # Vulnerability details  ## Impact Unchecked low-level calls  ## Proof of Concept Unchecked cases at 2 places :- BasicSale.receive() (2021-11-bootfinance/tge/contracts/PublicSale.sol#148-156) ignores return value by burnAddress.call{value: msg.value}() (2021-11-bootfinance/tge/contracts/PublicSale.sol#154)  BasicSale.burnEtherForMember(address) (2021-11-bootfinance/tge/contracts/PublicSale.sol#158-166) ignores return value by burnAddress.call{value: msg.value}() (2021-11-bootfinance/tge/contracts/PublicSale.sol#164)   ## Tools Used Manual  ## Recommended Mitigation Steps The return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low level is used to prevent blocking operations, consider logging failed calls.  
# Handle  jonah1005   # Vulnerability details  ## Impact The sanity checks in `rampTargetPrice` are broken [SwapUtils.sol#L1571-L1581](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1571-L1581) ```solidity         if (futureTargetPricePrecise < initialTargetPricePrecise) {             require(                 futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,                 "futureTargetPrice_ is too small"             );         } else {             require(                 futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),                 "futureTargetPrice_ is too large"             );         } ``` If `futureTargetPricePrecise` is smaller than `initialTargetPricePrecise` 0.01 of `futureTargetPricePrecise` would never larger than `initialTargetPricePrecise`.  Admin would not be able to ramp the target price. As it's one of the most important features of the customswap, I consider this is a high-risk issue  ## Proof of Concept Here's a web3.py script to demo that it's not possible to change the target price even by 1 wei. ```python     p1, p2, _, _ =swap.functions.targetPriceStorage().call()     future = w3.eth.getBlock(w3.eth.block_number)['timestamp'] + 200 * 24 * 3600      # futureTargetPrice_ is too small     swap.functions.rampTargetPrice(p1 -1, future).transact()     # futureTargetPrice_ is too large     swap.functions.rampTargetPrice(p1 + 1, future).transact() ``` ## Tools Used None ## Recommended Mitigation Steps  Would it be something like: ```solidity         if (futureTargetPricePrecise < initialTargetPricePrecise) {             require(                 futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE + WEI_UNIT).div(WEI_UNIT) >= initialTargetPricePrecise,                 "futureTargetPrice_ is too small"             );         } else {             require(                 futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE + WEI_UNIT).div(WEI_UNIT),                 "futureTargetPrice_ is too large"             );         } ``` I believe the dev would spot this mistake if there's a more relaxed timeline.  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact  I'm not sure why some of this code is commented out.   It could point to items that are not done or need redesigning, be a mistake, or just be testing overhead.   ## Proof of Concept The commented out code is here:  Unclear: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L27 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L76  Obviously Test related: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L187  Guarded launch: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L42-L49 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L201-L204 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L235-L237  ## Tools Used VS Code  ## Recommended Mitigation Steps Review and remove or resolve/document the commented out lines if needed.  
# Handle  pants   # Vulnerability details  ## Impact In BTCPoolDelegator contract, address state variables `future_owner` in lines 51 and bool state variable `is_killed` in line 55 should be placed one after another. solidity keep storage in 32 bytes slot and can optimize multiple variables that are less than 32 bytes. address is 20 bytes and bool is 1 byte, so it can be placed in one storage slot instead of two.  ## Proof of Concept Tested it on Remix, saves 50 gas per transaction  ## Recommended Mitigation Steps change ``` 50    uint256 public future_admin_fee; 51    address public future_owner; 52 53    uint256 kill_deadline; 54    uint256 constant kill_deadline_dt = 2 * 30 * 86400; 54    bool is_killed; ``` to ``` 50    uint256 public future_admin_fee; 51    uint256 constant kill_deadline_dt = 2 * 30 * 86400; 52 53    uint256 kill_deadline; 54    address public future_owner; 54    bool is_killed; ```  
# Handle  Reigada   # Vulnerability details  ## Impact The contract BasicSale contains a fallback function and a burnEtherForMember() function with exactly the same implementation. These 2 functions do the following call: _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);  The _recordBurn function contains the following if block: if (mapEraDay_MemberUnits[_era][_day][_member] == 0) {                              // If hasn't contributed to this Day yet     mapMemberEra_Days[_member][_era].push(_day);                                    // Add it     mapEraDay_MemberCount[_era][_day] += 1;                                         // Count member     mapEraDay_Members[_era][_day].push(_member);                                    // Add member }  What does this mean? If a user performs multiple calls to the contract sending 0 ether as msg.value, the if block will be entered and a new key will be pushed to the mapping. Luckily the cost of an addition to or a read from a mapping does not change with the number of keys mapped. But this would totally mess the function getDaysContributedForEra output. Currently this function is only used as a view function, and not used by the smart contract itself. But it's a risk for future implementations that may make use of it.  ## Proof of Concept >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0xd65ffecd5052314bc09f616461ff6aa9efeb857151c0339dc15653fb90ebb91f   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 0   Transaction confirmed   Block: 13577879   Gas used: 117368 (1.75%)  <Transaction '0xd65ffecd5052314bc09f616461ff6aa9efeb857151c0339dc15653fb90ebb91f'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 1  >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0x0a48f89c1266af2c3eea5cdcec93dae76e4ed2a0936e53e8713d669989b88b19   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 1   Transaction confirmed   Block: 13577880   Gas used: 91568 (1.36%)  <Transaction '0x0a48f89c1266af2c3eea5cdcec93dae76e4ed2a0936e53e8713d669989b88b19'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 2  >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0xeb85e31664eb1578f54daba1be112f9533948d0e2414510874ed55fbb3a9a9e0   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 2   Transaction confirmed   Block: 13577881   Gas used: 91568 (1.36%)  <Transaction '0xeb85e31664eb1578f54daba1be112f9533948d0e2414510874ed55fbb3a9a9e0'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 3  ## Tools Used Manual testing  ## Recommended Mitigation Steps Add the following require statement to the fallback and the burnEtherForMember() functions: require(msg.value > 0, "Some ether should be sent")  
# Handle  Reigada   # Vulnerability details  ## Impact As we can see in the contracts AirdropDistribution and InvestorDistribution, they both have the following approve() call: mainToken.approve(address(vestLock), 2**256-1); https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L499 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L80  This is necessary because both contracts transfer tokens to the vesting contract by calling its vest() function: https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L544 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L569 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L134 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L158  The code of the vest() function in the Vesting contract performs a transfer from msg.sender to Vesting contract address -> vestingToken.transferFrom(msg.sender, address(this), _amount); https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L95  Same is done in the BasicSale contract: https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSale.sol#L225  The problem is that this contract is missing the approve() call. For that reason, the contract is totally useless as the function _withdrawShare() will always revert with the following message: revert reason: ERC20: transfer amount exceeds allowance. This means that all the mainToken sent to the contract would be stuck there forever. No way to retrieve them.  How this issue was not detected in the testing phase? Very simple. The mock used by the team has an empty vest() function that performs no transfer call. https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/helper/MockVesting.sol#L10  ## Proof of Concept See below Brownie's custom output: Calling -> publicsale.withdrawShare(1, 1, {'from': user2}) Transaction sent: 0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 5   BasicSale.withdrawShare confirmed (ERC20: transfer amount exceeds allowance)   Block: 13577532   Gas used: 323334 (4.81%)  Call trace for '0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde': Initial call cost  [21344 gas] BasicSale.withdrawShare  0:3724  [16114 / -193010 gas] ├── BasicSale._withdrawShare  111:1109  [8643 / 63957 gas] │   ├── BasicSale._updateEmission  116:405  [53294 / 55739 gas] │   │   └── BasicSale.getDayEmission  233:248  [2445 gas] │   ├── BasicSale._processWithdrawal  437:993  [-7726 / -616 gas] │   │   ├── BasicSale.getEmissionShare  484:859  [4956 / 6919 gas] │   │   │   │ │   │   │   └── MockERC20.balanceOf  [STATICCALL]  616:738  [1963 gas] │   │   │           ├── address: mockerc20.address │   │   │           ├── input arguments: │   │   │           │   └── account: publicsale.address │   │   │           └── return value: 100000000000000000000 │   │   │ │   │   └── SafeMath.sub  924:984  [191 gas] │   └── SafeMath.sub  1040:1100  [191 gas] │ ├── MockERC20.transfer  [CALL]  1269:1554  [1115 / 30109 gas] │   │   ├── address: mockerc20.address │   │   ├── value: 0 │   │   ├── input arguments: │   │   │   ├── recipient: user2.address │   │   │   └── amount: 27272727272727272727 │   │   └── return value: True │   │ │   └── ERC20.transfer  1366:1534  [50 / 28994 gas] │       └── ERC20._transfer  1374:1526  [28944 gas] └── Vesting.vest  [CALL]  1705:3712  [-330491 / -303190 gas]     │   ├── address: vesting.address     │   ├── value: 0     │   ├── input arguments:     │   │   ├── _beneficiary: user2.address     │   │   ├── _amount: 63636363636363636363     │   │   └── _isRevocable: 0     │   └── revert reason: ERC20: transfer amount exceeds allowance <-------------     │     ├── SafeMath.add  1855:1883  [94 gas]     ├── SafeMath.add  3182:3210  [94 gas]     ├── SafeMath.add  3236:3264  [94 gas]     │     └── MockERC20.transferFrom  [CALL]  3341:3700  [99923 / 27019 gas]         │   ├── address: mockerc20.address         │   ├── value: 0         │   ├── input arguments:         │   │   ├── sender: publicsale.address         │   │   ├── recipient: vesting.address         │   │   └── amount: 63636363636363636363         │   └── revert reason: ERC20: transfer amount exceeds allowance         │         └── ERC20.transferFrom  3465:3700  [-97648 / -72904 gas]             └── ERC20._transfer  3473:3625  [24744 gas]  ## Tools Used Manual testing  ## Recommended Mitigation Steps The following approve() call should be added in the constructor of the BasicSale contract: mainToken.approve(address(vestLock), 2**256-1);  
# Handle  0x0x0x   # Vulnerability details  ## Impact Gas optimization  ## Proof of Concept  On Swap.sol at L190 and L191, it is checked that whether _a and _a2 is bigger equal to 0. Since they are both uint256, this condition is always satisfied. Therefore, those conditions are not required.  ## Tools Used  Manual analysis  
# Handle  gpersoon   # Vulnerability details  ## Impact Anyone can call the function vest() of Vesting.sol, for example with a smail "_amount" of tokens, for any _beneficiary.  The function overwrites the value of benRevocable[_beneficiary], effectively erasing any previous value.  So you can set any _beneficiary to Revocable. Although revoke() is only callable by the owner, this is circumventing the entire mechanism of benRevocable.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L73-L98  function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable whenNotPaused {         ...         if(_isRevocable == 0){             benRevocable[_beneficiary] = [false,false];  // just overwrites the value         }         else if(_isRevocable == 1){             benRevocable[_beneficiary] = [true,false]; // just overwrites the value         }        ## Tools Used  ## Recommended Mitigation Steps Whitelist the calling of vest() Or check if values for benRevocable are already set.   
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you are an investor and want to claim the last part of your claimable tokens (or your entire set of claimable tokens if you haven't claimed anything yet). Then you call the function claim() of InvestorDistribution.sol, which has the following statement: "require(investors[msg.sender].amount - claimable != 0);" This statement will prevent you from claiming your tokens because it will stop execution.  Note: with the function claimExact() it is possible to claim the last part.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/InvestorDistribution.sol#L113-L128  function claim() external nonReentrant { ...         require(investors[msg.sender].amount - claimable != 0);         investors[msg.sender].amount -= claimable;  ## Tools Used  ## Recommended Mitigation Steps Remove the require statement.   
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you are eligible for the last part of your airdrop (or your entire airdrop if you haven't claimed anything yet). Then you call the function claim() of AirdropDistribution.sol, which has the following statement: "assert(airdrop[msg.sender].amount - claimable != 0);" This statement will prevent you from claiming your airdrop because it will stop execution.  Note: with the function claimExact() it is possible to claim the last part.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L522-L536  function claim() external nonReentrant {        ..         assert(airdrop[msg.sender].amount - claimable != 0);         airdrop[msg.sender].amount -= claimable;  ## Tools Used  ## Recommended Mitigation Steps Remove the assert statement. Also add the following to validate() , to prevent claiming the airdrop again:       require(validated[msg.sender]== 0, "Already validated.");  
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose someone claims the last part of his airdrop via claimExact() of AirdropDistribution.sol Then airdrop[msg.sender].amount will be set to 0.  Suppose you then call validate() again.  The check "airdrop[msg.sender].amount == 0" will allow you to continue, because amount has just be set to 0. In the next part of the function, airdrop[msg.sender] is overwritten with fresh values and airdrop[msg.sender].claimed will be reset to 0.  Now you can claim your airdrop again (as long as there are tokens present in the contract)  Note: The function claim() prevents this from happening via "assert(airdrop[msg.sender].amount - claimable != 0);", which has its own problems, see other reported issues.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L555-L563  function claimExact(uint256 _value) external nonReentrant {         require(msg.sender != address(0));         require(airdrop[msg.sender].amount != 0);                  uint256 avail = _available_supply();         uint256 claimable = avail * airdrop[msg.sender].fraction / 10**18; //         if (airdrop[msg.sender].claimed != 0){             claimable -= airdrop[msg.sender].claimed;         }          require(airdrop[msg.sender].amount >= claimable); // amount can be equal to claimable         require(_value <= claimable);                       // _value can be equal to claimable         airdrop[msg.sender].amount -= _value;      // amount will be set to 0 with the last claim   // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L504-L517 function validate() external nonReentrant {         ...         require(airdrop[msg.sender].amount == 0, "Already validated.");         ...              Airdrop memory newAirdrop = Airdrop(airdroppable, 0, airdroppable, 10**18 * airdroppable / airdrop_supply);              airdrop[msg.sender] = newAirdrop;              validated[msg.sender] = 1;   // this is set, but isn't checked on entry of this function  ## Tools Used  ## Recommended Mitigation Steps Add the following to validate() :         require(validated[msg.sender]== 0, "Already validated.");  
# Handle  JMukesh   # Vulnerability details  ## Impact Event should be emitted after sensitive action like setting fees, admin_fees otherwise it will be difficult track offchain fees changes  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L57  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L58  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L53  ## Tools Used  manual review ## Recommended Mitigation Steps  event should be emitted after the sensitive action  
# Handle  JMukesh   # Vulnerability details  ## Impact due to lack of checking admin_fee, it can be greater than max_admin_fee  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L57  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L58  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L53  ## Tools Used  manual review  ## Recommended Mitigation Steps  add input validation for admin_fee  
# Handle  nathaniel   # Vulnerability details  ## Impact Inconsistency between the `claim()` function and `claimExact()` function, in that `claimExact` does not check the claimable amount. In the scenario where claimable = 0, and `investors[msg.sender].claimed != 0` then it will attempt to underflow. If `_amount` is 0, then it could potentially reach the `vestLock.vest()` function, where it will then revert with the inaccurate message "amount must be positive" which doesn't reflect the underlying issue.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L145 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L121 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L75  ## Tools Used manual review   ## Recommended Mitigation Steps Add `require(claimable > 0)`  
# Handle  nathaniel   # Vulnerability details  ## Impact `amount` in the `Investors` struct is vague. It would be assumed to be the invested amount, however this amount decreases when the beneficiary claims. A more appropriate name could be `unclaimed_amount`. `claimable_to_send` is not appropriate name in the `claimExact()` function, as it is not the claimable total, instead `exact_claim_to_send` would make more sense. ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L24 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L155   
# Handle  nathaniel   # Vulnerability details  ## Impact Functions include `updateEmission(), dev_rugpull(), setAdmin(), revoke() ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L185 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L203 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L212 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L104  
# Handle  nathaniel   # Vulnerability details  ## Impact The timelocks for any *beneficiary* are unbounded, and can be vested by someone who is not the *beneficiary*. When the array becomes significantly big enough, the vestments will no longer be claimable for the *beneficiary*.  The `vest()` function in Vesting.sol does not check the *beneficiary*, hence anyone can vest for anyone else, pushing a new timelock to the `timelocks[_beneficiary]`. The `_claimableAmount()` function (used by `claim()` function), then loops through the `timelocks[_beneficiary]` to determine the amount to be claimed. A malicious actor can easy repeatedly call the `vest()` function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable.  The malicious actor could do this to each *beneficiary*, locking up all the vestments.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L81 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L195 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L148  ## Tools Used Manual code review  ## Recommended Mitigation Steps - Create a minimum on the vestment amounts, such that it won't be feasible for a malicious actor to create a large amount of vestments. - Restrict the vestment contribution of a *beneficiary* where `require(beneficiary == msg.sender)`  
# Handle  ye0lde   # Vulnerability details  ## Impact  Code clarity  ## Proof of Concept  The function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L291-L298  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to simplify:    <code>     function getDayEmission() public view returns (uint) {            return (remainingSupply > emission ? emission : remainingSupply);     } </code>  
# Handle  ye0lde   # Vulnerability details  ## Impact  Cache Reference To State Variables "currentDay, currentEra, emission" in _updateEmission (PublicSale.sol)  Caching the references to "currentDay, currentEra, emission" will decrease gas usage.   ## Proof of Concept  The variables "currentDay, currentEra, emission" are referenced 20 times in function "_updateEmission" here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L247-L276  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to cache those variables:    <code>  function _updateEmission() private {         uint _now = block.timestamp;                                                                                      // Find now()         if (_now >= nextDayTime) {                                                                                         // If time passed the next Day time                  uint256 _currentDay = currentDay;             uint256 _currentEra = currentEra;             uint256 _emission = emission;              if (remainingSupply > _emission) {                 remainingSupply -= _emission;                                                              }             else {                 remainingSupply = 0;                                                                     }             if (_currentDay >= daysPerEra) {                                                                                 // If time passed the next Era time                 _currentEra += 1; _currentDay = 0;                                                                        // Increment Era, reset Day                 nextEraTime = _now + (secondsPerDay * daysPerEra);                                          // Set next Era time                 _emission = getNextEraEmission();                                                                        // Get correct emission                 mapEra_Emission[currentEra] = _emission;                                                           // Map emission to Era                 emit NewEra(_currentEra, _emission, nextEraTime, totalBurnt);                            // Emit Event             }             _currentDay += 1;                                                                                                     // Increment Day             nextDayTime = _now + secondsPerDay;                                                                  // Set next Day time             _emission = getDayEmission();                                                                                // Check daily Dmission             mapEraDay_EmissionRemaining[_currentEra][_currentDay] = _emission;               // Map emission to Day             uint _era = _currentEra;             uint _day = _currentDay - 1;             if (_currentDay == 1) {                 // new era                 _era = _currentEra - 1;                 _day = daysPerEra;             }              currentDay = _currentDay;             currentEra = _currentEra;             emission = _emission;                 emit NewDay(_currentEra, _currentDay, nextDayTime, mapEraDay_Units[_era][_day], mapEraDay_MemberCount[_era][_day]);         }     } </code>   
# Handle  Reigada   # Vulnerability details  ## Impact In the Vesting contract, the function revoke() sends the vested tokens to the beneficiary and the remaining tokens that are not vested yet are sent to the multisig address. It makes no sense to allow calling this function once the address has already vested the 100% of the tokens (after 1 year in this case -> uint256 _unlockTimestamp = block.timestamp.add(unixYear);).  Basically in this case the function revoke() would behave like a claim() function but doing some extra checks which waste gas (gas paid by the owner of the contract instead of the beneficiary address) and also emitting an extra event -> https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L123  For that reason, it is recommended to add a require statement that handles this case:  uint256 index = timelocks[_addr].length - 1; require (block.timestamp < timelocks[_addr][index].releaseTimestamp, 'Account fully vested');  ## Tools Used Manual testing  ## Recommended Mitigation Steps It is recommended to add a require statement that handles this case in the Vesting.revoke() function:  uint256 index = timelocks[_addr].length - 1; require (block.timestamp < timelocks[_addr][index].releaseTimestamp, 'Account fully vested');  
# Handle  Reigada   # Vulnerability details  ## Impact There is an unnecessary require statement in vesting.claim() -> https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L197  This check is already done in https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L186  ## Tools Used Manual testing  ## Recommended Mitigation Steps Remove the require statement in the claim() function as it is totally unnecessary. The check is already performed in the function _claimableAmount(address _addr).  
# Handle  Reigada   # Vulnerability details  ## Impact In the contract Vesting, function vest(), the parameter _isRevocable is declared as an uint256 when it is used as a boolean.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L77  ## Tools Used Manual review  ## Recommended Mitigation Steps Declare the parameter _isRevocable as a bool.  
# Handle  Ruhum   # Vulnerability details  ## Impact With version 4.x of the ERC20 token, the `approve()` function returns a boolean indicating whether it was successful or not.  https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#IERC20-approve-address-uint256-  Best practice is to either check the return value or use `safeApprove()` / `safeIncreaseAllowance()` which will revert if the operation was unsuccessful  https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#SafeERC20-safeApprove-contract-IERC20-address-uint256-  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L499  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L80  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps use `safeApprove()` or `safeIncreaseAllowance()`  
# Handle  Reigada   # Vulnerability details  ## Impact In both airdrop contracts: AirdropDistribution and InvestorDistribution, once all the participants have claimed their tokens, some will remain in the contract due to some imprecision in the calculations. There is no function that allows to substract them which means that those tokens will remain stuck in the contracts forever.  I have made the test with just 5 participants: user2, user3, user4, user5 & user6.  uint256[5] airdropBalances =     [     4032000,     4032000,     4032000,     4032000,     4032000     ];  >>> 4032000 * 5 20160000  Initially 20160000 tokens were transferred to the contract  mockToken.transfer(airdropdist.address, 20160000000000000000000000)  After 260 weeks, these were the results:  ----------------> mockToken.balanceOf(airdropdist.address) -> 2842805668532461833600 <-----------------  mockToken.balanceOf(user2) -> 1209429431659888052289865 vesting.benTotal(user2.address) -> 2822002007206405455343415 mockToken.balanceOf(user3) -> 1209429431659888052289984 vesting.benTotal(user3.address) -> 2822002007206405455343296 mockToken.balanceOf(user4) -> 1209429431659888052289984 vesting.benTotal(user4.address) -> 2822002007206405455343296 mockToken.balanceOf(user5) -> 1209429431659888052289984 vesting.benTotal(user5.address) -> 2822002007206405455343296 mockToken.balanceOf(user6) -> 1209429431659888052289984 vesting.benTotal(user6.address) -> 2822002007206405455343296  As we can see above 2842 tokens remain in the contract and there is no way to retrieve them.  ## Tools Used Manual testing / brownie  ## Recommended Mitigation Steps Add an onlyOwner function that allows to retrieve all the remaining tokens once all the participants of the airdrop have claimed the whole amount of their rewards.  
# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details On the `AirdropDistribution.sol`, the `airdrop_supply` ([line 462](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L462)) value is set to be `20160000`. However, adding all the `airdropBalances` does show that the value should be `20159997` instead.   ## Impact This does cause some operations on the contract to mislead in the results. This is more noticed on bigger airdropped accounts.  ## Proof of Concept Adding all the `airdropBalances` values do show the difference.  ## Tools Used Manual code review  ## Recommended Mitigation Steps The `airdrop_supply` should be reflecting the actual airdropped balance without misleading the total amount. Change the value to `20159997`.  
# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details On the `claim` function ([line 524](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L524))  of the `AirdropDistribution.sol` contract, the `validated` check is redundant. The flag is only set when the `validate` function is called. Once validated, the amount will always be different than zero, meaning that the check is not necessary.  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps The check could be removed for gas optimization.  
# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details The `_available_supply` and `available_supply` functions on the `AirdropDistribution` (lines [601](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L601) and [607](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L607)) do contain the exact same code.  Furthermore, the `assert` check inside those functions should be changed to a require statement since the check is not an invariant and gas refund should take place if the check fails ([SWC-110](https://swcregistry.io/docs/SWC-110)).  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps The `available_supply` and `_available_supply` functions should be combined into a single public function (public functions can be used internally without any extra gas) or have the public function call the internal implementation and use the private implementation in the contract.  The `assert` check in the `available_supply` function should be changed to a require statement since the check is not an invariant.  
# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details The `InvestorDistribution` ([InvestorDistribution.sol](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol)) contract does contain some statements that could be removed to optimize the gas usage.  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps - Variable set on [Line 77](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L77) can be removed since the implicit value is already zero - On lines 106 and 107 ([here](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L106-L107)), the statement could be changed to a single line containing `delete investors[_investor]`.  
# Handle  PranavG   # Vulnerability details  ## Impact State variables that never change can be declared constant. This can greatly reduce gas costs. Examples : airdrop_supply in AirdropDistribution.sol(#462) investors_supply in InvestorDistribution.sol(#33)  unixYear in Vesting.sol(#30)  ## Recommended Mitigation Steps Add the constant keyword for state variables whose value never change.  
# Handle  PranavG   # Vulnerability details  ## Impact MathUtils.sol has unused import at line #5: import "@openzeppelin/contracts/math/SafeMath.sol"; The import is not used in any way.   ## Recommended Mitigation Steps Remove it to improve readability of the code.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Tokens are locked for 1 day less than specified in spec.  ## Proof of Concept  The vesting period is calculated here in `unixYear`  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L30  This results in a lockup of 364 days rather than the expected 365.  ## Recommended Mitigation Steps  Replace line with `uint256 constant private unixYear = 365 days;`   
# Handle  pants   # Vulnerability details  The function `GaugeController.commit_transfer_ownership()` emits `CommitOwnership` events when the future admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `CommitOwnership` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new future admin is different than the old one.  
# Handle  pants   # Vulnerability details  The function `GaugeController.apply_transfer_ownership()` emits `ApplyOwnership` events when the admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `ApplyOwnership` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new admin is different than the old one.  
# Handle  pants   # Vulnerability details  The function `GaugeController.__init__()` (the constructor) sets the initial admin, but it doesn't emit an appropriate `ApplyOwnership` event.  ## Impact The users won't know who's the initial admin by searching for the first `ApplyOwnership` event, although they should be able to.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit this event.  
# Handle  pants   # Vulnerability details  The function `MainToken.__init__()` (the constructor) sets the initial admin, but it doesn't emit an appropriate `SetAdmin` event.  ## Impact The users won't know who's the initial admin by searching for the first `SetAdmin` event, although they should be able to.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit this event.  
# Handle  pants   # Vulnerability details  The function `LPToken.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  
# Handle  pants   # Vulnerability details  The function `LPToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  
# Handle  pants   # Vulnerability details  The functions `LPToken.transfer()` and `LPToken.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  
# Handle  pants   # Vulnerability details  The function `LPToken.set_minter()` doesn't check that `_minter` doesn't equal zero before it sets it as the new minter.  ## Impact This function can be invoked by mistake with the zero address as `_minter`, causing the system to lose its minter forever, without the option to set a new minter.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Check that `_minter` doesn't equal zero before setting it as the new minter.  
# Handle  pants   # Vulnerability details  The function `LPToken.__init__()` (the constructor) emits `Transfer` events when the amount minted for `msg.sender` is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the amount minted for `msg.sender` is not zero.  
# Handle  pants   # Vulnerability details  The function `MainToken.__init__()` (the constructor) emits `Transfer` events when the amount minted for `msg.sender` is zero. This is always the case, as the value of the constant `INITIAL_SUPPLY` is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the amount minted for `msg.sender` is not zero.  
# Handle  pants   # Vulnerability details  The function `MainToken.set_mint_multisig()` doesn't check that `_minting_multisig` doesn't equal zero before it sets it as the new `minting_multisig`.  ## Impact This function can be invoked by mistake with the zero address as `_minting_multisig`, causing the system to lose its `minting_multisig` forever, without the option to set a new `minting_multisig`.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Check that `_minting_multisig` doesn't equal zero before setting it as the new `minting_multisig`.  
# Handle  pants   # Vulnerability details  The function `MainToken.set_mint_multisig()` emits `SetMintMultisig` events when `minting_multisig` hasn't changed, and left as it was before that transaction.  ## Impact There is no reason to emit these `SetMintMultisig` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new `minting_multisig` is different than the old one.  
# Handle  pants   # Vulnerability details  The function `MainToken.set_admin()` emits `SetAdmin` events when the admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `SetAdmin` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new admin is different than the old one.  
# Handle  pants   # Vulnerability details  The function `MainToken.set_minter()` emits `SetMinter` events when the minter hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `SetMinter` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new minter is different than the old one.  
# Handle  pants   # Vulnerability details  The function `MainToken.burn()` emits `Transfer` events when the burned amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the burned amount is not zero.  
# Handle  pants   # Vulnerability details  The functions `MainToken.mint()` and `MainToken.mint_dev()` emit `Transfer` events when the minted amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the minted amount is not zero.  
# Handle  pants   # Vulnerability details  The function `MainToken.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  
# Handle  pants   # Vulnerability details  The function `MainToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  
# Handle  pants   # Vulnerability details  The functions `MainToken.transfer()` and `MainToken.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  
# Handle  pants   # Vulnerability details  The function `PoolGauge.withdraw()` emits `Withdraw` events when the withdrawn amount is zero.  ## Impact There is no reason to emit these `Withdraw` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the withdrawn amount is not zero.  
# Handle  pants   # Vulnerability details  The function `PoolGauge.deposit()` emits `Deposit` events when the deposited amount is zero.  ## Impact There is no reason to emit these `Deposit` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the deposited amount is not zero.  
# Handle  pants   # Vulnerability details  The function `PoolGauge.withdraw()` doesn't have to execute these lines of code when `_value` equals zero: ``` _balance: uint256 = self.balanceOf[msg.sender] - _value _supply: uint256 = self.totalSupply - _value self.balanceOf[msg.sender] = _balance self.totalSupply = _supply  self._update_liquidity_limit(msg.sender, _balance, _supply)  assert ERC20(self.lp_token).transfer(msg.sender, _value) ```  ## Impact There is no reason to execute these lines of code if `_value` equals zero because they won't affect the system. An identical optimization is already implemented in `PoolGauge.deposit()`.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Execute these lines of code only if `_value` doesn't equal zero.  
# Handle  pants   # Vulnerability details  The function `Token.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  
# Handle  pants   # Vulnerability details  The function `Token.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  
# Handle  pants   # Vulnerability details  The functions `Token.transfer()` and `Token.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  
# Handle  pants   # Vulnerability details  The functions `USDPoolDelegator.balances()`, `USDPoolDelegator.coins()` and `USDPoolDelegator.underlying_coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` / `_underlying_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceeds the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` / `_underlying_coins` array bounds.  
# Handle  pants   # Vulnerability details  The functions `ETHPoolDelegator.balances()` and `ETHPoolDelegator.coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceeds the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` array bounds.  
# Handle  pants   # Vulnerability details  The functions `BTCPoolDelegator.balances()` and `BTCPoolDelegator.coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` array bounds.  
# Handle  defsec   # Vulnerability details  ## Impact  The current ownership transfer process involves the current owner calling Swap.transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier.  ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L30" 2. The contract has many onlyOwner function. 3. The contract is inherited from the Ownable which includes transferOwnership.  ## Tools Used  None  ## Recommended Mitigation Steps  Implement zero address check and Consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.  
# Handle  Reigada   # Vulnerability details  ## Impact The if statement in _updateEmission() can be removed as the condition is already checked in updateEmission() https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L596 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L186  ## Proof of Concept     function _updateEmission() private {         if (block.timestamp >= startEpochTime + RATE_TIME) {             miningEpoch += 1;             startEpochTime = startEpochTime.add(RATE_TIME);             startEpochSupply = startEpochSupply.add(rate.mul(RATE_TIME));              if (miningEpoch < INITIAL_RATE_EPOCH_CUTTOF) {                 rate = rate.mul(EPOCH_INFLATION).div(100000);             }             else {                 rate = 0;             }             emit updateMiningParameters(block.timestamp, rate, startEpochSupply);         }     }      //Update emission to be called at every step change to update emission inflation     function updateEmission() public {         require(block.timestamp >= startEpochTime + RATE_TIME, "Too soon"); // Condition already checked here         _updateEmission();     }  ## Tools Used Manual testing  ## Recommended Mitigation Steps Remove the if condition in the _updateEmission() private function  
# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been seen maxVesting amount is disabled. However, there is no maximum and minimum vesting amount defined. Users can vest small amount. For the protocol liquditiy calculation maximum and minimum threshold should be defined.   ## Proof of Concept  1. Navigate to the following contract.  """ https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L76 """  2. Vesting amount didnt check.  ## Tools Used  Review  ## Recommended Mitigation Steps  It is suggested to check maximum/minimum vesting amount on the contract.   
# Handle  Reigada   # Vulnerability details  ## Impact Multiple calls to transferFrom and transfer are frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of “false” is returned. It’s important to check this. If you don’t, in this concrete case, some airdrop eligible participants could be left without their tokens. It is also a best practice to check this.  ## Proof of Concept AirdropDistributionMock.sol:132:        mainToken.transfer(msg.sender, claimable_to_send); AirdropDistributionMock.sol:157:        mainToken.transfer(msg.sender, claimable_to_send); AirdropDistribution.sol:542:        mainToken.transfer(msg.sender, claimable_to_send); AirdropDistribution.sol:567:        mainToken.transfer(msg.sender, claimable_to_send);  InvestorDistribution.sol:132:        mainToken.transfer(msg.sender, claimable_to_send); InvestorDistribution.sol:156:        mainToken.transfer(msg.sender, claimable_to_send); InvestorDistribution.sol:207:        mainToken.transfer(msg.sender, bal);  Vesting.sol:95:        vestingToken.transferFrom(msg.sender, address(this), _amount);  PublicSale.sol:224:            mainToken.transfer(_member, v_value);   ## Tools Used Manual testing  ## Recommended Mitigation Steps Check the result of transferFrom and transfer. Although if this is done, the contracts will not be compatible with non standard ERC20 tokens like USDT. For that reason, I would rather recommend making use of SafeERC20 library: safeTransfer and safeTransferFrom.  
# Handle  defsec   # Vulnerability details  ## Impact  Using newer compiler versions and the optimizer gives gas optimizations and additional safety checks are available for free.  The advantages of versions 0.8.* over <0.8.0 are:  - Safemath by default from 0.8.0 (can be more gas efficient than library based safemath.) - Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls. - Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs. - Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.    ## Proof of Concept  1. The contest repository contracts contain pragma 0.6.12^. The contracts pragma version should be updated to 0.8.4.  (https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol ) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L3) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/MathUtils.sol#L3) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSale.sol#L2) (https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSaleBatchWithdraw.sol#L2)  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to upgrade pragma to at least 0.8.4.  
# Handle  ye0lde   # Vulnerability details  ## Impact  getEmissionShare Can Be Rewritten To Be More Efficient (PublicSale.sol)  The "else" and returning 0, can be eliminated.  The existing but unused named return variable "value" can be used instead of a return statement. These changes reduce gas and improve code clarity.  ## Proof of Concept  The getEmissionShare function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L231-L245  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>     function getEmissionShare(uint era, uint day, address member) public view returns (uint value) {           uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units                  if (memberUnits != 0) {             uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units             uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];     // Get emission remaining for Day             uint balance = mainToken.balanceOf(address(this));             if (emissionRemaining > balance) {                 emissionRemaining = balance;                                                // In case less than required emission             }             value = (emissionRemaining * memberUnits) / totalUnits;         // Calculate share         }     }    </code>  
# Handle  ye0lde   # Vulnerability details  ## Impact  _processWithdrawal Can Be Rewritten To Be More Efficient (PublicSale.sol)  The "else", the setting of "value to 0", and the return statement can be eliminated to reduce gas and improve code clarity.  ## Proof of Concept  The _processWithdrawal function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L212-L229  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>     function _processWithdrawal (uint _era, uint _day, address _member) private returns (uint value) {           uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member]; // Get Member Units                  if (memberUnits != 0) {             value = getEmissionShare(_era, _day, _member);          // Get the emission Share for Member             mapEraDay_MemberUnits[_era][_day][_member] = 0;  // Set to 0 since it will be withdrawn             mapEraDay_UnitsRemaining[_era][_day] = mapEraDay_UnitsRemaining[_era][_day].sub(memberUnits);  // Decrement Member Units             mapEraDay_EmissionRemaining[_era][_day] = mapEraDay_EmissionRemaining[_era][_day].sub(value);  // Decrement emission             totalEmitted += value;                                                 // Add to Total Emitted             uint256 v_value = value * 3 / 10;                                 // Transfer 30%, lock the rest in vesting contract                          mainToken.transfer(_member, v_value);                      // ERC20 transfer function             vestLock.vest(_member, value - v_value, 0);             emit Withdrawal(msg.sender, _member, _era, _day, value, mapEraDay_EmissionRemaining[_era][_day]);         }     } </code>  
# Handle  ye0lde   # Vulnerability details  ## Impact  The "else if", the second call to _processWithdrawal, and the return statement can be eliminated to reduce gas and improve code clarity.  ## Proof of Concept  The _withdrawShare function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L201-L210  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>  function _withdrawShare (uint _era, uint _day, address _member) private returns (uint value) {  _updateEmission();    if (_era < currentEra ||                                                          // Allow if in previous Era                                                                          (_era == currentEra && _day < currentDay)) {                // or current Era and previous day    value = _processWithdrawal(_era, _day, _member);   // Process Withdrawal      }   } </code>  
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L187 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L194 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L231  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named returns  
# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L149-L150 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/SwapUtils.sol#L1625 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/SwapUtils.sol#L1679  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L105 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L194-L197  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L152 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L162  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.    
# Handle  ye0lde   # Vulnerability details  ## Impact  The "else if(_isRevocable == 1)" is not needed and can be removed to save gas and improve code clarity.  ## Proof of Concept  The "_isRevocable" variable is guaranteed to be 0 or 1 here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L77  But it is treated like it can have some other value here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L83-L88  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Rewrite these lines https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L83-L88 to <code>  benRevocable[_beneficiary] = (_isRevocable == 0) ? [false,false] : [true,false]; </code>  
# Handle  pants   # Vulnerability details  Since no contract inherent from SwapUtils all internal functions could be set private. For example  getD could be set private to save gas.  
# Handle  pants   # Vulnerability details  optimizing for loops by caching memory array length, instead of calling it every time.  For example at Swap.sol at time 158 you should have  uint8 len = _pooledTokens.length and in the next line define the forloop with stop condition of  i<len  This appears in many places in the code. At some places you did cached the array length correctly.   
# Handle  pants   # Vulnerability details  When double reading a variable from memory the gas efficient way is to cache it and use the cached value.   For example in line 537, 538 of SwapUtils.sol you have two accesses to xp[i]. You can save xp[i] as local variable and then use it instead at the second time.  
# Handle  pants   # Vulnerability details  An admin can (by mistake maybe) addInvestor with address that already exists. This way its funds are locked in the system and cannot be withdrawn, even by the admin.    
# Handle  pants   # Vulnerability details  In InvestorDistribution line 103 you read investors[_investor] multiple times (only at this function investors[_investor] is read 6 times). You could cache the value and call the cached value instead. Investors x = investors[_investor]; And then use x.amount, x.claimed, etc.  
# Handle  pants   # Vulnerability details  In InvestorDistribution you generally use uint256 for every quantity, although 256 bits are much more than necessary. For example for Investor structure you can change all to uint128, and for every normal use it will not affect and save gas.  
# Handle  pants   # Vulnerability details  In InvestorDistribution at line 19 you have      using SafeMath for uint256;  although you use solidity >0.8.0 therefore you don't need to use safeMath for uint256  
# Handle  tqts   # Vulnerability details  ## Impact Several references to storage can be cached to save significant amounts of gas.  ## Proof of Concept File lines are stated in Mitigation Steps.  ## Tools Used Manual review   ## Recommended Mitigation Steps  #### In function calculateWithdrawOneTokenDY (L406) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, so one SLOAD is saved.  #### In function _calculateRemoveLiquidity (L953) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, one of those as condition in a for loop, so at least _pooledTokensLength SLOADS are saved.  #### In function _feePerToken (L1080) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, so one SLOAD is saved.  #### In function swap (L1098) ``` IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom]; ``` The value is used 4 times, so 3 SLOADs are saved. However, this causes a stack too deep error in line 1129. To mitigate this, replace lines 1129-1132 for: ``` uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);         dyAdminFee = dyAdminFee.div(self.tokenPrecisionMultipliers[tokenIndexTo]); ```  #### In function addLiquidity (L1163) ``` uint256 _pooledTokensLength = self.pooledTokens.length; uint256 _lpTokenTotalSupply = self.lpToken.totalSupply(); ``` _pooledTokensLength is used 4 times. 3 SLOADs saved. _lpTokenTotalSupply is used 6 times, however the one in line 1266 is called after a mint() so it's not the same value and thus can't be replaced. 4 SLOADs saved.  #### In function _updateUserWithdrawFee (L1290) ``` uint256 _withdrawFee = self.defaultWithdrawFee; ``` The value is used 3 times, so 2 SLOADs are saved.  #### In function removeLiquidityImbalance (L1415) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used 5 times, twice as a for condition, so at least 2 + _pooledTokensLength SLOADs are saved.  
# Handle  jah   # Vulnerability details  ## Impact  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). If you explicitly initialize it with its default value, you are just wasting gas. ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L77 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L77 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L66  https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6  ## Tools Used Manual analysis  ## Recommended Mitigation Steps  
# Handle  tqts   # Vulnerability details  ## Impact According to the comment in line 148 of Swap.sol, the function checks for _pooledTokens and precisions parameters, however, the require at line 151 is redundant, as it will pass if both previous checks passed.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L151  ## Tools Used  ## Recommended Mitigation Steps Remove the require, or change it to validate the correct precision parameters.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs + risk of accidental changes to values expected to be fixed.  ## Proof of Concept  Several contracts contain variables which are set at deploy time and never changed again. For example see `PublicSale.sol`  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L70-L81  Since solidity 0.6.5, variables can be marked `immutable` which avoids the need for SLOADs when reading these variables - decreasing gas costs and protecting against accidentally modifying these variables.  https://blog.soliditylang.org/2020/05/13/immutable-keyword/#:~:text=With%20version%200.6.,time%20of%20a%20deployed%20contract.  ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  Inspect all contracts for variables which are set once and then never modified, apply `immutable` keyword and adjust constructors to not read these values (instead use passed parameters)  
