See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-looksrare-findings/blob/main/data/adriro-Q.md).
# Lines of code  https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/lowLevelCallers/LowLevelETH.sol#L35 https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/lowLevelCallers/LowLevelETH.sol#L46 https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/lowLevelCallers/LowLevelETH.sol#L57   # Vulnerability details  ## Impact The `call` opcode's return value not checked, which could leads to the `originator` lose funds.  ## Proof of Concept The caller of `LooksRareAggregator.sol::execute` could be a contract who may not implement the `fallback` or `receive` function, when a call to it with value sent, it will revert, thus failed to receive the ETH.  Let's imagine the contract call the `execute` function to buy multiple NFTs with ETH as the payout currency and make the `isAtomic` parameter being false. Since the batch buy of NFTs is not atomic, the failed transactions in LooksRare or Seaport marketplace will return the passed ETH. The contract doesn't implement the `fallback/receive` function and the call opcode's return value not checked, thus the ETH value will be trapped in the `LooksRareAggregator` contract until the next user call the `execute` function and the trapped ETH is returned to him. The `originator` lose funds.  ```solidity     function _returnETHIfAny(address recipient) internal {         assembly {             if gt(selfbalance(), 0) {                 let status := call(gas(), recipient, selfbalance(), 0, 0, 0, 0) // @audit-issue status not checked.             }         }     } ```   ## Tools Used Manual review  ## Recommended Mitigation Steps  check the return value the `call` opcode. ```solidity     function _returnETHIfAny() internal {         bool status;         assembly {             if gt(selfbalance(), 0) {                 status := call(gas(), caller(), selfbalance(), 0, 0, 0, 0) // @audit-issue [MED] status not checked             }         }         if (!status) revert ETHTransferFail();     }      function _returnETHIfAny(address recipient) internal {         bool status;         assembly {             if gt(selfbalance(), 0) {                 status := call(gas(), recipient, selfbalance(), 0, 0, 0, 0) // @audit-issue status not checked.             }         }         if (!status) revert ETHTransferFail();     } function _returnETHIfAnyWithOneWeiLeft() internal {         bool status;         assembly {             if gt(selfbalance(), 1) {                 status := call(gas(), caller(), sub(selfbalance(), 1), 0, 0, 0, 0)             }         }         if (!status) revert ETHTransferFail();     } ```  
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-looksrare-findings/blob/main/data/a12jmx-Q.md).
# Lines of code  https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L136-L164 https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L232-L252   # Vulnerability details  ## Impact The `order.price` in the parameter `tradeData` is not used as the actual token amount sent to the seaport market and also not checked if those are equal when using the `ERC20EnabledLooksRareAggregator` for `SeaportPorxy` with ERC20 tokens.  So users can set the order.price to ZERO to avoid paying any fees for ERC20 orders.  ## Proof of Concept Test file SeaportUSDCZeroPrice.t.sol, modified from test SeaportProxyERC721USDC.t.sol and annotate with `# diff`. ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.17;  import {IERC20} from "../../contracts/interfaces/IERC20.sol"; import {IERC721} from "../../contracts/interfaces/IERC721.sol"; import {OwnableTwoSteps} from "../../contracts/OwnableTwoSteps.sol"; import {SeaportProxy} from "../../contracts/proxies/SeaportProxy.sol"; import {ERC20EnabledLooksRareAggregator} from "../../contracts/ERC20EnabledLooksRareAggregator.sol"; import {LooksRareAggregator} from "../../contracts/LooksRareAggregator.sol"; import {IProxy} from "../../contracts/interfaces/IProxy.sol"; import {ILooksRareAggregator} from "../../contracts/interfaces/ILooksRareAggregator.sol"; import {BasicOrder, FeeData, TokenTransfer} from "../../contracts/libraries/OrderStructs.sol"; import {TestHelpers} from "./TestHelpers.sol"; import {TestParameters} from "./TestParameters.sol"; import {SeaportProxyTestHelpers} from "./SeaportProxyTestHelpers.sol";  /**  * @notice SeaportProxy ERC721 USDC orders with fees tests  */ contract SeaportUSDCZeroPrice is TestParameters, TestHelpers, SeaportProxyTestHelpers {     LooksRareAggregator private aggregator;     ERC20EnabledLooksRareAggregator private erc20EnabledAggregator;     SeaportProxy private seaportProxy;      function setUp() public {         vm.createSelectFork(vm.rpcUrl("mainnet"), 15_491_323);          aggregator = new LooksRareAggregator();         erc20EnabledAggregator = new ERC20EnabledLooksRareAggregator(address(aggregator));         seaportProxy = new SeaportProxy(SEAPORT, address(aggregator));         aggregator.addFunction(address(seaportProxy), SeaportProxy.execute.selector);          deal(USDC, _buyer, INITIAL_USDC_BALANCE);          aggregator.approve(SEAPORT, USDC, type(uint256).max);         aggregator.setFee(address(seaportProxy), 250, _protocolFeeRecipient);         aggregator.setERC20EnabledLooksRareAggregator(address(erc20EnabledAggregator));     }      function testExecuteWithPriceZero() public asPrankedUser(_buyer) {         bool isAtomic = true;         ILooksRareAggregator.TradeData[] memory tradeData = _generateTradeData();         uint256 totalPrice =          // diff         // not pay the fee for order 0 , so cut 250 bp from total price         (tradeData[0].orders[0].price * (10250 - 250)) /         // diff end             10000 +             (tradeData[0].orders[1].price * 10250) /             10000;         IERC20(USDC).approve(address(erc20EnabledAggregator), totalPrice);         // diff         // set order 0 price to ZERO         tradeData[0].orders[0].price = 0;         // diff end          TokenTransfer[] memory tokenTransfers = new TokenTransfer[](1);         tokenTransfers[0].currency = USDC;         tokenTransfers[0].amount = totalPrice;          erc20EnabledAggregator.execute(tokenTransfers, tradeData, _buyer, isAtomic);          assertEq(IERC721(BAYC).balanceOf(_buyer), 2);         assertEq(IERC721(BAYC).ownerOf(9948), _buyer);         assertEq(IERC721(BAYC).ownerOf(8350), _buyer);         assertEq(IERC20(USDC).balanceOf(_buyer), INITIAL_USDC_BALANCE - totalPrice);     }      function _generateTradeData() private view returns (ILooksRareAggregator.TradeData[] memory) {         BasicOrder memory orderOne = validBAYCId9948Order();         BasicOrder memory orderTwo = validBAYCId8350Order();         BasicOrder[] memory orders = new BasicOrder[](2);         orders[0] = orderOne;         orders[1] = orderTwo;          bytes[] memory ordersExtraData = new bytes[](2);         {             bytes memory orderOneExtraData = validBAYCId9948OrderExtraData();             bytes memory orderTwoExtraData = validBAYCId8350OrderExtraData();             ordersExtraData[0] = orderOneExtraData;             ordersExtraData[1] = orderTwoExtraData;         }          bytes memory extraData = validMultipleItemsSameCollectionExtraData();         ILooksRareAggregator.TradeData[] memory tradeData = new ILooksRareAggregator.TradeData[](1);         tradeData[0] = ILooksRareAggregator.TradeData({             proxy: address(seaportProxy),             selector: SeaportProxy.execute.selector,             value: 0,             maxFeeBp: 250,             orders: orders,             ordersExtraData: ordersExtraData,             extraData: extraData         });          return tradeData;     } }  ``` run test: ``` forge test --match-test testExecuteWithPriceZero -vvvvv ```  ## Tools Used foundry  ## Recommended Mitigation Steps Assert the order price is equal to the token amount of the seaport order when populating parameters.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-looksrare-findings/blob/main/data/datapunk-G.md).
# Lines of code  https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/OwnableTwoSteps.sol#L11   # Vulnerability details  ## Impact  It is stated in the documents that "contract ownership management" is used with a timelock;  ```js README.md:   122: - Does it use a timelock function?: Yes but only for contract ownership management and not business critical functions. ```  However, the `function _setupDelayForRenouncingOwnership` where timelock is specified in the `OwnableTwoSteps.sol` contract where `owner` privileges are set is not used in the project, so a timelock cannot be mentioned.  ```solidity  function _setupDelayForRenouncingOwnership(uint256 _delay) internal {         delay = _delay;     } ```   This is stated in the NatSpec comments but there is no definition as stated in the comments;  ```solidity contracts/OwnableTwoSteps.sol:   40:      *         Delay (for the timelock) must be set by the contract that inherits from this.  ```   ## Tools Used Manuel Code Review   ## Recommended Mitigation Steps  ```diff  contracts/OwnableTwoSteps.sol:      // Delay for the timelock (in seconds)     uint256 public delay;    43       */   44:     constructor(uint256 _delay) {   45:         owner = msg.sender;   +           delay = _delay;   46:     }   47:    48      /**    ```  
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-looksrare-findings/blob/main/data/aviggiano-G.md).
# Lines of code  https://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/proxies/SeaportProxy.sol#L136-L147   # Vulnerability details  ## Impact When a user fulfills an order using SeaportProxy, fees are charged in the _handleFees function based on orders.price. ```solidity     function _handleFees(         BasicOrder[] calldata orders,         uint256 feeBp,         address feeRecipient     ) private {         address lastOrderCurrency;         uint256 fee;         uint256 ordersLength = orders.length;          for (uint256 i; i < ordersLength; ) {             address currency = orders[i].currency;             uint256 orderFee = (orders[i].price * feeBp) / 10000; ``` According to the Seaport documentation, Seaport allows partial fulfillment of orders, which results in too much fee being charged when an order is partially filled https://docs.opensea.io/v2.0/reference/seaport-overview#partial-fills  Consider feeBp == 2% The order on Seaport has a fill status of 0/100 and each item is worth 1 eth. User A fulfills the order using LooksRareAggregator.execute and sends 102 ETH, where order.price == 100 ETH. Since the other user fulfilled the order before User A, when User A fulfills the order, the order status is 99/100 Eventually User A buys an item for 1 ETH but pays a fee of 2 ETH. ## Proof of Concept https://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/proxies/SeaportProxy.sol#L136-L147  ## Tools Used None ## Recommended Mitigation Steps Consider charging fees based on the user's actual filled price
