# Handle  moose-code   # Vulnerability details  ## Impact Users have essentially have an option to either claim currently earned reward amounts on future rewards tokens, or the current rewards token.   Although stated on line 84, it does not take into account the implications and lock in this contract will have on the future value of new tokens able to be issued via rewards.   ## Proof of Concept Smart users will monitor the mempool for setRewards transactions. If the new reward token (token b) is less valuable than the old reward token (token a), they front run this transaction by calling claim. Otherwise they let their accrued 'token a' roll into rewards of of the more valuable 'token b'.  Given loads of users will likely hold these tokens from day 1, there will potentially be thousands of different addresses squatting on rewards.   Economically, given the above it makes sense that the value of new reward tokens, i.e. 'token b' should always be less than that of 'token a'. This is undesirable in a rewards token contract as there is no reliable way to start issuing a more valuable token at a later stage, unless exposing yourself to a major risk of reward squatting.  i.e. You could not in future say we want to run a rewards period of of issuing an asset like WETH rewards for 10 days, after first initially issuing DAI as a reward. This hamstrings flexibility of the contract.  P.s. This is one of the slickest contracts I've read. Love how awesome it is.Just believe this should be fixed, then its good to go.   ## Tools Used Manual analysis  ## Recommended Mitigation Steps It is true you could probably write a script to manually go call 'claim' on thousands of squatting token addresses but this is a poor solution.   A simple mapping pattern could be used with an index mapping to a reward cycle with a reward token and a new accumulative etc. Users would likely need to be given a period a to claim from old reward cycles before their token balance could no longer reliably used to calculate past rewards. The would still be able to claim everything up until their last action (even though this may be before the rewards cycle ended).  
# Handle  hickuphh3   # Vulnerability details  ### Impact  As per the [solidity documentation](https://docs.soliditylang.org/en/v0.8.1/abi-spec.html?highlight=events#events):  However, for all “complex” types or types of dynamic length, including all arrays, string, bytes and structs, EVENT_INDEXED_ARGS will contain the Keccak hash of a special in-place encoded value (see Encoding of Indexed Event Parameters), rather than the encoded value directly.  It therefore might not be useful to index `address[] targets` in `Timelock.sol` and `address[] contacts` in `EmergencyBrake.sol`, since it's the keccak hash of the addresses. [Also saves gas to drop the indexed keyword](https://ethereum.stackexchange.com/questions/56486/does-it-make-a-difference-to-index-an-event-with-one-parameter/56491).  ### Recommended Mitigation Steps  Remove the `indexed` keyword for the arguments mentioned above.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  As brought up in a [previous audit issue](https://github.com/code-423n4/2021-05-yield-findings/issues/4), "the suggestion of changing all public auth functions to external auth will be applied". The same should therefore be done for the new contracts `Strategy.sol` and `ERC20Rewards.sol`, since all public methods in it aren't called internally.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `uint128` output by `_updateRewardsPerToken()` isn't used by any function. Furthermore, L107 returns a wrong value.  `if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod.start) return 0;`  It should return `rewardsPerToken_.accumulated` instead, because in the case of a new rewards schedule being set, `rewardsPeriod.start` is updated to a new timestamp. Hence, the current accumulated value of all previous reward schedules thus far should be returned.  ### Recommended Mitigation Steps  Since the return value isn't used anywhere, remove it.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `latest()` function is unused and can be removed.  ### Recommended Mitigation Steps  Remove L68-L71  
# Handle  hickuphh3   # Vulnerability details  ### Impact  This would be equivalent to [Unipool's `rewardPerToken()` function](https://github.com/k06a/Unipool/blob/master/contracts/Unipool.sol#L69). Note that `rewardsPerToken.accumulated` only reflects the latest stored accumulated value, but does not account for pending accumulation like Unipool, and is therefore not the same. It possibly might be mistaken to be so, hence the low risk classification.  ### Recommended Mitigation Steps  A possible implementation is given below.  ```jsx function latestRewardPerToken() external view returns (uint256) {  RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;  if (_totalSupply == 0) return rewardsPerToken_.accumulated;  uint32 end = earliest(block.timestamp.u32(), rewardsPeriod.end);  uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated;  return rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply; } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  While it might seem like a good feature to have, being able to switch reward tokens will only be useful for tokens which are equivalent in value (probably stablecoins, pegged tokens) since it carries over unclaimed rewards from the previous reward program. It would be safer to keep the reward token immutable as a safeguard against violations of this condition.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level call returns success even if the contract is non-existent. This requires a contract existence check before making the low-level call.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L93  See: “The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.” from https://docs.soliditylang.org/en/v0.8.7/control-structures.html#error-handling-assert-require-revert-and-exceptions  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for target contract existence before call.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  That cauldron_ parameter is not used here and ladle_.cauldron() is used instead. The Ladle constructor initializes its cauldron value and so the only way this could differ from the parameter is if the argument to this function is specified incorrectly.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L100  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L106-L107  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/Ladle.sol#L33   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Either use parameter or remove it in favor of the value from ladle_.cauldron().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Few events are missing emits which prevents the intended data from being observed easily by off-chain interfaces.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L48-L49  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add emits or remove event declarations.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  solc version 0.8.3 and 0.8.4 fixed important bugs in the compiler. Using version 0.8.1 misses these fixes and may cause a vulnerability.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L2  https://github.com/ethereum/solidity/releases/tag/v0.8.4: Solidity 0.8.4 fixes a bug in the ABI decoder. The release contains an important bugfix. See decoding from memory bug blog post for more details.  https://github.com/ethereum/solidity/releases/tag/v0.8.3: Solidity 0.8.3 is a bugfix release that fixes an important bug about how the optimizer handles the Keccak256 opcode. For details on the bug, please see the bug blog post.   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider upgrading to 0.8.3 or 0.8.4  
# Handle  0xRajeev   # Vulnerability details  ## Impact  setRewards() is missing input validation on parameters start and end to check if end > start. If accidentally set incorrectly, this will allow resetting new rewards while there is an ongoing one.   ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L88  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a require() to check that end > start.  
# Handle  0xRajeev   # Vulnerability details  ## Impact The check for array lengths is unnecessary in two places where the following check on txHash will anyway fail if the lengths don’t match with what was hashed earlier during schedule. Removing the length check can save a little gas.  Such a require() in cancel() can be removed because if there is a mismatch, the entry lookup in transactions[] will fail anyway and also, this will not be sceduled/executed.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L70-L72  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L81-L85   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate and remove these checks.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The require check for decimals_ <= 18 is unnecessary given its set to 18 right above unless this needs to be obtained differently as hinted by the comment.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/compound/CTokenMultiOracle.sol#L110-L111  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate check and remove.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  As noted in the code comment, peek and get functions are the same for this oracle. So we can change `peek` to public visibility and have `get` call `peek` instead of copying the same code here. Minor deployment cost savings but increase in readability/maintainability.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/composite/CompositeMultiOracle.sol#L91  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/composite/CompositeMultiOracle.sol#L74-L128  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace two functions having the same code with a single function.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function parameters are passed in calldata. For external functions, these are simply read from calldata. But explicitly specifying memory location for such parameters will force their copying to memory resulting in extra bytecode and more gas. Leaving them in calldata will save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L45-L46  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L66-L67  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L77-L78  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L101-L102  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L116-L117  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/FYTokenFactory.sol#L21-L22  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Do not use memory data location specifier for external function parameters  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Event emits where there are equivalent local variables or parameters for state variables can save gas by using those instead of state variables because of the expensive SLOADs.  ## Proof of Concept  rewardsToken: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L97  delay: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L51   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use parameters or local variables instead of state variables in event emits  
# Handle  0xRajeev   # Vulnerability details  ## Impact  SLOADs cost 2100 gas for first time reads of state variables and then 100 gas for repeated reads in the context of a transaction (post Berlin fork). MLOADs cost 3 gas units. Therefore, caching state variable in local variables for repeated reads saves gas.  ## Proof of Concept  Examples of state variables that are read at the lines shown and also later in that same function:  rewardsPeriod: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L80  _totalSupply: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L107  nextPool: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L163  ladle: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L172  base: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L180  pool (600 gas savings): https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L183  pool: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L208  cached: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L262   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider caching state variables in local variables.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Public functions need to copy their arguments from calldata to memory resulting in more bytecode and gas consumption. If functions are never called from within the contracts, they can be declared external in which case their parameters are always in calldata without being copied to memory. This results in gas savings. There are many such public functions that don’t appear to be called from within the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L75  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L100-L101  All functions declared in this range: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L127-L252  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility from public to external  
# Handle  shw   # Vulnerability details  ## Impact  The `_updateRewardsPerToken` function of `ERC20Rewards` is called when a token is transferred, minted, or burned. Thus, it could be called multiple times in a single block. Gas optimization is possible by checking if the `end` variable is equal to `rewardsPerToken_.lastUpdated`. If so, the function can return after line 112 since no reward needs to be updated. The early return could avoid writing to the storage (line 117) and thus save gas.  ## Proof of Concept  Referenced code: [ERC20Rewards.sol#L112](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L112) [ERC20Rewards.sol#L117](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L117)  ## Recommended Mitigation Steps  Simply return if `end == rewardsPerToken_.lastUpdated` if the `_updateRewardsPerToken` function.  
# Handle  shw   # Vulnerability details  ## Impact  The `CTokenMultiOracle` contract assumes the exchange rates (borrowing rate) of Compound always have 18 decimals, while, however, which is not true. According to the [Compound documentation](https://compound.finance/docs/ctokens#exchange-rate), the exchange rate returned from the `exchangeRateCurrent` function is scaled by `1 * 10^(18 - 8 + Underlying Token Decimals)` (and so does `exchangeRateStored`). Using a wrong decimal number on the exchange rate could cause incorrect pricing on tokens.  ## Proof of Concept  Referenced code: [CTokenMultiOracle.sol#L110](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/compound/CTokenMultiOracle.sol#L110)  ## Recommended Mitigation Steps  Follow the documentation and get the decimals of the underlying tokens to set the correct decimal of a `Source`.  
# Handle  shw   # Vulnerability details  ## Impact  The `peek` and `get` functions of `CompositeMultiOracle` do not initialize the return variable `updateTime`, which is always 0 since the oldest timestamp is chosen and returned.  ## Proof of Concept  Referenced code: [CompositeMultiOracle.sol#L76](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L76) [CompositeMultiOracle.sol#L96](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L96)  ## Recommended Mitigation Steps  Handle the case when `updateTimeIn` is 0 in the private `_peek` and `_get` functions. If so, simply return `updateTimeOut`.  
# Handle  shw   # Vulnerability details  ## Impact  Tokens not compliant with the ERC20 specification could return `false` from the `transfer` function call to indicate the transfer fails, while the calling contract would not notice the failure if the return value is not checked. Checking the return value is a requirement, as written in the [EIP-20](https://eips.ethereum.org/EIPS/eip-20) specification:  > Callers MUST handle `false` from `returns (bool success)`. Callers MUST NOT assume that `false` is never returned!  ## Proof of Concept  Referenced code: [ERC20Rewards.sol#L175](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L175)  ## Recommended Mitigation Steps  Use the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from OpenZeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.  
# Handle  cmichel   # Vulnerability details  The return value is never used and should be removed to save some gas.  
# Handle  cmichel   # Vulnerability details  `TimeLock.setDelay` reads storage variable for event which produces an `SLOAD`. It should use `emit DelaySet(_delay)` instead of `emit DelaySet(delay)`  
# Handle  cmichel   # Vulnerability details  The `claim` function performs an ERC20 transfer `rewardsToken.transfer(to, claiming);` but does not check the return value, nor does it work with all legacy tokens.  Some tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` function return `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do **not** revert if the transfer failed but return `false` instead.   ## Impact Tokens that don't actually perform the transfer and return `false` are still counted as a correct transfer and tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin’s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.   
# Handle  cmichel   # Vulnerability details  The `setRewards` function allows setting a different token. Holders of a previous reward period cannot all be paid out and will receive **their old reward amount** in the new token.  This leads to issues when the new token is more (less) valuable, or uses different decimals.  **Example:** Assume the first reward period paid out in `DAI` which has 18 decimals. Someone would have received `1.0 DAI = 1e18 DAI` if they called `claim` now. Instead, they wait until the new period starts with `USDC` (using only 6 decimals) and can `claim` their `1e18` reward amount in USDC which would equal `1e12 USDC`, one trillion USD.  ## Impact Changing the reward token only works if old and new tokens use the same decimals and have the exact same value. Otherwise, users that claim too late/early will lose out.  ## Recommended Mitigation Steps Disallow changing the reward token, or clear user's pending rewards of the old token. The second approach requires more code changes and keeping track of what token a user last claimed.  
# Handle  cmichel   # Vulnerability details  The `ERC20Rewards._updateRewardsPerToken` function exits without updating `rewardsPerToken_.lastUpdated` if `totalSupply` is zero, i.e., if there are no tokens initially.  This leads to an error if there is an active rewards period but not tokens have been minted yet.  **Example:** `rewardsPeriod.start: 1 month ago`, `rewardsPeriod.end: in 1 month`, `totalSupply == 0`. The first mint leads to the user (mintee) receiving all rewards for the past period (50% of the total rewards in this case). - `_mint` is called, calls `_updateRewardsPerToken` which short-circuits. `rewardsPerToken.lastUpdated` is still set to `rewardsPeriod.start` from the constructor. Then `_updateUserRewards` is called and does not currently yield any rewards. (because both balance and the index diff are zero). User is now minted the tokens, `totalSupply` increases and user balance is set. - User performs a `claim`: `_updateRewardsPerToken` is called and `timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated = block.timestamp - rewardsPeriod.start = 1 month`. Contract "issues" rewards for the past month. The first mintee receives all of it.  ## Impact The first mintee receives all pending rewards when they should not receive any past rewards. This can easily happen if the token is new, the reward period has already been initialized and is running, but the protocol has not officially launched yet. Note that `setRewards` also allows setting a date in the past which would also be fatal in this case.  ## Recommended Mitigation Steps The `rewardsPerToken_.lastUpdated` field must always be updated in `_updateRewardsPerToken` to the current time (or `end`) even if `_totalSupply == 0`. Don't return early.  
# Handle  cmichel   # Vulnerability details  The `TimeLock.schedule` function reverts if the same `targets` and `data` fields are used as the `txHash` will be the same. This means one cannot schedule the same transactions multiple times.  ## Impact Imagine the delay is set to 30 days, but a contractor needs to be paid every 2 weeks. One needs to wait 30 days before scheduling the second payment to them.  ## Recommended Mitigation Steps Also include `eta` in the hash. (Compound's Timelock does it as well.) This way the same transaction data can be used by specifying a different `eta`.   
# Handle  cmichel   # Vulnerability details  The `Strategy.Divest` event is not fired.  ## Impact Off-chain scripts that rely on this event won't work.  ## Recommended Mitigation Steps Emit this event in `endPool`.  
# Handle  cmichel   # Vulnerability details  The `Strategy.Invest` event is not fired.  ## Impact Off-chain scripts that rely on this event won't work.  ## Recommended Mitigation Steps Emit this event in `startPool`.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Given a configuration of target, contacts and permissions, calling `terminate()` will permanently prevent this configuration from being used again because the state becomes `State.TERMINATED`. All other functions require the configuration to be in the other states (UNKNOWN, PLANNED, or EXECUTED).  In other words, the removal of the restoring option for the configuration through `EmergencyBrake` is permanent.  ### Recommended Mitigation Steps  Since `EmergencyBrake` cannot reinstate permissions after termination, it would be better to have terminate change its state to UNKNOWN. The TERMINATED state can therefore be removed.  
# Handle  PierrickGT   # Vulnerability details  ## Impact In the external functions `setSources` and `setPaths` of `CompositeMultiOracle.sol`, we call `bases.length` three times. This value can be stored in a variable to avoid two sload.  Also, `uint256 i = 0;` can be refactored to `uint256 i;` since `uint256` initializes with a value of `0` by default.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L39-L46  https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L60-L67  ## Recommended Mitigation Steps Store `bases.length` in a variable and declare `i` with the default value: ``` uint256 basesLength = bases.length;  require(     basesLength == quotes.length &&      basesLength == sources_.length,     "Mismatched inputs" );  for (uint256 i; i < basesLength; i++) {     _setSource(bases[i], quotes[i], sources_[i]); } ``` ``` uint256 basesLength = bases.length;  require(     basesLength == quotes.length &&      basesLength == paths_.length,     "Mismatched inputs" );  for (uint256 i; i < basesLength; i++) {     _setPath(bases[i], quotes[i], paths_[i]); } ```  
# Handle  PierrickGT   # Vulnerability details  ## Impact In `CompositeMultiOracle.sol`, internal functions, event, struct, public constant and mapping are not documented.  Functions parameters and return values should also be documented for external functions.  Natspec documentation should also be added to describe what this contract is all about.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L79-L81  https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L97-L99  ## Recommended Mitigation Steps Add natspec documentation to describe the contract and not just his title: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L11-L12  Add natspec documentation for the following code: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L15 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L17-L18 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L20 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L25-L26 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L110 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L120 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L130 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L140  Add natspec documentation for parameters and return value of these functions: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L31 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L38 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L52 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L59 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L74 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L94  
# Handle  PierrickGT   # Vulnerability details  ## Impact In the external function `setSources` of `CTokenMultiOracle.sol`, we call `cTokenIds.length` three times. This value can be stored in a variable to avoid two sload.  Also, `uint256 i = 0;` can be refactored to `uint256 i;` since `uint256` initializes with a value of `0` by default.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L38-L39  https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L42  ## Recommended Mitigation Steps Store `cTokenIds.length` in a variable and declare `i` with the default value: ``` uint256 cTokenIdsLength = cTokenIds.length;  require(     cTokenIdsLength == underlyings.length &&     cTokenIdsLength == cTokens.length,     "Mismatched inputs" );  for (uint256 i; i < cTokenIdsLength; i++) {     _setSource(cTokenIds[i], underlyings[i], cTokens[i]); } ```  
# Handle  PierrickGT   # Vulnerability details  # CTokenMultiOracle.sol - Add natspec documentation  ## Impact In `CTokenMultiOracle.sol`, internal functions, event, struct, public constant and mapping are not documented.  Functions parameters and return values should also be documented for external functions.  Natspec documentation should also be added to describe what this contract is all about.  ## Recommended Mitigation Steps Add natspec documentation to describe the contract: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L11  Add natspec documentation for the following code: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L14 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L16 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L18 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L24 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L73 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L91 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L109  Add natspec documentation for parameters and return value of these functions: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L29 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L36 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L51 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L64   
# Handle  PierrickGT   # Vulnerability details  ## Impact In `FYTokenFactory.sol`, it is possible to avoid one sload by storing `fyToken.ROOT()` in a variable.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/77bc292601ba6cb6d35f9a1cb606f21ed94ad36e/contracts/FYTokenFactory.sol#L37-L38  ## Tools Used Manual analysis  ## Recommended Mitigation Steps ```   bytes4 rootRole = fyToken.ROOT();    fyToken.grantRole(rootRole, msg.sender);   fyToken.renounceRole(rootRole, address(this)); ```  
# Handle  gpersoon   # Vulnerability details  ## Impact The contract Wand defines a few role constants with bytes4(keccak256("...function...")) However if the function template would change slightly, for example when uint128 is replaced by uint256, then this construction isn't valid anymore.  It is safer the use the function selector, as is done in EmergencyBrake.sol  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/main/contracts/Wand.sol#L27      bytes4 public constant JOIN = bytes4(keccak256("join(address,uint128)"));     bytes4 public constant EXIT = bytes4(keccak256("exit(address,uint128)"));     bytes4 public constant MINT = bytes4(keccak256("mint(address,uint256)"));     bytes4 public constant BURN = bytes4(keccak256("burn(address,uint256)"));  https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/EmergencyBrake.sol#L35   _grantRole(IEmergencyBrake.plan.selector, planner);  ## Tools Used  ## Recommended Mitigation Steps Use function selectors in Wand.sol   
# Handle  gpersoon   # Vulnerability details  ## Impact In function get of CompositeMultiOracle the updateTime is not initialized, so it will be 0  Function _get has the following statement:    updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;      updateTimeIn ==0 ==>  (updateTimeOut < updateTimeIn)== false ==> result of the expression is updateTimeIn == 0 ==> updateTimeOut =0  So this means the function get will always return updateTime==0  The updateTime result of the function get doesn't seem to be used in the code so the risk is low. If would only be relevant for future code updates.   ## Proof of Concept //https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L94  function get(bytes32 base, bytes32 quote, uint256 amount)  external virtual override  returns (uint256 value, uint256 updateTime)  { ...         for (uint256 p = 0; p < path.length; p++) {             (price, updateTime) = _get(base_, path[p], price, updateTime);  function _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)  private returns (uint priceOut, uint updateTimeOut) {     ...         (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals);    // Get price for one unit       ...         updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time     }  ## Tools Used  ## Recommended Mitigation Steps In function get, add the following in the beginning of the function: updateTime = block.timestamp;  
# Handle  gpersoon   # Vulnerability details  ## Impact The functions schedule and cancel of TimeLock.sol receive the parameters targets and data. This is not absolutely necessary. Receiving txHash would be enough, as txHash is verified in the function execute. This is like a commit and reveal scheme. It would save some gas and contract complexity.  This assumes that the parameters  targets and data are accessible offchain for verification, which I would think would be true anyway.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps You can use the following approach if you want to save some gas. Note: the parameters targets and data won't be available onchain in events (at least until execute has been performed)   function schedule(bytes32 txHash, uint256 eta) external override auth {         require(eta >= block.timestamp + delay, "Must satisfy delay."); // This also prevents setting eta = 0 and messing up the state                 require(transactions[txHash] == 0, "Transaction not unknown.");         transactions[txHash] = eta;                ....     }      function cancel(bytes32 txHash) external override auth {         require(transactions[txHash] != 0, "Transaction hasn't been scheduled.");         delete transactions[txHash];        ....     }  
# Handle  gpersoon   # Vulnerability details  ## Impact TimeLock.sol contains a comment with a double negative, which is confusing to read: Transaction not unknown.  ## Proof of Concept //https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/TimeLock.sol#L55  function schedule(address[] calldata targets, bytes[] calldata data, uint256 eta)   external override auth returns (bytes32 txHash)  { ..         require(transactions[txHash] == 0, "Transaction not unknown.");  ## Tools Used  ## Recommended Mitigation Steps Replace: Transaction not unknown. with: Transaction already scheduled.  
# Handle  moose-code   # Vulnerability details  ## Impact Users have essentially have an option to either claim currently earned reward amounts on future rewards tokens, or the current rewards token.   Although stated on line 84, it does not take into account the implications and lock in this contract will have on the future value of new tokens able to be issued via rewards.   ## Proof of Concept Smart users will monitor the mempool for setRewards transactions. If the new reward token (token b) is less valuable than the old reward token (token a), they front run this transaction by calling claim. Otherwise they let their accrued 'token a' roll into rewards of of the more valuable 'token b'.  Given loads of users will likely hold these tokens from day 1, there will potentially be thousands of different addresses squatting on rewards.   Economically, given the above it makes sense that the value of new reward tokens, i.e. 'token b' should always be less than that of 'token a'. This is undesirable in a rewards token contract as there is no reliable way to start issuing a more valuable token at a later stage, unless exposing yourself to a major risk of reward squatting.  i.e. You could not in future say we want to run a rewards period of of issuing an asset like WETH rewards for 10 days, after first initially issuing DAI as a reward. This hamstrings flexibility of the contract.  P.s. This is one of the slickest contracts I've read. Love how awesome it is.Just believe this should be fixed, then its good to go.   ## Tools Used Manual analysis  ## Recommended Mitigation Steps It is true you could probably write a script to manually go call 'claim' on thousands of squatting token addresses but this is a poor solution.   A simple mapping pattern could be used with an index mapping to a reward cycle with a reward token and a new accumulative etc. Users would likely need to be given a period a to claim from old reward cycles before their token balance could no longer reliably used to calculate past rewards. The would still be able to claim everything up until their last action (even though this may be before the rewards cycle ended).  
# Handle  hickuphh3   # Vulnerability details  ### Impact  As per the [solidity documentation](https://docs.soliditylang.org/en/v0.8.1/abi-spec.html?highlight=events#events):  However, for all “complex” types or types of dynamic length, including all arrays, string, bytes and structs, EVENT_INDEXED_ARGS will contain the Keccak hash of a special in-place encoded value (see Encoding of Indexed Event Parameters), rather than the encoded value directly.  It therefore might not be useful to index `address[] targets` in `Timelock.sol` and `address[] contacts` in `EmergencyBrake.sol`, since it's the keccak hash of the addresses. [Also saves gas to drop the indexed keyword](https://ethereum.stackexchange.com/questions/56486/does-it-make-a-difference-to-index-an-event-with-one-parameter/56491).  ### Recommended Mitigation Steps  Remove the `indexed` keyword for the arguments mentioned above.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  As brought up in a [previous audit issue](https://github.com/code-423n4/2021-05-yield-findings/issues/4), "the suggestion of changing all public auth functions to external auth will be applied". The same should therefore be done for the new contracts `Strategy.sol` and `ERC20Rewards.sol`, since all public methods in it aren't called internally.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `uint128` output by `_updateRewardsPerToken()` isn't used by any function. Furthermore, L107 returns a wrong value.  `if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod.start) return 0;`  It should return `rewardsPerToken_.accumulated` instead, because in the case of a new rewards schedule being set, `rewardsPeriod.start` is updated to a new timestamp. Hence, the current accumulated value of all previous reward schedules thus far should be returned.  ### Recommended Mitigation Steps  Since the return value isn't used anywhere, remove it.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `latest()` function is unused and can be removed.  ### Recommended Mitigation Steps  Remove L68-L71  
# Handle  hickuphh3   # Vulnerability details  ### Impact  This would be equivalent to [Unipool's `rewardPerToken()` function](https://github.com/k06a/Unipool/blob/master/contracts/Unipool.sol#L69). Note that `rewardsPerToken.accumulated` only reflects the latest stored accumulated value, but does not account for pending accumulation like Unipool, and is therefore not the same. It possibly might be mistaken to be so, hence the low risk classification.  ### Recommended Mitigation Steps  A possible implementation is given below.  ```jsx function latestRewardPerToken() external view returns (uint256) {  RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;  if (_totalSupply == 0) return rewardsPerToken_.accumulated;  uint32 end = earliest(block.timestamp.u32(), rewardsPeriod.end);  uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated;  return rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply; } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  While it might seem like a good feature to have, being able to switch reward tokens will only be useful for tokens which are equivalent in value (probably stablecoins, pegged tokens) since it carries over unclaimed rewards from the previous reward program. It would be safer to keep the reward token immutable as a safeguard against violations of this condition.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level call returns success even if the contract is non-existent. This requires a contract existence check before making the low-level call.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L93  See: “The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.” from https://docs.soliditylang.org/en/v0.8.7/control-structures.html#error-handling-assert-require-revert-and-exceptions  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for target contract existence before call.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  That cauldron_ parameter is not used here and ladle_.cauldron() is used instead. The Ladle constructor initializes its cauldron value and so the only way this could differ from the parameter is if the argument to this function is specified incorrectly.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L100  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L106-L107  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/Ladle.sol#L33   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Either use parameter or remove it in favor of the value from ladle_.cauldron().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Few events are missing emits which prevents the intended data from being observed easily by off-chain interfaces.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L48-L49  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add emits or remove event declarations.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  solc version 0.8.3 and 0.8.4 fixed important bugs in the compiler. Using version 0.8.1 misses these fixes and may cause a vulnerability.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L2  https://github.com/ethereum/solidity/releases/tag/v0.8.4: Solidity 0.8.4 fixes a bug in the ABI decoder. The release contains an important bugfix. See decoding from memory bug blog post for more details.  https://github.com/ethereum/solidity/releases/tag/v0.8.3: Solidity 0.8.3 is a bugfix release that fixes an important bug about how the optimizer handles the Keccak256 opcode. For details on the bug, please see the bug blog post.   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider upgrading to 0.8.3 or 0.8.4  
# Handle  0xRajeev   # Vulnerability details  ## Impact  setRewards() is missing input validation on parameters start and end to check if end > start. If accidentally set incorrectly, this will allow resetting new rewards while there is an ongoing one.   ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L88  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a require() to check that end > start.  
# Handle  0xRajeev   # Vulnerability details  ## Impact The check for array lengths is unnecessary in two places where the following check on txHash will anyway fail if the lengths don’t match with what was hashed earlier during schedule. Removing the length check can save a little gas.  Such a require() in cancel() can be removed because if there is a mismatch, the entry lookup in transactions[] will fail anyway and also, this will not be sceduled/executed.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L70-L72  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L81-L85   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate and remove these checks.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The require check for decimals_ <= 18 is unnecessary given its set to 18 right above unless this needs to be obtained differently as hinted by the comment.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/compound/CTokenMultiOracle.sol#L110-L111  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate check and remove.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  As noted in the code comment, peek and get functions are the same for this oracle. So we can change `peek` to public visibility and have `get` call `peek` instead of copying the same code here. Minor deployment cost savings but increase in readability/maintainability.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/composite/CompositeMultiOracle.sol#L91  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/composite/CompositeMultiOracle.sol#L74-L128  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace two functions having the same code with a single function.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function parameters are passed in calldata. For external functions, these are simply read from calldata. But explicitly specifying memory location for such parameters will force their copying to memory resulting in extra bytecode and more gas. Leaving them in calldata will save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L45-L46  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L66-L67  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L77-L78  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L101-L102  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L116-L117  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/FYTokenFactory.sol#L21-L22  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Do not use memory data location specifier for external function parameters  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Event emits where there are equivalent local variables or parameters for state variables can save gas by using those instead of state variables because of the expensive SLOADs.  ## Proof of Concept  rewardsToken: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L97  delay: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L51   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use parameters or local variables instead of state variables in event emits  
# Handle  0xRajeev   # Vulnerability details  ## Impact  SLOADs cost 2100 gas for first time reads of state variables and then 100 gas for repeated reads in the context of a transaction (post Berlin fork). MLOADs cost 3 gas units. Therefore, caching state variable in local variables for repeated reads saves gas.  ## Proof of Concept  Examples of state variables that are read at the lines shown and also later in that same function:  rewardsPeriod: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L80  _totalSupply: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L107  nextPool: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L163  ladle: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L172  base: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L180  pool (600 gas savings): https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L183  pool: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L208  cached: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L262   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider caching state variables in local variables.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Public functions need to copy their arguments from calldata to memory resulting in more bytecode and gas consumption. If functions are never called from within the contracts, they can be declared external in which case their parameters are always in calldata without being copied to memory. This results in gas savings. There are many such public functions that don’t appear to be called from within the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L75  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L100-L101  All functions declared in this range: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L127-L252  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility from public to external   
# Handle  shw   # Vulnerability details  ## Impact  The `_updateRewardsPerToken` function of `ERC20Rewards` is called when a token is transferred, minted, or burned. Thus, it could be called multiple times in a single block. Gas optimization is possible by checking if the `end` variable is equal to `rewardsPerToken_.lastUpdated`. If so, the function can return after line 112 since no reward needs to be updated. The early return could avoid writing to the storage (line 117) and thus save gas.  ## Proof of Concept  Referenced code: [ERC20Rewards.sol#L112](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L112) [ERC20Rewards.sol#L117](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L117)  ## Recommended Mitigation Steps  Simply return if `end == rewardsPerToken_.lastUpdated` if the `_updateRewardsPerToken` function.  
# Handle  shw   # Vulnerability details  ## Impact  The `CTokenMultiOracle` contract assumes the exchange rates (borrowing rate) of Compound always have 18 decimals, while, however, which is not true. According to the [Compound documentation](https://compound.finance/docs/ctokens#exchange-rate), the exchange rate returned from the `exchangeRateCurrent` function is scaled by `1 * 10^(18 - 8 + Underlying Token Decimals)` (and so does `exchangeRateStored`). Using a wrong decimal number on the exchange rate could cause incorrect pricing on tokens.  ## Proof of Concept  Referenced code: [CTokenMultiOracle.sol#L110](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/compound/CTokenMultiOracle.sol#L110)  ## Recommended Mitigation Steps  Follow the documentation and get the decimals of the underlying tokens to set the correct decimal of a `Source`.  
# Handle  shw   # Vulnerability details  ## Impact  The `peek` and `get` functions of `CompositeMultiOracle` do not initialize the return variable `updateTime`, which is always 0 since the oldest timestamp is chosen and returned.  ## Proof of Concept  Referenced code: [CompositeMultiOracle.sol#L76](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L76) [CompositeMultiOracle.sol#L96](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L96)  ## Recommended Mitigation Steps  Handle the case when `updateTimeIn` is 0 in the private `_peek` and `_get` functions. If so, simply return `updateTimeOut`.  
# Handle  shw   # Vulnerability details  ## Impact  Tokens not compliant with the ERC20 specification could return `false` from the `transfer` function call to indicate the transfer fails, while the calling contract would not notice the failure if the return value is not checked. Checking the return value is a requirement, as written in the [EIP-20](https://eips.ethereum.org/EIPS/eip-20) specification:  > Callers MUST handle `false` from `returns (bool success)`. Callers MUST NOT assume that `false` is never returned!  ## Proof of Concept  Referenced code: [ERC20Rewards.sol#L175](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L175)  ## Recommended Mitigation Steps  Use the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from OpenZeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.  
# Handle  cmichel   # Vulnerability details  The return value is never used and should be removed to save some gas.  
# Handle  cmichel   # Vulnerability details  `TimeLock.setDelay` reads storage variable for event which produces an `SLOAD`. It should use `emit DelaySet(_delay)` instead of `emit DelaySet(delay)`  
# Handle  cmichel   # Vulnerability details  The `claim` function performs an ERC20 transfer `rewardsToken.transfer(to, claiming);` but does not check the return value, nor does it work with all legacy tokens.  Some tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` function return `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do **not** revert if the transfer failed but return `false` instead.   ## Impact Tokens that don't actually perform the transfer and return `false` are still counted as a correct transfer and tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin’s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.   
# Handle  cmichel   # Vulnerability details  The `setRewards` function allows setting a different token. Holders of a previous reward period cannot all be paid out and will receive **their old reward amount** in the new token.  This leads to issues when the new token is more (less) valuable, or uses different decimals.  **Example:** Assume the first reward period paid out in `DAI` which has 18 decimals. Someone would have received `1.0 DAI = 1e18 DAI` if they called `claim` now. Instead, they wait until the new period starts with `USDC` (using only 6 decimals) and can `claim` their `1e18` reward amount in USDC which would equal `1e12 USDC`, one trillion USD.  ## Impact Changing the reward token only works if old and new tokens use the same decimals and have the exact same value. Otherwise, users that claim too late/early will lose out.  ## Recommended Mitigation Steps Disallow changing the reward token, or clear user's pending rewards of the old token. The second approach requires more code changes and keeping track of what token a user last claimed.  
# Handle  cmichel   # Vulnerability details  The `ERC20Rewards._updateRewardsPerToken` function exits without updating `rewardsPerToken_.lastUpdated` if `totalSupply` is zero, i.e., if there are no tokens initially.  This leads to an error if there is an active rewards period but not tokens have been minted yet.  **Example:** `rewardsPeriod.start: 1 month ago`, `rewardsPeriod.end: in 1 month`, `totalSupply == 0`. The first mint leads to the user (mintee) receiving all rewards for the past period (50% of the total rewards in this case). - `_mint` is called, calls `_updateRewardsPerToken` which short-circuits. `rewardsPerToken.lastUpdated` is still set to `rewardsPeriod.start` from the constructor. Then `_updateUserRewards` is called and does not currently yield any rewards. (because both balance and the index diff are zero). User is now minted the tokens, `totalSupply` increases and user balance is set. - User performs a `claim`: `_updateRewardsPerToken` is called and `timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated = block.timestamp - rewardsPeriod.start = 1 month`. Contract "issues" rewards for the past month. The first mintee receives all of it.  ## Impact The first mintee receives all pending rewards when they should not receive any past rewards. This can easily happen if the token is new, the reward period has already been initialized and is running, but the protocol has not officially launched yet. Note that `setRewards` also allows setting a date in the past which would also be fatal in this case.  ## Recommended Mitigation Steps The `rewardsPerToken_.lastUpdated` field must always be updated in `_updateRewardsPerToken` to the current time (or `end`) even if `_totalSupply == 0`. Don't return early.  
# Handle  cmichel   # Vulnerability details  The `TimeLock.schedule` function reverts if the same `targets` and `data` fields are used as the `txHash` will be the same. This means one cannot schedule the same transactions multiple times.  ## Impact Imagine the delay is set to 30 days, but a contractor needs to be paid every 2 weeks. One needs to wait 30 days before scheduling the second payment to them.  ## Recommended Mitigation Steps Also include `eta` in the hash. (Compound's Timelock does it as well.) This way the same transaction data can be used by specifying a different `eta`.   
# Handle  cmichel   # Vulnerability details  The `Strategy.Divest` event is not fired.  ## Impact Off-chain scripts that rely on this event won't work.  ## Recommended Mitigation Steps Emit this event in `endPool`.  
# Handle  cmichel   # Vulnerability details  The `Strategy.Invest` event is not fired.  ## Impact Off-chain scripts that rely on this event won't work.  ## Recommended Mitigation Steps Emit this event in `startPool`.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Given a configuration of target, contacts and permissions, calling `terminate()` will permanently prevent this configuration from being used again because the state becomes `State.TERMINATED`. All other functions require the configuration to be in the other states (UNKNOWN, PLANNED, or EXECUTED).  In other words, the removal of the restoring option for the configuration through `EmergencyBrake` is permanent.  ### Recommended Mitigation Steps  Since `EmergencyBrake` cannot reinstate permissions after termination, it would be better to have terminate change its state to UNKNOWN. The TERMINATED state can therefore be removed.  
# Handle  PierrickGT   # Vulnerability details  ## Impact In the external functions `setSources` and `setPaths` of `CompositeMultiOracle.sol`, we call `bases.length` three times. This value can be stored in a variable to avoid two sload.  Also, `uint256 i = 0;` can be refactored to `uint256 i;` since `uint256` initializes with a value of `0` by default.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L39-L46  https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L60-L67  ## Recommended Mitigation Steps Store `bases.length` in a variable and declare `i` with the default value: ``` uint256 basesLength = bases.length;  require(     basesLength == quotes.length &&      basesLength == sources_.length,     "Mismatched inputs" );  for (uint256 i; i < basesLength; i++) {     _setSource(bases[i], quotes[i], sources_[i]); } ``` ``` uint256 basesLength = bases.length;  require(     basesLength == quotes.length &&      basesLength == paths_.length,     "Mismatched inputs" );  for (uint256 i; i < basesLength; i++) {     _setPath(bases[i], quotes[i], paths_[i]); } ```  
# Handle  PierrickGT   # Vulnerability details  ## Impact In `CompositeMultiOracle.sol`, internal functions, event, struct, public constant and mapping are not documented.  Functions parameters and return values should also be documented for external functions.  Natspec documentation should also be added to describe what this contract is all about.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L79-L81  https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L97-L99  ## Recommended Mitigation Steps Add natspec documentation to describe the contract and not just his title: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L11-L12  Add natspec documentation for the following code: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L15 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L17-L18 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L20 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L25-L26 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L110 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L120 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L130 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L140  Add natspec documentation for parameters and return value of these functions: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L31 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L38 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L52 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L59 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L74 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L94  
# Handle  PierrickGT   # Vulnerability details  ## Impact In the external function `setSources` of `CTokenMultiOracle.sol`, we call `cTokenIds.length` three times. This value can be stored in a variable to avoid two sload.  Also, `uint256 i = 0;` can be refactored to `uint256 i;` since `uint256` initializes with a value of `0` by default.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L38-L39  https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L42  ## Recommended Mitigation Steps Store `cTokenIds.length` in a variable and declare `i` with the default value: ``` uint256 cTokenIdsLength = cTokenIds.length;  require(     cTokenIdsLength == underlyings.length &&     cTokenIdsLength == cTokens.length,     "Mismatched inputs" );  for (uint256 i; i < cTokenIdsLength; i++) {     _setSource(cTokenIds[i], underlyings[i], cTokens[i]); } ```  
# Handle  PierrickGT   # Vulnerability details  # CTokenMultiOracle.sol - Add natspec documentation  ## Impact In `CTokenMultiOracle.sol`, internal functions, event, struct, public constant and mapping are not documented.  Functions parameters and return values should also be documented for external functions.  Natspec documentation should also be added to describe what this contract is all about.  ## Recommended Mitigation Steps Add natspec documentation to describe the contract: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L11  Add natspec documentation for the following code: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L14 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L16 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L18 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L24 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L73 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L91 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L109  Add natspec documentation for parameters and return value of these functions: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L29 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L36 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L51 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L64   
# Handle  PierrickGT   # Vulnerability details  ## Impact In `FYTokenFactory.sol`, it is possible to avoid one sload by storing `fyToken.ROOT()` in a variable.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/77bc292601ba6cb6d35f9a1cb606f21ed94ad36e/contracts/FYTokenFactory.sol#L37-L38  ## Tools Used Manual analysis  ## Recommended Mitigation Steps ```   bytes4 rootRole = fyToken.ROOT();    fyToken.grantRole(rootRole, msg.sender);   fyToken.renounceRole(rootRole, address(this)); ```  
# Handle  gpersoon   # Vulnerability details  ## Impact The contract Wand defines a few role constants with bytes4(keccak256("...function...")) However if the function template would change slightly, for example when uint128 is replaced by uint256, then this construction isn't valid anymore.  It is safer the use the function selector, as is done in EmergencyBrake.sol  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/main/contracts/Wand.sol#L27      bytes4 public constant JOIN = bytes4(keccak256("join(address,uint128)"));     bytes4 public constant EXIT = bytes4(keccak256("exit(address,uint128)"));     bytes4 public constant MINT = bytes4(keccak256("mint(address,uint256)"));     bytes4 public constant BURN = bytes4(keccak256("burn(address,uint256)"));  https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/EmergencyBrake.sol#L35   _grantRole(IEmergencyBrake.plan.selector, planner);  ## Tools Used  ## Recommended Mitigation Steps Use function selectors in Wand.sol   
# Handle  gpersoon   # Vulnerability details  ## Impact In function get of CompositeMultiOracle the updateTime is not initialized, so it will be 0  Function _get has the following statement:    updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;      updateTimeIn ==0 ==>  (updateTimeOut < updateTimeIn)== false ==> result of the expression is updateTimeIn == 0 ==> updateTimeOut =0  So this means the function get will always return updateTime==0  The updateTime result of the function get doesn't seem to be used in the code so the risk is low. If would only be relevant for future code updates.   ## Proof of Concept //https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L94  function get(bytes32 base, bytes32 quote, uint256 amount)  external virtual override  returns (uint256 value, uint256 updateTime)  { ...         for (uint256 p = 0; p < path.length; p++) {             (price, updateTime) = _get(base_, path[p], price, updateTime);  function _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)  private returns (uint priceOut, uint updateTimeOut) {     ...         (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals);    // Get price for one unit       ...         updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time     }  ## Tools Used  ## Recommended Mitigation Steps In function get, add the following in the beginning of the function: updateTime = block.timestamp;  
# Handle  gpersoon   # Vulnerability details  ## Impact The functions schedule and cancel of TimeLock.sol receive the parameters targets and data. This is not absolutely necessary. Receiving txHash would be enough, as txHash is verified in the function execute. This is like a commit and reveal scheme. It would save some gas and contract complexity.  This assumes that the parameters  targets and data are accessible offchain for verification, which I would think would be true anyway.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps You can use the following approach if you want to save some gas. Note: the parameters targets and data won't be available onchain in events (at least until execute has been performed)   function schedule(bytes32 txHash, uint256 eta) external override auth {         require(eta >= block.timestamp + delay, "Must satisfy delay."); // This also prevents setting eta = 0 and messing up the state                 require(transactions[txHash] == 0, "Transaction not unknown.");         transactions[txHash] = eta;                ....     }      function cancel(bytes32 txHash) external override auth {         require(transactions[txHash] != 0, "Transaction hasn't been scheduled.");         delete transactions[txHash];        ....     }  
# Handle  gpersoon   # Vulnerability details  ## Impact TimeLock.sol contains a comment with a double negative, which is confusing to read: Transaction not unknown.  ## Proof of Concept //https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/TimeLock.sol#L55  function schedule(address[] calldata targets, bytes[] calldata data, uint256 eta)   external override auth returns (bytes32 txHash)  { ..         require(transactions[txHash] == 0, "Transaction not unknown.");  ## Tools Used  ## Recommended Mitigation Steps Replace: Transaction not unknown. with: Transaction already scheduled.  
# Handle  moose-code   # Vulnerability details  ## Impact Users have essentially have an option to either claim currently earned reward amounts on future rewards tokens, or the current rewards token.   Although stated on line 84, it does not take into account the implications and lock in this contract will have on the future value of new tokens able to be issued via rewards.   ## Proof of Concept Smart users will monitor the mempool for setRewards transactions. If the new reward token (token b) is less valuable than the old reward token (token a), they front run this transaction by calling claim. Otherwise they let their accrued 'token a' roll into rewards of of the more valuable 'token b'.  Given loads of users will likely hold these tokens from day 1, there will potentially be thousands of different addresses squatting on rewards.   Economically, given the above it makes sense that the value of new reward tokens, i.e. 'token b' should always be less than that of 'token a'. This is undesirable in a rewards token contract as there is no reliable way to start issuing a more valuable token at a later stage, unless exposing yourself to a major risk of reward squatting.  i.e. You could not in future say we want to run a rewards period of of issuing an asset like WETH rewards for 10 days, after first initially issuing DAI as a reward. This hamstrings flexibility of the contract.  P.s. This is one of the slickest contracts I've read. Love how awesome it is.Just believe this should be fixed, then its good to go.   ## Tools Used Manual analysis  ## Recommended Mitigation Steps It is true you could probably write a script to manually go call 'claim' on thousands of squatting token addresses but this is a poor solution.   A simple mapping pattern could be used with an index mapping to a reward cycle with a reward token and a new accumulative etc. Users would likely need to be given a period a to claim from old reward cycles before their token balance could no longer reliably used to calculate past rewards. The would still be able to claim everything up until their last action (even though this may be before the rewards cycle ended).  
# Handle  hickuphh3   # Vulnerability details  ### Impact  As per the [solidity documentation](https://docs.soliditylang.org/en/v0.8.1/abi-spec.html?highlight=events#events):  However, for all “complex” types or types of dynamic length, including all arrays, string, bytes and structs, EVENT_INDEXED_ARGS will contain the Keccak hash of a special in-place encoded value (see Encoding of Indexed Event Parameters), rather than the encoded value directly.  It therefore might not be useful to index `address[] targets` in `Timelock.sol` and `address[] contacts` in `EmergencyBrake.sol`, since it's the keccak hash of the addresses. [Also saves gas to drop the indexed keyword](https://ethereum.stackexchange.com/questions/56486/does-it-make-a-difference-to-index-an-event-with-one-parameter/56491).  ### Recommended Mitigation Steps  Remove the `indexed` keyword for the arguments mentioned above.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  As brought up in a [previous audit issue](https://github.com/code-423n4/2021-05-yield-findings/issues/4), "the suggestion of changing all public auth functions to external auth will be applied". The same should therefore be done for the new contracts `Strategy.sol` and `ERC20Rewards.sol`, since all public methods in it aren't called internally.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `uint128` output by `_updateRewardsPerToken()` isn't used by any function. Furthermore, L107 returns a wrong value.  `if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod.start) return 0;`  It should return `rewardsPerToken_.accumulated` instead, because in the case of a new rewards schedule being set, `rewardsPeriod.start` is updated to a new timestamp. Hence, the current accumulated value of all previous reward schedules thus far should be returned.  ### Recommended Mitigation Steps  Since the return value isn't used anywhere, remove it.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The `latest()` function is unused and can be removed.  ### Recommended Mitigation Steps  Remove L68-L71  
# Handle  hickuphh3   # Vulnerability details  ### Impact  This would be equivalent to [Unipool's `rewardPerToken()` function](https://github.com/k06a/Unipool/blob/master/contracts/Unipool.sol#L69). Note that `rewardsPerToken.accumulated` only reflects the latest stored accumulated value, but does not account for pending accumulation like Unipool, and is therefore not the same. It possibly might be mistaken to be so, hence the low risk classification.  ### Recommended Mitigation Steps  A possible implementation is given below.  ```jsx function latestRewardPerToken() external view returns (uint256) {  RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;  if (_totalSupply == 0) return rewardsPerToken_.accumulated;  uint32 end = earliest(block.timestamp.u32(), rewardsPeriod.end);  uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated;  return rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply; } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  While it might seem like a good feature to have, being able to switch reward tokens will only be useful for tokens which are equivalent in value (probably stablecoins, pegged tokens) since it carries over unclaimed rewards from the previous reward program. It would be safer to keep the reward token immutable as a safeguard against violations of this condition.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level call returns success even if the contract is non-existent. This requires a contract existence check before making the low-level call.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L93  See: “The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.” from https://docs.soliditylang.org/en/v0.8.7/control-structures.html#error-handling-assert-require-revert-and-exceptions  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for target contract existence before call.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  That cauldron_ parameter is not used here and ladle_.cauldron() is used instead. The Ladle constructor initializes its cauldron value and so the only way this could differ from the parameter is if the argument to this function is specified incorrectly.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L100  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L106-L107  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/Ladle.sol#L33   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Either use parameter or remove it in favor of the value from ladle_.cauldron().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Few events are missing emits which prevents the intended data from being observed easily by off-chain interfaces.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L48-L49  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add emits or remove event declarations.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  solc version 0.8.3 and 0.8.4 fixed important bugs in the compiler. Using version 0.8.1 misses these fixes and may cause a vulnerability.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L2  https://github.com/ethereum/solidity/releases/tag/v0.8.4: Solidity 0.8.4 fixes a bug in the ABI decoder. The release contains an important bugfix. See decoding from memory bug blog post for more details.  https://github.com/ethereum/solidity/releases/tag/v0.8.3: Solidity 0.8.3 is a bugfix release that fixes an important bug about how the optimizer handles the Keccak256 opcode. For details on the bug, please see the bug blog post.   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider upgrading to 0.8.3 or 0.8.4  
# Handle  0xRajeev   # Vulnerability details  ## Impact  setRewards() is missing input validation on parameters start and end to check if end > start. If accidentally set incorrectly, this will allow resetting new rewards while there is an ongoing one.   ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L88  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a require() to check that end > start.  
# Handle  0xRajeev   # Vulnerability details  ## Impact The check for array lengths is unnecessary in two places where the following check on txHash will anyway fail if the lengths don’t match with what was hashed earlier during schedule. Removing the length check can save a little gas.  Such a require() in cancel() can be removed because if there is a mismatch, the entry lookup in transactions[] will fail anyway and also, this will not be sceduled/executed.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L70-L72  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L81-L85   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate and remove these checks.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The require check for decimals_ <= 18 is unnecessary given its set to 18 right above unless this needs to be obtained differently as hinted by the comment.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/compound/CTokenMultiOracle.sol#L110-L111  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate check and remove.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  As noted in the code comment, peek and get functions are the same for this oracle. So we can change `peek` to public visibility and have `get` call `peek` instead of copying the same code here. Minor deployment cost savings but increase in readability/maintainability.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/composite/CompositeMultiOracle.sol#L91  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/composite/CompositeMultiOracle.sol#L74-L128  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace two functions having the same code with a single function.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function parameters are passed in calldata. For external functions, these are simply read from calldata. But explicitly specifying memory location for such parameters will force their copying to memory resulting in extra bytecode and more gas. Leaving them in calldata will save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L45-L46  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L66-L67  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L77-L78  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L101-L102  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L116-L117  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/FYTokenFactory.sol#L21-L22  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Do not use memory data location specifier for external function parameters  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Event emits where there are equivalent local variables or parameters for state variables can save gas by using those instead of state variables because of the expensive SLOADs.  ## Proof of Concept  rewardsToken: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L97  delay: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L51   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use parameters or local variables instead of state variables in event emits  
# Handle  0xRajeev   # Vulnerability details  ## Impact  SLOADs cost 2100 gas for first time reads of state variables and then 100 gas for repeated reads in the context of a transaction (post Berlin fork). MLOADs cost 3 gas units. Therefore, caching state variable in local variables for repeated reads saves gas.  ## Proof of Concept  Examples of state variables that are read at the lines shown and also later in that same function:  rewardsPeriod: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L80  _totalSupply: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L107  nextPool: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L163  ladle: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L172  base: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L180  pool (600 gas savings): https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L183  pool: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L208  cached: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L262   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider caching state variables in local variables.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Public functions need to copy their arguments from calldata to memory resulting in more bytecode and gas consumption. If functions are never called from within the contracts, they can be declared external in which case their parameters are always in calldata without being copied to memory. This results in gas savings. There are many such public functions that don’t appear to be called from within the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L75  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L100-L101  All functions declared in this range: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L127-L252  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility from public to external   
# Handle  shw   # Vulnerability details  ## Impact  The `_updateRewardsPerToken` function of `ERC20Rewards` is called when a token is transferred, minted, or burned. Thus, it could be called multiple times in a single block. Gas optimization is possible by checking if the `end` variable is equal to `rewardsPerToken_.lastUpdated`. If so, the function can return after line 112 since no reward needs to be updated. The early return could avoid writing to the storage (line 117) and thus save gas.  ## Proof of Concept  Referenced code: [ERC20Rewards.sol#L112](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L112) [ERC20Rewards.sol#L117](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L117)  ## Recommended Mitigation Steps  Simply return if `end == rewardsPerToken_.lastUpdated` if the `_updateRewardsPerToken` function.  
# Handle  shw   # Vulnerability details  ## Impact  The `CTokenMultiOracle` contract assumes the exchange rates (borrowing rate) of Compound always have 18 decimals, while, however, which is not true. According to the [Compound documentation](https://compound.finance/docs/ctokens#exchange-rate), the exchange rate returned from the `exchangeRateCurrent` function is scaled by `1 * 10^(18 - 8 + Underlying Token Decimals)` (and so does `exchangeRateStored`). Using a wrong decimal number on the exchange rate could cause incorrect pricing on tokens.  ## Proof of Concept  Referenced code: [CTokenMultiOracle.sol#L110](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/compound/CTokenMultiOracle.sol#L110)  ## Recommended Mitigation Steps  Follow the documentation and get the decimals of the underlying tokens to set the correct decimal of a `Source`.  
# Handle  shw   # Vulnerability details  ## Impact  The `peek` and `get` functions of `CompositeMultiOracle` do not initialize the return variable `updateTime`, which is always 0 since the oldest timestamp is chosen and returned.  ## Proof of Concept  Referenced code: [CompositeMultiOracle.sol#L76](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L76) [CompositeMultiOracle.sol#L96](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L96)  ## Recommended Mitigation Steps  Handle the case when `updateTimeIn` is 0 in the private `_peek` and `_get` functions. If so, simply return `updateTimeOut`.  
# Handle  shw   # Vulnerability details  ## Impact  Tokens not compliant with the ERC20 specification could return `false` from the `transfer` function call to indicate the transfer fails, while the calling contract would not notice the failure if the return value is not checked. Checking the return value is a requirement, as written in the [EIP-20](https://eips.ethereum.org/EIPS/eip-20) specification:  > Callers MUST handle `false` from `returns (bool success)`. Callers MUST NOT assume that `false` is never returned!  ## Proof of Concept  Referenced code: [ERC20Rewards.sol#L175](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L175)  ## Recommended Mitigation Steps  Use the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from OpenZeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.  
# Handle  cmichel   # Vulnerability details  The return value is never used and should be removed to save some gas.  
# Handle  cmichel   # Vulnerability details  `TimeLock.setDelay` reads storage variable for event which produces an `SLOAD`. It should use `emit DelaySet(_delay)` instead of `emit DelaySet(delay)`  
# Handle  cmichel   # Vulnerability details  The `claim` function performs an ERC20 transfer `rewardsToken.transfer(to, claiming);` but does not check the return value, nor does it work with all legacy tokens.  Some tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` function return `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do **not** revert if the transfer failed but return `false` instead.   ## Impact Tokens that don't actually perform the transfer and return `false` are still counted as a correct transfer and tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin’s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.   
# Handle  cmichel   # Vulnerability details  The `setRewards` function allows setting a different token. Holders of a previous reward period cannot all be paid out and will receive **their old reward amount** in the new token.  This leads to issues when the new token is more (less) valuable, or uses different decimals.  **Example:** Assume the first reward period paid out in `DAI` which has 18 decimals. Someone would have received `1.0 DAI = 1e18 DAI` if they called `claim` now. Instead, they wait until the new period starts with `USDC` (using only 6 decimals) and can `claim` their `1e18` reward amount in USDC which would equal `1e12 USDC`, one trillion USD.  ## Impact Changing the reward token only works if old and new tokens use the same decimals and have the exact same value. Otherwise, users that claim too late/early will lose out.  ## Recommended Mitigation Steps Disallow changing the reward token, or clear user's pending rewards of the old token. The second approach requires more code changes and keeping track of what token a user last claimed.  
# Handle  cmichel   # Vulnerability details  The `ERC20Rewards._updateRewardsPerToken` function exits without updating `rewardsPerToken_.lastUpdated` if `totalSupply` is zero, i.e., if there are no tokens initially.  This leads to an error if there is an active rewards period but not tokens have been minted yet.  **Example:** `rewardsPeriod.start: 1 month ago`, `rewardsPeriod.end: in 1 month`, `totalSupply == 0`. The first mint leads to the user (mintee) receiving all rewards for the past period (50% of the total rewards in this case). - `_mint` is called, calls `_updateRewardsPerToken` which short-circuits. `rewardsPerToken.lastUpdated` is still set to `rewardsPeriod.start` from the constructor. Then `_updateUserRewards` is called and does not currently yield any rewards. (because both balance and the index diff are zero). User is now minted the tokens, `totalSupply` increases and user balance is set. - User performs a `claim`: `_updateRewardsPerToken` is called and `timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated = block.timestamp - rewardsPeriod.start = 1 month`. Contract "issues" rewards for the past month. The first mintee receives all of it.  ## Impact The first mintee receives all pending rewards when they should not receive any past rewards. This can easily happen if the token is new, the reward period has already been initialized and is running, but the protocol has not officially launched yet. Note that `setRewards` also allows setting a date in the past which would also be fatal in this case.  ## Recommended Mitigation Steps The `rewardsPerToken_.lastUpdated` field must always be updated in `_updateRewardsPerToken` to the current time (or `end`) even if `_totalSupply == 0`. Don't return early.  
# Handle  cmichel   # Vulnerability details  The `TimeLock.schedule` function reverts if the same `targets` and `data` fields are used as the `txHash` will be the same. This means one cannot schedule the same transactions multiple times.  ## Impact Imagine the delay is set to 30 days, but a contractor needs to be paid every 2 weeks. One needs to wait 30 days before scheduling the second payment to them.  ## Recommended Mitigation Steps Also include `eta` in the hash. (Compound's Timelock does it as well.) This way the same transaction data can be used by specifying a different `eta`.   
# Handle  cmichel   # Vulnerability details  The `Strategy.Divest` event is not fired.  ## Impact Off-chain scripts that rely on this event won't work.  ## Recommended Mitigation Steps Emit this event in `endPool`.  
# Handle  cmichel   # Vulnerability details  The `Strategy.Invest` event is not fired.  ## Impact Off-chain scripts that rely on this event won't work.  ## Recommended Mitigation Steps Emit this event in `startPool`.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  Given a configuration of target, contacts and permissions, calling `terminate()` will permanently prevent this configuration from being used again because the state becomes `State.TERMINATED`. All other functions require the configuration to be in the other states (UNKNOWN, PLANNED, or EXECUTED).  In other words, the removal of the restoring option for the configuration through `EmergencyBrake` is permanent.  ### Recommended Mitigation Steps  Since `EmergencyBrake` cannot reinstate permissions after termination, it would be better to have terminate change its state to UNKNOWN. The TERMINATED state can therefore be removed.  
# Handle  PierrickGT   # Vulnerability details  ## Impact In the external functions `setSources` and `setPaths` of `CompositeMultiOracle.sol`, we call `bases.length` three times. This value can be stored in a variable to avoid two sload.  Also, `uint256 i = 0;` can be refactored to `uint256 i;` since `uint256` initializes with a value of `0` by default.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L39-L46  https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L60-L67  ## Recommended Mitigation Steps Store `bases.length` in a variable and declare `i` with the default value: ``` uint256 basesLength = bases.length;  require(     basesLength == quotes.length &&      basesLength == sources_.length,     "Mismatched inputs" );  for (uint256 i; i < basesLength; i++) {     _setSource(bases[i], quotes[i], sources_[i]); } ``` ``` uint256 basesLength = bases.length;  require(     basesLength == quotes.length &&      basesLength == paths_.length,     "Mismatched inputs" );  for (uint256 i; i < basesLength; i++) {     _setPath(bases[i], quotes[i], paths_[i]); } ```  
# Handle  PierrickGT   # Vulnerability details  ## Impact In `CompositeMultiOracle.sol`, internal functions, event, struct, public constant and mapping are not documented.  Functions parameters and return values should also be documented for external functions.  Natspec documentation should also be added to describe what this contract is all about.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L79-L81  https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L97-L99  ## Recommended Mitigation Steps Add natspec documentation to describe the contract and not just his title: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L11-L12  Add natspec documentation for the following code: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L15 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L17-L18 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L20 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L25-L26 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L110 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L120 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L130 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L140  Add natspec documentation for parameters and return value of these functions: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L31 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L38 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L52 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L59 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L74 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L94  
# Handle  PierrickGT   # Vulnerability details  ## Impact In the external function `setSources` of `CTokenMultiOracle.sol`, we call `cTokenIds.length` three times. This value can be stored in a variable to avoid two sload.  Also, `uint256 i = 0;` can be refactored to `uint256 i;` since `uint256` initializes with a value of `0` by default.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L38-L39  https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L42  ## Recommended Mitigation Steps Store `cTokenIds.length` in a variable and declare `i` with the default value: ``` uint256 cTokenIdsLength = cTokenIds.length;  require(     cTokenIdsLength == underlyings.length &&     cTokenIdsLength == cTokens.length,     "Mismatched inputs" );  for (uint256 i; i < cTokenIdsLength; i++) {     _setSource(cTokenIds[i], underlyings[i], cTokens[i]); } ```  
# Handle  PierrickGT   # Vulnerability details  # CTokenMultiOracle.sol - Add natspec documentation  ## Impact In `CTokenMultiOracle.sol`, internal functions, event, struct, public constant and mapping are not documented.  Functions parameters and return values should also be documented for external functions.  Natspec documentation should also be added to describe what this contract is all about.  ## Recommended Mitigation Steps Add natspec documentation to describe the contract: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L11  Add natspec documentation for the following code: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L14 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L16 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L18 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L24 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L73 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L91 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L109  Add natspec documentation for parameters and return value of these functions: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L29 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L36 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L51 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L64   
# Handle  PierrickGT   # Vulnerability details  ## Impact In `FYTokenFactory.sol`, it is possible to avoid one sload by storing `fyToken.ROOT()` in a variable.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/77bc292601ba6cb6d35f9a1cb606f21ed94ad36e/contracts/FYTokenFactory.sol#L37-L38  ## Tools Used Manual analysis  ## Recommended Mitigation Steps ```   bytes4 rootRole = fyToken.ROOT();    fyToken.grantRole(rootRole, msg.sender);   fyToken.renounceRole(rootRole, address(this)); ```  
# Handle  gpersoon   # Vulnerability details  ## Impact The contract Wand defines a few role constants with bytes4(keccak256("...function...")) However if the function template would change slightly, for example when uint128 is replaced by uint256, then this construction isn't valid anymore.  It is safer the use the function selector, as is done in EmergencyBrake.sol  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/main/contracts/Wand.sol#L27      bytes4 public constant JOIN = bytes4(keccak256("join(address,uint128)"));     bytes4 public constant EXIT = bytes4(keccak256("exit(address,uint128)"));     bytes4 public constant MINT = bytes4(keccak256("mint(address,uint256)"));     bytes4 public constant BURN = bytes4(keccak256("burn(address,uint256)"));  https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/EmergencyBrake.sol#L35   _grantRole(IEmergencyBrake.plan.selector, planner);  ## Tools Used  ## Recommended Mitigation Steps Use function selectors in Wand.sol   
# Handle  gpersoon   # Vulnerability details  ## Impact In function get of CompositeMultiOracle the updateTime is not initialized, so it will be 0  Function _get has the following statement:    updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;      updateTimeIn ==0 ==>  (updateTimeOut < updateTimeIn)== false ==> result of the expression is updateTimeIn == 0 ==> updateTimeOut =0  So this means the function get will always return updateTime==0  The updateTime result of the function get doesn't seem to be used in the code so the risk is low. If would only be relevant for future code updates.   ## Proof of Concept //https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L94  function get(bytes32 base, bytes32 quote, uint256 amount)  external virtual override  returns (uint256 value, uint256 updateTime)  { ...         for (uint256 p = 0; p < path.length; p++) {             (price, updateTime) = _get(base_, path[p], price, updateTime);  function _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)  private returns (uint priceOut, uint updateTimeOut) {     ...         (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals);    // Get price for one unit       ...         updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time     }  ## Tools Used  ## Recommended Mitigation Steps In function get, add the following in the beginning of the function: updateTime = block.timestamp;  
# Handle  gpersoon   # Vulnerability details  ## Impact The functions schedule and cancel of TimeLock.sol receive the parameters targets and data. This is not absolutely necessary. Receiving txHash would be enough, as txHash is verified in the function execute. This is like a commit and reveal scheme. It would save some gas and contract complexity.  This assumes that the parameters  targets and data are accessible offchain for verification, which I would think would be true anyway.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps You can use the following approach if you want to save some gas. Note: the parameters targets and data won't be available onchain in events (at least until execute has been performed)   function schedule(bytes32 txHash, uint256 eta) external override auth {         require(eta >= block.timestamp + delay, "Must satisfy delay."); // This also prevents setting eta = 0 and messing up the state                 require(transactions[txHash] == 0, "Transaction not unknown.");         transactions[txHash] = eta;                ....     }      function cancel(bytes32 txHash) external override auth {         require(transactions[txHash] != 0, "Transaction hasn't been scheduled.");         delete transactions[txHash];        ....     }  
# Handle  gpersoon   # Vulnerability details  ## Impact TimeLock.sol contains a comment with a double negative, which is confusing to read: Transaction not unknown.  ## Proof of Concept //https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/TimeLock.sol#L55  function schedule(address[] calldata targets, bytes[] calldata data, uint256 eta)   external override auth returns (bytes32 txHash)  { ..         require(transactions[txHash] == 0, "Transaction not unknown.");  ## Tools Used  ## Recommended Mitigation Steps Replace: Transaction not unknown. with: Transaction already scheduled.  
