See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/brgltd-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/jadezti-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/adriro-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/karanctf-G.md).
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L197-L296 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L230-L313   # Vulnerability details  ## Impact Function `compound()` in `AutoPxGmx` and `AutoPxGlp` contracts is for compounding `pxGLP` (and additionally `pxGMX`) rewards. it works by calling `PirexGmx.claim(px*, this)` to collect the rewards of the vault and then swap the received amount (to calculate the reward, contract save the balance of a contract in that reward token before and after the call to the `claim()` and by subtracting them finds the received reward amount) and deposit them in `PirexGmx` again for compounding and in doing so it calculates fee based on what it received and in `AutoPxGlp` case it calculates `pxGMX` rewards too based on the extra amount contract receives during the execution of `claim()`. but attacker can call `PirexGmx.claim(px*, PirexGlp)` directly and make `PirexGmx` contract to transfer (`gmxBaseReward` and `pxGmx`) rewards to `AutoPxGlp` and in this case the logics of fee calculation and reward calculation in `compound()` function won't get executed and contract won't get it's fee from rewards and users won't get their `pxGmx` reward. so this bug would cause fee loss in `AutoPxGmx` and `AutoPxGlp` for contract and `pxGmx`'s reward loss for users in `AutoPxGlp`.  ## Proof of Concept the bug in in `AutoPxGmx` is similar to `AutoPxGlp`, so we only give Proof of Concept for `AutoPxGlp`. This is `compound()` function code in `AutoPxGlp` contract: ```     function compound(         uint256 minUsdg,         uint256 minGlp,         bool optOutIncentive     )         public         returns (             uint256 gmxBaseRewardAmountIn,             uint256 pxGmxAmountOut,             uint256 pxGlpAmountOut,             uint256 totalPxGlpFee,             uint256 totalPxGmxFee,             uint256 pxGlpIncentive,             uint256 pxGmxIncentive         )     {         if (minUsdg == 0) revert InvalidParam();         if (minGlp == 0) revert InvalidParam();          uint256 preClaimTotalAssets = asset.balanceOf(address(this));         uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));          PirexRewards(rewardsModule).claim(asset, address(this));         PirexRewards(rewardsModule).claim(pxGmx, address(this));          // Track the amount of rewards received         gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));          if (gmxBaseRewardAmountIn != 0) {             // Deposit received rewards for pxGLP             (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(                 address(gmxBaseReward),                 gmxBaseRewardAmountIn,                 minUsdg,                 minGlp,                 address(this)             );         }          // Distribute fees if the amount of vault assets increased         uint256 newAssets = totalAssets() - preClaimTotalAssets;         if (newAssets != 0) {             totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;             pxGlpIncentive = optOutIncentive                 ? 0                 : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;              if (pxGlpIncentive != 0)                 asset.safeTransfer(msg.sender, pxGlpIncentive);              asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);         }          // Track the amount of pxGMX received         pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;          if (pxGmxAmountOut != 0) {             // Calculate and distribute pxGMX fees if the amount of pxGMX increased             totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;             pxGmxIncentive = optOutIncentive                 ? 0                 : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;              if (pxGmxIncentive != 0)                 pxGmx.safeTransfer(msg.sender, pxGmxIncentive);              pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);              // Update the pxGmx reward accrual             _harvest(pxGmxAmountOut - totalPxGmxFee);         } else {             // Required to keep the globalState up-to-date             _globalAccrue();         }          emit Compounded(             msg.sender,             minGlp,             gmxBaseRewardAmountIn,             pxGmxAmountOut,             pxGlpAmountOut,             totalPxGlpFee,             totalPxGmxFee,             pxGlpIncentive,             pxGmxIncentive         );     } ``` As you can see contract collects rewards by calling `PirexRewards.claim()` and in the line `uint256 newAssets = totalAssets() - preClaimTotalAssets;` contract calculates the received amount of rewards(by subtracting the balance after and before reward claim) and then calculates fee based on this amount `totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;` and then sends the fee in the line `asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive)` for `owner`. the logic for `pxGmx` rewards are the same. As you can see the calculation of fee is based on the rewards received, and there is no other logic in the contract to calculate and transfer the fee of protocol. so if `AutoPxGpl` receives rewards without `compound()` getting called then for those rewards fee won't be calculated and transferred and protocol would lose it's fee. In the line `_harvest(pxGmxAmountOut - totalPxGmxFee)` contract calls `_harvest()` function to update the `pxGmx` reward accrual and there is no call to `_harvest()` in any other place and this is the only place where `pxGmx` reward accrual gets updated. contract uses `pxGmxAmountOut` which is the amount of `gmx` contract received during the call (code calculates it by subtracting the balance after and before reward claim: `pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;`) so contract only handles accrual rewards in this function call and if some `pxGmx` rewards claimed for contract without `compund()` logic execution then those rewards won't be used in `_harvest()` and `_globalAccrue()` calculation and users won't receive those rewards. As mentioned attacker can call `PirexRewards.claim(pxGmx, AutoPxGpl)` directly and make `PirexRewads` contract to transfer `AutoPxGpl` rewards. This is `claim()` code in `PirexRewards`: ```     function claim(ERC20 producerToken, address user) external {         if (address(producerToken) == address(0)) revert ZeroAddress();         if (user == address(0)) revert ZeroAddress();          harvest();         userAccrue(producerToken, user);          ProducerToken storage p = producerTokens[producerToken];         uint256 globalRewards = p.globalState.rewards;         uint256 userRewards = p.userStates[user].rewards;          // Claim should be skipped and not reverted on zero global/user reward         if (globalRewards != 0 && userRewards != 0) {             ERC20[] memory rewardTokens = p.rewardTokens;             uint256 rLen = rewardTokens.length;              // Update global and user reward states to reflect the claim             p.globalState.rewards = globalRewards - userRewards;             p.userStates[user].rewards = 0;              emit Claim(producerToken, user);              // Transfer the proportionate reward token amounts to the recipient             for (uint256 i; i < rLen; ++i) {                 ERC20 rewardToken = rewardTokens[i];                 address rewardRecipient = p.rewardRecipients[user][rewardToken];                 address recipient = rewardRecipient != address(0)                     ? rewardRecipient                     : user;                 uint256 rewardState = p.rewardStates[rewardToken];                 uint256 amount = (rewardState * userRewards) / globalRewards;                  if (amount != 0) {                     // Update reward state (i.e. amount) to reflect reward tokens transferred out                     p.rewardStates[rewardToken] = rewardState - amount;                      producer.claimUserReward(                         address(rewardToken),                         amount,                         recipient                     );                 }             }         }     } ``` As you can see it can be called by anyone for any user. so to perform this attack, attacker would perform this steps: 1. suppose `AutoPxGpl` has pending rewards, for example 100 `pxGmx` and 100 `weth`. 2. attacker would call  `PirexRewards.claim(pxGmx, AutoPxGpl)` and  `PirexRewards.claim(pxGpl, AutoPxGpl)` and `PirexRewards` contract would calculate and claim and transfer `pxGmx` rewards and `weth` rewards of `AutoPxGpl` address. 3. then `AutoPxGpl` has no pending rewards but the balance of `pxGmx` and `weth` of contract has been increased. 4. if anyone call `AutoPxGpl.compound()` because there is no pending rewards contract would receive no rewards and because contract only calculates fee and rewards based on received rewards during the call to `compound()` so contract wouldn't calculate any fee or reward accrual for those 1000 `pxGmx` and `weth` rewards. 5. `owner` of `AutoPxGpl` would lose his fee for those rewards and users of `AutoPxGpl` would lose their claims for those 1000 `pxGmx` rewards (because the calculation for them didn't happen).  This bug is because of the fact that the only logic handling rewards is in `compound()` function which is only handling receiving rewards by calling `claim()` during the call to `compound()` but it's possible to call `claim()` directly (`PirexRewards` contract allows this) and `AutoPxGpl` won't get notified about this new rewards and the related logics won't get executed.  ## Tools Used VIM  ## Recommended Mitigation Steps contract should keep track of it's previous balance when `compound()` get executed and update this balance in deposits and withdraws and claims so it can detect rewards that directly transferred to contract without call to `compound()`.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/0xfuje-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/keccak123-G.md).
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L940-L949   # Vulnerability details  ## Impact  PirexGmx#migrateReward() may cause users to lose Reward. before PirexRewards.sol set new PirexGmx  ## Proof of Concept  The current migration process is: call # completemigration ()-> # migrateward ()  After this method, the producer of PirexRewards.sol contract is still the old PirexGmx.   At this time, if AutoPxGmx#compound () is called by bot:  AutoPxGmx#compound() -> PirexRewards#.claim() -> old_PirexGmx#claimRewards()  Old_PirexGmx#claimRewards () will return zero rewards  and the reward of AutopXGMX will be lost.   old PirexGmx still can execute https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L824-L828  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L940-L949  ## Tools Used  ## Recommended Mitigation Steps  There are two ways to solve the problem. 1. set the producer of PirexRewards to the new PirexGmx in completeMigration (). 2. In #migrateReward (), set the old PirexGmx's "pirexRewards" to address(0), so that you can't use the old PirexGmx to get rewards  Simply use the second, such as: ```solidity     function migrateReward() external whenPaused {         if (msg.sender != migratedTo) revert NotMigratedTo();         if (gmxRewardRouterV2.pendingReceivers(address(this)) != address(0))             revert PendingMigration();          // Transfer out any remaining base reward (ie. WETH) to the new contract         gmxBaseReward.safeTransfer(             migratedTo,             gmxBaseReward.balanceOf(address(this))         ); +       pirexRewards ==address(0);   //*** set pirexRewards=0,Avoid claimRewards () being called by mistake.***//     } ``` ``` 
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L733-L816 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L228-L267 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L332-L348   # Vulnerability details  ## Impact Function `claimRewards()` in `PirexGmx` claims WETH and esGMX rewards and multiplier points (MP) from GMX protocol. it uses `_calculateRewards()` to calculate the unclaimed reward token amounts produced for each token type. but because of the lack of checks, function `_calculateRewards()` would revert when `RewardTracker.distributor.totalSupply()` is zero so if any of 4 `RewardTracker`s has zero `totalSupply()` then function `claimRewards()` would revert too and function `harvest()` in `PirexRewards` contract would revert too because it calls `PirexGmx.claimRewards()`. `harvest()` is used in `claim()` function so `claim()` would not work too. This bug would harvesting rewards for `PirexRewards` contract and claiming reward for users from `PirexRewards` when supply of one of `RewardTracker`s contracts in GMX protocol is zero. Function `claimRewards()` is written based on GMX code, but the logic is not correctly copied because in GMX protocol contract checks for `totalSupply()` and it prevents this bug from happening.  ## Proof of Concept This is function `_calculateRewards()`'s code in `PirexGmx`: ```    function _calculateRewards(bool isBaseReward, bool useGmx)         internal         view         returns (uint256)     {         RewardTracker r;          if (isBaseReward) {             r = useGmx ? rewardTrackerGmx : rewardTrackerGlp;         } else {             r = useGmx ? stakedGmx : feeStakedGlp;         }          address distributor = r.distributor();         uint256 pendingRewards = IRewardDistributor(distributor)             .pendingRewards();         uint256 distributorBalance = (isBaseReward ? gmxBaseReward : esGmx)             .balanceOf(distributor);         uint256 blockReward = pendingRewards > distributorBalance             ? distributorBalance             : pendingRewards;         uint256 precision = r.PRECISION();         uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() +             ((blockReward * precision) / r.totalSupply());          if (cumulativeRewardPerToken == 0) return 0;          return             r.claimableReward(address(this)) +             ((r.stakedAmounts(address(this)) *                 (cumulativeRewardPerToken -                     r.previousCumulatedRewardPerToken(address(this)))) /                 precision);     } ``` As you can see in the line `uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() + ((blockReward * precision) / r.totalSupply())` if `totalSupply()` was zero then code would revert because of division by zero error. so if `RewardTracker.distributor.totalSupply()` was zero then function `_calculateRewards` would revert and won't work and other function using `_calculateRewards()` would be break too.  This is part of function `claimRewards()`'s code in `PirexGmx` contract: ```     function claimRewards()         external         onlyPirexRewards         returns (             ERC20[] memory producerTokens,             ERC20[] memory rewardTokens,             uint256[] memory rewardAmounts         )     {         // Assign return values used by the PirexRewards contract         producerTokens = new ERC20[](4);         rewardTokens = new ERC20[](4);         rewardAmounts = new uint256[](4);         producerTokens[0] = pxGmx;         producerTokens[1] = pxGlp;         producerTokens[2] = pxGmx;         producerTokens[3] = pxGlp;         rewardTokens[0] = gmxBaseReward;         rewardTokens[1] = gmxBaseReward;         rewardTokens[2] = ERC20(pxGmx); // esGMX rewards distributed as pxGMX         rewardTokens[3] = ERC20(pxGmx);          // Get pre-reward claim reward token balances to calculate actual amount received         uint256 baseRewardBeforeClaim = gmxBaseReward.balanceOf(address(this));         uint256 esGmxBeforeClaim = stakedGmx.depositBalances(             address(this),             address(esGmx)         );          // Calculate the unclaimed reward token amounts produced for each token type         uint256 gmxBaseRewards = _calculateRewards(true, true);         uint256 glpBaseRewards = _calculateRewards(true, false);         uint256 gmxEsGmxRewards = _calculateRewards(false, true);         uint256 glpEsGmxRewards = _calculateRewards(false, false); ``` As you can see it calls `_calculateRewards()` to calculate  the unclaimed reward token amounts  produced for each token type in GMX protocol. so function `claimRewards()` would revert too when `totalSupply()` of one of these 4 `RewardTracker`'s distributers was zero. This is part of functions `harvest()` and `claim()` code in `PirexReward` contract: ```     function harvest()         public         returns (             ERC20[] memory _producerTokens,             ERC20[] memory rewardTokens,             uint256[] memory rewardAmounts         )     {         (_producerTokens, rewardTokens, rewardAmounts) = producer             .claimRewards();         uint256 pLen = _producerTokens.length; ....... ...... ......       function claim(ERC20 producerToken, address user) external {         if (address(producerToken) == address(0)) revert ZeroAddress();         if (user == address(0)) revert ZeroAddress();          harvest();         userAccrue(producerToken, user); .... .... .... ``` As you can see `harvest()` calls `claimRewards()` and `claim()` calls `harvest()` so these two function would revert and won't work when `totalSupply()` of one of these 4 `RewardTracker`'s distributers in GMX protocol was zero. in that situation the protocol can't harvest and claim rewards from GMX because of this bug and users won't be able to claim their rewards from the protocol. the condition for this bug could happen from time to time as GMX decided to prevent it by checking the value of `totalSupply()`. This is function `_updateRewards()` code in `RewardTracker` in GMX protocol (https://github.com/gmx-io/gmx-contracts/blob/65e62b62aadea5baca48b8157acb9351249dbaf1/contracts/staking/RewardTracker.sol#L272-L286): ```     function _updateRewards(address _account) private {         uint256 blockReward = IRewardDistributor(distributor).distribute();          uint256 supply = totalSupply;         uint256 _cumulativeRewardPerToken = cumulativeRewardPerToken;         if (supply > 0 && blockReward > 0) {             _cumulativeRewardPerToken = _cumulativeRewardPerToken.add(blockReward.mul(PRECISION).div(supply));             cumulativeRewardPerToken = _cumulativeRewardPerToken;         }          // cumulativeRewardPerToken can only increase .... .... ``` As you can see it checks that `supply > 0` before using it as denominator in division. So GMX protocol handles the case when `totalSupply()` is zero and contract logics won't break when this case happens but function `_calculateRewards()` which tries to calculate GMX protocol rewards beforehand don't handle this case(the case where `totalSupply()` is zero) so the logics would break when this case happens and it would cause function `harvest()` and `claim()` to be unfunctional.  ## Tools Used VIM  ## Recommended Mitigation Steps check that `totalSupply()` is not zero before using it.
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L269-L293 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L346-L355   # Vulnerability details  ## Impact Function `configureGmxState()` of `PirexGmx` is for configuring GMX contract state but logic is using `safeApprove()` improperly, it won't reset approval amount for old `stakedGmx` address This would cause 4 problem: 1. different behavior in `setContract()` and `configureGmxState()` for handling `stakeGmx` address changes. in `setContract()` the logic reset approval for old address to zero but in `configureGmxState()` the logic don't reset old address GMX spending approval. 2. the call to this function would revert if `stakeGmx` address didn't changed but other addresses has been changed so `owner` can't use this to configure contract. 3. contract won't reset approval for old `stakedGmx` addresse which is a threat because contract in that address can steal all the GMX balance any time in the future if that old address had been compromised. 4. contract won't reset approval for old `stakedGmx` addresse, if `owner` use `configureGmxState()` to change the `stakeGmx` value then it won't be possible to set `stakedGmx` value to previous ones by using either `configureGmxState()` or `setContract()` and contract would be in broken state.   ## Proof of Concept This is `configureGmxState()` code in `PirexGmx`: ```     /**         @notice Configure GMX contract state      */     function configureGmxState() external onlyOwner whenPaused {         // Variables which can be assigned by reading previously-set GMX contracts         rewardTrackerGmx = RewardTracker(gmxRewardRouterV2.feeGmxTracker());         rewardTrackerGlp = RewardTracker(gmxRewardRouterV2.feeGlpTracker());         feeStakedGlp = RewardTracker(gmxRewardRouterV2.stakedGlpTracker());         stakedGmx = RewardTracker(gmxRewardRouterV2.stakedGmxTracker());         glpManager = gmxRewardRouterV2.glpManager();         gmxVault = IVault(IGlpManager(glpManager).vault());          emit ConfigureGmxState(             msg.sender,             rewardTrackerGmx,             rewardTrackerGlp,             feeStakedGlp,             stakedGmx,             glpManager,             gmxVault         );          // Approve GMX to enable staking         gmx.safeApprove(address(stakedGmx), type(uint256).max);     } ``` As you can see it just sets the approval for new `stakeGmx` address and don't do anything about spending approval of old `stakeGmx` address. This is part of the `setContract()` code that handels `stakeGmx`: ```         if (c == Contracts.StakedGmx) {             // Set the current stakedGmx (pending change) approval amount to 0             gmx.safeApprove(address(stakedGmx), 0);              stakedGmx = RewardTracker(contractAddress);              // Approve the new stakedGmx contract address allowance to the max             gmx.safeApprove(contractAddress, type(uint256).max);             return;         } ``` As you can see it resets the spending approval of old `stakedGmx` address to zero and then give unlimited spending approval for new address. So the impact #1 is obvious that the code for same logic in two different functions don't beehive similarly.  Function `configureGmxState()` is used for configuring GMX contract state but if `owner` uses this function one time then it won't be possible to call this function the second time if `stakedGmx` wasn't changed. for example in this scenario: 1. owner calls `configureGmxState()` to set values for GMX contract addresses. 2. then address of one of contract changes in GMX (`stakedGmx` stayed the same) and owner want's to call `configureGmxState()` to reset the values of variables to correct ones. 3. owner call to `configureGmxState()` would fail because `stakedGmx` address didn't changed and in the line ` gmx.safeApprove(address(stakedGmx), type(uint256).max);` contract tries to set non zero approval for `stakedGmx` but it already has non zero spending allowance. (`safeApprove()` would revert if the current spending allowance is not zero and the new allowance is not zero either). so the impact #2 would happen and calls to this function in some scenarios would fail and it won't be functional.  Because function `configureGmxState()` don't reset the old `stakeGmx` address's GMX token spending approval to 0x0 so it would be possible to lose all GMX balance of `PirexGmx` contract if the old `stakeGmx` addresses are compromised. for example in this scenario: 1. GMX protocol get hacked(either by a bug or leaking some private keys) and `stakeGmx` contract control would be in hacker's hand. 2. GMX deploy new contracts and `stakeGmx` address changes in GMX. () 3. owner of `PirexGmx` calls `configureGmxState()` to reset the values of GMX contracts addresses in `PirexGmx`.  4. function `configureGmxState()` logic would change the GMX contract addresses but it won't set GMX token spending approval for old `stakeGmx` address to zero. 5. hacker who control the old `stakeGmx` address would use his access to that address contract to withdraw GMX balance of `PirexGmx`. because `PirexGmx` won't set approval for old `stakeGmx` contract so it would be possible for that old `stakeGmx` address to transfer GMX balance of `PirexGmx` anytime in future. the bug in old `stakeGmx` contract or leakage of private keys of `stakeGmx` address(private key who can become the owner or admin of that contract) can be happen after migrating GMX and Pirex contracts too. This is impact #3 scenario.  in scenario #4 contract would stuck in unrecoverable state. the problem is that if `configureGmxState()` is get used more than once and `stakeGmx` variable's value has been changes more than once then it won't be possible to set `stakeGmx` value to old values either with `configureGmxState()` or `setContract()` and the contract won't be useful. the scenario is this: (`safeApprove()` won't allow to set non-zero approval for address that has already non-zero approval amount. see the OZ implementation) 1. GMX protocol changes its `stakeGmx` contract address from old address to new (for any reason, they got hacked or they are migrating or ....) 2. `owner` of `PirexGmx` calls `configureGmxState()` to update GMX protocol's contract address in `PirexGmx` contract and the logic would update the values of variables. (the GMX spending approval for old and new `stakeGmx` address would be max value). 3. GMX protocol changes `stakeGmx` contract address from new value to old value (for any reason, they decided to roll back to old address) 4. owner tries to call `configureGmxState()` to reupdate GMX protocol's address in `PirexGmx` but the call would revert because the code tries to call `safeApprove()` for address that has already non-zero allowance. 5. owner can't call `setContract()` to update value of `stakeGmx` variable because this function tries to call `safeApprove()` to set non-zero approval value for address that already has non-zero allowance. so in this state `owner` can't recover `PirexGmx` contract and because contract has wrong value for `stakeGmx` it won't be functional and it would stay in broken state.   ## Tools Used VIM  ## Recommended Mitigation Steps like `setContract()`, function `configureGmxState()` should set approval for old `PirexGmx` to zero first.
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L367 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L583   # Vulnerability details  ## Impact In ``PirexGmx`` and ``AutoPxGlp`` you have function ``depositGlp()``, which accepts any ERC20 token from whitelist Now there are 9 tokens (see here: https://arbiscan.io/address/0x489ee077994b6658eafa855c308275ead8097c4a#readContract): ``WBTC, WETH, USDC, LINK, UNI, USDT, MIM, FRAX, DAI`` And the list may extend  So any user can deposit any of those tokens and receive pxGlp token: ```     function testUSDTDepositGlp() external {         // 0 USDT TOKENS         address myAddress = address(this);         assertEq(usdt.balanceOf(myAddress), 0);          // The one with many USDT tokens         vm.prank(0xB6CfcF89a7B22988bfC96632aC2A9D6daB60d641);         uint256 amount = 100000;         usdt.transfer(myAddress, amount);          // amount USDT TOKENS         assertEq(usdt.balanceOf(myAddress), amount);          // DEPOSIT USDT TOKENS         usdt.approve(address(pirexGmx), amount);         pirexGmx.depositGlp(address(usdt), amount, 1, 1, address(this));                  // SUCCESSSFULLY DEPOSITED         assertEq(usdt.balanceOf(address(this)), 0);         assertEq(pxGlp.balanceOf(address(this)), 118890025839780442);     } ```  But if of this tokens will start charge fee on transfers, the logic will be broken and calls to ``depositGlp()`` with suck token will fail  Because here you use the amount of tokens sent from user wallet: https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L512 ```             t.safeTransferFrom(msg.sender, address(this), tokenAmount);              // Mint and stake GLP using ERC20 tokens             deposited = gmxRewardRouterV2.mintAndStakeGlp(                 token,                 tokenAmount,                 minUsdg,                 minGlp             ); ``` And then ``gmxRewardRouterV2`` tries to transfer tokens to his balance from your balance:  ``` IERC20(_token).safeTransferFrom(_fundingAccount, address(vault), _amount); ```  (See https://arbiscan.io/address/0x321f653eed006ad1c29d174e17d96351bde22649#code - GlpManager and https://arbiscan.io/address/0xA906F338CB21815cBc4Bc87ace9e68c87eF8d8F1#code - RewardRouterV2)   But you received less than ``tokenAmount`` tokens because of fee. And transaction will fail   ## Proof of Concept Let's imagine USDT in arbitrub started to charge fees 1% per transfer  Alice wants to deposit 100 USDT through ``PirexGmx.depositGlp()`` Then you do  ``t.safeTransferFrom(Alice, address(this), 100);`` You will receive only 99 USDT  But in the next line you will try to send 100 USDT: ``` deposited = gmxRewardRouterV2.mintAndStakeGlp(                 token,                 tokenAmount,                 minUsdg,                 minGlp             ); ```  So transaction fails and Alice can't get pxGlp tokens    ## Tools Used  vs code  ## Recommended Mitigation Steps  USDT already has fees in other blockchains.  Many of these tokens use proxy pattern (and USDT too). It's quite probably that in one day one of the tokens will start charge fees. Or you would like to add one more token to whitelist and the token will be with fees  Thats why I consider finding as medium severity   To avoid problems, use common pattern, when you check your balance before operation and balance after, like that:  ```             uint256 balanceBefore = t.balanceOf(address(this));             t.safeTransferFrom(msg.sender, address(this), tokenAmount);             uint256 balanceAfter = t.balanceOf(address(this));              uint256 tokenAmount = balanceAfter - balanceBefore;              // Mint and stake GLP using ERC20 tokens             deposited = gmxRewardRouterV2.mintAndStakeGlp(                 token,                 tokenAmount,                 minUsdg,                 minGlp             ); ``` 
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373   # Vulnerability details  ## Proof of Concept  If the user deposits too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the `PirexRewards.claim` function. Subsequently, their accrued rewards will be cleared out (set to zero), and they will lose their rewards.  The amount of reward tokens that are claimable by a user is computed in Line 403 of the `PirexRewards.claim` function.  If the balance of pxGMX of a user is too small compared to other users (or total supply of pxGMX), the code below will always return zero due to rounding issues within solidity.  ```solidity uint256 amount = (rewardState * userRewards) / globalRewards; ```  Since the user's accrued rewards is cleared at Line 391 within the `PirexRewards.claim` function (`p.userStates[user].rewards = 0;`), the user's accrued rewards will be lost.  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373  ```solidity File: PirexRewards.sol 368:     /** 369:         @notice Claim rewards 370:         @param  producerToken  ERC20    Producer token contract 371:         @param  user           address  User 372:     */ 373:     function claim(ERC20 producerToken, address user) external { 374:         if (address(producerToken) == address(0)) revert ZeroAddress(); 375:         if (user == address(0)) revert ZeroAddress(); 376:  377:         harvest(); 378:         userAccrue(producerToken, user); 379:  380:         ProducerToken storage p = producerTokens[producerToken]; 381:         uint256 globalRewards = p.globalState.rewards; 382:         uint256 userRewards = p.userStates[user].rewards; 383:  384:         // Claim should be skipped and not reverted on zero global/user reward 385:         if (globalRewards != 0 && userRewards != 0) { 386:             ERC20[] memory rewardTokens = p.rewardTokens; 387:             uint256 rLen = rewardTokens.length; 388:  389:             // Update global and user reward states to reflect the claim 390:             p.globalState.rewards = globalRewards - userRewards; 391:             p.userStates[user].rewards = 0; 392:  393:             emit Claim(producerToken, user); 394:  395:             // Transfer the proportionate reward token amounts to the recipient 396:             for (uint256 i; i < rLen; ++i) { 397:                 ERC20 rewardToken = rewardTokens[i]; 398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken]; 399:                 address recipient = rewardRecipient != address(0) 400:                     ? rewardRecipient 401:                     : user; 402:                 uint256 rewardState = p.rewardStates[rewardToken]; 403:                 uint256 amount = (rewardState * userRewards) / globalRewards; 404:  405:                 if (amount != 0) { 406:                     // Update reward state (i.e. amount) to reflect reward tokens transferred out 407:                     p.rewardStates[rewardToken] = rewardState - amount; 408:  409:                     producer.claimUserReward( 410:                         address(rewardToken), 411:                         amount, 412:                         recipient 413:                     ); 414:                 } 415:             } 416:         } 417:     } ```  The graph below represents the amount of GMX tokens Alice and Bob staked in `PirexGmx` for each second during the period. Note that the graph is not drawn proportionally.  Green = Number of GMX tokens staked by Alice  Blue = Number of GMX tokens staked by Bob  ![](https://user-images.githubusercontent.com/102820284/204132852-f76c8959-5040-46bf-9529-edd0d4a98e41.png)  Based on the above graph:  - Alice staked 1 GMX token for 4 seconds (From T80 to T85) - Bob staked 99999 GMX tokens for 4 seconds (From T80 to T85)  Assume that the emission rate is 0.1 esGMX per 1 GMX staked per second.  In this case, the state variable will be as follows at the end of T83, assuming both the global and all user states have been updated and rewards have been harvested.  - rewardState = 60,000 esGMX tokens (600,000 * 0.1) - globalRewards = 600,000 (100,000 * 6) - Accrued `userRewards` of Alice = 6 - Accrued `userRewards` of Bob = 599,994 (99,999 * 6)  Following is the description of `rewardState` for reference:  > The `rewardState` represents the total number of a specific ERC20 reward token (e.g. WETH or esGMX) held by a producer (e.g. pxGMX or pxGPL).  > > The `rewardState` of each reward token (e.g. WETH or esGMX) will increase whenever the rewards are harvested by the producer (e.g. `PirexRewards.harvest` is called). On the other hand, the `rewardState` will decrease if the users claim the rewards.  At the end of T85, Alice should be entitled to 1.2 esGMX tokens (0.2/sec * 6).  Following is the formula used in the `PirexRewards` contract to compute the number of reward tokens a user is entitled to.   ```solidity amount = (rewardState * userRewards) / globalRewards; ```  If Alice claims the rewards at the end of T85, she will get zero esGMX tokens instead of 1.2 esGMX tokens.  ```solidity amount = (rewardState * userRewards) / globalRewards; 60,000 * 6 / 600,000 360,000/600,000 = 0.6 = 0 ```  Since Alice's accrued rewards are cleared at Line 391 within the `PirexRewards.claim` function (`p.userStates[user].rewards = 0;`), Alice's accrued rewards will be lost. Alice will have to start accruing the rewards from zero after calling the `PirexRewards.claim` function.  Another side effect is that since the 1.2 esGMX tokens that belong to Alice are still in the contract, they will be claimed by other users.  ## Impact  Users who deposit too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the `PirexRewards.claim` function. Also, their accrued rewards will be cleared out (set to zero). Loss of reward tokens for the users.  Additionally, the `PirexRewards.claim` function is permissionless, and anyone can trigger the claim on behalf of any user. A malicious user could call the `PirexRewards.claim` function on behalf of a victim at the right time when the victim's accrued reward is small enough to cause a rounding error or precision loss, thus causing the victim accrued reward to be cleared out (set to zero).  ## Recommended Mitigation Steps  Following are some of the possible remediation actions:  #### 1. Use `RewardPerToken ` approach  Avoid calculating the rewards that the users are entitled based on the ratio of `userRewards` and `globalRewards`.  Instead, consider implementing the RewardPerToken for users and global, as seen in many of the well-established reward contracts below, which is not vulnerable to this issue:  - https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb81a3dc2e46536bb8af9c2bdc585f63425e/src/FlywheelCore.sol#L226 - https://github.com/Synthetixio/synthetix/blob/2cb4b23fe409af526de67dfbb84aae84b2b13747/contracts/StakingRewards.sol#L61  #### 2. Fallback logic if`amount ==  0`  If the `amount` is zero, revert the transaction. Alternatively, if the `amount` is zero, do not clear out the user's accrued reward state variable since the user did not receive anything yet.  ```diff function claim(ERC20 producerToken, address user) external { ..SNIP..    uint256 amount = (rewardState * userRewards) / globalRewards;     if (amount != 0) {     // Update reward state (i.e. amount) to reflect reward tokens transferred out     p.rewardStates[rewardToken] = rewardState - amount;      producer.claimUserReward(      address(rewardToken),      amount,      recipient     ); -   } +   } else { +    revert ZeroRewardTokens(); +   } ..SNIP.. } ```
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L73 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L152   # Vulnerability details  ## Proof of Concept  During initialization, the `AutoPxGMX` vault will grant max allowance to the platform (PirexGMX) to spend its GMX tokens in Line 97 of the constructor method below. This is required because the vault needs to deposit GMX tokens to the platform (PirexGMX) contract. During deposit, the platform (PirexGMX) contract will pull the GMX tokens within the vault and send them to GMX protocol for staking. Otherwise, the deposit feature within the vault will not work.  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L73  ```solidity File: AutoPxGmx.sol 73:     constructor( 74:         address _gmxBaseReward, 75:         address _gmx, 76:         address _asset, 77:         string memory _name, 78:         string memory _symbol, 79:         address _platform, 80:         address _rewardsModule 81:     ) Owned(msg.sender) PirexERC4626(ERC20(_asset), _name, _symbol) { 82:         if (_gmxBaseReward == address(0)) revert ZeroAddress(); 83:         if (_gmx == address(0)) revert ZeroAddress(); 84:         if (_asset == address(0)) revert ZeroAddress(); 85:         if (bytes(_name).length == 0) revert InvalidAssetParam(); 86:         if (bytes(_symbol).length == 0) revert InvalidAssetParam(); 87:         if (_platform == address(0)) revert ZeroAddress(); 88:         if (_rewardsModule == address(0)) revert ZeroAddress(); 89:  90:         gmxBaseReward = ERC20(_gmxBaseReward); 91:         gmx = ERC20(_gmx); 92:         platform = _platform; 93:         rewardsModule = _rewardsModule; 94:  95:         // Approve the Uniswap V3 router to manage our base reward (inbound swap token) 96:         gmxBaseReward.safeApprove(address(SWAP_ROUTER), type(uint256).max); 97:         gmx.safeApprove(_platform, type(uint256).max); 98:     } ```  However, when the owner calls the `AutoPxGmx.setPlatform` function to update the `platform` to a new address, it does not grant any allowance to the new platform address. As a result, the new platform (PirexGMX) will not be able to pull the GMX tokens from the vault. Thus, the deposit feature of the vault will break, and no one will be able to deposit.  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L152  ```solidity File: AutoPxGmx.sol 152:     function setPlatform(address _platform) external onlyOwner { 153:         if (_platform == address(0)) revert ZeroAddress(); 154:  155:         platform = _platform; 156:  157:         emit PlatformUpdated(_platform); 158:     } ```  ## Impact  The deposit feature of the vault will break, and no one will be able to deposit.  ## Recommended Mitigation Steps  Ensure that allowance is given to the new platform address so that it can pull the GMX tokens from the vault.  ```diff function setPlatform(address _platform) external onlyOwner {     if (_platform == address(0)) revert ZeroAddress(); +   if (_platform == platform) revert SamePlatformAddress();      +   gmx.safeApprove(platform, 0); // set the old platform approval amount to zero +   gmx.safeApprove(_platform, type(uint256).max); // approve the new platform contract address allowance to the max      platform = _platform;      emit PlatformUpdated(_platform); } ```
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L305 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L281 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373   # Vulnerability details  ## Background  The amount of rewards accrued by global and user states is computed by the following steps:  1. Calculate seconds elapsed since the last update (`block.timestamp - lastUpdate`) 2. Calculate the new rewards by multiplying seconds elapsed by the last supply (`(block.timestamp - lastUpdate) * lastSupply`) 3. Append the new rewards to the existing rewards (`rewards = rewards + (block.timestamp - lastUpdate) * lastSupply`)  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L305  ```solidity /**     @notice Update global accrual state     @param  globalState    GlobalState  Global state of the producer token     @param  producerToken  ERC20        Producer token contract */ function _globalAccrue(GlobalState storage globalState, ERC20 producerToken)  internal {     uint256 totalSupply = producerToken.totalSupply();     uint256 lastUpdate = globalState.lastUpdate;     uint256 lastSupply = globalState.lastSupply;      // Calculate rewards, the product of seconds elapsed and last supply     // Only calculate and update states when needed     if (block.timestamp != lastUpdate || totalSupply != lastSupply) {         uint256 rewards = globalState.rewards +             (block.timestamp - lastUpdate) *             lastSupply;                          globalState.lastUpdate = block.timestamp.safeCastTo32();             globalState.lastSupply = totalSupply.safeCastTo224();             globalState.rewards = rewards;     ..SNIP.. } ```  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L281  ```solidity /**     @notice Update user rewards accrual state     @param  producerToken  ERC20    Rewards-producing token     @param  user           address  User address */ function userAccrue(ERC20 producerToken, address user) public {     if (address(producerToken) == address(0)) revert ZeroAddress();     if (user == address(0)) revert ZeroAddress();      UserState storage u = producerTokens[producerToken].userStates[user];     uint256 balance = producerToken.balanceOf(user);      // Calculate the amount of rewards accrued by the user up to this call     uint256 rewards = u.rewards +     u.lastBalance *     (block.timestamp - u.lastUpdate);          u.lastUpdate = block.timestamp.safeCastTo32();     u.lastBalance = balance.safeCastTo224();     u.rewards = rewards;     ..SNIP.. } ```  When a user claims the rewards, the number of reward tokens the user is entitled to is equal to the `rewardState` scaled by the ratio of the `userRewards` to the `globalRewards`. Refer to Line 403 below.  The `rewardState` represents the total number of a specific ERC20 reward token (e.g. WETH or esGMX) held by a producer (e.g. pxGMX or pxGPL).   The `rewardState` of each reward token (e.g. WETH or esGMX) will increase whenever the rewards are harvested by the producer (e.g. `PirexRewards.harvest` is called). On the other hand, the `rewardState` will decrease if the users claim the rewards.  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373  ```solidity File: PirexRewards.sol 373:     function claim(ERC20 producerToken, address user) external { ..SNIP.. 395:             // Transfer the proportionate reward token amounts to the recipient 396:             for (uint256 i; i < rLen; ++i) { 397:                 ERC20 rewardToken = rewardTokens[i]; 398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken]; 399:                 address recipient = rewardRecipient != address(0) 400:                     ? rewardRecipient 401:                     : user; 402:                 uint256 rewardState = p.rewardStates[rewardToken]; 403:                 uint256 amount = (rewardState * userRewards) / globalRewards; ..SNIP.. 417:     } ```  #### How reward tokens are distributed  The Multiplier Point (MP) effect will be ignored for simplicity. Assume that the emission rate is constant throughout the entire period (from T80 to T84) and the emission rate is 1 esGMX per 1 GMX staked per second.  The graph below represents the amount of GMX tokens Alice and Bob staked for each second during the period.   A = Alice and B = Bob; each block represents 1 GMX token staked.  ![](https://user-images.githubusercontent.com/102820284/204132445-50422095-c02c-4f45-95d6-575667211092.png)  Based on the above graph:  - Alice staked 1 GMX token from T80 to T84. Alice will earn five (5) esGMX tokens at the end of T84. - Bob staked 4 GMX tokens from T83 to T84. Bob will earn eight (8) esGMX tokens at the end of T84. - A total of 13 esGMX will be harvested by `PirexRewards` contract at the end of T84  The existing reward distribution design in the `PirexRewards` contract will work perfectly if the emission rate is constant, similar to the example above.  In this case, the state variable will be as follows at the end of T84, assuming both the global and all user states have been updated and rewards have been harvested.  - rewardState = 13 esGMX tokens (5 + 8) - globalRewards = 13 - Accrued `userRewards` of Alice = 5 - Accrued `userRewards` of Bob = 8  When Alice calls the `PirexRewards.claim` function to claim her rewards at the end of T84, she will get back five (5) esGMX tokens, which is correct.  ```solidity (rewardState * userRewards) / globalRewards (13 * 5) / 13 = 5 ```  ## Proof of Concept  However, the fact is that the emission rate of reward tokens (e.g. esGMX or WETH) is not constant. Instead, the emission rate is dynamic and depends on various factors, such as the following:  - The number of rewards tokens allocated by GMX governance for each month. Refer to https://gov.gmx.io/t/esgmx-emissions/272. In some months, the number of esGMX emissions will be higher. - The number of GMX/GLP tokens staked by the community. The more tokens being staked by the community users, the more diluted the rewards will be.  The graph below represents the amount of GMX tokens Alice and Bob staked for each second during the period.   A = Alice and B = Bob; each block represents 1 GMX token staked.  ![](https://user-images.githubusercontent.com/102820284/204132445-50422095-c02c-4f45-95d6-575667211092.png)  The Multiplier Point (MP) effect will be ignored for simplicity. Assume that the emission rate is as follows:  - From T80 to 82: 2 esGMX per 1 GMX staked per second (Higher emission rate) - From T83 to 84: 1 esGMX per 1 GMX staked per second (Lower emission rate)  By manually computing the amount of esGMX reward tokens that Alice is entitled to at the end of T84:  ```solidity [1 staked GMX * (T82 - T80) * 2esGMX/sec] + [1 staked GMX * (T84 - T83) * 1esGMX/sec] [1 staked GMX * 3 secs * 2esGMX/sec] + [1 staked GMX * 2secs * 1esGMX/sec] 6 + 2 = 8 ```  Alice will be entitled to 8 esGMX reward tokens at the end of T84.  By manually computing the amount of esGMX reward tokens that Bob is entitled to at the end of T84:  ```solidity [4 staked GMX * 2secs * 1esGMX/sec] = 8 ```  Bob will be entitled to 8 esGMX reward tokens at the end of T84.  However, the existing reward distribution design in the `PirexRewards` contract will cause Alice to get fewer reward tokens than she is entitled to and cause Bob to get more rewards than he is entitled to.  The state variable will be as follows at the end of T84, assuming both the global and all user states have been updated and rewards have been harvested.  - rewardState = 16 esGMX tokens (8 + 8) - globalRewards = 13 - Accrued `userRewards` of Alice = 5 - Accrued `userRewards` of Bob = 8  When Alice calls the `PirexRewards.claim` function to claim her rewards at the end of T84, she will only get back six (6) esGMX tokens, which is less than eight (8) esGMX tokens she is entitled to or earned.  ```solidity (rewardState * userRewards) / globalRewards (16 * 5) / 13 = 6.15 = 6 ```  When Bob calls the `PirexRewards.claim` function to claim his rewards at the end of T84, he will get back nine (9) esGMX tokens, which is more than eight (8) esGMX tokens he is entitled to or earned.  ```solidity (rewardState * userRewards) / globalRewards (16 * 8) / 13 = 9.85 = 9 ```  ## Impact  As shown in the PoC, some users will lose their reward tokens due to the miscalculation within the existing reward distribution design.  ## Recommended Mitigation Steps  Update the existing reward distribution design to handle the dynamic emission rate. Implement the RewardPerToken for users and global, as seen in many of the well-established reward contracts below, which is not vulnerable to this issue:  - https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb81a3dc2e46536bb8af9c2bdc585f63425e/src/FlywheelCore.sol#L226 - https://github.com/Synthetixio/synthetix/blob/2cb4b23fe409af526de67dfbb84aae84b2b13747/contracts/StakingRewards.sol#L61
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/gzeon-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/codeislight-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/Rolezn-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/aphak5010-G.md).
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L615 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L685 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L712   # Vulnerability details  ## Impact The following 'redeem' related functions are likely to be blocked, users will not be able to retrieve their funds. ``` function _redeemPxGlp(     address token,     uint256 amount,     uint256 minOut,     address receiver ); function redeemPxGlpETH(     uint256 amount,     uint256 minOut,     address receiver ); function redeemPxGlp(     address token,     uint256 amount,     uint256 minOut,     address receiver ); ```  ## Proof of Concept The 'GlpManager' contract of GMX has a 'cooldownDuration' limit on redeem/unstake ('_removeLiquidity()'). While there is at least one deposit/stake ('_addLiquidity()') operation in the past 'cooldownDuration' time, redemption would fail. Obviously this limitation is user-based,  and 'PirexGmx' contract is one such user.  https://github.com/gmx-io/gmx-contracts/blob/c3618b0d6fc1b88819393dc7e6c785e32e78c72b/contracts/core/GlpManager.sol#L234  ``` Current setting of 'cooldownDuration' is 15 minutes, the max value is 2 days. ``` https://arbiscan.io/address/0x321f653eed006ad1c29d174e17d96351bde22649#readContract  Due to the above limit, there are 3 risks that can block redemption for Pirex users.  1.__The normal case__ Let's say there is 10% GMX users will use Pirex to manage their GLP.  By checking recent history of GMX router contract, we can find the average stake interval is smaller than 1 minute https://arbiscan.io/address/0xa906f338cb21815cbc4bc87ace9e68c87ef8d8f1 Let's take ``` averageStakeIntervalOfGMX = 30 seconds ``` So if Pirex has 10% of GMX users, then ``` averageStakeIntervalOfPirex = 30 ÷ 10% = 300 seconds ``` The probability of successfully redeeming is a typical Poisson distribution: https://en.wikipedia.org/wiki/Poisson_distribution With ``` λ = cooldownDuration ÷ averageStakeIntervalOfPirex = 15 * 60 ÷ 300 = 3 k = 0 ``` So we get ``` P ≈ 1 ÷ (2.718 * 2.718 * 2.718) ≈ 0.05  ``` Conclusion ``` If Pirex has 10 % of GMX users, then the redemption will fail with 95% probability. ```  A full list of % of GMX users versus failure probability of redemption ``` 1% : 26% 5% : 78% 10% : 95% 20% : 99.75% 30% : 99.98% ```  2.__The attack case__ If an attacker, such as bad competitors of similar projects, try to exploit this vulnerability. Let's estimate the cost for attack.  As attacker can deposit a very small GLP, such as 1 wei, so we can ignore the GLP cost and only focus on GAS cost.  By checking the explorer history https://arbiscan.io We are safe to assume the cost for calling 'depositGlpETH()' or 'depositGlp' is ``` txCost = 0.1 USD ```  To block redemption, attacker have to execute a deposit call every 15 minutes, so ``` dailyCost = 24 * (60 / 15) * 0.1 = 9.6 USD yearCost = 365 * 9.6 = 3504 USD ``` Conclusion ``` If an attacker want to block Pirex users funds, his yearly cost is only about 3.5k USD. ```  3.__GMX adjusts protocol parameters__ If GMX increases 'cooldownDuration' to 2 days, it will obviously cause redemption not working.  ## Tools Used VS Code  ## Recommended Mitigation Steps Reserve some time range for redemption only. e.g. 1 of every 7 days.
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L225 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L14 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L14 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L215-L216 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L332   # Vulnerability details  ## Impact The ERC-4626 Tokenized Vault Standard requires the `maxWithdraw` function to be implemented ([https://ethereum.org/en/developers/docs/standards/tokens/erc-4626/#maxwithdraw](https://ethereum.org/en/developers/docs/standards/tokens/erc-4626/#maxwithdraw)).    This function is supposed to return "the maximum amount of underlying assets that can be withdrawn from the owner balance with a single withdraw call".    The `PirexERC4626` contract implements this function ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L225](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L225)).   It is implemented correctly when `PirexERC4626` is used on its own.    However in this project, the `PirexERC4626` contract is not used on its own but inherited by `AutoPxGmx` ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L14](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L14)) and `AutoPxGlp` ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L14](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L14)).    `AutoPxGmx` and `AutoPxGlp` implement a `withdrawalPenalty` i.e. a fee that is paid when a user wants to withdraw assets from the vault.    `AutoPxGmx` and `AutoPxGlp` do not override the `maxWithdraw` function.    This causes the `maxWithdraw` function to return an amount of assets that is too big to be withdrawn.    So when `maxWithdraw` is called and with the returned amount `withdraw` is called, the call to `withdraw` will revert.    This can cause issues in any upstream components that rely on `AutoPxGmx` and `AutoPxGlp` to correctly implement the ERC4626 standard.    For example an upstream wrapper might only allow withdrawals with the maximum amount and determine this maximum amount by calling the `maxWithdraw` function. As this function returns a value that is too big, no withdrawals will be possible.    ## Proof of Concept 1. The `maxWithdraw` function in a `AutoPxGmx` contract is called 2. Now the `withdraw` function is called with the value that was returned by the `maxWithdraw` function ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315)) 3. The `withdraw` function in turn calls the `previewWithdraw` function ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199)) 4. The `previewWithdraw` function will increase the amount of shares to include the `withdrawalPenalty` ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L215-L216](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L215-L216)) which causes the amount of shares to burn to be too large and the call to `burn` will revert ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L332](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L332))  ## Tools Used VSCode  ## Recommended Mitigation Steps In the `AutoPxGmx` and `AutoPxGlp` function implement the `maxWithdraw` function that overrides the function in `PirexERC4626` and takes into account the `withdrawalPenalty`.    Potential fix: ```solidity function maxWithdraw(address owner) public view override returns (uint256) {     uint256 shares = balanceOf(owner);      // Calculate assets based on a user's % ownership of vault shares     uint256 assets = convertToAssets(shares);      uint256 _totalSupply = totalSupply;      // Calculate a penalty - zero if user is the last to withdraw     uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)         ? 0         : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);      // Redeemable amount is the post-penalty amount     return assets - penalty; } ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/chaduke-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/brgltd-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/jadezti-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/adriro-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/karanctf-G.md).
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L197-L296 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L230-L313   # Vulnerability details  ## Impact Function `compound()` in `AutoPxGmx` and `AutoPxGlp` contracts is for compounding `pxGLP` (and additionally `pxGMX`) rewards. it works by calling `PirexGmx.claim(px*, this)` to collect the rewards of the vault and then swap the received amount (to calculate the reward, contract save the balance of a contract in that reward token before and after the call to the `claim()` and by subtracting them finds the received reward amount) and deposit them in `PirexGmx` again for compounding and in doing so it calculates fee based on what it received and in `AutoPxGlp` case it calculates `pxGMX` rewards too based on the extra amount contract receives during the execution of `claim()`. but attacker can call `PirexGmx.claim(px*, PirexGlp)` directly and make `PirexGmx` contract to transfer (`gmxBaseReward` and `pxGmx`) rewards to `AutoPxGlp` and in this case the logics of fee calculation and reward calculation in `compound()` function won't get executed and contract won't get it's fee from rewards and users won't get their `pxGmx` reward. so this bug would cause fee loss in `AutoPxGmx` and `AutoPxGlp` for contract and `pxGmx`'s reward loss for users in `AutoPxGlp`.  ## Proof of Concept the bug in in `AutoPxGmx` is similar to `AutoPxGlp`, so we only give Proof of Concept for `AutoPxGlp`. This is `compound()` function code in `AutoPxGlp` contract: ```     function compound(         uint256 minUsdg,         uint256 minGlp,         bool optOutIncentive     )         public         returns (             uint256 gmxBaseRewardAmountIn,             uint256 pxGmxAmountOut,             uint256 pxGlpAmountOut,             uint256 totalPxGlpFee,             uint256 totalPxGmxFee,             uint256 pxGlpIncentive,             uint256 pxGmxIncentive         )     {         if (minUsdg == 0) revert InvalidParam();         if (minGlp == 0) revert InvalidParam();          uint256 preClaimTotalAssets = asset.balanceOf(address(this));         uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));          PirexRewards(rewardsModule).claim(asset, address(this));         PirexRewards(rewardsModule).claim(pxGmx, address(this));          // Track the amount of rewards received         gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));          if (gmxBaseRewardAmountIn != 0) {             // Deposit received rewards for pxGLP             (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(                 address(gmxBaseReward),                 gmxBaseRewardAmountIn,                 minUsdg,                 minGlp,                 address(this)             );         }          // Distribute fees if the amount of vault assets increased         uint256 newAssets = totalAssets() - preClaimTotalAssets;         if (newAssets != 0) {             totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;             pxGlpIncentive = optOutIncentive                 ? 0                 : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;              if (pxGlpIncentive != 0)                 asset.safeTransfer(msg.sender, pxGlpIncentive);              asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);         }          // Track the amount of pxGMX received         pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;          if (pxGmxAmountOut != 0) {             // Calculate and distribute pxGMX fees if the amount of pxGMX increased             totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;             pxGmxIncentive = optOutIncentive                 ? 0                 : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;              if (pxGmxIncentive != 0)                 pxGmx.safeTransfer(msg.sender, pxGmxIncentive);              pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);              // Update the pxGmx reward accrual             _harvest(pxGmxAmountOut - totalPxGmxFee);         } else {             // Required to keep the globalState up-to-date             _globalAccrue();         }          emit Compounded(             msg.sender,             minGlp,             gmxBaseRewardAmountIn,             pxGmxAmountOut,             pxGlpAmountOut,             totalPxGlpFee,             totalPxGmxFee,             pxGlpIncentive,             pxGmxIncentive         );     } ``` As you can see contract collects rewards by calling `PirexRewards.claim()` and in the line `uint256 newAssets = totalAssets() - preClaimTotalAssets;` contract calculates the received amount of rewards(by subtracting the balance after and before reward claim) and then calculates fee based on this amount `totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;` and then sends the fee in the line `asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive)` for `owner`. the logic for `pxGmx` rewards are the same. As you can see the calculation of fee is based on the rewards received, and there is no other logic in the contract to calculate and transfer the fee of protocol. so if `AutoPxGpl` receives rewards without `compound()` getting called then for those rewards fee won't be calculated and transferred and protocol would lose it's fee. In the line `_harvest(pxGmxAmountOut - totalPxGmxFee)` contract calls `_harvest()` function to update the `pxGmx` reward accrual and there is no call to `_harvest()` in any other place and this is the only place where `pxGmx` reward accrual gets updated. contract uses `pxGmxAmountOut` which is the amount of `gmx` contract received during the call (code calculates it by subtracting the balance after and before reward claim: `pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;`) so contract only handles accrual rewards in this function call and if some `pxGmx` rewards claimed for contract without `compund()` logic execution then those rewards won't be used in `_harvest()` and `_globalAccrue()` calculation and users won't receive those rewards. As mentioned attacker can call `PirexRewards.claim(pxGmx, AutoPxGpl)` directly and make `PirexRewads` contract to transfer `AutoPxGpl` rewards. This is `claim()` code in `PirexRewards`: ```     function claim(ERC20 producerToken, address user) external {         if (address(producerToken) == address(0)) revert ZeroAddress();         if (user == address(0)) revert ZeroAddress();          harvest();         userAccrue(producerToken, user);          ProducerToken storage p = producerTokens[producerToken];         uint256 globalRewards = p.globalState.rewards;         uint256 userRewards = p.userStates[user].rewards;          // Claim should be skipped and not reverted on zero global/user reward         if (globalRewards != 0 && userRewards != 0) {             ERC20[] memory rewardTokens = p.rewardTokens;             uint256 rLen = rewardTokens.length;              // Update global and user reward states to reflect the claim             p.globalState.rewards = globalRewards - userRewards;             p.userStates[user].rewards = 0;              emit Claim(producerToken, user);              // Transfer the proportionate reward token amounts to the recipient             for (uint256 i; i < rLen; ++i) {                 ERC20 rewardToken = rewardTokens[i];                 address rewardRecipient = p.rewardRecipients[user][rewardToken];                 address recipient = rewardRecipient != address(0)                     ? rewardRecipient                     : user;                 uint256 rewardState = p.rewardStates[rewardToken];                 uint256 amount = (rewardState * userRewards) / globalRewards;                  if (amount != 0) {                     // Update reward state (i.e. amount) to reflect reward tokens transferred out                     p.rewardStates[rewardToken] = rewardState - amount;                      producer.claimUserReward(                         address(rewardToken),                         amount,                         recipient                     );                 }             }         }     } ``` As you can see it can be called by anyone for any user. so to perform this attack, attacker would perform this steps: 1. suppose `AutoPxGpl` has pending rewards, for example 100 `pxGmx` and 100 `weth`. 2. attacker would call  `PirexRewards.claim(pxGmx, AutoPxGpl)` and  `PirexRewards.claim(pxGpl, AutoPxGpl)` and `PirexRewards` contract would calculate and claim and transfer `pxGmx` rewards and `weth` rewards of `AutoPxGpl` address. 3. then `AutoPxGpl` has no pending rewards but the balance of `pxGmx` and `weth` of contract has been increased. 4. if anyone call `AutoPxGpl.compound()` because there is no pending rewards contract would receive no rewards and because contract only calculates fee and rewards based on received rewards during the call to `compound()` so contract wouldn't calculate any fee or reward accrual for those 1000 `pxGmx` and `weth` rewards. 5. `owner` of `AutoPxGpl` would lose his fee for those rewards and users of `AutoPxGpl` would lose their claims for those 1000 `pxGmx` rewards (because the calculation for them didn't happen).  This bug is because of the fact that the only logic handling rewards is in `compound()` function which is only handling receiving rewards by calling `claim()` during the call to `compound()` but it's possible to call `claim()` directly (`PirexRewards` contract allows this) and `AutoPxGpl` won't get notified about this new rewards and the related logics won't get executed.  ## Tools Used VIM  ## Recommended Mitigation Steps contract should keep track of it's previous balance when `compound()` get executed and update this balance in deposits and withdraws and claims so it can detect rewards that directly transferred to contract without call to `compound()`.
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/0xfuje-Q.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/keccak123-G.md).
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L940-L949   # Vulnerability details  ## Impact  PirexGmx#migrateReward() may cause users to lose Reward. before PirexRewards.sol set new PirexGmx  ## Proof of Concept  The current migration process is: call # completemigration ()-> # migrateward ()  After this method, the producer of PirexRewards.sol contract is still the old PirexGmx.   At this time, if AutoPxGmx#compound () is called by bot:  AutoPxGmx#compound() -> PirexRewards#.claim() -> old_PirexGmx#claimRewards()  Old_PirexGmx#claimRewards () will return zero rewards  and the reward of AutopXGMX will be lost.   old PirexGmx still can execute https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L824-L828  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L940-L949  ## Tools Used  ## Recommended Mitigation Steps  There are two ways to solve the problem. 1. set the producer of PirexRewards to the new PirexGmx in completeMigration (). 2. In #migrateReward (), set the old PirexGmx's "pirexRewards" to address(0), so that you can't use the old PirexGmx to get rewards  Simply use the second, such as: ```solidity     function migrateReward() external whenPaused {         if (msg.sender != migratedTo) revert NotMigratedTo();         if (gmxRewardRouterV2.pendingReceivers(address(this)) != address(0))             revert PendingMigration();          // Transfer out any remaining base reward (ie. WETH) to the new contract         gmxBaseReward.safeTransfer(             migratedTo,             gmxBaseReward.balanceOf(address(this))         ); +       pirexRewards ==address(0);   //*** set pirexRewards=0,Avoid claimRewards () being called by mistake.***//     } ``` ``` 
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L733-L816 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L228-L267 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L332-L348   # Vulnerability details  ## Impact Function `claimRewards()` in `PirexGmx` claims WETH and esGMX rewards and multiplier points (MP) from GMX protocol. it uses `_calculateRewards()` to calculate the unclaimed reward token amounts produced for each token type. but because of the lack of checks, function `_calculateRewards()` would revert when `RewardTracker.distributor.totalSupply()` is zero so if any of 4 `RewardTracker`s has zero `totalSupply()` then function `claimRewards()` would revert too and function `harvest()` in `PirexRewards` contract would revert too because it calls `PirexGmx.claimRewards()`. `harvest()` is used in `claim()` function so `claim()` would not work too. This bug would harvesting rewards for `PirexRewards` contract and claiming reward for users from `PirexRewards` when supply of one of `RewardTracker`s contracts in GMX protocol is zero. Function `claimRewards()` is written based on GMX code, but the logic is not correctly copied because in GMX protocol contract checks for `totalSupply()` and it prevents this bug from happening.  ## Proof of Concept This is function `_calculateRewards()`'s code in `PirexGmx`: ```    function _calculateRewards(bool isBaseReward, bool useGmx)         internal         view         returns (uint256)     {         RewardTracker r;          if (isBaseReward) {             r = useGmx ? rewardTrackerGmx : rewardTrackerGlp;         } else {             r = useGmx ? stakedGmx : feeStakedGlp;         }          address distributor = r.distributor();         uint256 pendingRewards = IRewardDistributor(distributor)             .pendingRewards();         uint256 distributorBalance = (isBaseReward ? gmxBaseReward : esGmx)             .balanceOf(distributor);         uint256 blockReward = pendingRewards > distributorBalance             ? distributorBalance             : pendingRewards;         uint256 precision = r.PRECISION();         uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() +             ((blockReward * precision) / r.totalSupply());          if (cumulativeRewardPerToken == 0) return 0;          return             r.claimableReward(address(this)) +             ((r.stakedAmounts(address(this)) *                 (cumulativeRewardPerToken -                     r.previousCumulatedRewardPerToken(address(this)))) /                 precision);     } ``` As you can see in the line `uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() + ((blockReward * precision) / r.totalSupply())` if `totalSupply()` was zero then code would revert because of division by zero error. so if `RewardTracker.distributor.totalSupply()` was zero then function `_calculateRewards` would revert and won't work and other function using `_calculateRewards()` would be break too.  This is part of function `claimRewards()`'s code in `PirexGmx` contract: ```     function claimRewards()         external         onlyPirexRewards         returns (             ERC20[] memory producerTokens,             ERC20[] memory rewardTokens,             uint256[] memory rewardAmounts         )     {         // Assign return values used by the PirexRewards contract         producerTokens = new ERC20[](4);         rewardTokens = new ERC20[](4);         rewardAmounts = new uint256[](4);         producerTokens[0] = pxGmx;         producerTokens[1] = pxGlp;         producerTokens[2] = pxGmx;         producerTokens[3] = pxGlp;         rewardTokens[0] = gmxBaseReward;         rewardTokens[1] = gmxBaseReward;         rewardTokens[2] = ERC20(pxGmx); // esGMX rewards distributed as pxGMX         rewardTokens[3] = ERC20(pxGmx);          // Get pre-reward claim reward token balances to calculate actual amount received         uint256 baseRewardBeforeClaim = gmxBaseReward.balanceOf(address(this));         uint256 esGmxBeforeClaim = stakedGmx.depositBalances(             address(this),             address(esGmx)         );          // Calculate the unclaimed reward token amounts produced for each token type         uint256 gmxBaseRewards = _calculateRewards(true, true);         uint256 glpBaseRewards = _calculateRewards(true, false);         uint256 gmxEsGmxRewards = _calculateRewards(false, true);         uint256 glpEsGmxRewards = _calculateRewards(false, false); ``` As you can see it calls `_calculateRewards()` to calculate  the unclaimed reward token amounts  produced for each token type in GMX protocol. so function `claimRewards()` would revert too when `totalSupply()` of one of these 4 `RewardTracker`'s distributers was zero. This is part of functions `harvest()` and `claim()` code in `PirexReward` contract: ```     function harvest()         public         returns (             ERC20[] memory _producerTokens,             ERC20[] memory rewardTokens,             uint256[] memory rewardAmounts         )     {         (_producerTokens, rewardTokens, rewardAmounts) = producer             .claimRewards();         uint256 pLen = _producerTokens.length; ....... ...... ......       function claim(ERC20 producerToken, address user) external {         if (address(producerToken) == address(0)) revert ZeroAddress();         if (user == address(0)) revert ZeroAddress();          harvest();         userAccrue(producerToken, user); .... .... .... ``` As you can see `harvest()` calls `claimRewards()` and `claim()` calls `harvest()` so these two function would revert and won't work when `totalSupply()` of one of these 4 `RewardTracker`'s distributers in GMX protocol was zero. in that situation the protocol can't harvest and claim rewards from GMX because of this bug and users won't be able to claim their rewards from the protocol. the condition for this bug could happen from time to time as GMX decided to prevent it by checking the value of `totalSupply()`. This is function `_updateRewards()` code in `RewardTracker` in GMX protocol (https://github.com/gmx-io/gmx-contracts/blob/65e62b62aadea5baca48b8157acb9351249dbaf1/contracts/staking/RewardTracker.sol#L272-L286): ```     function _updateRewards(address _account) private {         uint256 blockReward = IRewardDistributor(distributor).distribute();          uint256 supply = totalSupply;         uint256 _cumulativeRewardPerToken = cumulativeRewardPerToken;         if (supply > 0 && blockReward > 0) {             _cumulativeRewardPerToken = _cumulativeRewardPerToken.add(blockReward.mul(PRECISION).div(supply));             cumulativeRewardPerToken = _cumulativeRewardPerToken;         }          // cumulativeRewardPerToken can only increase .... .... ``` As you can see it checks that `supply > 0` before using it as denominator in division. So GMX protocol handles the case when `totalSupply()` is zero and contract logics won't break when this case happens but function `_calculateRewards()` which tries to calculate GMX protocol rewards beforehand don't handle this case(the case where `totalSupply()` is zero) so the logics would break when this case happens and it would cause function `harvest()` and `claim()` to be unfunctional.  ## Tools Used VIM  ## Recommended Mitigation Steps check that `totalSupply()` is not zero before using it.
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L269-L293 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L346-L355   # Vulnerability details  ## Impact Function `configureGmxState()` of `PirexGmx` is for configuring GMX contract state but logic is using `safeApprove()` improperly, it won't reset approval amount for old `stakedGmx` address This would cause 4 problem: 1. different behavior in `setContract()` and `configureGmxState()` for handling `stakeGmx` address changes. in `setContract()` the logic reset approval for old address to zero but in `configureGmxState()` the logic don't reset old address GMX spending approval. 2. the call to this function would revert if `stakeGmx` address didn't changed but other addresses has been changed so `owner` can't use this to configure contract. 3. contract won't reset approval for old `stakedGmx` addresse which is a threat because contract in that address can steal all the GMX balance any time in the future if that old address had been compromised. 4. contract won't reset approval for old `stakedGmx` addresse, if `owner` use `configureGmxState()` to change the `stakeGmx` value then it won't be possible to set `stakedGmx` value to previous ones by using either `configureGmxState()` or `setContract()` and contract would be in broken state.   ## Proof of Concept This is `configureGmxState()` code in `PirexGmx`: ```     /**         @notice Configure GMX contract state      */     function configureGmxState() external onlyOwner whenPaused {         // Variables which can be assigned by reading previously-set GMX contracts         rewardTrackerGmx = RewardTracker(gmxRewardRouterV2.feeGmxTracker());         rewardTrackerGlp = RewardTracker(gmxRewardRouterV2.feeGlpTracker());         feeStakedGlp = RewardTracker(gmxRewardRouterV2.stakedGlpTracker());         stakedGmx = RewardTracker(gmxRewardRouterV2.stakedGmxTracker());         glpManager = gmxRewardRouterV2.glpManager();         gmxVault = IVault(IGlpManager(glpManager).vault());          emit ConfigureGmxState(             msg.sender,             rewardTrackerGmx,             rewardTrackerGlp,             feeStakedGlp,             stakedGmx,             glpManager,             gmxVault         );          // Approve GMX to enable staking         gmx.safeApprove(address(stakedGmx), type(uint256).max);     } ``` As you can see it just sets the approval for new `stakeGmx` address and don't do anything about spending approval of old `stakeGmx` address. This is part of the `setContract()` code that handels `stakeGmx`: ```         if (c == Contracts.StakedGmx) {             // Set the current stakedGmx (pending change) approval amount to 0             gmx.safeApprove(address(stakedGmx), 0);              stakedGmx = RewardTracker(contractAddress);              // Approve the new stakedGmx contract address allowance to the max             gmx.safeApprove(contractAddress, type(uint256).max);             return;         } ``` As you can see it resets the spending approval of old `stakedGmx` address to zero and then give unlimited spending approval for new address. So the impact #1 is obvious that the code for same logic in two different functions don't beehive similarly.  Function `configureGmxState()` is used for configuring GMX contract state but if `owner` uses this function one time then it won't be possible to call this function the second time if `stakedGmx` wasn't changed. for example in this scenario: 1. owner calls `configureGmxState()` to set values for GMX contract addresses. 2. then address of one of contract changes in GMX (`stakedGmx` stayed the same) and owner want's to call `configureGmxState()` to reset the values of variables to correct ones. 3. owner call to `configureGmxState()` would fail because `stakedGmx` address didn't changed and in the line ` gmx.safeApprove(address(stakedGmx), type(uint256).max);` contract tries to set non zero approval for `stakedGmx` but it already has non zero spending allowance. (`safeApprove()` would revert if the current spending allowance is not zero and the new allowance is not zero either). so the impact #2 would happen and calls to this function in some scenarios would fail and it won't be functional.  Because function `configureGmxState()` don't reset the old `stakeGmx` address's GMX token spending approval to 0x0 so it would be possible to lose all GMX balance of `PirexGmx` contract if the old `stakeGmx` addresses are compromised. for example in this scenario: 1. GMX protocol get hacked(either by a bug or leaking some private keys) and `stakeGmx` contract control would be in hacker's hand. 2. GMX deploy new contracts and `stakeGmx` address changes in GMX. () 3. owner of `PirexGmx` calls `configureGmxState()` to reset the values of GMX contracts addresses in `PirexGmx`.  4. function `configureGmxState()` logic would change the GMX contract addresses but it won't set GMX token spending approval for old `stakeGmx` address to zero. 5. hacker who control the old `stakeGmx` address would use his access to that address contract to withdraw GMX balance of `PirexGmx`. because `PirexGmx` won't set approval for old `stakeGmx` contract so it would be possible for that old `stakeGmx` address to transfer GMX balance of `PirexGmx` anytime in future. the bug in old `stakeGmx` contract or leakage of private keys of `stakeGmx` address(private key who can become the owner or admin of that contract) can be happen after migrating GMX and Pirex contracts too. This is impact #3 scenario.  in scenario #4 contract would stuck in unrecoverable state. the problem is that if `configureGmxState()` is get used more than once and `stakeGmx` variable's value has been changes more than once then it won't be possible to set `stakeGmx` value to old values either with `configureGmxState()` or `setContract()` and the contract won't be useful. the scenario is this: (`safeApprove()` won't allow to set non-zero approval for address that has already non-zero approval amount. see the OZ implementation) 1. GMX protocol changes its `stakeGmx` contract address from old address to new (for any reason, they got hacked or they are migrating or ....) 2. `owner` of `PirexGmx` calls `configureGmxState()` to update GMX protocol's contract address in `PirexGmx` contract and the logic would update the values of variables. (the GMX spending approval for old and new `stakeGmx` address would be max value). 3. GMX protocol changes `stakeGmx` contract address from new value to old value (for any reason, they decided to roll back to old address) 4. owner tries to call `configureGmxState()` to reupdate GMX protocol's address in `PirexGmx` but the call would revert because the code tries to call `safeApprove()` for address that has already non-zero allowance. 5. owner can't call `setContract()` to update value of `stakeGmx` variable because this function tries to call `safeApprove()` to set non-zero approval value for address that already has non-zero allowance. so in this state `owner` can't recover `PirexGmx` contract and because contract has wrong value for `stakeGmx` it won't be functional and it would stay in broken state.   ## Tools Used VIM  ## Recommended Mitigation Steps like `setContract()`, function `configureGmxState()` should set approval for old `PirexGmx` to zero first.
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L367 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L583   # Vulnerability details  ## Impact In ``PirexGmx`` and ``AutoPxGlp`` you have function ``depositGlp()``, which accepts any ERC20 token from whitelist Now there are 9 tokens (see here: https://arbiscan.io/address/0x489ee077994b6658eafa855c308275ead8097c4a#readContract): ``WBTC, WETH, USDC, LINK, UNI, USDT, MIM, FRAX, DAI`` And the list may extend  So any user can deposit any of those tokens and receive pxGlp token: ```     function testUSDTDepositGlp() external {         // 0 USDT TOKENS         address myAddress = address(this);         assertEq(usdt.balanceOf(myAddress), 0);          // The one with many USDT tokens         vm.prank(0xB6CfcF89a7B22988bfC96632aC2A9D6daB60d641);         uint256 amount = 100000;         usdt.transfer(myAddress, amount);          // amount USDT TOKENS         assertEq(usdt.balanceOf(myAddress), amount);          // DEPOSIT USDT TOKENS         usdt.approve(address(pirexGmx), amount);         pirexGmx.depositGlp(address(usdt), amount, 1, 1, address(this));                  // SUCCESSSFULLY DEPOSITED         assertEq(usdt.balanceOf(address(this)), 0);         assertEq(pxGlp.balanceOf(address(this)), 118890025839780442);     } ```  But if of this tokens will start charge fee on transfers, the logic will be broken and calls to ``depositGlp()`` with suck token will fail  Because here you use the amount of tokens sent from user wallet: https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L512 ```             t.safeTransferFrom(msg.sender, address(this), tokenAmount);              // Mint and stake GLP using ERC20 tokens             deposited = gmxRewardRouterV2.mintAndStakeGlp(                 token,                 tokenAmount,                 minUsdg,                 minGlp             ); ``` And then ``gmxRewardRouterV2`` tries to transfer tokens to his balance from your balance:  ``` IERC20(_token).safeTransferFrom(_fundingAccount, address(vault), _amount); ```  (See https://arbiscan.io/address/0x321f653eed006ad1c29d174e17d96351bde22649#code - GlpManager and https://arbiscan.io/address/0xA906F338CB21815cBc4Bc87ace9e68c87eF8d8F1#code - RewardRouterV2)   But you received less than ``tokenAmount`` tokens because of fee. And transaction will fail   ## Proof of Concept Let's imagine USDT in arbitrub started to charge fees 1% per transfer  Alice wants to deposit 100 USDT through ``PirexGmx.depositGlp()`` Then you do  ``t.safeTransferFrom(Alice, address(this), 100);`` You will receive only 99 USDT  But in the next line you will try to send 100 USDT: ``` deposited = gmxRewardRouterV2.mintAndStakeGlp(                 token,                 tokenAmount,                 minUsdg,                 minGlp             ); ```  So transaction fails and Alice can't get pxGlp tokens    ## Tools Used  vs code  ## Recommended Mitigation Steps  USDT already has fees in other blockchains.  Many of these tokens use proxy pattern (and USDT too). It's quite probably that in one day one of the tokens will start charge fees. Or you would like to add one more token to whitelist and the token will be with fees  Thats why I consider finding as medium severity   To avoid problems, use common pattern, when you check your balance before operation and balance after, like that:  ```             uint256 balanceBefore = t.balanceOf(address(this));             t.safeTransferFrom(msg.sender, address(this), tokenAmount);             uint256 balanceAfter = t.balanceOf(address(this));              uint256 tokenAmount = balanceAfter - balanceBefore;              // Mint and stake GLP using ERC20 tokens             deposited = gmxRewardRouterV2.mintAndStakeGlp(                 token,                 tokenAmount,                 minUsdg,                 minGlp             ); ``` 
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373   # Vulnerability details  ## Proof of Concept  If the user deposits too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the `PirexRewards.claim` function. Subsequently, their accrued rewards will be cleared out (set to zero), and they will lose their rewards.  The amount of reward tokens that are claimable by a user is computed in Line 403 of the `PirexRewards.claim` function.  If the balance of pxGMX of a user is too small compared to other users (or total supply of pxGMX), the code below will always return zero due to rounding issues within solidity.  ```solidity uint256 amount = (rewardState * userRewards) / globalRewards; ```  Since the user's accrued rewards is cleared at Line 391 within the `PirexRewards.claim` function (`p.userStates[user].rewards = 0;`), the user's accrued rewards will be lost.  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373  ```solidity File: PirexRewards.sol 368:     /** 369:         @notice Claim rewards 370:         @param  producerToken  ERC20    Producer token contract 371:         @param  user           address  User 372:     */ 373:     function claim(ERC20 producerToken, address user) external { 374:         if (address(producerToken) == address(0)) revert ZeroAddress(); 375:         if (user == address(0)) revert ZeroAddress(); 376:  377:         harvest(); 378:         userAccrue(producerToken, user); 379:  380:         ProducerToken storage p = producerTokens[producerToken]; 381:         uint256 globalRewards = p.globalState.rewards; 382:         uint256 userRewards = p.userStates[user].rewards; 383:  384:         // Claim should be skipped and not reverted on zero global/user reward 385:         if (globalRewards != 0 && userRewards != 0) { 386:             ERC20[] memory rewardTokens = p.rewardTokens; 387:             uint256 rLen = rewardTokens.length; 388:  389:             // Update global and user reward states to reflect the claim 390:             p.globalState.rewards = globalRewards - userRewards; 391:             p.userStates[user].rewards = 0; 392:  393:             emit Claim(producerToken, user); 394:  395:             // Transfer the proportionate reward token amounts to the recipient 396:             for (uint256 i; i < rLen; ++i) { 397:                 ERC20 rewardToken = rewardTokens[i]; 398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken]; 399:                 address recipient = rewardRecipient != address(0) 400:                     ? rewardRecipient 401:                     : user; 402:                 uint256 rewardState = p.rewardStates[rewardToken]; 403:                 uint256 amount = (rewardState * userRewards) / globalRewards; 404:  405:                 if (amount != 0) { 406:                     // Update reward state (i.e. amount) to reflect reward tokens transferred out 407:                     p.rewardStates[rewardToken] = rewardState - amount; 408:  409:                     producer.claimUserReward( 410:                         address(rewardToken), 411:                         amount, 412:                         recipient 413:                     ); 414:                 } 415:             } 416:         } 417:     } ```  The graph below represents the amount of GMX tokens Alice and Bob staked in `PirexGmx` for each second during the period. Note that the graph is not drawn proportionally.  Green = Number of GMX tokens staked by Alice  Blue = Number of GMX tokens staked by Bob  ![](https://user-images.githubusercontent.com/102820284/204132852-f76c8959-5040-46bf-9529-edd0d4a98e41.png)  Based on the above graph:  - Alice staked 1 GMX token for 4 seconds (From T80 to T85) - Bob staked 99999 GMX tokens for 4 seconds (From T80 to T85)  Assume that the emission rate is 0.1 esGMX per 1 GMX staked per second.  In this case, the state variable will be as follows at the end of T83, assuming both the global and all user states have been updated and rewards have been harvested.  - rewardState = 60,000 esGMX tokens (600,000 * 0.1) - globalRewards = 600,000 (100,000 * 6) - Accrued `userRewards` of Alice = 6 - Accrued `userRewards` of Bob = 599,994 (99,999 * 6)  Following is the description of `rewardState` for reference:  > The `rewardState` represents the total number of a specific ERC20 reward token (e.g. WETH or esGMX) held by a producer (e.g. pxGMX or pxGPL).  > > The `rewardState` of each reward token (e.g. WETH or esGMX) will increase whenever the rewards are harvested by the producer (e.g. `PirexRewards.harvest` is called). On the other hand, the `rewardState` will decrease if the users claim the rewards.  At the end of T85, Alice should be entitled to 1.2 esGMX tokens (0.2/sec * 6).  Following is the formula used in the `PirexRewards` contract to compute the number of reward tokens a user is entitled to.   ```solidity amount = (rewardState * userRewards) / globalRewards; ```  If Alice claims the rewards at the end of T85, she will get zero esGMX tokens instead of 1.2 esGMX tokens.  ```solidity amount = (rewardState * userRewards) / globalRewards; 60,000 * 6 / 600,000 360,000/600,000 = 0.6 = 0 ```  Since Alice's accrued rewards are cleared at Line 391 within the `PirexRewards.claim` function (`p.userStates[user].rewards = 0;`), Alice's accrued rewards will be lost. Alice will have to start accruing the rewards from zero after calling the `PirexRewards.claim` function.  Another side effect is that since the 1.2 esGMX tokens that belong to Alice are still in the contract, they will be claimed by other users.  ## Impact  Users who deposit too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the `PirexRewards.claim` function. Also, their accrued rewards will be cleared out (set to zero). Loss of reward tokens for the users.  Additionally, the `PirexRewards.claim` function is permissionless, and anyone can trigger the claim on behalf of any user. A malicious user could call the `PirexRewards.claim` function on behalf of a victim at the right time when the victim's accrued reward is small enough to cause a rounding error or precision loss, thus causing the victim accrued reward to be cleared out (set to zero).  ## Recommended Mitigation Steps  Following are some of the possible remediation actions:  #### 1. Use `RewardPerToken ` approach  Avoid calculating the rewards that the users are entitled based on the ratio of `userRewards` and `globalRewards`.  Instead, consider implementing the RewardPerToken for users and global, as seen in many of the well-established reward contracts below, which is not vulnerable to this issue:  - https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb81a3dc2e46536bb8af9c2bdc585f63425e/src/FlywheelCore.sol#L226 - https://github.com/Synthetixio/synthetix/blob/2cb4b23fe409af526de67dfbb84aae84b2b13747/contracts/StakingRewards.sol#L61  #### 2. Fallback logic if`amount ==  0`  If the `amount` is zero, revert the transaction. Alternatively, if the `amount` is zero, do not clear out the user's accrued reward state variable since the user did not receive anything yet.  ```diff function claim(ERC20 producerToken, address user) external { ..SNIP..    uint256 amount = (rewardState * userRewards) / globalRewards;     if (amount != 0) {     // Update reward state (i.e. amount) to reflect reward tokens transferred out     p.rewardStates[rewardToken] = rewardState - amount;      producer.claimUserReward(      address(rewardToken),      amount,      recipient     ); -   } +   } else { +    revert ZeroRewardTokens(); +   } ..SNIP.. } ```
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L73 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L152   # Vulnerability details  ## Proof of Concept  During initialization, the `AutoPxGMX` vault will grant max allowance to the platform (PirexGMX) to spend its GMX tokens in Line 97 of the constructor method below. This is required because the vault needs to deposit GMX tokens to the platform (PirexGMX) contract. During deposit, the platform (PirexGMX) contract will pull the GMX tokens within the vault and send them to GMX protocol for staking. Otherwise, the deposit feature within the vault will not work.  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L73  ```solidity File: AutoPxGmx.sol 73:     constructor( 74:         address _gmxBaseReward, 75:         address _gmx, 76:         address _asset, 77:         string memory _name, 78:         string memory _symbol, 79:         address _platform, 80:         address _rewardsModule 81:     ) Owned(msg.sender) PirexERC4626(ERC20(_asset), _name, _symbol) { 82:         if (_gmxBaseReward == address(0)) revert ZeroAddress(); 83:         if (_gmx == address(0)) revert ZeroAddress(); 84:         if (_asset == address(0)) revert ZeroAddress(); 85:         if (bytes(_name).length == 0) revert InvalidAssetParam(); 86:         if (bytes(_symbol).length == 0) revert InvalidAssetParam(); 87:         if (_platform == address(0)) revert ZeroAddress(); 88:         if (_rewardsModule == address(0)) revert ZeroAddress(); 89:  90:         gmxBaseReward = ERC20(_gmxBaseReward); 91:         gmx = ERC20(_gmx); 92:         platform = _platform; 93:         rewardsModule = _rewardsModule; 94:  95:         // Approve the Uniswap V3 router to manage our base reward (inbound swap token) 96:         gmxBaseReward.safeApprove(address(SWAP_ROUTER), type(uint256).max); 97:         gmx.safeApprove(_platform, type(uint256).max); 98:     } ```  However, when the owner calls the `AutoPxGmx.setPlatform` function to update the `platform` to a new address, it does not grant any allowance to the new platform address. As a result, the new platform (PirexGMX) will not be able to pull the GMX tokens from the vault. Thus, the deposit feature of the vault will break, and no one will be able to deposit.  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L152  ```solidity File: AutoPxGmx.sol 152:     function setPlatform(address _platform) external onlyOwner { 153:         if (_platform == address(0)) revert ZeroAddress(); 154:  155:         platform = _platform; 156:  157:         emit PlatformUpdated(_platform); 158:     } ```  ## Impact  The deposit feature of the vault will break, and no one will be able to deposit.  ## Recommended Mitigation Steps  Ensure that allowance is given to the new platform address so that it can pull the GMX tokens from the vault.  ```diff function setPlatform(address _platform) external onlyOwner {     if (_platform == address(0)) revert ZeroAddress(); +   if (_platform == platform) revert SamePlatformAddress();      +   gmx.safeApprove(platform, 0); // set the old platform approval amount to zero +   gmx.safeApprove(_platform, type(uint256).max); // approve the new platform contract address allowance to the max      platform = _platform;      emit PlatformUpdated(_platform); } ```
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L305 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L281 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373   # Vulnerability details  ## Background  The amount of rewards accrued by global and user states is computed by the following steps:  1. Calculate seconds elapsed since the last update (`block.timestamp - lastUpdate`) 2. Calculate the new rewards by multiplying seconds elapsed by the last supply (`(block.timestamp - lastUpdate) * lastSupply`) 3. Append the new rewards to the existing rewards (`rewards = rewards + (block.timestamp - lastUpdate) * lastSupply`)  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L305  ```solidity /**     @notice Update global accrual state     @param  globalState    GlobalState  Global state of the producer token     @param  producerToken  ERC20        Producer token contract */ function _globalAccrue(GlobalState storage globalState, ERC20 producerToken)  internal {     uint256 totalSupply = producerToken.totalSupply();     uint256 lastUpdate = globalState.lastUpdate;     uint256 lastSupply = globalState.lastSupply;      // Calculate rewards, the product of seconds elapsed and last supply     // Only calculate and update states when needed     if (block.timestamp != lastUpdate || totalSupply != lastSupply) {         uint256 rewards = globalState.rewards +             (block.timestamp - lastUpdate) *             lastSupply;                          globalState.lastUpdate = block.timestamp.safeCastTo32();             globalState.lastSupply = totalSupply.safeCastTo224();             globalState.rewards = rewards;     ..SNIP.. } ```  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L281  ```solidity /**     @notice Update user rewards accrual state     @param  producerToken  ERC20    Rewards-producing token     @param  user           address  User address */ function userAccrue(ERC20 producerToken, address user) public {     if (address(producerToken) == address(0)) revert ZeroAddress();     if (user == address(0)) revert ZeroAddress();      UserState storage u = producerTokens[producerToken].userStates[user];     uint256 balance = producerToken.balanceOf(user);      // Calculate the amount of rewards accrued by the user up to this call     uint256 rewards = u.rewards +     u.lastBalance *     (block.timestamp - u.lastUpdate);          u.lastUpdate = block.timestamp.safeCastTo32();     u.lastBalance = balance.safeCastTo224();     u.rewards = rewards;     ..SNIP.. } ```  When a user claims the rewards, the number of reward tokens the user is entitled to is equal to the `rewardState` scaled by the ratio of the `userRewards` to the `globalRewards`. Refer to Line 403 below.  The `rewardState` represents the total number of a specific ERC20 reward token (e.g. WETH or esGMX) held by a producer (e.g. pxGMX or pxGPL).   The `rewardState` of each reward token (e.g. WETH or esGMX) will increase whenever the rewards are harvested by the producer (e.g. `PirexRewards.harvest` is called). On the other hand, the `rewardState` will decrease if the users claim the rewards.  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373  ```solidity File: PirexRewards.sol 373:     function claim(ERC20 producerToken, address user) external { ..SNIP.. 395:             // Transfer the proportionate reward token amounts to the recipient 396:             for (uint256 i; i < rLen; ++i) { 397:                 ERC20 rewardToken = rewardTokens[i]; 398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken]; 399:                 address recipient = rewardRecipient != address(0) 400:                     ? rewardRecipient 401:                     : user; 402:                 uint256 rewardState = p.rewardStates[rewardToken]; 403:                 uint256 amount = (rewardState * userRewards) / globalRewards; ..SNIP.. 417:     } ```  #### How reward tokens are distributed  The Multiplier Point (MP) effect will be ignored for simplicity. Assume that the emission rate is constant throughout the entire period (from T80 to T84) and the emission rate is 1 esGMX per 1 GMX staked per second.  The graph below represents the amount of GMX tokens Alice and Bob staked for each second during the period.   A = Alice and B = Bob; each block represents 1 GMX token staked.  ![](https://user-images.githubusercontent.com/102820284/204132445-50422095-c02c-4f45-95d6-575667211092.png)  Based on the above graph:  - Alice staked 1 GMX token from T80 to T84. Alice will earn five (5) esGMX tokens at the end of T84. - Bob staked 4 GMX tokens from T83 to T84. Bob will earn eight (8) esGMX tokens at the end of T84. - A total of 13 esGMX will be harvested by `PirexRewards` contract at the end of T84  The existing reward distribution design in the `PirexRewards` contract will work perfectly if the emission rate is constant, similar to the example above.  In this case, the state variable will be as follows at the end of T84, assuming both the global and all user states have been updated and rewards have been harvested.  - rewardState = 13 esGMX tokens (5 + 8) - globalRewards = 13 - Accrued `userRewards` of Alice = 5 - Accrued `userRewards` of Bob = 8  When Alice calls the `PirexRewards.claim` function to claim her rewards at the end of T84, she will get back five (5) esGMX tokens, which is correct.  ```solidity (rewardState * userRewards) / globalRewards (13 * 5) / 13 = 5 ```  ## Proof of Concept  However, the fact is that the emission rate of reward tokens (e.g. esGMX or WETH) is not constant. Instead, the emission rate is dynamic and depends on various factors, such as the following:  - The number of rewards tokens allocated by GMX governance for each month. Refer to https://gov.gmx.io/t/esgmx-emissions/272. In some months, the number of esGMX emissions will be higher. - The number of GMX/GLP tokens staked by the community. The more tokens being staked by the community users, the more diluted the rewards will be.  The graph below represents the amount of GMX tokens Alice and Bob staked for each second during the period.   A = Alice and B = Bob; each block represents 1 GMX token staked.  ![](https://user-images.githubusercontent.com/102820284/204132445-50422095-c02c-4f45-95d6-575667211092.png)  The Multiplier Point (MP) effect will be ignored for simplicity. Assume that the emission rate is as follows:  - From T80 to 82: 2 esGMX per 1 GMX staked per second (Higher emission rate) - From T83 to 84: 1 esGMX per 1 GMX staked per second (Lower emission rate)  By manually computing the amount of esGMX reward tokens that Alice is entitled to at the end of T84:  ```solidity [1 staked GMX * (T82 - T80) * 2esGMX/sec] + [1 staked GMX * (T84 - T83) * 1esGMX/sec] [1 staked GMX * 3 secs * 2esGMX/sec] + [1 staked GMX * 2secs * 1esGMX/sec] 6 + 2 = 8 ```  Alice will be entitled to 8 esGMX reward tokens at the end of T84.  By manually computing the amount of esGMX reward tokens that Bob is entitled to at the end of T84:  ```solidity [4 staked GMX * 2secs * 1esGMX/sec] = 8 ```  Bob will be entitled to 8 esGMX reward tokens at the end of T84.  However, the existing reward distribution design in the `PirexRewards` contract will cause Alice to get fewer reward tokens than she is entitled to and cause Bob to get more rewards than he is entitled to.  The state variable will be as follows at the end of T84, assuming both the global and all user states have been updated and rewards have been harvested.  - rewardState = 16 esGMX tokens (8 + 8) - globalRewards = 13 - Accrued `userRewards` of Alice = 5 - Accrued `userRewards` of Bob = 8  When Alice calls the `PirexRewards.claim` function to claim her rewards at the end of T84, she will only get back six (6) esGMX tokens, which is less than eight (8) esGMX tokens she is entitled to or earned.  ```solidity (rewardState * userRewards) / globalRewards (16 * 5) / 13 = 6.15 = 6 ```  When Bob calls the `PirexRewards.claim` function to claim his rewards at the end of T84, he will get back nine (9) esGMX tokens, which is more than eight (8) esGMX tokens he is entitled to or earned.  ```solidity (rewardState * userRewards) / globalRewards (16 * 8) / 13 = 9.85 = 9 ```  ## Impact  As shown in the PoC, some users will lose their reward tokens due to the miscalculation within the existing reward distribution design.  ## Recommended Mitigation Steps  Update the existing reward distribution design to handle the dynamic emission rate. Implement the RewardPerToken for users and global, as seen in many of the well-established reward contracts below, which is not vulnerable to this issue:  - https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb81a3dc2e46536bb8af9c2bdc585f63425e/src/FlywheelCore.sol#L226 - https://github.com/Synthetixio/synthetix/blob/2cb4b23fe409af526de67dfbb84aae84b2b13747/contracts/StakingRewards.sol#L61
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/gzeon-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/codeislight-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/Rolezn-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/aphak5010-G.md).
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L615 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L685 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L712   # Vulnerability details  ## Impact The following 'redeem' related functions are likely to be blocked, users will not be able to retrieve their funds. ``` function _redeemPxGlp(     address token,     uint256 amount,     uint256 minOut,     address receiver ); function redeemPxGlpETH(     uint256 amount,     uint256 minOut,     address receiver ); function redeemPxGlp(     address token,     uint256 amount,     uint256 minOut,     address receiver ); ```  ## Proof of Concept The 'GlpManager' contract of GMX has a 'cooldownDuration' limit on redeem/unstake ('_removeLiquidity()'). While there is at least one deposit/stake ('_addLiquidity()') operation in the past 'cooldownDuration' time, redemption would fail. Obviously this limitation is user-based,  and 'PirexGmx' contract is one such user.  https://github.com/gmx-io/gmx-contracts/blob/c3618b0d6fc1b88819393dc7e6c785e32e78c72b/contracts/core/GlpManager.sol#L234  ``` Current setting of 'cooldownDuration' is 15 minutes, the max value is 2 days. ``` https://arbiscan.io/address/0x321f653eed006ad1c29d174e17d96351bde22649#readContract  Due to the above limit, there are 3 risks that can block redemption for Pirex users.  1.__The normal case__ Let's say there is 10% GMX users will use Pirex to manage their GLP.  By checking recent history of GMX router contract, we can find the average stake interval is smaller than 1 minute https://arbiscan.io/address/0xa906f338cb21815cbc4bc87ace9e68c87ef8d8f1 Let's take ``` averageStakeIntervalOfGMX = 30 seconds ``` So if Pirex has 10% of GMX users, then ``` averageStakeIntervalOfPirex = 30 ÷ 10% = 300 seconds ``` The probability of successfully redeeming is a typical Poisson distribution: https://en.wikipedia.org/wiki/Poisson_distribution With ``` λ = cooldownDuration ÷ averageStakeIntervalOfPirex = 15 * 60 ÷ 300 = 3 k = 0 ``` So we get ``` P ≈ 1 ÷ (2.718 * 2.718 * 2.718) ≈ 0.05  ``` Conclusion ``` If Pirex has 10 % of GMX users, then the redemption will fail with 95% probability. ```  A full list of % of GMX users versus failure probability of redemption ``` 1% : 26% 5% : 78% 10% : 95% 20% : 99.75% 30% : 99.98% ```  2.__The attack case__ If an attacker, such as bad competitors of similar projects, try to exploit this vulnerability. Let's estimate the cost for attack.  As attacker can deposit a very small GLP, such as 1 wei, so we can ignore the GLP cost and only focus on GAS cost.  By checking the explorer history https://arbiscan.io We are safe to assume the cost for calling 'depositGlpETH()' or 'depositGlp' is ``` txCost = 0.1 USD ```  To block redemption, attacker have to execute a deposit call every 15 minutes, so ``` dailyCost = 24 * (60 / 15) * 0.1 = 9.6 USD yearCost = 365 * 9.6 = 3504 USD ``` Conclusion ``` If an attacker want to block Pirex users funds, his yearly cost is only about 3.5k USD. ```  3.__GMX adjusts protocol parameters__ If GMX increases 'cooldownDuration' to 2 days, it will obviously cause redemption not working.  ## Tools Used VS Code  ## Recommended Mitigation Steps Reserve some time range for redemption only. e.g. 1 of every 7 days.
# Lines of code  https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L225 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L14 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L14 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L215-L216 https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L332   # Vulnerability details  ## Impact The ERC-4626 Tokenized Vault Standard requires the `maxWithdraw` function to be implemented ([https://ethereum.org/en/developers/docs/standards/tokens/erc-4626/#maxwithdraw](https://ethereum.org/en/developers/docs/standards/tokens/erc-4626/#maxwithdraw)).    This function is supposed to return "the maximum amount of underlying assets that can be withdrawn from the owner balance with a single withdraw call".    The `PirexERC4626` contract implements this function ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L225](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L225)).   It is implemented correctly when `PirexERC4626` is used on its own.    However in this project, the `PirexERC4626` contract is not used on its own but inherited by `AutoPxGmx` ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L14](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L14)) and `AutoPxGlp` ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L14](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L14)).    `AutoPxGmx` and `AutoPxGlp` implement a `withdrawalPenalty` i.e. a fee that is paid when a user wants to withdraw assets from the vault.    `AutoPxGmx` and `AutoPxGlp` do not override the `maxWithdraw` function.    This causes the `maxWithdraw` function to return an amount of assets that is too big to be withdrawn.    So when `maxWithdraw` is called and with the returned amount `withdraw` is called, the call to `withdraw` will revert.    This can cause issues in any upstream components that rely on `AutoPxGmx` and `AutoPxGlp` to correctly implement the ERC4626 standard.    For example an upstream wrapper might only allow withdrawals with the maximum amount and determine this maximum amount by calling the `maxWithdraw` function. As this function returns a value that is too big, no withdrawals will be possible.    ## Proof of Concept 1. The `maxWithdraw` function in a `AutoPxGmx` contract is called 2. Now the `withdraw` function is called with the value that was returned by the `maxWithdraw` function ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315)) 3. The `withdraw` function in turn calls the `previewWithdraw` function ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199)) 4. The `previewWithdraw` function will increase the amount of shares to include the `withdrawalPenalty` ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L215-L216](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L215-L216)) which causes the amount of shares to burn to be too large and the call to `burn` will revert ([https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L332](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L332))  ## Tools Used VSCode  ## Recommended Mitigation Steps In the `AutoPxGmx` and `AutoPxGlp` function implement the `maxWithdraw` function that overrides the function in `PirexERC4626` and takes into account the `withdrawalPenalty`.    Potential fix: ```solidity function maxWithdraw(address owner) public view override returns (uint256) {     uint256 shares = balanceOf(owner);      // Calculate assets based on a user's % ownership of vault shares     uint256 assets = convertToAssets(shares);      uint256 _totalSupply = totalSupply;      // Calculate a penalty - zero if user is the last to withdraw     uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)         ? 0         : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);      // Redeemable amount is the post-penalty amount     return assets - penalty; } ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-11-redactedcartel-findings/blob/main/data/chaduke-G.md).
