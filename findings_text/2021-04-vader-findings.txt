# Handle  shw   # Vulnerability details  ## Impact  In `Router.sol`, the second `else if` statement in the function `swapWithSynthsWithLimit` is unnecessary.  ## Proof of Concept  Referenced code: [Router.sol#L162](https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L162)  ## Tools Used  None  ## Recommended Mitigation Steps  Consider using `else {...}`, which has the identical behavior to save gas.  
# Handle  paulius.eth   # Vulnerability details  ## Impact Both structs CollateralDetails and DebtDetails have unused ID field which is never set nor queried:    uint ID;  
# Handle  paulius.eth   # Vulnerability details  ## Impact In function updateAnchorPrice here 'arrayAnchors[i]' can be replaced with 'token' to eliminate one expensive storage access:    arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);  
# Handle  paulius.eth   # Vulnerability details  ## Impact Condition could be '>', not '>=' as there is no point in recalculating amount to the same value (waste of gas):  if((totalSupply + amount) >= maxSupply){   amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply  }  
# Handle  a_delamo   # Vulnerability details  Here you have more information: https://gist.github.com/alexon1234/5eb3fff3bded4e4c50d6e13abae6f474  
# Handle  paulius.eth   # Vulnerability details  ## Impact a bit cheapier when you replace:   require(inited == false); with:   require(!inited); same with variable == true.  
# Handle  paulius.eth   # Vulnerability details  ## Impact Here are some useless calculations:   if(_token == VADER && _pool != VADER){  // Want to know added VADER      addedAmount = _balance - pooledVADER;      pooledVADER = pooledVADER + addedAmount;  } else if(_token == USDV) {             // Want to know added USDV      addedAmount = _balance - pooledUSDV;      pooledUSDV = pooledUSDV + addedAmount; if you do the simple maths, it is always in the first case, pooledVADER = _balance, in the second case pooledUSDV = _balance.   
# Handle  paulius.eth   # Vulnerability details  ## Impact There are variables that are only assigned once (e.g. in a constructor). You should mark such variables with the keyword "immutable", this greatly reduces the gas costs. A concrete example of such a variable is "VADER" which is only initialized once and cannot be changed later:    VADER = _vader; There are plenty of such variables across the contracts.   
# Handle  paulius.eth   # Vulnerability details  ## Impact iERC20 decimals field is declared as uint, but to be exact, ERC20 specification declares decimals as uint8. Anyway, this has no security impact as 18 decimals is set which fits in uint8.  ## Recommended Mitigation Steps You can refactor to uint8 or just be informed about such compatibility guidelines.  
# Handle  s1m0   # Vulnerability details  ## Impact The following functions check that an uint > 0 but it's always true.  ## Proof of Concept https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L278 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L197 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L127  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Remove the checks.  
# Handle  s1m0   # Vulnerability details  ## Impact Events not emitted for important state changes. https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L93 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L98 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L196 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L201 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L61 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L163 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L171 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L179 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L184 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L188 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L193 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L198  ## Proof of Concept -  ## Tools Used Manual analysis.  ## Recommended Mitigation Steps Emit events with meaningful names for the changes made.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The flipMinting() function can disable/stop conversion/redeeming of VADER<>USDV tokens upon DAO approval (when that functionality is added). When minting is disabled (i.e. false), the convert functions in USDV.sol accept VADER tokens from sender (L170) but do not burn them to mint the sender the equivalent USDV tokens. When minting is disabled (i.e. false), the redeem functions in USDV.sol accept USDV tokens from sender (L188) but do not burn them to mint the sender the equivalent VADER tokens. Both paths silently return 0 without reverting the transaction thus trapping the sent tokens and leaving the users with lost funds. Protocol will break and funds will be lost.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L171-L177  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L174-L181  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L165-L172  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L183-L191  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L238-L243   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Revert in the paths (instead of silently returning) when minting is disabled so that tokens are not accepted for conversion or redemption.  
# Handle  @cmichelio   # Vulnerability details  `Router.updateAnchorPrice` iterates over all anchor tokens on each update which is very inefficient and does a lot of expensive storage loads. add a mapping `address => index` to easily retrieve the index of the token in the `arrayAnchors` mapping.  
# Handle  @cmichelio   # Vulnerability details  `DAO.mapPID_finalised` is never read in the contract, only written. Remove it and show the `finalized` state in the frontend based on whether the `FinalisedProposal` event was emitted  
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  Proposals that passed the threshold ("finalized") can be cancelled by a minority again using the `cancelProposal` functions. It only sets `mapPID_votes` to zero but `mapPID_timeStart` and `mapPID_finalising` stay the same and pass the checks in `finaliseProposal` which queues them for execution.  ## Impact  Proposals cannot be cancelled.  ## Recommended Mitigation Steps  Set a cancel flag and check for it in `finaliseProposal` and in execution.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  Anyone can cancel any proposals by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`. This always passes the minority check as the proposal was approved.  ## Impact  An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.  ## Recommended Mitigation Steps  Check `oldProposalID == newProposalID`   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  When depositing two different synths, their weight is added to the same `mapMember_weight[_member]` storage variable. When withdrawing the full amount of one synth with `_processWithdraw(synth, member, basisPoints=10000` the full weight is decreased.  The second deposited synth is now essentially weightless.  ## Impact  Users that deposited more than one synth can not claim their fair share of rewards after a withdrawal.  ## Recommended Mitigation Steps  The weight should be indexed by the synth as well.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `harvest` calls `calcCurrentReward` which computes `_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];`. As one can claim different synths than the synths that they deposited, `mapMemberSynth_lastTime[member][synth]` might still be uninitialized and the `_secondsSinceClaim` becomes the current block timestamp.  ## Impact  The larger the `_secondsSinceClaim` the larger the rewards. This bug allows claiming a huge chunk of the rewards.  ## Recommended Mitigation Steps  Let users only harvest synths that they deposited.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `_deposit` function increases the member's _weight_ by `_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);` which is the swap output amount when trading the deposited underlying synth amount.  Notice that anyone can create synths of custom tokens by calling `Pools.deploySynth(customToken)`.  Therefore an attacker can deposit valueless custom tokens and inflate their member weight as follows:  1. Create a custom token and issue lots of tokens to the attacker 2. Create synth of this token 3. Add liquidity for the `TOKEN <> BASE` pair by providing a single wei of `TOKEN` and `10^18` BASE tokens. This makes the `TOKEN` price very expensive. 4. Mint some synths by paying BASE to the pool 5. Deposit the fake synth, `_weight` will be very high because the token pool price is so high.  Call `harvest(realSynth)` with a synth with actual value. This will increase the synth balance and it can be withdrawn later.  ## Impact  Anyone can inflate their member weight through depositing a custom synth and earn almost all vault rewards by calling `harvest(realSynth)` with a valuable "real" synth. The rewards are distributed pro rata to the member weight which is independent of the actual synth deposited.  ## Recommended Mitigation Steps  The `calcReward` function completely disregards the `synth` parameter which seems odd. Think about making the rewards based on the actual synths deposited instead of a "global" weight tracker. Alternatively, whitelist certain synths that count toward the weight, or don't let anyone create synths.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Vader._transfer` function burns the transfer fee on `msg.sender` but this address might not be involved in the transfer at all due to `transferFrom`.  ## Impact  Smart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality.  ## Recommended Mitigation Steps  It should first increase the balance of `recipient` by the full amount and then burn the fee on the `recipient`.  
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Utils.getInterestOwed` function computes the `_interestPayment` as:  ```solidity uint256 _interestPayment =   calcShare(       timeElapsed,       _year,       getInterestPayment(collateralAsset, debtAsset)   ); // Share of the payment over 1 year ```  However, `calcShare` caps `timeElpased` to `_year` and therefore the owed interest does not grow after a year has elapsed.  ## Impact  The impact is probably small because the only call so far computes the elapsed time as `block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];` which most likely will never go beyond a year.  It's still recommended to fix the logic bug in case more functions will be added that use the broken function.  ## Recommended Mitigation Steps  Use a different function than `calcShare` that does not cap.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `flashProof` modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block.  However, it performs this check on `tx.origin` and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.  But flash loan attacks are theoretically not limited to the same transaction but to the same block as miners have full control of the block and include several vulnerable transactions back to back. (Think transaction _bundles_ similar to flashbot bundles that most mining pools currently offer.)  A miner can deploy a proxy smart contract relaying all contract calls and call it from a different EOA each time bypassing the `tx.origin` restriction.  ## Impact  The `flashProof` modifier does not serve its purpose.  ## Recommended Mitigation Steps  Try to apply the modifier to individual addresses that interact with the protocol instead of `tx.origin`.  Furthermore, attacks possible with flash loans are usually also possible for whales, making it debatable if adding flash-loan prevention logic is a good practice.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The inline-comment defines the number of asymmetric shares as `(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3` but the `Utils.calcAsymmetricShare` function computes `(uA * 2U^2 - 2uU + u^2) / U^3` which is not equivalent as can be seen from the `A^2` term in the first term which does not occur in the second one. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.  ## Impact  The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share which is used to determine the collateral value in base tokens could be wrong. For example, it might be possible to borrow more than the collateral put up.  ## Recommended Mitigation Steps  Clarify if the comment is correct or the code and fix them.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Router.getAnchorPrice` sorts the `arrayPrices` array and always returns the third element `_sortedAnchorFeed[2]`. This only returns the median if `_sortedAnchorFeed` is of length 5, but it can be anything from `0` to `anchorLimit`.  ## Impact  If not enough anchors are listed initially, it might become out-of-bounds and break all contract functionality due to revert, or return a wrong median. If `anchorLimit` is set to a different value than 5, it's also wrong.  ## Recommended Mitigation Steps  Check the length of `_sortedAnchorFeed` and return `_sortedAnchorFeed[_sortedAnchorFeed.length / 2]` if it's odd, or the average of the two in the middle if it's even.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Router.swapWithSynthsWithLimit` allows trading token to token and specifying slippage protection. A token to token trade consists of two trades:  1. token to base 2. base to token  The slippage protection of the second trade (base to token) is computed wrong:  ```solidity require(iUTILS(UTILS()).calcSwapSlip(         inputAmount, // should use outToken here from prev trade         iPOOLS(POOLS).getBaseAmount(outputToken)   ) <= slipLimit ); ```  It compares the **token** input amount (of the first trade) to the **base** reserve of the second pair.  ## Impact  Slippage protection fails and either the trade is cancelled when it shouldn't be or it is accepted even though the user suffered more losses than expected.  ## Recommended Mitigation Steps  It should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pool.lockUnits` allows anyone to steal pool tokens from a `member` and assign them to `msg.sender`.  ## Impact  Anyone can steal pool tokens from any other user.  ## Recommended Mitigation Steps  Add access control and require that `msg.sender` is the router or another authorized party.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pools.mintSynth` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `mintSynth(token, token, member)`.  The `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.  ## Impact  It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased.  The amount that is minted could also be inflated (cheaper than sending the actual base tokens), especially if `token` is a high-precision token or worth less than base.  ## Recommended Mitigation Steps  Check that `base` is either `USDV` or `VADER` in `mintSynth`.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `getAddedAmount` function only works correctly when called with `(VADER/USDV, pool)` or `(pool, pool)`. However, when called with (`token, pool)` where `token` is neither `VADER/USDV/pool`, it returns wrong results:  1. It gets the `token` balance 2. And subtracts it from the stored `mapToken_tokenAmount[_pool]` amount which can be that of a completely different token  ## Impact  Anyone can break individual pairs by calling `sync(token1, token2)` where the `token1` balance is less than `mapToken_tokenAmount[token2]`. This will add the difference to `mapToken_tokenAmount[token2]` and break the accounting and result in a wrong swap logic.  Furthermore, this can also be used to swap tokens without having to pay anthing with `swap(token1, token2, member, toBase=false)`.  ## Recommended Mitigation Steps  Add a require statement in the `else` branch that checks that `_token == _pool`.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pools.swap` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `swap(token, token, member, toBase=false)`.  The `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.  ## Impact  It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased (and `token` decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.  Another example scenario is that the token pool amount can be stolen. Send `tokenIn=baseAmount` of tokens to the pool and call `swap(base=token, token, member, toBase=false)`. Depending on the price of `token` relative to `base` this could be cheaper than trading with the base tokens.  ## Recommended Mitigation Steps  Check that `base` is either `USDV` or `VADER`  
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The spec defines the number of LP units to be minted as `units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments` but the `Utils.calcLiquidityUnits` function computes `((P * part1) + part2) / part3 * slipAdjustments`. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.  ## Impact  The math from the spec is not correclty implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.  ## Recommended Mitigation Steps  Fix the equation.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The internal _transfer() function is called from external facing transfer(), transferFrom() and transferTo() functions all of which have different sender addresses. It is msg.sender for transfer(), sender parameter for transferFrom() and tx.origin for transferTo(). These different senders are reflected in the sender parameter of _transfer() function. While this sender parameter is correctly used for transfer of tokens within _transfer, the call to _burn() on L129 incorrectly uses msg.sender as the burn address which is correct only in the case of the transfer() caller's context. This is incorrect for transferFrom() and transferTo() caller contexts.  This will incorrectly burn the fees from a different (intermediate contract) account for all users of the protocol interacting with the transferTo() and transferFrom() functions and lead to incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L129  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L122-L134  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L91-L94  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L108-L112  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L116-L119    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change L129 to: _burn(sender, _fee);   
# Handle  jvaqa   # Vulnerability details  ## Impact Gas Optimization: DAO.sol Unnecessary Multiple Return Statements  ## Recommended Mitigation Steps  In DAO.sol, replace this:  if(votes > consensus){     return true; } else {     return false; }  With this:  return (votes > consensus)  
# Handle  jvaqa   # Vulnerability details  ## Impact  Gas Optimization: Utils.sol Make An Unnecessary Multiplication And Division By An Identical Value  The value "(T1 * B1) / T1" is identical to the value "B1", so you can simplify the expression "B1 + (T1 * B1) / T1" to "B1 + B1".  ## Recommended Mitigation Steps  In Utils.sol, replace this:  uint _redemptionValue = B1 + (T1 * B1) / T1;   With this:  uint _redemptionValue = B1 + B1;  
# Handle  jvaqa   # Vulnerability details  ## Impact  Gas Optimization: Vader.sol Unnecessary Conditional  You can remove this conditional entirely.  ## Recommended Mitigation Steps  In Vader.sol, change this:  if(emitting){         emitting = false;     } else {         emitting = true;     }  To this:  emitting = !emitting;  
# Handle  jvaqa   # Vulnerability details  ## Impact  Avoid Unnecessary Expensive SSTORE Calls In Vether.sol By Checking If _fee Is Non-Zero  SSTORE calls (writes to storage) are very expensive, especially for cold-storage slots (those that have not yet been accessed this transaction). We know that the SSTORE call to totalFees will be a cold storage call, since this is the only place in the whole contract that totalFees is used. Vether.sol makes two SSTORE calls in _transfer that are unnecessary when _fee is zero. It will be common for _fee to be zero, since Vether.sol implements an "excluded addresses" list (mapAddress_Excluded), where _fee is zero when either the sender or the recipient is on the excludedAddresses list. Currently, anyone can add themselves to the excludedAddresses list, but that is probably a mistake.  Nevertheless, since it will probably at least include Uniswap, we should add a check for whether _fee is zero.  ## Proof of Concept When _fee is zero, Vether._transfer() nevertheless makes these two unnecessary SSTORE calls:  _balances[address(this)] += _fee; totalFees += _fee;  ## Recommended Mitigation Steps  Change this:  _balances[address(this)] += _fee; totalFees += _fee;  To this:  if(_fee > 0){   _balances[address(this)] += _fee;   totalFees += _fee; }    
# Handle  0xRajeev   # Vulnerability details  ## Impact  The conditional checking if proposal has quorum in finaliseProposal() is unnecessary and will never be triggered because finalising proposals will always have quorum. Proposal without quorum are not finalised in the voteProposal() function.  Removing this code will reduce contract size and save some gas.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L114-L116  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L82-L90  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L94-L99   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove code from L114 to L116.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Instead of performing a zero-address check in moveRewardAddress on L146 or L152, it is more efficient to do so in newAddressProposal() as soon as the new address is proposed, instead of allowing a proposal for zero-address which goes through the whole voting process. If there is a requirement for zero-address proposals, it should be specified explicitly.  Depending on the participation in the voting process, this will save significant amount of gas for all the participants.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L69-L74  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L144-L154  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Perform input validation of zero-address in newAddressProposal() for proposedAddress parameter.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  changeDAO() updates DAO address in one-step. If an incorrect address is mistakenly used (and voted upon) then future administrative access or recovering from this mistake is prevented because onlyDAO modifier is used for changeDAO(), which requires msg.sender to be the incorrectly used DAO address (for which private keys may not be available to sign transactions).  Reference: See finding #6 from Trail of Bits audit of Hermez Network: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L192-L196   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use a two-step process where the old DAO address first proposes new ownership in one transaction and a second transaction from the newly proposed DAO address accepts ownership. A mistake in the first step can be recovered by granting with a new correct address again before the new DAO address accepts ownership. Ideally, there should also be a timelock enforced before the new DAO takes effect.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function setRewardAddress is used by DAO to change rewardAddress from USDV to something else. However, there is no zero-address validation on the address. This may accidentally mint rewards to zero-address.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L80  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L209  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L183-L186   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address check to setRewardAddress.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  From Solidity’s documentation (https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables), “State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value. Compared to regular state variables, the gas costs of constant and immutable variables are much lower.”  The burnAddress variable  can be made immutable. This will avoid the use of one storage slot and lead to gas savings.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L36   https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L71  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Make burnAddress immutable.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  One of the stated protocol (review) goals is to detect susceptibility to “Any attack vectors using flash loans on Anchor price, synths or lending.” As such, USDV contract aims to protect against flash attacks using flashProof() modifier which uses the following check in isMature() to determine if currently executing contract context is at least blockDelay duration ahead of the previous context: lastBlock[tx.origin] + blockDelay <= block.number  However, blockDelay state variable is not initialized which means it has a default uint value of 0. So unless it is set to >= 1 by setParams() which can be called only by the DAO (which currently does not have the capability to call setParams() function), blockDelay will be 0 which allows current executing context (block.number) to be the same as the previous one (lastBlock[tx.origin]). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks as opposed to what is expected as commented on L41: "// Stops an EOA doing a flash attack in same block"  Even if the DAO can call setParams() to change blockDelay to >= 1, there is a big window of opportunity for flash attacks until the DAO votes, finalises and approves such a proposal. Moreover, such proposals can be cancelled by a DAO minority or replaced by a malicious DAO minority to launch flash attacks.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L22  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L140-L142  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L35-L44  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L174    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Initialize blockDelay to >= 1 at declaration or in constructor.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  From Solidity’s documentation (https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables), “State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value. Compared to regular state variables, the gas costs of constant and immutable variables are much lower.”  State variables name, symbol and decimals can be declared as constants and assigned at declaration (instead of constructor) because they are never modified later. This avoid 3 storage slots and associated expensive SSTOREs/SLOADs to save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L12-L13   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Declare state variables name, symbol and decimals as constant.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The deploySynth() function in Pools.sol is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory’s deploySynth() function.   However, the require() incorrectly uses ‘||’ operator instead of ‘&&’ which allows both VADER and USDV to be supplied as the token parameters. This will allow an attacker to deploy either VADER or USDV as a Synth which will break assumptions throughout the entire protocol. Protocol will break and funds may be lost.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L138   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change ‘||’ operator to ‘&&’ in the require statement: require(token != VADER && token != USDV);   
# Handle  0xRajeev   # Vulnerability details  ## Impact  _isMember mapping state variable is declared and used only in the getter function isMember(), but is net assigned to anywhere in the contract. This will consume an unnecessary storage slot and along with its getter function will also increase the contract size.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L22  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L215-L217   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove _isMember state variable declaration on L22 and related getter function isMember().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  A bool in Solidity is internally represented as a unit8 and so required only 8 bits of the 256-bits storage slot. An address variable is 160-bits. So declaring a bool next to an address variable lets Solidity pack them in the same storage slot thereby using one slot instead of two.  Moving the inited bool state variable next to one of the address state variables VADER, USDV, ROUTER or FACTORY lets the compiler pack them together in one storage slot instead of two, thereby saving one slot. It costs 20k gas to SSTORE each slot of data.  The current order where inited bool is declared before uint does not allow packing because uint itself requires the entire 256-bits of a slot, which forces the compiler to use one full slot for the inited bool variable.  For reference, see https://mudit.blog/solidity-gas-optimization-tips/  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L13-L20   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move inited bool state variable declaration next to an address state variable declaration.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  If the requirement is that listed anchors are unique token addresses, then the loop in replaceAnchor() can break upon match+replace to save gas from executing more loop iterations.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L261-L265   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a break statement after L263.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  There is no input validation in replacePool() function to check if oldToken exists and is curated. Using a non-existing oldToken (even 0 address) passes the check on L236 (because Pools.getBaseAmount() will return 0 for the non-existing token) and newToken will be made curated. This can be used to bypass the curatedPoolLimit enforced only in curatePool() function.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L234-L241  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L227-L229  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L227  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check if oldToken exists and is curated as part of input validation in replacePool() function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  repayDelay uint state variable is declared but never used elsewhere. This will consume an unnecessary storage slot and also increase the contract size.  ## Proof of Concept https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L35   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove repayDelay state variable declaration on L35.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The conditional in calcReward() function uses the same code in both if/else parts with repeated use of reserveUSDV, reserveVADER and getUSDVAmount leading to incorrect computed value of _adjustedReserve in the else part.  This will affect harvest rewards for all users of the protocol and lead to incorrect accounting. Protocol will break and lead to fund loss.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L141  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L144  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L125  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L105   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change variables and function calls from using USDV to VADER in the else part of the conditional which has to return the adjusted reserves when synth is not an asset i.e. an anchor and therefore base is VADER.  L144 should be changed to: uint _adjustedReserve = iROUTER(ROUTER).getVADERAmount(reserveUSDV()) + reserveVADER();   
# Handle  gpersoon   # Vulnerability details  ## Impact Vault.sol has a different pragma statement than the rest, it contains an additional "^".  For the record the Vether.sol contract (as deployed here https://etherscan.io/address/0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279#code),  has a different solidity version.  It's cleaner to use the same versions.  ## Proof of Concept  DAO.sol:pragma solidity 0.8.3; Factory.sol:pragma solidity 0.8.3; Pools.sol:pragma solidity 0.8.3; Router.sol:pragma solidity 0.8.3; Synth.sol:pragma solidity 0.8.3; USDV.sol:pragma solidity 0.8.3; Utils.sol:pragma solidity 0.8.3; Vader.sol:pragma solidity 0.8.3; Vault.sol:pragma solidity ^0.8.3; Vether.sol:pragma solidity 0.6.4;  ## Tools Used Editor  ## Recommended Mitigation Steps Use the same solidity versions   
# Handle  gpersoon   # Vulnerability details  ## Impact The function transferOut of Pools.sol contains a iERC20(_token).transfer where the result of the function isn't checked. This could result in transfers that don't succeed are undetected.  ## Proof of Concept Pools.sol:   function transferOut(address _token, uint _amount, address _recipient) internal {         if(_token == VADER){             pooledVADER = pooledVADER - _amount; // Accounting         } else if(_token == USDV) {             pooledUSDV = pooledUSDV - _amount;  // Accounting         }         if(_recipient != address(this)){             iERC20(_token).transfer(_recipient, _amount);         }     }  ## Tools Used Editor  ## Recommended Mitigation Steps Add a require statement to check the result: require(...transfer(...) )   
# Handle  gpersoon   # Vulnerability details  ## Impact Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.  ## Proof of Concept  DAO.sol:    function init(address _vader, address _usdv, address _vault) public { Factory.sol:    function init(address _pool) public { Pools.sol:    function init(address _vader, address _usdv, address _router, address _factory) public { Router.sol:    function init(address _vader, address _usdv, address _pool) public { USDV.sol:    function init(address _vader, address _vault, address _router) external { Utils.sol:    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public { Vader.sol:    function init(address _vether, address _USDV, address _utils) external { Vault.sol:    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {    ## Tools Used Editor  ## Recommended Mitigation Steps Add a check to the init function, for example that only the deployer can call the function.  
# Handle  gpersoon   # Vulnerability details  ## Impact There is some unused / redundant code present.  Router.sol defines repayDelay but it is never used Vault.sol initializes POOLS twice, with the same value.  ## Proof of Concept Router.sol: uint public repayDelay = 3600;  Vault.sol:  function init(address _vader, address _usdv, address _router, ... ..         POOLS = _pool; ..           POOLS = _pool;     ## Tools Used Editor  ## Recommended Mitigation Steps Remove redundant code  
# Handle  JMukesh   # Vulnerability details  ## Impact public functions that are never called by the contract should be declared external to save gas.  ## Proof of Concept  1. In Vault.sol  -- > init() and grant()                     https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L45  https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L68  2. Vader.sol -- > burn()    https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L146  3. Utils.sol -- > init(),  getProtection()   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L30  4. Router.sol -- >  init(address,address,address)  getVADERAmount(uint256)  getUSDVAmount(uint256)  borrow(uint256,address,address)  repay(uint256,address,address)  checkLiquidate() getSystemCollateral(address,address)  getSystemDebt(address,address) getSystemInterestPaid()   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L77  5. Pools.sol  init(address,address,address,address)  isMember(address)  isSynth(address)   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol  6. Dao.sol  init(address,address,address)  newGrantProposal(address,uint256)  newAddressProposal(address,string)  voteProposal(uint256)  cancelProposal(uint256,uint256)  finaliseProposal(uint256)  https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/DAO.sol#L46    ## Tools Used  slither  ## Recommended Mitigation Steps  use external instead of public visibility to save gas  
# Handle  shw   # Vulnerability details  ## Impact  In `Router.sol`, the second `else if` statement in the function `swapWithSynthsWithLimit` is unnecessary.  ## Proof of Concept  Referenced code: [Router.sol#L162](https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L162)  ## Tools Used  None  ## Recommended Mitigation Steps  Consider using `else {...}`, which has the identical behavior to save gas.  
# Handle  paulius.eth   # Vulnerability details  ## Impact Both structs CollateralDetails and DebtDetails have unused ID field which is never set nor queried:    uint ID;  
# Handle  paulius.eth   # Vulnerability details  ## Impact In function updateAnchorPrice here 'arrayAnchors[i]' can be replaced with 'token' to eliminate one expensive storage access:    arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);  
# Handle  paulius.eth   # Vulnerability details  ## Impact Condition could be '>', not '>=' as there is no point in recalculating amount to the same value (waste of gas):  if((totalSupply + amount) >= maxSupply){   amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply  }  
# Handle  a_delamo   # Vulnerability details  Here you have more information: https://gist.github.com/alexon1234/5eb3fff3bded4e4c50d6e13abae6f474  
# Handle  paulius.eth   # Vulnerability details  ## Impact a bit cheapier when you replace:   require(inited == false); with:   require(!inited); same with variable == true.  
# Handle  paulius.eth   # Vulnerability details  ## Impact Here are some useless calculations:   if(_token == VADER && _pool != VADER){  // Want to know added VADER      addedAmount = _balance - pooledVADER;      pooledVADER = pooledVADER + addedAmount;  } else if(_token == USDV) {             // Want to know added USDV      addedAmount = _balance - pooledUSDV;      pooledUSDV = pooledUSDV + addedAmount; if you do the simple maths, it is always in the first case, pooledVADER = _balance, in the second case pooledUSDV = _balance.   
# Handle  paulius.eth   # Vulnerability details  ## Impact There are variables that are only assigned once (e.g. in a constructor). You should mark such variables with the keyword "immutable", this greatly reduces the gas costs. A concrete example of such a variable is "VADER" which is only initialized once and cannot be changed later:    VADER = _vader; There are plenty of such variables across the contracts.   
# Handle  paulius.eth   # Vulnerability details  ## Impact iERC20 decimals field is declared as uint, but to be exact, ERC20 specification declares decimals as uint8. Anyway, this has no security impact as 18 decimals is set which fits in uint8.  ## Recommended Mitigation Steps You can refactor to uint8 or just be informed about such compatibility guidelines.  
# Handle  s1m0   # Vulnerability details  ## Impact The following functions check that an uint > 0 but it's always true.  ## Proof of Concept https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L278 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L197 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L127  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Remove the checks.  
# Handle  s1m0   # Vulnerability details  ## Impact Events not emitted for important state changes. https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L93 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L98 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L196 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L201 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L61 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L163 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L171 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L179 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L184 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L188 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L193 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L198  ## Proof of Concept -  ## Tools Used Manual analysis.  ## Recommended Mitigation Steps Emit events with meaningful names for the changes made.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The flipMinting() function can disable/stop conversion/redeeming of VADER<>USDV tokens upon DAO approval (when that functionality is added). When minting is disabled (i.e. false), the convert functions in USDV.sol accept VADER tokens from sender (L170) but do not burn them to mint the sender the equivalent USDV tokens. When minting is disabled (i.e. false), the redeem functions in USDV.sol accept USDV tokens from sender (L188) but do not burn them to mint the sender the equivalent VADER tokens. Both paths silently return 0 without reverting the transaction thus trapping the sent tokens and leaving the users with lost funds. Protocol will break and funds will be lost.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L171-L177  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L174-L181  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L165-L172  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L183-L191  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L238-L243   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Revert in the paths (instead of silently returning) when minting is disabled so that tokens are not accepted for conversion or redemption.  
# Handle  @cmichelio   # Vulnerability details  `Router.updateAnchorPrice` iterates over all anchor tokens on each update which is very inefficient and does a lot of expensive storage loads. add a mapping `address => index` to easily retrieve the index of the token in the `arrayAnchors` mapping.  
# Handle  @cmichelio   # Vulnerability details  `DAO.mapPID_finalised` is never read in the contract, only written. Remove it and show the `finalized` state in the frontend based on whether the `FinalisedProposal` event was emitted  
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  Proposals that passed the threshold ("finalized") can be cancelled by a minority again using the `cancelProposal` functions. It only sets `mapPID_votes` to zero but `mapPID_timeStart` and `mapPID_finalising` stay the same and pass the checks in `finaliseProposal` which queues them for execution.  ## Impact  Proposals cannot be cancelled.  ## Recommended Mitigation Steps  Set a cancel flag and check for it in `finaliseProposal` and in execution.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  Anyone can cancel any proposals by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`. This always passes the minority check as the proposal was approved.  ## Impact  An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.  ## Recommended Mitigation Steps  Check `oldProposalID == newProposalID`   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  When depositing two different synths, their weight is added to the same `mapMember_weight[_member]` storage variable. When withdrawing the full amount of one synth with `_processWithdraw(synth, member, basisPoints=10000` the full weight is decreased.  The second deposited synth is now essentially weightless.  ## Impact  Users that deposited more than one synth can not claim their fair share of rewards after a withdrawal.  ## Recommended Mitigation Steps  The weight should be indexed by the synth as well.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `harvest` calls `calcCurrentReward` which computes `_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];`. As one can claim different synths than the synths that they deposited, `mapMemberSynth_lastTime[member][synth]` might still be uninitialized and the `_secondsSinceClaim` becomes the current block timestamp.  ## Impact  The larger the `_secondsSinceClaim` the larger the rewards. This bug allows claiming a huge chunk of the rewards.  ## Recommended Mitigation Steps  Let users only harvest synths that they deposited.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `_deposit` function increases the member's _weight_ by `_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);` which is the swap output amount when trading the deposited underlying synth amount.  Notice that anyone can create synths of custom tokens by calling `Pools.deploySynth(customToken)`.  Therefore an attacker can deposit valueless custom tokens and inflate their member weight as follows:  1. Create a custom token and issue lots of tokens to the attacker 2. Create synth of this token 3. Add liquidity for the `TOKEN <> BASE` pair by providing a single wei of `TOKEN` and `10^18` BASE tokens. This makes the `TOKEN` price very expensive. 4. Mint some synths by paying BASE to the pool 5. Deposit the fake synth, `_weight` will be very high because the token pool price is so high.  Call `harvest(realSynth)` with a synth with actual value. This will increase the synth balance and it can be withdrawn later.  ## Impact  Anyone can inflate their member weight through depositing a custom synth and earn almost all vault rewards by calling `harvest(realSynth)` with a valuable "real" synth. The rewards are distributed pro rata to the member weight which is independent of the actual synth deposited.  ## Recommended Mitigation Steps  The `calcReward` function completely disregards the `synth` parameter which seems odd. Think about making the rewards based on the actual synths deposited instead of a "global" weight tracker. Alternatively, whitelist certain synths that count toward the weight, or don't let anyone create synths.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Vader._transfer` function burns the transfer fee on `msg.sender` but this address might not be involved in the transfer at all due to `transferFrom`.  ## Impact  Smart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality.  ## Recommended Mitigation Steps  It should first increase the balance of `recipient` by the full amount and then burn the fee on the `recipient`.  
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Utils.getInterestOwed` function computes the `_interestPayment` as:  ```solidity uint256 _interestPayment =   calcShare(       timeElapsed,       _year,       getInterestPayment(collateralAsset, debtAsset)   ); // Share of the payment over 1 year ```  However, `calcShare` caps `timeElpased` to `_year` and therefore the owed interest does not grow after a year has elapsed.  ## Impact  The impact is probably small because the only call so far computes the elapsed time as `block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];` which most likely will never go beyond a year.  It's still recommended to fix the logic bug in case more functions will be added that use the broken function.  ## Recommended Mitigation Steps  Use a different function than `calcShare` that does not cap.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `flashProof` modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block.  However, it performs this check on `tx.origin` and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.  But flash loan attacks are theoretically not limited to the same transaction but to the same block as miners have full control of the block and include several vulnerable transactions back to back. (Think transaction _bundles_ similar to flashbot bundles that most mining pools currently offer.)  A miner can deploy a proxy smart contract relaying all contract calls and call it from a different EOA each time bypassing the `tx.origin` restriction.  ## Impact  The `flashProof` modifier does not serve its purpose.  ## Recommended Mitigation Steps  Try to apply the modifier to individual addresses that interact with the protocol instead of `tx.origin`.  Furthermore, attacks possible with flash loans are usually also possible for whales, making it debatable if adding flash-loan prevention logic is a good practice.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The inline-comment defines the number of asymmetric shares as `(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3` but the `Utils.calcAsymmetricShare` function computes `(uA * 2U^2 - 2uU + u^2) / U^3` which is not equivalent as can be seen from the `A^2` term in the first term which does not occur in the second one. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.  ## Impact  The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share which is used to determine the collateral value in base tokens could be wrong. For example, it might be possible to borrow more than the collateral put up.  ## Recommended Mitigation Steps  Clarify if the comment is correct or the code and fix them.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Router.getAnchorPrice` sorts the `arrayPrices` array and always returns the third element `_sortedAnchorFeed[2]`. This only returns the median if `_sortedAnchorFeed` is of length 5, but it can be anything from `0` to `anchorLimit`.  ## Impact  If not enough anchors are listed initially, it might become out-of-bounds and break all contract functionality due to revert, or return a wrong median. If `anchorLimit` is set to a different value than 5, it's also wrong.  ## Recommended Mitigation Steps  Check the length of `_sortedAnchorFeed` and return `_sortedAnchorFeed[_sortedAnchorFeed.length / 2]` if it's odd, or the average of the two in the middle if it's even.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Router.swapWithSynthsWithLimit` allows trading token to token and specifying slippage protection. A token to token trade consists of two trades:  1. token to base 2. base to token  The slippage protection of the second trade (base to token) is computed wrong:  ```solidity require(iUTILS(UTILS()).calcSwapSlip(         inputAmount, // should use outToken here from prev trade         iPOOLS(POOLS).getBaseAmount(outputToken)   ) <= slipLimit ); ```  It compares the **token** input amount (of the first trade) to the **base** reserve of the second pair.  ## Impact  Slippage protection fails and either the trade is cancelled when it shouldn't be or it is accepted even though the user suffered more losses than expected.  ## Recommended Mitigation Steps  It should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pool.lockUnits` allows anyone to steal pool tokens from a `member` and assign them to `msg.sender`.  ## Impact  Anyone can steal pool tokens from any other user.  ## Recommended Mitigation Steps  Add access control and require that `msg.sender` is the router or another authorized party.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pools.mintSynth` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `mintSynth(token, token, member)`.  The `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.  ## Impact  It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased.  The amount that is minted could also be inflated (cheaper than sending the actual base tokens), especially if `token` is a high-precision token or worth less than base.  ## Recommended Mitigation Steps  Check that `base` is either `USDV` or `VADER` in `mintSynth`.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `getAddedAmount` function only works correctly when called with `(VADER/USDV, pool)` or `(pool, pool)`. However, when called with (`token, pool)` where `token` is neither `VADER/USDV/pool`, it returns wrong results:  1. It gets the `token` balance 2. And subtracts it from the stored `mapToken_tokenAmount[_pool]` amount which can be that of a completely different token  ## Impact  Anyone can break individual pairs by calling `sync(token1, token2)` where the `token1` balance is less than `mapToken_tokenAmount[token2]`. This will add the difference to `mapToken_tokenAmount[token2]` and break the accounting and result in a wrong swap logic.  Furthermore, this can also be used to swap tokens without having to pay anthing with `swap(token1, token2, member, toBase=false)`.  ## Recommended Mitigation Steps  Add a require statement in the `else` branch that checks that `_token == _pool`.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pools.swap` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `swap(token, token, member, toBase=false)`.  The `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.  ## Impact  It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased (and `token` decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.  Another example scenario is that the token pool amount can be stolen. Send `tokenIn=baseAmount` of tokens to the pool and call `swap(base=token, token, member, toBase=false)`. Depending on the price of `token` relative to `base` this could be cheaper than trading with the base tokens.  ## Recommended Mitigation Steps  Check that `base` is either `USDV` or `VADER`  
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The spec defines the number of LP units to be minted as `units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments` but the `Utils.calcLiquidityUnits` function computes `((P * part1) + part2) / part3 * slipAdjustments`. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.  ## Impact  The math from the spec is not correclty implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.  ## Recommended Mitigation Steps  Fix the equation.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The internal _transfer() function is called from external facing transfer(), transferFrom() and transferTo() functions all of which have different sender addresses. It is msg.sender for transfer(), sender parameter for transferFrom() and tx.origin for transferTo(). These different senders are reflected in the sender parameter of _transfer() function. While this sender parameter is correctly used for transfer of tokens within _transfer, the call to _burn() on L129 incorrectly uses msg.sender as the burn address which is correct only in the case of the transfer() caller's context. This is incorrect for transferFrom() and transferTo() caller contexts.  This will incorrectly burn the fees from a different (intermediate contract) account for all users of the protocol interacting with the transferTo() and transferFrom() functions and lead to incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L129  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L122-L134  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L91-L94  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L108-L112  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L116-L119    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change L129 to: _burn(sender, _fee);   
# Handle  jvaqa   # Vulnerability details  ## Impact Gas Optimization: DAO.sol Unnecessary Multiple Return Statements  ## Recommended Mitigation Steps  In DAO.sol, replace this:  if(votes > consensus){     return true; } else {     return false; }  With this:  return (votes > consensus)  
# Handle  jvaqa   # Vulnerability details  ## Impact  Gas Optimization: Utils.sol Make An Unnecessary Multiplication And Division By An Identical Value  The value "(T1 * B1) / T1" is identical to the value "B1", so you can simplify the expression "B1 + (T1 * B1) / T1" to "B1 + B1".  ## Recommended Mitigation Steps  In Utils.sol, replace this:  uint _redemptionValue = B1 + (T1 * B1) / T1;   With this:  uint _redemptionValue = B1 + B1;  
# Handle  jvaqa   # Vulnerability details  ## Impact  Gas Optimization: Vader.sol Unnecessary Conditional  You can remove this conditional entirely.  ## Recommended Mitigation Steps  In Vader.sol, change this:  if(emitting){         emitting = false;     } else {         emitting = true;     }  To this:  emitting = !emitting;  
# Handle  jvaqa   # Vulnerability details  ## Impact  Avoid Unnecessary Expensive SSTORE Calls In Vether.sol By Checking If _fee Is Non-Zero  SSTORE calls (writes to storage) are very expensive, especially for cold-storage slots (those that have not yet been accessed this transaction). We know that the SSTORE call to totalFees will be a cold storage call, since this is the only place in the whole contract that totalFees is used. Vether.sol makes two SSTORE calls in _transfer that are unnecessary when _fee is zero. It will be common for _fee to be zero, since Vether.sol implements an "excluded addresses" list (mapAddress_Excluded), where _fee is zero when either the sender or the recipient is on the excludedAddresses list. Currently, anyone can add themselves to the excludedAddresses list, but that is probably a mistake.  Nevertheless, since it will probably at least include Uniswap, we should add a check for whether _fee is zero.  ## Proof of Concept When _fee is zero, Vether._transfer() nevertheless makes these two unnecessary SSTORE calls:  _balances[address(this)] += _fee; totalFees += _fee;  ## Recommended Mitigation Steps  Change this:  _balances[address(this)] += _fee; totalFees += _fee;  To this:  if(_fee > 0){   _balances[address(this)] += _fee;   totalFees += _fee; }    
# Handle  0xRajeev   # Vulnerability details  ## Impact  The conditional checking if proposal has quorum in finaliseProposal() is unnecessary and will never be triggered because finalising proposals will always have quorum. Proposal without quorum are not finalised in the voteProposal() function.  Removing this code will reduce contract size and save some gas.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L114-L116  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L82-L90  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L94-L99   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove code from L114 to L116.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Instead of performing a zero-address check in moveRewardAddress on L146 or L152, it is more efficient to do so in newAddressProposal() as soon as the new address is proposed, instead of allowing a proposal for zero-address which goes through the whole voting process. If there is a requirement for zero-address proposals, it should be specified explicitly.  Depending on the participation in the voting process, this will save significant amount of gas for all the participants.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L69-L74  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L144-L154  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Perform input validation of zero-address in newAddressProposal() for proposedAddress parameter.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  changeDAO() updates DAO address in one-step. If an incorrect address is mistakenly used (and voted upon) then future administrative access or recovering from this mistake is prevented because onlyDAO modifier is used for changeDAO(), which requires msg.sender to be the incorrectly used DAO address (for which private keys may not be available to sign transactions).  Reference: See finding #6 from Trail of Bits audit of Hermez Network: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L192-L196   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use a two-step process where the old DAO address first proposes new ownership in one transaction and a second transaction from the newly proposed DAO address accepts ownership. A mistake in the first step can be recovered by granting with a new correct address again before the new DAO address accepts ownership. Ideally, there should also be a timelock enforced before the new DAO takes effect.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function setRewardAddress is used by DAO to change rewardAddress from USDV to something else. However, there is no zero-address validation on the address. This may accidentally mint rewards to zero-address.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L80  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L209  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L183-L186   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address check to setRewardAddress.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  From Solidity’s documentation (https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables), “State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value. Compared to regular state variables, the gas costs of constant and immutable variables are much lower.”  The burnAddress variable  can be made immutable. This will avoid the use of one storage slot and lead to gas savings.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L36   https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L71  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Make burnAddress immutable.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  One of the stated protocol (review) goals is to detect susceptibility to “Any attack vectors using flash loans on Anchor price, synths or lending.” As such, USDV contract aims to protect against flash attacks using flashProof() modifier which uses the following check in isMature() to determine if currently executing contract context is at least blockDelay duration ahead of the previous context: lastBlock[tx.origin] + blockDelay <= block.number  However, blockDelay state variable is not initialized which means it has a default uint value of 0. So unless it is set to >= 1 by setParams() which can be called only by the DAO (which currently does not have the capability to call setParams() function), blockDelay will be 0 which allows current executing context (block.number) to be the same as the previous one (lastBlock[tx.origin]). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks as opposed to what is expected as commented on L41: "// Stops an EOA doing a flash attack in same block"  Even if the DAO can call setParams() to change blockDelay to >= 1, there is a big window of opportunity for flash attacks until the DAO votes, finalises and approves such a proposal. Moreover, such proposals can be cancelled by a DAO minority or replaced by a malicious DAO minority to launch flash attacks.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L22  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L140-L142  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L35-L44  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L174    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Initialize blockDelay to >= 1 at declaration or in constructor.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  From Solidity’s documentation (https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables), “State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value. Compared to regular state variables, the gas costs of constant and immutable variables are much lower.”  State variables name, symbol and decimals can be declared as constants and assigned at declaration (instead of constructor) because they are never modified later. This avoid 3 storage slots and associated expensive SSTOREs/SLOADs to save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L12-L13   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Declare state variables name, symbol and decimals as constant.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The deploySynth() function in Pools.sol is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory’s deploySynth() function.   However, the require() incorrectly uses ‘||’ operator instead of ‘&&’ which allows both VADER and USDV to be supplied as the token parameters. This will allow an attacker to deploy either VADER or USDV as a Synth which will break assumptions throughout the entire protocol. Protocol will break and funds may be lost.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L138   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change ‘||’ operator to ‘&&’ in the require statement: require(token != VADER && token != USDV);   
# Handle  0xRajeev   # Vulnerability details  ## Impact  _isMember mapping state variable is declared and used only in the getter function isMember(), but is net assigned to anywhere in the contract. This will consume an unnecessary storage slot and along with its getter function will also increase the contract size.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L22  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L215-L217   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove _isMember state variable declaration on L22 and related getter function isMember().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  A bool in Solidity is internally represented as a unit8 and so required only 8 bits of the 256-bits storage slot. An address variable is 160-bits. So declaring a bool next to an address variable lets Solidity pack them in the same storage slot thereby using one slot instead of two.  Moving the inited bool state variable next to one of the address state variables VADER, USDV, ROUTER or FACTORY lets the compiler pack them together in one storage slot instead of two, thereby saving one slot. It costs 20k gas to SSTORE each slot of data.  The current order where inited bool is declared before uint does not allow packing because uint itself requires the entire 256-bits of a slot, which forces the compiler to use one full slot for the inited bool variable.  For reference, see https://mudit.blog/solidity-gas-optimization-tips/  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L13-L20   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move inited bool state variable declaration next to an address state variable declaration.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  If the requirement is that listed anchors are unique token addresses, then the loop in replaceAnchor() can break upon match+replace to save gas from executing more loop iterations.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L261-L265   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a break statement after L263.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  There is no input validation in replacePool() function to check if oldToken exists and is curated. Using a non-existing oldToken (even 0 address) passes the check on L236 (because Pools.getBaseAmount() will return 0 for the non-existing token) and newToken will be made curated. This can be used to bypass the curatedPoolLimit enforced only in curatePool() function.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L234-L241  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L227-L229  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L227  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check if oldToken exists and is curated as part of input validation in replacePool() function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  repayDelay uint state variable is declared but never used elsewhere. This will consume an unnecessary storage slot and also increase the contract size.  ## Proof of Concept https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L35   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove repayDelay state variable declaration on L35.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The conditional in calcReward() function uses the same code in both if/else parts with repeated use of reserveUSDV, reserveVADER and getUSDVAmount leading to incorrect computed value of _adjustedReserve in the else part.  This will affect harvest rewards for all users of the protocol and lead to incorrect accounting. Protocol will break and lead to fund loss.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L141  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L144  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L125  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L105   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change variables and function calls from using USDV to VADER in the else part of the conditional which has to return the adjusted reserves when synth is not an asset i.e. an anchor and therefore base is VADER.  L144 should be changed to: uint _adjustedReserve = iROUTER(ROUTER).getVADERAmount(reserveUSDV()) + reserveVADER();   
# Handle  gpersoon   # Vulnerability details  ## Impact Vault.sol has a different pragma statement than the rest, it contains an additional "^".  For the record the Vether.sol contract (as deployed here https://etherscan.io/address/0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279#code),  has a different solidity version.  It's cleaner to use the same versions.  ## Proof of Concept  DAO.sol:pragma solidity 0.8.3; Factory.sol:pragma solidity 0.8.3; Pools.sol:pragma solidity 0.8.3; Router.sol:pragma solidity 0.8.3; Synth.sol:pragma solidity 0.8.3; USDV.sol:pragma solidity 0.8.3; Utils.sol:pragma solidity 0.8.3; Vader.sol:pragma solidity 0.8.3; Vault.sol:pragma solidity ^0.8.3; Vether.sol:pragma solidity 0.6.4;  ## Tools Used Editor  ## Recommended Mitigation Steps Use the same solidity versions   
# Handle  gpersoon   # Vulnerability details  ## Impact The function transferOut of Pools.sol contains a iERC20(_token).transfer where the result of the function isn't checked. This could result in transfers that don't succeed are undetected.  ## Proof of Concept Pools.sol:   function transferOut(address _token, uint _amount, address _recipient) internal {         if(_token == VADER){             pooledVADER = pooledVADER - _amount; // Accounting         } else if(_token == USDV) {             pooledUSDV = pooledUSDV - _amount;  // Accounting         }         if(_recipient != address(this)){             iERC20(_token).transfer(_recipient, _amount);         }     }  ## Tools Used Editor  ## Recommended Mitigation Steps Add a require statement to check the result: require(...transfer(...) )   
# Handle  gpersoon   # Vulnerability details  ## Impact Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.  ## Proof of Concept  DAO.sol:    function init(address _vader, address _usdv, address _vault) public { Factory.sol:    function init(address _pool) public { Pools.sol:    function init(address _vader, address _usdv, address _router, address _factory) public { Router.sol:    function init(address _vader, address _usdv, address _pool) public { USDV.sol:    function init(address _vader, address _vault, address _router) external { Utils.sol:    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public { Vader.sol:    function init(address _vether, address _USDV, address _utils) external { Vault.sol:    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {    ## Tools Used Editor  ## Recommended Mitigation Steps Add a check to the init function, for example that only the deployer can call the function.  
# Handle  gpersoon   # Vulnerability details  ## Impact There is some unused / redundant code present.  Router.sol defines repayDelay but it is never used Vault.sol initializes POOLS twice, with the same value.  ## Proof of Concept Router.sol: uint public repayDelay = 3600;  Vault.sol:  function init(address _vader, address _usdv, address _router, ... ..         POOLS = _pool; ..           POOLS = _pool;     ## Tools Used Editor  ## Recommended Mitigation Steps Remove redundant code  
# Handle  JMukesh   # Vulnerability details  ## Impact public functions that are never called by the contract should be declared external to save gas.  ## Proof of Concept  1. In Vault.sol  -- > init() and grant()                     https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L45  https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L68  2. Vader.sol -- > burn()    https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L146  3. Utils.sol -- > init(),  getProtection()   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L30  4. Router.sol -- >  init(address,address,address)  getVADERAmount(uint256)  getUSDVAmount(uint256)  borrow(uint256,address,address)  repay(uint256,address,address)  checkLiquidate() getSystemCollateral(address,address)  getSystemDebt(address,address) getSystemInterestPaid()   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L77  5. Pools.sol  init(address,address,address,address)  isMember(address)  isSynth(address)   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol  6. Dao.sol  init(address,address,address)  newGrantProposal(address,uint256)  newAddressProposal(address,string)  voteProposal(uint256)  cancelProposal(uint256,uint256)  finaliseProposal(uint256)  https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/DAO.sol#L46    ## Tools Used  slither  ## Recommended Mitigation Steps  use external instead of public visibility to save gas  
# Handle  shw   # Vulnerability details  ## Impact  In `Router.sol`, the second `else if` statement in the function `swapWithSynthsWithLimit` is unnecessary.  ## Proof of Concept  Referenced code: [Router.sol#L162](https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L162)  ## Tools Used  None  ## Recommended Mitigation Steps  Consider using `else {...}`, which has the identical behavior to save gas.  
# Handle  paulius.eth   # Vulnerability details  ## Impact Both structs CollateralDetails and DebtDetails have unused ID field which is never set nor queried:    uint ID;  
# Handle  paulius.eth   # Vulnerability details  ## Impact In function updateAnchorPrice here 'arrayAnchors[i]' can be replaced with 'token' to eliminate one expensive storage access:    arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);  
# Handle  paulius.eth   # Vulnerability details  ## Impact Condition could be '>', not '>=' as there is no point in recalculating amount to the same value (waste of gas):  if((totalSupply + amount) >= maxSupply){   amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply  }  
# Handle  a_delamo   # Vulnerability details  Here you have more information: https://gist.github.com/alexon1234/5eb3fff3bded4e4c50d6e13abae6f474  
# Handle  paulius.eth   # Vulnerability details  ## Impact a bit cheapier when you replace:   require(inited == false); with:   require(!inited); same with variable == true.  
# Handle  paulius.eth   # Vulnerability details  ## Impact Here are some useless calculations:   if(_token == VADER && _pool != VADER){  // Want to know added VADER      addedAmount = _balance - pooledVADER;      pooledVADER = pooledVADER + addedAmount;  } else if(_token == USDV) {             // Want to know added USDV      addedAmount = _balance - pooledUSDV;      pooledUSDV = pooledUSDV + addedAmount; if you do the simple maths, it is always in the first case, pooledVADER = _balance, in the second case pooledUSDV = _balance.   
# Handle  paulius.eth   # Vulnerability details  ## Impact There are variables that are only assigned once (e.g. in a constructor). You should mark such variables with the keyword "immutable", this greatly reduces the gas costs. A concrete example of such a variable is "VADER" which is only initialized once and cannot be changed later:    VADER = _vader; There are plenty of such variables across the contracts.   
# Handle  paulius.eth   # Vulnerability details  ## Impact iERC20 decimals field is declared as uint, but to be exact, ERC20 specification declares decimals as uint8. Anyway, this has no security impact as 18 decimals is set which fits in uint8.  ## Recommended Mitigation Steps You can refactor to uint8 or just be informed about such compatibility guidelines.  
# Handle  s1m0   # Vulnerability details  ## Impact The following functions check that an uint > 0 but it's always true.  ## Proof of Concept https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L278 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L197 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L127  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Remove the checks.  
# Handle  s1m0   # Vulnerability details  ## Impact Events not emitted for important state changes. https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L93 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L98 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L196 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L201 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L61 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L163 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L171 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L179 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L184 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L188 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L193 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L198  ## Proof of Concept -  ## Tools Used Manual analysis.  ## Recommended Mitigation Steps Emit events with meaningful names for the changes made.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The flipMinting() function can disable/stop conversion/redeeming of VADER<>USDV tokens upon DAO approval (when that functionality is added). When minting is disabled (i.e. false), the convert functions in USDV.sol accept VADER tokens from sender (L170) but do not burn them to mint the sender the equivalent USDV tokens. When minting is disabled (i.e. false), the redeem functions in USDV.sol accept USDV tokens from sender (L188) but do not burn them to mint the sender the equivalent VADER tokens. Both paths silently return 0 without reverting the transaction thus trapping the sent tokens and leaving the users with lost funds. Protocol will break and funds will be lost.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L171-L177  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L174-L181  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L165-L172  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L183-L191  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L238-L243   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Revert in the paths (instead of silently returning) when minting is disabled so that tokens are not accepted for conversion or redemption.  
# Handle  @cmichelio   # Vulnerability details  `Router.updateAnchorPrice` iterates over all anchor tokens on each update which is very inefficient and does a lot of expensive storage loads. add a mapping `address => index` to easily retrieve the index of the token in the `arrayAnchors` mapping.  
# Handle  @cmichelio   # Vulnerability details  `DAO.mapPID_finalised` is never read in the contract, only written. Remove it and show the `finalized` state in the frontend based on whether the `FinalisedProposal` event was emitted  
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  Proposals that passed the threshold ("finalized") can be cancelled by a minority again using the `cancelProposal` functions. It only sets `mapPID_votes` to zero but `mapPID_timeStart` and `mapPID_finalising` stay the same and pass the checks in `finaliseProposal` which queues them for execution.  ## Impact  Proposals cannot be cancelled.  ## Recommended Mitigation Steps  Set a cancel flag and check for it in `finaliseProposal` and in execution.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  Anyone can cancel any proposals by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`. This always passes the minority check as the proposal was approved.  ## Impact  An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.  ## Recommended Mitigation Steps  Check `oldProposalID == newProposalID`   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  When depositing two different synths, their weight is added to the same `mapMember_weight[_member]` storage variable. When withdrawing the full amount of one synth with `_processWithdraw(synth, member, basisPoints=10000` the full weight is decreased.  The second deposited synth is now essentially weightless.  ## Impact  Users that deposited more than one synth can not claim their fair share of rewards after a withdrawal.  ## Recommended Mitigation Steps  The weight should be indexed by the synth as well.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `harvest` calls `calcCurrentReward` which computes `_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];`. As one can claim different synths than the synths that they deposited, `mapMemberSynth_lastTime[member][synth]` might still be uninitialized and the `_secondsSinceClaim` becomes the current block timestamp.  ## Impact  The larger the `_secondsSinceClaim` the larger the rewards. This bug allows claiming a huge chunk of the rewards.  ## Recommended Mitigation Steps  Let users only harvest synths that they deposited.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `_deposit` function increases the member's _weight_ by `_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);` which is the swap output amount when trading the deposited underlying synth amount.  Notice that anyone can create synths of custom tokens by calling `Pools.deploySynth(customToken)`.  Therefore an attacker can deposit valueless custom tokens and inflate their member weight as follows:  1. Create a custom token and issue lots of tokens to the attacker 2. Create synth of this token 3. Add liquidity for the `TOKEN <> BASE` pair by providing a single wei of `TOKEN` and `10^18` BASE tokens. This makes the `TOKEN` price very expensive. 4. Mint some synths by paying BASE to the pool 5. Deposit the fake synth, `_weight` will be very high because the token pool price is so high.  Call `harvest(realSynth)` with a synth with actual value. This will increase the synth balance and it can be withdrawn later.  ## Impact  Anyone can inflate their member weight through depositing a custom synth and earn almost all vault rewards by calling `harvest(realSynth)` with a valuable "real" synth. The rewards are distributed pro rata to the member weight which is independent of the actual synth deposited.  ## Recommended Mitigation Steps  The `calcReward` function completely disregards the `synth` parameter which seems odd. Think about making the rewards based on the actual synths deposited instead of a "global" weight tracker. Alternatively, whitelist certain synths that count toward the weight, or don't let anyone create synths.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Vader._transfer` function burns the transfer fee on `msg.sender` but this address might not be involved in the transfer at all due to `transferFrom`.  ## Impact  Smart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality.  ## Recommended Mitigation Steps  It should first increase the balance of `recipient` by the full amount and then burn the fee on the `recipient`.  
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Utils.getInterestOwed` function computes the `_interestPayment` as:  ```solidity uint256 _interestPayment =   calcShare(       timeElapsed,       _year,       getInterestPayment(collateralAsset, debtAsset)   ); // Share of the payment over 1 year ```  However, `calcShare` caps `timeElpased` to `_year` and therefore the owed interest does not grow after a year has elapsed.  ## Impact  The impact is probably small because the only call so far computes the elapsed time as `block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];` which most likely will never go beyond a year.  It's still recommended to fix the logic bug in case more functions will be added that use the broken function.  ## Recommended Mitigation Steps  Use a different function than `calcShare` that does not cap.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `flashProof` modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block.  However, it performs this check on `tx.origin` and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.  But flash loan attacks are theoretically not limited to the same transaction but to the same block as miners have full control of the block and include several vulnerable transactions back to back. (Think transaction _bundles_ similar to flashbot bundles that most mining pools currently offer.)  A miner can deploy a proxy smart contract relaying all contract calls and call it from a different EOA each time bypassing the `tx.origin` restriction.  ## Impact  The `flashProof` modifier does not serve its purpose.  ## Recommended Mitigation Steps  Try to apply the modifier to individual addresses that interact with the protocol instead of `tx.origin`.  Furthermore, attacks possible with flash loans are usually also possible for whales, making it debatable if adding flash-loan prevention logic is a good practice.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The inline-comment defines the number of asymmetric shares as `(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3` but the `Utils.calcAsymmetricShare` function computes `(uA * 2U^2 - 2uU + u^2) / U^3` which is not equivalent as can be seen from the `A^2` term in the first term which does not occur in the second one. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.  ## Impact  The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share which is used to determine the collateral value in base tokens could be wrong. For example, it might be possible to borrow more than the collateral put up.  ## Recommended Mitigation Steps  Clarify if the comment is correct or the code and fix them.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Router.getAnchorPrice` sorts the `arrayPrices` array and always returns the third element `_sortedAnchorFeed[2]`. This only returns the median if `_sortedAnchorFeed` is of length 5, but it can be anything from `0` to `anchorLimit`.  ## Impact  If not enough anchors are listed initially, it might become out-of-bounds and break all contract functionality due to revert, or return a wrong median. If `anchorLimit` is set to a different value than 5, it's also wrong.  ## Recommended Mitigation Steps  Check the length of `_sortedAnchorFeed` and return `_sortedAnchorFeed[_sortedAnchorFeed.length / 2]` if it's odd, or the average of the two in the middle if it's even.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Router.swapWithSynthsWithLimit` allows trading token to token and specifying slippage protection. A token to token trade consists of two trades:  1. token to base 2. base to token  The slippage protection of the second trade (base to token) is computed wrong:  ```solidity require(iUTILS(UTILS()).calcSwapSlip(         inputAmount, // should use outToken here from prev trade         iPOOLS(POOLS).getBaseAmount(outputToken)   ) <= slipLimit ); ```  It compares the **token** input amount (of the first trade) to the **base** reserve of the second pair.  ## Impact  Slippage protection fails and either the trade is cancelled when it shouldn't be or it is accepted even though the user suffered more losses than expected.  ## Recommended Mitigation Steps  It should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pool.lockUnits` allows anyone to steal pool tokens from a `member` and assign them to `msg.sender`.  ## Impact  Anyone can steal pool tokens from any other user.  ## Recommended Mitigation Steps  Add access control and require that `msg.sender` is the router or another authorized party.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pools.mintSynth` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `mintSynth(token, token, member)`.  The `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.  ## Impact  It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased.  The amount that is minted could also be inflated (cheaper than sending the actual base tokens), especially if `token` is a high-precision token or worth less than base.  ## Recommended Mitigation Steps  Check that `base` is either `USDV` or `VADER` in `mintSynth`.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `getAddedAmount` function only works correctly when called with `(VADER/USDV, pool)` or `(pool, pool)`. However, when called with (`token, pool)` where `token` is neither `VADER/USDV/pool`, it returns wrong results:  1. It gets the `token` balance 2. And subtracts it from the stored `mapToken_tokenAmount[_pool]` amount which can be that of a completely different token  ## Impact  Anyone can break individual pairs by calling `sync(token1, token2)` where the `token1` balance is less than `mapToken_tokenAmount[token2]`. This will add the difference to `mapToken_tokenAmount[token2]` and break the accounting and result in a wrong swap logic.  Furthermore, this can also be used to swap tokens without having to pay anthing with `swap(token1, token2, member, toBase=false)`.  ## Recommended Mitigation Steps  Add a require statement in the `else` branch that checks that `_token == _pool`.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pools.swap` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `swap(token, token, member, toBase=false)`.  The `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.  ## Impact  It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased (and `token` decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.  Another example scenario is that the token pool amount can be stolen. Send `tokenIn=baseAmount` of tokens to the pool and call `swap(base=token, token, member, toBase=false)`. Depending on the price of `token` relative to `base` this could be cheaper than trading with the base tokens.  ## Recommended Mitigation Steps  Check that `base` is either `USDV` or `VADER`  
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The spec defines the number of LP units to be minted as `units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments` but the `Utils.calcLiquidityUnits` function computes `((P * part1) + part2) / part3 * slipAdjustments`. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.  ## Impact  The math from the spec is not correclty implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.  ## Recommended Mitigation Steps  Fix the equation.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The internal _transfer() function is called from external facing transfer(), transferFrom() and transferTo() functions all of which have different sender addresses. It is msg.sender for transfer(), sender parameter for transferFrom() and tx.origin for transferTo(). These different senders are reflected in the sender parameter of _transfer() function. While this sender parameter is correctly used for transfer of tokens within _transfer, the call to _burn() on L129 incorrectly uses msg.sender as the burn address which is correct only in the case of the transfer() caller's context. This is incorrect for transferFrom() and transferTo() caller contexts.  This will incorrectly burn the fees from a different (intermediate contract) account for all users of the protocol interacting with the transferTo() and transferFrom() functions and lead to incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L129  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L122-L134  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L91-L94  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L108-L112  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L116-L119    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change L129 to: _burn(sender, _fee);   
# Handle  jvaqa   # Vulnerability details  ## Impact Gas Optimization: DAO.sol Unnecessary Multiple Return Statements  ## Recommended Mitigation Steps  In DAO.sol, replace this:  if(votes > consensus){     return true; } else {     return false; }  With this:  return (votes > consensus)  
# Handle  jvaqa   # Vulnerability details  ## Impact  Gas Optimization: Utils.sol Make An Unnecessary Multiplication And Division By An Identical Value  The value "(T1 * B1) / T1" is identical to the value "B1", so you can simplify the expression "B1 + (T1 * B1) / T1" to "B1 + B1".  ## Recommended Mitigation Steps  In Utils.sol, replace this:  uint _redemptionValue = B1 + (T1 * B1) / T1;   With this:  uint _redemptionValue = B1 + B1;  
# Handle  jvaqa   # Vulnerability details  ## Impact  Gas Optimization: Vader.sol Unnecessary Conditional  You can remove this conditional entirely.  ## Recommended Mitigation Steps  In Vader.sol, change this:  if(emitting){         emitting = false;     } else {         emitting = true;     }  To this:  emitting = !emitting;  
# Handle  jvaqa   # Vulnerability details  ## Impact  Avoid Unnecessary Expensive SSTORE Calls In Vether.sol By Checking If _fee Is Non-Zero  SSTORE calls (writes to storage) are very expensive, especially for cold-storage slots (those that have not yet been accessed this transaction). We know that the SSTORE call to totalFees will be a cold storage call, since this is the only place in the whole contract that totalFees is used. Vether.sol makes two SSTORE calls in _transfer that are unnecessary when _fee is zero. It will be common for _fee to be zero, since Vether.sol implements an "excluded addresses" list (mapAddress_Excluded), where _fee is zero when either the sender or the recipient is on the excludedAddresses list. Currently, anyone can add themselves to the excludedAddresses list, but that is probably a mistake.  Nevertheless, since it will probably at least include Uniswap, we should add a check for whether _fee is zero.  ## Proof of Concept When _fee is zero, Vether._transfer() nevertheless makes these two unnecessary SSTORE calls:  _balances[address(this)] += _fee; totalFees += _fee;  ## Recommended Mitigation Steps  Change this:  _balances[address(this)] += _fee; totalFees += _fee;  To this:  if(_fee > 0){   _balances[address(this)] += _fee;   totalFees += _fee; }    
# Handle  0xRajeev   # Vulnerability details  ## Impact  The conditional checking if proposal has quorum in finaliseProposal() is unnecessary and will never be triggered because finalising proposals will always have quorum. Proposal without quorum are not finalised in the voteProposal() function.  Removing this code will reduce contract size and save some gas.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L114-L116  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L82-L90  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L94-L99   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove code from L114 to L116.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Instead of performing a zero-address check in moveRewardAddress on L146 or L152, it is more efficient to do so in newAddressProposal() as soon as the new address is proposed, instead of allowing a proposal for zero-address which goes through the whole voting process. If there is a requirement for zero-address proposals, it should be specified explicitly.  Depending on the participation in the voting process, this will save significant amount of gas for all the participants.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L69-L74  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L144-L154  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Perform input validation of zero-address in newAddressProposal() for proposedAddress parameter.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  changeDAO() updates DAO address in one-step. If an incorrect address is mistakenly used (and voted upon) then future administrative access or recovering from this mistake is prevented because onlyDAO modifier is used for changeDAO(), which requires msg.sender to be the incorrectly used DAO address (for which private keys may not be available to sign transactions).  Reference: See finding #6 from Trail of Bits audit of Hermez Network: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L192-L196   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use a two-step process where the old DAO address first proposes new ownership in one transaction and a second transaction from the newly proposed DAO address accepts ownership. A mistake in the first step can be recovered by granting with a new correct address again before the new DAO address accepts ownership. Ideally, there should also be a timelock enforced before the new DAO takes effect.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function setRewardAddress is used by DAO to change rewardAddress from USDV to something else. However, there is no zero-address validation on the address. This may accidentally mint rewards to zero-address.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L80  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L209  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L183-L186   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address check to setRewardAddress.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  From Solidity’s documentation (https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables), “State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value. Compared to regular state variables, the gas costs of constant and immutable variables are much lower.”  The burnAddress variable  can be made immutable. This will avoid the use of one storage slot and lead to gas savings.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L36   https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L71  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Make burnAddress immutable.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  One of the stated protocol (review) goals is to detect susceptibility to “Any attack vectors using flash loans on Anchor price, synths or lending.” As such, USDV contract aims to protect against flash attacks using flashProof() modifier which uses the following check in isMature() to determine if currently executing contract context is at least blockDelay duration ahead of the previous context: lastBlock[tx.origin] + blockDelay <= block.number  However, blockDelay state variable is not initialized which means it has a default uint value of 0. So unless it is set to >= 1 by setParams() which can be called only by the DAO (which currently does not have the capability to call setParams() function), blockDelay will be 0 which allows current executing context (block.number) to be the same as the previous one (lastBlock[tx.origin]). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks as opposed to what is expected as commented on L41: "// Stops an EOA doing a flash attack in same block"  Even if the DAO can call setParams() to change blockDelay to >= 1, there is a big window of opportunity for flash attacks until the DAO votes, finalises and approves such a proposal. Moreover, such proposals can be cancelled by a DAO minority or replaced by a malicious DAO minority to launch flash attacks.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L22  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L140-L142  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L35-L44  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L174    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Initialize blockDelay to >= 1 at declaration or in constructor.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  From Solidity’s documentation (https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables), “State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value. Compared to regular state variables, the gas costs of constant and immutable variables are much lower.”  State variables name, symbol and decimals can be declared as constants and assigned at declaration (instead of constructor) because they are never modified later. This avoid 3 storage slots and associated expensive SSTOREs/SLOADs to save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L12-L13   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Declare state variables name, symbol and decimals as constant.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The deploySynth() function in Pools.sol is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory’s deploySynth() function.   However, the require() incorrectly uses ‘||’ operator instead of ‘&&’ which allows both VADER and USDV to be supplied as the token parameters. This will allow an attacker to deploy either VADER or USDV as a Synth which will break assumptions throughout the entire protocol. Protocol will break and funds may be lost.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L138   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change ‘||’ operator to ‘&&’ in the require statement: require(token != VADER && token != USDV);   
# Handle  0xRajeev   # Vulnerability details  ## Impact  _isMember mapping state variable is declared and used only in the getter function isMember(), but is net assigned to anywhere in the contract. This will consume an unnecessary storage slot and along with its getter function will also increase the contract size.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L22  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L215-L217   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove _isMember state variable declaration on L22 and related getter function isMember().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  A bool in Solidity is internally represented as a unit8 and so required only 8 bits of the 256-bits storage slot. An address variable is 160-bits. So declaring a bool next to an address variable lets Solidity pack them in the same storage slot thereby using one slot instead of two.  Moving the inited bool state variable next to one of the address state variables VADER, USDV, ROUTER or FACTORY lets the compiler pack them together in one storage slot instead of two, thereby saving one slot. It costs 20k gas to SSTORE each slot of data.  The current order where inited bool is declared before uint does not allow packing because uint itself requires the entire 256-bits of a slot, which forces the compiler to use one full slot for the inited bool variable.  For reference, see https://mudit.blog/solidity-gas-optimization-tips/  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L13-L20   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move inited bool state variable declaration next to an address state variable declaration.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  If the requirement is that listed anchors are unique token addresses, then the loop in replaceAnchor() can break upon match+replace to save gas from executing more loop iterations.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L261-L265   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a break statement after L263.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  There is no input validation in replacePool() function to check if oldToken exists and is curated. Using a non-existing oldToken (even 0 address) passes the check on L236 (because Pools.getBaseAmount() will return 0 for the non-existing token) and newToken will be made curated. This can be used to bypass the curatedPoolLimit enforced only in curatePool() function.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L234-L241  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L227-L229  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L227  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check if oldToken exists and is curated as part of input validation in replacePool() function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  repayDelay uint state variable is declared but never used elsewhere. This will consume an unnecessary storage slot and also increase the contract size.  ## Proof of Concept https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L35   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove repayDelay state variable declaration on L35.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The conditional in calcReward() function uses the same code in both if/else parts with repeated use of reserveUSDV, reserveVADER and getUSDVAmount leading to incorrect computed value of _adjustedReserve in the else part.  This will affect harvest rewards for all users of the protocol and lead to incorrect accounting. Protocol will break and lead to fund loss.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L141  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L144  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L125  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L105   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change variables and function calls from using USDV to VADER in the else part of the conditional which has to return the adjusted reserves when synth is not an asset i.e. an anchor and therefore base is VADER.  L144 should be changed to: uint _adjustedReserve = iROUTER(ROUTER).getVADERAmount(reserveUSDV()) + reserveVADER();   
# Handle  gpersoon   # Vulnerability details  ## Impact Vault.sol has a different pragma statement than the rest, it contains an additional "^".  For the record the Vether.sol contract (as deployed here https://etherscan.io/address/0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279#code),  has a different solidity version.  It's cleaner to use the same versions.  ## Proof of Concept  DAO.sol:pragma solidity 0.8.3; Factory.sol:pragma solidity 0.8.3; Pools.sol:pragma solidity 0.8.3; Router.sol:pragma solidity 0.8.3; Synth.sol:pragma solidity 0.8.3; USDV.sol:pragma solidity 0.8.3; Utils.sol:pragma solidity 0.8.3; Vader.sol:pragma solidity 0.8.3; Vault.sol:pragma solidity ^0.8.3; Vether.sol:pragma solidity 0.6.4;  ## Tools Used Editor  ## Recommended Mitigation Steps Use the same solidity versions   
# Handle  gpersoon   # Vulnerability details  ## Impact The function transferOut of Pools.sol contains a iERC20(_token).transfer where the result of the function isn't checked. This could result in transfers that don't succeed are undetected.  ## Proof of Concept Pools.sol:   function transferOut(address _token, uint _amount, address _recipient) internal {         if(_token == VADER){             pooledVADER = pooledVADER - _amount; // Accounting         } else if(_token == USDV) {             pooledUSDV = pooledUSDV - _amount;  // Accounting         }         if(_recipient != address(this)){             iERC20(_token).transfer(_recipient, _amount);         }     }  ## Tools Used Editor  ## Recommended Mitigation Steps Add a require statement to check the result: require(...transfer(...) )   
# Handle  gpersoon   # Vulnerability details  ## Impact Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.  ## Proof of Concept  DAO.sol:    function init(address _vader, address _usdv, address _vault) public { Factory.sol:    function init(address _pool) public { Pools.sol:    function init(address _vader, address _usdv, address _router, address _factory) public { Router.sol:    function init(address _vader, address _usdv, address _pool) public { USDV.sol:    function init(address _vader, address _vault, address _router) external { Utils.sol:    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public { Vader.sol:    function init(address _vether, address _USDV, address _utils) external { Vault.sol:    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {    ## Tools Used Editor  ## Recommended Mitigation Steps Add a check to the init function, for example that only the deployer can call the function.  
# Handle  gpersoon   # Vulnerability details  ## Impact There is some unused / redundant code present.  Router.sol defines repayDelay but it is never used Vault.sol initializes POOLS twice, with the same value.  ## Proof of Concept Router.sol: uint public repayDelay = 3600;  Vault.sol:  function init(address _vader, address _usdv, address _router, ... ..         POOLS = _pool; ..           POOLS = _pool;     ## Tools Used Editor  ## Recommended Mitigation Steps Remove redundant code  
# Handle  JMukesh   # Vulnerability details  ## Impact public functions that are never called by the contract should be declared external to save gas.  ## Proof of Concept  1. In Vault.sol  -- > init() and grant()                     https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L45  https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L68  2. Vader.sol -- > burn()    https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L146  3. Utils.sol -- > init(),  getProtection()   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L30  4. Router.sol -- >  init(address,address,address)  getVADERAmount(uint256)  getUSDVAmount(uint256)  borrow(uint256,address,address)  repay(uint256,address,address)  checkLiquidate() getSystemCollateral(address,address)  getSystemDebt(address,address) getSystemInterestPaid()   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L77  5. Pools.sol  init(address,address,address,address)  isMember(address)  isSynth(address)   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol  6. Dao.sol  init(address,address,address)  newGrantProposal(address,uint256)  newAddressProposal(address,string)  voteProposal(uint256)  cancelProposal(uint256,uint256)  finaliseProposal(uint256)  https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/DAO.sol#L46    ## Tools Used  slither  ## Recommended Mitigation Steps  use external instead of public visibility to save gas  
# Handle  shw   # Vulnerability details  ## Impact  In `Router.sol`, the second `else if` statement in the function `swapWithSynthsWithLimit` is unnecessary.  ## Proof of Concept  Referenced code: [Router.sol#L162](https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L162)  ## Tools Used  None  ## Recommended Mitigation Steps  Consider using `else {...}`, which has the identical behavior to save gas.  
# Handle  paulius.eth   # Vulnerability details  ## Impact Both structs CollateralDetails and DebtDetails have unused ID field which is never set nor queried:    uint ID;  
# Handle  paulius.eth   # Vulnerability details  ## Impact In function updateAnchorPrice here 'arrayAnchors[i]' can be replaced with 'token' to eliminate one expensive storage access:    arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);  
# Handle  paulius.eth   # Vulnerability details  ## Impact Condition could be '>', not '>=' as there is no point in recalculating amount to the same value (waste of gas):  if((totalSupply + amount) >= maxSupply){   amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply  }  
# Handle  a_delamo   # Vulnerability details  Here you have more information: https://gist.github.com/alexon1234/5eb3fff3bded4e4c50d6e13abae6f474  
# Handle  paulius.eth   # Vulnerability details  ## Impact a bit cheapier when you replace:   require(inited == false); with:   require(!inited); same with variable == true.  
# Handle  paulius.eth   # Vulnerability details  ## Impact Here are some useless calculations:   if(_token == VADER && _pool != VADER){  // Want to know added VADER      addedAmount = _balance - pooledVADER;      pooledVADER = pooledVADER + addedAmount;  } else if(_token == USDV) {             // Want to know added USDV      addedAmount = _balance - pooledUSDV;      pooledUSDV = pooledUSDV + addedAmount; if you do the simple maths, it is always in the first case, pooledVADER = _balance, in the second case pooledUSDV = _balance.   
# Handle  paulius.eth   # Vulnerability details  ## Impact There are variables that are only assigned once (e.g. in a constructor). You should mark such variables with the keyword "immutable", this greatly reduces the gas costs. A concrete example of such a variable is "VADER" which is only initialized once and cannot be changed later:    VADER = _vader; There are plenty of such variables across the contracts.   
# Handle  paulius.eth   # Vulnerability details  ## Impact iERC20 decimals field is declared as uint, but to be exact, ERC20 specification declares decimals as uint8. Anyway, this has no security impact as 18 decimals is set which fits in uint8.  ## Recommended Mitigation Steps You can refactor to uint8 or just be informed about such compatibility guidelines.  
# Handle  s1m0   # Vulnerability details  ## Impact The following functions check that an uint > 0 but it's always true.  ## Proof of Concept https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L278 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L197 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L127  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Remove the checks.  
# Handle  s1m0   # Vulnerability details  ## Impact Events not emitted for important state changes. https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L93 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L98 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L196 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L201 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L61 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L163 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L171 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L179 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L184 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L188 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L193 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L198  ## Proof of Concept -  ## Tools Used Manual analysis.  ## Recommended Mitigation Steps Emit events with meaningful names for the changes made.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The flipMinting() function can disable/stop conversion/redeeming of VADER<>USDV tokens upon DAO approval (when that functionality is added). When minting is disabled (i.e. false), the convert functions in USDV.sol accept VADER tokens from sender (L170) but do not burn them to mint the sender the equivalent USDV tokens. When minting is disabled (i.e. false), the redeem functions in USDV.sol accept USDV tokens from sender (L188) but do not burn them to mint the sender the equivalent VADER tokens. Both paths silently return 0 without reverting the transaction thus trapping the sent tokens and leaving the users with lost funds. Protocol will break and funds will be lost.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L171-L177  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L174-L181  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L165-L172  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L183-L191  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L238-L243   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Revert in the paths (instead of silently returning) when minting is disabled so that tokens are not accepted for conversion or redemption.  
# Handle  @cmichelio   # Vulnerability details  `Router.updateAnchorPrice` iterates over all anchor tokens on each update which is very inefficient and does a lot of expensive storage loads. add a mapping `address => index` to easily retrieve the index of the token in the `arrayAnchors` mapping.  
# Handle  @cmichelio   # Vulnerability details  `DAO.mapPID_finalised` is never read in the contract, only written. Remove it and show the `finalized` state in the frontend based on whether the `FinalisedProposal` event was emitted  
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  Proposals that passed the threshold ("finalized") can be cancelled by a minority again using the `cancelProposal` functions. It only sets `mapPID_votes` to zero but `mapPID_timeStart` and `mapPID_finalising` stay the same and pass the checks in `finaliseProposal` which queues them for execution.  ## Impact  Proposals cannot be cancelled.  ## Recommended Mitigation Steps  Set a cancel flag and check for it in `finaliseProposal` and in execution.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  Anyone can cancel any proposals by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`. This always passes the minority check as the proposal was approved.  ## Impact  An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.  ## Recommended Mitigation Steps  Check `oldProposalID == newProposalID`   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  When depositing two different synths, their weight is added to the same `mapMember_weight[_member]` storage variable. When withdrawing the full amount of one synth with `_processWithdraw(synth, member, basisPoints=10000` the full weight is decreased.  The second deposited synth is now essentially weightless.  ## Impact  Users that deposited more than one synth can not claim their fair share of rewards after a withdrawal.  ## Recommended Mitigation Steps  The weight should be indexed by the synth as well.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `harvest` calls `calcCurrentReward` which computes `_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];`. As one can claim different synths than the synths that they deposited, `mapMemberSynth_lastTime[member][synth]` might still be uninitialized and the `_secondsSinceClaim` becomes the current block timestamp.  ## Impact  The larger the `_secondsSinceClaim` the larger the rewards. This bug allows claiming a huge chunk of the rewards.  ## Recommended Mitigation Steps  Let users only harvest synths that they deposited.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `_deposit` function increases the member's _weight_ by `_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);` which is the swap output amount when trading the deposited underlying synth amount.  Notice that anyone can create synths of custom tokens by calling `Pools.deploySynth(customToken)`.  Therefore an attacker can deposit valueless custom tokens and inflate their member weight as follows:  1. Create a custom token and issue lots of tokens to the attacker 2. Create synth of this token 3. Add liquidity for the `TOKEN <> BASE` pair by providing a single wei of `TOKEN` and `10^18` BASE tokens. This makes the `TOKEN` price very expensive. 4. Mint some synths by paying BASE to the pool 5. Deposit the fake synth, `_weight` will be very high because the token pool price is so high.  Call `harvest(realSynth)` with a synth with actual value. This will increase the synth balance and it can be withdrawn later.  ## Impact  Anyone can inflate their member weight through depositing a custom synth and earn almost all vault rewards by calling `harvest(realSynth)` with a valuable "real" synth. The rewards are distributed pro rata to the member weight which is independent of the actual synth deposited.  ## Recommended Mitigation Steps  The `calcReward` function completely disregards the `synth` parameter which seems odd. Think about making the rewards based on the actual synths deposited instead of a "global" weight tracker. Alternatively, whitelist certain synths that count toward the weight, or don't let anyone create synths.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Vader._transfer` function burns the transfer fee on `msg.sender` but this address might not be involved in the transfer at all due to `transferFrom`.  ## Impact  Smart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality.  ## Recommended Mitigation Steps  It should first increase the balance of `recipient` by the full amount and then burn the fee on the `recipient`.  
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Utils.getInterestOwed` function computes the `_interestPayment` as:  ```solidity uint256 _interestPayment =   calcShare(       timeElapsed,       _year,       getInterestPayment(collateralAsset, debtAsset)   ); // Share of the payment over 1 year ```  However, `calcShare` caps `timeElpased` to `_year` and therefore the owed interest does not grow after a year has elapsed.  ## Impact  The impact is probably small because the only call so far computes the elapsed time as `block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];` which most likely will never go beyond a year.  It's still recommended to fix the logic bug in case more functions will be added that use the broken function.  ## Recommended Mitigation Steps  Use a different function than `calcShare` that does not cap.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `flashProof` modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block.  However, it performs this check on `tx.origin` and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.  But flash loan attacks are theoretically not limited to the same transaction but to the same block as miners have full control of the block and include several vulnerable transactions back to back. (Think transaction _bundles_ similar to flashbot bundles that most mining pools currently offer.)  A miner can deploy a proxy smart contract relaying all contract calls and call it from a different EOA each time bypassing the `tx.origin` restriction.  ## Impact  The `flashProof` modifier does not serve its purpose.  ## Recommended Mitigation Steps  Try to apply the modifier to individual addresses that interact with the protocol instead of `tx.origin`.  Furthermore, attacks possible with flash loans are usually also possible for whales, making it debatable if adding flash-loan prevention logic is a good practice.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The inline-comment defines the number of asymmetric shares as `(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3` but the `Utils.calcAsymmetricShare` function computes `(uA * 2U^2 - 2uU + u^2) / U^3` which is not equivalent as can be seen from the `A^2` term in the first term which does not occur in the second one. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.  ## Impact  The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share which is used to determine the collateral value in base tokens could be wrong. For example, it might be possible to borrow more than the collateral put up.  ## Recommended Mitigation Steps  Clarify if the comment is correct or the code and fix them.   
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Router.getAnchorPrice` sorts the `arrayPrices` array and always returns the third element `_sortedAnchorFeed[2]`. This only returns the median if `_sortedAnchorFeed` is of length 5, but it can be anything from `0` to `anchorLimit`.  ## Impact  If not enough anchors are listed initially, it might become out-of-bounds and break all contract functionality due to revert, or return a wrong median. If `anchorLimit` is set to a different value than 5, it's also wrong.  ## Recommended Mitigation Steps  Check the length of `_sortedAnchorFeed` and return `_sortedAnchorFeed[_sortedAnchorFeed.length / 2]` if it's odd, or the average of the two in the middle if it's even.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Router.swapWithSynthsWithLimit` allows trading token to token and specifying slippage protection. A token to token trade consists of two trades:  1. token to base 2. base to token  The slippage protection of the second trade (base to token) is computed wrong:  ```solidity require(iUTILS(UTILS()).calcSwapSlip(         inputAmount, // should use outToken here from prev trade         iPOOLS(POOLS).getBaseAmount(outputToken)   ) <= slipLimit ); ```  It compares the **token** input amount (of the first trade) to the **base** reserve of the second pair.  ## Impact  Slippage protection fails and either the trade is cancelled when it shouldn't be or it is accepted even though the user suffered more losses than expected.  ## Recommended Mitigation Steps  It should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pool.lockUnits` allows anyone to steal pool tokens from a `member` and assign them to `msg.sender`.  ## Impact  Anyone can steal pool tokens from any other user.  ## Recommended Mitigation Steps  Add access control and require that `msg.sender` is the router or another authorized party.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pools.mintSynth` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `mintSynth(token, token, member)`.  The `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.  ## Impact  It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased.  The amount that is minted could also be inflated (cheaper than sending the actual base tokens), especially if `token` is a high-precision token or worth less than base.  ## Recommended Mitigation Steps  Check that `base` is either `USDV` or `VADER` in `mintSynth`.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `getAddedAmount` function only works correctly when called with `(VADER/USDV, pool)` or `(pool, pool)`. However, when called with (`token, pool)` where `token` is neither `VADER/USDV/pool`, it returns wrong results:  1. It gets the `token` balance 2. And subtracts it from the stored `mapToken_tokenAmount[_pool]` amount which can be that of a completely different token  ## Impact  Anyone can break individual pairs by calling `sync(token1, token2)` where the `token1` balance is less than `mapToken_tokenAmount[token2]`. This will add the difference to `mapToken_tokenAmount[token2]` and break the accounting and result in a wrong swap logic.  Furthermore, this can also be used to swap tokens without having to pay anthing with `swap(token1, token2, member, toBase=false)`.  ## Recommended Mitigation Steps  Add a require statement in the `else` branch that checks that `_token == _pool`.   
# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pools.swap` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `swap(token, token, member, toBase=false)`.  The `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.  ## Impact  It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased (and `token` decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.  Another example scenario is that the token pool amount can be stolen. Send `tokenIn=baseAmount` of tokens to the pool and call `swap(base=token, token, member, toBase=false)`. Depending on the price of `token` relative to `base` this could be cheaper than trading with the base tokens.  ## Recommended Mitigation Steps  Check that `base` is either `USDV` or `VADER`  
# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The spec defines the number of LP units to be minted as `units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments` but the `Utils.calcLiquidityUnits` function computes `((P * part1) + part2) / part3 * slipAdjustments`. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.  ## Impact  The math from the spec is not correclty implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.  ## Recommended Mitigation Steps  Fix the equation.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The internal _transfer() function is called from external facing transfer(), transferFrom() and transferTo() functions all of which have different sender addresses. It is msg.sender for transfer(), sender parameter for transferFrom() and tx.origin for transferTo(). These different senders are reflected in the sender parameter of _transfer() function. While this sender parameter is correctly used for transfer of tokens within _transfer, the call to _burn() on L129 incorrectly uses msg.sender as the burn address which is correct only in the case of the transfer() caller's context. This is incorrect for transferFrom() and transferTo() caller contexts.  This will incorrectly burn the fees from a different (intermediate contract) account for all users of the protocol interacting with the transferTo() and transferFrom() functions and lead to incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L129  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L122-L134  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L91-L94  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L108-L112  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L116-L119    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change L129 to: _burn(sender, _fee);   
# Handle  jvaqa   # Vulnerability details  ## Impact Gas Optimization: DAO.sol Unnecessary Multiple Return Statements  ## Recommended Mitigation Steps  In DAO.sol, replace this:  if(votes > consensus){     return true; } else {     return false; }  With this:  return (votes > consensus)  
# Handle  jvaqa   # Vulnerability details  ## Impact  Gas Optimization: Utils.sol Make An Unnecessary Multiplication And Division By An Identical Value  The value "(T1 * B1) / T1" is identical to the value "B1", so you can simplify the expression "B1 + (T1 * B1) / T1" to "B1 + B1".  ## Recommended Mitigation Steps  In Utils.sol, replace this:  uint _redemptionValue = B1 + (T1 * B1) / T1;   With this:  uint _redemptionValue = B1 + B1;  
# Handle  jvaqa   # Vulnerability details  ## Impact  Gas Optimization: Vader.sol Unnecessary Conditional  You can remove this conditional entirely.  ## Recommended Mitigation Steps  In Vader.sol, change this:  if(emitting){         emitting = false;     } else {         emitting = true;     }  To this:  emitting = !emitting;  
# Handle  jvaqa   # Vulnerability details  ## Impact  Avoid Unnecessary Expensive SSTORE Calls In Vether.sol By Checking If _fee Is Non-Zero  SSTORE calls (writes to storage) are very expensive, especially for cold-storage slots (those that have not yet been accessed this transaction). We know that the SSTORE call to totalFees will be a cold storage call, since this is the only place in the whole contract that totalFees is used. Vether.sol makes two SSTORE calls in _transfer that are unnecessary when _fee is zero. It will be common for _fee to be zero, since Vether.sol implements an "excluded addresses" list (mapAddress_Excluded), where _fee is zero when either the sender or the recipient is on the excludedAddresses list. Currently, anyone can add themselves to the excludedAddresses list, but that is probably a mistake.  Nevertheless, since it will probably at least include Uniswap, we should add a check for whether _fee is zero.  ## Proof of Concept When _fee is zero, Vether._transfer() nevertheless makes these two unnecessary SSTORE calls:  _balances[address(this)] += _fee; totalFees += _fee;  ## Recommended Mitigation Steps  Change this:  _balances[address(this)] += _fee; totalFees += _fee;  To this:  if(_fee > 0){   _balances[address(this)] += _fee;   totalFees += _fee; }    
# Handle  0xRajeev   # Vulnerability details  ## Impact  The conditional checking if proposal has quorum in finaliseProposal() is unnecessary and will never be triggered because finalising proposals will always have quorum. Proposal without quorum are not finalised in the voteProposal() function.  Removing this code will reduce contract size and save some gas.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L114-L116  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L82-L90  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L94-L99   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove code from L114 to L116.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Instead of performing a zero-address check in moveRewardAddress on L146 or L152, it is more efficient to do so in newAddressProposal() as soon as the new address is proposed, instead of allowing a proposal for zero-address which goes through the whole voting process. If there is a requirement for zero-address proposals, it should be specified explicitly.  Depending on the participation in the voting process, this will save significant amount of gas for all the participants.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L69-L74  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L144-L154  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Perform input validation of zero-address in newAddressProposal() for proposedAddress parameter.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  changeDAO() updates DAO address in one-step. If an incorrect address is mistakenly used (and voted upon) then future administrative access or recovering from this mistake is prevented because onlyDAO modifier is used for changeDAO(), which requires msg.sender to be the incorrectly used DAO address (for which private keys may not be available to sign transactions).  Reference: See finding #6 from Trail of Bits audit of Hermez Network: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L192-L196   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use a two-step process where the old DAO address first proposes new ownership in one transaction and a second transaction from the newly proposed DAO address accepts ownership. A mistake in the first step can be recovered by granting with a new correct address again before the new DAO address accepts ownership. Ideally, there should also be a timelock enforced before the new DAO takes effect.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Function setRewardAddress is used by DAO to change rewardAddress from USDV to something else. However, there is no zero-address validation on the address. This may accidentally mint rewards to zero-address.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L80  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L209  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L183-L186   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address check to setRewardAddress.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  From Solidity’s documentation (https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables), “State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value. Compared to regular state variables, the gas costs of constant and immutable variables are much lower.”  The burnAddress variable  can be made immutable. This will avoid the use of one storage slot and lead to gas savings.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L36   https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L71  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Make burnAddress immutable.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  One of the stated protocol (review) goals is to detect susceptibility to “Any attack vectors using flash loans on Anchor price, synths or lending.” As such, USDV contract aims to protect against flash attacks using flashProof() modifier which uses the following check in isMature() to determine if currently executing contract context is at least blockDelay duration ahead of the previous context: lastBlock[tx.origin] + blockDelay <= block.number  However, blockDelay state variable is not initialized which means it has a default uint value of 0. So unless it is set to >= 1 by setParams() which can be called only by the DAO (which currently does not have the capability to call setParams() function), blockDelay will be 0 which allows current executing context (block.number) to be the same as the previous one (lastBlock[tx.origin]). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks as opposed to what is expected as commented on L41: "// Stops an EOA doing a flash attack in same block"  Even if the DAO can call setParams() to change blockDelay to >= 1, there is a big window of opportunity for flash attacks until the DAO votes, finalises and approves such a proposal. Moreover, such proposals can be cancelled by a DAO minority or replaced by a malicious DAO minority to launch flash attacks.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L22  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L140-L142  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L35-L44  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L174    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Initialize blockDelay to >= 1 at declaration or in constructor.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  From Solidity’s documentation (https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables), “State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value. Compared to regular state variables, the gas costs of constant and immutable variables are much lower.”  State variables name, symbol and decimals can be declared as constants and assigned at declaration (instead of constructor) because they are never modified later. This avoid 3 storage slots and associated expensive SSTOREs/SLOADs to save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L12-L13   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Declare state variables name, symbol and decimals as constant.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The deploySynth() function in Pools.sol is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory’s deploySynth() function.   However, the require() incorrectly uses ‘||’ operator instead of ‘&&’ which allows both VADER and USDV to be supplied as the token parameters. This will allow an attacker to deploy either VADER or USDV as a Synth which will break assumptions throughout the entire protocol. Protocol will break and funds may be lost.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L138   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change ‘||’ operator to ‘&&’ in the require statement: require(token != VADER && token != USDV);   
# Handle  0xRajeev   # Vulnerability details  ## Impact  _isMember mapping state variable is declared and used only in the getter function isMember(), but is net assigned to anywhere in the contract. This will consume an unnecessary storage slot and along with its getter function will also increase the contract size.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L22  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L215-L217   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove _isMember state variable declaration on L22 and related getter function isMember().   
# Handle  0xRajeev   # Vulnerability details  ## Impact  A bool in Solidity is internally represented as a unit8 and so required only 8 bits of the 256-bits storage slot. An address variable is 160-bits. So declaring a bool next to an address variable lets Solidity pack them in the same storage slot thereby using one slot instead of two.  Moving the inited bool state variable next to one of the address state variables VADER, USDV, ROUTER or FACTORY lets the compiler pack them together in one storage slot instead of two, thereby saving one slot. It costs 20k gas to SSTORE each slot of data.  The current order where inited bool is declared before uint does not allow packing because uint itself requires the entire 256-bits of a slot, which forces the compiler to use one full slot for the inited bool variable.  For reference, see https://mudit.blog/solidity-gas-optimization-tips/  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L13-L20   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move inited bool state variable declaration next to an address state variable declaration.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  If the requirement is that listed anchors are unique token addresses, then the loop in replaceAnchor() can break upon match+replace to save gas from executing more loop iterations.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L261-L265   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a break statement after L263.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  There is no input validation in replacePool() function to check if oldToken exists and is curated. Using a non-existing oldToken (even 0 address) passes the check on L236 (because Pools.getBaseAmount() will return 0 for the non-existing token) and newToken will be made curated. This can be used to bypass the curatedPoolLimit enforced only in curatePool() function.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L234-L241  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L227-L229  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L227  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check if oldToken exists and is curated as part of input validation in replacePool() function.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  repayDelay uint state variable is declared but never used elsewhere. This will consume an unnecessary storage slot and also increase the contract size.  ## Proof of Concept https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L35   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove repayDelay state variable declaration on L35.   
# Handle  0xRajeev   # Vulnerability details  ## Impact  The conditional in calcReward() function uses the same code in both if/else parts with repeated use of reserveUSDV, reserveVADER and getUSDVAmount leading to incorrect computed value of _adjustedReserve in the else part.  This will affect harvest rewards for all users of the protocol and lead to incorrect accounting. Protocol will break and lead to fund loss.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L141  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L144  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L125  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L105   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change variables and function calls from using USDV to VADER in the else part of the conditional which has to return the adjusted reserves when synth is not an asset i.e. an anchor and therefore base is VADER.  L144 should be changed to: uint _adjustedReserve = iROUTER(ROUTER).getVADERAmount(reserveUSDV()) + reserveVADER();   
# Handle  gpersoon   # Vulnerability details  ## Impact Vault.sol has a different pragma statement than the rest, it contains an additional "^".  For the record the Vether.sol contract (as deployed here https://etherscan.io/address/0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279#code),  has a different solidity version.  It's cleaner to use the same versions.  ## Proof of Concept  DAO.sol:pragma solidity 0.8.3; Factory.sol:pragma solidity 0.8.3; Pools.sol:pragma solidity 0.8.3; Router.sol:pragma solidity 0.8.3; Synth.sol:pragma solidity 0.8.3; USDV.sol:pragma solidity 0.8.3; Utils.sol:pragma solidity 0.8.3; Vader.sol:pragma solidity 0.8.3; Vault.sol:pragma solidity ^0.8.3; Vether.sol:pragma solidity 0.6.4;  ## Tools Used Editor  ## Recommended Mitigation Steps Use the same solidity versions   
# Handle  gpersoon   # Vulnerability details  ## Impact The function transferOut of Pools.sol contains a iERC20(_token).transfer where the result of the function isn't checked. This could result in transfers that don't succeed are undetected.  ## Proof of Concept Pools.sol:   function transferOut(address _token, uint _amount, address _recipient) internal {         if(_token == VADER){             pooledVADER = pooledVADER - _amount; // Accounting         } else if(_token == USDV) {             pooledUSDV = pooledUSDV - _amount;  // Accounting         }         if(_recipient != address(this)){             iERC20(_token).transfer(_recipient, _amount);         }     }  ## Tools Used Editor  ## Recommended Mitigation Steps Add a require statement to check the result: require(...transfer(...) )   
# Handle  gpersoon   # Vulnerability details  ## Impact Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.  ## Proof of Concept  DAO.sol:    function init(address _vader, address _usdv, address _vault) public { Factory.sol:    function init(address _pool) public { Pools.sol:    function init(address _vader, address _usdv, address _router, address _factory) public { Router.sol:    function init(address _vader, address _usdv, address _pool) public { USDV.sol:    function init(address _vader, address _vault, address _router) external { Utils.sol:    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public { Vader.sol:    function init(address _vether, address _USDV, address _utils) external { Vault.sol:    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {    ## Tools Used Editor  ## Recommended Mitigation Steps Add a check to the init function, for example that only the deployer can call the function.  
# Handle  gpersoon   # Vulnerability details  ## Impact There is some unused / redundant code present.  Router.sol defines repayDelay but it is never used Vault.sol initializes POOLS twice, with the same value.  ## Proof of Concept Router.sol: uint public repayDelay = 3600;  Vault.sol:  function init(address _vader, address _usdv, address _router, ... ..         POOLS = _pool; ..           POOLS = _pool;     ## Tools Used Editor  ## Recommended Mitigation Steps Remove redundant code  
# Handle  JMukesh   # Vulnerability details  ## Impact public functions that are never called by the contract should be declared external to save gas.  ## Proof of Concept  1. In Vault.sol  -- > init() and grant()                     https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L45  https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L68  2. Vader.sol -- > burn()    https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L146  3. Utils.sol -- > init(),  getProtection()   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L30  4. Router.sol -- >  init(address,address,address)  getVADERAmount(uint256)  getUSDVAmount(uint256)  borrow(uint256,address,address)  repay(uint256,address,address)  checkLiquidate() getSystemCollateral(address,address)  getSystemDebt(address,address) getSystemInterestPaid()   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L77  5. Pools.sol  init(address,address,address,address)  isMember(address)  isSynth(address)   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol  6. Dao.sol  init(address,address,address)  newGrantProposal(address,uint256)  newAddressProposal(address,string)  voteProposal(uint256)  cancelProposal(uint256,uint256)  finaliseProposal(uint256)  https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/DAO.sol#L46    ## Tools Used  slither  ## Recommended Mitigation Steps  use external instead of public visibility to save gas  
