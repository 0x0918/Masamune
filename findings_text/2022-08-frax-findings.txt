# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairConstants.sol#L41 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/LinearInterestRate.sol#L34 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/VariableInterestRate.sol#L40 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/VariableInterestRate.sol#L41   # Vulnerability details  ## Impact  All annual rate constants in the system are calculated with an assumption that block time is 15 second (actually itâ€™s from 12 to 14 seconds as in [the documentation](https://ethereum.org/vi/developers/docs/blocks/#block-time). And these constants are used to calculate rate in rate calculator and also used to reset interest rate when there are no borrows.  But actually, [the merge is really near](https://ethereum.org/vi/upgrades/merge/) and after the merge blocks come exactly each 12 seconds which basically makes all these constants wrong.   This resulted in wrong interest rate after reseting when there are no borrows and wrong rate returned by rate calculators.  ## Proof of Concept  These annual rate is calculated by solving an equation for `r` with an assumption 365.24 days per year and 15s blocks. For example, this is for the 0.5% annual rate ``` 1.005 = (1 + 15*r)^(365.24 * 24 * 3600 / 15) ```   But actually after the merge, blocks come in exactly each 12 seconds. Check out [this blog post](https://blog.ethereum.org/2021/11/29/how-the-merge-impacts-app-layer/) of Tim Beiko   [Line 431-433](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L431-L433) reset interest rate when there are no borrows ```solidity if (!paused()) {     _currentRateInfo.ratePerSec = DEFAULT_INT; } ```  These constants are used in `requireValidInitData()` and also `getNewRate()` function in rate calculators and wrong constants might make `getNewRate()` return wrong value. For example, [line 72-74](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/VariableInterestRate.sol#L72-L74) used `MIN_INT` as new interest rate ```solidity if (_newRatePerSec < MIN_INT) {     _newRatePerSec = MIN_INT; } ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider to update these constants with an assumption that block time is 12 seconds. 
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L194   # Vulnerability details  ## Impact After confirmed with the sponsor, `dirtyLiquidationFee` is 90% of `cleanLiquidationFee` like the [comment](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L194).  But it uses `9% (9000 / 1e5 = 0.09)` and the fee calculation will be wrong [here](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L988-L990).   ## Tools Used Manual Review   ## Recommended Mitigation Steps We should change `9000` to `90000`.  ``` dirtyLiquidationFee = (_liquidationFee * 90000) / LIQ_PRECISION; // 90% of clean fee ```
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L215-L222   # Vulnerability details  ## Impact This function is changing the protocol fee that is used during interest calculation [here](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L477-L488).  But it doesn't update interest before changing the fee so the `_feesAmount` will be calculated wrongly.   ## Proof of Concept As we can see during [pause()](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L326) and [unpause()](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L335), `_addInterest()` must be called before any changes.  But with the [changeFee()](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L215), it doesn't update interest and the `_feesAmount` might be calculated wrongly.  - At time `T1`, [_currentRateInfo.feeToProtocolRate = F1](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L477). - At `T2`, the owner had changed the fee to `F2`. - At `T3`, [_addInterest()](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L409) is called during `deposit()` or other functions. - Then [during this calculation](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L477-L488), `F1` should be applied from `T1` to `T2` and `F2` should be applied from `T2` and `T3`. But it uses `F2` from `T1` to `T2`.   ## Tools Used Manual Review   ## Recommended Mitigation Steps Recommend modifying `changeFee()` like below.  ``` function changeFee(uint32 _newFee) external whenNotPaused {     if (msg.sender != TIME_LOCK_ADDRESS) revert OnlyTimeLock();     if (_newFee > MAX_PROTOCOL_FEE) {         revert BadProtocolFee();     }      _addInterest(); //+++++++++++++++++++++++++++++++++      currentRateInfo.feeToProtocolRate = _newFee;     emit ChangeFee(_newFee); } ```
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L206   # Vulnerability details  ## Impact  The ownership of a deployed Fraxlend pair is transferred to `COMPTROLLER_ADDRESS` on deployment via `FraxlendPairDeployer_deploySecond`. This very owner is able to change the currently used time lock contract address with the `FraxlendPair.setTimeLock` function. A time lock is enforced on the `FraxlendPair.changeFee` function whenever the protocol fee is adjusted.  However, as the Fraxlend pair owner is able to change the time lock contract address to any other arbitrary (contract) address, it is possible to circumvent this timelock without users knowing. By using a custom smart contract without an enforced time lock, the protocol fee can be changed at any time without a proper time lock.  ## Proof of Concept  [FraxlendPair.sol#L206](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L206)  ````solidity /// @notice The ```setTimeLock``` function sets the TIME_LOCK address /// @param _newAddress the new time lock address function setTimeLock(address _newAddress) external onlyOwner {     emit SetTimeLock(TIME_LOCK_ADDRESS, _newAddress);     TIME_LOCK_ADDRESS = _newAddress; } ````  ## Tools Used  Manual review  ## Recommended mitigation steps  Currently, the owner `COMPTROLLER_ADDRESS` address is trustworthy, however, nothing prevents the above-described scenario. To protect users from sudden protocol fee changes, consider using a minimal time lock implementation directly implemented in the contract without trusting any external contract. 
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L84-L86 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L204-L207   # Vulnerability details  ## Impact Allows to reset **TIME_LOCK_ADDRESS** value multiple times by the owner. According to comments in FraxlendPairCore this should act as a constant/immutable value. Given that this value will be define through function **setTimeLock** in **FraxLendPair** contract this value can changed whenever the owner wants. This does not seem the expected behaviour.  ## Proof of Concept The owner can call whenever they want the function **setTimeLock**, which reset the value of **TIME_LOCK_ADDRESS**  ## Tools Used Manual read  ## Recommended Mitigation Steps Add a bool which act as mutex if **TIME_LOCK_ADDRESS** has already been set, and modify **setTimeLock** function in FraxlendPair contract ```solidity // In FraxlendPair contract bool public timelockSetted; function setTimeLock(address _newAddress) external onlyOwner {         require(!timelockSetted);         emit SetTimeLock(TIME_LOCK_ADDRESS, _newAddress);         TIME_LOCK_ADDRESS = _newAddress;         timelockeSetted=true; } ```
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L997-L1015   # Vulnerability details  ## Impact  Leftover shares in `liquidateClean` are only subtracted from pair totals, but not from user's borrowed shares. This means that after `liquidateClean`, borrower's shares will be greater than `0` (leftover shares after liquidations), but the user is still insolvent and can be liquidated again and again (with `_sharesToLiquidate` set to `0`). Each subsequent liquidation will write off the bad debt (reduce pair totals by borrower leftover shares/amounts), but doesn't take anything from liquidator nor borrower (since `_sharesToLiquidate == 0`).  This messes up the whole pair accounting, with total asset amounts reducing and total borrow amounts and shares reducing. This will make it impossible for borrowers to repay debt (or be liquidated), because borrow totals will underflow, and lenders amount to withdraw will reduce a lot (they will share non-existant huge bad debt).  Reducing pair totals scenario: 1. Alice borrows `1000 FRAX` (`1000` shares) against `1.5 ETH` collateral (`1 ETH = 1000`, `Max LTV` = `75%`) 2. ETH drops to `500` very quickly with liquidators being unable to liquidate Alice due to network congestion 3. At ETH = `500`, Alice collateral is worth `750` against `1000 FRAX` debt, making Alice insolvent and in a bad debt 4. Liquidator calls `liquidateClean` for `800` shares, which cleans up all available collateral of `1.5 ETH`. 5. At this point Alice has `200` shares debt with `0` collateral 6. Liquidator repeatedly calls `liquidateClean` with `0` shares to liquidate. Each call pair totals are reduced by `200` shares (and total borrow amount by a corresponding amount). 7. When pair totals reach close to `0`, the pool is effectively locked. Borrowers can't repay, lenders can withdraw severly reduced amounts.  ## Proof of Concept  Copy this to src/test/e2e/LiquidationBugTest.sol  https://gist.github.com/panprog/cbdc1658d63c30c9fe94127a4b4b7e72   ## Recommended Mitigation Steps  After the line  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L1012  add          _sharesToLiquidate += _sharesToAdjust;
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L136-L138 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L140-L142   # Vulnerability details  ## Impact FraxlendPair.sol is not EIP-4626 compliant, variation from the standard could break composability and potentially lead to loss of funds  ## Proof of Concept  According to EIP-4626 method specifications (https://eips.ethereum.org/EIPS/eip-4626)  For maxDeposit:      MUST factor in both global and user-specific limits, like if deposits are entirely disabled (even temporarily) it MUST return 0.  For maxMint:      MUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it MUST return 0.  When FraxlendPair.sol is paused, deposit and mint are both disabled. This means that maxMint and maxDeposit should return 0 when the contract is paused.   The current implementations of maxMint and maxDeposit do not follow this specification:      function maxDeposit(address) external pure returns (uint256) {         return type(uint128).max;     }      function maxMint(address) external pure returns (uint256) {         return type(uint128).max;     }  No matter the state of the contract they always return uint128.max, but they should return 0 when the contract is paused.  ## Tools Used  ## Recommended Mitigation Steps  maxDeposit and maxMint should be updated to return 0 when contract is paused. Use of the whenNotPaused modifier is not appropriate because that would cause a revert and maxDeposit and maxMint should never revert according to EIP-4626
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairDeployer.sol#L405   # Vulnerability details  ## Impact The method `globalPause` is not tested and it doesn't work as expected.  ## Proof of Concept Because the method returns an array (`_updatedAddresses`) and has never been initialized, when you want to set its value, it fails.  Recipe:  - Call `globalPause` with any valid address. - The transaction will FAULT.  ## Affected source code  - [FraxlendPairDeployer.sol#L405](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairDeployer.sol#L405)  ## Recommended Mitigation Steps  Initialize the `_updatedAddresses` array like shown bellow:  ```diff     function globalPause(address[] memory _addresses) external returns (address[] memory _updatedAddresses) {         require(msg.sender == CIRCUIT_BREAKER_ADDRESS, "Circuit Breaker only");         address _pairAddress;         uint256 _lengthOfArray = _addresses.length; +       _updatedAddresses = new address[](_lengthOfArray);         for (uint256 i = 0; i < _lengthOfArray; ) {             _pairAddress = _addresses[i];             try IFraxlendPair(_pairAddress).pause() {                 _updatedAddresses[i] = _addresses[i];             } catch {}             unchecked {                 i = i + 1;             }         }     } ```
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairConstants.sol#L41 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/LinearInterestRate.sol#L34 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/VariableInterestRate.sol#L40 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/VariableInterestRate.sol#L41   # Vulnerability details  ## Impact  All annual rate constants in the system are calculated with an assumption that block time is 15 second (actually itâ€™s from 12 to 14 seconds as in [the documentation](https://ethereum.org/vi/developers/docs/blocks/#block-time). And these constants are used to calculate rate in rate calculator and also used to reset interest rate when there are no borrows.  But actually, [the merge is really near](https://ethereum.org/vi/upgrades/merge/) and after the merge blocks come exactly each 12 seconds which basically makes all these constants wrong.   This resulted in wrong interest rate after reseting when there are no borrows and wrong rate returned by rate calculators.  ## Proof of Concept  These annual rate is calculated by solving an equation for `r` with an assumption 365.24 days per year and 15s blocks. For example, this is for the 0.5% annual rate ``` 1.005 = (1 + 15*r)^(365.24 * 24 * 3600 / 15) ```   But actually after the merge, blocks come in exactly each 12 seconds. Check out [this blog post](https://blog.ethereum.org/2021/11/29/how-the-merge-impacts-app-layer/) of Tim Beiko   [Line 431-433](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L431-L433) reset interest rate when there are no borrows ```solidity if (!paused()) {     _currentRateInfo.ratePerSec = DEFAULT_INT; } ```  These constants are used in `requireValidInitData()` and also `getNewRate()` function in rate calculators and wrong constants might make `getNewRate()` return wrong value. For example, [line 72-74](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/VariableInterestRate.sol#L72-L74) used `MIN_INT` as new interest rate ```solidity if (_newRatePerSec < MIN_INT) {     _newRatePerSec = MIN_INT; } ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider to update these constants with an assumption that block time is 12 seconds. 
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L194   # Vulnerability details  ## Impact After confirmed with the sponsor, `dirtyLiquidationFee` is 90% of `cleanLiquidationFee` like the [comment](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L194).  But it uses `9% (9000 / 1e5 = 0.09)` and the fee calculation will be wrong [here](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L988-L990).   ## Tools Used Manual Review   ## Recommended Mitigation Steps We should change `9000` to `90000`.  ``` dirtyLiquidationFee = (_liquidationFee * 90000) / LIQ_PRECISION; // 90% of clean fee ```
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L215-L222   # Vulnerability details  ## Impact This function is changing the protocol fee that is used during interest calculation [here](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L477-L488).  But it doesn't update interest before changing the fee so the `_feesAmount` will be calculated wrongly.   ## Proof of Concept As we can see during [pause()](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L326) and [unpause()](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L335), `_addInterest()` must be called before any changes.  But with the [changeFee()](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L215), it doesn't update interest and the `_feesAmount` might be calculated wrongly.  - At time `T1`, [_currentRateInfo.feeToProtocolRate = F1](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L477). - At `T2`, the owner had changed the fee to `F2`. - At `T3`, [_addInterest()](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L409) is called during `deposit()` or other functions. - Then [during this calculation](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L477-L488), `F1` should be applied from `T1` to `T2` and `F2` should be applied from `T2` and `T3`. But it uses `F2` from `T1` to `T2`.   ## Tools Used Manual Review   ## Recommended Mitigation Steps Recommend modifying `changeFee()` like below.  ``` function changeFee(uint32 _newFee) external whenNotPaused {     if (msg.sender != TIME_LOCK_ADDRESS) revert OnlyTimeLock();     if (_newFee > MAX_PROTOCOL_FEE) {         revert BadProtocolFee();     }      _addInterest(); //+++++++++++++++++++++++++++++++++      currentRateInfo.feeToProtocolRate = _newFee;     emit ChangeFee(_newFee); } ```
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L206   # Vulnerability details  ## Impact  The ownership of a deployed Fraxlend pair is transferred to `COMPTROLLER_ADDRESS` on deployment via `FraxlendPairDeployer_deploySecond`. This very owner is able to change the currently used time lock contract address with the `FraxlendPair.setTimeLock` function. A time lock is enforced on the `FraxlendPair.changeFee` function whenever the protocol fee is adjusted.  However, as the Fraxlend pair owner is able to change the time lock contract address to any other arbitrary (contract) address, it is possible to circumvent this timelock without users knowing. By using a custom smart contract without an enforced time lock, the protocol fee can be changed at any time without a proper time lock.  ## Proof of Concept  [FraxlendPair.sol#L206](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L206)  ````solidity /// @notice The ```setTimeLock``` function sets the TIME_LOCK address /// @param _newAddress the new time lock address function setTimeLock(address _newAddress) external onlyOwner {     emit SetTimeLock(TIME_LOCK_ADDRESS, _newAddress);     TIME_LOCK_ADDRESS = _newAddress; } ````  ## Tools Used  Manual review  ## Recommended mitigation steps  Currently, the owner `COMPTROLLER_ADDRESS` address is trustworthy, however, nothing prevents the above-described scenario. To protect users from sudden protocol fee changes, consider using a minimal time lock implementation directly implemented in the contract without trusting any external contract. 
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L84-L86 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L204-L207   # Vulnerability details  ## Impact Allows to reset **TIME_LOCK_ADDRESS** value multiple times by the owner. According to comments in FraxlendPairCore this should act as a constant/immutable value. Given that this value will be define through function **setTimeLock** in **FraxLendPair** contract this value can changed whenever the owner wants. This does not seem the expected behaviour.  ## Proof of Concept The owner can call whenever they want the function **setTimeLock**, which reset the value of **TIME_LOCK_ADDRESS**  ## Tools Used Manual read  ## Recommended Mitigation Steps Add a bool which act as mutex if **TIME_LOCK_ADDRESS** has already been set, and modify **setTimeLock** function in FraxlendPair contract ```solidity // In FraxlendPair contract bool public timelockSetted; function setTimeLock(address _newAddress) external onlyOwner {         require(!timelockSetted);         emit SetTimeLock(TIME_LOCK_ADDRESS, _newAddress);         TIME_LOCK_ADDRESS = _newAddress;         timelockeSetted=true; } ```
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L997-L1015   # Vulnerability details  ## Impact  Leftover shares in `liquidateClean` are only subtracted from pair totals, but not from user's borrowed shares. This means that after `liquidateClean`, borrower's shares will be greater than `0` (leftover shares after liquidations), but the user is still insolvent and can be liquidated again and again (with `_sharesToLiquidate` set to `0`). Each subsequent liquidation will write off the bad debt (reduce pair totals by borrower leftover shares/amounts), but doesn't take anything from liquidator nor borrower (since `_sharesToLiquidate == 0`).  This messes up the whole pair accounting, with total asset amounts reducing and total borrow amounts and shares reducing. This will make it impossible for borrowers to repay debt (or be liquidated), because borrow totals will underflow, and lenders amount to withdraw will reduce a lot (they will share non-existant huge bad debt).  Reducing pair totals scenario: 1. Alice borrows `1000 FRAX` (`1000` shares) against `1.5 ETH` collateral (`1 ETH = 1000`, `Max LTV` = `75%`) 2. ETH drops to `500` very quickly with liquidators being unable to liquidate Alice due to network congestion 3. At ETH = `500`, Alice collateral is worth `750` against `1000 FRAX` debt, making Alice insolvent and in a bad debt 4. Liquidator calls `liquidateClean` for `800` shares, which cleans up all available collateral of `1.5 ETH`. 5. At this point Alice has `200` shares debt with `0` collateral 6. Liquidator repeatedly calls `liquidateClean` with `0` shares to liquidate. Each call pair totals are reduced by `200` shares (and total borrow amount by a corresponding amount). 7. When pair totals reach close to `0`, the pool is effectively locked. Borrowers can't repay, lenders can withdraw severly reduced amounts.  ## Proof of Concept  Copy this to src/test/e2e/LiquidationBugTest.sol  https://gist.github.com/panprog/cbdc1658d63c30c9fe94127a4b4b7e72   ## Recommended Mitigation Steps  After the line  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L1012  add          _sharesToLiquidate += _sharesToAdjust;
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L136-L138 https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPair.sol#L140-L142   # Vulnerability details  ## Impact FraxlendPair.sol is not EIP-4626 compliant, variation from the standard could break composability and potentially lead to loss of funds  ## Proof of Concept  According to EIP-4626 method specifications (https://eips.ethereum.org/EIPS/eip-4626)  For maxDeposit:      MUST factor in both global and user-specific limits, like if deposits are entirely disabled (even temporarily) it MUST return 0.  For maxMint:      MUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it MUST return 0.  When FraxlendPair.sol is paused, deposit and mint are both disabled. This means that maxMint and maxDeposit should return 0 when the contract is paused.   The current implementations of maxMint and maxDeposit do not follow this specification:      function maxDeposit(address) external pure returns (uint256) {         return type(uint128).max;     }      function maxMint(address) external pure returns (uint256) {         return type(uint128).max;     }  No matter the state of the contract they always return uint128.max, but they should return 0 when the contract is paused.  ## Tools Used  ## Recommended Mitigation Steps  maxDeposit and maxMint should be updated to return 0 when contract is paused. Use of the whenNotPaused modifier is not appropriate because that would cause a revert and maxDeposit and maxMint should never revert according to EIP-4626
# Lines of code  https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairDeployer.sol#L405   # Vulnerability details  ## Impact The method `globalPause` is not tested and it doesn't work as expected.  ## Proof of Concept Because the method returns an array (`_updatedAddresses`) and has never been initialized, when you want to set its value, it fails.  Recipe:  - Call `globalPause` with any valid address. - The transaction will FAULT.  ## Affected source code  - [FraxlendPairDeployer.sol#L405](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairDeployer.sol#L405)  ## Recommended Mitigation Steps  Initialize the `_updatedAddresses` array like shown bellow:  ```diff     function globalPause(address[] memory _addresses) external returns (address[] memory _updatedAddresses) {         require(msg.sender == CIRCUIT_BREAKER_ADDRESS, "Circuit Breaker only");         address _pairAddress;         uint256 _lengthOfArray = _addresses.length; +       _updatedAddresses = new address[](_lengthOfArray);         for (uint256 i = 0; i < _lengthOfArray; ) {             _pairAddress = _addresses[i];             try IFraxlendPair(_pairAddress).pause() {                 _updatedAddresses[i] = _addresses[i];             } catch {}             unchecked {                 i = i + 1;             }         }     } ```
