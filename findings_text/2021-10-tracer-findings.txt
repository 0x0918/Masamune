# Handle  pauliax   # Vulnerability details  ## Impact Because 'token' is of type uint here, this comparison can be simplified to reduce gas costs:   require(token == 0 || token == 1, "Pool: token out of range"); //before  ## Recommended Mitigation Steps   require(token < 2, "Pool: token out of range"); //after  
# Handle  pauliax   # Vulnerability details  ## Impact Uneccesarry multiplication by 1 here:   require(initialization._fee < 1 * PoolSwapLibrary.WAD_PRECISION, "Fee >= 100%");  ## Recommended Mitigation Steps   require(initialization._fee < PoolSwapLibrary.WAD_PRECISION, "Fee >= 100%");  
# Handle  pauliax   # Vulnerability details  ## Impact There are unused imports. They will increase the size of deployment with no real benefit. Consider removing unused imports to save some gas.   Examples of such imports are:   in contract PoolKeeper import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/proxy/Clones.sol";  imported twice: import "../interfaces/IERC20DecimalsWrapper.sol";  in contract PoolCommitter import "../interfaces/IOracleWrapper.sol";  ## Recommended Mitigation Steps Remove unnecessary imports.  
# Handle  pauliax   # Vulnerability details  ## Impact There are variables that do not change so they can be marked as immutable to greatly improve the gast costs. Examples of such variables are: scaler and oracle in ChainlinkOracleWrapper, factory in PoolCommitterDeployer, poolName in LeveragedPool and there are many more.  ## Recommended Mitigation Steps Consider applying 'immutable' to reduce gas costs.   
# Handle  pauliax   # Vulnerability details  ## Impact Not used variables.  In library PoolSwapLibrary:   bytes16 public constant zero = 0x00000000000000000000000000000000;   bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000; In contract PoolKeeper:   uint256 public constant MAX_DECIMALS = 18;  ## Recommended Mitigation Steps Remove if you don't need them to save some gas.  
# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why the block time is based on ETH mainnet 13s intervals, when in Arbitrum where these contracts are supposed to be deployed block times are faster:     uint256 public constant BLOCK_TIME = 13; /* in seconds */ I wanted to ask this Tracer's representative on Discord but received no answer so submitting this and you can decide if that was intentional.    
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  - `LeveragedPool.sol#intervalPassed()`      https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L259-L261      ```solidity         function intervalPassed() public view override returns (bool) {             return block.timestamp >= lastPriceTimestamp + updateInterval;         }     ```      `lastPriceTimestamp + updateInterval` will never overlow.  - `LeveragedPool.sol#executePriceChange()`      https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L175-L204      ```solidity     emit PoolRebalance(         int256(newShortBalance) - int256(_shortBalance),         int256(newLongBalance) - int256(_longBalance)     );     ```      `int256(newShortBalance) - int256(_shortBalance)` and `int256(newLongBalance) - int256(_longBalance)` will never underflow.  
# Handle  cmichel   # Vulnerability details  The `PoolKeeper.keeperReward` computation mixes WADs and Quads which leads to issues. 1. Note that `keeperTip` returns values where `1` = `1%`, and `100 = 100%`, the same way `BASE_TIP = 5 = 5%`. Thus `_tipPercent = ABDKMathQuad.fromUInt(keeperTip)` is a Quad value of this keeper tip, and not in "wad units" as the comment above it says.  ```solidity // @audit ðŸ‘‡ this comment is not correct, it's in Quad units // tip percent in wad units bytes16 _tipPercent = ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval)); ```  2. Now the `wadRewardValue` interprets `_tipPercent` as a WAD + Quad value which ultimately leads to significantly fewer keeper rewards: It tries to compute `_keeperGas + _keeperGas * _tipPercent` and to compute `_keeperGas * _tipPercent` it does a wrong division by `fixedPoint` (1e18 as a quad value) because it think the `_tipPercent` is a WAD value (100%=1e18) as a quad, when indeed `100%=100`. It seems like it should divide by `100` as a quad instead.  ``` ABDKMathQuad.add(     ABDKMathQuad.fromUInt(_keeperGas),     // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100     ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100)) ) ```  ## Impact The keeper rewards are off as the `_keeperGas * _tipPercent` is divided by 1e18 instead of 1e2. Keeper will just receive their `_keeperGas` cost but the tip part will be close to zero every time.  ## Recommended Mitigation Steps Generally, I'd say the contract mixes quad and WAD units where it doesn't have to do it. Usually, you either use WAD or Quad math but not both at the same time. This complicates the code. I'd make `keeperTip()`  return a `byte16` Quad value as a percentage where `100% = ABDKMathQuad.fromUInt(1)`. This temporary float result can then be used in a different ABDKMathQuad computation.  Alternatively, divide by 100 as a quad instead of 1e18 as a quad because `_tipPercent` is not a WAD value, but simply a percentage where `1 = 1%`.  ```solidity ABDKMathQuad.add(     ABDKMathQuad.fromUInt(_keeperGas),     // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100     ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100)) ) ```   
# Handle  cmichel   # Vulnerability details  `PoolFactory.uint2str` computes `i % 10` as `uint8(_i - (_i / 10) * 10)`. This intuitively seems more gas-expensive than doing `i % 10`. Consider using `i % 10` instead which also makes the code simpler to read.   
# Handle  cmichel   # Vulnerability details  `PoolFactory.setFee` does not check if the `_fee` parameter is at most 100%.  ## Impact Setting a very high fee, even above 100%, will lead to the pool's funds being drained.  ## Recommended Mitigation Steps Validate `_fee` against a reasonable max-fee value, ideally < 100%.   
# Handle  cmichel   # Vulnerability details  The `LeveragedPool.transferGovernance` function emits an event and reads the new governance variable from storage.  ```solidity emit ProvisionalGovernanceChanged(provisionalGovernance); ```  It is cheaper to use the `_governance` parameter instead which is the same value.   
# Handle  cmichel   # Vulnerability details  The `PoolCommiter.shadowPools` track commitments for all four `Long/Short Mint/Burn` types and uses these to reconstruct the initial total supply to correctly compute the token amounts for the sequence of commitments (as short/long tokens already get burned in the commitment phase and reduced the total supply). However, the two burn types `LongBurn` and `ShortBurn` are all that's needed for the reconstruction which can be seen from the fact that `shadowPools[.]` is only accessed with them.  #### Recommendation Only store `shadowPools` for `LongBurn` and `ShortBurn` types, and remove the `shadowPools[_commitType] = shadowPools[_commitType] - _commit.amount;` statement in `_uncommit` which is unnecessary for the mints as it just pays out what's already tracked in the commitments (`_commit`).   
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `PoolFactory.constructor: _feeReceiver`: The parameters should be checked to be non-zero - `ChainlinkOracleWrapper.constructor: _oracle`: The parameters should be checked to be non-zero or contracts  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  loop   # Vulnerability details  When making external calls to ERC20 functions LeveragedPool checks for zero addresses. These checks are already available in the OpenZeppelin ERC20 implementation which is used. This results in redundant checks which increase gas costs when calling these functions.   ## Proof of Concept Require statements used in LeveragedPool: - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L148 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L163-L164 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L234 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L251  Checks in OpenZeppelin implementation: - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L225-L226 - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L252 - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L275  ## Tools Used Remix  
# Handle  loop   # Vulnerability details  The comment for the `withdrawQuote()` function states 'Pool must not be paused'. Require statement requires paused to be true.  ## Impact Comment seems to be wrong, so no direct impact on functioning of protocol.  ## Proof of Concept Comment: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L359  Require: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L363  
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  The unused named return variables are here.  ChainlinkOracleWrapper.sol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/ChainlinkOracleWrapper.sol#L57-L67  LeveragedPool.sol https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L327-L340 https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L353-L355  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Remove the unused named return variables or use them instead of creating additional variables.   
# Handle  ye0lde   # Vulnerability details  ## Impact  It is possible to minimize the number of storage slots used by rearranging the state variables in a more efficient way.  ## Proof of Concept In  LeveragedPool.sol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L22-L44  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Arrange the uint32, bytes32, and bool variables such that they fit into the same slot.   
# Handle  pauliax   # Vulnerability details  ## Impact Because 'token' is of type uint here, this comparison can be simplified to reduce gas costs:   require(token == 0 || token == 1, "Pool: token out of range"); //before  ## Recommended Mitigation Steps   require(token < 2, "Pool: token out of range"); //after  
# Handle  pauliax   # Vulnerability details  ## Impact Uneccesarry multiplication by 1 here:   require(initialization._fee < 1 * PoolSwapLibrary.WAD_PRECISION, "Fee >= 100%");  ## Recommended Mitigation Steps   require(initialization._fee < PoolSwapLibrary.WAD_PRECISION, "Fee >= 100%");  
# Handle  pauliax   # Vulnerability details  ## Impact There are unused imports. They will increase the size of deployment with no real benefit. Consider removing unused imports to save some gas.   Examples of such imports are:   in contract PoolKeeper import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/proxy/Clones.sol";  imported twice: import "../interfaces/IERC20DecimalsWrapper.sol";  in contract PoolCommitter import "../interfaces/IOracleWrapper.sol";  ## Recommended Mitigation Steps Remove unnecessary imports.  
# Handle  pauliax   # Vulnerability details  ## Impact There are variables that do not change so they can be marked as immutable to greatly improve the gast costs. Examples of such variables are: scaler and oracle in ChainlinkOracleWrapper, factory in PoolCommitterDeployer, poolName in LeveragedPool and there are many more.  ## Recommended Mitigation Steps Consider applying 'immutable' to reduce gas costs.   
# Handle  pauliax   # Vulnerability details  ## Impact Not used variables.  In library PoolSwapLibrary:   bytes16 public constant zero = 0x00000000000000000000000000000000;   bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000; In contract PoolKeeper:   uint256 public constant MAX_DECIMALS = 18;  ## Recommended Mitigation Steps Remove if you don't need them to save some gas.  
# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why the block time is based on ETH mainnet 13s intervals, when in Arbitrum where these contracts are supposed to be deployed block times are faster:     uint256 public constant BLOCK_TIME = 13; /* in seconds */ I wanted to ask this Tracer's representative on Discord but received no answer so submitting this and you can decide if that was intentional.    
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  - `LeveragedPool.sol#intervalPassed()`      https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L259-L261      ```solidity         function intervalPassed() public view override returns (bool) {             return block.timestamp >= lastPriceTimestamp + updateInterval;         }     ```      `lastPriceTimestamp + updateInterval` will never overlow.  - `LeveragedPool.sol#executePriceChange()`      https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L175-L204      ```solidity     emit PoolRebalance(         int256(newShortBalance) - int256(_shortBalance),         int256(newLongBalance) - int256(_longBalance)     );     ```      `int256(newShortBalance) - int256(_shortBalance)` and `int256(newLongBalance) - int256(_longBalance)` will never underflow.  
# Handle  cmichel   # Vulnerability details  The `PoolKeeper.keeperReward` computation mixes WADs and Quads which leads to issues. 1. Note that `keeperTip` returns values where `1` = `1%`, and `100 = 100%`, the same way `BASE_TIP = 5 = 5%`. Thus `_tipPercent = ABDKMathQuad.fromUInt(keeperTip)` is a Quad value of this keeper tip, and not in "wad units" as the comment above it says.  ```solidity // @audit ðŸ‘‡ this comment is not correct, it's in Quad units // tip percent in wad units bytes16 _tipPercent = ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval)); ```  2. Now the `wadRewardValue` interprets `_tipPercent` as a WAD + Quad value which ultimately leads to significantly fewer keeper rewards: It tries to compute `_keeperGas + _keeperGas * _tipPercent` and to compute `_keeperGas * _tipPercent` it does a wrong division by `fixedPoint` (1e18 as a quad value) because it think the `_tipPercent` is a WAD value (100%=1e18) as a quad, when indeed `100%=100`. It seems like it should divide by `100` as a quad instead.  ``` ABDKMathQuad.add(     ABDKMathQuad.fromUInt(_keeperGas),     // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100     ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100)) ) ```  ## Impact The keeper rewards are off as the `_keeperGas * _tipPercent` is divided by 1e18 instead of 1e2. Keeper will just receive their `_keeperGas` cost but the tip part will be close to zero every time.  ## Recommended Mitigation Steps Generally, I'd say the contract mixes quad and WAD units where it doesn't have to do it. Usually, you either use WAD or Quad math but not both at the same time. This complicates the code. I'd make `keeperTip()`  return a `byte16` Quad value as a percentage where `100% = ABDKMathQuad.fromUInt(1)`. This temporary float result can then be used in a different ABDKMathQuad computation.  Alternatively, divide by 100 as a quad instead of 1e18 as a quad because `_tipPercent` is not a WAD value, but simply a percentage where `1 = 1%`.  ```solidity ABDKMathQuad.add(     ABDKMathQuad.fromUInt(_keeperGas),     // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100     ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100)) ) ```   
# Handle  cmichel   # Vulnerability details  `PoolFactory.uint2str` computes `i % 10` as `uint8(_i - (_i / 10) * 10)`. This intuitively seems more gas-expensive than doing `i % 10`. Consider using `i % 10` instead which also makes the code simpler to read.   
# Handle  cmichel   # Vulnerability details  `PoolFactory.setFee` does not check if the `_fee` parameter is at most 100%.  ## Impact Setting a very high fee, even above 100%, will lead to the pool's funds being drained.  ## Recommended Mitigation Steps Validate `_fee` against a reasonable max-fee value, ideally < 100%.   
# Handle  cmichel   # Vulnerability details  The `LeveragedPool.transferGovernance` function emits an event and reads the new governance variable from storage.  ```solidity emit ProvisionalGovernanceChanged(provisionalGovernance); ```  It is cheaper to use the `_governance` parameter instead which is the same value.   
# Handle  cmichel   # Vulnerability details  The `PoolCommiter.shadowPools` track commitments for all four `Long/Short Mint/Burn` types and uses these to reconstruct the initial total supply to correctly compute the token amounts for the sequence of commitments (as short/long tokens already get burned in the commitment phase and reduced the total supply). However, the two burn types `LongBurn` and `ShortBurn` are all that's needed for the reconstruction which can be seen from the fact that `shadowPools[.]` is only accessed with them.  #### Recommendation Only store `shadowPools` for `LongBurn` and `ShortBurn` types, and remove the `shadowPools[_commitType] = shadowPools[_commitType] - _commit.amount;` statement in `_uncommit` which is unnecessary for the mints as it just pays out what's already tracked in the commitments (`_commit`).   
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `PoolFactory.constructor: _feeReceiver`: The parameters should be checked to be non-zero - `ChainlinkOracleWrapper.constructor: _oracle`: The parameters should be checked to be non-zero or contracts  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  loop   # Vulnerability details  When making external calls to ERC20 functions LeveragedPool checks for zero addresses. These checks are already available in the OpenZeppelin ERC20 implementation which is used. This results in redundant checks which increase gas costs when calling these functions.   ## Proof of Concept Require statements used in LeveragedPool: - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L148 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L163-L164 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L234 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L251  Checks in OpenZeppelin implementation: - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L225-L226 - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L252 - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L275  ## Tools Used Remix  
# Handle  loop   # Vulnerability details  The comment for the `withdrawQuote()` function states 'Pool must not be paused'. Require statement requires paused to be true.  ## Impact Comment seems to be wrong, so no direct impact on functioning of protocol.  ## Proof of Concept Comment: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L359  Require: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L363  
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  The unused named return variables are here.  ChainlinkOracleWrapper.sol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/ChainlinkOracleWrapper.sol#L57-L67  LeveragedPool.sol https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L327-L340 https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L353-L355  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Remove the unused named return variables or use them instead of creating additional variables.   
# Handle  ye0lde   # Vulnerability details  ## Impact  It is possible to minimize the number of storage slots used by rearranging the state variables in a more efficient way.  ## Proof of Concept In  LeveragedPool.sol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L22-L44  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Arrange the uint32, bytes32, and bool variables such that they fit into the same slot.   
# Handle  pauliax   # Vulnerability details  ## Impact Because 'token' is of type uint here, this comparison can be simplified to reduce gas costs:   require(token == 0 || token == 1, "Pool: token out of range"); //before  ## Recommended Mitigation Steps   require(token < 2, "Pool: token out of range"); //after  
# Handle  pauliax   # Vulnerability details  ## Impact Uneccesarry multiplication by 1 here:   require(initialization._fee < 1 * PoolSwapLibrary.WAD_PRECISION, "Fee >= 100%");  ## Recommended Mitigation Steps   require(initialization._fee < PoolSwapLibrary.WAD_PRECISION, "Fee >= 100%");  
# Handle  pauliax   # Vulnerability details  ## Impact There are unused imports. They will increase the size of deployment with no real benefit. Consider removing unused imports to save some gas.   Examples of such imports are:   in contract PoolKeeper import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/proxy/Clones.sol";  imported twice: import "../interfaces/IERC20DecimalsWrapper.sol";  in contract PoolCommitter import "../interfaces/IOracleWrapper.sol";  ## Recommended Mitigation Steps Remove unnecessary imports.  
# Handle  pauliax   # Vulnerability details  ## Impact There are variables that do not change so they can be marked as immutable to greatly improve the gast costs. Examples of such variables are: scaler and oracle in ChainlinkOracleWrapper, factory in PoolCommitterDeployer, poolName in LeveragedPool and there are many more.  ## Recommended Mitigation Steps Consider applying 'immutable' to reduce gas costs.   
# Handle  pauliax   # Vulnerability details  ## Impact Not used variables.  In library PoolSwapLibrary:   bytes16 public constant zero = 0x00000000000000000000000000000000;   bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000; In contract PoolKeeper:   uint256 public constant MAX_DECIMALS = 18;  ## Recommended Mitigation Steps Remove if you don't need them to save some gas.  
# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why the block time is based on ETH mainnet 13s intervals, when in Arbitrum where these contracts are supposed to be deployed block times are faster:     uint256 public constant BLOCK_TIME = 13; /* in seconds */ I wanted to ask this Tracer's representative on Discord but received no answer so submitting this and you can decide if that was intentional.    
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  - `LeveragedPool.sol#intervalPassed()`      https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L259-L261      ```solidity         function intervalPassed() public view override returns (bool) {             return block.timestamp >= lastPriceTimestamp + updateInterval;         }     ```      `lastPriceTimestamp + updateInterval` will never overlow.  - `LeveragedPool.sol#executePriceChange()`      https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L175-L204      ```solidity     emit PoolRebalance(         int256(newShortBalance) - int256(_shortBalance),         int256(newLongBalance) - int256(_longBalance)     );     ```      `int256(newShortBalance) - int256(_shortBalance)` and `int256(newLongBalance) - int256(_longBalance)` will never underflow.  
# Handle  cmichel   # Vulnerability details  The `PoolKeeper.keeperReward` computation mixes WADs and Quads which leads to issues. 1. Note that `keeperTip` returns values where `1` = `1%`, and `100 = 100%`, the same way `BASE_TIP = 5 = 5%`. Thus `_tipPercent = ABDKMathQuad.fromUInt(keeperTip)` is a Quad value of this keeper tip, and not in "wad units" as the comment above it says.  ```solidity // @audit ðŸ‘‡ this comment is not correct, it's in Quad units // tip percent in wad units bytes16 _tipPercent = ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval)); ```  2. Now the `wadRewardValue` interprets `_tipPercent` as a WAD + Quad value which ultimately leads to significantly fewer keeper rewards: It tries to compute `_keeperGas + _keeperGas * _tipPercent` and to compute `_keeperGas * _tipPercent` it does a wrong division by `fixedPoint` (1e18 as a quad value) because it think the `_tipPercent` is a WAD value (100%=1e18) as a quad, when indeed `100%=100`. It seems like it should divide by `100` as a quad instead.  ``` ABDKMathQuad.add(     ABDKMathQuad.fromUInt(_keeperGas),     // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100     ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100)) ) ```  ## Impact The keeper rewards are off as the `_keeperGas * _tipPercent` is divided by 1e18 instead of 1e2. Keeper will just receive their `_keeperGas` cost but the tip part will be close to zero every time.  ## Recommended Mitigation Steps Generally, I'd say the contract mixes quad and WAD units where it doesn't have to do it. Usually, you either use WAD or Quad math but not both at the same time. This complicates the code. I'd make `keeperTip()`  return a `byte16` Quad value as a percentage where `100% = ABDKMathQuad.fromUInt(1)`. This temporary float result can then be used in a different ABDKMathQuad computation.  Alternatively, divide by 100 as a quad instead of 1e18 as a quad because `_tipPercent` is not a WAD value, but simply a percentage where `1 = 1%`.  ```solidity ABDKMathQuad.add(     ABDKMathQuad.fromUInt(_keeperGas),     // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100     ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100)) ) ```   
# Handle  cmichel   # Vulnerability details  `PoolFactory.uint2str` computes `i % 10` as `uint8(_i - (_i / 10) * 10)`. This intuitively seems more gas-expensive than doing `i % 10`. Consider using `i % 10` instead which also makes the code simpler to read.   
# Handle  cmichel   # Vulnerability details  `PoolFactory.setFee` does not check if the `_fee` parameter is at most 100%.  ## Impact Setting a very high fee, even above 100%, will lead to the pool's funds being drained.  ## Recommended Mitigation Steps Validate `_fee` against a reasonable max-fee value, ideally < 100%.   
# Handle  cmichel   # Vulnerability details  The `LeveragedPool.transferGovernance` function emits an event and reads the new governance variable from storage.  ```solidity emit ProvisionalGovernanceChanged(provisionalGovernance); ```  It is cheaper to use the `_governance` parameter instead which is the same value.   
# Handle  cmichel   # Vulnerability details  The `PoolCommiter.shadowPools` track commitments for all four `Long/Short Mint/Burn` types and uses these to reconstruct the initial total supply to correctly compute the token amounts for the sequence of commitments (as short/long tokens already get burned in the commitment phase and reduced the total supply). However, the two burn types `LongBurn` and `ShortBurn` are all that's needed for the reconstruction which can be seen from the fact that `shadowPools[.]` is only accessed with them.  #### Recommendation Only store `shadowPools` for `LongBurn` and `ShortBurn` types, and remove the `shadowPools[_commitType] = shadowPools[_commitType] - _commit.amount;` statement in `_uncommit` which is unnecessary for the mints as it just pays out what's already tracked in the commitments (`_commit`).   
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `PoolFactory.constructor: _feeReceiver`: The parameters should be checked to be non-zero - `ChainlinkOracleWrapper.constructor: _oracle`: The parameters should be checked to be non-zero or contracts  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  loop   # Vulnerability details  When making external calls to ERC20 functions LeveragedPool checks for zero addresses. These checks are already available in the OpenZeppelin ERC20 implementation which is used. This results in redundant checks which increase gas costs when calling these functions.   ## Proof of Concept Require statements used in LeveragedPool: - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L148 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L163-L164 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L234 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L251  Checks in OpenZeppelin implementation: - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L225-L226 - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L252 - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L275  ## Tools Used Remix  
# Handle  loop   # Vulnerability details  The comment for the `withdrawQuote()` function states 'Pool must not be paused'. Require statement requires paused to be true.  ## Impact Comment seems to be wrong, so no direct impact on functioning of protocol.  ## Proof of Concept Comment: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L359  Require: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L363  
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  The unused named return variables are here.  ChainlinkOracleWrapper.sol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/ChainlinkOracleWrapper.sol#L57-L67  LeveragedPool.sol https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L327-L340 https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L353-L355  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Remove the unused named return variables or use them instead of creating additional variables.   
# Handle  ye0lde   # Vulnerability details  ## Impact  It is possible to minimize the number of storage slots used by rearranging the state variables in a more efficient way.  ## Proof of Concept In  LeveragedPool.sol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L22-L44  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Arrange the uint32, bytes32, and bool variables such that they fit into the same slot.   
