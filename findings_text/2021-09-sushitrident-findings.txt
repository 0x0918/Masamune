# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeLiquidityFromAdjustedBalances` function of `HybridPool` should return in the `if (s == 0)` statement, or it will cause a divison-by-zero error otherwise.  ## Proof of Concept  Referenced code: [HybridPool.sol#L350-L352](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L350-L352)  ## Recommended Mitigation Steps  Add `return computed;` after `computed = 0;`.  
# Handle  0xsanson   # Vulnerability details  ## Impact IndexPool doesn't collect fees for `barFeeTo`. Since this Pool contains also a method `updateBarFee()`, probably this is an unintended behavior. Also without a fee, liquidity providers would probably ditch ConstantProductPool in favor of IndexPool (using the same two tokens with equal weights), since they get all the rewards. This would constitute an issue for the ecosystem.  ## Recommended Mitigation Steps Add a way to send barFees to barFeeTo, same as the other pools.  
# Handle  broccoli   # Vulnerability details  ## Impact  The `_depositToBentoBox` and `_depositFromUserToBentoBox` allow users to provide ETH to the router, which is later deposited to the `bento` contract for swapping other assets or providing liquidity. However, in these two functions, the input parameter does not represent the actual amount of ETH to deposit, and users have to calculate the actual amount and send it to the router, causing a back-run vulnerability if there are ETH left after the operation.  ## Proof of Concept  1. A user wants to swap ETH to DAI. He calls `exactInputSingleWithNativeToken` on the router with the corresponding parameters and `params.amountIn` being 10. Before calling the function, he calculates `bento.toAmount(wETH, 10, true) = 15` and thus send 15 ETH to the router. 2. However, at the time when his transaction is executed, `bento.toAmount(wETH, amount, true)` becomes to `14`, which could happen if someone calls `harvest` on `bento` to update the `elastic` value of the `wETH` token. 3. As a result, only 14 ETH is transferred to the pool, and 1 ETH is left in the router. Anyone could back-run the user's transaction to retrieve the remaining 1 ETH from the router by calling the `refundETH` function.  Referenced code: [TridentRouter.sol#L318-L351](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L318-L351)  ## Recommended Mitigation Steps  Directly push the remaining ETH to the sender to prevent any ETH left in the router.  
# Handle  broccoli   # Vulnerability details  ## Impact  An attacker can call the `bento.harvest` function during the callback function of a flash swap of the `HybridPool` to reduce the number of input tokens that he has to pay to the pool, as long as there is any unrealized profit in the strategy contract of the underlying asset.  ## Proof of Concept  1. The `HybridPool` accounts for the reserve and balance of the pool using the `bento.toAmount` function, which represents the actual amount of assets that the pool owns instead of the relative share. The value of `toAmount` could increase or decrease if the `bento.harvest` function is called (by anyone), depending on whether the strategy contract earns or loses money. 2. Supposing that the DAI strategy contract of `Bento` has a profit not accounted for yet. To account for the profit, anyone could call `harvest` on `Bento` with the corresponding parameters, which, as a result, increases the `elastic` of the DAI token. 3. Now, an attacker wants to utilize the unrealized profit to steal funds from a DAI-WETH hybrid pool. He calls `flashSwap` to initiate a flash swap from WETH to DAI. First, the pool transfers the corresponding amount of DAI to him, calls the `tridentSwapCallback` function on the attacker's contract, and expects that enough DAI is received at the end. 4. During the `tridentSwapCallback` function, the attacker calls `bento.harvest` to realize the profit of DAI. As a result, the pool's `bento.toAmount` increases, and the amount of DAI that the attacker has to pay to the pool is decreased. The attacker could get the same amount of ETH but paying less DAI by exploiting this bug.  Referenced code: [HybridPool.sol#L218-L220](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L218-L220) [HybridPool.sol#L249-L250](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L249-L250) [HybridPool.sol#L272-L285](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L272-L285) [BentoBoxV1Flat.sol#L1105](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L1105) [BentoBoxV1Flat.sol#L786-L792](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L786-L792) [BentoBoxV1Flat.sol#L264-L277](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L264-L277)  ## Recommended Mitigation Steps  Consider not using `bento.toAmount` to track the reservers and balances, but use `balanceOf` instead (as done in the other two pools).   
# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeSingleOutGivenPoolIn` function of `IndexPool` uses the raw multiplication (i.e., `*`) to calculate the `zaz` variable. However, since both `(BASE - normalizedWeight)` and `_swapFee` are in `WAD`, the `_mul` function should be used instead to calculate the correct value of `zaz`. Otherwise, `zaz` would be `10 ** 18` times larger than the expected value and causes an integer underflow when calculating `amountOut`. The incorrect usage of multiplication prevents anyone from calling the function successfully.  ## Proof of Concept  Referenced code: [IndexPool.sol#L282](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L282)   ## Recommended Mitigation Steps  Change `(BASE - normalizedWeight) * _swapFee` to `_mul((BASE - normalizedWeight), _swapFee)`.  
# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeSingleOutGivenPoolIn` function of `IndexPool` uses the `_pow` function to calculate `tokenOutRatio` with the exponent in `WAD` (i.e., in 18 decimals of precision). However, the `_pow` function assumes that the given exponent `n` is not in `WAD`. (for example, `_pow(5, BASE)` returns `5 ** (10 ** 18)` instead of `5 ** 1`). The misuse of the `_pow` function could causes an integer overflow in the `_computeSingleOutGivenPoolIn` function and thus prevent any function from calling it.  ## Proof of Concept  Referenced code: [IndexPool.sol#L279](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L279)   ## Recommended Mitigation Steps  Change the `_pow` function to the `_compute` function, which supports exponents in `WAD`.  
# Handle  0xsanson   # Vulnerability details  ## Impact In HybridPool.sol, functions `_getY` and `_getYD` are identical (only differences are variables' names), and only `_getY` is used in the contract.  Since these functions are supposed to mimic those of Curve, it would make more sense to follow their naming conventions. In particular, `_getYD` correctly mimics Curve's `_get_y_D` ([ref](https://github.com/curvefi/curve-contract/blob/master/contracts/pool-templates/base/SwapTemplateBase.vy#L614)), while `_getY` does not mimic Curve's `_get_y` ([ref](https://github.com/curvefi/curve-contract/blob/master/contracts/pool-templates/base/SwapTemplateBase.vy#L379)).  ## Recommended Mitigation Steps Consider eliminating `_getY` and using `_getYD` instead in the contract.  
# Handle  tensors   # Vulnerability details  Throughout the code function selectors are often used instead of interfaces.  It is considered best practice to use interfaces instead of selectors for code readability.  
# Handle  tensors   # Vulnerability details  Constants of form 10**X can be rewritten as 1eX and this will save gas.  
# Handle  hack3r-0m   # Vulnerability details  https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/libraries/MathUtils.sol#L22 the difference is computed incorrectly when a > b.  As it only used in within1 function, scope narrows down to where `difference(a, b) <= 1;` is exploitable.  cases where `difference(a, b) <= 1` should be true but is reported false: - where b = a-1 (returned value is type(uint256).max)  cases where `difference(a, b) <= 1` should be false but is reported true: - where a = type(uint256).max and b = 0, it returns 1 but it should ideally return type(uint256).max  within1 is used at the following locations: - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L359 - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L383 - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L413  It is possible to decrease the denominator and increase the value of the numerator (when calculating y) using constants and input to make within1 fail  Mitigation:  Add `else` condition to mitigate it.  ``` unchecked {           if (a > b) {               diff = a - b;           }           else {               diff = b - a;              }       } ```  (re-submitting this issue after withdrawing past one since I forgot to add more  details and POC)  
# Handle  WatchPug   # Vulnerability details  Cache storage variable in the stack can save gas.  For instance:  https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L140-L155  `outRecord.reserve` is accessed 2 times.   https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L158-L179 https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L182-L205  `inRecord.reserve` is accessed 3 times.  
# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  https://github.com/sushiswap/trident/blob/master/contracts/TridentRouter.sol#L214-L234  - minWithdrawals.length - withdrawnLiquidity.length  https://github.com/sushiswap/trident/blob/master/contracts/TridentRouter.sol#L274  - tokenInput.length  https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L114-L136  - tokens.length  
# Handle  hrkrshnn   # Vulnerability details  ## Consider avoiding low level calls to MasterDeployer  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/ConstantProductPool.sol#L64)  The constructor uses low-level calls to the master deployer. It is more idiomatic to rely on high level solidity to deal with the calls. The difference would be additional checks on whether there is code at the specified address (additional `100` gas) and automatically performing the ABI decoding (may actually be more efficient than the manual implementation.) (Note that this call will still be `staticcall`, since `barFee` is a view function in the interface.)  Example:  ``` diff modified   contracts/pool/ConstantProductPool.sol @@ -61,7 +61,7 @@ contract ConstantProductPool is IPool, TridentERC20 {          require(_token1 != address(this), "INVALID_TOKEN");          require(_swapFee <= MAX_FEE, "INVALID_SWAP_FEE");  -        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector)); +        barFee = IMasterDeployer(_masterDeployer).barFee();          (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));          (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));  @@ -72,7 +72,6 @@ contract ConstantProductPool is IPool, TridentERC20 {          unchecked {              MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;          } -        barFee = abi.decode(_barFee, (uint256));          barFeeTo = abi.decode(_barFeeTo, (address));          bento = abi.decode(_bento, (address));          masterDeployer = _masterDeployer; ```   
# Handle  hrkrshnn   # Vulnerability details  ## Use `calldata` instead of `memory` for function parameters  In some cases, having function arguments in `calldata` instead of `memory` is more optimal.  Consider the following generic example:  ``` solidity contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above example, the dynamic array `arr` has the storage location `memory`. When the function gets called externally, the array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). And during the for loop, `arr[i]` accesses the value in memory using a `mload`. However, for the above example this is inefficient. Consider the following snippet instead:  ``` solidity contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  **Gas savings**: In the former example, the ABI decoding begins with copying value from `calldata` to `memory` in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  *In short*, use `calldata` instead of `memory` if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from `memory` to `calldata` may cause "unimplemented feature error". This can be avoided by using a newer (`0.8.*`) Solidity compiler.  ### Examples  ****Note****: The following pattern is prevalent in the codebase:  ``` solidity function f(bytes memory data) external {     (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to `bytes calldata` will decrease the gas. The total savings for this change across all such uses would be *quite significant.*  Examples:  ``` text ./contracts/examples/PoolFactory.sol:15:    function deployPool(bytes memory _deployData) external override returns (address) { ./contracts/examples/PoolTemplate.sol:12:    constructor(bytes memory _data) { ./contracts/flat/BentoBoxV1Flat.sol:603:    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) { ./contracts/pool/HybridPoolFactory.sol:13:    function deployPool(bytes memory _deployData) external returns (address pool) { ./contracts/pool/IndexPoolFactory.sol:13:    function deployPool(bytes memory _deployData) external returns (address pool) { ./contracts/pool/franchised/FranchisedConstantProductPool.sol:54:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/franchised/FranchisedHybridPool.sol:60:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/franchised/FranchisedIndexPool.sol:61:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/HybridPool.sol:60:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/ConstantProductPoolFactory.sol:13:    function deployPool(bytes memory _deployData) external returns (address pool) { ./contracts/pool/ConstantProductPool.sol:54:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/IndexPool.sol:61:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/utils/TridentHelper.sol:143:    function getSelector(bytes memory _data) internal pure returns (bytes4 sig) { ```  Other examples:  1.  <https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L174> 2.  <https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L218>   
# Handle  hrkrshnn   # Vulnerability details  ## Consider putting some parts of `_div` in unchecked  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L335)  ``` diff modified   contracts/pool/IndexPool.sol @@ -332,7 +332,8 @@ contract IndexPool is IPool, TridentERC20 {       function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {          uint256 c0 = a * BASE; -        uint256 c1 = c0 + (b / 2); +        unchecked { uint256 tmp =  b / 2; } +        uint256 c1 = c0 + tmp;          c2 = c1 / b;      } ```  Looking at the optimized assembly generated, the unchecked version doesn't seem to have the additional check for division by zero. I'm not entirely sure why, but my guess is because of inlining. Also consider replacing the division by inline assembly.  ``` solidity uint tmp; assembly {     tmp := div(b, 2) } uint256 c1 = c0 + tmp; ```  The change avoids an `if` condition which checks if the divisor is zero, which the optimizer is currently unable to optimize out. The gas savings would be around 16 (reduces a `jumpi`, `push 0` and `dupN`). Since the `_div` function is called from throughout the code (also present in other contracts), this may be worth considering, although I admit this might be too much of a micro-optimization.   
# Handle  hrkrshnn   # Vulnerability details  ## Caching a storage load in TridentERC20  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/TridentERC20.sol#L76)  This avoids an unnecessary `sload`.  ``` diff modified   contracts/pool/TridentERC20.sol @@ -73,8 +73,9 @@ abstract contract TridentERC20 {          address recipient,          uint256 amount      ) external returns (bool) { -        if (allowance[sender][msg.sender] != type(uint256).max) { -            allowance[sender][msg.sender] -= amount; +        uint _allowance = allowance[sender][msg.sender]; +        if (_allowance != type(uint256).max) { +            allowance[sender][msg.sender] = _allowance - amount;          }          balanceOf[sender] -= amount;          // @dev This is safe from overflow - the sum of all user ```   
# Handle  hrkrshnn   # Vulnerability details  ## Caching the storage read to `tokens.length`  Ignoring the caching for the for-loop condition (see my other issue "Caching the length in for loops"), this would save an additional `sload`, around `100` gas.  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L129).  ``` diff modified   contracts/pool/IndexPool.sol @@ -121,12 +121,12 @@ contract IndexPool is IPool, TridentERC20 {          (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));           uint256 ratio = _div(toBurn, totalSupply); -        withdrawnAmounts = new TokenAmount[](tokens.length); +        uint length = tokens.length; +        withdrawnAmounts = new TokenAmount[](length);           _burn(address(this), toBurn);  -        for (uint256 i = 0; i < tokens.length; i++) { +        for (uint256 i = 0; i < length; i++) {              address tokenOut = tokens[i];              uint256 balance = records[tokenOut].reserve;              uint120 amountOut = uint120(_mul(ratio, balance)); ```   
# Handle  hrkrshnn   # Vulnerability details  ## Caching the length in for loops  Consider a generic example of an array `arr` and the following loop:  ``` solidity for (uint i = 0; i < arr.length; i++) {     // do something that doesn't change arr.length } ```  In the above case, the solidity compiler will always read the length of the array during each iteration. That is,  1.  if it is a `storage` array, this is an extra `sload` operation (100     additional extra gas     ([EIP-2929](https://eips.ethereum.org/EIPS/eip-2929)) for each     iteration except for the first), 2.  if it is a `memory` array, this is an extra `mload` operation (3     additional gas for each iteration except for the first), 3.  if it is a `calldata` array, this is an extra `calldataload`     operation (3 additional gas for each iteration except for the first)  This extra costs can be avoided by caching the array length (in stack):  ``` solidity uint length = arr.length; for (uint i = 0; i < length; i++) {     // do something that doesn't change arr.length } ```  In the above example, the `sload` or `mload` or `calldataload` operation is only called once and subsequently replaced by a cheap `dupN` instruction. Even though `mload`, `calldataload` and `dupN` have the same gas cost, `mload` and `calldataload` needs an additional `pushX value` to put the offset in the stack, i.e., an extra 3 gas.  This optimization is especially important if it is a storage array or if it is a lengthy for loop. Note: this especially relevant for the IndexPool contract.  Note that the Yul based optimizer (not enabled by default; only relevant if you are using `--experimental-via-ir` or the equivalent in standard JSON) can sometimes do this caching automatically. However, this is likely not the case in your project. [Reference](https://forum.soliditylang.org/t/solidity-team-ama-2-on-wed-10th-of-march-2021/152/15?u=hrkrshnn).  ### Examples  ``` text ./contracts/flat/BentoBoxV1Flat.sol:626:        for (uint256 i = 0; i < calls.length; i++) { ./contracts/pool/PoolDeployer.sol:34:            for (uint256 i; i < tokens.length - 1; i++) { ./contracts/pool/PoolDeployer.sol:36:                for (uint256 j = i + 1; j < tokens.length; j++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:73:        for (uint256 i = 0; i < _tokens.length; i++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:104:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:132:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/franchised/WhiteListManager.sol:105:        for (uint256 i = 0; i < merkleProof.length; i++) { ./contracts/pool/IndexPool.sol:71:        for (uint256 i = 0; i < _tokens.length; i++) { ./contracts/pool/IndexPool.sol:102:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/IndexPool.sol:129:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/utils/TridentHelper.sol:27:        for (uint256 i = 0; i < data.length; i++) { ./contracts/TridentRouter.sol:65:        for (uint256 i; i < params.path.length; i++) { ./contracts/TridentRouter.sol:83:        for (uint256 i; i < path.length; i++) { ./contracts/TridentRouter.sol:123:        for (uint256 i; i < params.path.length; i++) { ./contracts/TridentRouter.sol:139:        for (uint256 i; i < params.initialPath.length; i++) { ./contracts/TridentRouter.sol:149:        for (uint256 i; i < params.percentagePath.length; i++) { ./contracts/TridentRouter.sol:157:        for (uint256 i; i < params.output.length; i++) { ./contracts/TridentRouter.sol:181:        for (uint256 i; i < tokenInput.length; i++) { ./contracts/TridentRouter.sol:223:        for (uint256 i; i < minWithdrawals.length; i++) { ./contracts/TridentRouter.sol:225:            for (; j < withdrawnLiquidity.length; j++) { ./contracts/TridentRouter.sol:274:        for (uint256 i; i < tokenInput.length; i++) { ```   
# Handle  cmichel   # Vulnerability details  The `HybridPool._computeLiquidityFromAdjustedBalances` function should return early if `s == 0` as it will always return zero. Currently, it still performs an expensive loop iteration.  ```solidity if (s == 0) {   // gas: should do an early return here   computed = 0;   // return 0; } ```  ## Recommended Mitigation Steps Return early with a value of `0` if `s == 0`.   
# Handle  cmichel   # Vulnerability details  The `HybridPool.burn` function subtracts some computation from `balance0`/`balance1`, but the result is never used.  ```solidity balance0 -= _toShare(token0, amount0); balance1 -= _toShare(token1, amount1); ```  ## Recommended Mitigation Steps Unless it is used as an underflow check, the computation should be removed the result is not used.   
# Handle  cmichel   # Vulnerability details  The `HybridPool`'s reserves are stored as Bento "amounts" (not Bento shares) in `_updateReserves` because `_balance()` converts the current share balance to amount balances. However, when retrieving the `reserve0/1` storage fields in `_getReserves`, they are converted to amounts a second time.  ## Impact The `HybridPool` returns wrong reserves which affects all minting/burning and swap functions. They all return wrong results making the pool eventually economically exploitable or leading to users receiving less tokens than they should.  ## POC Imagine the current Bento amount / share price being `1.5`. The pool's Bento _share_ balance being `1000`. `_updateReserves` will store a reserve of `1.5 * 1000 = 1500`. When anyone trades using the `swap` function, `_getReserves()` is called and multiplies it by `1.5` again, leading to using a reserve of 2250 instead of 1500. A higher reserve for the output token leads to receiving more tokens as the swap output. Thus the pool lost tokens and the LPs suffer this loss.  ## Recommended Mitigation Steps Make sure that the reserves are in the correct amounts.   
# Handle  cmichel   # Vulnerability details  The `HybridPool.flashSwap` function skips the `tridentSwapCallback` callback call if `data.length == 0`.  ## Impact It should never skip the callback, otherwise the `flashSwap` function is useless. Note that this behavior of the `HybridPool` is not in alignment with the `flashSwap` behavior of all other pools that indeed always call the callback.  ## Recommended Mitigation Steps Always make the call to `ITridentCallee(msg.sender).tridentSwapCallback(data);`, regardless of the `data` variable.  
# Handle  cmichel   # Vulnerability details  The `HybridPool.flashSwap` function sends the entire trade fees `fee` to the `barFeeTo`. It should only send `barFee * fee` to the `barFeeTo` address.  ## Impact LPs are not getting paid at all when this function is used. There is no incentive to provide liquidity.  ## Recommended Mitigation Steps The `flashSwap` function should use the same fee mechanism as `swap` and only send `barFee * fee / MAX_FEE` to the `barFeeTo`. See `_handleFee` function.   
# Handle  cmichel   # Vulnerability details  The `ConstantProductPool.burnSingle` function is basically a `burn` followed by a `swap` and must therefore act the same way as calling these two functions sequentially.  The token amounts to redeem (`amount0`, `amount1`) are computed on the **balance** (not the reserve). However, the swap amount is then computed on the **reserves** and not the balance. The `burn` function would have updated the `reserve` to the balances and therefore `balance` should be used here:  ```solidity amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1); ```  > ⚠️ The same issue occurs in the `HybridPool.burnSingle`.  ## Impact For a burn, usually the `reserve` should equal the `balance`, however if any new tokens are sent to the contract and `balance > reserve`, this function will return slightly less swap amounts.  ## Recommended Mitigation Steps Call `_getAmountOut` with the balances instead of the reserves: `_getAmountOut(amount0, balance0 - amount0, balance1 - amount1)`   
# Handle  cmichel   # Vulnerability details  The `ConstantProductPool` computes optimal balanced LP using `_nonOptimalMintFee`, which performs something like a swap. The returned swap fees should be included in the "`k`" computation as `_handleFees` uses the growth in `k` to estimate the swap fees.  ```solidity // should not reduce fee0 and fee1 uint256 computed = TridentMath.sqrt((balance0 - fee0) * (balance1 - fee1)); ```  > ⚠️ The same issue occurs in the `HybridPool.mint`.  ## Impact The non-optimal mint swap fees are not taken into account.  ## Recommended Mitigation Steps Compute `sqrt(k)` on the `balance0 * balance1` without deducting the swap fees.   
# Handle  cmichel   # Vulnerability details  The `ConstantProductPool.getAmountOut` function does not verify that `tokenIn == token1` in the `else` branch. This is done everywhere else though (see `swap` and `flashSwap`) and should be done here as well.  ## Impact The function can be called with a token that is not any of the pool tokens.  ## Recommended Mitigation Steps Add the missing check.  
# Handle  cmichel   # Vulnerability details  The `TridentHelper.withdrawFromWETH` (used in `TridentRouter.unwrapWETH`) function performs a low-level call to `WETH.withdraw(amount)`.  It then checks if the return `data` length is more or equal to `32` bytes, however `WETH.withdraw` returns `void` and has a return value of `0`. Thus, the function always reverts even if `success == true`.  ```solidity function withdrawFromWETH(uint256 amount) internal {     // @audit WETH.withdraw returns nothing, data.length always zero. this always reverts     require(success && data.length >= 32, "WITHDRAW_FROM_WETH_FAILED"); } ```  ## Impact The `unwrapWETH` function is broken and makes all transactions revert. Batch calls to the router cannot perform any unwrapping of WETH.  ## Recommended Mitigation Steps Remove the `data.length >= 32` from the require and only check if `success` is true.  
# Handle  cmichel   # Vulnerability details  The `IndexPool.constructor` function already mints `INIT_POOL_SUPPLY = 100 * 1e18 = 1e20` LP tokens to the zero address.  When trying to use the pool, someone has to provide the actual initial reserve tokens in `mint`. On the first `mint`, the pool reserves are zero and the token amount required to mint is just this `ratio` itself: `uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;`  Note that the `amountIn` is **independent of the token** which does not make much sense. This implies that all tokens must be provided in equal "raw amounts", regardless of their decimals and value.  ## POC #### Issue 1 Imagine I want to create a DAI/WBTC pool. If I want to initialize the pool with 100$ of DAI, `amountIn = ratio` needs to be `100*1e18=1e20` as DAI has 18 decimals. However, I now also need to supply `1e20` of WBTC (which has 8 decimals) and I'd need to pay `1e20/1e8 * priceOfBTC`, over a quadrillion dollars to match it with the 100$ of DAI.  #### Issue 2 Even in a pool where all tokens have the same decimals and the same value, like `USDC <> USDT`, it leads to issues: - Initial minter calls `mint` with `toMint = 1e20` which sets `ratio = 1e20 * 1e18 / 1e20 = 1e18` and thus `amountIn = 1e18` as well. The total supply increases to `2e20`. - Second minter needs to pay **less** tokens to receive the same amount of `1e18` LP tokens as the first minter. This should never be the case. `toMint = 1e20` => `ratio = 1e20 * 1e18 / 2e20 = 0.5e18`. Then `amountIn = ratio * reserve / 1e18 = 0.5*reserve = 0.5e18`. They only pay half of what the first LP provider had to pay.  ## Impact It's unclear why it's assumed that the pool's tokens are all in equal value - this is _not_ a StableSwap-like pool.  Any pool that uses tokens that don't have the same value and share the same decimals cannot be used because initial liquidity cannot be provided in an economically justifiable way.  It also leads to issues where the second LP supplier has to pay **less tokens** to receive the exact same amount of LP tokens that the initial minter receives. They can steal from the initial LP provider by burning these tokens again.  ## Recommended Mitigation Steps Do not mint the initial token supply to the zero address in the constructor.  Do it like Uniswap/Balancer and let the first liquidity provider provide arbitrary token amounts, then mint the initial pool supply. If `reserve == 0`, `amountIn` should just take the pool balances that were transferred to this account.  In case the initial mint to the zero address in the constructor was done to prevent the "Uniswap-attack" where the price of a single wei of LP token can be very high and price out LPs, send a small fraction of this initial LP supply (~1000) to the zero address **after** it was minted to the first supplier in `mint`.   
# Handle  broccoli   # Vulnerability details  ## Impact  TridentRouter is easy to fail when trying to provide liquidity to an index pool.  Users would not get extra lp if they are not providing lp at the pool's spot price. It's the same design as uniswap v2. However, uniswap's v2 handle's the dirty part.   [UniswapV2Router02.sol#L61-L76](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76) Users would not lose tokens if they use the router.  However, the router wouldn't stop users from transferring extra tokens. [TridentRouter.sol#L168-L190](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L168-L190)  Second, the price would possibly change when the transaction is confirmed. This would be reverted in the index pool.   Users would either transfer extra tokens or fail. I consider this is a medium-risk issue.   ## Proof of Concept  [TridentRouter.sol#L168-L190](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L168-L190)  A possible scenario:  There's a BTC/USD pool. BTC = 50000 USD. 1. A user sends a transaction to transfer 1 BTC and 50000 USD. 2. After the user send a transaction, a random bot buying BTC with USD. 3. The transaction at step 1 is mined. Since the BTC price is not 50000 USD, the transaction fails.   ## Tools Used  None  ## Recommended Mitigation Steps  Please refer to the uniswap v2 router. [UniswapV2Router02.sol#L61-L76](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76)  The router should calculate the optimal parameters for users.    
# Handle  0xRajeev   # Vulnerability details  ## Impact  Constants MAX_FEE_SQUARE and E18 are declared but never used. Unused constants could indicate missing logic or redundant code. In this case, they are likely to be redundant code that can be removed.  ## Proof of Concept  https://github.com/sushiswap/trident/blob/504e2e2f3929175eb7adc73844c381d5174e1c03/contracts/pool/ConstantProductPool.sol#L25  https://github.com/sushiswap/trident/blob/504e2e2f3929175eb7adc73844c381d5174e1c03/contracts/pool/ConstantProductPool.sol#L26  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Evaluate the use of the declared constants or remove them.  
# Handle  GreyArt   # Vulnerability details  ## Impact  Gas optimisation. Casting something of uint256 to uint32 has the same effect as mod since it will wrap around when it overflows. You need to ensure that unchecked math is used otherwise it will revert.  ## Recommended Mitigation Steps  [Line 294 of ConstantProductPool.sol](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/ConstantProductPool.sol#L294)  ```jsx function _update(         uint256 balance0,         uint256 balance1,         uint112 _reserve0,         uint112 _reserve1,         uint32 _blockTimestampLast     ) internal {         require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, "OVERFLOW");         if (blockTimestampLast == 0) {             // @dev TWAP support is disabled for gas efficiency.             reserve0 = uint112(balance0);             reserve1 = uint112(balance1);         } else {       unchecked { // changes starts here        uint32 blockTimestamp = uint32(block.timestamp);       } // changes end here             ...         }         emit Sync(balance0, balance1);     } ```  
# Handle  GreyArt   # Vulnerability details  ### Impact  L102: `_mint(address(0), MINIMUM_LIQUIDITY);` should be shifted after the if / else block to L110 because of further checks done in L106, and L108-L109.  This would help save gas should the checks mentioned fail.  ### Recommended Mitigation Steps  ```jsx if (msg.sender == migrator) {   liquidity = IMigrator(migrator).desiredLiquidity();   require(liquidity != 0 && liquidity != type(uint256).max, "BAD_DESIRED_LIQUIDITY"); } else {   require(migrator == address(0), "ONLY_MIGRATOR");   liquidity = computed - MINIMUM_LIQUIDITY; } _mint(address(0), MINIMUM_LIQUIDITY); ```  
# Handle  GreyArt   # Vulnerability details  ### Impact  A mint fee is applied whenever unbalanced liquidity is added, because it is akin to swapping the excess token amount for the other token.  However, the current implementation distributes the minted fee to the minter as well (when he should be excluded). It therefore acts as a rebate of sorts.  As a result, it makes adding and removing liquidity as opposed to swapping directly (negligibly) more desirable. An example is given below using the Constant Product Pool to illustrate this point. The Hybrid pool exhibits similar behaviour.  ### Proof of Concept  1. Initialize the pool with ETH-USDC sushi pool amounts. As of the time of writing, there is roughly 53586.556 ETH and 165143020.5295 USDC. 2. Mint unbalanced LP with 5 ETH (& 0 USDC). This gives the user `138573488720892 / 1e18` LP tokens. 3. Burn the minted LP tokens, giving the user 2.4963 ETH and 7692.40 USDC. This is therefore equivalent to swapping 5 - 2.4963 = 2.5037 ETH for 7692.4044 USDC. 4. If the user were to swap the 2.5037 ETH directly, he would receive 7692.369221 (0.03 USDC lesser).  ### Recommended Mitigation Steps  The mint fee should be distributed to existing LPs first, by incrementing `_reserve0` and `_reserve1` with the fee amounts. The rest of the calculations follow after.  ConstantProductPool  ```jsx (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1); // increment reserve amounts with fees _reserve0 += uint112(fee0); _reserve1 += uint112(fee1); unchecked {     _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply); } uint256 computed = TridentMath.sqrt(balance0 * balance1); ... kLast = computed; ```  HybridPool  ```jsx (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1); // increment reserve amounts with fees _reserve0 += uint112(fee0); _reserve1 += uint112(fee1); uint256 newLiq = _computeLiquidity(balance0, balance1); ... ```  
# Handle  broccoli   # Vulnerability details  ## Impact  When an lp provider deposits an imbalance amount of token, a swap fee is applied. HybridPool uses the same `_nonOptimalMintFee` as `constantProductPool`; however, since two pools use different AMM curve, the ideal balance is not the same.  ref: [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337)  Stable swap Pools are designed for 1B+ TVL. Any issue related to pricing/fee is serious. I consider this is a high-risk issue  ## Proof of Concept  [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337)  [HybridPool.sol#L425-L441](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L425-L441)  ## Tools Used  None  ## Recommended Mitigation Steps Calculate the swapping fee based on the stable swap curve. Please refer to [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337).  
# Handle  broccoli   # Vulnerability details  ## Impact  In the IndexPool contract, pow is used in calculating price. [IndexPool.sol#L255-L266](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L255-L266) However, Pow is easy to cause overflow. If the `weightRatio` is large (e.g. 10), there's always overflow.  Lp providers can still provide liquidity to the pool where no one can swap. All pools need to redeploy. I consider this a high-risk issue.   ## Proof of concept  It's easy to trigger this bug by deploying a 1:10 IndexPool.  ```python     deployed_code = encode_abi(["address[]","uint136[]","uint256"], [         (link.address, dai.address),         (10**18, 10 * 10**18),         10**13     ])     tx_hash = master_deployer.functions.deployPool(index_pool_factory.address, deployed_code).transact() ```  Transactions would be reverted when buying `link` with `dai`. ## Tools Used  None  ## Recommended Mitigation Steps  The `weightRatio` is an 18 decimals number. It should be divided by `(BASE)^exp`. The scale in the contract is not consistent. Recommend the dev to check all the scales/ decimals.   
# Handle  gpersoon   # Vulnerability details  ## Impact The function _update() of ConstantProductPool.sol verifies if blockTimestampLast == 0. The value of blockTimestampLast is also passed in the parameter _blockTimestampLast  (note: with extra _ ) So _blockTimestampLast could also be used, which saves a bit of gas.  ## Proof of Concept https://github.com/sushiswap/trident/blob/master/contracts/pool/ConstantProductPool.sol#L264  function _update(...        uint32 _blockTimestampLast) internal {         ...         if (blockTimestampLast == 0) {    // could also use _blockTimestampLast  ## Tools Used  ## Recommended Mitigation Steps replace    if (blockTimestampLast == 0) {    with    if (_blockTimestampLast == 0) {      
# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeLiquidityFromAdjustedBalances` function of `HybridPool` should return in the `if (s == 0)` statement, or it will cause a divison-by-zero error otherwise.  ## Proof of Concept  Referenced code: [HybridPool.sol#L350-L352](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L350-L352)  ## Recommended Mitigation Steps  Add `return computed;` after `computed = 0;`.  
# Handle  0xsanson   # Vulnerability details  ## Impact IndexPool doesn't collect fees for `barFeeTo`. Since this Pool contains also a method `updateBarFee()`, probably this is an unintended behavior. Also without a fee, liquidity providers would probably ditch ConstantProductPool in favor of IndexPool (using the same two tokens with equal weights), since they get all the rewards. This would constitute an issue for the ecosystem.  ## Recommended Mitigation Steps Add a way to send barFees to barFeeTo, same as the other pools.  
# Handle  broccoli   # Vulnerability details  ## Impact  The `_depositToBentoBox` and `_depositFromUserToBentoBox` allow users to provide ETH to the router, which is later deposited to the `bento` contract for swapping other assets or providing liquidity. However, in these two functions, the input parameter does not represent the actual amount of ETH to deposit, and users have to calculate the actual amount and send it to the router, causing a back-run vulnerability if there are ETH left after the operation.  ## Proof of Concept  1. A user wants to swap ETH to DAI. He calls `exactInputSingleWithNativeToken` on the router with the corresponding parameters and `params.amountIn` being 10. Before calling the function, he calculates `bento.toAmount(wETH, 10, true) = 15` and thus send 15 ETH to the router. 2. However, at the time when his transaction is executed, `bento.toAmount(wETH, amount, true)` becomes to `14`, which could happen if someone calls `harvest` on `bento` to update the `elastic` value of the `wETH` token. 3. As a result, only 14 ETH is transferred to the pool, and 1 ETH is left in the router. Anyone could back-run the user's transaction to retrieve the remaining 1 ETH from the router by calling the `refundETH` function.  Referenced code: [TridentRouter.sol#L318-L351](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L318-L351)  ## Recommended Mitigation Steps  Directly push the remaining ETH to the sender to prevent any ETH left in the router.  
# Handle  broccoli   # Vulnerability details  ## Impact  An attacker can call the `bento.harvest` function during the callback function of a flash swap of the `HybridPool` to reduce the number of input tokens that he has to pay to the pool, as long as there is any unrealized profit in the strategy contract of the underlying asset.  ## Proof of Concept  1. The `HybridPool` accounts for the reserve and balance of the pool using the `bento.toAmount` function, which represents the actual amount of assets that the pool owns instead of the relative share. The value of `toAmount` could increase or decrease if the `bento.harvest` function is called (by anyone), depending on whether the strategy contract earns or loses money. 2. Supposing that the DAI strategy contract of `Bento` has a profit not accounted for yet. To account for the profit, anyone could call `harvest` on `Bento` with the corresponding parameters, which, as a result, increases the `elastic` of the DAI token. 3. Now, an attacker wants to utilize the unrealized profit to steal funds from a DAI-WETH hybrid pool. He calls `flashSwap` to initiate a flash swap from WETH to DAI. First, the pool transfers the corresponding amount of DAI to him, calls the `tridentSwapCallback` function on the attacker's contract, and expects that enough DAI is received at the end. 4. During the `tridentSwapCallback` function, the attacker calls `bento.harvest` to realize the profit of DAI. As a result, the pool's `bento.toAmount` increases, and the amount of DAI that the attacker has to pay to the pool is decreased. The attacker could get the same amount of ETH but paying less DAI by exploiting this bug.  Referenced code: [HybridPool.sol#L218-L220](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L218-L220) [HybridPool.sol#L249-L250](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L249-L250) [HybridPool.sol#L272-L285](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L272-L285) [BentoBoxV1Flat.sol#L1105](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L1105) [BentoBoxV1Flat.sol#L786-L792](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L786-L792) [BentoBoxV1Flat.sol#L264-L277](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L264-L277)  ## Recommended Mitigation Steps  Consider not using `bento.toAmount` to track the reservers and balances, but use `balanceOf` instead (as done in the other two pools).   
# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeSingleOutGivenPoolIn` function of `IndexPool` uses the raw multiplication (i.e., `*`) to calculate the `zaz` variable. However, since both `(BASE - normalizedWeight)` and `_swapFee` are in `WAD`, the `_mul` function should be used instead to calculate the correct value of `zaz`. Otherwise, `zaz` would be `10 ** 18` times larger than the expected value and causes an integer underflow when calculating `amountOut`. The incorrect usage of multiplication prevents anyone from calling the function successfully.  ## Proof of Concept  Referenced code: [IndexPool.sol#L282](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L282)   ## Recommended Mitigation Steps  Change `(BASE - normalizedWeight) * _swapFee` to `_mul((BASE - normalizedWeight), _swapFee)`.  
# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeSingleOutGivenPoolIn` function of `IndexPool` uses the `_pow` function to calculate `tokenOutRatio` with the exponent in `WAD` (i.e., in 18 decimals of precision). However, the `_pow` function assumes that the given exponent `n` is not in `WAD`. (for example, `_pow(5, BASE)` returns `5 ** (10 ** 18)` instead of `5 ** 1`). The misuse of the `_pow` function could causes an integer overflow in the `_computeSingleOutGivenPoolIn` function and thus prevent any function from calling it.  ## Proof of Concept  Referenced code: [IndexPool.sol#L279](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L279)   ## Recommended Mitigation Steps  Change the `_pow` function to the `_compute` function, which supports exponents in `WAD`.  
# Handle  0xsanson   # Vulnerability details  ## Impact In HybridPool.sol, functions `_getY` and `_getYD` are identical (only differences are variables' names), and only `_getY` is used in the contract.  Since these functions are supposed to mimic those of Curve, it would make more sense to follow their naming conventions. In particular, `_getYD` correctly mimics Curve's `_get_y_D` ([ref](https://github.com/curvefi/curve-contract/blob/master/contracts/pool-templates/base/SwapTemplateBase.vy#L614)), while `_getY` does not mimic Curve's `_get_y` ([ref](https://github.com/curvefi/curve-contract/blob/master/contracts/pool-templates/base/SwapTemplateBase.vy#L379)).  ## Recommended Mitigation Steps Consider eliminating `_getY` and using `_getYD` instead in the contract.  
# Handle  tensors   # Vulnerability details  Throughout the code function selectors are often used instead of interfaces.  It is considered best practice to use interfaces instead of selectors for code readability.  
# Handle  tensors   # Vulnerability details  Constants of form 10**X can be rewritten as 1eX and this will save gas.  
# Handle  hack3r-0m   # Vulnerability details  https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/libraries/MathUtils.sol#L22 the difference is computed incorrectly when a > b.  As it only used in within1 function, scope narrows down to where `difference(a, b) <= 1;` is exploitable.  cases where `difference(a, b) <= 1` should be true but is reported false: - where b = a-1 (returned value is type(uint256).max)  cases where `difference(a, b) <= 1` should be false but is reported true: - where a = type(uint256).max and b = 0, it returns 1 but it should ideally return type(uint256).max  within1 is used at the following locations: - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L359 - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L383 - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L413  It is possible to decrease the denominator and increase the value of the numerator (when calculating y) using constants and input to make within1 fail  Mitigation:  Add `else` condition to mitigate it.  ``` unchecked {           if (a > b) {               diff = a - b;           }           else {               diff = b - a;              }       } ```  (re-submitting this issue after withdrawing past one since I forgot to add more  details and POC)  
# Handle  WatchPug   # Vulnerability details  Cache storage variable in the stack can save gas.  For instance:  https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L140-L155  `outRecord.reserve` is accessed 2 times.   https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L158-L179 https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L182-L205  `inRecord.reserve` is accessed 3 times.  
# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  https://github.com/sushiswap/trident/blob/master/contracts/TridentRouter.sol#L214-L234  - minWithdrawals.length - withdrawnLiquidity.length  https://github.com/sushiswap/trident/blob/master/contracts/TridentRouter.sol#L274  - tokenInput.length  https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L114-L136  - tokens.length  
# Handle  hrkrshnn   # Vulnerability details  ## Consider avoiding low level calls to MasterDeployer  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/ConstantProductPool.sol#L64)  The constructor uses low-level calls to the master deployer. It is more idiomatic to rely on high level solidity to deal with the calls. The difference would be additional checks on whether there is code at the specified address (additional `100` gas) and automatically performing the ABI decoding (may actually be more efficient than the manual implementation.) (Note that this call will still be `staticcall`, since `barFee` is a view function in the interface.)  Example:  ``` diff modified   contracts/pool/ConstantProductPool.sol @@ -61,7 +61,7 @@ contract ConstantProductPool is IPool, TridentERC20 {          require(_token1 != address(this), "INVALID_TOKEN");          require(_swapFee <= MAX_FEE, "INVALID_SWAP_FEE");  -        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector)); +        barFee = IMasterDeployer(_masterDeployer).barFee();          (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));          (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));  @@ -72,7 +72,6 @@ contract ConstantProductPool is IPool, TridentERC20 {          unchecked {              MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;          } -        barFee = abi.decode(_barFee, (uint256));          barFeeTo = abi.decode(_barFeeTo, (address));          bento = abi.decode(_bento, (address));          masterDeployer = _masterDeployer; ```   
# Handle  hrkrshnn   # Vulnerability details  ## Use `calldata` instead of `memory` for function parameters  In some cases, having function arguments in `calldata` instead of `memory` is more optimal.  Consider the following generic example:  ``` solidity contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above example, the dynamic array `arr` has the storage location `memory`. When the function gets called externally, the array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). And during the for loop, `arr[i]` accesses the value in memory using a `mload`. However, for the above example this is inefficient. Consider the following snippet instead:  ``` solidity contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  **Gas savings**: In the former example, the ABI decoding begins with copying value from `calldata` to `memory` in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  *In short*, use `calldata` instead of `memory` if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from `memory` to `calldata` may cause "unimplemented feature error". This can be avoided by using a newer (`0.8.*`) Solidity compiler.  ### Examples  ****Note****: The following pattern is prevalent in the codebase:  ``` solidity function f(bytes memory data) external {     (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to `bytes calldata` will decrease the gas. The total savings for this change across all such uses would be *quite significant.*  Examples:  ``` text ./contracts/examples/PoolFactory.sol:15:    function deployPool(bytes memory _deployData) external override returns (address) { ./contracts/examples/PoolTemplate.sol:12:    constructor(bytes memory _data) { ./contracts/flat/BentoBoxV1Flat.sol:603:    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) { ./contracts/pool/HybridPoolFactory.sol:13:    function deployPool(bytes memory _deployData) external returns (address pool) { ./contracts/pool/IndexPoolFactory.sol:13:    function deployPool(bytes memory _deployData) external returns (address pool) { ./contracts/pool/franchised/FranchisedConstantProductPool.sol:54:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/franchised/FranchisedHybridPool.sol:60:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/franchised/FranchisedIndexPool.sol:61:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/HybridPool.sol:60:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/ConstantProductPoolFactory.sol:13:    function deployPool(bytes memory _deployData) external returns (address pool) { ./contracts/pool/ConstantProductPool.sol:54:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/IndexPool.sol:61:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/utils/TridentHelper.sol:143:    function getSelector(bytes memory _data) internal pure returns (bytes4 sig) { ```  Other examples:  1.  <https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L174> 2.  <https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L218>   
# Handle  hrkrshnn   # Vulnerability details  ## Consider putting some parts of `_div` in unchecked  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L335)  ``` diff modified   contracts/pool/IndexPool.sol @@ -332,7 +332,8 @@ contract IndexPool is IPool, TridentERC20 {       function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {          uint256 c0 = a * BASE; -        uint256 c1 = c0 + (b / 2); +        unchecked { uint256 tmp =  b / 2; } +        uint256 c1 = c0 + tmp;          c2 = c1 / b;      } ```  Looking at the optimized assembly generated, the unchecked version doesn't seem to have the additional check for division by zero. I'm not entirely sure why, but my guess is because of inlining. Also consider replacing the division by inline assembly.  ``` solidity uint tmp; assembly {     tmp := div(b, 2) } uint256 c1 = c0 + tmp; ```  The change avoids an `if` condition which checks if the divisor is zero, which the optimizer is currently unable to optimize out. The gas savings would be around 16 (reduces a `jumpi`, `push 0` and `dupN`). Since the `_div` function is called from throughout the code (also present in other contracts), this may be worth considering, although I admit this might be too much of a micro-optimization.   
# Handle  hrkrshnn   # Vulnerability details  ## Caching a storage load in TridentERC20  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/TridentERC20.sol#L76)  This avoids an unnecessary `sload`.  ``` diff modified   contracts/pool/TridentERC20.sol @@ -73,8 +73,9 @@ abstract contract TridentERC20 {          address recipient,          uint256 amount      ) external returns (bool) { -        if (allowance[sender][msg.sender] != type(uint256).max) { -            allowance[sender][msg.sender] -= amount; +        uint _allowance = allowance[sender][msg.sender]; +        if (_allowance != type(uint256).max) { +            allowance[sender][msg.sender] = _allowance - amount;          }          balanceOf[sender] -= amount;          // @dev This is safe from overflow - the sum of all user ```   
# Handle  hrkrshnn   # Vulnerability details  ## Caching the storage read to `tokens.length`  Ignoring the caching for the for-loop condition (see my other issue "Caching the length in for loops"), this would save an additional `sload`, around `100` gas.  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L129).  ``` diff modified   contracts/pool/IndexPool.sol @@ -121,12 +121,12 @@ contract IndexPool is IPool, TridentERC20 {          (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));           uint256 ratio = _div(toBurn, totalSupply); -        withdrawnAmounts = new TokenAmount[](tokens.length); +        uint length = tokens.length; +        withdrawnAmounts = new TokenAmount[](length);           _burn(address(this), toBurn);  -        for (uint256 i = 0; i < tokens.length; i++) { +        for (uint256 i = 0; i < length; i++) {              address tokenOut = tokens[i];              uint256 balance = records[tokenOut].reserve;              uint120 amountOut = uint120(_mul(ratio, balance)); ```   
# Handle  hrkrshnn   # Vulnerability details  ## Caching the length in for loops  Consider a generic example of an array `arr` and the following loop:  ``` solidity for (uint i = 0; i < arr.length; i++) {     // do something that doesn't change arr.length } ```  In the above case, the solidity compiler will always read the length of the array during each iteration. That is,  1.  if it is a `storage` array, this is an extra `sload` operation (100     additional extra gas     ([EIP-2929](https://eips.ethereum.org/EIPS/eip-2929)) for each     iteration except for the first), 2.  if it is a `memory` array, this is an extra `mload` operation (3     additional gas for each iteration except for the first), 3.  if it is a `calldata` array, this is an extra `calldataload`     operation (3 additional gas for each iteration except for the first)  This extra costs can be avoided by caching the array length (in stack):  ``` solidity uint length = arr.length; for (uint i = 0; i < length; i++) {     // do something that doesn't change arr.length } ```  In the above example, the `sload` or `mload` or `calldataload` operation is only called once and subsequently replaced by a cheap `dupN` instruction. Even though `mload`, `calldataload` and `dupN` have the same gas cost, `mload` and `calldataload` needs an additional `pushX value` to put the offset in the stack, i.e., an extra 3 gas.  This optimization is especially important if it is a storage array or if it is a lengthy for loop. Note: this especially relevant for the IndexPool contract.  Note that the Yul based optimizer (not enabled by default; only relevant if you are using `--experimental-via-ir` or the equivalent in standard JSON) can sometimes do this caching automatically. However, this is likely not the case in your project. [Reference](https://forum.soliditylang.org/t/solidity-team-ama-2-on-wed-10th-of-march-2021/152/15?u=hrkrshnn).  ### Examples  ``` text ./contracts/flat/BentoBoxV1Flat.sol:626:        for (uint256 i = 0; i < calls.length; i++) { ./contracts/pool/PoolDeployer.sol:34:            for (uint256 i; i < tokens.length - 1; i++) { ./contracts/pool/PoolDeployer.sol:36:                for (uint256 j = i + 1; j < tokens.length; j++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:73:        for (uint256 i = 0; i < _tokens.length; i++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:104:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:132:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/franchised/WhiteListManager.sol:105:        for (uint256 i = 0; i < merkleProof.length; i++) { ./contracts/pool/IndexPool.sol:71:        for (uint256 i = 0; i < _tokens.length; i++) { ./contracts/pool/IndexPool.sol:102:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/IndexPool.sol:129:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/utils/TridentHelper.sol:27:        for (uint256 i = 0; i < data.length; i++) { ./contracts/TridentRouter.sol:65:        for (uint256 i; i < params.path.length; i++) { ./contracts/TridentRouter.sol:83:        for (uint256 i; i < path.length; i++) { ./contracts/TridentRouter.sol:123:        for (uint256 i; i < params.path.length; i++) { ./contracts/TridentRouter.sol:139:        for (uint256 i; i < params.initialPath.length; i++) { ./contracts/TridentRouter.sol:149:        for (uint256 i; i < params.percentagePath.length; i++) { ./contracts/TridentRouter.sol:157:        for (uint256 i; i < params.output.length; i++) { ./contracts/TridentRouter.sol:181:        for (uint256 i; i < tokenInput.length; i++) { ./contracts/TridentRouter.sol:223:        for (uint256 i; i < minWithdrawals.length; i++) { ./contracts/TridentRouter.sol:225:            for (; j < withdrawnLiquidity.length; j++) { ./contracts/TridentRouter.sol:274:        for (uint256 i; i < tokenInput.length; i++) { ```   
# Handle  cmichel   # Vulnerability details  The `HybridPool._computeLiquidityFromAdjustedBalances` function should return early if `s == 0` as it will always return zero. Currently, it still performs an expensive loop iteration.  ```solidity if (s == 0) {   // gas: should do an early return here   computed = 0;   // return 0; } ```  ## Recommended Mitigation Steps Return early with a value of `0` if `s == 0`.   
# Handle  cmichel   # Vulnerability details  The `HybridPool.burn` function subtracts some computation from `balance0`/`balance1`, but the result is never used.  ```solidity balance0 -= _toShare(token0, amount0); balance1 -= _toShare(token1, amount1); ```  ## Recommended Mitigation Steps Unless it is used as an underflow check, the computation should be removed the result is not used.   
# Handle  cmichel   # Vulnerability details  The `HybridPool`'s reserves are stored as Bento "amounts" (not Bento shares) in `_updateReserves` because `_balance()` converts the current share balance to amount balances. However, when retrieving the `reserve0/1` storage fields in `_getReserves`, they are converted to amounts a second time.  ## Impact The `HybridPool` returns wrong reserves which affects all minting/burning and swap functions. They all return wrong results making the pool eventually economically exploitable or leading to users receiving less tokens than they should.  ## POC Imagine the current Bento amount / share price being `1.5`. The pool's Bento _share_ balance being `1000`. `_updateReserves` will store a reserve of `1.5 * 1000 = 1500`. When anyone trades using the `swap` function, `_getReserves()` is called and multiplies it by `1.5` again, leading to using a reserve of 2250 instead of 1500. A higher reserve for the output token leads to receiving more tokens as the swap output. Thus the pool lost tokens and the LPs suffer this loss.  ## Recommended Mitigation Steps Make sure that the reserves are in the correct amounts.   
# Handle  cmichel   # Vulnerability details  The `HybridPool.flashSwap` function skips the `tridentSwapCallback` callback call if `data.length == 0`.  ## Impact It should never skip the callback, otherwise the `flashSwap` function is useless. Note that this behavior of the `HybridPool` is not in alignment with the `flashSwap` behavior of all other pools that indeed always call the callback.  ## Recommended Mitigation Steps Always make the call to `ITridentCallee(msg.sender).tridentSwapCallback(data);`, regardless of the `data` variable.  
# Handle  cmichel   # Vulnerability details  The `HybridPool.flashSwap` function sends the entire trade fees `fee` to the `barFeeTo`. It should only send `barFee * fee` to the `barFeeTo` address.  ## Impact LPs are not getting paid at all when this function is used. There is no incentive to provide liquidity.  ## Recommended Mitigation Steps The `flashSwap` function should use the same fee mechanism as `swap` and only send `barFee * fee / MAX_FEE` to the `barFeeTo`. See `_handleFee` function.   
# Handle  cmichel   # Vulnerability details  The `ConstantProductPool.burnSingle` function is basically a `burn` followed by a `swap` and must therefore act the same way as calling these two functions sequentially.  The token amounts to redeem (`amount0`, `amount1`) are computed on the **balance** (not the reserve). However, the swap amount is then computed on the **reserves** and not the balance. The `burn` function would have updated the `reserve` to the balances and therefore `balance` should be used here:  ```solidity amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1); ```  > ⚠️ The same issue occurs in the `HybridPool.burnSingle`.  ## Impact For a burn, usually the `reserve` should equal the `balance`, however if any new tokens are sent to the contract and `balance > reserve`, this function will return slightly less swap amounts.  ## Recommended Mitigation Steps Call `_getAmountOut` with the balances instead of the reserves: `_getAmountOut(amount0, balance0 - amount0, balance1 - amount1)`   
# Handle  cmichel   # Vulnerability details  The `ConstantProductPool` computes optimal balanced LP using `_nonOptimalMintFee`, which performs something like a swap. The returned swap fees should be included in the "`k`" computation as `_handleFees` uses the growth in `k` to estimate the swap fees.  ```solidity // should not reduce fee0 and fee1 uint256 computed = TridentMath.sqrt((balance0 - fee0) * (balance1 - fee1)); ```  > ⚠️ The same issue occurs in the `HybridPool.mint`.  ## Impact The non-optimal mint swap fees are not taken into account.  ## Recommended Mitigation Steps Compute `sqrt(k)` on the `balance0 * balance1` without deducting the swap fees.   
# Handle  cmichel   # Vulnerability details  The `ConstantProductPool.getAmountOut` function does not verify that `tokenIn == token1` in the `else` branch. This is done everywhere else though (see `swap` and `flashSwap`) and should be done here as well.  ## Impact The function can be called with a token that is not any of the pool tokens.  ## Recommended Mitigation Steps Add the missing check.  
# Handle  cmichel   # Vulnerability details  The `TridentHelper.withdrawFromWETH` (used in `TridentRouter.unwrapWETH`) function performs a low-level call to `WETH.withdraw(amount)`.  It then checks if the return `data` length is more or equal to `32` bytes, however `WETH.withdraw` returns `void` and has a return value of `0`. Thus, the function always reverts even if `success == true`.  ```solidity function withdrawFromWETH(uint256 amount) internal {     // @audit WETH.withdraw returns nothing, data.length always zero. this always reverts     require(success && data.length >= 32, "WITHDRAW_FROM_WETH_FAILED"); } ```  ## Impact The `unwrapWETH` function is broken and makes all transactions revert. Batch calls to the router cannot perform any unwrapping of WETH.  ## Recommended Mitigation Steps Remove the `data.length >= 32` from the require and only check if `success` is true.  
# Handle  cmichel   # Vulnerability details  The `IndexPool.constructor` function already mints `INIT_POOL_SUPPLY = 100 * 1e18 = 1e20` LP tokens to the zero address.  When trying to use the pool, someone has to provide the actual initial reserve tokens in `mint`. On the first `mint`, the pool reserves are zero and the token amount required to mint is just this `ratio` itself: `uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;`  Note that the `amountIn` is **independent of the token** which does not make much sense. This implies that all tokens must be provided in equal "raw amounts", regardless of their decimals and value.  ## POC #### Issue 1 Imagine I want to create a DAI/WBTC pool. If I want to initialize the pool with 100$ of DAI, `amountIn = ratio` needs to be `100*1e18=1e20` as DAI has 18 decimals. However, I now also need to supply `1e20` of WBTC (which has 8 decimals) and I'd need to pay `1e20/1e8 * priceOfBTC`, over a quadrillion dollars to match it with the 100$ of DAI.  #### Issue 2 Even in a pool where all tokens have the same decimals and the same value, like `USDC <> USDT`, it leads to issues: - Initial minter calls `mint` with `toMint = 1e20` which sets `ratio = 1e20 * 1e18 / 1e20 = 1e18` and thus `amountIn = 1e18` as well. The total supply increases to `2e20`. - Second minter needs to pay **less** tokens to receive the same amount of `1e18` LP tokens as the first minter. This should never be the case. `toMint = 1e20` => `ratio = 1e20 * 1e18 / 2e20 = 0.5e18`. Then `amountIn = ratio * reserve / 1e18 = 0.5*reserve = 0.5e18`. They only pay half of what the first LP provider had to pay.  ## Impact It's unclear why it's assumed that the pool's tokens are all in equal value - this is _not_ a StableSwap-like pool.  Any pool that uses tokens that don't have the same value and share the same decimals cannot be used because initial liquidity cannot be provided in an economically justifiable way.  It also leads to issues where the second LP supplier has to pay **less tokens** to receive the exact same amount of LP tokens that the initial minter receives. They can steal from the initial LP provider by burning these tokens again.  ## Recommended Mitigation Steps Do not mint the initial token supply to the zero address in the constructor.  Do it like Uniswap/Balancer and let the first liquidity provider provide arbitrary token amounts, then mint the initial pool supply. If `reserve == 0`, `amountIn` should just take the pool balances that were transferred to this account.  In case the initial mint to the zero address in the constructor was done to prevent the "Uniswap-attack" where the price of a single wei of LP token can be very high and price out LPs, send a small fraction of this initial LP supply (~1000) to the zero address **after** it was minted to the first supplier in `mint`.   
# Handle  broccoli   # Vulnerability details  ## Impact  TridentRouter is easy to fail when trying to provide liquidity to an index pool.  Users would not get extra lp if they are not providing lp at the pool's spot price. It's the same design as uniswap v2. However, uniswap's v2 handle's the dirty part.   [UniswapV2Router02.sol#L61-L76](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76) Users would not lose tokens if they use the router.  However, the router wouldn't stop users from transferring extra tokens. [TridentRouter.sol#L168-L190](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L168-L190)  Second, the price would possibly change when the transaction is confirmed. This would be reverted in the index pool.   Users would either transfer extra tokens or fail. I consider this is a medium-risk issue.   ## Proof of Concept  [TridentRouter.sol#L168-L190](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L168-L190)  A possible scenario:  There's a BTC/USD pool. BTC = 50000 USD. 1. A user sends a transaction to transfer 1 BTC and 50000 USD. 2. After the user send a transaction, a random bot buying BTC with USD. 3. The transaction at step 1 is mined. Since the BTC price is not 50000 USD, the transaction fails.   ## Tools Used  None  ## Recommended Mitigation Steps  Please refer to the uniswap v2 router. [UniswapV2Router02.sol#L61-L76](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76)  The router should calculate the optimal parameters for users.    
# Handle  0xRajeev   # Vulnerability details  ## Impact  Constants MAX_FEE_SQUARE and E18 are declared but never used. Unused constants could indicate missing logic or redundant code. In this case, they are likely to be redundant code that can be removed.  ## Proof of Concept  https://github.com/sushiswap/trident/blob/504e2e2f3929175eb7adc73844c381d5174e1c03/contracts/pool/ConstantProductPool.sol#L25  https://github.com/sushiswap/trident/blob/504e2e2f3929175eb7adc73844c381d5174e1c03/contracts/pool/ConstantProductPool.sol#L26  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Evaluate the use of the declared constants or remove them.  
# Handle  GreyArt   # Vulnerability details  ## Impact  Gas optimisation. Casting something of uint256 to uint32 has the same effect as mod since it will wrap around when it overflows. You need to ensure that unchecked math is used otherwise it will revert.  ## Recommended Mitigation Steps  [Line 294 of ConstantProductPool.sol](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/ConstantProductPool.sol#L294)  ```jsx function _update(         uint256 balance0,         uint256 balance1,         uint112 _reserve0,         uint112 _reserve1,         uint32 _blockTimestampLast     ) internal {         require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, "OVERFLOW");         if (blockTimestampLast == 0) {             // @dev TWAP support is disabled for gas efficiency.             reserve0 = uint112(balance0);             reserve1 = uint112(balance1);         } else {       unchecked { // changes starts here        uint32 blockTimestamp = uint32(block.timestamp);       } // changes end here             ...         }         emit Sync(balance0, balance1);     } ```  
# Handle  GreyArt   # Vulnerability details  ### Impact  L102: `_mint(address(0), MINIMUM_LIQUIDITY);` should be shifted after the if / else block to L110 because of further checks done in L106, and L108-L109.  This would help save gas should the checks mentioned fail.  ### Recommended Mitigation Steps  ```jsx if (msg.sender == migrator) {   liquidity = IMigrator(migrator).desiredLiquidity();   require(liquidity != 0 && liquidity != type(uint256).max, "BAD_DESIRED_LIQUIDITY"); } else {   require(migrator == address(0), "ONLY_MIGRATOR");   liquidity = computed - MINIMUM_LIQUIDITY; } _mint(address(0), MINIMUM_LIQUIDITY); ```  
# Handle  GreyArt   # Vulnerability details  ### Impact  A mint fee is applied whenever unbalanced liquidity is added, because it is akin to swapping the excess token amount for the other token.  However, the current implementation distributes the minted fee to the minter as well (when he should be excluded). It therefore acts as a rebate of sorts.  As a result, it makes adding and removing liquidity as opposed to swapping directly (negligibly) more desirable. An example is given below using the Constant Product Pool to illustrate this point. The Hybrid pool exhibits similar behaviour.  ### Proof of Concept  1. Initialize the pool with ETH-USDC sushi pool amounts. As of the time of writing, there is roughly 53586.556 ETH and 165143020.5295 USDC. 2. Mint unbalanced LP with 5 ETH (& 0 USDC). This gives the user `138573488720892 / 1e18` LP tokens. 3. Burn the minted LP tokens, giving the user 2.4963 ETH and 7692.40 USDC. This is therefore equivalent to swapping 5 - 2.4963 = 2.5037 ETH for 7692.4044 USDC. 4. If the user were to swap the 2.5037 ETH directly, he would receive 7692.369221 (0.03 USDC lesser).  ### Recommended Mitigation Steps  The mint fee should be distributed to existing LPs first, by incrementing `_reserve0` and `_reserve1` with the fee amounts. The rest of the calculations follow after.  ConstantProductPool  ```jsx (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1); // increment reserve amounts with fees _reserve0 += uint112(fee0); _reserve1 += uint112(fee1); unchecked {     _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply); } uint256 computed = TridentMath.sqrt(balance0 * balance1); ... kLast = computed; ```  HybridPool  ```jsx (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1); // increment reserve amounts with fees _reserve0 += uint112(fee0); _reserve1 += uint112(fee1); uint256 newLiq = _computeLiquidity(balance0, balance1); ... ```  
# Handle  broccoli   # Vulnerability details  ## Impact  When an lp provider deposits an imbalance amount of token, a swap fee is applied. HybridPool uses the same `_nonOptimalMintFee` as `constantProductPool`; however, since two pools use different AMM curve, the ideal balance is not the same.  ref: [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337)  Stable swap Pools are designed for 1B+ TVL. Any issue related to pricing/fee is serious. I consider this is a high-risk issue  ## Proof of Concept  [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337)  [HybridPool.sol#L425-L441](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L425-L441)  ## Tools Used  None  ## Recommended Mitigation Steps Calculate the swapping fee based on the stable swap curve. Please refer to [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337).  
# Handle  broccoli   # Vulnerability details  ## Impact  In the IndexPool contract, pow is used in calculating price. [IndexPool.sol#L255-L266](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L255-L266) However, Pow is easy to cause overflow. If the `weightRatio` is large (e.g. 10), there's always overflow.  Lp providers can still provide liquidity to the pool where no one can swap. All pools need to redeploy. I consider this a high-risk issue.   ## Proof of concept  It's easy to trigger this bug by deploying a 1:10 IndexPool.  ```python     deployed_code = encode_abi(["address[]","uint136[]","uint256"], [         (link.address, dai.address),         (10**18, 10 * 10**18),         10**13     ])     tx_hash = master_deployer.functions.deployPool(index_pool_factory.address, deployed_code).transact() ```  Transactions would be reverted when buying `link` with `dai`. ## Tools Used  None  ## Recommended Mitigation Steps  The `weightRatio` is an 18 decimals number. It should be divided by `(BASE)^exp`. The scale in the contract is not consistent. Recommend the dev to check all the scales/ decimals.   
# Handle  gpersoon   # Vulnerability details  ## Impact The function _update() of ConstantProductPool.sol verifies if blockTimestampLast == 0. The value of blockTimestampLast is also passed in the parameter _blockTimestampLast  (note: with extra _ ) So _blockTimestampLast could also be used, which saves a bit of gas.  ## Proof of Concept https://github.com/sushiswap/trident/blob/master/contracts/pool/ConstantProductPool.sol#L264  function _update(...        uint32 _blockTimestampLast) internal {         ...         if (blockTimestampLast == 0) {    // could also use _blockTimestampLast  ## Tools Used  ## Recommended Mitigation Steps replace    if (blockTimestampLast == 0) {    with    if (_blockTimestampLast == 0) {      
# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeLiquidityFromAdjustedBalances` function of `HybridPool` should return in the `if (s == 0)` statement, or it will cause a divison-by-zero error otherwise.  ## Proof of Concept  Referenced code: [HybridPool.sol#L350-L352](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L350-L352)  ## Recommended Mitigation Steps  Add `return computed;` after `computed = 0;`.  
# Handle  0xsanson   # Vulnerability details  ## Impact IndexPool doesn't collect fees for `barFeeTo`. Since this Pool contains also a method `updateBarFee()`, probably this is an unintended behavior. Also without a fee, liquidity providers would probably ditch ConstantProductPool in favor of IndexPool (using the same two tokens with equal weights), since they get all the rewards. This would constitute an issue for the ecosystem.  ## Recommended Mitigation Steps Add a way to send barFees to barFeeTo, same as the other pools.  
# Handle  broccoli   # Vulnerability details  ## Impact  The `_depositToBentoBox` and `_depositFromUserToBentoBox` allow users to provide ETH to the router, which is later deposited to the `bento` contract for swapping other assets or providing liquidity. However, in these two functions, the input parameter does not represent the actual amount of ETH to deposit, and users have to calculate the actual amount and send it to the router, causing a back-run vulnerability if there are ETH left after the operation.  ## Proof of Concept  1. A user wants to swap ETH to DAI. He calls `exactInputSingleWithNativeToken` on the router with the corresponding parameters and `params.amountIn` being 10. Before calling the function, he calculates `bento.toAmount(wETH, 10, true) = 15` and thus send 15 ETH to the router. 2. However, at the time when his transaction is executed, `bento.toAmount(wETH, amount, true)` becomes to `14`, which could happen if someone calls `harvest` on `bento` to update the `elastic` value of the `wETH` token. 3. As a result, only 14 ETH is transferred to the pool, and 1 ETH is left in the router. Anyone could back-run the user's transaction to retrieve the remaining 1 ETH from the router by calling the `refundETH` function.  Referenced code: [TridentRouter.sol#L318-L351](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L318-L351)  ## Recommended Mitigation Steps  Directly push the remaining ETH to the sender to prevent any ETH left in the router.  
# Handle  broccoli   # Vulnerability details  ## Impact  An attacker can call the `bento.harvest` function during the callback function of a flash swap of the `HybridPool` to reduce the number of input tokens that he has to pay to the pool, as long as there is any unrealized profit in the strategy contract of the underlying asset.  ## Proof of Concept  1. The `HybridPool` accounts for the reserve and balance of the pool using the `bento.toAmount` function, which represents the actual amount of assets that the pool owns instead of the relative share. The value of `toAmount` could increase or decrease if the `bento.harvest` function is called (by anyone), depending on whether the strategy contract earns or loses money. 2. Supposing that the DAI strategy contract of `Bento` has a profit not accounted for yet. To account for the profit, anyone could call `harvest` on `Bento` with the corresponding parameters, which, as a result, increases the `elastic` of the DAI token. 3. Now, an attacker wants to utilize the unrealized profit to steal funds from a DAI-WETH hybrid pool. He calls `flashSwap` to initiate a flash swap from WETH to DAI. First, the pool transfers the corresponding amount of DAI to him, calls the `tridentSwapCallback` function on the attacker's contract, and expects that enough DAI is received at the end. 4. During the `tridentSwapCallback` function, the attacker calls `bento.harvest` to realize the profit of DAI. As a result, the pool's `bento.toAmount` increases, and the amount of DAI that the attacker has to pay to the pool is decreased. The attacker could get the same amount of ETH but paying less DAI by exploiting this bug.  Referenced code: [HybridPool.sol#L218-L220](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L218-L220) [HybridPool.sol#L249-L250](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L249-L250) [HybridPool.sol#L272-L285](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L272-L285) [BentoBoxV1Flat.sol#L1105](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L1105) [BentoBoxV1Flat.sol#L786-L792](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L786-L792) [BentoBoxV1Flat.sol#L264-L277](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L264-L277)  ## Recommended Mitigation Steps  Consider not using `bento.toAmount` to track the reservers and balances, but use `balanceOf` instead (as done in the other two pools).   
# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeSingleOutGivenPoolIn` function of `IndexPool` uses the raw multiplication (i.e., `*`) to calculate the `zaz` variable. However, since both `(BASE - normalizedWeight)` and `_swapFee` are in `WAD`, the `_mul` function should be used instead to calculate the correct value of `zaz`. Otherwise, `zaz` would be `10 ** 18` times larger than the expected value and causes an integer underflow when calculating `amountOut`. The incorrect usage of multiplication prevents anyone from calling the function successfully.  ## Proof of Concept  Referenced code: [IndexPool.sol#L282](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L282)   ## Recommended Mitigation Steps  Change `(BASE - normalizedWeight) * _swapFee` to `_mul((BASE - normalizedWeight), _swapFee)`.  
# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeSingleOutGivenPoolIn` function of `IndexPool` uses the `_pow` function to calculate `tokenOutRatio` with the exponent in `WAD` (i.e., in 18 decimals of precision). However, the `_pow` function assumes that the given exponent `n` is not in `WAD`. (for example, `_pow(5, BASE)` returns `5 ** (10 ** 18)` instead of `5 ** 1`). The misuse of the `_pow` function could causes an integer overflow in the `_computeSingleOutGivenPoolIn` function and thus prevent any function from calling it.  ## Proof of Concept  Referenced code: [IndexPool.sol#L279](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L279)   ## Recommended Mitigation Steps  Change the `_pow` function to the `_compute` function, which supports exponents in `WAD`.  
# Handle  0xsanson   # Vulnerability details  ## Impact In HybridPool.sol, functions `_getY` and `_getYD` are identical (only differences are variables' names), and only `_getY` is used in the contract.  Since these functions are supposed to mimic those of Curve, it would make more sense to follow their naming conventions. In particular, `_getYD` correctly mimics Curve's `_get_y_D` ([ref](https://github.com/curvefi/curve-contract/blob/master/contracts/pool-templates/base/SwapTemplateBase.vy#L614)), while `_getY` does not mimic Curve's `_get_y` ([ref](https://github.com/curvefi/curve-contract/blob/master/contracts/pool-templates/base/SwapTemplateBase.vy#L379)).  ## Recommended Mitigation Steps Consider eliminating `_getY` and using `_getYD` instead in the contract.  
# Handle  tensors   # Vulnerability details  Throughout the code function selectors are often used instead of interfaces.  It is considered best practice to use interfaces instead of selectors for code readability.  
# Handle  tensors   # Vulnerability details  Constants of form 10**X can be rewritten as 1eX and this will save gas.  
# Handle  hack3r-0m   # Vulnerability details  https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/libraries/MathUtils.sol#L22 the difference is computed incorrectly when a > b.  As it only used in within1 function, scope narrows down to where `difference(a, b) <= 1;` is exploitable.  cases where `difference(a, b) <= 1` should be true but is reported false: - where b = a-1 (returned value is type(uint256).max)  cases where `difference(a, b) <= 1` should be false but is reported true: - where a = type(uint256).max and b = 0, it returns 1 but it should ideally return type(uint256).max  within1 is used at the following locations: - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L359 - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L383 - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L413  It is possible to decrease the denominator and increase the value of the numerator (when calculating y) using constants and input to make within1 fail  Mitigation:  Add `else` condition to mitigate it.  ``` unchecked {           if (a > b) {               diff = a - b;           }           else {               diff = b - a;              }       } ```  (re-submitting this issue after withdrawing past one since I forgot to add more  details and POC)  
# Handle  WatchPug   # Vulnerability details  Cache storage variable in the stack can save gas.  For instance:  https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L140-L155  `outRecord.reserve` is accessed 2 times.   https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L158-L179 https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L182-L205  `inRecord.reserve` is accessed 3 times.  
# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  https://github.com/sushiswap/trident/blob/master/contracts/TridentRouter.sol#L214-L234  - minWithdrawals.length - withdrawnLiquidity.length  https://github.com/sushiswap/trident/blob/master/contracts/TridentRouter.sol#L274  - tokenInput.length  https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L114-L136  - tokens.length  
# Handle  hrkrshnn   # Vulnerability details  ## Consider avoiding low level calls to MasterDeployer  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/ConstantProductPool.sol#L64)  The constructor uses low-level calls to the master deployer. It is more idiomatic to rely on high level solidity to deal with the calls. The difference would be additional checks on whether there is code at the specified address (additional `100` gas) and automatically performing the ABI decoding (may actually be more efficient than the manual implementation.) (Note that this call will still be `staticcall`, since `barFee` is a view function in the interface.)  Example:  ``` diff modified   contracts/pool/ConstantProductPool.sol @@ -61,7 +61,7 @@ contract ConstantProductPool is IPool, TridentERC20 {          require(_token1 != address(this), "INVALID_TOKEN");          require(_swapFee <= MAX_FEE, "INVALID_SWAP_FEE");  -        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector)); +        barFee = IMasterDeployer(_masterDeployer).barFee();          (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));          (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));  @@ -72,7 +72,6 @@ contract ConstantProductPool is IPool, TridentERC20 {          unchecked {              MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;          } -        barFee = abi.decode(_barFee, (uint256));          barFeeTo = abi.decode(_barFeeTo, (address));          bento = abi.decode(_bento, (address));          masterDeployer = _masterDeployer; ```   
# Handle  hrkrshnn   # Vulnerability details  ## Use `calldata` instead of `memory` for function parameters  In some cases, having function arguments in `calldata` instead of `memory` is more optimal.  Consider the following generic example:  ``` solidity contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above example, the dynamic array `arr` has the storage location `memory`. When the function gets called externally, the array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). And during the for loop, `arr[i]` accesses the value in memory using a `mload`. However, for the above example this is inefficient. Consider the following snippet instead:  ``` solidity contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  **Gas savings**: In the former example, the ABI decoding begins with copying value from `calldata` to `memory` in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  *In short*, use `calldata` instead of `memory` if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from `memory` to `calldata` may cause "unimplemented feature error". This can be avoided by using a newer (`0.8.*`) Solidity compiler.  ### Examples  ****Note****: The following pattern is prevalent in the codebase:  ``` solidity function f(bytes memory data) external {     (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to `bytes calldata` will decrease the gas. The total savings for this change across all such uses would be *quite significant.*  Examples:  ``` text ./contracts/examples/PoolFactory.sol:15:    function deployPool(bytes memory _deployData) external override returns (address) { ./contracts/examples/PoolTemplate.sol:12:    constructor(bytes memory _data) { ./contracts/flat/BentoBoxV1Flat.sol:603:    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) { ./contracts/pool/HybridPoolFactory.sol:13:    function deployPool(bytes memory _deployData) external returns (address pool) { ./contracts/pool/IndexPoolFactory.sol:13:    function deployPool(bytes memory _deployData) external returns (address pool) { ./contracts/pool/franchised/FranchisedConstantProductPool.sol:54:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/franchised/FranchisedHybridPool.sol:60:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/franchised/FranchisedIndexPool.sol:61:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/HybridPool.sol:60:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/ConstantProductPoolFactory.sol:13:    function deployPool(bytes memory _deployData) external returns (address pool) { ./contracts/pool/ConstantProductPool.sol:54:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/IndexPool.sol:61:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/utils/TridentHelper.sol:143:    function getSelector(bytes memory _data) internal pure returns (bytes4 sig) { ```  Other examples:  1.  <https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L174> 2.  <https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L218>   
# Handle  hrkrshnn   # Vulnerability details  ## Consider putting some parts of `_div` in unchecked  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L335)  ``` diff modified   contracts/pool/IndexPool.sol @@ -332,7 +332,8 @@ contract IndexPool is IPool, TridentERC20 {       function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {          uint256 c0 = a * BASE; -        uint256 c1 = c0 + (b / 2); +        unchecked { uint256 tmp =  b / 2; } +        uint256 c1 = c0 + tmp;          c2 = c1 / b;      } ```  Looking at the optimized assembly generated, the unchecked version doesn't seem to have the additional check for division by zero. I'm not entirely sure why, but my guess is because of inlining. Also consider replacing the division by inline assembly.  ``` solidity uint tmp; assembly {     tmp := div(b, 2) } uint256 c1 = c0 + tmp; ```  The change avoids an `if` condition which checks if the divisor is zero, which the optimizer is currently unable to optimize out. The gas savings would be around 16 (reduces a `jumpi`, `push 0` and `dupN`). Since the `_div` function is called from throughout the code (also present in other contracts), this may be worth considering, although I admit this might be too much of a micro-optimization.   
# Handle  hrkrshnn   # Vulnerability details  ## Caching a storage load in TridentERC20  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/TridentERC20.sol#L76)  This avoids an unnecessary `sload`.  ``` diff modified   contracts/pool/TridentERC20.sol @@ -73,8 +73,9 @@ abstract contract TridentERC20 {          address recipient,          uint256 amount      ) external returns (bool) { -        if (allowance[sender][msg.sender] != type(uint256).max) { -            allowance[sender][msg.sender] -= amount; +        uint _allowance = allowance[sender][msg.sender]; +        if (_allowance != type(uint256).max) { +            allowance[sender][msg.sender] = _allowance - amount;          }          balanceOf[sender] -= amount;          // @dev This is safe from overflow - the sum of all user ```   
# Handle  hrkrshnn   # Vulnerability details  ## Caching the storage read to `tokens.length`  Ignoring the caching for the for-loop condition (see my other issue "Caching the length in for loops"), this would save an additional `sload`, around `100` gas.  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L129).  ``` diff modified   contracts/pool/IndexPool.sol @@ -121,12 +121,12 @@ contract IndexPool is IPool, TridentERC20 {          (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));           uint256 ratio = _div(toBurn, totalSupply); -        withdrawnAmounts = new TokenAmount[](tokens.length); +        uint length = tokens.length; +        withdrawnAmounts = new TokenAmount[](length);           _burn(address(this), toBurn);  -        for (uint256 i = 0; i < tokens.length; i++) { +        for (uint256 i = 0; i < length; i++) {              address tokenOut = tokens[i];              uint256 balance = records[tokenOut].reserve;              uint120 amountOut = uint120(_mul(ratio, balance)); ```   
# Handle  hrkrshnn   # Vulnerability details  ## Caching the length in for loops  Consider a generic example of an array `arr` and the following loop:  ``` solidity for (uint i = 0; i < arr.length; i++) {     // do something that doesn't change arr.length } ```  In the above case, the solidity compiler will always read the length of the array during each iteration. That is,  1.  if it is a `storage` array, this is an extra `sload` operation (100     additional extra gas     ([EIP-2929](https://eips.ethereum.org/EIPS/eip-2929)) for each     iteration except for the first), 2.  if it is a `memory` array, this is an extra `mload` operation (3     additional gas for each iteration except for the first), 3.  if it is a `calldata` array, this is an extra `calldataload`     operation (3 additional gas for each iteration except for the first)  This extra costs can be avoided by caching the array length (in stack):  ``` solidity uint length = arr.length; for (uint i = 0; i < length; i++) {     // do something that doesn't change arr.length } ```  In the above example, the `sload` or `mload` or `calldataload` operation is only called once and subsequently replaced by a cheap `dupN` instruction. Even though `mload`, `calldataload` and `dupN` have the same gas cost, `mload` and `calldataload` needs an additional `pushX value` to put the offset in the stack, i.e., an extra 3 gas.  This optimization is especially important if it is a storage array or if it is a lengthy for loop. Note: this especially relevant for the IndexPool contract.  Note that the Yul based optimizer (not enabled by default; only relevant if you are using `--experimental-via-ir` or the equivalent in standard JSON) can sometimes do this caching automatically. However, this is likely not the case in your project. [Reference](https://forum.soliditylang.org/t/solidity-team-ama-2-on-wed-10th-of-march-2021/152/15?u=hrkrshnn).  ### Examples  ``` text ./contracts/flat/BentoBoxV1Flat.sol:626:        for (uint256 i = 0; i < calls.length; i++) { ./contracts/pool/PoolDeployer.sol:34:            for (uint256 i; i < tokens.length - 1; i++) { ./contracts/pool/PoolDeployer.sol:36:                for (uint256 j = i + 1; j < tokens.length; j++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:73:        for (uint256 i = 0; i < _tokens.length; i++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:104:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:132:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/franchised/WhiteListManager.sol:105:        for (uint256 i = 0; i < merkleProof.length; i++) { ./contracts/pool/IndexPool.sol:71:        for (uint256 i = 0; i < _tokens.length; i++) { ./contracts/pool/IndexPool.sol:102:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/IndexPool.sol:129:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/utils/TridentHelper.sol:27:        for (uint256 i = 0; i < data.length; i++) { ./contracts/TridentRouter.sol:65:        for (uint256 i; i < params.path.length; i++) { ./contracts/TridentRouter.sol:83:        for (uint256 i; i < path.length; i++) { ./contracts/TridentRouter.sol:123:        for (uint256 i; i < params.path.length; i++) { ./contracts/TridentRouter.sol:139:        for (uint256 i; i < params.initialPath.length; i++) { ./contracts/TridentRouter.sol:149:        for (uint256 i; i < params.percentagePath.length; i++) { ./contracts/TridentRouter.sol:157:        for (uint256 i; i < params.output.length; i++) { ./contracts/TridentRouter.sol:181:        for (uint256 i; i < tokenInput.length; i++) { ./contracts/TridentRouter.sol:223:        for (uint256 i; i < minWithdrawals.length; i++) { ./contracts/TridentRouter.sol:225:            for (; j < withdrawnLiquidity.length; j++) { ./contracts/TridentRouter.sol:274:        for (uint256 i; i < tokenInput.length; i++) { ```   
# Handle  cmichel   # Vulnerability details  The `HybridPool._computeLiquidityFromAdjustedBalances` function should return early if `s == 0` as it will always return zero. Currently, it still performs an expensive loop iteration.  ```solidity if (s == 0) {   // gas: should do an early return here   computed = 0;   // return 0; } ```  ## Recommended Mitigation Steps Return early with a value of `0` if `s == 0`.   
# Handle  cmichel   # Vulnerability details  The `HybridPool.burn` function subtracts some computation from `balance0`/`balance1`, but the result is never used.  ```solidity balance0 -= _toShare(token0, amount0); balance1 -= _toShare(token1, amount1); ```  ## Recommended Mitigation Steps Unless it is used as an underflow check, the computation should be removed the result is not used.   
# Handle  cmichel   # Vulnerability details  The `HybridPool`'s reserves are stored as Bento "amounts" (not Bento shares) in `_updateReserves` because `_balance()` converts the current share balance to amount balances. However, when retrieving the `reserve0/1` storage fields in `_getReserves`, they are converted to amounts a second time.  ## Impact The `HybridPool` returns wrong reserves which affects all minting/burning and swap functions. They all return wrong results making the pool eventually economically exploitable or leading to users receiving less tokens than they should.  ## POC Imagine the current Bento amount / share price being `1.5`. The pool's Bento _share_ balance being `1000`. `_updateReserves` will store a reserve of `1.5 * 1000 = 1500`. When anyone trades using the `swap` function, `_getReserves()` is called and multiplies it by `1.5` again, leading to using a reserve of 2250 instead of 1500. A higher reserve for the output token leads to receiving more tokens as the swap output. Thus the pool lost tokens and the LPs suffer this loss.  ## Recommended Mitigation Steps Make sure that the reserves are in the correct amounts.   
# Handle  cmichel   # Vulnerability details  The `HybridPool.flashSwap` function skips the `tridentSwapCallback` callback call if `data.length == 0`.  ## Impact It should never skip the callback, otherwise the `flashSwap` function is useless. Note that this behavior of the `HybridPool` is not in alignment with the `flashSwap` behavior of all other pools that indeed always call the callback.  ## Recommended Mitigation Steps Always make the call to `ITridentCallee(msg.sender).tridentSwapCallback(data);`, regardless of the `data` variable.  
# Handle  cmichel   # Vulnerability details  The `HybridPool.flashSwap` function sends the entire trade fees `fee` to the `barFeeTo`. It should only send `barFee * fee` to the `barFeeTo` address.  ## Impact LPs are not getting paid at all when this function is used. There is no incentive to provide liquidity.  ## Recommended Mitigation Steps The `flashSwap` function should use the same fee mechanism as `swap` and only send `barFee * fee / MAX_FEE` to the `barFeeTo`. See `_handleFee` function.   
# Handle  cmichel   # Vulnerability details  The `ConstantProductPool.burnSingle` function is basically a `burn` followed by a `swap` and must therefore act the same way as calling these two functions sequentially.  The token amounts to redeem (`amount0`, `amount1`) are computed on the **balance** (not the reserve). However, the swap amount is then computed on the **reserves** and not the balance. The `burn` function would have updated the `reserve` to the balances and therefore `balance` should be used here:  ```solidity amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1); ```  > ⚠️ The same issue occurs in the `HybridPool.burnSingle`.  ## Impact For a burn, usually the `reserve` should equal the `balance`, however if any new tokens are sent to the contract and `balance > reserve`, this function will return slightly less swap amounts.  ## Recommended Mitigation Steps Call `_getAmountOut` with the balances instead of the reserves: `_getAmountOut(amount0, balance0 - amount0, balance1 - amount1)`   
# Handle  cmichel   # Vulnerability details  The `ConstantProductPool` computes optimal balanced LP using `_nonOptimalMintFee`, which performs something like a swap. The returned swap fees should be included in the "`k`" computation as `_handleFees` uses the growth in `k` to estimate the swap fees.  ```solidity // should not reduce fee0 and fee1 uint256 computed = TridentMath.sqrt((balance0 - fee0) * (balance1 - fee1)); ```  > ⚠️ The same issue occurs in the `HybridPool.mint`.  ## Impact The non-optimal mint swap fees are not taken into account.  ## Recommended Mitigation Steps Compute `sqrt(k)` on the `balance0 * balance1` without deducting the swap fees.   
# Handle  cmichel   # Vulnerability details  The `ConstantProductPool.getAmountOut` function does not verify that `tokenIn == token1` in the `else` branch. This is done everywhere else though (see `swap` and `flashSwap`) and should be done here as well.  ## Impact The function can be called with a token that is not any of the pool tokens.  ## Recommended Mitigation Steps Add the missing check.  
# Handle  cmichel   # Vulnerability details  The `TridentHelper.withdrawFromWETH` (used in `TridentRouter.unwrapWETH`) function performs a low-level call to `WETH.withdraw(amount)`.  It then checks if the return `data` length is more or equal to `32` bytes, however `WETH.withdraw` returns `void` and has a return value of `0`. Thus, the function always reverts even if `success == true`.  ```solidity function withdrawFromWETH(uint256 amount) internal {     // @audit WETH.withdraw returns nothing, data.length always zero. this always reverts     require(success && data.length >= 32, "WITHDRAW_FROM_WETH_FAILED"); } ```  ## Impact The `unwrapWETH` function is broken and makes all transactions revert. Batch calls to the router cannot perform any unwrapping of WETH.  ## Recommended Mitigation Steps Remove the `data.length >= 32` from the require and only check if `success` is true.  
# Handle  cmichel   # Vulnerability details  The `IndexPool.constructor` function already mints `INIT_POOL_SUPPLY = 100 * 1e18 = 1e20` LP tokens to the zero address.  When trying to use the pool, someone has to provide the actual initial reserve tokens in `mint`. On the first `mint`, the pool reserves are zero and the token amount required to mint is just this `ratio` itself: `uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;`  Note that the `amountIn` is **independent of the token** which does not make much sense. This implies that all tokens must be provided in equal "raw amounts", regardless of their decimals and value.  ## POC #### Issue 1 Imagine I want to create a DAI/WBTC pool. If I want to initialize the pool with 100$ of DAI, `amountIn = ratio` needs to be `100*1e18=1e20` as DAI has 18 decimals. However, I now also need to supply `1e20` of WBTC (which has 8 decimals) and I'd need to pay `1e20/1e8 * priceOfBTC`, over a quadrillion dollars to match it with the 100$ of DAI.  #### Issue 2 Even in a pool where all tokens have the same decimals and the same value, like `USDC <> USDT`, it leads to issues: - Initial minter calls `mint` with `toMint = 1e20` which sets `ratio = 1e20 * 1e18 / 1e20 = 1e18` and thus `amountIn = 1e18` as well. The total supply increases to `2e20`. - Second minter needs to pay **less** tokens to receive the same amount of `1e18` LP tokens as the first minter. This should never be the case. `toMint = 1e20` => `ratio = 1e20 * 1e18 / 2e20 = 0.5e18`. Then `amountIn = ratio * reserve / 1e18 = 0.5*reserve = 0.5e18`. They only pay half of what the first LP provider had to pay.  ## Impact It's unclear why it's assumed that the pool's tokens are all in equal value - this is _not_ a StableSwap-like pool.  Any pool that uses tokens that don't have the same value and share the same decimals cannot be used because initial liquidity cannot be provided in an economically justifiable way.  It also leads to issues where the second LP supplier has to pay **less tokens** to receive the exact same amount of LP tokens that the initial minter receives. They can steal from the initial LP provider by burning these tokens again.  ## Recommended Mitigation Steps Do not mint the initial token supply to the zero address in the constructor.  Do it like Uniswap/Balancer and let the first liquidity provider provide arbitrary token amounts, then mint the initial pool supply. If `reserve == 0`, `amountIn` should just take the pool balances that were transferred to this account.  In case the initial mint to the zero address in the constructor was done to prevent the "Uniswap-attack" where the price of a single wei of LP token can be very high and price out LPs, send a small fraction of this initial LP supply (~1000) to the zero address **after** it was minted to the first supplier in `mint`.   
# Handle  broccoli   # Vulnerability details  ## Impact  TridentRouter is easy to fail when trying to provide liquidity to an index pool.  Users would not get extra lp if they are not providing lp at the pool's spot price. It's the same design as uniswap v2. However, uniswap's v2 handle's the dirty part.   [UniswapV2Router02.sol#L61-L76](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76) Users would not lose tokens if they use the router.  However, the router wouldn't stop users from transferring extra tokens. [TridentRouter.sol#L168-L190](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L168-L190)  Second, the price would possibly change when the transaction is confirmed. This would be reverted in the index pool.   Users would either transfer extra tokens or fail. I consider this is a medium-risk issue.   ## Proof of Concept  [TridentRouter.sol#L168-L190](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L168-L190)  A possible scenario:  There's a BTC/USD pool. BTC = 50000 USD. 1. A user sends a transaction to transfer 1 BTC and 50000 USD. 2. After the user send a transaction, a random bot buying BTC with USD. 3. The transaction at step 1 is mined. Since the BTC price is not 50000 USD, the transaction fails.   ## Tools Used  None  ## Recommended Mitigation Steps  Please refer to the uniswap v2 router. [UniswapV2Router02.sol#L61-L76](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76)  The router should calculate the optimal parameters for users.    
# Handle  0xRajeev   # Vulnerability details  ## Impact  Constants MAX_FEE_SQUARE and E18 are declared but never used. Unused constants could indicate missing logic or redundant code. In this case, they are likely to be redundant code that can be removed.  ## Proof of Concept  https://github.com/sushiswap/trident/blob/504e2e2f3929175eb7adc73844c381d5174e1c03/contracts/pool/ConstantProductPool.sol#L25  https://github.com/sushiswap/trident/blob/504e2e2f3929175eb7adc73844c381d5174e1c03/contracts/pool/ConstantProductPool.sol#L26  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Evaluate the use of the declared constants or remove them.  
# Handle  GreyArt   # Vulnerability details  ## Impact  Gas optimisation. Casting something of uint256 to uint32 has the same effect as mod since it will wrap around when it overflows. You need to ensure that unchecked math is used otherwise it will revert.  ## Recommended Mitigation Steps  [Line 294 of ConstantProductPool.sol](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/ConstantProductPool.sol#L294)  ```jsx function _update(         uint256 balance0,         uint256 balance1,         uint112 _reserve0,         uint112 _reserve1,         uint32 _blockTimestampLast     ) internal {         require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, "OVERFLOW");         if (blockTimestampLast == 0) {             // @dev TWAP support is disabled for gas efficiency.             reserve0 = uint112(balance0);             reserve1 = uint112(balance1);         } else {       unchecked { // changes starts here        uint32 blockTimestamp = uint32(block.timestamp);       } // changes end here             ...         }         emit Sync(balance0, balance1);     } ```  
# Handle  GreyArt   # Vulnerability details  ### Impact  L102: `_mint(address(0), MINIMUM_LIQUIDITY);` should be shifted after the if / else block to L110 because of further checks done in L106, and L108-L109.  This would help save gas should the checks mentioned fail.  ### Recommended Mitigation Steps  ```jsx if (msg.sender == migrator) {   liquidity = IMigrator(migrator).desiredLiquidity();   require(liquidity != 0 && liquidity != type(uint256).max, "BAD_DESIRED_LIQUIDITY"); } else {   require(migrator == address(0), "ONLY_MIGRATOR");   liquidity = computed - MINIMUM_LIQUIDITY; } _mint(address(0), MINIMUM_LIQUIDITY); ```  
# Handle  GreyArt   # Vulnerability details  ### Impact  A mint fee is applied whenever unbalanced liquidity is added, because it is akin to swapping the excess token amount for the other token.  However, the current implementation distributes the minted fee to the minter as well (when he should be excluded). It therefore acts as a rebate of sorts.  As a result, it makes adding and removing liquidity as opposed to swapping directly (negligibly) more desirable. An example is given below using the Constant Product Pool to illustrate this point. The Hybrid pool exhibits similar behaviour.  ### Proof of Concept  1. Initialize the pool with ETH-USDC sushi pool amounts. As of the time of writing, there is roughly 53586.556 ETH and 165143020.5295 USDC. 2. Mint unbalanced LP with 5 ETH (& 0 USDC). This gives the user `138573488720892 / 1e18` LP tokens. 3. Burn the minted LP tokens, giving the user 2.4963 ETH and 7692.40 USDC. This is therefore equivalent to swapping 5 - 2.4963 = 2.5037 ETH for 7692.4044 USDC. 4. If the user were to swap the 2.5037 ETH directly, he would receive 7692.369221 (0.03 USDC lesser).  ### Recommended Mitigation Steps  The mint fee should be distributed to existing LPs first, by incrementing `_reserve0` and `_reserve1` with the fee amounts. The rest of the calculations follow after.  ConstantProductPool  ```jsx (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1); // increment reserve amounts with fees _reserve0 += uint112(fee0); _reserve1 += uint112(fee1); unchecked {     _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply); } uint256 computed = TridentMath.sqrt(balance0 * balance1); ... kLast = computed; ```  HybridPool  ```jsx (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1); // increment reserve amounts with fees _reserve0 += uint112(fee0); _reserve1 += uint112(fee1); uint256 newLiq = _computeLiquidity(balance0, balance1); ... ```  
# Handle  broccoli   # Vulnerability details  ## Impact  When an lp provider deposits an imbalance amount of token, a swap fee is applied. HybridPool uses the same `_nonOptimalMintFee` as `constantProductPool`; however, since two pools use different AMM curve, the ideal balance is not the same.  ref: [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337)  Stable swap Pools are designed for 1B+ TVL. Any issue related to pricing/fee is serious. I consider this is a high-risk issue  ## Proof of Concept  [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337)  [HybridPool.sol#L425-L441](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L425-L441)  ## Tools Used  None  ## Recommended Mitigation Steps Calculate the swapping fee based on the stable swap curve. Please refer to [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337).  
# Handle  broccoli   # Vulnerability details  ## Impact  In the IndexPool contract, pow is used in calculating price. [IndexPool.sol#L255-L266](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L255-L266) However, Pow is easy to cause overflow. If the `weightRatio` is large (e.g. 10), there's always overflow.  Lp providers can still provide liquidity to the pool where no one can swap. All pools need to redeploy. I consider this a high-risk issue.   ## Proof of concept  It's easy to trigger this bug by deploying a 1:10 IndexPool.  ```python     deployed_code = encode_abi(["address[]","uint136[]","uint256"], [         (link.address, dai.address),         (10**18, 10 * 10**18),         10**13     ])     tx_hash = master_deployer.functions.deployPool(index_pool_factory.address, deployed_code).transact() ```  Transactions would be reverted when buying `link` with `dai`. ## Tools Used  None  ## Recommended Mitigation Steps  The `weightRatio` is an 18 decimals number. It should be divided by `(BASE)^exp`. The scale in the contract is not consistent. Recommend the dev to check all the scales/ decimals.   
# Handle  gpersoon   # Vulnerability details  ## Impact The function _update() of ConstantProductPool.sol verifies if blockTimestampLast == 0. The value of blockTimestampLast is also passed in the parameter _blockTimestampLast  (note: with extra _ ) So _blockTimestampLast could also be used, which saves a bit of gas.  ## Proof of Concept https://github.com/sushiswap/trident/blob/master/contracts/pool/ConstantProductPool.sol#L264  function _update(...        uint32 _blockTimestampLast) internal {         ...         if (blockTimestampLast == 0) {    // could also use _blockTimestampLast  ## Tools Used  ## Recommended Mitigation Steps replace    if (blockTimestampLast == 0) {    with    if (_blockTimestampLast == 0) {      
