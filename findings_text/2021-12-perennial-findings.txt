# Handle  leastwood   # Vulnerability details  ## Impact  The `maintenanceInvariant` modifier in `Collateral` aims to check if a user meets the margin requirements to withdraw collateral by checking its current and next maintenance. `maintenanceInvariant` inevitably calls `AccountPosition.maintenance` which uses the oracle's price to calculate the margin requirements for a given position. Hence, if the oracle has not synced in a long time, `maintenanceInvariant` may end up utilising an outdated price for a withdrawal. This may allow a user to withdraw collateral on an undercollaterized position.  ## Proof of Concept  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L67-L76 ``` function withdrawTo(address account, IProduct product, UFixed18 amount) notPaused collateralInvariant(msg.sender, product) maintenanceInvariant(msg.sender, product) external {     _products[product].debitAccount(msg.sender, amount);     token.push(account, amount);      emit Withdrawal(msg.sender, product, amount); } ```  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L233-L241 ``` modifier maintenanceInvariant(address account, IProduct product) {     _;      UFixed18 maintenance = product.maintenance(account);     UFixed18 maintenanceNext = product.maintenanceNext(account);      if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))         revert CollateralInsufficientCollateralError(); } ```  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/types/position/AccountPosition.sol#L71-L75 ```     function maintenanceInternal(Position memory position, IProductProvider provider) private view returns (UFixed18) {         Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion());         UFixed18 notionalMax = Fixed18Lib.from(position.max()).mul(oraclePrice).abs();         return notionalMax.mul(provider.maintenance());     } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding `settleForAccount(msg.sender)` to the `Collateral.withdrawTo` function to ensure the most up to date oracle price is used when assessing an account's margin requirements.  
# Handle  hubble   # Vulnerability details  ## Impact Incentivizer.updateFee expects a value between UFixed18Lib.ZERO and UFixed18Lib.ONE. When the incentive fee is updated outside of this range, the program creation fails and the product owners would not be able to add new Programs to the Product.  ## Proof of Concept Step 1. Update incentive fee File: /protocol/contracts/incentivizer/Incentivizer.sol Line 368     function updateFee(UFixed18 newFee) onlyOwner external { Line 369             fee = newFee; ...  Step 2. Create new Program File: /protocol/contracts/incentivizer/Incentivizer.sol Line 59    function create(ProgramInfo calldata info)  File: /protocol/contracts/incentivizer/types/ProgramInfo.sol Line 55         Position memory amountAfterFee = info.amount.mul(UFixed18Lib.ONE.sub(fee)); ...  Note: Fails at line 55, whenever fee is greater than UFixedLive.ONE  ## Tools Used Manual code review  ## Recommended Mitigation Steps Implement Range check   File: /protocol/contracts/incentivizer/Incentivizer.sol Line 368     function updateFee(UFixed18 newFee) onlyOwner external { Line 369          if(newFee.gte(UFixed18Lib.ONE)) revert NewError("newFee should be less than UFixed18Lib.ONE"); Line 370          fee = newFee;  Note: Range check at line 369  
# Handle  0x0x0x   # Vulnerability details  In case `oracleVersionCurrent != oracleVersionPreSettle`,  the following line  `accumulated = accumulated.sub(Fixed18Lib.from(_positions[account].settle(provider, oracleVersionPreSettle)));` ([https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/Product.sol#L136](https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/Product.sol#L136))  doesn't make any change. This line can be at the beginning of the `if` statement below to save gas.  
# Handle  0x0x0x   # Vulnerability details  At `Product.sol#closeAll` cache `_position[account]` to save gas.   In the first line of the function `_position[account]` is used twice and gas can be saved by caching it.  
# Handle  cmichel   # Vulnerability details  Certain functions in the `Fixed18` contract perform multiplications by `ONE` or `NEG_ONE` before diving by it again which leads to issues that these functions revert for all values `> MAX_UINT256 / ONE`, but they should not.  ```solidity function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {     if (s > 0) return from(m);     // @audit cannot convert large values because (m * NEG_ONE) might overflow     if (s < 0) return mul(from(m), NEG_ONE);     return ZERO; }  function abs(Fixed18 a) internal pure returns (UFixed18) {     // @audit cannot get abs value if multiplication of a * -1e18 /1e18 overflows. why not unwrap => unary minus     return sign(a) == -1 ? UFixed18Lib.from(mul(a, NEG_ONE)) : UFixed18Lib.from(a); } ```  ## Recommendation Change the implementation to not perform the useless `* 1e18 / 1e18` computations to cover the entire input range. Consider using a typecast `int256(UFixed18.unwrap(m))` after checking the range instead of doing `* NEG_ONE / 1e18`   
# Handle  cmichel   # Vulnerability details  Some fee parameters of functions are not checked for invalid values: - `Collateral.updateLiquidationFee`: The `newLiquidationFee` should be less than 100% - `Factory.updateFee`: The `newFee` should be less than 100%  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  ye0lde   # Vulnerability details  ## Impact Transfer amount can be checked for > 0 before calling `push' which makes a call to `safeTransfer`. This can save gas by avoiding the external call.  ## Proof of Concept  The transfer is here: https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L237-L238   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Check that transfer amount > 0 before L#237-238 are executed.  Consider checking for `amount` > 0 in these functions: https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L51 https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L68 https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L85  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `provider`, `factory()` in `Product#settleInternal()`      https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L72-L100   - `provider`, `_accumulator` in `Product#settleAccountInternal()`      https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L123-L152   - `factory()` in `Collateral#settleProduct()`      https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/collateral/Collateral.sol#L131-L145  
# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style does not follow the best practices:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/collateral/Collateral.sol#L171-L173  ```solidity=171 function shortfall(IProduct product) public view returns (UFixed18) {     return _products[product].shortfall; } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L256-L258  ```solidity=256 function maintenance(address account) public view returns (UFixed18) {     return _positions[account].maintenance(provider); } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L266-L268  ```solidity=266 function maintenanceNext(address account) public view returns (UFixed18) {     return _positions[account].maintenanceNext(provider); } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/factory/Factory.sol#L259-L261  ```solidity=259 function treasury() public view returns (address) {     return treasury(0); } ```  
# Handle  WatchPug   # Vulnerability details  `newController.owner` should be validated to make sure the new owner's address is not `address(0)`.  Otherwise, if the owner mistakenly calls `updateController()` with improper inputs can result in all the `onlyOwner(controllerId)` methods being unaccessible.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/factory/Factory.sol#L103-L106  ```solidity=103 function updateController(uint256 controllerId, Controller memory newController) onlyOwner(controllerId) external {     _controllers[controllerId] = newController;     emit ControllerUpdated(controllerId, newController.owner, newController.treasury); } ```  
# Handle  WatchPug   # Vulnerability details  Caching the result of `_registry[product].length()` can save gas from unnecessary extra SLOAD, function call, and code execution, especially in for loops.  Instances include:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L144-L144  ```solidity=144 for (uint256 i; i < _registry[product].length(); i++) { ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L174-L174  ```solidity=174 for (uint256 i; i < _registry[product].length(); i++) { ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L190-L190  ```solidity=190 for (uint256 i; i < _registry[product].length(); i++) { ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L232-L242  ```solidity=232{234,238} function claimFee(Token18[] calldata tokens) notPaused external {     for(uint256 i; i < tokens.length; i++) {         Token18 token = tokens[i];         UFixed18 amount = fees[token];          fees[token] = UFixed18Lib.ZERO;         tokens[i].push(factory().treasury(), amount);          emit FeeClaim(token, amount);     } } ```  `tokens[i]` at L238 is already cached in the local variable `token` at L234, resuing the result instead of doing the subscript operation again can save gas.  ### Recommendation  Change  ```solidity tokens[i].push(factory().treasury(), amount); ```  to:  ```solidity token.push(factory().treasury(), amount); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L29-L29  ```solidity=29 uint256 private _decimalOffset; ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50{52} function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  `_decimalOffset` is only used at L52。  Therefore `_decimalOffset` can be defined as `int256` and avoid unnecessary `SafeCast.toInt256()`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L20-L20 ```solidity=20 IChainlinkFeed public feed; ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L29-L29 ```solidity=29 uint256 private _decimalOffset; ```  In `ChainlinkOracle.sol`, `feed` and `_decimalOffset` will never change, use immutable variables instead of storage variables can save gas.   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/ProductProviderBase.sol#L13-L13  ```solidity=13 IOracle public oracle; ```  In `ProductProviderBase.sol`, `oracle` will never change, use immutable variables instead of storage variables can save gas.  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas.  There are many times across the codebase that will perform two external calls to the provider to query the current `oraclePrice`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/types/position/AccountPosition.sol#L72-L72  ```solidity=72 Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion()); ```  Consider adding a new method to the provider and return the current `oraclePrice` directly can combine two external calls into one and save some gas.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50 function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  If `block.timestamp - timestampAtVersion[currentVersion()] < minDelay`, there is no need to call `feed.latestRoundData()`.  ### Recommendation  Change to:  ```solidity=50 function sync() public {     if (priceAtVersion.length == 0 || block.timestamp - timestampAtVersion[currentVersion()] >= minDelay ) {         (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();         Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));          if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {             priceAtVersion.push(price);             timestampAtVersion.push(timestamp);              emit Version(currentVersion(), timestamp, price);         }     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50 function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  On `ChainlinkOracle.sol`, we are using `latestRoundData`, but there is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:  - https://docs.chain.link/docs/historical-price-data/#historical-rounds - https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  ### Recommendation  Consider adding missing checks for stale data.   For example:  ```solidity (uint80 roundID, int256 feedPrice, , uint256 timestamp, uint80 answeredInRound) = feed.latestRoundData(); require(feedPrice > 0, "Chainlink price <= 0");  require(answeredInRound >= roundID, "Stale price"); require(timestamp != 0, "Round not complete"); ```  
# Handle  WatchPug   # Vulnerability details  When `isEther()`, `decimals` must be `18`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L118-L120  ```solidity=118 function decimals(Token18 self) internal view returns (uint8) {     return isEther(self) ? 18 : IERC20Metadata(Token18.unwrap(self)).decimals(); } ```  Therefore, in `Token18.sol#balanceOf()`, `fromTokenAmount()` is unnecessary when `isEther()`.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L137-L142  ```solidity=137 function balanceOf(Token18 self, address account) internal view returns (UFixed18) {     uint256 tokenAmount = isEther(self) ?         account.balance :         IERC20(Token18.unwrap(self)).balanceOf(account);     return fromTokenAmount(self, tokenAmount); } ```  Can be changed to:  ```solidity=137 function balanceOf(Token18 self, address account) internal view returns (UFixed18) {     return isEther(self) ?         UFixed18.wrap(account.balance) :         fromTokenAmount(self, IERC20(Token18.unwrap(self)).balanceOf(account)); } ```  
# Handle  WatchPug   # Vulnerability details  When `isEther()`, `decimals` must be `18`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L118-L120  ```solidity=118     function decimals(Token18 self) internal view returns (uint8) {         return isEther(self) ? 18 : IERC20Metadata(Token18.unwrap(self)).decimals();     } ```  Therefore, in `Token18.sol#push()`, `toTokenAmount()` is unnecessary when `isEther()`.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L51-L59  ```solidity=51 function push(     Token18 self,     address recipient,     UFixed18 amount ) internal {     isEther(self)         ? Address.sendValue(payable(recipient), toTokenAmount(self, amount))         : IERC20(Token18.unwrap(self)).safeTransfer(recipient, toTokenAmount(self, amount)); } ```  Can be changed to:  ```solidity=51 function push(     Token18 self,     address recipient,     UFixed18 amount ) internal {     isEther(self)         ? Address.sendValue(payable(recipient), UFixed18.unwrap(amount))         : IERC20(Token18.unwrap(self)).safeTransfer(recipient, toTokenAmount(self, amount)); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L151-L154  ```solidity=151 function toTokenAmount(Token18 self, UFixed18 amount) private view returns (uint256) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** uint256(decimals(self)), 10 ** 18);     return UFixed18.unwrap(amount.mul(conversion)); } ```  Can be changed to:  ```solidity=151 function toTokenAmount(Token18 self, UFixed18 amount) private view returns (uint256) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** uint256(decimals(self)), 1e18);     return UFixed18.unwrap(amount.mul(conversion)); } ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L163-L166  ```solidity=163 function fromTokenAmount(Token18 self, uint256 amount) private view returns (UFixed18) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** 18, 10 ** uint256(decimals(self)));     return UFixed18.wrap(amount).mul(conversion); } ```  Can be changed to:  ```solidity=163 function fromTokenAmount(Token18 self, uint256 amount) private view returns (UFixed18) {     UFixed18 conversion = UFixed18Lib.ratio(1e18, 10 ** uint256(decimals(self)));     return UFixed18.wrap(amount).mul(conversion); } ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/types/position/PrePosition.sol#L145-L156  ```solidity=145 function computeFee(PrePosition memory self, IProductProvider provider, uint256 toOracleVersion) internal view returns (UFixed18 positionFee) {     Fixed18 oraclePrice = provider.priceAtVersion(toOracleVersion);     Position memory positionDelta = self.openPosition.add(self.closePosition);      (UFixed18 makerNotional, UFixed18 takerNotional) = (         Fixed18Lib.from(positionDelta.maker).mul(oraclePrice).abs(),         Fixed18Lib.from(positionDelta.taker).mul(oraclePrice).abs()     );      positionFee = positionFee.add(makerNotional.mul(provider.safeMakerFee()));     positionFee = positionFee.add(takerNotional.mul(provider.safeTakerFee())); } ```  At L154, `positionFee = positionFee.add(makerNotional.mul(provider.safeMakerFee()));`  can be changed to `positionFee = makerNotional.mul(provider.safeMakerFee());` as `positionFee == 0`.  Futhermore, L154-155 can be combined into:  ```solidity positionFee = makerNotional.mul(provider.safeMakerFee()).add(     takerNotional.mul(provider.safeTakerFee()) ); ```  
# Handle  kenzo   # Vulnerability details  Every time an account is settled, if shortfall is created, due to a wrong calculation shortfall will double in size and add the new shortfall.  ## Impact Loss of funds: users won't be able to withdraw the correct amount of funds. Somebody would have to donate funds to resolve the wrong shortfall.  ## Proof of Concept We can see in the `settleAccount` of `OptimisticLedger` that self.shortfall ends up being self.shortfall+self.shortfall+newShortfall: [(Code ref)](https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/types/OptimisticLedger.sol#L63:#L74) ```     function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)     internal returns (UFixed18 shortfall) {         Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);          if (newBalance.sign() == -1) {             shortfall = self.shortfall.add(newBalance.abs());             newBalance = Fixed18Lib.ZERO;         }          self.balances[account] = newBalance.abs();         self.shortfall = self.shortfall.add(shortfall);     } ```  Additionally, you can add the following line to the "shortfall reverts if depleted" test in Collateral.test.js, line 190: ``` await collateral.connect(productSigner).settleAccount(userB.address, -50) ``` Previously the test product had 50 shortfall. Now we added 50 more, but the test will print that the actual shortfall is 150, and not 100 as it should be.  ## Recommended Mitigation Steps Move the setting of `self.shortfall` to inside the if function and change the line to: ``` self.shortfall = shortfall ```  
# Handle  0x1f8b   # Vulnerability details  ## Impact Lost the owner by human error.  ## Proof of Concept The modification process of an owner is a delicate process, since the governance of our contract and therefore of the project may be at risk, for this reason it is recommended to adjust the owner’s modification logic, to a logic that allows to verify that the new owner is in fact valid and does exist.  It's mandatory to create a logic of the owner’s modification where a new owner is proposed first, the owner accepts the proposal and, in this way, we make sure that there are no errors when writing the address of the new owner.   Source reference: - UOwnable.transferOwnership  ## Tools Used Manual review  ## Recommended Mitigation Steps Use an ACK method for approve the new owner.  
# Handle  robee   # Vulnerability details  Not verified address arguments of external/public functions is a low risk issue.  It's less severe for onlyOwner methods but for any other method it's crucial since the default address is 0.          Argument account of Collateral.depositTo is not verified to be != 0         Argument account of Collateral.withdrawTo is not verified to be != 0         Argument account of Collateral.liquidate is not verified to be != 0         Argument account of Collateral.settleAccount is not verified to be != 0         Argument account of Collateral.collateral is not verified to be != 0         Argument account of Collateral.liquidatable is not verified to be != 0         Argument account of Collateral.liquidatableNext is not verified to be != 0         Argument treasury_ of Factory.initialize is not verified to be != 0         Argument controllerTreasury of Factory.createController is not verified to be != 0         Argument newPauser of Factory.updatePauser is not verified to be != 0         Argument account of Incentivizer.syncAccount is not verified to be != 0         Argument account of Incentivizer.unclaimed is not verified to be != 0         Argument account of Incentivizer.latestVersion is not verified to be != 0         Argument account of Incentivizer.settled is not verified to be != 0         Argument account of Product.settleAccount is not verified to be != 0         Argument account of Product.closeAll is not verified to be != 0         Argument account of Product.maintenance is not verified to be != 0         Argument account of Product.maintenanceNext is not verified to be != 0         Argument account of Product.isClosed is not verified to be != 0         Argument account of Product.isLiquidating is not verified to be != 0         Argument account of Product.position is not verified to be != 0         Argument account of Product.pre is not verified to be != 0         Argument account of Product.latestVersion is not verified to be != 0         Argument recipient of MockToken18.push is not verified to be != 0         Argument recipient of MockToken18.push is not verified to be != 0         Argument benefactor of MockToken18.pull is not verified to be != 0         Argument benefactor of MockToken18.pullTo is not verified to be != 0         Argument recipient of MockToken18.pullTo is not verified to be != 0         Argument account of MockToken18.balanceOf is not verified to be != 0         Argument newOwner of UOwnable.transferOwnership is not verified to be != 0   
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           Incentivizer.sol, line 3, import "@openzeppelin/contracts/utils/math/SafeCast.sol";         Program.sol, line 4, import "../../utils/types/Token18.sol";         IIncentivizer.sol, line 5, import "../product/types/position/Position.sol";         ChainlinkOracle.sol, line 5, import "../utils/types/UFixed18.sol";         AccountPosition.sol, line 4, import "../accumulator/Accumulator.sol";  
# Handle  leastwood   # Vulnerability details  ## Impact  The `maintenanceInvariant` modifier in `Collateral` aims to check if a user meets the margin requirements to withdraw collateral by checking its current and next maintenance. `maintenanceInvariant` inevitably calls `AccountPosition.maintenance` which uses the oracle's price to calculate the margin requirements for a given position. Hence, if the oracle has not synced in a long time, `maintenanceInvariant` may end up utilising an outdated price for a withdrawal. This may allow a user to withdraw collateral on an undercollaterized position.  ## Proof of Concept  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L67-L76 ``` function withdrawTo(address account, IProduct product, UFixed18 amount) notPaused collateralInvariant(msg.sender, product) maintenanceInvariant(msg.sender, product) external {     _products[product].debitAccount(msg.sender, amount);     token.push(account, amount);      emit Withdrawal(msg.sender, product, amount); } ```  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L233-L241 ``` modifier maintenanceInvariant(address account, IProduct product) {     _;      UFixed18 maintenance = product.maintenance(account);     UFixed18 maintenanceNext = product.maintenanceNext(account);      if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))         revert CollateralInsufficientCollateralError(); } ```  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/types/position/AccountPosition.sol#L71-L75 ```     function maintenanceInternal(Position memory position, IProductProvider provider) private view returns (UFixed18) {         Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion());         UFixed18 notionalMax = Fixed18Lib.from(position.max()).mul(oraclePrice).abs();         return notionalMax.mul(provider.maintenance());     } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding `settleForAccount(msg.sender)` to the `Collateral.withdrawTo` function to ensure the most up to date oracle price is used when assessing an account's margin requirements.  
# Handle  hubble   # Vulnerability details  ## Impact Incentivizer.updateFee expects a value between UFixed18Lib.ZERO and UFixed18Lib.ONE. When the incentive fee is updated outside of this range, the program creation fails and the product owners would not be able to add new Programs to the Product.  ## Proof of Concept Step 1. Update incentive fee File: /protocol/contracts/incentivizer/Incentivizer.sol Line 368     function updateFee(UFixed18 newFee) onlyOwner external { Line 369             fee = newFee; ...  Step 2. Create new Program File: /protocol/contracts/incentivizer/Incentivizer.sol Line 59    function create(ProgramInfo calldata info)  File: /protocol/contracts/incentivizer/types/ProgramInfo.sol Line 55         Position memory amountAfterFee = info.amount.mul(UFixed18Lib.ONE.sub(fee)); ...  Note: Fails at line 55, whenever fee is greater than UFixedLive.ONE  ## Tools Used Manual code review  ## Recommended Mitigation Steps Implement Range check   File: /protocol/contracts/incentivizer/Incentivizer.sol Line 368     function updateFee(UFixed18 newFee) onlyOwner external { Line 369          if(newFee.gte(UFixed18Lib.ONE)) revert NewError("newFee should be less than UFixed18Lib.ONE"); Line 370          fee = newFee;  Note: Range check at line 369  
# Handle  0x0x0x   # Vulnerability details  In case `oracleVersionCurrent != oracleVersionPreSettle`,  the following line  `accumulated = accumulated.sub(Fixed18Lib.from(_positions[account].settle(provider, oracleVersionPreSettle)));` ([https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/Product.sol#L136](https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/Product.sol#L136))  doesn't make any change. This line can be at the beginning of the `if` statement below to save gas.  
# Handle  0x0x0x   # Vulnerability details  At `Product.sol#closeAll` cache `_position[account]` to save gas.   In the first line of the function `_position[account]` is used twice and gas can be saved by caching it.  
# Handle  cmichel   # Vulnerability details  Certain functions in the `Fixed18` contract perform multiplications by `ONE` or `NEG_ONE` before diving by it again which leads to issues that these functions revert for all values `> MAX_UINT256 / ONE`, but they should not.  ```solidity function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {     if (s > 0) return from(m);     // @audit cannot convert large values because (m * NEG_ONE) might overflow     if (s < 0) return mul(from(m), NEG_ONE);     return ZERO; }  function abs(Fixed18 a) internal pure returns (UFixed18) {     // @audit cannot get abs value if multiplication of a * -1e18 /1e18 overflows. why not unwrap => unary minus     return sign(a) == -1 ? UFixed18Lib.from(mul(a, NEG_ONE)) : UFixed18Lib.from(a); } ```  ## Recommendation Change the implementation to not perform the useless `* 1e18 / 1e18` computations to cover the entire input range. Consider using a typecast `int256(UFixed18.unwrap(m))` after checking the range instead of doing `* NEG_ONE / 1e18`   
# Handle  cmichel   # Vulnerability details  Some fee parameters of functions are not checked for invalid values: - `Collateral.updateLiquidationFee`: The `newLiquidationFee` should be less than 100% - `Factory.updateFee`: The `newFee` should be less than 100%  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  ye0lde   # Vulnerability details  ## Impact Transfer amount can be checked for > 0 before calling `push' which makes a call to `safeTransfer`. This can save gas by avoiding the external call.  ## Proof of Concept  The transfer is here: https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L237-L238   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Check that transfer amount > 0 before L#237-238 are executed.  Consider checking for `amount` > 0 in these functions: https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L51 https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L68 https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L85  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `provider`, `factory()` in `Product#settleInternal()`      https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L72-L100   - `provider`, `_accumulator` in `Product#settleAccountInternal()`      https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L123-L152   - `factory()` in `Collateral#settleProduct()`      https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/collateral/Collateral.sol#L131-L145  
# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style does not follow the best practices:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/collateral/Collateral.sol#L171-L173  ```solidity=171 function shortfall(IProduct product) public view returns (UFixed18) {     return _products[product].shortfall; } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L256-L258  ```solidity=256 function maintenance(address account) public view returns (UFixed18) {     return _positions[account].maintenance(provider); } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L266-L268  ```solidity=266 function maintenanceNext(address account) public view returns (UFixed18) {     return _positions[account].maintenanceNext(provider); } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/factory/Factory.sol#L259-L261  ```solidity=259 function treasury() public view returns (address) {     return treasury(0); } ```  
# Handle  WatchPug   # Vulnerability details  `newController.owner` should be validated to make sure the new owner's address is not `address(0)`.  Otherwise, if the owner mistakenly calls `updateController()` with improper inputs can result in all the `onlyOwner(controllerId)` methods being unaccessible.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/factory/Factory.sol#L103-L106  ```solidity=103 function updateController(uint256 controllerId, Controller memory newController) onlyOwner(controllerId) external {     _controllers[controllerId] = newController;     emit ControllerUpdated(controllerId, newController.owner, newController.treasury); } ```  
# Handle  WatchPug   # Vulnerability details  Caching the result of `_registry[product].length()` can save gas from unnecessary extra SLOAD, function call, and code execution, especially in for loops.  Instances include:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L144-L144  ```solidity=144 for (uint256 i; i < _registry[product].length(); i++) { ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L174-L174  ```solidity=174 for (uint256 i; i < _registry[product].length(); i++) { ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L190-L190  ```solidity=190 for (uint256 i; i < _registry[product].length(); i++) { ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L232-L242  ```solidity=232{234,238} function claimFee(Token18[] calldata tokens) notPaused external {     for(uint256 i; i < tokens.length; i++) {         Token18 token = tokens[i];         UFixed18 amount = fees[token];          fees[token] = UFixed18Lib.ZERO;         tokens[i].push(factory().treasury(), amount);          emit FeeClaim(token, amount);     } } ```  `tokens[i]` at L238 is already cached in the local variable `token` at L234, resuing the result instead of doing the subscript operation again can save gas.  ### Recommendation  Change  ```solidity tokens[i].push(factory().treasury(), amount); ```  to:  ```solidity token.push(factory().treasury(), amount); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L29-L29  ```solidity=29 uint256 private _decimalOffset; ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50{52} function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  `_decimalOffset` is only used at L52。  Therefore `_decimalOffset` can be defined as `int256` and avoid unnecessary `SafeCast.toInt256()`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L20-L20 ```solidity=20 IChainlinkFeed public feed; ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L29-L29 ```solidity=29 uint256 private _decimalOffset; ```  In `ChainlinkOracle.sol`, `feed` and `_decimalOffset` will never change, use immutable variables instead of storage variables can save gas.   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/ProductProviderBase.sol#L13-L13  ```solidity=13 IOracle public oracle; ```  In `ProductProviderBase.sol`, `oracle` will never change, use immutable variables instead of storage variables can save gas.  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas.  There are many times across the codebase that will perform two external calls to the provider to query the current `oraclePrice`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/types/position/AccountPosition.sol#L72-L72  ```solidity=72 Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion()); ```  Consider adding a new method to the provider and return the current `oraclePrice` directly can combine two external calls into one and save some gas.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50 function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  If `block.timestamp - timestampAtVersion[currentVersion()] < minDelay`, there is no need to call `feed.latestRoundData()`.  ### Recommendation  Change to:  ```solidity=50 function sync() public {     if (priceAtVersion.length == 0 || block.timestamp - timestampAtVersion[currentVersion()] >= minDelay ) {         (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();         Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));          if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {             priceAtVersion.push(price);             timestampAtVersion.push(timestamp);              emit Version(currentVersion(), timestamp, price);         }     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50 function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  On `ChainlinkOracle.sol`, we are using `latestRoundData`, but there is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:  - https://docs.chain.link/docs/historical-price-data/#historical-rounds - https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  ### Recommendation  Consider adding missing checks for stale data.   For example:  ```solidity (uint80 roundID, int256 feedPrice, , uint256 timestamp, uint80 answeredInRound) = feed.latestRoundData(); require(feedPrice > 0, "Chainlink price <= 0");  require(answeredInRound >= roundID, "Stale price"); require(timestamp != 0, "Round not complete"); ```  
# Handle  WatchPug   # Vulnerability details  When `isEther()`, `decimals` must be `18`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L118-L120  ```solidity=118 function decimals(Token18 self) internal view returns (uint8) {     return isEther(self) ? 18 : IERC20Metadata(Token18.unwrap(self)).decimals(); } ```  Therefore, in `Token18.sol#balanceOf()`, `fromTokenAmount()` is unnecessary when `isEther()`.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L137-L142  ```solidity=137 function balanceOf(Token18 self, address account) internal view returns (UFixed18) {     uint256 tokenAmount = isEther(self) ?         account.balance :         IERC20(Token18.unwrap(self)).balanceOf(account);     return fromTokenAmount(self, tokenAmount); } ```  Can be changed to:  ```solidity=137 function balanceOf(Token18 self, address account) internal view returns (UFixed18) {     return isEther(self) ?         UFixed18.wrap(account.balance) :         fromTokenAmount(self, IERC20(Token18.unwrap(self)).balanceOf(account)); } ```  
# Handle  WatchPug   # Vulnerability details  When `isEther()`, `decimals` must be `18`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L118-L120  ```solidity=118     function decimals(Token18 self) internal view returns (uint8) {         return isEther(self) ? 18 : IERC20Metadata(Token18.unwrap(self)).decimals();     } ```  Therefore, in `Token18.sol#push()`, `toTokenAmount()` is unnecessary when `isEther()`.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L51-L59  ```solidity=51 function push(     Token18 self,     address recipient,     UFixed18 amount ) internal {     isEther(self)         ? Address.sendValue(payable(recipient), toTokenAmount(self, amount))         : IERC20(Token18.unwrap(self)).safeTransfer(recipient, toTokenAmount(self, amount)); } ```  Can be changed to:  ```solidity=51 function push(     Token18 self,     address recipient,     UFixed18 amount ) internal {     isEther(self)         ? Address.sendValue(payable(recipient), UFixed18.unwrap(amount))         : IERC20(Token18.unwrap(self)).safeTransfer(recipient, toTokenAmount(self, amount)); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L151-L154  ```solidity=151 function toTokenAmount(Token18 self, UFixed18 amount) private view returns (uint256) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** uint256(decimals(self)), 10 ** 18);     return UFixed18.unwrap(amount.mul(conversion)); } ```  Can be changed to:  ```solidity=151 function toTokenAmount(Token18 self, UFixed18 amount) private view returns (uint256) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** uint256(decimals(self)), 1e18);     return UFixed18.unwrap(amount.mul(conversion)); } ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L163-L166  ```solidity=163 function fromTokenAmount(Token18 self, uint256 amount) private view returns (UFixed18) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** 18, 10 ** uint256(decimals(self)));     return UFixed18.wrap(amount).mul(conversion); } ```  Can be changed to:  ```solidity=163 function fromTokenAmount(Token18 self, uint256 amount) private view returns (UFixed18) {     UFixed18 conversion = UFixed18Lib.ratio(1e18, 10 ** uint256(decimals(self)));     return UFixed18.wrap(amount).mul(conversion); } ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/types/position/PrePosition.sol#L145-L156  ```solidity=145 function computeFee(PrePosition memory self, IProductProvider provider, uint256 toOracleVersion) internal view returns (UFixed18 positionFee) {     Fixed18 oraclePrice = provider.priceAtVersion(toOracleVersion);     Position memory positionDelta = self.openPosition.add(self.closePosition);      (UFixed18 makerNotional, UFixed18 takerNotional) = (         Fixed18Lib.from(positionDelta.maker).mul(oraclePrice).abs(),         Fixed18Lib.from(positionDelta.taker).mul(oraclePrice).abs()     );      positionFee = positionFee.add(makerNotional.mul(provider.safeMakerFee()));     positionFee = positionFee.add(takerNotional.mul(provider.safeTakerFee())); } ```  At L154, `positionFee = positionFee.add(makerNotional.mul(provider.safeMakerFee()));`  can be changed to `positionFee = makerNotional.mul(provider.safeMakerFee());` as `positionFee == 0`.  Futhermore, L154-155 can be combined into:  ```solidity positionFee = makerNotional.mul(provider.safeMakerFee()).add(     takerNotional.mul(provider.safeTakerFee()) ); ```  
# Handle  kenzo   # Vulnerability details  Every time an account is settled, if shortfall is created, due to a wrong calculation shortfall will double in size and add the new shortfall.  ## Impact Loss of funds: users won't be able to withdraw the correct amount of funds. Somebody would have to donate funds to resolve the wrong shortfall.  ## Proof of Concept We can see in the `settleAccount` of `OptimisticLedger` that self.shortfall ends up being self.shortfall+self.shortfall+newShortfall: [(Code ref)](https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/types/OptimisticLedger.sol#L63:#L74) ```     function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)     internal returns (UFixed18 shortfall) {         Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);          if (newBalance.sign() == -1) {             shortfall = self.shortfall.add(newBalance.abs());             newBalance = Fixed18Lib.ZERO;         }          self.balances[account] = newBalance.abs();         self.shortfall = self.shortfall.add(shortfall);     } ```  Additionally, you can add the following line to the "shortfall reverts if depleted" test in Collateral.test.js, line 190: ``` await collateral.connect(productSigner).settleAccount(userB.address, -50) ``` Previously the test product had 50 shortfall. Now we added 50 more, but the test will print that the actual shortfall is 150, and not 100 as it should be.  ## Recommended Mitigation Steps Move the setting of `self.shortfall` to inside the if function and change the line to: ``` self.shortfall = shortfall ```  
# Handle  0x1f8b   # Vulnerability details  ## Impact Lost the owner by human error.  ## Proof of Concept The modification process of an owner is a delicate process, since the governance of our contract and therefore of the project may be at risk, for this reason it is recommended to adjust the owner’s modification logic, to a logic that allows to verify that the new owner is in fact valid and does exist.  It's mandatory to create a logic of the owner’s modification where a new owner is proposed first, the owner accepts the proposal and, in this way, we make sure that there are no errors when writing the address of the new owner.   Source reference: - UOwnable.transferOwnership  ## Tools Used Manual review  ## Recommended Mitigation Steps Use an ACK method for approve the new owner.  
# Handle  robee   # Vulnerability details  Not verified address arguments of external/public functions is a low risk issue.  It's less severe for onlyOwner methods but for any other method it's crucial since the default address is 0.          Argument account of Collateral.depositTo is not verified to be != 0         Argument account of Collateral.withdrawTo is not verified to be != 0         Argument account of Collateral.liquidate is not verified to be != 0         Argument account of Collateral.settleAccount is not verified to be != 0         Argument account of Collateral.collateral is not verified to be != 0         Argument account of Collateral.liquidatable is not verified to be != 0         Argument account of Collateral.liquidatableNext is not verified to be != 0         Argument treasury_ of Factory.initialize is not verified to be != 0         Argument controllerTreasury of Factory.createController is not verified to be != 0         Argument newPauser of Factory.updatePauser is not verified to be != 0         Argument account of Incentivizer.syncAccount is not verified to be != 0         Argument account of Incentivizer.unclaimed is not verified to be != 0         Argument account of Incentivizer.latestVersion is not verified to be != 0         Argument account of Incentivizer.settled is not verified to be != 0         Argument account of Product.settleAccount is not verified to be != 0         Argument account of Product.closeAll is not verified to be != 0         Argument account of Product.maintenance is not verified to be != 0         Argument account of Product.maintenanceNext is not verified to be != 0         Argument account of Product.isClosed is not verified to be != 0         Argument account of Product.isLiquidating is not verified to be != 0         Argument account of Product.position is not verified to be != 0         Argument account of Product.pre is not verified to be != 0         Argument account of Product.latestVersion is not verified to be != 0         Argument recipient of MockToken18.push is not verified to be != 0         Argument recipient of MockToken18.push is not verified to be != 0         Argument benefactor of MockToken18.pull is not verified to be != 0         Argument benefactor of MockToken18.pullTo is not verified to be != 0         Argument recipient of MockToken18.pullTo is not verified to be != 0         Argument account of MockToken18.balanceOf is not verified to be != 0         Argument newOwner of UOwnable.transferOwnership is not verified to be != 0   
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           Incentivizer.sol, line 3, import "@openzeppelin/contracts/utils/math/SafeCast.sol";         Program.sol, line 4, import "../../utils/types/Token18.sol";         IIncentivizer.sol, line 5, import "../product/types/position/Position.sol";         ChainlinkOracle.sol, line 5, import "../utils/types/UFixed18.sol";         AccountPosition.sol, line 4, import "../accumulator/Accumulator.sol";  
# Handle  leastwood   # Vulnerability details  ## Impact  The `maintenanceInvariant` modifier in `Collateral` aims to check if a user meets the margin requirements to withdraw collateral by checking its current and next maintenance. `maintenanceInvariant` inevitably calls `AccountPosition.maintenance` which uses the oracle's price to calculate the margin requirements for a given position. Hence, if the oracle has not synced in a long time, `maintenanceInvariant` may end up utilising an outdated price for a withdrawal. This may allow a user to withdraw collateral on an undercollaterized position.  ## Proof of Concept  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L67-L76 ``` function withdrawTo(address account, IProduct product, UFixed18 amount) notPaused collateralInvariant(msg.sender, product) maintenanceInvariant(msg.sender, product) external {     _products[product].debitAccount(msg.sender, amount);     token.push(account, amount);      emit Withdrawal(msg.sender, product, amount); } ```  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L233-L241 ``` modifier maintenanceInvariant(address account, IProduct product) {     _;      UFixed18 maintenance = product.maintenance(account);     UFixed18 maintenanceNext = product.maintenanceNext(account);      if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))         revert CollateralInsufficientCollateralError(); } ```  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/types/position/AccountPosition.sol#L71-L75 ```     function maintenanceInternal(Position memory position, IProductProvider provider) private view returns (UFixed18) {         Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion());         UFixed18 notionalMax = Fixed18Lib.from(position.max()).mul(oraclePrice).abs();         return notionalMax.mul(provider.maintenance());     } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding `settleForAccount(msg.sender)` to the `Collateral.withdrawTo` function to ensure the most up to date oracle price is used when assessing an account's margin requirements.  
# Handle  hubble   # Vulnerability details  ## Impact Incentivizer.updateFee expects a value between UFixed18Lib.ZERO and UFixed18Lib.ONE. When the incentive fee is updated outside of this range, the program creation fails and the product owners would not be able to add new Programs to the Product.  ## Proof of Concept Step 1. Update incentive fee File: /protocol/contracts/incentivizer/Incentivizer.sol Line 368     function updateFee(UFixed18 newFee) onlyOwner external { Line 369             fee = newFee; ...  Step 2. Create new Program File: /protocol/contracts/incentivizer/Incentivizer.sol Line 59    function create(ProgramInfo calldata info)  File: /protocol/contracts/incentivizer/types/ProgramInfo.sol Line 55         Position memory amountAfterFee = info.amount.mul(UFixed18Lib.ONE.sub(fee)); ...  Note: Fails at line 55, whenever fee is greater than UFixedLive.ONE  ## Tools Used Manual code review  ## Recommended Mitigation Steps Implement Range check   File: /protocol/contracts/incentivizer/Incentivizer.sol Line 368     function updateFee(UFixed18 newFee) onlyOwner external { Line 369          if(newFee.gte(UFixed18Lib.ONE)) revert NewError("newFee should be less than UFixed18Lib.ONE"); Line 370          fee = newFee;  Note: Range check at line 369  
# Handle  0x0x0x   # Vulnerability details  In case `oracleVersionCurrent != oracleVersionPreSettle`,  the following line  `accumulated = accumulated.sub(Fixed18Lib.from(_positions[account].settle(provider, oracleVersionPreSettle)));` ([https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/Product.sol#L136](https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/Product.sol#L136))  doesn't make any change. This line can be at the beginning of the `if` statement below to save gas.  
# Handle  0x0x0x   # Vulnerability details  At `Product.sol#closeAll` cache `_position[account]` to save gas.   In the first line of the function `_position[account]` is used twice and gas can be saved by caching it.  
# Handle  cmichel   # Vulnerability details  Certain functions in the `Fixed18` contract perform multiplications by `ONE` or `NEG_ONE` before diving by it again which leads to issues that these functions revert for all values `> MAX_UINT256 / ONE`, but they should not.  ```solidity function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {     if (s > 0) return from(m);     // @audit cannot convert large values because (m * NEG_ONE) might overflow     if (s < 0) return mul(from(m), NEG_ONE);     return ZERO; }  function abs(Fixed18 a) internal pure returns (UFixed18) {     // @audit cannot get abs value if multiplication of a * -1e18 /1e18 overflows. why not unwrap => unary minus     return sign(a) == -1 ? UFixed18Lib.from(mul(a, NEG_ONE)) : UFixed18Lib.from(a); } ```  ## Recommendation Change the implementation to not perform the useless `* 1e18 / 1e18` computations to cover the entire input range. Consider using a typecast `int256(UFixed18.unwrap(m))` after checking the range instead of doing `* NEG_ONE / 1e18`   
# Handle  cmichel   # Vulnerability details  Some fee parameters of functions are not checked for invalid values: - `Collateral.updateLiquidationFee`: The `newLiquidationFee` should be less than 100% - `Factory.updateFee`: The `newFee` should be less than 100%  ## Recommended Mitigation Steps Validate the parameters.  
# Handle  ye0lde   # Vulnerability details  ## Impact Transfer amount can be checked for > 0 before calling `push' which makes a call to `safeTransfer`. This can save gas by avoiding the external call.  ## Proof of Concept  The transfer is here: https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L237-L238   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Check that transfer amount > 0 before L#237-238 are executed.  Consider checking for `amount` > 0 in these functions: https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L51 https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L68 https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L85  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `provider`, `factory()` in `Product#settleInternal()`      https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L72-L100   - `provider`, `_accumulator` in `Product#settleAccountInternal()`      https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L123-L152   - `factory()` in `Collateral#settleProduct()`      https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/collateral/Collateral.sol#L131-L145  
# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style does not follow the best practices:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/collateral/Collateral.sol#L171-L173  ```solidity=171 function shortfall(IProduct product) public view returns (UFixed18) {     return _products[product].shortfall; } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L256-L258  ```solidity=256 function maintenance(address account) public view returns (UFixed18) {     return _positions[account].maintenance(provider); } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L266-L268  ```solidity=266 function maintenanceNext(address account) public view returns (UFixed18) {     return _positions[account].maintenanceNext(provider); } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/factory/Factory.sol#L259-L261  ```solidity=259 function treasury() public view returns (address) {     return treasury(0); } ```  
# Handle  WatchPug   # Vulnerability details  `newController.owner` should be validated to make sure the new owner's address is not `address(0)`.  Otherwise, if the owner mistakenly calls `updateController()` with improper inputs can result in all the `onlyOwner(controllerId)` methods being unaccessible.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/factory/Factory.sol#L103-L106  ```solidity=103 function updateController(uint256 controllerId, Controller memory newController) onlyOwner(controllerId) external {     _controllers[controllerId] = newController;     emit ControllerUpdated(controllerId, newController.owner, newController.treasury); } ```  
# Handle  WatchPug   # Vulnerability details  Caching the result of `_registry[product].length()` can save gas from unnecessary extra SLOAD, function call, and code execution, especially in for loops.  Instances include:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L144-L144  ```solidity=144 for (uint256 i; i < _registry[product].length(); i++) { ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L174-L174  ```solidity=174 for (uint256 i; i < _registry[product].length(); i++) { ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L190-L190  ```solidity=190 for (uint256 i; i < _registry[product].length(); i++) { ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L232-L242  ```solidity=232{234,238} function claimFee(Token18[] calldata tokens) notPaused external {     for(uint256 i; i < tokens.length; i++) {         Token18 token = tokens[i];         UFixed18 amount = fees[token];          fees[token] = UFixed18Lib.ZERO;         tokens[i].push(factory().treasury(), amount);          emit FeeClaim(token, amount);     } } ```  `tokens[i]` at L238 is already cached in the local variable `token` at L234, resuing the result instead of doing the subscript operation again can save gas.  ### Recommendation  Change  ```solidity tokens[i].push(factory().treasury(), amount); ```  to:  ```solidity token.push(factory().treasury(), amount); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L29-L29  ```solidity=29 uint256 private _decimalOffset; ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50{52} function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  `_decimalOffset` is only used at L52。  Therefore `_decimalOffset` can be defined as `int256` and avoid unnecessary `SafeCast.toInt256()`.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L20-L20 ```solidity=20 IChainlinkFeed public feed; ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L29-L29 ```solidity=29 uint256 private _decimalOffset; ```  In `ChainlinkOracle.sol`, `feed` and `_decimalOffset` will never change, use immutable variables instead of storage variables can save gas.   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/ProductProviderBase.sol#L13-L13  ```solidity=13 IOracle public oracle; ```  In `ProductProviderBase.sol`, `oracle` will never change, use immutable variables instead of storage variables can save gas.  
# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas.  There are many times across the codebase that will perform two external calls to the provider to query the current `oraclePrice`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/types/position/AccountPosition.sol#L72-L72  ```solidity=72 Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion()); ```  Consider adding a new method to the provider and return the current `oraclePrice` directly can combine two external calls into one and save some gas.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50 function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  If `block.timestamp - timestampAtVersion[currentVersion()] < minDelay`, there is no need to call `feed.latestRoundData()`.  ### Recommendation  Change to:  ```solidity=50 function sync() public {     if (priceAtVersion.length == 0 || block.timestamp - timestampAtVersion[currentVersion()] >= minDelay ) {         (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();         Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));          if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {             priceAtVersion.push(price);             timestampAtVersion.push(timestamp);              emit Version(currentVersion(), timestamp, price);         }     } } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50 function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  On `ChainlinkOracle.sol`, we are using `latestRoundData`, but there is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:  - https://docs.chain.link/docs/historical-price-data/#historical-rounds - https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  ### Recommendation  Consider adding missing checks for stale data.   For example:  ```solidity (uint80 roundID, int256 feedPrice, , uint256 timestamp, uint80 answeredInRound) = feed.latestRoundData(); require(feedPrice > 0, "Chainlink price <= 0");  require(answeredInRound >= roundID, "Stale price"); require(timestamp != 0, "Round not complete"); ```  
# Handle  WatchPug   # Vulnerability details  When `isEther()`, `decimals` must be `18`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L118-L120  ```solidity=118 function decimals(Token18 self) internal view returns (uint8) {     return isEther(self) ? 18 : IERC20Metadata(Token18.unwrap(self)).decimals(); } ```  Therefore, in `Token18.sol#balanceOf()`, `fromTokenAmount()` is unnecessary when `isEther()`.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L137-L142  ```solidity=137 function balanceOf(Token18 self, address account) internal view returns (UFixed18) {     uint256 tokenAmount = isEther(self) ?         account.balance :         IERC20(Token18.unwrap(self)).balanceOf(account);     return fromTokenAmount(self, tokenAmount); } ```  Can be changed to:  ```solidity=137 function balanceOf(Token18 self, address account) internal view returns (UFixed18) {     return isEther(self) ?         UFixed18.wrap(account.balance) :         fromTokenAmount(self, IERC20(Token18.unwrap(self)).balanceOf(account)); } ```  
# Handle  WatchPug   # Vulnerability details  When `isEther()`, `decimals` must be `18`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L118-L120  ```solidity=118     function decimals(Token18 self) internal view returns (uint8) {         return isEther(self) ? 18 : IERC20Metadata(Token18.unwrap(self)).decimals();     } ```  Therefore, in `Token18.sol#push()`, `toTokenAmount()` is unnecessary when `isEther()`.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L51-L59  ```solidity=51 function push(     Token18 self,     address recipient,     UFixed18 amount ) internal {     isEther(self)         ? Address.sendValue(payable(recipient), toTokenAmount(self, amount))         : IERC20(Token18.unwrap(self)).safeTransfer(recipient, toTokenAmount(self, amount)); } ```  Can be changed to:  ```solidity=51 function push(     Token18 self,     address recipient,     UFixed18 amount ) internal {     isEther(self)         ? Address.sendValue(payable(recipient), UFixed18.unwrap(amount))         : IERC20(Token18.unwrap(self)).safeTransfer(recipient, toTokenAmount(self, amount)); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L151-L154  ```solidity=151 function toTokenAmount(Token18 self, UFixed18 amount) private view returns (uint256) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** uint256(decimals(self)), 10 ** 18);     return UFixed18.unwrap(amount.mul(conversion)); } ```  Can be changed to:  ```solidity=151 function toTokenAmount(Token18 self, UFixed18 amount) private view returns (uint256) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** uint256(decimals(self)), 1e18);     return UFixed18.unwrap(amount.mul(conversion)); } ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L163-L166  ```solidity=163 function fromTokenAmount(Token18 self, uint256 amount) private view returns (UFixed18) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** 18, 10 ** uint256(decimals(self)));     return UFixed18.wrap(amount).mul(conversion); } ```  Can be changed to:  ```solidity=163 function fromTokenAmount(Token18 self, uint256 amount) private view returns (UFixed18) {     UFixed18 conversion = UFixed18Lib.ratio(1e18, 10 ** uint256(decimals(self)));     return UFixed18.wrap(amount).mul(conversion); } ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/types/position/PrePosition.sol#L145-L156  ```solidity=145 function computeFee(PrePosition memory self, IProductProvider provider, uint256 toOracleVersion) internal view returns (UFixed18 positionFee) {     Fixed18 oraclePrice = provider.priceAtVersion(toOracleVersion);     Position memory positionDelta = self.openPosition.add(self.closePosition);      (UFixed18 makerNotional, UFixed18 takerNotional) = (         Fixed18Lib.from(positionDelta.maker).mul(oraclePrice).abs(),         Fixed18Lib.from(positionDelta.taker).mul(oraclePrice).abs()     );      positionFee = positionFee.add(makerNotional.mul(provider.safeMakerFee()));     positionFee = positionFee.add(takerNotional.mul(provider.safeTakerFee())); } ```  At L154, `positionFee = positionFee.add(makerNotional.mul(provider.safeMakerFee()));`  can be changed to `positionFee = makerNotional.mul(provider.safeMakerFee());` as `positionFee == 0`.  Futhermore, L154-155 can be combined into:  ```solidity positionFee = makerNotional.mul(provider.safeMakerFee()).add(     takerNotional.mul(provider.safeTakerFee()) ); ```  
# Handle  kenzo   # Vulnerability details  Every time an account is settled, if shortfall is created, due to a wrong calculation shortfall will double in size and add the new shortfall.  ## Impact Loss of funds: users won't be able to withdraw the correct amount of funds. Somebody would have to donate funds to resolve the wrong shortfall.  ## Proof of Concept We can see in the `settleAccount` of `OptimisticLedger` that self.shortfall ends up being self.shortfall+self.shortfall+newShortfall: [(Code ref)](https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/types/OptimisticLedger.sol#L63:#L74) ```     function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)     internal returns (UFixed18 shortfall) {         Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);          if (newBalance.sign() == -1) {             shortfall = self.shortfall.add(newBalance.abs());             newBalance = Fixed18Lib.ZERO;         }          self.balances[account] = newBalance.abs();         self.shortfall = self.shortfall.add(shortfall);     } ```  Additionally, you can add the following line to the "shortfall reverts if depleted" test in Collateral.test.js, line 190: ``` await collateral.connect(productSigner).settleAccount(userB.address, -50) ``` Previously the test product had 50 shortfall. Now we added 50 more, but the test will print that the actual shortfall is 150, and not 100 as it should be.  ## Recommended Mitigation Steps Move the setting of `self.shortfall` to inside the if function and change the line to: ``` self.shortfall = shortfall ```  
# Handle  0x1f8b   # Vulnerability details  ## Impact Lost the owner by human error.  ## Proof of Concept The modification process of an owner is a delicate process, since the governance of our contract and therefore of the project may be at risk, for this reason it is recommended to adjust the owner’s modification logic, to a logic that allows to verify that the new owner is in fact valid and does exist.  It's mandatory to create a logic of the owner’s modification where a new owner is proposed first, the owner accepts the proposal and, in this way, we make sure that there are no errors when writing the address of the new owner.   Source reference: - UOwnable.transferOwnership  ## Tools Used Manual review  ## Recommended Mitigation Steps Use an ACK method for approve the new owner.  
# Handle  robee   # Vulnerability details  Not verified address arguments of external/public functions is a low risk issue.  It's less severe for onlyOwner methods but for any other method it's crucial since the default address is 0.          Argument account of Collateral.depositTo is not verified to be != 0         Argument account of Collateral.withdrawTo is not verified to be != 0         Argument account of Collateral.liquidate is not verified to be != 0         Argument account of Collateral.settleAccount is not verified to be != 0         Argument account of Collateral.collateral is not verified to be != 0         Argument account of Collateral.liquidatable is not verified to be != 0         Argument account of Collateral.liquidatableNext is not verified to be != 0         Argument treasury_ of Factory.initialize is not verified to be != 0         Argument controllerTreasury of Factory.createController is not verified to be != 0         Argument newPauser of Factory.updatePauser is not verified to be != 0         Argument account of Incentivizer.syncAccount is not verified to be != 0         Argument account of Incentivizer.unclaimed is not verified to be != 0         Argument account of Incentivizer.latestVersion is not verified to be != 0         Argument account of Incentivizer.settled is not verified to be != 0         Argument account of Product.settleAccount is not verified to be != 0         Argument account of Product.closeAll is not verified to be != 0         Argument account of Product.maintenance is not verified to be != 0         Argument account of Product.maintenanceNext is not verified to be != 0         Argument account of Product.isClosed is not verified to be != 0         Argument account of Product.isLiquidating is not verified to be != 0         Argument account of Product.position is not verified to be != 0         Argument account of Product.pre is not verified to be != 0         Argument account of Product.latestVersion is not verified to be != 0         Argument recipient of MockToken18.push is not verified to be != 0         Argument recipient of MockToken18.push is not verified to be != 0         Argument benefactor of MockToken18.pull is not verified to be != 0         Argument benefactor of MockToken18.pullTo is not verified to be != 0         Argument recipient of MockToken18.pullTo is not verified to be != 0         Argument account of MockToken18.balanceOf is not verified to be != 0         Argument newOwner of UOwnable.transferOwnership is not verified to be != 0   
# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           Incentivizer.sol, line 3, import "@openzeppelin/contracts/utils/math/SafeCast.sol";         Program.sol, line 4, import "../../utils/types/Token18.sol";         IIncentivizer.sol, line 5, import "../product/types/position/Position.sol";         ChainlinkOracle.sol, line 5, import "../utils/types/UFixed18.sol";         AccountPosition.sol, line 4, import "../accumulator/Accumulator.sol";  
