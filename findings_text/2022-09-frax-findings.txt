# Lines of code  https://github.com/corddry/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/xERC4626.sol#L78-L97   # Vulnerability details  ## Impact  In the current rewards accounting, vault shares in `deposit()` and `redeem()` can not correctly record the spot yields generated by the staked asset. Yields are released over the next rewards cycle. As a result, malicious users can steal yields from innocent users by picking special timing to `deposit()` and `redeem()`.   ## Proof of Concept  In `syncRewards()`, the current asset balance is break into 2 parts: `storedTotalAssets` and `lastRewardAmount/nextRewards`. The `lastRewardAmount` is the surplus balance of the asset, or the most recent yields. ```solidity // lib/ERC4626/src/xERC4626.sol     function syncRewards() public virtual {         // ...          uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;          storedTotalAssets = storedTotalAssets_ + lastRewardAmount_;          uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;          lastRewardAmount = nextRewards.safeCastTo192();         // ...                 rewardsCycleEnd = end;     } ```  And in the next rewards cycle, `lastRewardAmount` will be linearly added to `storedTotalAssets`, their sum is the return value of `totalAssets()`:  ```solidity     function totalAssets() public view override returns (uint256) {         // ...          if (block.timestamp >= rewardsCycleEnd_) {             // no rewards or rewards fully unlocked             // entire reward amount is available             return storedTotalAssets_ + lastRewardAmount_;         }          // rewards not fully unlocked         // add unlocked rewards to stored total         uint256 unlockedRewards = (lastRewardAmount_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);         return storedTotalAssets_ + unlockedRewards;     } ```  `totalAssets()` will be referred when `deposit()` and `redeem()`. ```solidity // lib/solmate/src/mixins/ERC4626.sol      function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {         require((shares = previewDeposit(assets)) != 0, "ZERO_SHARES");         // ...         _mint(receiver, shares);         // ...     }      function redeem() public virtual returns (uint256 assets) {         // ...         require((assets = previewRedeem(shares)) != 0, "ZERO_ASSETS");          beforeWithdraw(assets, shares);          _burn(owner, shares);          // ...          asset.safeTransfer(receiver, assets);     }      function previewDeposit(uint256 assets) public view virtual returns (uint256) {         return convertToShares(assets);     }      function previewRedeem(uint256 shares) public view virtual returns (uint256) {         return convertToAssets(shares);     }      function convertToShares(uint256 assets) public view virtual returns (uint256) {         uint256 supply = totalSupply;           return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());     }      function convertToAssets(uint256 shares) public view virtual returns (uint256) {         uint256 supply = totalSupply;           return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);     } ```  Based on the above rules, there are 2 potential abuse cases: 1. If withdraw just after the `rewardsCycleEnd` timestamp, a user can not get the yields from last rewards cycle. Since the `totalAssets()` only contain `storedTotalAssets` but not the yields part. It takes 1 rewards cycle to linearly add to the `storedTotalAssets`.   Assume per 10,000 asset staking generate yields of 70 for 7 days, and the reward cycle is 1 day. A malicious user Alice can do the following: - watch the mempool for  `withdraw(10,000)` from account Bob, front run it with `syncRewards()`, so that the most recent yields of amount 70 from Bob will stay in the vault.  - Alice will also deposit a 10,000 to take as much shares as possible.  - after 1 rewards cycle of 1 day, `redeem()` to take the yields of 70.   Effectively steal the yields from Bob. The profit for Alice is not 70, because after 1 day, her own deposit also generates some yield, in this example this portion is 1. At the end, Alice steal yield of amount 60.   2. When the Multisig Treasury transfers new yields into the vault, the new yields will accumulate until `syncRewards()` is called. It is possible that yields from multiple rewards cycles accumulates, and being released in the next cycle.  Knowing that the yields has been accumulated for 3 rewards cycles, a malicious user can `deposit()` and call `syncRewards()` to trigger the release of the rewards. `redeem()` after 1 cycle.  Here the malicious user gets yields of 3 cycles, lose 1 in the waiting cycle. The net profit is 2 cycle yields, and the gained yields should belong to the other users in the vault.    ## Tools Used Manual analysis.  ## Recommended Mitigation Steps   - for the `lastRewardAmount` not released, allow the users to redeem as it is linearly released later. - for the accumulated yields, only allow users to redeem the yields received after 1 rewards cycle after the deposit.
# Lines of code  https://github.com/code-423n4/2022-09-frax/blob/main/src/frxETHMinter.sol#L120   # Vulnerability details  ## Impact Frontrunning by malicious validator changing withdrawal credentials  ## Proof of Concept A malicious validator can frontrun depositEther transaction for its pubKey and deposit 1 ether for different withdrawal credential, thereby setting withdrawal credit before deposit of 32 ether by contract and thereby when 32 deposit ether are deposited, the withdrawal credential is also what was set before rather than the one being sent in depositEther transaction  ## Recommended Mitigation Steps Set withdrawal credentials for validator by depositing 1 ether with desired withdrawal credentials, before adding it in Operator Registry
# Lines of code  https://github.com/code-423n4/2022-09-frax/blob/dc6684f77b4e9bd965e8862be7f5fb71473a4c4c/src/frxETHMinter.sol#L129   # Vulnerability details  ## Impact `frxETHMinter.depositEther` always iterates over all deposits that are possible with the current balance (`(address(this).balance - currentWithheldETH) / DEPOSIT_SIZE`). However, when a lot of ETH was deposited into the contract / it was not called in a long time, this loop can reach the gas limit. When this happens, no more calls to `depositEther` are possible, as it will always run out of gas.  Of course, the probability that such a situation arises depends on the price of ETH. For >1,000 USD it would need require someone to deposit a large amount of money (which can also happen, there are whales with thousands of ETH, so if one of them would decide to use frxETH, the problem can arise). For lower prices, it can happen even for small (in dollar terms) deposits. And in general, the correct functionality of a protocol should not depend on the price of ETH.  ## Proof Of Concept Jerome Powell continues to rise interest rates, he just announced the next rate hike to 450%. The crypto market crashes, ETH is at 1 USD. Bob buys 100,000 ETH for 100,000 USD and deposits them into `frxETHMinter`. Because of this deposit, `numDeposit` within `depositEther` is equal to 3125. Therefore, every call to the function runs out of gas and it is not possible to deposit this ETH into the deposit contract.  ## Recommended Mitigation Steps It should be possible to specify an upper limit for the number of deposits such that progress is possible, even when a lot of ETH was deposited into the contract.
# Lines of code  https://github.com/code-423n4/2022-09-frax/blob/dc6684f77b4e9bd965e8862be7f5fb71473a4c4c/src/sfrxETH.sol#L50   # Vulnerability details  ## Impact `sfrxETH.beforeWithdraw` first calls the `beforeWithdraw` of `xERC4626`, which decrements `storedTotalAssets` by the given amount. If the timestamp is greater than the `rewardsCycleEnd`, `syncRewards` is called. However, the problem is that the assets have not been transfered out yet, meaning `asset.balanceOf(address(this))` still has the old value. On the other hand, `storedTotalAssets` was already updated. Therefore, the following calculation will be inflated by the amount for which the withdrawal was requested: ``` uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_; ``` This has severe consequences: 1.) During the following reward period, `lastRewardAmount` is too high, which means that too much rewards are paid out too users who want to withdraw. A user could exploit this to steal the assets of other users. 2.) When `syncRewards()` is called the next time, it is possible that the `nextRewards` calculation underflows because `lastRewardAmount > asset.balanceOf(address(this))`. This is very bad because `syncRewards()` will be called in every withdrawal (after the `rewardsCycleEnd`) and none of them will succeed because of the underflow. Depositing more also does not help here, it just increases `asset.balanceOf(address(this))` and `storedTotalAssets` by the same amount, which does not eliminate the underflow.  Note that this bug does not require a malicious user or a targeted attack to surface. It can (and probably will) happen in practice just by normal user interactions with the vault (which is for instance shown in the PoC).  ## Proof Of Concept Consider the following test: ``` function testTotalAssetsAfterWithdraw() public {                 uint128 deposit = 1 ether;         uint128 withdraw = 1 ether;         // Mint frxETH to this testing contract from nothing, for testing         mintTo(address(this), deposit);          // Generate some sfrxETH to this testing contract using frxETH         frxETHtoken.approve(address(sfrxETHtoken), deposit);         sfrxETHtoken.deposit(deposit, address(this));         require(sfrxETHtoken.totalAssets() == deposit);          vm.warp(block.timestamp + 1000);         // Withdraw frxETH (from sfrxETH) to this testing contract         sfrxETHtoken.withdraw(withdraw, address(this), address(this));         vm.warp(block.timestamp + 1000);         sfrxETHtoken.syncRewards();         require(sfrxETHtoken.totalAssets() == deposit - withdraw);     } ```  This is a normal user interaction where a user deposits into the vault, and makes a withdrawal some time later. However, at this point the `syncRewards()` within the `beforeWithdraw` is executed. Because of that, the documented accounting mistake happens and the next call (in fact every call that will be done in the future) to `syncRewards()` reverts with an underflow.  ## Recommended Mitigation Steps Call `syncRewards()` before decrementing `storedTotalAssets`, i.e.: ``` function beforeWithdraw(uint256 assets, uint256 shares) internal override {  if (block.timestamp >= rewardsCycleEnd) { syncRewards(); }  super.beforeWithdraw(assets, shares); // call xERC4626's beforeWithdraw AFTER } ``` Then, `asset.balanceOf(address(this))` and `storedTotalAssets` are still in sync within `syncRewards()`.
# Lines of code  https://github.com/corddry/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/xERC4626.sol#L78-L97   # Vulnerability details  ## Impact  In the current rewards accounting, vault shares in `deposit()` and `redeem()` can not correctly record the spot yields generated by the staked asset. Yields are released over the next rewards cycle. As a result, malicious users can steal yields from innocent users by picking special timing to `deposit()` and `redeem()`.   ## Proof of Concept  In `syncRewards()`, the current asset balance is break into 2 parts: `storedTotalAssets` and `lastRewardAmount/nextRewards`. The `lastRewardAmount` is the surplus balance of the asset, or the most recent yields. ```solidity // lib/ERC4626/src/xERC4626.sol     function syncRewards() public virtual {         // ...          uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;          storedTotalAssets = storedTotalAssets_ + lastRewardAmount_;          uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;          lastRewardAmount = nextRewards.safeCastTo192();         // ...                 rewardsCycleEnd = end;     } ```  And in the next rewards cycle, `lastRewardAmount` will be linearly added to `storedTotalAssets`, their sum is the return value of `totalAssets()`:  ```solidity     function totalAssets() public view override returns (uint256) {         // ...          if (block.timestamp >= rewardsCycleEnd_) {             // no rewards or rewards fully unlocked             // entire reward amount is available             return storedTotalAssets_ + lastRewardAmount_;         }          // rewards not fully unlocked         // add unlocked rewards to stored total         uint256 unlockedRewards = (lastRewardAmount_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);         return storedTotalAssets_ + unlockedRewards;     } ```  `totalAssets()` will be referred when `deposit()` and `redeem()`. ```solidity // lib/solmate/src/mixins/ERC4626.sol      function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {         require((shares = previewDeposit(assets)) != 0, "ZERO_SHARES");         // ...         _mint(receiver, shares);         // ...     }      function redeem() public virtual returns (uint256 assets) {         // ...         require((assets = previewRedeem(shares)) != 0, "ZERO_ASSETS");          beforeWithdraw(assets, shares);          _burn(owner, shares);          // ...          asset.safeTransfer(receiver, assets);     }      function previewDeposit(uint256 assets) public view virtual returns (uint256) {         return convertToShares(assets);     }      function previewRedeem(uint256 shares) public view virtual returns (uint256) {         return convertToAssets(shares);     }      function convertToShares(uint256 assets) public view virtual returns (uint256) {         uint256 supply = totalSupply;           return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());     }      function convertToAssets(uint256 shares) public view virtual returns (uint256) {         uint256 supply = totalSupply;           return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);     } ```  Based on the above rules, there are 2 potential abuse cases: 1. If withdraw just after the `rewardsCycleEnd` timestamp, a user can not get the yields from last rewards cycle. Since the `totalAssets()` only contain `storedTotalAssets` but not the yields part. It takes 1 rewards cycle to linearly add to the `storedTotalAssets`.   Assume per 10,000 asset staking generate yields of 70 for 7 days, and the reward cycle is 1 day. A malicious user Alice can do the following: - watch the mempool for  `withdraw(10,000)` from account Bob, front run it with `syncRewards()`, so that the most recent yields of amount 70 from Bob will stay in the vault.  - Alice will also deposit a 10,000 to take as much shares as possible.  - after 1 rewards cycle of 1 day, `redeem()` to take the yields of 70.   Effectively steal the yields from Bob. The profit for Alice is not 70, because after 1 day, her own deposit also generates some yield, in this example this portion is 1. At the end, Alice steal yield of amount 60.   2. When the Multisig Treasury transfers new yields into the vault, the new yields will accumulate until `syncRewards()` is called. It is possible that yields from multiple rewards cycles accumulates, and being released in the next cycle.  Knowing that the yields has been accumulated for 3 rewards cycles, a malicious user can `deposit()` and call `syncRewards()` to trigger the release of the rewards. `redeem()` after 1 cycle.  Here the malicious user gets yields of 3 cycles, lose 1 in the waiting cycle. The net profit is 2 cycle yields, and the gained yields should belong to the other users in the vault.    ## Tools Used Manual analysis.  ## Recommended Mitigation Steps   - for the `lastRewardAmount` not released, allow the users to redeem as it is linearly released later. - for the accumulated yields, only allow users to redeem the yields received after 1 rewards cycle after the deposit.
# Lines of code  https://github.com/code-423n4/2022-09-frax/blob/main/src/frxETHMinter.sol#L120   # Vulnerability details  ## Impact Frontrunning by malicious validator changing withdrawal credentials  ## Proof of Concept A malicious validator can frontrun depositEther transaction for its pubKey and deposit 1 ether for different withdrawal credential, thereby setting withdrawal credit before deposit of 32 ether by contract and thereby when 32 deposit ether are deposited, the withdrawal credential is also what was set before rather than the one being sent in depositEther transaction  ## Recommended Mitigation Steps Set withdrawal credentials for validator by depositing 1 ether with desired withdrawal credentials, before adding it in Operator Registry
# Lines of code  https://github.com/code-423n4/2022-09-frax/blob/dc6684f77b4e9bd965e8862be7f5fb71473a4c4c/src/frxETHMinter.sol#L129   # Vulnerability details  ## Impact `frxETHMinter.depositEther` always iterates over all deposits that are possible with the current balance (`(address(this).balance - currentWithheldETH) / DEPOSIT_SIZE`). However, when a lot of ETH was deposited into the contract / it was not called in a long time, this loop can reach the gas limit. When this happens, no more calls to `depositEther` are possible, as it will always run out of gas.  Of course, the probability that such a situation arises depends on the price of ETH. For >1,000 USD it would need require someone to deposit a large amount of money (which can also happen, there are whales with thousands of ETH, so if one of them would decide to use frxETH, the problem can arise). For lower prices, it can happen even for small (in dollar terms) deposits. And in general, the correct functionality of a protocol should not depend on the price of ETH.  ## Proof Of Concept Jerome Powell continues to rise interest rates, he just announced the next rate hike to 450%. The crypto market crashes, ETH is at 1 USD. Bob buys 100,000 ETH for 100,000 USD and deposits them into `frxETHMinter`. Because of this deposit, `numDeposit` within `depositEther` is equal to 3125. Therefore, every call to the function runs out of gas and it is not possible to deposit this ETH into the deposit contract.  ## Recommended Mitigation Steps It should be possible to specify an upper limit for the number of deposits such that progress is possible, even when a lot of ETH was deposited into the contract.
# Lines of code  https://github.com/code-423n4/2022-09-frax/blob/dc6684f77b4e9bd965e8862be7f5fb71473a4c4c/src/sfrxETH.sol#L50   # Vulnerability details  ## Impact `sfrxETH.beforeWithdraw` first calls the `beforeWithdraw` of `xERC4626`, which decrements `storedTotalAssets` by the given amount. If the timestamp is greater than the `rewardsCycleEnd`, `syncRewards` is called. However, the problem is that the assets have not been transfered out yet, meaning `asset.balanceOf(address(this))` still has the old value. On the other hand, `storedTotalAssets` was already updated. Therefore, the following calculation will be inflated by the amount for which the withdrawal was requested: ``` uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_; ``` This has severe consequences: 1.) During the following reward period, `lastRewardAmount` is too high, which means that too much rewards are paid out too users who want to withdraw. A user could exploit this to steal the assets of other users. 2.) When `syncRewards()` is called the next time, it is possible that the `nextRewards` calculation underflows because `lastRewardAmount > asset.balanceOf(address(this))`. This is very bad because `syncRewards()` will be called in every withdrawal (after the `rewardsCycleEnd`) and none of them will succeed because of the underflow. Depositing more also does not help here, it just increases `asset.balanceOf(address(this))` and `storedTotalAssets` by the same amount, which does not eliminate the underflow.  Note that this bug does not require a malicious user or a targeted attack to surface. It can (and probably will) happen in practice just by normal user interactions with the vault (which is for instance shown in the PoC).  ## Proof Of Concept Consider the following test: ``` function testTotalAssetsAfterWithdraw() public {                 uint128 deposit = 1 ether;         uint128 withdraw = 1 ether;         // Mint frxETH to this testing contract from nothing, for testing         mintTo(address(this), deposit);          // Generate some sfrxETH to this testing contract using frxETH         frxETHtoken.approve(address(sfrxETHtoken), deposit);         sfrxETHtoken.deposit(deposit, address(this));         require(sfrxETHtoken.totalAssets() == deposit);          vm.warp(block.timestamp + 1000);         // Withdraw frxETH (from sfrxETH) to this testing contract         sfrxETHtoken.withdraw(withdraw, address(this), address(this));         vm.warp(block.timestamp + 1000);         sfrxETHtoken.syncRewards();         require(sfrxETHtoken.totalAssets() == deposit - withdraw);     } ```  This is a normal user interaction where a user deposits into the vault, and makes a withdrawal some time later. However, at this point the `syncRewards()` within the `beforeWithdraw` is executed. Because of that, the documented accounting mistake happens and the next call (in fact every call that will be done in the future) to `syncRewards()` reverts with an underflow.  ## Recommended Mitigation Steps Call `syncRewards()` before decrementing `storedTotalAssets`, i.e.: ``` function beforeWithdraw(uint256 assets, uint256 shares) internal override {  if (block.timestamp >= rewardsCycleEnd) { syncRewards(); }  super.beforeWithdraw(assets, shares); // call xERC4626's beforeWithdraw AFTER } ``` Then, `asset.balanceOf(address(this))` and `storedTotalAssets` are still in sync within `syncRewards()`.
