# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/SemiFungibleVault.sol#L110-L119 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203-L218   # Vulnerability details  *Anyone* can withdraw to `receiver` once the `receiver` is `isApprovedForAll(owner, receiver)`. The funds will be sent to `receiver`, but it will happen whenever an arbitrary `msg.sender` wants. The only precondition is the presence of any approvals.  This can be easily used to sabotage the system as a whole. Say there are two depositors in the hedge Vault, Bob and David, both trust each other and approved each other. Mike the attacker observing the coming end of epoch where no depeg happened, calls the withdraw() for both Bob and David in the last block of the epoch. Mike gained nothing, while both Bob and David lost the payoff that was guaranteed for them at this point.  Setting the severity to be high as this can be routinely used to sabotage the y2k users, both risk and hedge, depriving them from the payouts whenever they happen to be on the winning side. Usual attackers here can be the users from the another side, risk users attacking hedge vault, and vice versa.  ## Proof of Concept  isApprovedForAll() in withdrawal functions checks the `receiver` to be approved, not the caller.  SemiFungibleVault's withdraw:  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/SemiFungibleVault.sol#L110-L119  ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     ) external virtual returns (uint256 shares) {         require(             msg.sender == owner || isApprovedForAll(owner, receiver),             "Only owner can withdraw, or owner has approved receiver for all"         ); ```  Vault's withdraw:  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203-L218  ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     )         external         override         epochHasEnded(id)         marketExists(id)         returns (uint256 shares)     {         if(             msg.sender != owner &&             isApprovedForAll(owner, receiver) == false)             revert OwnerDidNotAuthorize(msg.sender, owner); ```  This way anyone at any time can run withdraw from the Vaults whenever owner has some address approved.  ## Recommended Mitigation Steps  Consider changing the approval requirement to be for the caller, not receiver:  SemiFungibleVault's withdraw:  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/SemiFungibleVault.sol#L110-L119  ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     ) external virtual returns (uint256 shares) {         require( -           msg.sender == owner || isApprovedForAll(owner, receiver), +           msg.sender == owner || isApprovedForAll(owner, msg.sender),             "Only owner can withdraw, or owner has approved receiver for all"         ); ```  Vault's withdraw:  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203-L218  ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     )         external         override         epochHasEnded(id)         marketExists(id)         returns (uint256 shares)     {         if(             msg.sender != owner && -           isApprovedForAll(owner, receiver) == false) +           isApprovedForAll(owner, msg.sender) == false)             revert OwnerDidNotAuthorize(msg.sender, owner); ```  
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L378-L426 https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L203-L234   # Vulnerability details  ## Impact In the following `beforeWithdraw` function, `entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(idClaimTVL[id], 1 ether)` can be executed in several places. Because it uses division before multiplication, it is possible that `entitledAmount` is calculated to be 0. As the `withdraw` function shows below, when `entitledAmount` is 0, the receiver and treasury both receive 0. As a result, calling `withdraw` with a positive `assets` input can still result in transferring nothing to the receiver and treasury.  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L378-L426 ```solidity     function beforeWithdraw(uint256 id, uint256 amount)         public         view         returns (uint256 entitledAmount)     {         // in case the risk wins aka no depeg event         // risk users can withdraw the hedge (that is paid by the hedge buyers) and risk; withdraw = (risk + hedge)         // hedge pay for each hedge seller = ( risk / tvl before the hedge payouts ) * tvl in hedge pool         // in case there is a depeg event, the risk users can only withdraw the hedge         if (             keccak256(abi.encodePacked(symbol)) ==             keccak256(abi.encodePacked("rY2K"))         ) {             if (!idDepegged[id]) {                 //depeg event did not happen                 /*                 entitledAmount =                     (amount / idFinalTVL[id]) *                     idClaimTVL[id] +                     amount;                 */                 entitledAmount =                     amount.divWadDown(idFinalTVL[id]).mulDivDown(                         idClaimTVL[id],                         1 ether                     ) +                     amount;             } else {                 //depeg event did happen                 entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(                     idClaimTVL[id],                     1 ether                 );             }         }         // in case the hedge wins aka depegging         // hedge users pay the hedge to risk users anyway,         // hedge guy can withdraw risk (that is transfered from the risk pool),         // withdraw = % tvl that hedge buyer owns         // otherwise hedge users cannot withdraw any Eth         else {             entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(                 idClaimTVL[id],                 1 ether             );         }          return entitledAmount;     } ```  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L203-L234 ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     )         external         override         epochHasEnded(id)         marketExists(id)         returns (uint256 shares)     {         if(             msg.sender != owner &&             isApprovedForAll(owner, receiver) == false)             revert OwnerDidNotAuthorize(msg.sender, owner);          shares = previewWithdraw(id, assets); // No need to check for rounding error, previewWithdraw rounds up.          uint256 entitledShares = beforeWithdraw(id, shares);         _burn(owner, id, shares);          //Taking fee from the amount         uint256 feeValue = calculateWithdrawalFeeValue(entitledShares, id);         entitledShares = entitledShares - feeValue;         asset.transfer(treasury, feeValue);          emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);         asset.transfer(receiver, entitledShares);          return entitledShares;     } ```  ## Proof of Concept Please append the following test in `test\AssertTest.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     function testReceiveZeroDueToDivBeingPerformedBeforeMul() public {         vm.deal(alice, 1e24);         vm.deal(chad, 1e24);          vm.startPrank(admin);         FakeOracle fakeOracle = new FakeOracle(oracleFRAX, STRIKE_PRICE_FAKE_ORACLE);         vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, address(fakeOracle), "y2kFRAX_99*");         vm.stopPrank();          address hedge = vaultFactory.getVaults(1)[0];         address risk = vaultFactory.getVaults(1)[1];                  Vault vHedge = Vault(hedge);         Vault vRisk = Vault(risk);          // alice deposits 1e24 in hedge vault         vm.startPrank(alice);         ERC20(WETH).approve(hedge, 1e24);         vHedge.depositETH{value: 1e24}(endEpoch, alice);         vm.stopPrank();          // chad deposits 1e24 in risk vault         vm.startPrank(chad);         ERC20(WETH).approve(risk, 1e24);         vRisk.depositETH{value: 1e24}(endEpoch, chad);         vm.stopPrank();          vm.warp(beginEpoch + 10 days);          // depeg occurs         controller.triggerDepeg(SINGLE_MARKET_INDEX, endEpoch);          vm.startPrank(chad);          // chad withdraws 1e5 from risk vault         vRisk.withdraw(endEpoch, 1e5, chad, chad);          // the amount to chad is 0 because division is performed before multiplication         uint256 entitledShares = vRisk.beforeWithdraw(endEpoch, 1e5);          // chad receives nothing         assertEq(entitledShares, 0);         assertEq(ERC20(WETH).balanceOf(chad), 0);          // the amount to chad would be positive when multiplication is performed before division         uint256 entitledShares2 = (1e5 * vRisk.idClaimTVL(endEpoch)) / vRisk.idFinalTVL(endEpoch);         assertTrue(entitledShares2 > entitledShares);          vm.stopPrank();     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps `entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(idClaimTVL[id], 1 ether)` in the `beforeWithdraw` function can be updated to the following code. ```solidity     entitledAmount = (amount * idClaimTVL[id]) / idFinalTVL[id] ```
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L198-L248 https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L59-L64   # Vulnerability details  ## Impact When calling the following `triggerEndEpoch` function, `tvl`, which is a `VaultTVL` type, is created as a part of the emitted `DepegInsurance` `event` after `idClaimTVL` and `idFinalTVL` are already updated for both the hedge and risk vaults. However, comparing to the fields of the `VaultTVL` `struct` definition below, `insrVault.idClaimTVL(epochEnd)` is incorrectly used as `RISK_finalTVL` and `riskVault.idFinalTVL(epochEnd)` is incorrectly used as `INSR_claimTVL` because `insrVault.setClaimTVL(epochEnd, 0)` has been executed, which does not occur when calling the `triggerDepeg` function. Because of the incorrect `tvl` used in the emitted `DepegInsurance` `event`, the frontend can display misleading information that confuse users, and debugging with incorrect data will be hard for developers.  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L198-L248 ```solidity     function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {         if(             vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)                 revert MarketDoesNotExist(marketIndex);         if(             block.timestamp < epochEnd)             revert EpochNotExpired();          address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);          Vault insrVault = Vault(vaultsAddress[0]);         Vault riskVault = Vault(vaultsAddress[1]);          if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)             revert EpochNotExist();          //require this function cannot be called twice in the same epoch for the same vault         if(insrVault.idFinalTVL(epochEnd) != 0)             revert NotZeroTVL();         if(riskVault.idFinalTVL(epochEnd) != 0)              revert NotZeroTVL();          insrVault.endEpoch(epochEnd, false);         riskVault.endEpoch(epochEnd, false);          insrVault.setClaimTVL(epochEnd, 0);         riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));         insrVault.sendTokens(epochEnd, address(riskVault));          VaultTVL memory tvl = VaultTVL(             riskVault.idClaimTVL(epochEnd),             insrVault.idClaimTVL(epochEnd),             riskVault.idFinalTVL(epochEnd),             insrVault.idFinalTVL(epochEnd)         );          emit DepegInsurance(             keccak256(                 abi.encodePacked(                     marketIndex,                     insrVault.idEpochBegin(epochEnd),                     epochEnd                 )             ),             tvl,             false,             epochEnd,             block.timestamp,             getLatestPrice(insrVault.tokenInsured())         );     } ```  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L59-L64 ```solidity     struct VaultTVL {         uint256 RISK_claimTVL;         uint256 RISK_finalTVL;         uint256 INSR_claimTVL;         uint256 INSR_finalTVL;     } ```  ## Proof of Concept Please append the following test in `test\AssertTest.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     function testCallingtriggerEndEpochCreatesIncorrectVaultTVL() public{         testDeposit();          address hedge = vaultFactory.getVaults(1)[0];         address risk = vaultFactory.getVaults(1)[1];          Vault vHedge = Vault(hedge);         Vault vRisk = Vault(risk);          vm.warp(endEpoch + 1 days);          controller.triggerEndEpoch(SINGLE_MARKET_INDEX, endEpoch);          /* VaultTVL struct has the following structure              struct VaultTVL {                 uint256 RISK_claimTVL;                 uint256 RISK_finalTVL;                 uint256 INSR_claimTVL;                 uint256 INSR_finalTVL;             }          */          /* in controller.triggerEndEpoch, VaultTVL is created as follows after idClaimTVL and idFinalTVL for both vaults are already updated              VaultTVL memory tvl = VaultTVL(                 riskVault.idClaimTVL(epochEnd),                 insrVault.idClaimTVL(epochEnd),                 riskVault.idFinalTVL(epochEnd),                 insrVault.idFinalTVL(epochEnd)             );          */          // insrVault.idClaimTVL(epochEnd), which is vHedge.idClaimTVL(endEpoch), does not correspond to RISK_finalTVL, which should be vRisk.idFinalTVL(endEpoch)         assertTrue(vRisk.idFinalTVL(endEpoch) != vHedge.idClaimTVL(endEpoch));          // riskVault.idFinalTVL(epochEnd), which is vRisk.idFinalTVL(endEpoch), does not correspond to INSR_claimTVL, which should be vHedge.idClaimTVL(endEpoch)          assertTrue(vHedge.idClaimTVL(endEpoch) != vRisk.idFinalTVL(endEpoch));     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L227-L232 can be updated to the following code. ```solidity         VaultTVL memory tvl = VaultTVL(             riskVault.idClaimTVL(epochEnd),             riskVault.idFinalTVL(epochEnd),             insrVault.idClaimTVL(epochEnd),             insrVault.idFinalTVL(epochEnd)         ); ```
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L246 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L277-L286 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203   # Vulnerability details  ## Impact At the end of an epoch, the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) is called to trigger 'epoch end without depeg event', making risk users the winners and entitling them to [withdraw](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203) (risk + hedge) from the vault. In the case of the Arbitrum sequencer going down or restarting, there is a [grace period of one hour](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L285) before the [getLatestPrice()](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261) returns to execute without reverting. This means that the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) cannot complete during this time, because it calls the [getLatestPrice()](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261).  Making this high-priority because unless the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) completes: - winners cannot [withdraw](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203) althought the epoch is over; - during this time the strike price might be reached causing a depeg event at all effects turning the table for the winners; - the [getLatestPrice()](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261) is not functional to the completion of the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198), nor to the [withdraw](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203), but only informative used to initialize the event object emitted [at the very end of the triggerEndEpoch function](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L246).  First two points each constitute independent jsutification, thrid point reinforces the first 2 points.   ## Proof of Concept  ### triggerEndEpoch reverts if arbiter down or restarted less than eq GRACE_PERIOD_TIME ago (1hr)  File: [Controller.sol:L246](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L246)  Revert if getLatestPrice reverts.  ```solidity function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {          < ... omitted ... >      emit DepegInsurance(         keccak256(             abi.encodePacked(                 marketIndex,                 insrVault.idEpochBegin(epochEnd),                 epochEnd             )         ),         tvl,         false,         epochEnd,         block.timestamp,         getLatestPrice(insrVault.tokenInsured()) // @audit getLatestPrice reverts while sequencer unavailable or during grace period     ); } ```  File: [Controller.sol:L277-L286](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L277-L286)  Revert if sequencer down or grace period after restart not over.  ```solidity function getLatestPrice(address _token)     public     view     returns (int256 nowPrice) {     < ... omitted ... >      bool isSequencerUp = answer == 0;     if (!isSequencerUp) {         revert SequencerDown();     }      // Make sure the grace period has passed after the sequencer is back up.     uint256 timeSinceUp = block.timestamp - startedAt;     if (timeSinceUp <= GRACE_PERIOD_TIME) { // @audit 1 hour         revert GracePeriodNotOver();     }      < ... omitted ... > } ```  ### withdraw fails if triggerEndEpoch did not execute successfully  File: [Vault.sol:L203](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203)  Can execute if block.timestamp > epochEnd, but fails if trigger did not execute. Winners cannot withdraw.  ```solidity function withdraw(     uint256 id,     uint256 assets,     address receiver,     address owner )     external     override     epochHasEnded(id) // @audit same as require((block.timestamp > id) || idDepegged[id]), hence independent from triggers.     marketExists(id)     returns (uint256 shares) {     < ... omitted ... >      uint256 entitledShares = beforeWithdraw(id, shares); // @audit ratio is idClaimTVL[id]/ifFinalTVL[id], hence zero unless triggers executed          < ... omitted ... >      emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);     asset.transfer(receiver, entitledShares);      return entitledShares; } ```  ## Tools Used n/a  ## Recommended Mitigation Steps  The latest price is retrieved at the very end of the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) for the only purpose of initializing the DepegInsurance event.  Since it is used for informational purpose (logging / offchain logging) and not for functional purpose to the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) execution, it can be relaxed.   Depending on how the event is used, when getLatestPrice() is called for informative/logging purpose only, there could be few alternatives: - log a 0 when SequencerDown or GRACE_PERIOD_TIME not passed - log a 0 when SequencerDown and ignore GRACE_PERIOD_TIME  Once events are logged off-chain, some post processing may be used to correct/update the values with accurate data.
# Lines of code   https://github.com/code-423n4/2022-09-y2k-finance/blob/bca5080635370424a9fe21fe1aded98345d1f723/src/VaultFactory.sol#L157 https://github.com/code-423n4/2022-09-y2k-finance/blob/bca5080635370424a9fe21fe1aded98345d1f723/src/VaultFactory.sol#L163-L374   # Vulnerability details  # Immutable address owner is risky in `VaultFactory.sol` ### Impact The following contracts and functions, allow admins to interact with core functions such as:  `VaultFactory.sol` functions for:   - createNewMarket   - deployMoreAssets   - setController   - changeTreasury   - changeTimewindow   - changeController   - changeOracle  Given that `admin` is immutable it's very risky because it is irrecoverable from any mistakes  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the `onlyAdmin()` functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately.   When noticed, due to a failing `onlyAdmin()` function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.  ### Github Permalinks https://github.com/code-423n4/2022-09-y2k-finance/blob/bca5080635370424a9fe21fe1aded98345d1f723/src/VaultFactory.sol#L157  - Admin functions affected https://github.com/code-423n4/2022-09-y2k-finance/blob/bca5080635370424a9fe21fe1aded98345d1f723/src/VaultFactory.sol#L163-L374  ### Recommended steps Recommend remove immutable from admin address. Also taking care while deploying the contract / emitting an event when assigning _admin so in case it is wrongly deployed, it can be redeployed earlier. Finally adding a 2 steps transfer from admin for cases when admin needs to be migrate to another address.    
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/oracles/PegOracle.sol#L46-L83 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L299-L300   # Vulnerability details  ## Impact Wrong maths for handling pricefeed decimals. This code will only work for pricefeeds of 8 decimals, any others give wrong/incorrect data. The maths used can be shown in three lines:  ```solidity nowPrice = (price1 * 10000) / price2; nowPrice = nowPrice * int256(10**(18 - priceFeed1.decimals())); return nowPrice / 1000000; ```  Line1: adds 4 decimals Line2: adds (18 - d) decimals, (where d = pricefeed.decimals()) Line3:  removes 6 decimals  Total: adds (16 - d) decimals  when d=8, the contract correctly returns an 8 decimal number. However, when d = 6, the function will return a 10 decimal number. This is further raised by (18-d = 12) decimals when checking for depeg event, leading to a 22 decimal number which is 4 orders of magnitude incorrect.  if d=18, (like usd-eth pricefeeds) contract fails / returns 0.  All chainlink contracts which give price in eth, operate with 18 decimals. So this can cripple the system if added later.  ## Proof of Concept Running the test  AssertTest.t.sol:testPegOracleMarketCreation and changing the line on  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/test/AssertTest.t.sol#L30  to ```solidity PegOracle pegOracle3 = new PegOracle(             0xB1552C5e96B312d0Bf8b554186F846C40614a540,  //usd-eth contract address             btcEthOracle         ); ``` gives this output  ``` oracle3price1: 1085903802394919427                                                                                                                                                                                oracle3price2: 13753840915281064000                                                                                                                                                                               oracle3price1 / oracle3price2: 0 ```  returning an oracle value of 0. Simulating with a mock price feed of 6 decimals gives results 4 orders of magnitude off.  ## Tools Used Foundry, vs-code  ## Recommended Mitigation Steps Since only the price ratio is calculated, there is no point in increasing the decimal by (18-d) in the second line. Proposed solution: ```solidity nowPrice = (price1 * 10000) / price2; nowPrice = nowPrice * int256(10**(priceFeed1.decimals())) * 100; return nowPrice / 1000000; ``` This returns results in d decimals, no matter the value of d. 
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L96   # Vulnerability details  ## Impact Depeg event can still happen when the price of a pegged asset is equal to the strike price of a Vault which is incorrect.   This docs clearly mentions:  "When the price of a pegged asset is below the strike price of a Vault, a Keeper(could be anyone) will trigger the depeg event and both Vaults(hedge and risk) will swap their total assets with the other party." - https://code4rena.com/contests/2022-09-y2k-finance-contest  ## Proof of Concept  1. Assume strike price of vault is 1 and current price of pegged asset is also 1  2. User calls [triggerDepeg](https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L148) function which calls isDisaster modifier to check the depeg eligibility  3. Now lets see [isDisaster](https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L83) modifier  ``` modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {         address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);         if(             vaultsAddress.length != VAULTS_LENGTH             )             revert MarketDoesNotExist(marketIndex);          address vaultAddress = vaultsAddress[0];         Vault vault = Vault(vaultAddress);          if(vault.idExists(epochEnd) == false)             revert EpochNotExist();          if(             vault.strikePrice() < getLatestPrice(vault.tokenInsured())             )             revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));          if(             vault.idEpochBegin(epochEnd) > block.timestamp)             revert EpochNotStarted();          if(             block.timestamp > epochEnd             )             revert EpochExpired();         _;     } ```  4. Assume block.timestamp is at correct timestamp (between idEpochBegin and epochEnd), so none of revert execute. Lets look into the interesting one at  ```         if(             vault.strikePrice() < getLatestPrice(vault.tokenInsured())             )             revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured())); ```  5. Since in our case price of vault=price of pegged asset so if condition does not execute and finally isDisaster completes without any revert meaning go ahead of depeg  6. But this is incorrect since price is still not below strike price and is just equal  ## Recommended Mitigation Steps Change the isDisaster modifier to revert when price of a pegged asset is equal to the strike price of a Vault  ``` if(             vault.strikePrice() <= getLatestPrice(vault.tokenInsured())             )             revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured())); ```
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/oracles/PegOracle.sol#L63 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/Controller.sol#L308 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/oracles/PegOracle.sol#L126   # Vulnerability details  ## Impact Different problems have been found with the use of the oracle that can incur economic losses when the oracle is not consumed in a completely safe way.  ## Proof of Concept  Thre problems found are:  - The `timeStamp` check is not correct since in both cases it is done against 0, which would mean that a date of 2 years ago would be valid, so old prices can be taken.  ```javascript     function getLatestPrice(address _token)         public         view         returns (int256 nowPrice)     {         ...         if(timeStamp == 0)             revert TimestampZero();         return price;     } ```  - Oracle price 1 can be outdated:  The `latestRoundData` method of the `PegOracle` contract calls `priceFeed1.latestRoundData();` directly, but does not perform the necessary round or timestamp checks, and delegates them to the caller, but these checks are performed on price2 because it calls `getOracle2_Price` in this case, this inconsistency between how it take the price1 and price2 behaves favors human errors when consuming the oracle.  ## Recommended Mitigation Steps  For the timestamp issue, it should be checked like this:  ```diff +   uint constant observationFrequency = 1 hours;      function getLatestPrice(address _token)         public         view         returns (int256 nowPrice)     {         ...         (             uint80 roundID,             int256 price,             ,             uint256 timeStamp,             uint80 answeredInRound         ) = priceFeed.latestRoundData();          uint256 decimals = 10**(18-(priceFeed.decimals()));         price = price * int256(decimals);          if(price <= 0)             revert OraclePriceZero();          if(answeredInRound < roundID)             revert RoundIDOutdated();  -       if(timeStamp == 0) +       if(timeStamp < block.timestamp - uint256(observationFrequency))             revert TimestampZero();          return price;     } ```   
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/Vault.sol#L244-L252 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L205-L213 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L237-L239 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L244-L246 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L251-L258 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L263-L270   # Vulnerability details  ## Impact  Other protocols that integrate with Y2K may wrongly assume that the functions are EIP-4626 compliant. Thus, it might cause integration problems in the future that can lead to wide range of issues for both parties.   ## Proof of Concept  All official EIP-4626 requirements can be found on it's [official page](https://eips.ethereum.org/EIPS/eip-4626#methods). Non-compliant functions are listed below along with the reason they are not compliant:  The following functions are missing but should be present: 1. mint(uint256, address) returns (uint256) 2. redeem(uint256, address, address) returns (uint256)  The following functions are non-compliant because they don't account for withdraw and deposit locking: 1. maxDeposit 2. maxMint 3. maxWithdraw 4. maxRedeem  All of the above functions should return 0 when their respective functions are disabled (i.e. maxDeposit should return 0 when deposits are disabled)  previewDeposit is not compliant because it must account for fees which it does not  totalAssets is not compliant because it does not always return the underlying managed by the vault because it fails to include the assets paid out during a depeg or the end of the epoch.  ## Tools Used  ## Recommended Mitigation Steps  All functions listed above should be modified to meet the specifications of EIP-4626
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/SemiFungibleVault.sol#L110-L119 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203-L218   # Vulnerability details  *Anyone* can withdraw to `receiver` once the `receiver` is `isApprovedForAll(owner, receiver)`. The funds will be sent to `receiver`, but it will happen whenever an arbitrary `msg.sender` wants. The only precondition is the presence of any approvals.  This can be easily used to sabotage the system as a whole. Say there are two depositors in the hedge Vault, Bob and David, both trust each other and approved each other. Mike the attacker observing the coming end of epoch where no depeg happened, calls the withdraw() for both Bob and David in the last block of the epoch. Mike gained nothing, while both Bob and David lost the payoff that was guaranteed for them at this point.  Setting the severity to be high as this can be routinely used to sabotage the y2k users, both risk and hedge, depriving them from the payouts whenever they happen to be on the winning side. Usual attackers here can be the users from the another side, risk users attacking hedge vault, and vice versa.  ## Proof of Concept  isApprovedForAll() in withdrawal functions checks the `receiver` to be approved, not the caller.  SemiFungibleVault's withdraw:  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/SemiFungibleVault.sol#L110-L119  ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     ) external virtual returns (uint256 shares) {         require(             msg.sender == owner || isApprovedForAll(owner, receiver),             "Only owner can withdraw, or owner has approved receiver for all"         ); ```  Vault's withdraw:  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203-L218  ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     )         external         override         epochHasEnded(id)         marketExists(id)         returns (uint256 shares)     {         if(             msg.sender != owner &&             isApprovedForAll(owner, receiver) == false)             revert OwnerDidNotAuthorize(msg.sender, owner); ```  This way anyone at any time can run withdraw from the Vaults whenever owner has some address approved.  ## Recommended Mitigation Steps  Consider changing the approval requirement to be for the caller, not receiver:  SemiFungibleVault's withdraw:  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/SemiFungibleVault.sol#L110-L119  ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     ) external virtual returns (uint256 shares) {         require( -           msg.sender == owner || isApprovedForAll(owner, receiver), +           msg.sender == owner || isApprovedForAll(owner, msg.sender),             "Only owner can withdraw, or owner has approved receiver for all"         ); ```  Vault's withdraw:  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203-L218  ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     )         external         override         epochHasEnded(id)         marketExists(id)         returns (uint256 shares)     {         if(             msg.sender != owner && -           isApprovedForAll(owner, receiver) == false) +           isApprovedForAll(owner, msg.sender) == false)             revert OwnerDidNotAuthorize(msg.sender, owner); ```  
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L378-L426 https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L203-L234   # Vulnerability details  ## Impact In the following `beforeWithdraw` function, `entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(idClaimTVL[id], 1 ether)` can be executed in several places. Because it uses division before multiplication, it is possible that `entitledAmount` is calculated to be 0. As the `withdraw` function shows below, when `entitledAmount` is 0, the receiver and treasury both receive 0. As a result, calling `withdraw` with a positive `assets` input can still result in transferring nothing to the receiver and treasury.  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L378-L426 ```solidity     function beforeWithdraw(uint256 id, uint256 amount)         public         view         returns (uint256 entitledAmount)     {         // in case the risk wins aka no depeg event         // risk users can withdraw the hedge (that is paid by the hedge buyers) and risk; withdraw = (risk + hedge)         // hedge pay for each hedge seller = ( risk / tvl before the hedge payouts ) * tvl in hedge pool         // in case there is a depeg event, the risk users can only withdraw the hedge         if (             keccak256(abi.encodePacked(symbol)) ==             keccak256(abi.encodePacked("rY2K"))         ) {             if (!idDepegged[id]) {                 //depeg event did not happen                 /*                 entitledAmount =                     (amount / idFinalTVL[id]) *                     idClaimTVL[id] +                     amount;                 */                 entitledAmount =                     amount.divWadDown(idFinalTVL[id]).mulDivDown(                         idClaimTVL[id],                         1 ether                     ) +                     amount;             } else {                 //depeg event did happen                 entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(                     idClaimTVL[id],                     1 ether                 );             }         }         // in case the hedge wins aka depegging         // hedge users pay the hedge to risk users anyway,         // hedge guy can withdraw risk (that is transfered from the risk pool),         // withdraw = % tvl that hedge buyer owns         // otherwise hedge users cannot withdraw any Eth         else {             entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(                 idClaimTVL[id],                 1 ether             );         }          return entitledAmount;     } ```  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L203-L234 ```solidity     function withdraw(         uint256 id,         uint256 assets,         address receiver,         address owner     )         external         override         epochHasEnded(id)         marketExists(id)         returns (uint256 shares)     {         if(             msg.sender != owner &&             isApprovedForAll(owner, receiver) == false)             revert OwnerDidNotAuthorize(msg.sender, owner);          shares = previewWithdraw(id, assets); // No need to check for rounding error, previewWithdraw rounds up.          uint256 entitledShares = beforeWithdraw(id, shares);         _burn(owner, id, shares);          //Taking fee from the amount         uint256 feeValue = calculateWithdrawalFeeValue(entitledShares, id);         entitledShares = entitledShares - feeValue;         asset.transfer(treasury, feeValue);          emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);         asset.transfer(receiver, entitledShares);          return entitledShares;     } ```  ## Proof of Concept Please append the following test in `test\AssertTest.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     function testReceiveZeroDueToDivBeingPerformedBeforeMul() public {         vm.deal(alice, 1e24);         vm.deal(chad, 1e24);          vm.startPrank(admin);         FakeOracle fakeOracle = new FakeOracle(oracleFRAX, STRIKE_PRICE_FAKE_ORACLE);         vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, address(fakeOracle), "y2kFRAX_99*");         vm.stopPrank();          address hedge = vaultFactory.getVaults(1)[0];         address risk = vaultFactory.getVaults(1)[1];                  Vault vHedge = Vault(hedge);         Vault vRisk = Vault(risk);          // alice deposits 1e24 in hedge vault         vm.startPrank(alice);         ERC20(WETH).approve(hedge, 1e24);         vHedge.depositETH{value: 1e24}(endEpoch, alice);         vm.stopPrank();          // chad deposits 1e24 in risk vault         vm.startPrank(chad);         ERC20(WETH).approve(risk, 1e24);         vRisk.depositETH{value: 1e24}(endEpoch, chad);         vm.stopPrank();          vm.warp(beginEpoch + 10 days);          // depeg occurs         controller.triggerDepeg(SINGLE_MARKET_INDEX, endEpoch);          vm.startPrank(chad);          // chad withdraws 1e5 from risk vault         vRisk.withdraw(endEpoch, 1e5, chad, chad);          // the amount to chad is 0 because division is performed before multiplication         uint256 entitledShares = vRisk.beforeWithdraw(endEpoch, 1e5);          // chad receives nothing         assertEq(entitledShares, 0);         assertEq(ERC20(WETH).balanceOf(chad), 0);          // the amount to chad would be positive when multiplication is performed before division         uint256 entitledShares2 = (1e5 * vRisk.idClaimTVL(endEpoch)) / vRisk.idFinalTVL(endEpoch);         assertTrue(entitledShares2 > entitledShares);          vm.stopPrank();     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps `entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(idClaimTVL[id], 1 ether)` in the `beforeWithdraw` function can be updated to the following code. ```solidity     entitledAmount = (amount * idClaimTVL[id]) / idFinalTVL[id] ```
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L198-L248 https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L59-L64   # Vulnerability details  ## Impact When calling the following `triggerEndEpoch` function, `tvl`, which is a `VaultTVL` type, is created as a part of the emitted `DepegInsurance` `event` after `idClaimTVL` and `idFinalTVL` are already updated for both the hedge and risk vaults. However, comparing to the fields of the `VaultTVL` `struct` definition below, `insrVault.idClaimTVL(epochEnd)` is incorrectly used as `RISK_finalTVL` and `riskVault.idFinalTVL(epochEnd)` is incorrectly used as `INSR_claimTVL` because `insrVault.setClaimTVL(epochEnd, 0)` has been executed, which does not occur when calling the `triggerDepeg` function. Because of the incorrect `tvl` used in the emitted `DepegInsurance` `event`, the frontend can display misleading information that confuse users, and debugging with incorrect data will be hard for developers.  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L198-L248 ```solidity     function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {         if(             vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)                 revert MarketDoesNotExist(marketIndex);         if(             block.timestamp < epochEnd)             revert EpochNotExpired();          address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);          Vault insrVault = Vault(vaultsAddress[0]);         Vault riskVault = Vault(vaultsAddress[1]);          if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)             revert EpochNotExist();          //require this function cannot be called twice in the same epoch for the same vault         if(insrVault.idFinalTVL(epochEnd) != 0)             revert NotZeroTVL();         if(riskVault.idFinalTVL(epochEnd) != 0)              revert NotZeroTVL();          insrVault.endEpoch(epochEnd, false);         riskVault.endEpoch(epochEnd, false);          insrVault.setClaimTVL(epochEnd, 0);         riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));         insrVault.sendTokens(epochEnd, address(riskVault));          VaultTVL memory tvl = VaultTVL(             riskVault.idClaimTVL(epochEnd),             insrVault.idClaimTVL(epochEnd),             riskVault.idFinalTVL(epochEnd),             insrVault.idFinalTVL(epochEnd)         );          emit DepegInsurance(             keccak256(                 abi.encodePacked(                     marketIndex,                     insrVault.idEpochBegin(epochEnd),                     epochEnd                 )             ),             tvl,             false,             epochEnd,             block.timestamp,             getLatestPrice(insrVault.tokenInsured())         );     } ```  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L59-L64 ```solidity     struct VaultTVL {         uint256 RISK_claimTVL;         uint256 RISK_finalTVL;         uint256 INSR_claimTVL;         uint256 INSR_finalTVL;     } ```  ## Proof of Concept Please append the following test in `test\AssertTest.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     function testCallingtriggerEndEpochCreatesIncorrectVaultTVL() public{         testDeposit();          address hedge = vaultFactory.getVaults(1)[0];         address risk = vaultFactory.getVaults(1)[1];          Vault vHedge = Vault(hedge);         Vault vRisk = Vault(risk);          vm.warp(endEpoch + 1 days);          controller.triggerEndEpoch(SINGLE_MARKET_INDEX, endEpoch);          /* VaultTVL struct has the following structure              struct VaultTVL {                 uint256 RISK_claimTVL;                 uint256 RISK_finalTVL;                 uint256 INSR_claimTVL;                 uint256 INSR_finalTVL;             }          */          /* in controller.triggerEndEpoch, VaultTVL is created as follows after idClaimTVL and idFinalTVL for both vaults are already updated              VaultTVL memory tvl = VaultTVL(                 riskVault.idClaimTVL(epochEnd),                 insrVault.idClaimTVL(epochEnd),                 riskVault.idFinalTVL(epochEnd),                 insrVault.idFinalTVL(epochEnd)             );          */          // insrVault.idClaimTVL(epochEnd), which is vHedge.idClaimTVL(endEpoch), does not correspond to RISK_finalTVL, which should be vRisk.idFinalTVL(endEpoch)         assertTrue(vRisk.idFinalTVL(endEpoch) != vHedge.idClaimTVL(endEpoch));          // riskVault.idFinalTVL(epochEnd), which is vRisk.idFinalTVL(endEpoch), does not correspond to INSR_claimTVL, which should be vHedge.idClaimTVL(endEpoch)          assertTrue(vHedge.idClaimTVL(endEpoch) != vRisk.idFinalTVL(endEpoch));     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L227-L232 can be updated to the following code. ```solidity         VaultTVL memory tvl = VaultTVL(             riskVault.idClaimTVL(epochEnd),             riskVault.idFinalTVL(epochEnd),             insrVault.idClaimTVL(epochEnd),             insrVault.idFinalTVL(epochEnd)         ); ```
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L246 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L277-L286 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203   # Vulnerability details  ## Impact At the end of an epoch, the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) is called to trigger 'epoch end without depeg event', making risk users the winners and entitling them to [withdraw](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203) (risk + hedge) from the vault. In the case of the Arbitrum sequencer going down or restarting, there is a [grace period of one hour](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L285) before the [getLatestPrice()](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261) returns to execute without reverting. This means that the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) cannot complete during this time, because it calls the [getLatestPrice()](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261).  Making this high-priority because unless the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) completes: - winners cannot [withdraw](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203) althought the epoch is over; - during this time the strike price might be reached causing a depeg event at all effects turning the table for the winners; - the [getLatestPrice()](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L261) is not functional to the completion of the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198), nor to the [withdraw](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203), but only informative used to initialize the event object emitted [at the very end of the triggerEndEpoch function](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L246).  First two points each constitute independent jsutification, thrid point reinforces the first 2 points.   ## Proof of Concept  ### triggerEndEpoch reverts if arbiter down or restarted less than eq GRACE_PERIOD_TIME ago (1hr)  File: [Controller.sol:L246](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L246)  Revert if getLatestPrice reverts.  ```solidity function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {          < ... omitted ... >      emit DepegInsurance(         keccak256(             abi.encodePacked(                 marketIndex,                 insrVault.idEpochBegin(epochEnd),                 epochEnd             )         ),         tvl,         false,         epochEnd,         block.timestamp,         getLatestPrice(insrVault.tokenInsured()) // @audit getLatestPrice reverts while sequencer unavailable or during grace period     ); } ```  File: [Controller.sol:L277-L286](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L277-L286)  Revert if sequencer down or grace period after restart not over.  ```solidity function getLatestPrice(address _token)     public     view     returns (int256 nowPrice) {     < ... omitted ... >      bool isSequencerUp = answer == 0;     if (!isSequencerUp) {         revert SequencerDown();     }      // Make sure the grace period has passed after the sequencer is back up.     uint256 timeSinceUp = block.timestamp - startedAt;     if (timeSinceUp <= GRACE_PERIOD_TIME) { // @audit 1 hour         revert GracePeriodNotOver();     }      < ... omitted ... > } ```  ### withdraw fails if triggerEndEpoch did not execute successfully  File: [Vault.sol:L203](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Vault.sol#L203)  Can execute if block.timestamp > epochEnd, but fails if trigger did not execute. Winners cannot withdraw.  ```solidity function withdraw(     uint256 id,     uint256 assets,     address receiver,     address owner )     external     override     epochHasEnded(id) // @audit same as require((block.timestamp > id) || idDepegged[id]), hence independent from triggers.     marketExists(id)     returns (uint256 shares) {     < ... omitted ... >      uint256 entitledShares = beforeWithdraw(id, shares); // @audit ratio is idClaimTVL[id]/ifFinalTVL[id], hence zero unless triggers executed          < ... omitted ... >      emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);     asset.transfer(receiver, entitledShares);      return entitledShares; } ```  ## Tools Used n/a  ## Recommended Mitigation Steps  The latest price is retrieved at the very end of the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) for the only purpose of initializing the DepegInsurance event.  Since it is used for informational purpose (logging / offchain logging) and not for functional purpose to the [triggerEndEpoch(...)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L198) execution, it can be relaxed.   Depending on how the event is used, when getLatestPrice() is called for informative/logging purpose only, there could be few alternatives: - log a 0 when SequencerDown or GRACE_PERIOD_TIME not passed - log a 0 when SequencerDown and ignore GRACE_PERIOD_TIME  Once events are logged off-chain, some post processing may be used to correct/update the values with accurate data.
# Lines of code   https://github.com/code-423n4/2022-09-y2k-finance/blob/bca5080635370424a9fe21fe1aded98345d1f723/src/VaultFactory.sol#L157 https://github.com/code-423n4/2022-09-y2k-finance/blob/bca5080635370424a9fe21fe1aded98345d1f723/src/VaultFactory.sol#L163-L374   # Vulnerability details  # Immutable address owner is risky in `VaultFactory.sol` ### Impact The following contracts and functions, allow admins to interact with core functions such as:  `VaultFactory.sol` functions for:   - createNewMarket   - deployMoreAssets   - setController   - changeTreasury   - changeTimewindow   - changeController   - changeOracle  Given that `admin` is immutable it's very risky because it is irrecoverable from any mistakes  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the `onlyAdmin()` functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately.   When noticed, due to a failing `onlyAdmin()` function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.  ### Github Permalinks https://github.com/code-423n4/2022-09-y2k-finance/blob/bca5080635370424a9fe21fe1aded98345d1f723/src/VaultFactory.sol#L157  - Admin functions affected https://github.com/code-423n4/2022-09-y2k-finance/blob/bca5080635370424a9fe21fe1aded98345d1f723/src/VaultFactory.sol#L163-L374  ### Recommended steps Recommend remove immutable from admin address. Also taking care while deploying the contract / emitting an event when assigning _admin so in case it is wrongly deployed, it can be redeployed earlier. Finally adding a 2 steps transfer from admin for cases when admin needs to be migrate to another address.    
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/oracles/PegOracle.sol#L46-L83 https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L299-L300   # Vulnerability details  ## Impact Wrong maths for handling pricefeed decimals. This code will only work for pricefeeds of 8 decimals, any others give wrong/incorrect data. The maths used can be shown in three lines:  ```solidity nowPrice = (price1 * 10000) / price2; nowPrice = nowPrice * int256(10**(18 - priceFeed1.decimals())); return nowPrice / 1000000; ```  Line1: adds 4 decimals Line2: adds (18 - d) decimals, (where d = pricefeed.decimals()) Line3:  removes 6 decimals  Total: adds (16 - d) decimals  when d=8, the contract correctly returns an 8 decimal number. However, when d = 6, the function will return a 10 decimal number. This is further raised by (18-d = 12) decimals when checking for depeg event, leading to a 22 decimal number which is 4 orders of magnitude incorrect.  if d=18, (like usd-eth pricefeeds) contract fails / returns 0.  All chainlink contracts which give price in eth, operate with 18 decimals. So this can cripple the system if added later.  ## Proof of Concept Running the test  AssertTest.t.sol:testPegOracleMarketCreation and changing the line on  https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/test/AssertTest.t.sol#L30  to ```solidity PegOracle pegOracle3 = new PegOracle(             0xB1552C5e96B312d0Bf8b554186F846C40614a540,  //usd-eth contract address             btcEthOracle         ); ``` gives this output  ``` oracle3price1: 1085903802394919427                                                                                                                                                                                oracle3price2: 13753840915281064000                                                                                                                                                                               oracle3price1 / oracle3price2: 0 ```  returning an oracle value of 0. Simulating with a mock price feed of 6 decimals gives results 4 orders of magnitude off.  ## Tools Used Foundry, vs-code  ## Recommended Mitigation Steps Since only the price ratio is calculated, there is no point in increasing the decimal by (18-d) in the second line. Proposed solution: ```solidity nowPrice = (price1 * 10000) / price2; nowPrice = nowPrice * int256(10**(priceFeed1.decimals())) * 100; return nowPrice / 1000000; ``` This returns results in d decimals, no matter the value of d. 
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L96   # Vulnerability details  ## Impact Depeg event can still happen when the price of a pegged asset is equal to the strike price of a Vault which is incorrect.   This docs clearly mentions:  "When the price of a pegged asset is below the strike price of a Vault, a Keeper(could be anyone) will trigger the depeg event and both Vaults(hedge and risk) will swap their total assets with the other party." - https://code4rena.com/contests/2022-09-y2k-finance-contest  ## Proof of Concept  1. Assume strike price of vault is 1 and current price of pegged asset is also 1  2. User calls [triggerDepeg](https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L148) function which calls isDisaster modifier to check the depeg eligibility  3. Now lets see [isDisaster](https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L83) modifier  ``` modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {         address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);         if(             vaultsAddress.length != VAULTS_LENGTH             )             revert MarketDoesNotExist(marketIndex);          address vaultAddress = vaultsAddress[0];         Vault vault = Vault(vaultAddress);          if(vault.idExists(epochEnd) == false)             revert EpochNotExist();          if(             vault.strikePrice() < getLatestPrice(vault.tokenInsured())             )             revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));          if(             vault.idEpochBegin(epochEnd) > block.timestamp)             revert EpochNotStarted();          if(             block.timestamp > epochEnd             )             revert EpochExpired();         _;     } ```  4. Assume block.timestamp is at correct timestamp (between idEpochBegin and epochEnd), so none of revert execute. Lets look into the interesting one at  ```         if(             vault.strikePrice() < getLatestPrice(vault.tokenInsured())             )             revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured())); ```  5. Since in our case price of vault=price of pegged asset so if condition does not execute and finally isDisaster completes without any revert meaning go ahead of depeg  6. But this is incorrect since price is still not below strike price and is just equal  ## Recommended Mitigation Steps Change the isDisaster modifier to revert when price of a pegged asset is equal to the strike price of a Vault  ``` if(             vault.strikePrice() <= getLatestPrice(vault.tokenInsured())             )             revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured())); ```
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/oracles/PegOracle.sol#L63 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/Controller.sol#L308 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/oracles/PegOracle.sol#L126   # Vulnerability details  ## Impact Different problems have been found with the use of the oracle that can incur economic losses when the oracle is not consumed in a completely safe way.  ## Proof of Concept  Thre problems found are:  - The `timeStamp` check is not correct since in both cases it is done against 0, which would mean that a date of 2 years ago would be valid, so old prices can be taken.  ```javascript     function getLatestPrice(address _token)         public         view         returns (int256 nowPrice)     {         ...         if(timeStamp == 0)             revert TimestampZero();         return price;     } ```  - Oracle price 1 can be outdated:  The `latestRoundData` method of the `PegOracle` contract calls `priceFeed1.latestRoundData();` directly, but does not perform the necessary round or timestamp checks, and delegates them to the caller, but these checks are performed on price2 because it calls `getOracle2_Price` in this case, this inconsistency between how it take the price1 and price2 behaves favors human errors when consuming the oracle.  ## Recommended Mitigation Steps  For the timestamp issue, it should be checked like this:  ```diff +   uint constant observationFrequency = 1 hours;      function getLatestPrice(address _token)         public         view         returns (int256 nowPrice)     {         ...         (             uint80 roundID,             int256 price,             ,             uint256 timeStamp,             uint80 answeredInRound         ) = priceFeed.latestRoundData();          uint256 decimals = 10**(18-(priceFeed.decimals()));         price = price * int256(decimals);          if(price <= 0)             revert OraclePriceZero();          if(answeredInRound < roundID)             revert RoundIDOutdated();  -       if(timeStamp == 0) +       if(timeStamp < block.timestamp - uint256(observationFrequency))             revert TimestampZero();          return price;     } ```   
# Lines of code  https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/Vault.sol#L244-L252 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L205-L213 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L237-L239 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L244-L246 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L251-L258 https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/SemiFungibleVault.sol#L263-L270   # Vulnerability details  ## Impact  Other protocols that integrate with Y2K may wrongly assume that the functions are EIP-4626 compliant. Thus, it might cause integration problems in the future that can lead to wide range of issues for both parties.   ## Proof of Concept  All official EIP-4626 requirements can be found on it's [official page](https://eips.ethereum.org/EIPS/eip-4626#methods). Non-compliant functions are listed below along with the reason they are not compliant:  The following functions are missing but should be present: 1. mint(uint256, address) returns (uint256) 2. redeem(uint256, address, address) returns (uint256)  The following functions are non-compliant because they don't account for withdraw and deposit locking: 1. maxDeposit 2. maxMint 3. maxWithdraw 4. maxRedeem  All of the above functions should return 0 when their respective functions are disabled (i.e. maxDeposit should return 0 when deposits are disabled)  previewDeposit is not compliant because it must account for fees which it does not  totalAssets is not compliant because it does not always return the underlying managed by the vault because it fails to include the assets paid out during a depeg or the end of the epoch.  ## Tools Used  ## Recommended Mitigation Steps  All functions listed above should be modified to meet the specifications of EIP-4626
