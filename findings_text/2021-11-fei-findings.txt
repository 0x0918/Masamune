# Handle  danb   # Vulnerability details  oracle.pcvStats returns newProtocolEquity as  int256, it is then casted to uint256 in recalculate. If it is possible that newProtocolEquity will be negative, consider using SafeCast instead.  
# Handle  danb   # Vulnerability details  ## Impact in the first call to requery, If the oracle returns newProtocolEquity = 0, it can never be changed and would lead to denial of service of the system. ## Proof of Concept  In requery, init is checked to be false if newProtocolEquity = 0, and then set to true. so if it is already initialized and newProtocolEquity = 0, it wouldn't change anything ## Tools Used manual review  
# Handle  loop   # Vulnerability details  `preMergeCirculatingTribe` is a `uint256` set to a constant value which isn't changed by any function in the contract and can thus be declared as a constant state variable to save some gas during deployment and when using `preMergeCirculatingTribe`.  ## Proof of Concept https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L28  
# Handle  gzeon   # Vulnerability details  ## Impact The revert reason in L74 is inaccurate. It should be "ragequit more than assigned". L72-75 ```         require(             (claimed[thisSender] + multiplier) <= key,             "already ragequit all you tokens"         ); ``` The original revert string wrongly implies that claimed[thisSender] >= key Might cause confusing when user who have not yet claimed mistakenly supplied a multiplier > key  
# Handle  hickuphh3   # Vulnerability details  ## Impact  The following line  ```jsx address public constant oracleAddress =  0xd1866289B4Bd22D453fFF676760961e0898EE9BF; // oracle with caching ```  is only used in the instantiation of the oracle  `IOracle public constant oracle = IOracle(oracleAddress);`  The first instantiation can be combined with the second to save gas.  ## Recommended Mitigation Steps  `IOracle public constant oracle = IOracle(0xd1866289B4Bd22D453fFF676760961e0898EE9BF);`  
# Handle  hickuphh3   # Vulnerability details  ## Suggestion  Based on past experiences with on-chain actions involving merkle proofs, users tend to ask for the merkle tree data so that they can, in this case, ragequit their TRIBE for FEI by directly interacting with the contract on Etherscan.  It would therefore be helpful for `verifyClaim()` to be made public for users to verify that the merkle proof they input via Etherscan is correct.  
# Handle  hickuphh3   # Vulnerability details  ## Impact  Looking at the TRIBE token implementation, it would be cheaper to call the `transfer()` method as opposed to the the `transferFrom()` method since the latter contains additional logic (Eg. additional SLOAD to fetch the allowance).  ## Recommended Mitigation Steps  ```jsx function giveTo(address target, uint256 amount) internal {   bool check = token1.transfer(target, amount);  require(check, "erc20 transfer failed"); } ```  
# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external {     (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L141`  `https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L165`  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  
# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:  https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L205-L208  ```solidity require(             msg.sender == party0Timelock,             "Only the timelock for party 0 may call this function"         ); ```  https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L217-L220  ```solidity require(             msg.sender == party1Timelock,             "Only the timelock for party 1 may call this function"         ); ```  
# Handle  Czar102   # Vulnerability details  ## Impact In `TribeRagequit` when a user tries to withdraw more than is left, a `"already ragequit all you tokens"` error is displayed. This is not necessarily true.\ For example, if one may withdraw multiplier 1000 times and calls `ngmi(...)` function, stating their balance as 1001 tokens, they would get an information that they have already ragequit all tokens, whic is false as non of them have been ragequit yet.  ## Proof of Concept [code](https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L74)  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change the information to correctly reflect the situation.  
# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function setExpirationBlock in PegExchanger.sol could be set external         The function isEnabled in PegExchanger.sol could be set external         The function party0Accept in PegExchanger.sol could be set external         The function isExpired in PegExchanger.sol could be set external         The function party1Accept in PegExchanger.sol could be set external         The function exchange in PegExchanger.sol could be set external         The function isEnabled in TRIBERagequit.sol could be set external         The function ngmi in TRIBERagequit.sol could be set external         The function requery in TRIBERagequit.sol could be set external         The function party0Accept in TRIBERagequit.sol could be set external         The function isExpired in TRIBERagequit.sol could be set external         The function party1Accept in TRIBERagequit.sol could be set external         The function recalculate in TRIBERagequit.sol could be set external    
# Handle  robee   # Vulnerability details  The following functions could be set private to save gas and improve code quality:         The function takeFrom in PegExchanger.sol could be set internal         The function giveTo in PegExchanger.sol could be set internal         The function verifyProof in TRIBERagequit.sol could be set internal         The function takeFrom in TRIBERagequit.sol could be set internal         The function processProof in TRIBERagequit.sol could be set internal         The function giveTo in TRIBERagequit.sol could be set internal         The function _startCountdown in TRIBERagequit.sol could be set internal  
# Handle  tqts   # Vulnerability details  ## Impact Saving of one SLOAD instruction  ## Proof of Concept The value of `claimed[thisSender] + multiplier` is used twice in `ngmi(uint256,uint256,bytes32[])`. This involves a SLOAD each time it is calculated. Usages in lines 73 and 76 of TRIBERagequit.sol.  ## Tools Used Manual review  ## Recommended Mitigation Steps Precache the value of the expression right before line 72. Worst case, if the require fails, no extra gas is used. Best case, if the require succeeds, the SLOAD in line 76 is saved.  
# Handle  danb   # Vulnerability details  oracle.pcvStats returns newProtocolEquity as  int256, it is then casted to uint256 in recalculate. If it is possible that newProtocolEquity will be negative, consider using SafeCast instead.  
# Handle  danb   # Vulnerability details  ## Impact in the first call to requery, If the oracle returns newProtocolEquity = 0, it can never be changed and would lead to denial of service of the system. ## Proof of Concept  In requery, init is checked to be false if newProtocolEquity = 0, and then set to true. so if it is already initialized and newProtocolEquity = 0, it wouldn't change anything ## Tools Used manual review  
# Handle  loop   # Vulnerability details  `preMergeCirculatingTribe` is a `uint256` set to a constant value which isn't changed by any function in the contract and can thus be declared as a constant state variable to save some gas during deployment and when using `preMergeCirculatingTribe`.  ## Proof of Concept https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L28  
# Handle  gzeon   # Vulnerability details  ## Impact The revert reason in L74 is inaccurate. It should be "ragequit more than assigned". L72-75 ```         require(             (claimed[thisSender] + multiplier) <= key,             "already ragequit all you tokens"         ); ``` The original revert string wrongly implies that claimed[thisSender] >= key Might cause confusing when user who have not yet claimed mistakenly supplied a multiplier > key  
# Handle  hickuphh3   # Vulnerability details  ## Impact  The following line  ```jsx address public constant oracleAddress =  0xd1866289B4Bd22D453fFF676760961e0898EE9BF; // oracle with caching ```  is only used in the instantiation of the oracle  `IOracle public constant oracle = IOracle(oracleAddress);`  The first instantiation can be combined with the second to save gas.  ## Recommended Mitigation Steps  `IOracle public constant oracle = IOracle(0xd1866289B4Bd22D453fFF676760961e0898EE9BF);`  
# Handle  hickuphh3   # Vulnerability details  ## Suggestion  Based on past experiences with on-chain actions involving merkle proofs, users tend to ask for the merkle tree data so that they can, in this case, ragequit their TRIBE for FEI by directly interacting with the contract on Etherscan.  It would therefore be helpful for `verifyClaim()` to be made public for users to verify that the merkle proof they input via Etherscan is correct.  
# Handle  hickuphh3   # Vulnerability details  ## Impact  Looking at the TRIBE token implementation, it would be cheaper to call the `transfer()` method as opposed to the the `transferFrom()` method since the latter contains additional logic (Eg. additional SLOAD to fetch the allowance).  ## Recommended Mitigation Steps  ```jsx function giveTo(address target, uint256 amount) internal {   bool check = token1.transfer(target, amount);  require(check, "erc20 transfer failed"); } ```  
# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external {     (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L141`  `https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L165`  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  
# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:  https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L205-L208  ```solidity require(             msg.sender == party0Timelock,             "Only the timelock for party 0 may call this function"         ); ```  https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L217-L220  ```solidity require(             msg.sender == party1Timelock,             "Only the timelock for party 1 may call this function"         ); ```  
# Handle  Czar102   # Vulnerability details  ## Impact In `TribeRagequit` when a user tries to withdraw more than is left, a `"already ragequit all you tokens"` error is displayed. This is not necessarily true.\ For example, if one may withdraw multiplier 1000 times and calls `ngmi(...)` function, stating their balance as 1001 tokens, they would get an information that they have already ragequit all tokens, whic is false as non of them have been ragequit yet.  ## Proof of Concept [code](https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L74)  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change the information to correctly reflect the situation.  
# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function setExpirationBlock in PegExchanger.sol could be set external         The function isEnabled in PegExchanger.sol could be set external         The function party0Accept in PegExchanger.sol could be set external         The function isExpired in PegExchanger.sol could be set external         The function party1Accept in PegExchanger.sol could be set external         The function exchange in PegExchanger.sol could be set external         The function isEnabled in TRIBERagequit.sol could be set external         The function ngmi in TRIBERagequit.sol could be set external         The function requery in TRIBERagequit.sol could be set external         The function party0Accept in TRIBERagequit.sol could be set external         The function isExpired in TRIBERagequit.sol could be set external         The function party1Accept in TRIBERagequit.sol could be set external         The function recalculate in TRIBERagequit.sol could be set external    
# Handle  robee   # Vulnerability details  The following functions could be set private to save gas and improve code quality:         The function takeFrom in PegExchanger.sol could be set internal         The function giveTo in PegExchanger.sol could be set internal         The function verifyProof in TRIBERagequit.sol could be set internal         The function takeFrom in TRIBERagequit.sol could be set internal         The function processProof in TRIBERagequit.sol could be set internal         The function giveTo in TRIBERagequit.sol could be set internal         The function _startCountdown in TRIBERagequit.sol could be set internal  
# Handle  tqts   # Vulnerability details  ## Impact Saving of one SLOAD instruction  ## Proof of Concept The value of `claimed[thisSender] + multiplier` is used twice in `ngmi(uint256,uint256,bytes32[])`. This involves a SLOAD each time it is calculated. Usages in lines 73 and 76 of TRIBERagequit.sol.  ## Tools Used Manual review  ## Recommended Mitigation Steps Precache the value of the expression right before line 72. Worst case, if the require fails, no extra gas is used. Best case, if the require succeeds, the SLOAD in line 76 is saved.  
# Handle  danb   # Vulnerability details  oracle.pcvStats returns newProtocolEquity as  int256, it is then casted to uint256 in recalculate. If it is possible that newProtocolEquity will be negative, consider using SafeCast instead.  
# Handle  danb   # Vulnerability details  ## Impact in the first call to requery, If the oracle returns newProtocolEquity = 0, it can never be changed and would lead to denial of service of the system. ## Proof of Concept  In requery, init is checked to be false if newProtocolEquity = 0, and then set to true. so if it is already initialized and newProtocolEquity = 0, it wouldn't change anything ## Tools Used manual review  
# Handle  loop   # Vulnerability details  `preMergeCirculatingTribe` is a `uint256` set to a constant value which isn't changed by any function in the contract and can thus be declared as a constant state variable to save some gas during deployment and when using `preMergeCirculatingTribe`.  ## Proof of Concept https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L28  
# Handle  gzeon   # Vulnerability details  ## Impact The revert reason in L74 is inaccurate. It should be "ragequit more than assigned". L72-75 ```         require(             (claimed[thisSender] + multiplier) <= key,             "already ragequit all you tokens"         ); ``` The original revert string wrongly implies that claimed[thisSender] >= key Might cause confusing when user who have not yet claimed mistakenly supplied a multiplier > key  
# Handle  hickuphh3   # Vulnerability details  ## Impact  The following line  ```jsx address public constant oracleAddress =  0xd1866289B4Bd22D453fFF676760961e0898EE9BF; // oracle with caching ```  is only used in the instantiation of the oracle  `IOracle public constant oracle = IOracle(oracleAddress);`  The first instantiation can be combined with the second to save gas.  ## Recommended Mitigation Steps  `IOracle public constant oracle = IOracle(0xd1866289B4Bd22D453fFF676760961e0898EE9BF);`  
# Handle  hickuphh3   # Vulnerability details  ## Suggestion  Based on past experiences with on-chain actions involving merkle proofs, users tend to ask for the merkle tree data so that they can, in this case, ragequit their TRIBE for FEI by directly interacting with the contract on Etherscan.  It would therefore be helpful for `verifyClaim()` to be made public for users to verify that the merkle proof they input via Etherscan is correct.  
# Handle  hickuphh3   # Vulnerability details  ## Impact  Looking at the TRIBE token implementation, it would be cheaper to call the `transfer()` method as opposed to the the `transferFrom()` method since the latter contains additional logic (Eg. additional SLOAD to fetch the allowance).  ## Recommended Mitigation Steps  ```jsx function giveTo(address target, uint256 amount) internal {   bool check = token1.transfer(target, amount);  require(check, "erc20 transfer failed"); } ```  
# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause "unimplemented feature error". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external {     (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L141`  `https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L165`  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  
# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:  https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L205-L208  ```solidity require(             msg.sender == party0Timelock,             "Only the timelock for party 0 may call this function"         ); ```  https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L217-L220  ```solidity require(             msg.sender == party1Timelock,             "Only the timelock for party 1 may call this function"         ); ```  
# Handle  Czar102   # Vulnerability details  ## Impact In `TribeRagequit` when a user tries to withdraw more than is left, a `"already ragequit all you tokens"` error is displayed. This is not necessarily true.\ For example, if one may withdraw multiplier 1000 times and calls `ngmi(...)` function, stating their balance as 1001 tokens, they would get an information that they have already ragequit all tokens, whic is false as non of them have been ragequit yet.  ## Proof of Concept [code](https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L74)  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change the information to correctly reflect the situation.  
# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function setExpirationBlock in PegExchanger.sol could be set external         The function isEnabled in PegExchanger.sol could be set external         The function party0Accept in PegExchanger.sol could be set external         The function isExpired in PegExchanger.sol could be set external         The function party1Accept in PegExchanger.sol could be set external         The function exchange in PegExchanger.sol could be set external         The function isEnabled in TRIBERagequit.sol could be set external         The function ngmi in TRIBERagequit.sol could be set external         The function requery in TRIBERagequit.sol could be set external         The function party0Accept in TRIBERagequit.sol could be set external         The function isExpired in TRIBERagequit.sol could be set external         The function party1Accept in TRIBERagequit.sol could be set external         The function recalculate in TRIBERagequit.sol could be set external    
# Handle  robee   # Vulnerability details  The following functions could be set private to save gas and improve code quality:         The function takeFrom in PegExchanger.sol could be set internal         The function giveTo in PegExchanger.sol could be set internal         The function verifyProof in TRIBERagequit.sol could be set internal         The function takeFrom in TRIBERagequit.sol could be set internal         The function processProof in TRIBERagequit.sol could be set internal         The function giveTo in TRIBERagequit.sol could be set internal         The function _startCountdown in TRIBERagequit.sol could be set internal  
# Handle  tqts   # Vulnerability details  ## Impact Saving of one SLOAD instruction  ## Proof of Concept The value of `claimed[thisSender] + multiplier` is used twice in `ngmi(uint256,uint256,bytes32[])`. This involves a SLOAD each time it is calculated. Usages in lines 73 and 76 of TRIBERagequit.sol.  ## Tools Used Manual review  ## Recommended Mitigation Steps Precache the value of the expression right before line 72. Worst case, if the require fails, no extra gas is used. Best case, if the require succeeds, the SLOAD in line 76 is saved.  
