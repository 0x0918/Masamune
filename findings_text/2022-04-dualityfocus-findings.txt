# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L48 https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L58 https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/UniV3LpVault.sol#L418   # Vulnerability details  Some tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens.  For example Tether (USDT)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.  ## Impact The code as currently implemented does not handle these sorts of tokens properly when they're a Uniswap pool asset, which would prevent USDT, the sixth largest pool, from being used by this project. This project relies heavily on Uniswap, so this would hamper future growth and availability of the protocol.  ## Proof of Concept  1. File: contracts/vault_and_oracles/FlashLoan.sol (line [48](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L48)) ```solidity         IERC20(assets[0]).approve(address(LP_VAULT), amounts[0]); ```  2. File: contracts/vault_and_oracles/FlashLoan.sol (line [58](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L58)) ```solidity         IERC20(assets[0]).approve(address(LENDING_POOL), amountOwing); ```  3. File: contracts/vault_and_oracles/UniV3LpVault.sol (line [418](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/UniV3LpVault.sol#L418)) ```solidity             IERC20Detailed(params.asset).approve(msg.sender, owedBack); ```  There are other calls to `approve()`, but they correctly set the approval to zero after the transfer is done, so that the next approval can go through.  ## Tools Used Code inspection  ## Recommended Mitigation Steps Use OpenZeppelin’s `SafeERC20`'s `safeTransfer()` instead   
# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L621 https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L379 https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L520 https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L521   # Vulnerability details  ## Impact  `UniV3LpVault._swap` utilizes `swapRouter.exactInput` to perform swaps between two tokens. During swaps, `transfer` function of each token along the path will be called to propagate the assets.  Since anyone can create a uniswap pair of arbitrary assets, it is possible to include intermediate hop with malicious tokens within the path. Thus `UniV3LpVault._swap` effectively grants users the ability to perform arbitrary contract calls during the swap process if `swapPath` is not validated properly.  Usage of invalidated `swapPath` can be found in `UniV3LpVault.flashFocusCall` and `UniV3LpVault.repayDebt`.  ## Proof of Concept  The security of `Comptroller` and `UniV3LpVault` relies on validating all used tokens thoroughly. This is done by a whitelist mechanism where admin decides a predefined set of usable tokens, and users can only perform actions within the allowed range. This whitelist approach eliminates most of the attack surface regarding directly passing in malicious tokens as arguments.  Apart from passing malicious tokens directly, there are a few other potential weaknesses, the most obvious one is leveraging flash loans for collaterals. However, due to the adoption of AAVE LendingPool, the external validation within flash loan pool blocks this approach.  Unfortunately, a more obscure path exists. Looking at the swapping mechanism, it is not hard to realize it is backed by uniswapV3. An interesting characteristic of uniswap pools is that anyone can create pools for any token pairs, thus if we don't fully validate each and every pool we are using, chances are there will be malicious entries hidden within them.  This is partially the case which we see here, the user gets to supply a path, where the source and target are validated against benign tokens, the intermediate ones are not. An example of utilizing path for arbitrary function call is illustrated below 1. Create malicious token tokenM 2. Create pools tokenS<->tokenM and tokenM<->tokenT where tokenS and tokenT are benign tokens 3. Supply path (tokenS, tokenM, tokenT) for swapping  In the above case, when transferring tokenM while doing swap, we have full control over code executed and can insert arbitrary contract calls within.  Noticeably, while gaining arbitrary contract calls sounds dangerous, it does not necessarily mean the contract is exploitable. It still depends on the scenario in which an arbitrary call happens.  In the case of duality, the two locations where arbitrary `swapPath` can be provided is in `flashFocusCall` and `repayDebt`, both in which holds a local lock over `UniV3LpVault`. No global are applied to `Comptroller` or `Ctokens` while performing swaps.  ```     function flashFocusCall(FlashFocusParams calldata params) external override {         ...         {             ...             if (!tokenOfPool && params.swapPath.length > 0) amountIn0 = _swap(params.swapPath, params.amount);             ...         }         ...     }      function flashFocus(FlashFocusParams calldata params)         external         override         nonReentrant(true)         isAuthorizedForToken(params.tokenId)         avoidsShortfall     {         ...         flashLoan.LENDING_POOL().flashLoan(             receiverAddress,             assets,             amounts,             modes,             onBehalfOf,             newParams,             referralCode         );     }      function repayDebt(RepayDebtParams calldata params)         external         override         nonReentrant(true)         isAuthorizedForToken(params.tokenId)         avoidsShortfall         returns (uint256 amountReturned)     {         ...         {             ...             if (amountOutFrom0 == 0 && params.swapPath0.length > 0) amountOutFrom0 = _swap(params.swapPath0, amount0);             if (amountOutFrom1 == 0 && params.swapPath1.length > 0) amountOutFrom1 = _swap(params.swapPath1, amount1);             ...         }         ...     } ```   The lack of global locks here had us doubting whether an attack is possible. While we spent a considerable amount of time and failed to come up with any possible attack vectors, the complexity of the system held us back from concluding that an attack is impossible.  Thus we report this finding here in hope of inspiring developers either to prove the attack impossible or mitigate the attack surface.  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  The easiest way to mitigate this is to validate the entire path against a predefined whitelist while in `_checkSwapPath`. This approach is far from optimal and also limits the flexibility of swapping between tokens. However, before security is proved, this is the best approach we can come up with.   
# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/compound_rari_fork/CToken.sol#L1379   # Vulnerability details  ## Impact  The implementation of `CToken` in Duality introduced an `_acceptAdmin` function, which presumably should allow changing the `admin`. However, there does not exist a pairing `proposePendingAdmin` function that can propose a new `pendingAdmin`, thus `pendingAdmin` will never be set. This renders the `_acceptAdmin` function useless.  ## Proof of Concept  `_acceptAdmin` requires `msg.sender` to equal `pendingAdmin`, however, since `pendingAdmin` can never be set, it will always be `address(0)`, making this function unusable.  ```     function _acceptAdmin() external returns (uint256) {         // Check caller is pendingAdmin and pendingAdmin ≠ address(0)         if (msg.sender != pendingAdmin || msg.sender == address(0)) {             return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);         }         // Save current values for inclusion in log         address oldAdmin = admin;         address oldPendingAdmin = pendingAdmin;         // Store admin with value pendingAdmin         admin = pendingAdmin;         // Clear the pending value         pendingAdmin = address(0);         emit NewAdmin(oldAdmin, admin);         emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);         return uint256(Error.NO_ERROR);     } ```  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Add a `proposePendingAdmin` function where the current admin can propose successors.  ```     function _proposePendingAdmin(address newPendingAdmin) external {         if (msg.sender != admin) {             return fail(Error.UNAUTHORIZED, FailureInfo.PROPOSE_PENDING_ADMIN_CHECK);         }         address oldPendingAdmin = pendingAdmin;         pendingAdmin = newPendingAdmin;         emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);         return uint256(Error.NO_ERROR)     } ```   
# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/compound_rari_fork/Comptroller.sol#L1105   # Vulnerability details  ## Impact  `Comptroller._setUniV3LpVault` allows the admin of `Comptroller` to change the accompanying `UniV3LpVault`. However since actions including collateral calculation, uniswapV3 position withdrawal, uniswapV3 collateral liquidation all require `Comptroller` and `UniV3LpVault` to cooperate seamlessly, a change in `Comptroller.uniV3LpVault` would mean all the above actions are no longer performable on existing NFTs.  ## Proof of Concept  `_setUniV3LpVault` allows changing of `uniV3LpVault`.  ```     function _setUniV3LpVault(IUniV3LpVault newVault) public returns (uint256) {         ...         uniV3LpVault = newVault;         ...     } ```  However, functions such as `UniV3LpVault.withdrawToken` require `Comptroller` to estimate NFT collateral value. This estimation can only be done when the address of `UniV3LpVault` matches `Comptroller.uniV3LpVault` as shown in `addNFTCollateral` below.  ``` contract UniV3LpVault is IUniV3LpVault {     ...     function withdrawToken(...) external override nonReentrant(false) avoidsShortfall {         ...     }      modifier avoidsShortfall() {         _;         (, , uint256 shortfall) = comptroller.getAccountLiquidity(msg.sender);         require(shortfall == 0, "insufficient liquidity");     }     ... }  contract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {     ...     function getAccountLiquidity(address account) public view returns (...) {         (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(...);         ...     }      function getHypotheticalAccountLiquidityInternal(...) internal view returns (...) {         ...         addNFTCollateral(account, vars);         ...     }      function addNFTCollateral(address account, AccountLiquidityLocalVars memory vars) internal view {         uint256 userTokensLength = uniV3LpVault.getUserTokensLength(account);         for (uint256 i = 0; i < userTokensLength; i++) {             ...             {                 ...                 address poolAddress = uniV3LpVault.getPoolAddress(tokenId);                 ...             }             ...         }         ...     } } ``` The mutual reliance causes NFT tokens to become stuck. In some cases users can solve this issue by depositing more collateral to cover the shortcoming caused by "disappearing NFTs". In other cases such as liquidation, the functionality becomes downright broken and unuseable..  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Remove the option to change `Comptroller.uniV3LpVault` altogether, as this functionality is not really helpful for the overall protocol. Another way to handle this is to forcefully evict all NFTs before changing the vault. However, this is extremely complex as it would potentially cause users to become severely under-collateralized, and would require more care in tracking and maintaining states.   
# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/compound_rari_fork/CToken.sol#L1641   # Vulnerability details  ## Impact  In the referenced code this line,  `require(msg.sender != admin, "caller not admin");` is meant to prevent non-admins from calling the function however it instead prevents admins from calling the function and allows anyone else to. This could lead to defacing the token i.e changing the name to something offensive like Shit Token, Poo Coin, etc.  ## Recommended Mitigation Steps  Adjust the require statement to reflect it's intended function i.e ` require(msg.sender == admin, "caller not admin");`  
# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/compound_rari_fork/Comptroller.sol#L1491   # Vulnerability details  ## Impact The `_setPoolCollateralFactors` function does not check that the collateral factor is < 100%. It's possible that it's set to 200% and then borrows more than the collateral is worth, stealing from the pool.  ## Recommended Mitigation Steps Disable the possibility of ever having a collateral factor > 100% by checking:  ```diff for (uint256 i = 0; i < pools.length; i++) { +   require(collateralFactorsMantissa[i] <= 1e18, "CF > 100%");     poolCollateralFactors[pools[i]] = collateralFactorsMantissa[i]; } ```   
# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L48 https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L58 https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/UniV3LpVault.sol#L418   # Vulnerability details  Some tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens.  For example Tether (USDT)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.  ## Impact The code as currently implemented does not handle these sorts of tokens properly when they're a Uniswap pool asset, which would prevent USDT, the sixth largest pool, from being used by this project. This project relies heavily on Uniswap, so this would hamper future growth and availability of the protocol.  ## Proof of Concept  1. File: contracts/vault_and_oracles/FlashLoan.sol (line [48](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L48)) ```solidity         IERC20(assets[0]).approve(address(LP_VAULT), amounts[0]); ```  2. File: contracts/vault_and_oracles/FlashLoan.sol (line [58](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L58)) ```solidity         IERC20(assets[0]).approve(address(LENDING_POOL), amountOwing); ```  3. File: contracts/vault_and_oracles/UniV3LpVault.sol (line [418](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/UniV3LpVault.sol#L418)) ```solidity             IERC20Detailed(params.asset).approve(msg.sender, owedBack); ```  There are other calls to `approve()`, but they correctly set the approval to zero after the transfer is done, so that the next approval can go through.  ## Tools Used Code inspection  ## Recommended Mitigation Steps Use OpenZeppelin’s `SafeERC20`'s `safeTransfer()` instead   
# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L621 https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L379 https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L520 https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L521   # Vulnerability details  ## Impact  `UniV3LpVault._swap` utilizes `swapRouter.exactInput` to perform swaps between two tokens. During swaps, `transfer` function of each token along the path will be called to propagate the assets.  Since anyone can create a uniswap pair of arbitrary assets, it is possible to include intermediate hop with malicious tokens within the path. Thus `UniV3LpVault._swap` effectively grants users the ability to perform arbitrary contract calls during the swap process if `swapPath` is not validated properly.  Usage of invalidated `swapPath` can be found in `UniV3LpVault.flashFocusCall` and `UniV3LpVault.repayDebt`.  ## Proof of Concept  The security of `Comptroller` and `UniV3LpVault` relies on validating all used tokens thoroughly. This is done by a whitelist mechanism where admin decides a predefined set of usable tokens, and users can only perform actions within the allowed range. This whitelist approach eliminates most of the attack surface regarding directly passing in malicious tokens as arguments.  Apart from passing malicious tokens directly, there are a few other potential weaknesses, the most obvious one is leveraging flash loans for collaterals. However, due to the adoption of AAVE LendingPool, the external validation within flash loan pool blocks this approach.  Unfortunately, a more obscure path exists. Looking at the swapping mechanism, it is not hard to realize it is backed by uniswapV3. An interesting characteristic of uniswap pools is that anyone can create pools for any token pairs, thus if we don't fully validate each and every pool we are using, chances are there will be malicious entries hidden within them.  This is partially the case which we see here, the user gets to supply a path, where the source and target are validated against benign tokens, the intermediate ones are not. An example of utilizing path for arbitrary function call is illustrated below 1. Create malicious token tokenM 2. Create pools tokenS<->tokenM and tokenM<->tokenT where tokenS and tokenT are benign tokens 3. Supply path (tokenS, tokenM, tokenT) for swapping  In the above case, when transferring tokenM while doing swap, we have full control over code executed and can insert arbitrary contract calls within.  Noticeably, while gaining arbitrary contract calls sounds dangerous, it does not necessarily mean the contract is exploitable. It still depends on the scenario in which an arbitrary call happens.  In the case of duality, the two locations where arbitrary `swapPath` can be provided is in `flashFocusCall` and `repayDebt`, both in which holds a local lock over `UniV3LpVault`. No global are applied to `Comptroller` or `Ctokens` while performing swaps.  ```     function flashFocusCall(FlashFocusParams calldata params) external override {         ...         {             ...             if (!tokenOfPool && params.swapPath.length > 0) amountIn0 = _swap(params.swapPath, params.amount);             ...         }         ...     }      function flashFocus(FlashFocusParams calldata params)         external         override         nonReentrant(true)         isAuthorizedForToken(params.tokenId)         avoidsShortfall     {         ...         flashLoan.LENDING_POOL().flashLoan(             receiverAddress,             assets,             amounts,             modes,             onBehalfOf,             newParams,             referralCode         );     }      function repayDebt(RepayDebtParams calldata params)         external         override         nonReentrant(true)         isAuthorizedForToken(params.tokenId)         avoidsShortfall         returns (uint256 amountReturned)     {         ...         {             ...             if (amountOutFrom0 == 0 && params.swapPath0.length > 0) amountOutFrom0 = _swap(params.swapPath0, amount0);             if (amountOutFrom1 == 0 && params.swapPath1.length > 0) amountOutFrom1 = _swap(params.swapPath1, amount1);             ...         }         ...     } ```   The lack of global locks here had us doubting whether an attack is possible. While we spent a considerable amount of time and failed to come up with any possible attack vectors, the complexity of the system held us back from concluding that an attack is impossible.  Thus we report this finding here in hope of inspiring developers either to prove the attack impossible or mitigate the attack surface.  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  The easiest way to mitigate this is to validate the entire path against a predefined whitelist while in `_checkSwapPath`. This approach is far from optimal and also limits the flexibility of swapping between tokens. However, before security is proved, this is the best approach we can come up with.   
# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/compound_rari_fork/CToken.sol#L1379   # Vulnerability details  ## Impact  The implementation of `CToken` in Duality introduced an `_acceptAdmin` function, which presumably should allow changing the `admin`. However, there does not exist a pairing `proposePendingAdmin` function that can propose a new `pendingAdmin`, thus `pendingAdmin` will never be set. This renders the `_acceptAdmin` function useless.  ## Proof of Concept  `_acceptAdmin` requires `msg.sender` to equal `pendingAdmin`, however, since `pendingAdmin` can never be set, it will always be `address(0)`, making this function unusable.  ```     function _acceptAdmin() external returns (uint256) {         // Check caller is pendingAdmin and pendingAdmin ≠ address(0)         if (msg.sender != pendingAdmin || msg.sender == address(0)) {             return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);         }         // Save current values for inclusion in log         address oldAdmin = admin;         address oldPendingAdmin = pendingAdmin;         // Store admin with value pendingAdmin         admin = pendingAdmin;         // Clear the pending value         pendingAdmin = address(0);         emit NewAdmin(oldAdmin, admin);         emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);         return uint256(Error.NO_ERROR);     } ```  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Add a `proposePendingAdmin` function where the current admin can propose successors.  ```     function _proposePendingAdmin(address newPendingAdmin) external {         if (msg.sender != admin) {             return fail(Error.UNAUTHORIZED, FailureInfo.PROPOSE_PENDING_ADMIN_CHECK);         }         address oldPendingAdmin = pendingAdmin;         pendingAdmin = newPendingAdmin;         emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);         return uint256(Error.NO_ERROR)     } ```   
# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/compound_rari_fork/Comptroller.sol#L1105   # Vulnerability details  ## Impact  `Comptroller._setUniV3LpVault` allows the admin of `Comptroller` to change the accompanying `UniV3LpVault`. However since actions including collateral calculation, uniswapV3 position withdrawal, uniswapV3 collateral liquidation all require `Comptroller` and `UniV3LpVault` to cooperate seamlessly, a change in `Comptroller.uniV3LpVault` would mean all the above actions are no longer performable on existing NFTs.  ## Proof of Concept  `_setUniV3LpVault` allows changing of `uniV3LpVault`.  ```     function _setUniV3LpVault(IUniV3LpVault newVault) public returns (uint256) {         ...         uniV3LpVault = newVault;         ...     } ```  However, functions such as `UniV3LpVault.withdrawToken` require `Comptroller` to estimate NFT collateral value. This estimation can only be done when the address of `UniV3LpVault` matches `Comptroller.uniV3LpVault` as shown in `addNFTCollateral` below.  ``` contract UniV3LpVault is IUniV3LpVault {     ...     function withdrawToken(...) external override nonReentrant(false) avoidsShortfall {         ...     }      modifier avoidsShortfall() {         _;         (, , uint256 shortfall) = comptroller.getAccountLiquidity(msg.sender);         require(shortfall == 0, "insufficient liquidity");     }     ... }  contract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {     ...     function getAccountLiquidity(address account) public view returns (...) {         (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(...);         ...     }      function getHypotheticalAccountLiquidityInternal(...) internal view returns (...) {         ...         addNFTCollateral(account, vars);         ...     }      function addNFTCollateral(address account, AccountLiquidityLocalVars memory vars) internal view {         uint256 userTokensLength = uniV3LpVault.getUserTokensLength(account);         for (uint256 i = 0; i < userTokensLength; i++) {             ...             {                 ...                 address poolAddress = uniV3LpVault.getPoolAddress(tokenId);                 ...             }             ...         }         ...     } } ``` The mutual reliance causes NFT tokens to become stuck. In some cases users can solve this issue by depositing more collateral to cover the shortcoming caused by "disappearing NFTs". In other cases such as liquidation, the functionality becomes downright broken and unuseable..  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Remove the option to change `Comptroller.uniV3LpVault` altogether, as this functionality is not really helpful for the overall protocol. Another way to handle this is to forcefully evict all NFTs before changing the vault. However, this is extremely complex as it would potentially cause users to become severely under-collateralized, and would require more care in tracking and maintaining states.   
# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/compound_rari_fork/CToken.sol#L1641   # Vulnerability details  ## Impact  In the referenced code this line,  `require(msg.sender != admin, "caller not admin");` is meant to prevent non-admins from calling the function however it instead prevents admins from calling the function and allows anyone else to. This could lead to defacing the token i.e changing the name to something offensive like Shit Token, Poo Coin, etc.  ## Recommended Mitigation Steps  Adjust the require statement to reflect it's intended function i.e ` require(msg.sender == admin, "caller not admin");`  
# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/compound_rari_fork/Comptroller.sol#L1491   # Vulnerability details  ## Impact The `_setPoolCollateralFactors` function does not check that the collateral factor is < 100%. It's possible that it's set to 200% and then borrows more than the collateral is worth, stealing from the pool.  ## Recommended Mitigation Steps Disable the possibility of ever having a collateral factor > 100% by checking:  ```diff for (uint256 i = 0; i < pools.length; i++) { +   require(collateralFactorsMantissa[i] <= 1e18, "CF > 100%");     poolCollateralFactors[pools[i]] = collateralFactorsMantissa[i]; } ```   
