# Handle  pants   # Vulnerability details    
# Handle  pants   # Vulnerability details  These `public` functions are never called by their contract: - `TempusAMM.getSwapAmountToEndWithEqualShares()` - `TempusAMM.getRate()` - `AaveTempusPool.currentInterestRate()` - `AaveTempusPool.numAssetsPerYieldToken()` - `AaveTempusPool.numYieldTokensPerAsset()` - `CompoundTempusPool.currentInterestRate()` - `CompoundTempusPool.numAssetsPerYieldToken()` - `CompoundTempusPool.numYieldTokensPerAsset()` - `LidoTempusPool.currentInterestRate()` - `LidoTempusPool.numAssetsPerYieldToken()` - `LidoTempusPool.numYieldTokensPerAsset()` - `ERC20FixedSupply.decimals()` - `ERC20OwnerMintableToken.burn()` - `ERC20OwnerMintableToken.burnFrom()` - `PoolShare.decimals()` - `PermanentlyOwnable.renounceOwnership()` - `TempusController.depositYieldBearing()` - `TempusController.depositBacking()` - `TempusController.redeemToYieldBearing()` - `TempusController.redeemToBacking()` - `TempusPool.estimatedMintedShares()` - `TempusPool.estimatedRedeem()`  Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `external`.  
# Handle  pants   # Vulnerability details  These files has open TODOs: - `TempusPool.sol` - `unusedAMMImportOnly.sol` - `Fixed256xVar.sol` - `LidoTempusPool.sol`  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Resolve these TODOs and bubble up the errors.  
# Handle  TomFrench   # Vulnerability details  ## Impact Increased gas costs  ## Proof of Concept  On L189, we use a uint8 as the for loop variable: https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L189  Due to how the EVM natively works on 256 numbers, using a 8 bit number here introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage  ## Recommended Mitigation Steps  Change i to be a uint256 and replace any similar uints which only exist in memory and aren't required to use a smaller type.  
# Handle  hyh   # Vulnerability details  ## Vulnerability Details getAMMOrderedAmounts, https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L692, and _exitTempusAmmAndRedeem, https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L644, functions use explicit token comparison for ordering, while it is based on current Balancer pool implementation, which can change, leading to contract logic discrepancies.  In the same time _getAMMDetailsAndEnsureInitialized (https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L673) do rely on PoolTokens, which obtain token list in Balancer's call sequence as follows: PoolTokens._getPoolTokens -> TwoTokenPoolsBalance._getTwoTokenPoolTokens -> TwoTokenPoolsBalance._getTwoTokenPoolBalances -> TwoTokenPoolsBalance._twoTokenPoolTokens[].  TwoTokenPoolsBalance._twoTokenPoolTokens[] is ordered during _registerTwoTokenPoolTokens, but this is current implementation.  It is safer to use vault.getPoolTokens(poolId) in getAMMOrderedAmounts to obtain an ordered pair.  This can matter as AMM token usage isn't symmetric (https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L84).  ## Impact Probability here is low and risk rating is minimal, but the impact can vary as TempusController contract  logic rely on token ordering.  
# Handle  pauliax   # Vulnerability details  ## Impact The loop here is not really necessary as _TOTAL_TOKENS is a constant of 2 so there is always just 1 iteration:         for (uint256 i = 1; i < _TOTAL_TOKENS; ++i) {             uint256 currentBalance = balances[i];             if (currentBalance > maxBalance) {                 chosenTokenIndex = i;                 maxBalance = currentBalance;             }         }  ## Recommended Mitigation Steps Consider if you want to reduce gas usage by eliminating this loop here but taking the risk that _TOTAL_TOKENS will not be updated to a different value.  
# Handle  pauliax   # Vulnerability details  ## Impact There are unused imports. They will increase the size of deployment with no real benefit. Consider removing unused imports to save some gas. Examples of such imports are:   In TempusAMMUserDataHelpers   import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/IERC20.sol";  In TempusController   import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";  In TempusAMM   import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";  ## Recommended Mitigation Steps Consider removing them to reduce deployment gas usage.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusPool.sol#L375-L375  ```solidity uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0; ```  `maturityTime - currentTime` will never underflow.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/mocks/aave/WadRayMath.sol#L59-L59  ```solidity require(a <= (type(uint256).max - halfWAD) / b, "multiplication oveflow"); ```  `oveflow` should be `overflow`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/VecMath.sol#L10-L10  ```solidity /// @dev Substracting two vectors ```  `Substracting` should be `Subtracting`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/mocks/lido/StETH.sol#L302-L302  ```solidity * @dev This is used for calaulating tokens from shares and vice versa. ```  `calaulating` should be `calculating`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L779-L779  ```solidity //  - endTime is alawys larger than startTime ```  `alawys` should be `always`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L47-L47  ```solidity /// @param recipient Address of user that recieved Yield Bearing Tokens ```  `recieved` should be `received`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L163-L163  ```solidity /// @param recipient Address of user that will recieve yield bearing tokens ```  `recieve` should be `receive`.  
# Handle  cmichel   # Vulnerability details  In `CompoundTempusPool`, the `cToken` and the base class' `yieldBearingToken` storage fields are the same. Remove the `cToken` field and the assignment in the constructor to save gas.   
# Handle  cmichel   # Vulnerability details  The (second) `TempusController._exitTempusAmmAndRedeem` function swaps the difference of yield and principal shares using the AMM.  ```solidity swap(     tempusAMM,     tempusAMM.getSwapAmountToEndWithEqualShares(principals, yields, maxLeftoverShares),     tokenIn,     tokenOut,     0 // @audit min return of zero ); // yields and principals are updated to the received amounts and redeemed // ... ```  It does not use a min return value for this swap and it is, therefore, susceptible to sandwich attacks.  > A common attack in DeFi is the sandwich attack. Upon observing a trade of asset X for asset Y, an attacker frontruns the victim trade by also buying asset Y, lets the victim execute the trade, and then backruns (executes after) the victim by trading back the amount gained in the first trade. Intuitively, one uses the knowledge that someone’s going to buy an asset, and that this trade will increase its price, to make a profit. The attacker’s plan is to buy this asset cheap, let the victim buy at an increased price, and then sell the received amount again at a higher price afterwards.  ## Impact Trades can happen at a bad price and lead to receiving fewer tokens than at a fair market price. The attacker's profit is the user's loss.  ## Recommended Mitigation Steps Add minimum return amount checks. Accept a function parameter that can be chosen by the transaction sender, then check that the actually received amount is above this parameter. Similar to `minLpAmountsOut` but for the yields & principal shares (or the redeemed tokens).  
# Handle  cmichel   # Vulnerability details  There's a griefing attack where an attacker can make any user transaction for `TempusController.exitTempusAMM` fail. In `_exitTempusAMM`, the user exits their LP position and claims back yield and principal shares. The LP amounts to redeem are determined by the function parameter `lpTokensAmount`. A final `assert(tempusAMM.balanceOf(address(this)) == 0)` statement checks that the LP token amount of the contract is zero after the exit. This is only true if no other LP shares were already in the contract.  However, an attacker can frontrun this call and send the smallest unit of LP shares to the contract which then makes the original deposit-and-fix transaction fail.  ## Impact All `exitTempusAMM` calls can be made to fail and this function becomes unusable.  ## Recommended Mitigation Steps Remove the `assert` check.  
# Handle  cmichel   # Vulnerability details  There's a griefing attack where an attacker can make any user transaction for `TempusController.depositAndFix` fail. In `_depositAndFix`, `swapAmount` many yield shares are swapped to principal where `swapAmount` is derived from the function arguments. A final `assert(yieldShares.balanceOf(address(this)) == 0)` statement checks that the yield shares of the contract are zero after the swap. This is only true if no other yield shares were already in the contract.  However, an attacker can frontrun this call and send the smallest unit of yield shares to the contract which then makes the original deposit-and-fix transaction fail.  ## Impact All `depositAndFix` calls can be made to fail and this function becomes unusable.  ## Recommended Mitigation Steps Remove the `assert` check.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Reduced flexibility of AMM + additional gas costs on swaps  ## Proof of Concept  As the relative payouts of the principal and yield tokens are fixed at the point of finalisation, there's no need to freeze the AMM as it will just rapidly be arbed to the final prices of each token. No funds will be lost by LPs.  Making this change would reduce gas costs as swaps won't have to check maturity (load the TempusPool then perform SLOAD for maturity state variable).  ## Recommended Mitigation Steps  Remove `beforeMaturity` modifier from AMM.  
# Handle  TomFrench   # Vulnerability details  ## Impact  ## Proof of Concept  As the `TempusAmm` only ever registers with the Balancer Vault with the two token specialization the `GeneralPool` interface will never be used as the Vault will call the `MinimalSwapInfoPool` hooks instead.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L107-L110  See here in the Balancer Vault code:  https://github.com/balancer-labs/balancer-v2-monorepo/blob/62c5cba7cae1d481f913c90fe0d9d94e101570c5/pkg/vault/contracts/Swaps.sol#L287-L292  ## Recommended Mitigation Steps  Remove the inheritance from `BaseGeneralPool` and remove the functions highlighted in the link below. This will help reduce bytecode from the AMM factory and reduce deployment costs.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L283-L309  
# Handle  TomFrench   # Vulnerability details  ## Impact  Higher gas costs on transfers of tokens from user to TempusPool  ## Proof of Concept  Following the flow of tokens from the user to their the `TempusPool contract`:  1. User calls `TempusController.depositBacking`, `TempusController` transfers user's tokens to itself and approves relevant `TempusPool`  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L412-L414  2. `TempusController` calls `TempusPool.deposit` which in turn transfers tokens from the `TempusController` and then invests them.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusPool.sol#L178  This first transfer is then superfluous as the `TempusPool` trusts the `TempusController` (it's the only contract which may call `deposit`). We're then incurring the costs of 1 `transfer` and 1 `approve` unnecessarily.  ## Recommended Mitigation Steps  As `TempusPool` trusts `TempusController`, `TempusController` can transfer the tokens directly to `TempusPool` and just tell it how much has been deposited.  L412-L414 of `TempusController.sol` would then be replaced with: ``` // Deposit to directly to targetPool uint transferredYBT = yieldBearingToken.untrustedTransferFrom(msg.sender, targetPool, yieldTokenAmount); ```  
# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs on several `TempusPool` functions  ## Proof of Concept  `TempusPool`s have a `finalize` function which checks whether `block.timestamp >= maturityTime` and flips the `maturity` storage variable as well as setting `maturityInterestRate` to the current interest rate.  https://github.com/tempus-finance/tempus-protocol/blob/0240b4d172d7aa093a70e0401f4140c99aa30dc6/contracts/TempusPool.sol#L126-L135  `maturity` is used in several places to check whether the pool has expired however checking this variable is more expensive than checking `block.timestamp >= maturityTime` (due to the need for a SLOAD whereas `maturityTime` is immutable so no SLOAD is needed). I'd recommend making a `function matured() public view` to keep the readability.  However `maturityInterestRate` still needs to be set correctly. This could be done by reading the current interest rate when `matured()` returns true but `maturityInterestRate == 0` this could cause issues with some functions which are currently view functions however.   ## Recommended Mitigation Steps  Half solution:  Replace `matured` state variable with a `matured()` view function which returns `maturityInterestRate > 0`. This removes an SSTORE from `finalize` and an `SLOAD` from any function which uses `maturityInterestRate` as you can just check if it's greater than zero to see if the pool has matured.  Full solution:   Replace `matured` state variable with a `matured()` view function which returns  `block.timestamp >= maturityTime`. This combined with setting `maturityInterestRate` when you see that `matured() == true` and `maturityInterestRate == 0` would remove the need for the `finalize` function entirely.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact If `initInterestRate` in the `TempusPool`'s constructor is given as 0,  no funds can be withdrawn as `getRedemptionAmounts()` always panic errors with _division by 0_ ([link](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusPool.sol#L305)).  ## Recommended Mitigation Steps It should be stated in the constructor's specs that `initInterestRate` should not be 0.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The `protocolName` variables in the protocol-specific `TempusPool`s are set as _immutable_ but could be set as _constant_.  See [Compound](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/CompoundTempusPool.sol#L19),  [Aave](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/AaveTempusPool.sol#L18),  [Lido](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/LidoTempusPool.sol#L9).  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _depositAndProvideLiquidity can be used go retrieve arbitrary ERC20 tokens from the TempusController.sol contract.  As the test contract of TempusController.sol https://goerli.etherscan.io/address/0xd4330638b87f97ec1605d7ec7d67ea1de5dd7aaa shows, it has indeed ERC20 tokens.  The problem is due to the fact that you supply an arbitrary tempusAMM to depositAndProvideLiquidity and thus to _depositAndProvideLiquidity.  tempusAMM could be a fake contract that supplies values that are completely fake.  At the end of the function _depositAndProvideLiquidity, ERC20 tokens are send to the user. If you can manipulate the variables ammTokens,  mintedShares  and sharesUsed you can send back any tokens held in the contract "ammTokens[0].safeTransfer(msg.sender, mintedShares - sharesUsed[0]);"  The Proof of Concept shows an approach to do this.    ## Proof of Concept https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L73-L79  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L304-L335  Create a fake Vault contract (fakeVault) with the following functions: fakeVault.getPoolTokens(poolId) --> returns {TokenToSteal1,TokenToSteal2},{fakeBalance1,fakeBalance2},0 fakeVault.JoinPoolRequest() --> do nothing fakeVault.joinPool() --> do nothing  Create a fake Pool contract (fakePool) with the following functions: fakePool.yieldBearingToken() --> returns fakeYieldBearingToken fakePool.deposit() --> returns fakeMintedShares,....  Create a fake ammTokens contract with the following functions: tempusAMM.getVault() --> returns fakeVault tempusAMM.getPoolId() --> returns 0 tempusAMM.tempusPool() --> returns fakePool   call depositAndProvideLiquidity(fakeTempusAMM,1,false) // false -> yieldBearingToken _getAMMDetailsAndEnsureInitialized returns fakeVault,0, {token1,token2},{balance1,balance2} _deposit(fakePool,1,false) calls _depositYieldBearing which calls fakePool.deposit()  and returns fakeMintedShares _provideLiquidity(...)  calculates a vale of ammLiquidityProvisionAmounts _provideLiquidity(...)  skips the safeTransferFrom because sender == address(this))  the calls to fakeVault.JoinPoolRequest() and fakeVault.joinPool() can be faked. _provideLiquidity(...)  returns the value ammLiquidityProvisionAmounts  Now fakeMintedShares - ammLiquidityProvisionAmounts number of TokenToSteal1 and TokenToSteal2 are transferred to msg.sender  As you can both manipulate TokenToSteal1 and fakeMintedShares, you can transfer any token to msg.sender  ## Tools Used  ## Recommended Mitigation Steps Create a whitelist for tempusAMMs   
# Handle  chenyu   # Vulnerability details  ## Impact [PermanentlyOwnable](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/utils/PermanentlyOwnable.sol) does not prevent transferring to a dead address. It's possible to have a human error that transfers the contract ownership to a address not owned by the old owner.  ## Recommended Mitigation Steps Recommend a two step transfer that owner nominates an account, then the nominated account call an accept function to ensure the nominated account is valid.  
# Handle  chenyu   # Vulnerability details  ## Impact In TempusAMM constructor [L138](https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L138), the scaling factor 0 always maps to yieldShare, and scaling factor 1 always maps to principalShare, even though in L134 the two token might swap if principalShare < yieldShare, which makes _token0 = principalShare and _token1 = yieldShare, but scaling factor 0 is based on yieldShare.  Later [_scalingFactor](https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L802) is based on _token0, so it might get the wrong scaling factor if principalShare and yieldShare had swapped.  ## Recommended Mitigation Steps Update the lines to ```         _scalingFactor0 = _computeScalingFactor(IERC20(address(_token0)));         _scalingFactor1 = _computeScalingFactor(IERC20(address(_token1))); ```  
# Handle  loop   # Vulnerability details  TempusPool needs to be initialized with a valid and existing controller. When initializing a pool `address controller` is passed to the constructor of a pool implementation. This `address` is then passed as `address ctrl` to the TempusPool constructor where it is set to the immutable `address controller`. If a pool accidentally gets initialized with the zero address passed to the constructor there is no way to change it and the pool needs to be reinitialized.  ## Proof of Concept https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusPool.sol#L66-L100  ## Recommended Mitigation Steps Add something along the lines of `require(ctrl != address(0), "controller can not be zero` to avoid potential invalid pool initializations.   
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  AaveTempusPool.sol: Unused named return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/pools/AaveTempusPool.sol#L74  LidoTempusPool.sol: Unused named return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/pools/LidoTempusPool.sol#L59  TempusAMM.sol: Unneeded return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L533  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named return variables or return.  
# Handle  pants   # Vulnerability details    
# Handle  pants   # Vulnerability details  These `public` functions are never called by their contract: - `TempusAMM.getSwapAmountToEndWithEqualShares()` - `TempusAMM.getRate()` - `AaveTempusPool.currentInterestRate()` - `AaveTempusPool.numAssetsPerYieldToken()` - `AaveTempusPool.numYieldTokensPerAsset()` - `CompoundTempusPool.currentInterestRate()` - `CompoundTempusPool.numAssetsPerYieldToken()` - `CompoundTempusPool.numYieldTokensPerAsset()` - `LidoTempusPool.currentInterestRate()` - `LidoTempusPool.numAssetsPerYieldToken()` - `LidoTempusPool.numYieldTokensPerAsset()` - `ERC20FixedSupply.decimals()` - `ERC20OwnerMintableToken.burn()` - `ERC20OwnerMintableToken.burnFrom()` - `PoolShare.decimals()` - `PermanentlyOwnable.renounceOwnership()` - `TempusController.depositYieldBearing()` - `TempusController.depositBacking()` - `TempusController.redeemToYieldBearing()` - `TempusController.redeemToBacking()` - `TempusPool.estimatedMintedShares()` - `TempusPool.estimatedRedeem()`  Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `external`.  
# Handle  pants   # Vulnerability details  These files has open TODOs: - `TempusPool.sol` - `unusedAMMImportOnly.sol` - `Fixed256xVar.sol` - `LidoTempusPool.sol`  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Resolve these TODOs and bubble up the errors.  
# Handle  TomFrench   # Vulnerability details  ## Impact Increased gas costs  ## Proof of Concept  On L189, we use a uint8 as the for loop variable: https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L189  Due to how the EVM natively works on 256 numbers, using a 8 bit number here introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage  ## Recommended Mitigation Steps  Change i to be a uint256 and replace any similar uints which only exist in memory and aren't required to use a smaller type.  
# Handle  hyh   # Vulnerability details  ## Vulnerability Details getAMMOrderedAmounts, https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L692, and _exitTempusAmmAndRedeem, https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L644, functions use explicit token comparison for ordering, while it is based on current Balancer pool implementation, which can change, leading to contract logic discrepancies.  In the same time _getAMMDetailsAndEnsureInitialized (https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L673) do rely on PoolTokens, which obtain token list in Balancer's call sequence as follows: PoolTokens._getPoolTokens -> TwoTokenPoolsBalance._getTwoTokenPoolTokens -> TwoTokenPoolsBalance._getTwoTokenPoolBalances -> TwoTokenPoolsBalance._twoTokenPoolTokens[].  TwoTokenPoolsBalance._twoTokenPoolTokens[] is ordered during _registerTwoTokenPoolTokens, but this is current implementation.  It is safer to use vault.getPoolTokens(poolId) in getAMMOrderedAmounts to obtain an ordered pair.  This can matter as AMM token usage isn't symmetric (https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L84).  ## Impact Probability here is low and risk rating is minimal, but the impact can vary as TempusController contract  logic rely on token ordering.  
# Handle  pauliax   # Vulnerability details  ## Impact The loop here is not really necessary as _TOTAL_TOKENS is a constant of 2 so there is always just 1 iteration:         for (uint256 i = 1; i < _TOTAL_TOKENS; ++i) {             uint256 currentBalance = balances[i];             if (currentBalance > maxBalance) {                 chosenTokenIndex = i;                 maxBalance = currentBalance;             }         }  ## Recommended Mitigation Steps Consider if you want to reduce gas usage by eliminating this loop here but taking the risk that _TOTAL_TOKENS will not be updated to a different value.  
# Handle  pauliax   # Vulnerability details  ## Impact There are unused imports. They will increase the size of deployment with no real benefit. Consider removing unused imports to save some gas. Examples of such imports are:   In TempusAMMUserDataHelpers   import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/IERC20.sol";  In TempusController   import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";  In TempusAMM   import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";  ## Recommended Mitigation Steps Consider removing them to reduce deployment gas usage.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusPool.sol#L375-L375  ```solidity uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0; ```  `maturityTime - currentTime` will never underflow.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/mocks/aave/WadRayMath.sol#L59-L59  ```solidity require(a <= (type(uint256).max - halfWAD) / b, "multiplication oveflow"); ```  `oveflow` should be `overflow`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/VecMath.sol#L10-L10  ```solidity /// @dev Substracting two vectors ```  `Substracting` should be `Subtracting`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/mocks/lido/StETH.sol#L302-L302  ```solidity * @dev This is used for calaulating tokens from shares and vice versa. ```  `calaulating` should be `calculating`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L779-L779  ```solidity //  - endTime is alawys larger than startTime ```  `alawys` should be `always`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L47-L47  ```solidity /// @param recipient Address of user that recieved Yield Bearing Tokens ```  `recieved` should be `received`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L163-L163  ```solidity /// @param recipient Address of user that will recieve yield bearing tokens ```  `recieve` should be `receive`.  
# Handle  cmichel   # Vulnerability details  In `CompoundTempusPool`, the `cToken` and the base class' `yieldBearingToken` storage fields are the same. Remove the `cToken` field and the assignment in the constructor to save gas.   
# Handle  cmichel   # Vulnerability details  The (second) `TempusController._exitTempusAmmAndRedeem` function swaps the difference of yield and principal shares using the AMM.  ```solidity swap(     tempusAMM,     tempusAMM.getSwapAmountToEndWithEqualShares(principals, yields, maxLeftoverShares),     tokenIn,     tokenOut,     0 // @audit min return of zero ); // yields and principals are updated to the received amounts and redeemed // ... ```  It does not use a min return value for this swap and it is, therefore, susceptible to sandwich attacks.  > A common attack in DeFi is the sandwich attack. Upon observing a trade of asset X for asset Y, an attacker frontruns the victim trade by also buying asset Y, lets the victim execute the trade, and then backruns (executes after) the victim by trading back the amount gained in the first trade. Intuitively, one uses the knowledge that someone’s going to buy an asset, and that this trade will increase its price, to make a profit. The attacker’s plan is to buy this asset cheap, let the victim buy at an increased price, and then sell the received amount again at a higher price afterwards.  ## Impact Trades can happen at a bad price and lead to receiving fewer tokens than at a fair market price. The attacker's profit is the user's loss.  ## Recommended Mitigation Steps Add minimum return amount checks. Accept a function parameter that can be chosen by the transaction sender, then check that the actually received amount is above this parameter. Similar to `minLpAmountsOut` but for the yields & principal shares (or the redeemed tokens).  
# Handle  cmichel   # Vulnerability details  There's a griefing attack where an attacker can make any user transaction for `TempusController.exitTempusAMM` fail. In `_exitTempusAMM`, the user exits their LP position and claims back yield and principal shares. The LP amounts to redeem are determined by the function parameter `lpTokensAmount`. A final `assert(tempusAMM.balanceOf(address(this)) == 0)` statement checks that the LP token amount of the contract is zero after the exit. This is only true if no other LP shares were already in the contract.  However, an attacker can frontrun this call and send the smallest unit of LP shares to the contract which then makes the original deposit-and-fix transaction fail.  ## Impact All `exitTempusAMM` calls can be made to fail and this function becomes unusable.  ## Recommended Mitigation Steps Remove the `assert` check.  
# Handle  cmichel   # Vulnerability details  There's a griefing attack where an attacker can make any user transaction for `TempusController.depositAndFix` fail. In `_depositAndFix`, `swapAmount` many yield shares are swapped to principal where `swapAmount` is derived from the function arguments. A final `assert(yieldShares.balanceOf(address(this)) == 0)` statement checks that the yield shares of the contract are zero after the swap. This is only true if no other yield shares were already in the contract.  However, an attacker can frontrun this call and send the smallest unit of yield shares to the contract which then makes the original deposit-and-fix transaction fail.  ## Impact All `depositAndFix` calls can be made to fail and this function becomes unusable.  ## Recommended Mitigation Steps Remove the `assert` check.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Reduced flexibility of AMM + additional gas costs on swaps  ## Proof of Concept  As the relative payouts of the principal and yield tokens are fixed at the point of finalisation, there's no need to freeze the AMM as it will just rapidly be arbed to the final prices of each token. No funds will be lost by LPs.  Making this change would reduce gas costs as swaps won't have to check maturity (load the TempusPool then perform SLOAD for maturity state variable).  ## Recommended Mitigation Steps  Remove `beforeMaturity` modifier from AMM.  
# Handle  TomFrench   # Vulnerability details  ## Impact  ## Proof of Concept  As the `TempusAmm` only ever registers with the Balancer Vault with the two token specialization the `GeneralPool` interface will never be used as the Vault will call the `MinimalSwapInfoPool` hooks instead.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L107-L110  See here in the Balancer Vault code:  https://github.com/balancer-labs/balancer-v2-monorepo/blob/62c5cba7cae1d481f913c90fe0d9d94e101570c5/pkg/vault/contracts/Swaps.sol#L287-L292  ## Recommended Mitigation Steps  Remove the inheritance from `BaseGeneralPool` and remove the functions highlighted in the link below. This will help reduce bytecode from the AMM factory and reduce deployment costs.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L283-L309  
# Handle  TomFrench   # Vulnerability details  ## Impact  Higher gas costs on transfers of tokens from user to TempusPool  ## Proof of Concept  Following the flow of tokens from the user to their the `TempusPool contract`:  1. User calls `TempusController.depositBacking`, `TempusController` transfers user's tokens to itself and approves relevant `TempusPool`  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L412-L414  2. `TempusController` calls `TempusPool.deposit` which in turn transfers tokens from the `TempusController` and then invests them.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusPool.sol#L178  This first transfer is then superfluous as the `TempusPool` trusts the `TempusController` (it's the only contract which may call `deposit`). We're then incurring the costs of 1 `transfer` and 1 `approve` unnecessarily.  ## Recommended Mitigation Steps  As `TempusPool` trusts `TempusController`, `TempusController` can transfer the tokens directly to `TempusPool` and just tell it how much has been deposited.  L412-L414 of `TempusController.sol` would then be replaced with: ``` // Deposit to directly to targetPool uint transferredYBT = yieldBearingToken.untrustedTransferFrom(msg.sender, targetPool, yieldTokenAmount); ```  
# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs on several `TempusPool` functions  ## Proof of Concept  `TempusPool`s have a `finalize` function which checks whether `block.timestamp >= maturityTime` and flips the `maturity` storage variable as well as setting `maturityInterestRate` to the current interest rate.  https://github.com/tempus-finance/tempus-protocol/blob/0240b4d172d7aa093a70e0401f4140c99aa30dc6/contracts/TempusPool.sol#L126-L135  `maturity` is used in several places to check whether the pool has expired however checking this variable is more expensive than checking `block.timestamp >= maturityTime` (due to the need for a SLOAD whereas `maturityTime` is immutable so no SLOAD is needed). I'd recommend making a `function matured() public view` to keep the readability.  However `maturityInterestRate` still needs to be set correctly. This could be done by reading the current interest rate when `matured()` returns true but `maturityInterestRate == 0` this could cause issues with some functions which are currently view functions however.   ## Recommended Mitigation Steps  Half solution:  Replace `matured` state variable with a `matured()` view function which returns `maturityInterestRate > 0`. This removes an SSTORE from `finalize` and an `SLOAD` from any function which uses `maturityInterestRate` as you can just check if it's greater than zero to see if the pool has matured.  Full solution:   Replace `matured` state variable with a `matured()` view function which returns  `block.timestamp >= maturityTime`. This combined with setting `maturityInterestRate` when you see that `matured() == true` and `maturityInterestRate == 0` would remove the need for the `finalize` function entirely.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact If `initInterestRate` in the `TempusPool`'s constructor is given as 0,  no funds can be withdrawn as `getRedemptionAmounts()` always panic errors with _division by 0_ ([link](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusPool.sol#L305)).  ## Recommended Mitigation Steps It should be stated in the constructor's specs that `initInterestRate` should not be 0.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The `protocolName` variables in the protocol-specific `TempusPool`s are set as _immutable_ but could be set as _constant_.  See [Compound](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/CompoundTempusPool.sol#L19),  [Aave](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/AaveTempusPool.sol#L18),  [Lido](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/LidoTempusPool.sol#L9).  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _depositAndProvideLiquidity can be used go retrieve arbitrary ERC20 tokens from the TempusController.sol contract.  As the test contract of TempusController.sol https://goerli.etherscan.io/address/0xd4330638b87f97ec1605d7ec7d67ea1de5dd7aaa shows, it has indeed ERC20 tokens.  The problem is due to the fact that you supply an arbitrary tempusAMM to depositAndProvideLiquidity and thus to _depositAndProvideLiquidity.  tempusAMM could be a fake contract that supplies values that are completely fake.  At the end of the function _depositAndProvideLiquidity, ERC20 tokens are send to the user. If you can manipulate the variables ammTokens,  mintedShares  and sharesUsed you can send back any tokens held in the contract "ammTokens[0].safeTransfer(msg.sender, mintedShares - sharesUsed[0]);"  The Proof of Concept shows an approach to do this.    ## Proof of Concept https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L73-L79  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L304-L335  Create a fake Vault contract (fakeVault) with the following functions: fakeVault.getPoolTokens(poolId) --> returns {TokenToSteal1,TokenToSteal2},{fakeBalance1,fakeBalance2},0 fakeVault.JoinPoolRequest() --> do nothing fakeVault.joinPool() --> do nothing  Create a fake Pool contract (fakePool) with the following functions: fakePool.yieldBearingToken() --> returns fakeYieldBearingToken fakePool.deposit() --> returns fakeMintedShares,....  Create a fake ammTokens contract with the following functions: tempusAMM.getVault() --> returns fakeVault tempusAMM.getPoolId() --> returns 0 tempusAMM.tempusPool() --> returns fakePool   call depositAndProvideLiquidity(fakeTempusAMM,1,false) // false -> yieldBearingToken _getAMMDetailsAndEnsureInitialized returns fakeVault,0, {token1,token2},{balance1,balance2} _deposit(fakePool,1,false) calls _depositYieldBearing which calls fakePool.deposit()  and returns fakeMintedShares _provideLiquidity(...)  calculates a vale of ammLiquidityProvisionAmounts _provideLiquidity(...)  skips the safeTransferFrom because sender == address(this))  the calls to fakeVault.JoinPoolRequest() and fakeVault.joinPool() can be faked. _provideLiquidity(...)  returns the value ammLiquidityProvisionAmounts  Now fakeMintedShares - ammLiquidityProvisionAmounts number of TokenToSteal1 and TokenToSteal2 are transferred to msg.sender  As you can both manipulate TokenToSteal1 and fakeMintedShares, you can transfer any token to msg.sender  ## Tools Used  ## Recommended Mitigation Steps Create a whitelist for tempusAMMs   
# Handle  chenyu   # Vulnerability details  ## Impact [PermanentlyOwnable](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/utils/PermanentlyOwnable.sol) does not prevent transferring to a dead address. It's possible to have a human error that transfers the contract ownership to a address not owned by the old owner.  ## Recommended Mitigation Steps Recommend a two step transfer that owner nominates an account, then the nominated account call an accept function to ensure the nominated account is valid.  
# Handle  chenyu   # Vulnerability details  ## Impact In TempusAMM constructor [L138](https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L138), the scaling factor 0 always maps to yieldShare, and scaling factor 1 always maps to principalShare, even though in L134 the two token might swap if principalShare < yieldShare, which makes _token0 = principalShare and _token1 = yieldShare, but scaling factor 0 is based on yieldShare.  Later [_scalingFactor](https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L802) is based on _token0, so it might get the wrong scaling factor if principalShare and yieldShare had swapped.  ## Recommended Mitigation Steps Update the lines to ```         _scalingFactor0 = _computeScalingFactor(IERC20(address(_token0)));         _scalingFactor1 = _computeScalingFactor(IERC20(address(_token1))); ```  
# Handle  loop   # Vulnerability details  TempusPool needs to be initialized with a valid and existing controller. When initializing a pool `address controller` is passed to the constructor of a pool implementation. This `address` is then passed as `address ctrl` to the TempusPool constructor where it is set to the immutable `address controller`. If a pool accidentally gets initialized with the zero address passed to the constructor there is no way to change it and the pool needs to be reinitialized.  ## Proof of Concept https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusPool.sol#L66-L100  ## Recommended Mitigation Steps Add something along the lines of `require(ctrl != address(0), "controller can not be zero` to avoid potential invalid pool initializations.   
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  AaveTempusPool.sol: Unused named return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/pools/AaveTempusPool.sol#L74  LidoTempusPool.sol: Unused named return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/pools/LidoTempusPool.sol#L59  TempusAMM.sol: Unneeded return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L533  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named return variables or return.  
# Handle  pants   # Vulnerability details    
# Handle  pants   # Vulnerability details  These `public` functions are never called by their contract: - `TempusAMM.getSwapAmountToEndWithEqualShares()` - `TempusAMM.getRate()` - `AaveTempusPool.currentInterestRate()` - `AaveTempusPool.numAssetsPerYieldToken()` - `AaveTempusPool.numYieldTokensPerAsset()` - `CompoundTempusPool.currentInterestRate()` - `CompoundTempusPool.numAssetsPerYieldToken()` - `CompoundTempusPool.numYieldTokensPerAsset()` - `LidoTempusPool.currentInterestRate()` - `LidoTempusPool.numAssetsPerYieldToken()` - `LidoTempusPool.numYieldTokensPerAsset()` - `ERC20FixedSupply.decimals()` - `ERC20OwnerMintableToken.burn()` - `ERC20OwnerMintableToken.burnFrom()` - `PoolShare.decimals()` - `PermanentlyOwnable.renounceOwnership()` - `TempusController.depositYieldBearing()` - `TempusController.depositBacking()` - `TempusController.redeemToYieldBearing()` - `TempusController.redeemToBacking()` - `TempusPool.estimatedMintedShares()` - `TempusPool.estimatedRedeem()`  Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `external`.  
# Handle  pants   # Vulnerability details  These files has open TODOs: - `TempusPool.sol` - `unusedAMMImportOnly.sol` - `Fixed256xVar.sol` - `LidoTempusPool.sol`  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Resolve these TODOs and bubble up the errors.  
# Handle  TomFrench   # Vulnerability details  ## Impact Increased gas costs  ## Proof of Concept  On L189, we use a uint8 as the for loop variable: https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L189  Due to how the EVM natively works on 256 numbers, using a 8 bit number here introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage  ## Recommended Mitigation Steps  Change i to be a uint256 and replace any similar uints which only exist in memory and aren't required to use a smaller type.  
# Handle  hyh   # Vulnerability details  ## Vulnerability Details getAMMOrderedAmounts, https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L692, and _exitTempusAmmAndRedeem, https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L644, functions use explicit token comparison for ordering, while it is based on current Balancer pool implementation, which can change, leading to contract logic discrepancies.  In the same time _getAMMDetailsAndEnsureInitialized (https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L673) do rely on PoolTokens, which obtain token list in Balancer's call sequence as follows: PoolTokens._getPoolTokens -> TwoTokenPoolsBalance._getTwoTokenPoolTokens -> TwoTokenPoolsBalance._getTwoTokenPoolBalances -> TwoTokenPoolsBalance._twoTokenPoolTokens[].  TwoTokenPoolsBalance._twoTokenPoolTokens[] is ordered during _registerTwoTokenPoolTokens, but this is current implementation.  It is safer to use vault.getPoolTokens(poolId) in getAMMOrderedAmounts to obtain an ordered pair.  This can matter as AMM token usage isn't symmetric (https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L84).  ## Impact Probability here is low and risk rating is minimal, but the impact can vary as TempusController contract  logic rely on token ordering.  
# Handle  pauliax   # Vulnerability details  ## Impact The loop here is not really necessary as _TOTAL_TOKENS is a constant of 2 so there is always just 1 iteration:         for (uint256 i = 1; i < _TOTAL_TOKENS; ++i) {             uint256 currentBalance = balances[i];             if (currentBalance > maxBalance) {                 chosenTokenIndex = i;                 maxBalance = currentBalance;             }         }  ## Recommended Mitigation Steps Consider if you want to reduce gas usage by eliminating this loop here but taking the risk that _TOTAL_TOKENS will not be updated to a different value.  
# Handle  pauliax   # Vulnerability details  ## Impact There are unused imports. They will increase the size of deployment with no real benefit. Consider removing unused imports to save some gas. Examples of such imports are:   In TempusAMMUserDataHelpers   import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/IERC20.sol";  In TempusController   import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";  In TempusAMM   import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";  ## Recommended Mitigation Steps Consider removing them to reduce deployment gas usage.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusPool.sol#L375-L375  ```solidity uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0; ```  `maturityTime - currentTime` will never underflow.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/mocks/aave/WadRayMath.sol#L59-L59  ```solidity require(a <= (type(uint256).max - halfWAD) / b, "multiplication oveflow"); ```  `oveflow` should be `overflow`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/VecMath.sol#L10-L10  ```solidity /// @dev Substracting two vectors ```  `Substracting` should be `Subtracting`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/mocks/lido/StETH.sol#L302-L302  ```solidity * @dev This is used for calaulating tokens from shares and vice versa. ```  `calaulating` should be `calculating`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L779-L779  ```solidity //  - endTime is alawys larger than startTime ```  `alawys` should be `always`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L47-L47  ```solidity /// @param recipient Address of user that recieved Yield Bearing Tokens ```  `recieved` should be `received`.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L163-L163  ```solidity /// @param recipient Address of user that will recieve yield bearing tokens ```  `recieve` should be `receive`.  
# Handle  cmichel   # Vulnerability details  In `CompoundTempusPool`, the `cToken` and the base class' `yieldBearingToken` storage fields are the same. Remove the `cToken` field and the assignment in the constructor to save gas.   
# Handle  cmichel   # Vulnerability details  The (second) `TempusController._exitTempusAmmAndRedeem` function swaps the difference of yield and principal shares using the AMM.  ```solidity swap(     tempusAMM,     tempusAMM.getSwapAmountToEndWithEqualShares(principals, yields, maxLeftoverShares),     tokenIn,     tokenOut,     0 // @audit min return of zero ); // yields and principals are updated to the received amounts and redeemed // ... ```  It does not use a min return value for this swap and it is, therefore, susceptible to sandwich attacks.  > A common attack in DeFi is the sandwich attack. Upon observing a trade of asset X for asset Y, an attacker frontruns the victim trade by also buying asset Y, lets the victim execute the trade, and then backruns (executes after) the victim by trading back the amount gained in the first trade. Intuitively, one uses the knowledge that someone’s going to buy an asset, and that this trade will increase its price, to make a profit. The attacker’s plan is to buy this asset cheap, let the victim buy at an increased price, and then sell the received amount again at a higher price afterwards.  ## Impact Trades can happen at a bad price and lead to receiving fewer tokens than at a fair market price. The attacker's profit is the user's loss.  ## Recommended Mitigation Steps Add minimum return amount checks. Accept a function parameter that can be chosen by the transaction sender, then check that the actually received amount is above this parameter. Similar to `minLpAmountsOut` but for the yields & principal shares (or the redeemed tokens).  
# Handle  cmichel   # Vulnerability details  There's a griefing attack where an attacker can make any user transaction for `TempusController.exitTempusAMM` fail. In `_exitTempusAMM`, the user exits their LP position and claims back yield and principal shares. The LP amounts to redeem are determined by the function parameter `lpTokensAmount`. A final `assert(tempusAMM.balanceOf(address(this)) == 0)` statement checks that the LP token amount of the contract is zero after the exit. This is only true if no other LP shares were already in the contract.  However, an attacker can frontrun this call and send the smallest unit of LP shares to the contract which then makes the original deposit-and-fix transaction fail.  ## Impact All `exitTempusAMM` calls can be made to fail and this function becomes unusable.  ## Recommended Mitigation Steps Remove the `assert` check.  
# Handle  cmichel   # Vulnerability details  There's a griefing attack where an attacker can make any user transaction for `TempusController.depositAndFix` fail. In `_depositAndFix`, `swapAmount` many yield shares are swapped to principal where `swapAmount` is derived from the function arguments. A final `assert(yieldShares.balanceOf(address(this)) == 0)` statement checks that the yield shares of the contract are zero after the swap. This is only true if no other yield shares were already in the contract.  However, an attacker can frontrun this call and send the smallest unit of yield shares to the contract which then makes the original deposit-and-fix transaction fail.  ## Impact All `depositAndFix` calls can be made to fail and this function becomes unusable.  ## Recommended Mitigation Steps Remove the `assert` check.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Reduced flexibility of AMM + additional gas costs on swaps  ## Proof of Concept  As the relative payouts of the principal and yield tokens are fixed at the point of finalisation, there's no need to freeze the AMM as it will just rapidly be arbed to the final prices of each token. No funds will be lost by LPs.  Making this change would reduce gas costs as swaps won't have to check maturity (load the TempusPool then perform SLOAD for maturity state variable).  ## Recommended Mitigation Steps  Remove `beforeMaturity` modifier from AMM.  
# Handle  TomFrench   # Vulnerability details  ## Impact  ## Proof of Concept  As the `TempusAmm` only ever registers with the Balancer Vault with the two token specialization the `GeneralPool` interface will never be used as the Vault will call the `MinimalSwapInfoPool` hooks instead.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L107-L110  See here in the Balancer Vault code:  https://github.com/balancer-labs/balancer-v2-monorepo/blob/62c5cba7cae1d481f913c90fe0d9d94e101570c5/pkg/vault/contracts/Swaps.sol#L287-L292  ## Recommended Mitigation Steps  Remove the inheritance from `BaseGeneralPool` and remove the functions highlighted in the link below. This will help reduce bytecode from the AMM factory and reduce deployment costs.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L283-L309  
# Handle  TomFrench   # Vulnerability details  ## Impact  Higher gas costs on transfers of tokens from user to TempusPool  ## Proof of Concept  Following the flow of tokens from the user to their the `TempusPool contract`:  1. User calls `TempusController.depositBacking`, `TempusController` transfers user's tokens to itself and approves relevant `TempusPool`  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L412-L414  2. `TempusController` calls `TempusPool.deposit` which in turn transfers tokens from the `TempusController` and then invests them.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusPool.sol#L178  This first transfer is then superfluous as the `TempusPool` trusts the `TempusController` (it's the only contract which may call `deposit`). We're then incurring the costs of 1 `transfer` and 1 `approve` unnecessarily.  ## Recommended Mitigation Steps  As `TempusPool` trusts `TempusController`, `TempusController` can transfer the tokens directly to `TempusPool` and just tell it how much has been deposited.  L412-L414 of `TempusController.sol` would then be replaced with: ``` // Deposit to directly to targetPool uint transferredYBT = yieldBearingToken.untrustedTransferFrom(msg.sender, targetPool, yieldTokenAmount); ```  
# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs on several `TempusPool` functions  ## Proof of Concept  `TempusPool`s have a `finalize` function which checks whether `block.timestamp >= maturityTime` and flips the `maturity` storage variable as well as setting `maturityInterestRate` to the current interest rate.  https://github.com/tempus-finance/tempus-protocol/blob/0240b4d172d7aa093a70e0401f4140c99aa30dc6/contracts/TempusPool.sol#L126-L135  `maturity` is used in several places to check whether the pool has expired however checking this variable is more expensive than checking `block.timestamp >= maturityTime` (due to the need for a SLOAD whereas `maturityTime` is immutable so no SLOAD is needed). I'd recommend making a `function matured() public view` to keep the readability.  However `maturityInterestRate` still needs to be set correctly. This could be done by reading the current interest rate when `matured()` returns true but `maturityInterestRate == 0` this could cause issues with some functions which are currently view functions however.   ## Recommended Mitigation Steps  Half solution:  Replace `matured` state variable with a `matured()` view function which returns `maturityInterestRate > 0`. This removes an SSTORE from `finalize` and an `SLOAD` from any function which uses `maturityInterestRate` as you can just check if it's greater than zero to see if the pool has matured.  Full solution:   Replace `matured` state variable with a `matured()` view function which returns  `block.timestamp >= maturityTime`. This combined with setting `maturityInterestRate` when you see that `matured() == true` and `maturityInterestRate == 0` would remove the need for the `finalize` function entirely.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact If `initInterestRate` in the `TempusPool`'s constructor is given as 0,  no funds can be withdrawn as `getRedemptionAmounts()` always panic errors with _division by 0_ ([link](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusPool.sol#L305)).  ## Recommended Mitigation Steps It should be stated in the constructor's specs that `initInterestRate` should not be 0.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The `protocolName` variables in the protocol-specific `TempusPool`s are set as _immutable_ but could be set as _constant_.  See [Compound](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/CompoundTempusPool.sol#L19),  [Aave](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/AaveTempusPool.sol#L18),  [Lido](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/LidoTempusPool.sol#L9).  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _depositAndProvideLiquidity can be used go retrieve arbitrary ERC20 tokens from the TempusController.sol contract.  As the test contract of TempusController.sol https://goerli.etherscan.io/address/0xd4330638b87f97ec1605d7ec7d67ea1de5dd7aaa shows, it has indeed ERC20 tokens.  The problem is due to the fact that you supply an arbitrary tempusAMM to depositAndProvideLiquidity and thus to _depositAndProvideLiquidity.  tempusAMM could be a fake contract that supplies values that are completely fake.  At the end of the function _depositAndProvideLiquidity, ERC20 tokens are send to the user. If you can manipulate the variables ammTokens,  mintedShares  and sharesUsed you can send back any tokens held in the contract "ammTokens[0].safeTransfer(msg.sender, mintedShares - sharesUsed[0]);"  The Proof of Concept shows an approach to do this.    ## Proof of Concept https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L73-L79  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L304-L335  Create a fake Vault contract (fakeVault) with the following functions: fakeVault.getPoolTokens(poolId) --> returns {TokenToSteal1,TokenToSteal2},{fakeBalance1,fakeBalance2},0 fakeVault.JoinPoolRequest() --> do nothing fakeVault.joinPool() --> do nothing  Create a fake Pool contract (fakePool) with the following functions: fakePool.yieldBearingToken() --> returns fakeYieldBearingToken fakePool.deposit() --> returns fakeMintedShares,....  Create a fake ammTokens contract with the following functions: tempusAMM.getVault() --> returns fakeVault tempusAMM.getPoolId() --> returns 0 tempusAMM.tempusPool() --> returns fakePool   call depositAndProvideLiquidity(fakeTempusAMM,1,false) // false -> yieldBearingToken _getAMMDetailsAndEnsureInitialized returns fakeVault,0, {token1,token2},{balance1,balance2} _deposit(fakePool,1,false) calls _depositYieldBearing which calls fakePool.deposit()  and returns fakeMintedShares _provideLiquidity(...)  calculates a vale of ammLiquidityProvisionAmounts _provideLiquidity(...)  skips the safeTransferFrom because sender == address(this))  the calls to fakeVault.JoinPoolRequest() and fakeVault.joinPool() can be faked. _provideLiquidity(...)  returns the value ammLiquidityProvisionAmounts  Now fakeMintedShares - ammLiquidityProvisionAmounts number of TokenToSteal1 and TokenToSteal2 are transferred to msg.sender  As you can both manipulate TokenToSteal1 and fakeMintedShares, you can transfer any token to msg.sender  ## Tools Used  ## Recommended Mitigation Steps Create a whitelist for tempusAMMs   
# Handle  chenyu   # Vulnerability details  ## Impact [PermanentlyOwnable](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/utils/PermanentlyOwnable.sol) does not prevent transferring to a dead address. It's possible to have a human error that transfers the contract ownership to a address not owned by the old owner.  ## Recommended Mitigation Steps Recommend a two step transfer that owner nominates an account, then the nominated account call an accept function to ensure the nominated account is valid.  
# Handle  chenyu   # Vulnerability details  ## Impact In TempusAMM constructor [L138](https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L138), the scaling factor 0 always maps to yieldShare, and scaling factor 1 always maps to principalShare, even though in L134 the two token might swap if principalShare < yieldShare, which makes _token0 = principalShare and _token1 = yieldShare, but scaling factor 0 is based on yieldShare.  Later [_scalingFactor](https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L802) is based on _token0, so it might get the wrong scaling factor if principalShare and yieldShare had swapped.  ## Recommended Mitigation Steps Update the lines to ```         _scalingFactor0 = _computeScalingFactor(IERC20(address(_token0)));         _scalingFactor1 = _computeScalingFactor(IERC20(address(_token1))); ```  
# Handle  loop   # Vulnerability details  TempusPool needs to be initialized with a valid and existing controller. When initializing a pool `address controller` is passed to the constructor of a pool implementation. This `address` is then passed as `address ctrl` to the TempusPool constructor where it is set to the immutable `address controller`. If a pool accidentally gets initialized with the zero address passed to the constructor there is no way to change it and the pool needs to be reinitialized.  ## Proof of Concept https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusPool.sol#L66-L100  ## Recommended Mitigation Steps Add something along the lines of `require(ctrl != address(0), "controller can not be zero` to avoid potential invalid pool initializations.   
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  AaveTempusPool.sol: Unused named return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/pools/AaveTempusPool.sol#L74  LidoTempusPool.sol: Unused named return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/pools/LidoTempusPool.sol#L59  TempusAMM.sol: Unneeded return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L533  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named return variables or return.  
