# Handle  pauliax   # Vulnerability details  ## Impact I don't think it's necessary for the library to use itself here:   library LibBytes {     using LibBytes for bytes;  ## Recommended Mitigation Steps Remove this 'using' statement as it does not give anything in this case.  
# Handle  pauliax   # Vulnerability details  ## Impact First perform the addition and only then check the length to avoid this duplicate math operation:     require(b.length >= index + 32, "BytesLib: length");     // Arrays are prefixed by a 256 bit length parameter     index += 32; Or if you want to stay with this approach, then at least consider using the 'unchecked' keyword when this addition is performed the second time as then ready know this can't overflow. Also, in function recoverAddrImpl the same operation is performed twice:   sig.length - 33  ## Recommended Mitigation Steps Refactor duplicate math operations.  
# Handle  pauliax   # Vulnerability details  ## Impact There is a common issue that ecrecover returns empty (0x0) address when the signature is invalid. function recoverAddrImpl should check that before returning the result of ecrecover.  ## Recommended Mitigation Steps See the solution here: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/cryptography/ECDSA.sol#L68  
# Handle  pauliax   # Vulnerability details  ## Impact The 'DOMAIN_SEPARATOR' is not recalculated in the case of a hard fork. The variable DOMAIN_SEPARATOR in contract QuickAccManager is cached in the contract storage and will not change after being initialized. However, if a hard fork happens after the contract deployment, the domain would become invalid on one of the forked chains due to the block.chainid has changed.  A similar issue was reported in a previous contest and was assigned a severity of low: https://github.com/code-423n4/2021-06-realitycards-findings/issues/166  ## Recommended Mitigation Steps An elegant solution that you may consider applying is from Sushi Trident: https://github.com/sushiswap/trident/blob/concentrated/contracts/pool/concentrated/TridentNFT.sol#L47-L62  
# Handle  pauliax   # Vulnerability details  ## Impact WETH address is hardcoded but it may differ on other chains, e.g. Polygon, so make sure to check this before deploying and update if neccessary:   address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;  ## Recommended Mitigation Steps You should consider injecting WETH address via the constructor.  
# Handle  JMukesh   # Vulnerability details  ## Impact require message give the idea what was the cause of failure , so its the best practise to  add message in require()  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L218  ## Tools Used manual reveiw  ## Recommended Mitigation Steps add message in require()  
# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept most of contract used floating pragma  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed solidity version  
# Handle  WatchPug   # Vulnerability details  Most of the for loops in the codebase use `<` to control the loop:  ```solidity for (uint i=0; i<len; i++) { ```  However, in `Zapper.sol`, all 7 for loops are using `!=`:  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L79-L79  ```solidity for (uint i=0; i!=spenders.length; i++) { ```  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L87-L87   https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L110-L110  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L126-L126  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L131-L131  Using `for (uint i=0; i!=len; i++) {}` to control for loops introduces inconsistent code style.  ### Recommendation  Change from `!=` to `<` for all for loops.  
# Handle  cmichel   # Vulnerability details  The `SignatureValidatorV2.recoverAddrImpl` function currently uses three `if (mode == *)` checks but the modes are all distinct enum values and therefore an `else if` can be used. This is more efficient because if the first branch is already matched, there's no need to check the `mode` against the remaining values anymore.  
# Handle  cmichel   # Vulnerability details  The `index += 32` addition in `readBytes32` can be put in an `unsafe` block as the array length is already checked to be greater than the addition.  
# Handle  cmichel   # Vulnerability details  Several different signature modes can be used and `Identity.execute` forwards the `signature` parameter to the `SignatureValidator` library. The returned `signer` is then used for the `privileges` check:  ```solidity address signer = SignatureValidator.recoverAddrImpl(hash, signature, true); // signer will be QuickAccountContract require(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE'); ```  It's possible to create a smart contract mode signature (`SignatureMode.SmartWallet`) for arbitrary transactions as the `QuickAccManager.isValidSignature` uses an attacker-controlled `id` identity contract for the privileges check. An attacker can just create an attacker contract returning the desired values and the smart-wallet signature appears to be valid:  ```solidity // @audit id is attacker-controlled (address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes)); // @audit this may not be used for authorization, attacker can return desired value if (Identity(id).privileges(address(this)) == accHash) {   // bytes4(keccak256("isValidSignature(bytes32,bytes)")   return 0x1626ba7e; } else {   return 0xffffffff; } ```  ## POC  Assume an `Identity` contract is set up with a `QuickAccManager` as the `privileges` account, i.e. `privileges[accHash] != 0`.  We can construct a `SignatureMode.SmartWallet` signature for an _arbitrary_ hash: 1. Call `Identity.execute(txns, spoofedSignature)` where `spoofedSignature = abi.encode(attackerContract, timelock=0, sig1=0, sig2=0, address(quickAccountManager), SignatureMode.SmartWallet)` 2. This will call `recoverAddrImpl(txnsHash, spoofedSignature, true)`, decode the bytes **at the end** of `spoofedSignature` and determine `mode = SignatureMode.SmartWallet` and `wallet = quickAccountManager`. It will cut off these arguments and call `quickAccountManager.isValidSignature(txnsHash, (attackerContract, 0, 0, 0))` 3. The `QuickAccManager` will decode the signature, construct `accHash` which is the hash of all zeroes (due to failed signatures returning 0). It will then call `attacker.privileges(address(this))` and the attacker contract can return the `accHash` that matches an account hash of failed signatures, i.e., `keccak256(abi.encode(QuickAccount(0,0,0)))`. The comparison is satisfied and it returns the success value. 4. The checks in `Identity.execute` pass and the transactions `txns` are executed.  ## Impact Any `Identity` contract using `QuickAccManager` can be exploited. Funds can then be stolen from the wallet.  ## Recommendation The issue is that `QuickAccManager` blindly trusts the values in `signature`. It might be enough to remove the `id` from the `signature` and use `msg.sender` as the identity instead: `Identity(msg.sender).privileges(address(this)) == accHash`. This seems to work with the current `Identity` implementation but might not work if this is extended and the `isValidSignature` is called from another contract and wants to verify a signature on a different identity. In that case, the `Identity/SignatureValidator` may not blindly forward the attacker-supplied signature and instead needs to re-encode the parameters with trusted values before calling `QuickAccManager`.   
# Handle  cmichel   # Vulnerability details  A single `QuickAccount` can serve as the "privilege" for multiple identities, see the comment in `QuickAccManager.sol`:  > NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges[address(this)]. this is by design  If there exist two different identities that _both share the same QuickAccount_ (`identity1.privileges(address(this)) == identity2.privileges(address(this)) == accHash`) the following attack is possible in `QuickAccManager.send`:  Upon observing a valid `send` on the first identity, the same transactions can be replayed on the second identity by an attacker by calling `send` with the same arguments and just changing the `identity` to the second identity.  This is because the `identity` is not part of the `hash`. Including the **nonce of** the identity in the hash is not enough.  Two fresh identities will both take on nonces on zero and lead to the same hash.  ## Impact Transactions on one identity can be replayed on another one if it uses the same `QuickAccount`. For example, a transaction paying a contractor can be replayed by the contract on the second identity earning the payment twice.  ## Recommended Mitigation Steps 1. Nonces should not be indexed by the identity but by the `accHash`. This is because nonces are used to stop replay attacks and thus need to be on the _signer_ (`QuickAccount` in this case), not on the target contract to call. 2. The `identity` _address_ itself needs to be part of `hash` as otherwise the `send` can be frontrun and executed by anyone on the other identity by switching out the `identity` parameter.  ## Other occurrences This issue of using the wrong nonce (on the `identity` which means the nonces repeat per identity) and not including `identity` address leads to other attacks throughout the `QuickAccManager`: - `cancel`: attacker can use the same signature to cancel the same transactions on the second identity - `execScheduled`: can frontrun this call and execute it on the second identity instead. This will make the original transaction fail as `scheduled[hash]` is deleted. - `sendTransfer`: same transfers can be replayed on second identity - `sendTxns`: same transactions can be replayed on second identity   
# Handle  cmichel   # Vulnerability details  The `SignatureValidator.recoverAddrImpl` function does not revert on invalid signatures and returns zero instead. Thus if anyone added the zero address to their `privileges` by accident, funds can be stolen in `Identity.execute`.  ## Recommended Mitigation Steps Unless there's a valid reason for the `SignatureMode.NoSig` mode, consider reverting if `ecrecover` returns the zero address indicating an invalid signature.   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L128-L128  The variables `TRANSFER_TYPEHASH`, `TXNS_TYPEHASH`, `BUNDLE_TYPEHASH` are named in all caps, which implies that they are constants. However, they are not being marked as `constant`. Mark them as `constant` can also help save some gas.  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `scheduled[hashTx]` in `QuickAccManager.sol#cancel()`     https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L92-L92  - `scheduled[hash]` in `QuickAccManager.sol#execScheduled()`     https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L102-L102  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L69-L72  Some storage variables include `admin`, `lendingPool` and `aaveRefCode` are unnecessary as they will never be changed.  Change to `immutable` can save gas.  
# Handle  WatchPug   # Vulnerability details  At L149, `params.recipient` is read and put into a local variable `recipient`. However, `recipient` is only read once when `wrapOutputToLending` is true. Thus, the variable `recipient` is unnecessary.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L147-L159  ```solidity=147 function tradeV3Single(ISwapRouter uniV3Router, ISwapRouter.ExactInputSingleParams calldata params, bool wrapOutputToLending) external returns (uint) {     ISwapRouter.ExactInputSingleParams memory tradeParams = params;     address recipient = params.recipient;     if(wrapOutputToLending) {         tradeParams.recipient = address(this);     }      uint amountOut = uniV3Router.exactInputSingle(tradeParams);     if(wrapOutputToLending) {         lendingPool.deposit(params.tokenOut, amountOut, recipient, aaveRefCode);     }     return amountOut; } ```  ### Recommendation  Change to:  ```solidity=147 function tradeV3Single(ISwapRouter uniV3Router, ISwapRouter.ExactInputSingleParams calldata params, bool wrapOutputToLending) external returns (uint) {     ISwapRouter.ExactInputSingleParams memory tradeParams = params;     if(wrapOutputToLending) {         tradeParams.recipient = address(this);     }      uint amountOut = uniV3Router.exactInputSingle(tradeParams);     if(wrapOutputToLending) {         lendingPool.deposit(params.tokenOut, amountOut, params.recipient, aaveRefCode);     }     return amountOut; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L137-L140  ```solidity function wrapETH() payable external {     // TODO: it may be slightly cheaper to call deposit() directly     payable(WETH).transfer(msg.value); } ```  ### Recommendation  Change to:  ```solidity interface IWETH {     function deposit() external payable; } function wrapETH() payable external {     IWETH(WETH).deposit{ value: msg.value }(); } ```  
# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `Zapper.sol#constructor()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L79-L79  - `Zapper.sol#approveMaxMany()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L87-L87  - `Zapper.sol#exchangeV2()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L104-L104  - `Zapper.sol#wrapLending()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L126-L126  - `Zapper.sol#unwrapLending()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L131  - `QuickAccManager.sol#sendTxns()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L162-L162  
# Handle  WatchPug   # Vulnerability details  In `QuickAccManager.sol#send()`, `nonces[address(identity)]` is being read 2 times (1st at L58, 2nd at L64), the second read is unnecessary, cache it in the stack at the first read can save some gas.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L55-L67  ```solidity=55{58,64} function send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');     uint initialNonce = nonces[address(identity)];     // Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs     bytes32 hash = keccak256(abi.encode(         address(this),         block.chainid,         accHash,         nonces[address(identity)]++,         txns,         sigs.isBothSigned     )); ```  ### Recommendation  Change to:  ```solidity=55{58,64} function send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');     uint initialNonce = nonces[address(identity)]++;     // Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs     bytes32 hash = keccak256(abi.encode(         address(this),         block.chainid,         accHash,         initialNonce,         txns,         sigs.isBothSigned     )); ```  
# Handle  ye0lde   # Vulnerability details  ## Impact  A variable is being assigned its default value which is unnecessary. Removing the assignment will save gas when deploying.  ## Proof of Concept  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L9  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the assignment.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deploy time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L33 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L55 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L59 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L64 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L65  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function setAddrPrivilege of Identity.sol the value of privileges[addr] is compare to 0 and 1 in the following way: "if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1)))"  As 0 and 1 are adjacent, you could also check "uint(privileges[addr]) > 1". This saves a (small amount) of gas.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L59  ## Tools Used  ## Recommended Mitigation Steps replace if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1))) ... with if (uint(privileges[addr]) > 1) ...  
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose one of the supplied addrs[i] to the constructor of Identity.sol happens to be 0 ( by accident).  In that case: privileges[0] = 1  Now suppose you call execute() with an invalid signature, then recoverAddrImpl will return a value of 0 and thus signer=0. If you then check "privileges[signer] !=0"  this will be true and anyone can perform any transaction.  This is clearly an unwanted situation.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L23-L30  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L97-L98  ## Tools Used  ## Recommended Mitigation Steps In the constructor of Identity.sol, add in the for loop the following: require (addrs[i] !=0,"Zero not allowed");  
# Handle  loop   # Vulnerability details  The `withdraw` function in `IdentityFactory.sol` is declared as public but can be external since it is not used internally.  ## Impact Saves some gas in case it ever needs to be called.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/IdentityFactory.sol#L52  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `CANCEL_PREFIX` in the `QuickAccManager` is never reset after initialization. Declaring it as a constant saves gas.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `creator` in the `IdentityFactory` is never reset after initialization in the constructor. Declaring it as immutable saves gas.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `DOMAIN_SEPARATOR` in the `QuickAccManager` is never reset after initialization in the constructor. Declaring it as immutable saves gas.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact If a caller has privileges for a QuickAccount consisting of two `address(0)`'s, then the caller can execute arbitrary transactions through the  `QuicAccManager::send()` function.  ## Proof of Concept A caller of the `QuickAccManager::send()` needs to be privileged for the  QuickAccount the caller provides as argument ([line 57](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L57)).  As an arbitrary value can be set as `privileged[caller]` in `Indentity.sol`, so can a QuickAccount struct consisting of two `address(0)`'s.  The following calls to `SignatureValidator::recoverAddr()` (line 69, 70 and 73) can be made to always return `address(0)` if the signature has  `SignatureMode.NoSig`.  As the signature is provided as argument in `QuickAccManager::send()`, the  caller has total control of it.  The checks in line [69, 70](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L69) and [73](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L73) now always pass as long as the accounts in the QuickAccount struct are  `address(0)` too.  Therefore, a caller with permissions for such a QuickAccount can execute and  schedule arbitrary transactions without the need for valid signatures.  ## Tools Used -  ## Recommended Mitigation Steps Add a check in the `QuickAccManager::send()` function to forbid  QuickAccounts with `address(0)`.  
# Handle  WatchPug   # Vulnerability details  In `QuickAccManager.sol#cancel()`, the `hashTx` to identify the transaction to be canceled is wrong. The last parameter is missing.  As a result, users will be unable to cancel a scheduled transaction.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L91-L91  ```solidity=81{91} function cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');      bytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));     address signer = SignatureValidator.recoverAddr(hash, sig);     require(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');      // @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief     // opportunity: someone wants to cancel post-maturity, and you front them with execScheduled     bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));     require(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');     delete scheduled[hashTx];      emit LogCancelled(hashTx, accHash, signer, block.timestamp); } ```  ### Recommendation  Change to:  ```solidity bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false)); ```  
# Handle  pauliax   # Vulnerability details  ## Impact I don't think it's necessary for the library to use itself here:   library LibBytes {     using LibBytes for bytes;  ## Recommended Mitigation Steps Remove this 'using' statement as it does not give anything in this case.  
# Handle  pauliax   # Vulnerability details  ## Impact First perform the addition and only then check the length to avoid this duplicate math operation:     require(b.length >= index + 32, "BytesLib: length");     // Arrays are prefixed by a 256 bit length parameter     index += 32; Or if you want to stay with this approach, then at least consider using the 'unchecked' keyword when this addition is performed the second time as then ready know this can't overflow. Also, in function recoverAddrImpl the same operation is performed twice:   sig.length - 33  ## Recommended Mitigation Steps Refactor duplicate math operations.  
# Handle  pauliax   # Vulnerability details  ## Impact There is a common issue that ecrecover returns empty (0x0) address when the signature is invalid. function recoverAddrImpl should check that before returning the result of ecrecover.  ## Recommended Mitigation Steps See the solution here: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/cryptography/ECDSA.sol#L68  
# Handle  pauliax   # Vulnerability details  ## Impact The 'DOMAIN_SEPARATOR' is not recalculated in the case of a hard fork. The variable DOMAIN_SEPARATOR in contract QuickAccManager is cached in the contract storage and will not change after being initialized. However, if a hard fork happens after the contract deployment, the domain would become invalid on one of the forked chains due to the block.chainid has changed.  A similar issue was reported in a previous contest and was assigned a severity of low: https://github.com/code-423n4/2021-06-realitycards-findings/issues/166  ## Recommended Mitigation Steps An elegant solution that you may consider applying is from Sushi Trident: https://github.com/sushiswap/trident/blob/concentrated/contracts/pool/concentrated/TridentNFT.sol#L47-L62  
# Handle  pauliax   # Vulnerability details  ## Impact WETH address is hardcoded but it may differ on other chains, e.g. Polygon, so make sure to check this before deploying and update if neccessary:   address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;  ## Recommended Mitigation Steps You should consider injecting WETH address via the constructor.  
# Handle  JMukesh   # Vulnerability details  ## Impact require message give the idea what was the cause of failure , so its the best practise to  add message in require()  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L218  ## Tools Used manual reveiw  ## Recommended Mitigation Steps add message in require()  
# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept most of contract used floating pragma  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed solidity version  
# Handle  WatchPug   # Vulnerability details  Most of the for loops in the codebase use `<` to control the loop:  ```solidity for (uint i=0; i<len; i++) { ```  However, in `Zapper.sol`, all 7 for loops are using `!=`:  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L79-L79  ```solidity for (uint i=0; i!=spenders.length; i++) { ```  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L87-L87   https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L110-L110  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L126-L126  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L131-L131  Using `for (uint i=0; i!=len; i++) {}` to control for loops introduces inconsistent code style.  ### Recommendation  Change from `!=` to `<` for all for loops.  
# Handle  cmichel   # Vulnerability details  The `SignatureValidatorV2.recoverAddrImpl` function currently uses three `if (mode == *)` checks but the modes are all distinct enum values and therefore an `else if` can be used. This is more efficient because if the first branch is already matched, there's no need to check the `mode` against the remaining values anymore.  
# Handle  cmichel   # Vulnerability details  The `index += 32` addition in `readBytes32` can be put in an `unsafe` block as the array length is already checked to be greater than the addition.  
# Handle  cmichel   # Vulnerability details  Several different signature modes can be used and `Identity.execute` forwards the `signature` parameter to the `SignatureValidator` library. The returned `signer` is then used for the `privileges` check:  ```solidity address signer = SignatureValidator.recoverAddrImpl(hash, signature, true); // signer will be QuickAccountContract require(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE'); ```  It's possible to create a smart contract mode signature (`SignatureMode.SmartWallet`) for arbitrary transactions as the `QuickAccManager.isValidSignature` uses an attacker-controlled `id` identity contract for the privileges check. An attacker can just create an attacker contract returning the desired values and the smart-wallet signature appears to be valid:  ```solidity // @audit id is attacker-controlled (address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes)); // @audit this may not be used for authorization, attacker can return desired value if (Identity(id).privileges(address(this)) == accHash) {   // bytes4(keccak256("isValidSignature(bytes32,bytes)")   return 0x1626ba7e; } else {   return 0xffffffff; } ```  ## POC  Assume an `Identity` contract is set up with a `QuickAccManager` as the `privileges` account, i.e. `privileges[accHash] != 0`.  We can construct a `SignatureMode.SmartWallet` signature for an _arbitrary_ hash: 1. Call `Identity.execute(txns, spoofedSignature)` where `spoofedSignature = abi.encode(attackerContract, timelock=0, sig1=0, sig2=0, address(quickAccountManager), SignatureMode.SmartWallet)` 2. This will call `recoverAddrImpl(txnsHash, spoofedSignature, true)`, decode the bytes **at the end** of `spoofedSignature` and determine `mode = SignatureMode.SmartWallet` and `wallet = quickAccountManager`. It will cut off these arguments and call `quickAccountManager.isValidSignature(txnsHash, (attackerContract, 0, 0, 0))` 3. The `QuickAccManager` will decode the signature, construct `accHash` which is the hash of all zeroes (due to failed signatures returning 0). It will then call `attacker.privileges(address(this))` and the attacker contract can return the `accHash` that matches an account hash of failed signatures, i.e., `keccak256(abi.encode(QuickAccount(0,0,0)))`. The comparison is satisfied and it returns the success value. 4. The checks in `Identity.execute` pass and the transactions `txns` are executed.  ## Impact Any `Identity` contract using `QuickAccManager` can be exploited. Funds can then be stolen from the wallet.  ## Recommendation The issue is that `QuickAccManager` blindly trusts the values in `signature`. It might be enough to remove the `id` from the `signature` and use `msg.sender` as the identity instead: `Identity(msg.sender).privileges(address(this)) == accHash`. This seems to work with the current `Identity` implementation but might not work if this is extended and the `isValidSignature` is called from another contract and wants to verify a signature on a different identity. In that case, the `Identity/SignatureValidator` may not blindly forward the attacker-supplied signature and instead needs to re-encode the parameters with trusted values before calling `QuickAccManager`.   
# Handle  cmichel   # Vulnerability details  A single `QuickAccount` can serve as the "privilege" for multiple identities, see the comment in `QuickAccManager.sol`:  > NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges[address(this)]. this is by design  If there exist two different identities that _both share the same QuickAccount_ (`identity1.privileges(address(this)) == identity2.privileges(address(this)) == accHash`) the following attack is possible in `QuickAccManager.send`:  Upon observing a valid `send` on the first identity, the same transactions can be replayed on the second identity by an attacker by calling `send` with the same arguments and just changing the `identity` to the second identity.  This is because the `identity` is not part of the `hash`. Including the **nonce of** the identity in the hash is not enough.  Two fresh identities will both take on nonces on zero and lead to the same hash.  ## Impact Transactions on one identity can be replayed on another one if it uses the same `QuickAccount`. For example, a transaction paying a contractor can be replayed by the contract on the second identity earning the payment twice.  ## Recommended Mitigation Steps 1. Nonces should not be indexed by the identity but by the `accHash`. This is because nonces are used to stop replay attacks and thus need to be on the _signer_ (`QuickAccount` in this case), not on the target contract to call. 2. The `identity` _address_ itself needs to be part of `hash` as otherwise the `send` can be frontrun and executed by anyone on the other identity by switching out the `identity` parameter.  ## Other occurrences This issue of using the wrong nonce (on the `identity` which means the nonces repeat per identity) and not including `identity` address leads to other attacks throughout the `QuickAccManager`: - `cancel`: attacker can use the same signature to cancel the same transactions on the second identity - `execScheduled`: can frontrun this call and execute it on the second identity instead. This will make the original transaction fail as `scheduled[hash]` is deleted. - `sendTransfer`: same transfers can be replayed on second identity - `sendTxns`: same transactions can be replayed on second identity   
# Handle  cmichel   # Vulnerability details  The `SignatureValidator.recoverAddrImpl` function does not revert on invalid signatures and returns zero instead. Thus if anyone added the zero address to their `privileges` by accident, funds can be stolen in `Identity.execute`.  ## Recommended Mitigation Steps Unless there's a valid reason for the `SignatureMode.NoSig` mode, consider reverting if `ecrecover` returns the zero address indicating an invalid signature.   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L128-L128  The variables `TRANSFER_TYPEHASH`, `TXNS_TYPEHASH`, `BUNDLE_TYPEHASH` are named in all caps, which implies that they are constants. However, they are not being marked as `constant`. Mark them as `constant` can also help save some gas.  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `scheduled[hashTx]` in `QuickAccManager.sol#cancel()`     https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L92-L92  - `scheduled[hash]` in `QuickAccManager.sol#execScheduled()`     https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L102-L102  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L69-L72  Some storage variables include `admin`, `lendingPool` and `aaveRefCode` are unnecessary as they will never be changed.  Change to `immutable` can save gas.  
# Handle  WatchPug   # Vulnerability details  At L149, `params.recipient` is read and put into a local variable `recipient`. However, `recipient` is only read once when `wrapOutputToLending` is true. Thus, the variable `recipient` is unnecessary.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L147-L159  ```solidity=147 function tradeV3Single(ISwapRouter uniV3Router, ISwapRouter.ExactInputSingleParams calldata params, bool wrapOutputToLending) external returns (uint) {     ISwapRouter.ExactInputSingleParams memory tradeParams = params;     address recipient = params.recipient;     if(wrapOutputToLending) {         tradeParams.recipient = address(this);     }      uint amountOut = uniV3Router.exactInputSingle(tradeParams);     if(wrapOutputToLending) {         lendingPool.deposit(params.tokenOut, amountOut, recipient, aaveRefCode);     }     return amountOut; } ```  ### Recommendation  Change to:  ```solidity=147 function tradeV3Single(ISwapRouter uniV3Router, ISwapRouter.ExactInputSingleParams calldata params, bool wrapOutputToLending) external returns (uint) {     ISwapRouter.ExactInputSingleParams memory tradeParams = params;     if(wrapOutputToLending) {         tradeParams.recipient = address(this);     }      uint amountOut = uniV3Router.exactInputSingle(tradeParams);     if(wrapOutputToLending) {         lendingPool.deposit(params.tokenOut, amountOut, params.recipient, aaveRefCode);     }     return amountOut; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L137-L140  ```solidity function wrapETH() payable external {     // TODO: it may be slightly cheaper to call deposit() directly     payable(WETH).transfer(msg.value); } ```  ### Recommendation  Change to:  ```solidity interface IWETH {     function deposit() external payable; } function wrapETH() payable external {     IWETH(WETH).deposit{ value: msg.value }(); } ```  
# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `Zapper.sol#constructor()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L79-L79  - `Zapper.sol#approveMaxMany()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L87-L87  - `Zapper.sol#exchangeV2()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L104-L104  - `Zapper.sol#wrapLending()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L126-L126  - `Zapper.sol#unwrapLending()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L131  - `QuickAccManager.sol#sendTxns()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L162-L162  
# Handle  WatchPug   # Vulnerability details  In `QuickAccManager.sol#send()`, `nonces[address(identity)]` is being read 2 times (1st at L58, 2nd at L64), the second read is unnecessary, cache it in the stack at the first read can save some gas.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L55-L67  ```solidity=55{58,64} function send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');     uint initialNonce = nonces[address(identity)];     // Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs     bytes32 hash = keccak256(abi.encode(         address(this),         block.chainid,         accHash,         nonces[address(identity)]++,         txns,         sigs.isBothSigned     )); ```  ### Recommendation  Change to:  ```solidity=55{58,64} function send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');     uint initialNonce = nonces[address(identity)]++;     // Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs     bytes32 hash = keccak256(abi.encode(         address(this),         block.chainid,         accHash,         initialNonce,         txns,         sigs.isBothSigned     )); ```  
# Handle  ye0lde   # Vulnerability details  ## Impact  A variable is being assigned its default value which is unnecessary. Removing the assignment will save gas when deploying.  ## Proof of Concept  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L9  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the assignment.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deploy time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L33 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L55 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L59 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L64 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L65  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function setAddrPrivilege of Identity.sol the value of privileges[addr] is compare to 0 and 1 in the following way: "if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1)))"  As 0 and 1 are adjacent, you could also check "uint(privileges[addr]) > 1". This saves a (small amount) of gas.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L59  ## Tools Used  ## Recommended Mitigation Steps replace if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1))) ... with if (uint(privileges[addr]) > 1) ...  
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose one of the supplied addrs[i] to the constructor of Identity.sol happens to be 0 ( by accident).  In that case: privileges[0] = 1  Now suppose you call execute() with an invalid signature, then recoverAddrImpl will return a value of 0 and thus signer=0. If you then check "privileges[signer] !=0"  this will be true and anyone can perform any transaction.  This is clearly an unwanted situation.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L23-L30  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L97-L98  ## Tools Used  ## Recommended Mitigation Steps In the constructor of Identity.sol, add in the for loop the following: require (addrs[i] !=0,"Zero not allowed");  
# Handle  loop   # Vulnerability details  The `withdraw` function in `IdentityFactory.sol` is declared as public but can be external since it is not used internally.  ## Impact Saves some gas in case it ever needs to be called.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/IdentityFactory.sol#L52  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `CANCEL_PREFIX` in the `QuickAccManager` is never reset after initialization. Declaring it as a constant saves gas.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `creator` in the `IdentityFactory` is never reset after initialization in the constructor. Declaring it as immutable saves gas.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `DOMAIN_SEPARATOR` in the `QuickAccManager` is never reset after initialization in the constructor. Declaring it as immutable saves gas.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact If a caller has privileges for a QuickAccount consisting of two `address(0)`'s, then the caller can execute arbitrary transactions through the  `QuicAccManager::send()` function.  ## Proof of Concept A caller of the `QuickAccManager::send()` needs to be privileged for the  QuickAccount the caller provides as argument ([line 57](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L57)).  As an arbitrary value can be set as `privileged[caller]` in `Indentity.sol`, so can a QuickAccount struct consisting of two `address(0)`'s.  The following calls to `SignatureValidator::recoverAddr()` (line 69, 70 and 73) can be made to always return `address(0)` if the signature has  `SignatureMode.NoSig`.  As the signature is provided as argument in `QuickAccManager::send()`, the  caller has total control of it.  The checks in line [69, 70](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L69) and [73](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L73) now always pass as long as the accounts in the QuickAccount struct are  `address(0)` too.  Therefore, a caller with permissions for such a QuickAccount can execute and  schedule arbitrary transactions without the need for valid signatures.  ## Tools Used -  ## Recommended Mitigation Steps Add a check in the `QuickAccManager::send()` function to forbid  QuickAccounts with `address(0)`.  
# Handle  WatchPug   # Vulnerability details  In `QuickAccManager.sol#cancel()`, the `hashTx` to identify the transaction to be canceled is wrong. The last parameter is missing.  As a result, users will be unable to cancel a scheduled transaction.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L91-L91  ```solidity=81{91} function cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');      bytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));     address signer = SignatureValidator.recoverAddr(hash, sig);     require(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');      // @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief     // opportunity: someone wants to cancel post-maturity, and you front them with execScheduled     bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));     require(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');     delete scheduled[hashTx];      emit LogCancelled(hashTx, accHash, signer, block.timestamp); } ```  ### Recommendation  Change to:  ```solidity bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false)); ```  
# Handle  pauliax   # Vulnerability details  ## Impact I don't think it's necessary for the library to use itself here:   library LibBytes {     using LibBytes for bytes;  ## Recommended Mitigation Steps Remove this 'using' statement as it does not give anything in this case.  
# Handle  pauliax   # Vulnerability details  ## Impact First perform the addition and only then check the length to avoid this duplicate math operation:     require(b.length >= index + 32, "BytesLib: length");     // Arrays are prefixed by a 256 bit length parameter     index += 32; Or if you want to stay with this approach, then at least consider using the 'unchecked' keyword when this addition is performed the second time as then ready know this can't overflow. Also, in function recoverAddrImpl the same operation is performed twice:   sig.length - 33  ## Recommended Mitigation Steps Refactor duplicate math operations.  
# Handle  pauliax   # Vulnerability details  ## Impact There is a common issue that ecrecover returns empty (0x0) address when the signature is invalid. function recoverAddrImpl should check that before returning the result of ecrecover.  ## Recommended Mitigation Steps See the solution here: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/cryptography/ECDSA.sol#L68  
# Handle  pauliax   # Vulnerability details  ## Impact The 'DOMAIN_SEPARATOR' is not recalculated in the case of a hard fork. The variable DOMAIN_SEPARATOR in contract QuickAccManager is cached in the contract storage and will not change after being initialized. However, if a hard fork happens after the contract deployment, the domain would become invalid on one of the forked chains due to the block.chainid has changed.  A similar issue was reported in a previous contest and was assigned a severity of low: https://github.com/code-423n4/2021-06-realitycards-findings/issues/166  ## Recommended Mitigation Steps An elegant solution that you may consider applying is from Sushi Trident: https://github.com/sushiswap/trident/blob/concentrated/contracts/pool/concentrated/TridentNFT.sol#L47-L62  
# Handle  pauliax   # Vulnerability details  ## Impact WETH address is hardcoded but it may differ on other chains, e.g. Polygon, so make sure to check this before deploying and update if neccessary:   address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;  ## Recommended Mitigation Steps You should consider injecting WETH address via the constructor.  
# Handle  JMukesh   # Vulnerability details  ## Impact require message give the idea what was the cause of failure , so its the best practise to  add message in require()  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L218  ## Tools Used manual reveiw  ## Recommended Mitigation Steps add message in require()  
# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept most of contract used floating pragma  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed solidity version  
# Handle  WatchPug   # Vulnerability details  Most of the for loops in the codebase use `<` to control the loop:  ```solidity for (uint i=0; i<len; i++) { ```  However, in `Zapper.sol`, all 7 for loops are using `!=`:  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L79-L79  ```solidity for (uint i=0; i!=spenders.length; i++) { ```  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L87-L87   https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L110-L110  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L126-L126  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L131-L131  Using `for (uint i=0; i!=len; i++) {}` to control for loops introduces inconsistent code style.  ### Recommendation  Change from `!=` to `<` for all for loops.  
# Handle  cmichel   # Vulnerability details  The `SignatureValidatorV2.recoverAddrImpl` function currently uses three `if (mode == *)` checks but the modes are all distinct enum values and therefore an `else if` can be used. This is more efficient because if the first branch is already matched, there's no need to check the `mode` against the remaining values anymore.  
# Handle  cmichel   # Vulnerability details  The `index += 32` addition in `readBytes32` can be put in an `unsafe` block as the array length is already checked to be greater than the addition.  
# Handle  cmichel   # Vulnerability details  Several different signature modes can be used and `Identity.execute` forwards the `signature` parameter to the `SignatureValidator` library. The returned `signer` is then used for the `privileges` check:  ```solidity address signer = SignatureValidator.recoverAddrImpl(hash, signature, true); // signer will be QuickAccountContract require(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE'); ```  It's possible to create a smart contract mode signature (`SignatureMode.SmartWallet`) for arbitrary transactions as the `QuickAccManager.isValidSignature` uses an attacker-controlled `id` identity contract for the privileges check. An attacker can just create an attacker contract returning the desired values and the smart-wallet signature appears to be valid:  ```solidity // @audit id is attacker-controlled (address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes)); // @audit this may not be used for authorization, attacker can return desired value if (Identity(id).privileges(address(this)) == accHash) {   // bytes4(keccak256("isValidSignature(bytes32,bytes)")   return 0x1626ba7e; } else {   return 0xffffffff; } ```  ## POC  Assume an `Identity` contract is set up with a `QuickAccManager` as the `privileges` account, i.e. `privileges[accHash] != 0`.  We can construct a `SignatureMode.SmartWallet` signature for an _arbitrary_ hash: 1. Call `Identity.execute(txns, spoofedSignature)` where `spoofedSignature = abi.encode(attackerContract, timelock=0, sig1=0, sig2=0, address(quickAccountManager), SignatureMode.SmartWallet)` 2. This will call `recoverAddrImpl(txnsHash, spoofedSignature, true)`, decode the bytes **at the end** of `spoofedSignature` and determine `mode = SignatureMode.SmartWallet` and `wallet = quickAccountManager`. It will cut off these arguments and call `quickAccountManager.isValidSignature(txnsHash, (attackerContract, 0, 0, 0))` 3. The `QuickAccManager` will decode the signature, construct `accHash` which is the hash of all zeroes (due to failed signatures returning 0). It will then call `attacker.privileges(address(this))` and the attacker contract can return the `accHash` that matches an account hash of failed signatures, i.e., `keccak256(abi.encode(QuickAccount(0,0,0)))`. The comparison is satisfied and it returns the success value. 4. The checks in `Identity.execute` pass and the transactions `txns` are executed.  ## Impact Any `Identity` contract using `QuickAccManager` can be exploited. Funds can then be stolen from the wallet.  ## Recommendation The issue is that `QuickAccManager` blindly trusts the values in `signature`. It might be enough to remove the `id` from the `signature` and use `msg.sender` as the identity instead: `Identity(msg.sender).privileges(address(this)) == accHash`. This seems to work with the current `Identity` implementation but might not work if this is extended and the `isValidSignature` is called from another contract and wants to verify a signature on a different identity. In that case, the `Identity/SignatureValidator` may not blindly forward the attacker-supplied signature and instead needs to re-encode the parameters with trusted values before calling `QuickAccManager`.   
# Handle  cmichel   # Vulnerability details  A single `QuickAccount` can serve as the "privilege" for multiple identities, see the comment in `QuickAccManager.sol`:  > NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges[address(this)]. this is by design  If there exist two different identities that _both share the same QuickAccount_ (`identity1.privileges(address(this)) == identity2.privileges(address(this)) == accHash`) the following attack is possible in `QuickAccManager.send`:  Upon observing a valid `send` on the first identity, the same transactions can be replayed on the second identity by an attacker by calling `send` with the same arguments and just changing the `identity` to the second identity.  This is because the `identity` is not part of the `hash`. Including the **nonce of** the identity in the hash is not enough.  Two fresh identities will both take on nonces on zero and lead to the same hash.  ## Impact Transactions on one identity can be replayed on another one if it uses the same `QuickAccount`. For example, a transaction paying a contractor can be replayed by the contract on the second identity earning the payment twice.  ## Recommended Mitigation Steps 1. Nonces should not be indexed by the identity but by the `accHash`. This is because nonces are used to stop replay attacks and thus need to be on the _signer_ (`QuickAccount` in this case), not on the target contract to call. 2. The `identity` _address_ itself needs to be part of `hash` as otherwise the `send` can be frontrun and executed by anyone on the other identity by switching out the `identity` parameter.  ## Other occurrences This issue of using the wrong nonce (on the `identity` which means the nonces repeat per identity) and not including `identity` address leads to other attacks throughout the `QuickAccManager`: - `cancel`: attacker can use the same signature to cancel the same transactions on the second identity - `execScheduled`: can frontrun this call and execute it on the second identity instead. This will make the original transaction fail as `scheduled[hash]` is deleted. - `sendTransfer`: same transfers can be replayed on second identity - `sendTxns`: same transactions can be replayed on second identity   
# Handle  cmichel   # Vulnerability details  The `SignatureValidator.recoverAddrImpl` function does not revert on invalid signatures and returns zero instead. Thus if anyone added the zero address to their `privileges` by accident, funds can be stolen in `Identity.execute`.  ## Recommended Mitigation Steps Unless there's a valid reason for the `SignatureMode.NoSig` mode, consider reverting if `ecrecover` returns the zero address indicating an invalid signature.   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L128-L128  The variables `TRANSFER_TYPEHASH`, `TXNS_TYPEHASH`, `BUNDLE_TYPEHASH` are named in all caps, which implies that they are constants. However, they are not being marked as `constant`. Mark them as `constant` can also help save some gas.  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `scheduled[hashTx]` in `QuickAccManager.sol#cancel()`     https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L92-L92  - `scheduled[hash]` in `QuickAccManager.sol#execScheduled()`     https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L102-L102  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L69-L72  Some storage variables include `admin`, `lendingPool` and `aaveRefCode` are unnecessary as they will never be changed.  Change to `immutable` can save gas.  
# Handle  WatchPug   # Vulnerability details  At L149, `params.recipient` is read and put into a local variable `recipient`. However, `recipient` is only read once when `wrapOutputToLending` is true. Thus, the variable `recipient` is unnecessary.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L147-L159  ```solidity=147 function tradeV3Single(ISwapRouter uniV3Router, ISwapRouter.ExactInputSingleParams calldata params, bool wrapOutputToLending) external returns (uint) {     ISwapRouter.ExactInputSingleParams memory tradeParams = params;     address recipient = params.recipient;     if(wrapOutputToLending) {         tradeParams.recipient = address(this);     }      uint amountOut = uniV3Router.exactInputSingle(tradeParams);     if(wrapOutputToLending) {         lendingPool.deposit(params.tokenOut, amountOut, recipient, aaveRefCode);     }     return amountOut; } ```  ### Recommendation  Change to:  ```solidity=147 function tradeV3Single(ISwapRouter uniV3Router, ISwapRouter.ExactInputSingleParams calldata params, bool wrapOutputToLending) external returns (uint) {     ISwapRouter.ExactInputSingleParams memory tradeParams = params;     if(wrapOutputToLending) {         tradeParams.recipient = address(this);     }      uint amountOut = uniV3Router.exactInputSingle(tradeParams);     if(wrapOutputToLending) {         lendingPool.deposit(params.tokenOut, amountOut, params.recipient, aaveRefCode);     }     return amountOut; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L137-L140  ```solidity function wrapETH() payable external {     // TODO: it may be slightly cheaper to call deposit() directly     payable(WETH).transfer(msg.value); } ```  ### Recommendation  Change to:  ```solidity interface IWETH {     function deposit() external payable; } function wrapETH() payable external {     IWETH(WETH).deposit{ value: msg.value }(); } ```  
# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `Zapper.sol#constructor()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L79-L79  - `Zapper.sol#approveMaxMany()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L87-L87  - `Zapper.sol#exchangeV2()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L104-L104  - `Zapper.sol#wrapLending()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L126-L126  - `Zapper.sol#unwrapLending()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L131  - `QuickAccManager.sol#sendTxns()` https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L162-L162  
# Handle  WatchPug   # Vulnerability details  In `QuickAccManager.sol#send()`, `nonces[address(identity)]` is being read 2 times (1st at L58, 2nd at L64), the second read is unnecessary, cache it in the stack at the first read can save some gas.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L55-L67  ```solidity=55{58,64} function send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');     uint initialNonce = nonces[address(identity)];     // Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs     bytes32 hash = keccak256(abi.encode(         address(this),         block.chainid,         accHash,         nonces[address(identity)]++,         txns,         sigs.isBothSigned     )); ```  ### Recommendation  Change to:  ```solidity=55{58,64} function send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');     uint initialNonce = nonces[address(identity)]++;     // Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs     bytes32 hash = keccak256(abi.encode(         address(this),         block.chainid,         accHash,         initialNonce,         txns,         sigs.isBothSigned     )); ```  
# Handle  ye0lde   # Vulnerability details  ## Impact  A variable is being assigned its default value which is unnecessary. Removing the assignment will save gas when deploying.  ## Proof of Concept  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L9  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the assignment.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deploy time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L33 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L55 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L59 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L64 https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/libs/SignatureValidatorV2.sol#L65  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function setAddrPrivilege of Identity.sol the value of privileges[addr] is compare to 0 and 1 in the following way: "if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1)))"  As 0 and 1 are adjacent, you could also check "uint(privileges[addr]) > 1". This saves a (small amount) of gas.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L59  ## Tools Used  ## Recommended Mitigation Steps replace if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1))) ... with if (uint(privileges[addr]) > 1) ...  
# Handle  gpersoon   # Vulnerability details  ## Impact Suppose one of the supplied addrs[i] to the constructor of Identity.sol happens to be 0 ( by accident).  In that case: privileges[0] = 1  Now suppose you call execute() with an invalid signature, then recoverAddrImpl will return a value of 0 and thus signer=0. If you then check "privileges[signer] !=0"  this will be true and anyone can perform any transaction.  This is clearly an unwanted situation.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L23-L30  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L97-L98  ## Tools Used  ## Recommended Mitigation Steps In the constructor of Identity.sol, add in the for loop the following: require (addrs[i] !=0,"Zero not allowed");  
# Handle  loop   # Vulnerability details  The `withdraw` function in `IdentityFactory.sol` is declared as public but can be external since it is not used internally.  ## Impact Saves some gas in case it ever needs to be called.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/IdentityFactory.sol#L52  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `CANCEL_PREFIX` in the `QuickAccManager` is never reset after initialization. Declaring it as a constant saves gas.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `creator` in the `IdentityFactory` is never reset after initialization in the constructor. Declaring it as immutable saves gas.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `DOMAIN_SEPARATOR` in the `QuickAccManager` is never reset after initialization in the constructor. Declaring it as immutable saves gas.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact If a caller has privileges for a QuickAccount consisting of two `address(0)`'s, then the caller can execute arbitrary transactions through the  `QuicAccManager::send()` function.  ## Proof of Concept A caller of the `QuickAccManager::send()` needs to be privileged for the  QuickAccount the caller provides as argument ([line 57](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L57)).  As an arbitrary value can be set as `privileged[caller]` in `Indentity.sol`, so can a QuickAccount struct consisting of two `address(0)`'s.  The following calls to `SignatureValidator::recoverAddr()` (line 69, 70 and 73) can be made to always return `address(0)` if the signature has  `SignatureMode.NoSig`.  As the signature is provided as argument in `QuickAccManager::send()`, the  caller has total control of it.  The checks in line [69, 70](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L69) and [73](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L73) now always pass as long as the accounts in the QuickAccount struct are  `address(0)` too.  Therefore, a caller with permissions for such a QuickAccount can execute and  schedule arbitrary transactions without the need for valid signatures.  ## Tools Used -  ## Recommended Mitigation Steps Add a check in the `QuickAccManager::send()` function to forbid  QuickAccounts with `address(0)`.  
# Handle  WatchPug   # Vulnerability details  In `QuickAccManager.sol#cancel()`, the `hashTx` to identify the transaction to be canceled is wrong. The last parameter is missing.  As a result, users will be unable to cancel a scheduled transaction.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L91-L91  ```solidity=81{91} function cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');      bytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));     address signer = SignatureValidator.recoverAddr(hash, sig);     require(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');      // @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief     // opportunity: someone wants to cancel post-maturity, and you front them with execScheduled     bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));     require(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');     delete scheduled[hashTx];      emit LogCancelled(hashTx, accHash, signer, block.timestamp); } ```  ### Recommendation  Change to:  ```solidity bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false)); ```  
