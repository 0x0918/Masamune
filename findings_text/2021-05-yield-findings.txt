# Handle  shw   # Vulnerability details  ## Impact  According to the protocol design, users have to pay borrowing interest when repaying the debt with underlying tokens after maturity. However, a user can give his vault to `Witch` and then buy all his collateral using underlying tokens to avoid paying the interest. Besides, this bug could make users less incentivized to repay the debt before maturity and hold the underlying tokens until liquidation.  ## Proof of Concept  1. A user creates a new vault and opens a borrowing position as usual. 2. The maturity date passed. If the user wants to close the position using underlying tokens, he has to pay a borrowing interest (line 350 in `Ladle`), which is his debt multiplied by the rate accrual (line 373). 3. Now, the user wants to avoid paying the borrowing interest. He gives his vault to `Witch` by calling the function `batch` of `Ladle` with the operation `GIVE`. 4. He then calls the function `buy` of `Witch` with the corresponding `vaultId` to buy all his collateral using underlying tokens.  In the last step, the `elapsed` time (line 61) is equal to the current timestamp since the vault is never grabbed by `Witch` before, and thus the auction time of the vault, `cauldron.auctions(vaultId)`, is 0 (the default mapping value). Therefore, the collateral is sold at a price of `balances_.art/balances_.ink` (line 74). The user can buy `balances_.ink` amount of collateral using `balances_.art` but not paying for borrowing fees.  Referenced code: [Ladle.sol#L350](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L350) [Ladle.sol#L368-L377](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L368-L377) [Ladle.sol#L267-L272](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L267-L272) [Cauldron.sol#L234-L252](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L234-L252) [Witch.sol#L61](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L61) [Witch.sol#L74](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L74)  ## Recommended Mitigation Steps  Do not allow users to `give` vaults to `Witch`. To be more careful, require `vaultOwners[vaultId]` and `cauldron.auctions(vaultId)` to be non-zero at the beginning of function `buy`.  
# Handle  shw   # Vulnerability details  ## Impact  It is possible for an attacker to intendedly create a fake `Join` corresponding to a specific token beforehand to make `Wand` unable to deploy the actual `Join`, causing a DoS attack.  ## Proof of Concept  The address of `Join` corresponding to an underlying `asset` is determined as follows and thus unique:  ```solidity Join join = new Join{salt: keccak256(abi.encodePacked(asset))}(); ```  Besides, the function `createJoin` in the contract `JoinFactory` is permissionless: Anyone can create the `Join` corresponding to the `asset`. An attacker could then deploy a large number of `Joins` with different common underlying assets (e.g., DAI, USDC, ETH) before the `Wand` deploying them. The attempt of deploying these `Joins` by `Wand` would fail since the attacker had occupied the desired addresses with fake `Joins`, resulting in a DoS attack.  Moreover, the attacker can also perform DoS attacks on newly added assets: He monitors the mempool to find transactions calling the function `addAsset` of `Wand` and front-runs them to create the corresponding `Join` to make the benign transaction fail.  Referenced code: [JoinFactory.sol#L64-L75](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/JoinFactory.sol#L64-L75) [Wand.sol#L53](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Wand.sol#L53)  ## Recommended Mitigation Steps  Enable access control in `createJoin` (e.g., adding the `auth` modifier) and allow `Wand` to call it.  
# Handle  shw   # Vulnerability details  ## Impact  At line 172 in the contract `FYToken`, the `unchecked` keyword is unnecessary since no arithmetic operation is involved.  ## Proof of Concept  Referenced code: [FYToken.sol#L172](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L172)  ## Recommended Mitigation Steps  Consider removing the `unchecked` keyword.  
# Handle  a_delamo   # Vulnerability details  ## Impact  In the Pool.sol contract there is the following code:  ``` function _update(         uint128 baseBalance,         uint128 fyBalance,         uint112 _baseCached,         uint112 _fyTokenCached     ) private {         ....              cumulativeBalancesRatio +=                 (scaledFYTokenCached / _baseCached) *                 timeElapsed;         ....     } ```  The multiplication should be always placed at the end to avoid miscalculations like the following one:  ```   a = (b/d)*c   0 = (5/10)*2      a = (b * c)/ 2   1 = (5 * 2)/10  ```      
# Handle  a_delamo   # Vulnerability details  ## Impact The following methods could be external instead of public  ``` level(bytes12) should be declared external:         - Cauldron.level(bytes12) (contracts/Cauldron.sol#513-521) mature(bytes6) should be declared external:         - Cauldron.mature(bytes6) (contracts/Cauldron.sol#524-532) accrual(bytes6) should be declared external:         - Cauldron.accrual(bytes6) (contracts/Cauldron.sol#546-553) setFlashFeeFactor(uint256) should be declared external:         - Join.setFlashFeeFactor(uint256) (contracts/Join.sol#33-36) maxFlashLoan(address) should be declared external:         - Join.maxFlashLoan(address) (contracts/Join.sol#90-97) flashFee(address,uint256) should be declared external:         - Join.flashFee(address,uint256) (contracts/Join.sol#105-113) flashLoan(IERC3156FlashBorrower,address,uint256,bytes) should be declared external:         - Join.flashLoan(IERC3156FlashBorrower,address,uint256,bytes) (contracts/Join.sol#132-151) setFee(uint256) should be declared external:         - Ladle.setFee(uint256) (contracts/Ladle.sol#102-105) addAsset(bytes6,address) should be declared external:         - Wand.addAsset(bytes6,address) (contracts/Wand.sol#49-61) makeBase(bytes6,IMultiOracleGov,address,address) should be declared external:         - Wand.makeBase(bytes6,IMultiOracleGov,address,address) (contracts/Wand.sol#65-78) makeIlk(bytes6,bytes6,IMultiOracleGov,address,uint32,uint96,uint24,uint8) should be declared external:         - Wand.makeIlk(bytes6,bytes6,IMultiOracleGov,address,uint32,uint96,uint24,uint8) (contracts/Wand.sol#81-94) addSeries(bytes6,bytes6,uint32,bytes6[],string,string) should be declared external:         - Wand.addSeries(bytes6,bytes6,uint32,bytes6[],string,string) (contracts/Wand.sol#98-154) setAuctionTime(uint128) should be declared external:         - Witch.setAuctionTime(uint128) (contracts/Witch.sol#41-44) setInitialProportion(uint128) should be declared external:         - Witch.setInitialProportion(uint128) (contracts/Witch.sol#47-51) grab(bytes12) should be declared external:         - Witch.grab(bytes12) (contracts/Witch.sol#54-59) buy(bytes12,uint128,uint128) should be declared external:         - Witch.buy(bytes12,uint128,uint128) (contracts/Witch.sol#62-99) mint(address,uint256) should be declared external:         - DAIMock.mint(address,uint256) (contracts/mocks/DAIMock.sol#36-38) mint(address,uint256) should be declared external:         - ERC20Mock.mint(address,uint256) (contracts/mocks/ERC20Mock.sol#11-13) mint(address,uint256) should be declared external:         - RestrictedERC20Mock.mint(address,uint256) (contracts/mocks/RestrictedERC20Mock.sol#12-14) burn(address,uint256) should be declared external:         - RestrictedERC20Mock.burn(address,uint256) (contracts/mocks/RestrictedERC20Mock.sol#17-19) pull(address,uint256) should be declared external:         - GemJoinMock.pull(address,uint256) (contracts/mocks/TLMMock.sol#14-16) mint(address,uint256) should be declared external:         - USDCMock.mint(address,uint256) (contracts/mocks/USDCMock.sol#13-15) withdraw(uint256) should be declared external:         - WETH9Mock.withdraw(uint256) (contracts/mocks/WETH9Mock.sol#21-26) totalSupply() should be declared external:         - WETH9Mock.totalSupply() (contracts/mocks/WETH9Mock.sol#28-30) latestRoundData() should be declared external:         - ChainlinkAggregatorV3Mock.latestRoundData() (contracts/mocks/oracles/chainlink/ChainlinkAggregatorV3Mock.sol#22-34) exchangeRateCurrent() should be declared external:         - CTokenChiMock.exchangeRateCurrent() (contracts/mocks/oracles/compound/CTokenChiMock.sol#12-14) tickSpacing() should be declared external:         - UniswapV3PoolMock.tickSpacing() (contracts/mocks/oracles/uniswap/UniswapV3PoolMock.sol#27-29) maxLiquidityPerTick() should be declared external:         - UniswapV3PoolMock.maxLiquidityPerTick() (contracts/mocks/oracles/uniswap/UniswapV3PoolMock.sol#31-33) setSources(bytes6[],bytes6[],address[]) should be declared external:         - ChainlinkMultiOracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#56-68) peek(bytes32,bytes32,uint256) should be declared external:         - ChainlinkMultiOracle.peek(bytes32,bytes32,uint256) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#105-113)         - CompoundMultiOracle.peek(bytes32,bytes32,uint256) (contracts/oracles/compound/CompoundMultiOracle.sol#78-86)         - UniswapV3Oracle.peek(bytes32,bytes32,uint256) (contracts/oracles/uniswap/UniswapV3Oracle.sol#126-132) get(bytes32,bytes32,uint256) should be declared external:         - ChainlinkMultiOracle.get(bytes32,bytes32,uint256) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#119-127)         - CompoundMultiOracle.get(bytes32,bytes32,uint256) (contracts/oracles/compound/CompoundMultiOracle.sol#92-100)         - UniswapV3Oracle.get(bytes32,bytes32,uint256) (contracts/oracles/uniswap/UniswapV3Oracle.sol#138-144) setSources(bytes6[],bytes6[],address[]) should be declared external:         - CompoundMultiOracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/compound/CompoundMultiOracle.sol#37-48) setSecondsAgo(uint32) should be declared external:         - UniswapV3Oracle.setSecondsAgo(uint32) (contracts/oracles/uniswap/UniswapV3Oracle.sol#44-48) setSources(bytes6[],bytes6[],address[]) should be declared external:         - UniswapV3Oracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/uniswap/UniswapV3Oracle.sol#73-85) transferOwnership(address) should be declared external:         - Ownable.transferOwnership(address) (contracts/utils/access/Ownable.sol#25-28) tokenSymbol(address) should be declared external:         - SafeERC20Namer.tokenSymbol(address) (contracts/utils/token/SafeERC20Namer.sol#87-95) tokenName(address) should be declared external:         - SafeERC20Namer.tokenName(address) (contracts/utils/token/SafeERC20Namer.sol#98-106) setParameter(bytes32,int128) should be declared external:         - Pool.setParameter(bytes32,int128) (contracts/yieldspace/Pool.sol#135-141) getK() should be declared external:         - Pool.getK() (contracts/yieldspace/Pool.sol#144-147) getG1() should be declared external:         - Pool.getG1() (contracts/yieldspace/Pool.sol#150-152) getG2() should be declared external:         - Pool.getG2() (contracts/yieldspace/Pool.sol#155-157) getCache() should be declared external:         - Pool.getCache() (contracts/yieldspace/Pool.sol#175-185) fyTokenOutForBaseIn(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.fyTokenOutForBaseIn(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#657-694) baseOutForFYTokenIn(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.baseOutForFYTokenIn(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#707-744) fyTokenInForBaseOut(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.fyTokenInForBaseOut(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#757-797) baseInForFYTokenOut(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.baseInForFYTokenOut(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#811-848) ```  Here more information about the gas optimizations of external vs public: https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tools Used  Slither   
# Handle  pauliax   # Vulnerability details  ## Impact It would be helpful if function build explicitly check that seriesId != bytes12(0). In practice, it is not possible to have a series with an id of 0, so this check will not pass:     require (ilks[seriesId][ilkId] == true, "Ilk not added to series"); however, the error message is not very informative, thus I am suggesting adding an explicit check.  ## Recommended Mitigation Steps require (seriesId != bytes12(0), "Series id is zero");  
# Handle  pauliax   # Vulnerability details  ## Impact function redeem in contract FYToken should return 'redeemed' amount. There return value is not used anywhere, but it's a mistake that it assigns 'redeemed' but returns 'amount'.  ## Recommended Mitigation Steps Remove return sentence or explicitly return 'redeemed'.  
# Handle  pauliax   # Vulnerability details  ## Impact external function transferToPool is pretty useless and error-prone. It relies on the user not to leave these tokens in a separate tx, otherwise, it will just be feeding the bots. To use it directly users will have to write their own custom smart contract and chain actions.  ## Recommended Mitigation Steps It would be better to remove this function and leave the only way to invoke it via a batch function.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function batch of Ladle.sol, at the operation GIVE, the value of vault is stored and is deleted directly afterwards. So storing is unnecessary. Maybe the solidity compiler already optimizes this.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L228   function batch( } else if (operation == Operation.GIVE) {                ...                  vault = _give(vaultId, to);                 delete vault;   // Clear the cache, since the vault doesn't necessarily belong to msg.sender anymore              ## Tools Used  ## Recommended Mitigation Steps Remove the " vault = "   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Project uses multiple compiler versions with most specifying ^0.8.0, some specifying >=0.8.0 which allows breaking versions >= 0.9.0 in future if reused/redeployed, and some even allowing much older >= 0.5.0/0.6.0.   The dangers of allowing multiple compilers across breaking revisions is that the security bug fixes and features might be different across different contracts introducing vulnerabilities or giving a false sense of security.  For example, most contract use ^0.8.0 which means they have default checked arithmetic to prevent overflows/underflows without using OZ SafeMath. This doesn’t apply to the few (inherited) contracts that may be compiled with <0.8.0 and have unchecked overflows/underflows.   ## Proof of Concept  ^0.8.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L2  >= 0.8.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/yieldspace/YieldMath.sol#L2  >= 0.5.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/token/SafeERC20Namer.sol#L3  >= 0.6.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/token/TransferHelper.sol#L4  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. Update all contracts to use pragma solidity ^0.8.0 or better a fixed version like 0.8.4 2. Deploy with the same compiler version which was used for testing  
# Handle  0xRajeev   # Vulnerability details  ## Impact  flashFeeFactor is uninitialized at declaration and so zero initially until set by setFlashFeeFactor(). As indicated in one of the the explainer videos, the idea is to set this by default to uint256.max to disable flash loans by default.  Currently, flash loans are enabled by default with a zero flash fee unless changed by setFlashFeeFactor().  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L26  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L32-L39  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L107-L110  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L117-L119  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L132   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Initialize at declaration with a reasonable value which could be uint256.max to disable flash loans by default.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The LOCK role is special in AccessControl because it has itself as the admin role (like ROOT) but no members. This means that calling setRoleAdmin(msg.sig, LOCK) means no one can grant/revoke that msg.sig role anymore and it gets locked irreversibly. This means it disables admin-based permissioning management of that role and therefore is very powerful in its impact.  Given this, there is a special function lockRole() which is specifically meant to enforce LOCK as the admin for the specified role parameter. For all other role admin creations, the generic setRoleAdmin() may be used. However, setRoleAdmin() does not itself prevent specifying the use of LOCK as the admin. If this is accidentally used then it leads to disabling that role’s admin management irreversibly similar to the lockRole() function.  It is safer to force admins to use lockRole() as the only way to set admin to LOCK and prevent the use of LOCK as the adminRole parameter in setRoleAdmin(), because doing so will make the intention of the caller clearer as lockRole() clearly has that functionality specified in its name and that’s the only thing it does.   ## Proof of Concept  Alice who is the admin for foo() wants to give the admin rights to Bob (0xFFFFFFF0) but instead of calling setRoleAdmin(foo.sig, 0xFFFFFFF0), she calls setRoleAdmin(foo.sig, 0xFFFFFFFF) where 0xFFFFFFFF is LOCK. This makes LOCK as the admin for foo() and prevents any further admin-based access control management for foo().  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L48  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L129-L131  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L235-L240  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L165-L176  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Prevent the use of LOCK as the adminRole parameter in setRoleAdmin().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Add an address check in receive() of Ladle.sol to ensure the only address sending ETH being received in receive() is the Weth9 contract (similar to the check in PoolRouter.sol) for Ether withdrawal in _exitEther().  This will prevent stray Ether from being sent accidentally to this contract and getting locked.  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L521-L522  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/yieldspace/PoolRouter.sol#L145-L148   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add an address check in receive() of Ladle.sol to ensure only Weth9 contract can send Ether to this contract.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Many batched operation functions return values but these are ignored by the caller batch(). While this may be acceptable for the front-end which picks up any state changes from such functions via emitted events, integrating protocols that make a call to batch() may require it to package and send back return values of all operations from the batch to react on-chain to the success/failure or other return values from such calls. Otherwise, they will be in the dark on the success/impact of batched operations they’ve triggered.  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L120-L245  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L250  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L258  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L284-L286  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L296-L298  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L326-L328  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L342-L344  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L382-L384  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L396-L398  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L410-L412  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L446-L448  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L462-L464  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L527-L529  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L539-L541  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L559-L561  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L588-L590  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Package and send back return values of all batched operations’ functions to the caller of batch().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The grab() function in Cauldron is used by the Witch or other liquidation engines to grab vaults that are under-collateralized. To prevent re-grabbing without sufficient time for auctioning collateral/debt, the logic uses an auctionInterval threshold to give a reasonable window to a liquidation engine that has grabbed the vault.  The grab() function has a comment on Line 354: “// Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.” indicating a requirement of the auctionInterval being equal to one day. This can happen only if the auctionInterval is set appropriately. However, this state variable is uninitialized (defaults to 0) and depends on setAuctionInterval() being called with the appropriate auctionInterval_ value which is also not validated.  Discussion with the project lead indicated that this comment is incorrect. Nevertheless, it is safer to initialize auctionInterval at declaration to a safe default value instead of the current 0 which will allow liquidation engines to re-grab vaults without making any progress on liquidation auction. It is also good to add a threshold check in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value.  Rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because liquidation engines will keep re-grabbing vaults from each other and potentially result in liquidation bots entering a live-lock situation without making any progress on liquidation auctions. This will result in collateral being stuck and impact entire protocol’s functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.   ## Proof of Concept  Configuration recipe forgets to set the auctionInterval state variable by calling setAuctionInterval() and inadvertently leaves it at the default value of 0. Alternatively, it calls it but with a lower than intended/reasonable auction interval value. Both scenarios fail to give sufficient protection to liquidation engines from having their grabbed vaults re-grabbed without sufficient time for liquidation auctions.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L63  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L108-L115  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L354   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. Initialize auctionInterval  at declaration with a reasonable default value. 2. Add a threshold check in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The vaultID for a new vault being built is required to be specified by the user building a vault via the build() function (instead of being assigned by the Cauldron/protocol). An attacker can observe a build() as part of a batch transaction in the mempool, identify the vaultID being requested and front-run that by constructing a malicious batch transaction with only the build operation with that same vaultID. The protocol would create a vault with that vaultID and assign attacker as its owner. More importantly, the valid batch transaction in the mempool which was front-run will later fail to create its vault because that vaultID already exists, as per the check on Line180 of Cauldron.sol. As a result, the valid batch transaction fails entirely because of the attacker front-running with the observed vaultID.  While the attacker gains nothing except the ownership of an empty vault after spending the gas, this could grief the protocol’s real users by preventing them from opening a vault and interacting with the protocol in any manner.  Rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because valid vaults from the Yield front-end will never be successfully created and will lead to a DoS against the entire protocol’s functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.  ## Proof of Concept  Alice uses Yield’s front-end to create a valid batch transaction. Evil Eve observes that in the mempool and identifies the vaultID of the vault being built by Alice. Eve submits her own batch transaction (without using the front-end) with only a build operation using Alice’s vaultID. She uses a higher gas price to front-run Alice’s transaction and get’s the protocol to assign that vaultID to herself. Alice’s batch transaction later fails because the vaultID she requested is already assigned to Eve. Eve can do this for any valid transaction to grief protocol users by wasting her gas to cause DoS.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L180  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L173-L190  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L133-L135  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L249-L255   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Mitigate this DoS vector by having the Cauldron assign the vauldID instead of user specifying it in the build() operation. This would likely require the build() to be a separate non-batch transaction followed by other operations that use the vaultID assigned in build(). Consider the pros/cons of this approach because it will significantly affect the batching/caching logic in Ladle.  Alternatively, consider adding validation logic in Ladle’s batching to revert batches that have only build or a subset of the operations that do not make sense to the protocol’s operations per valid recipes, which could be an attacker’s signature pattern.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  setDebtLimits() is used to set the maximum and minimum debt for an underlying and ilk pair. The assumption is that max will be greater than min while setting them because otherwise the debt checks in _pour() for line/dust will fail and revert.  While max and min debt limits can be reset, it is safer to perform input validation on them in setDebtLimits().  ## Proof of Concept  A recipe incorrectly interchanges the values of min and max debt which leads to exceptions in pouring into the vaults.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L91-L92  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L319-L322  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Wand.sol#L79   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a check to ensure max > mix.  
# Handle  pauliax   # Vulnerability details  ## Impact In contract UniswapV3Oracle function _peek has visibility of public while the name and similar functions in other oracles are declared as private.  ## Recommended Mitigation Steps give _peek private visibility.  
# Handle  pauliax   # Vulnerability details  ## Impact function transferToPool is marked as 'payable'. It only transfers ERC20 tokens, no Ether, so there is no need in having 'payable' here.  ## Recommended Mitigation Steps Remove 'payable' modifier from function transferToPool.  
# Handle  pauliax   # Vulnerability details  ## Impact Function _burnInternal always returns 0 as a third parameter. It should return tokensBurnt, tokenOut, fyTokenOut.  ## Recommended Mitigation Steps return (tokensBurned, tokenOut, fyTokenOut);  
# Handle  cmichel   # Vulnerability details  The `FYToken.constructor` performs an external call to `IERC20Metadata(address(IJoin(join_).asset())).decimals()`. This function was optional in the initial ERC-20 and might fail for old tokens that therefore did not implement it.  ## Impact FyTokens cannot be created for tokens that implemented the old initial ERC20 without the `decimals` function.  ## Recommended Mitigation Steps Consider using the helper function in the utils to retrieve it `SafeERC20Namer.tokenDecimals`, the same way the `Pool.constructor` works.  
# Handle  cmichel   # Vulnerability details  The witch can `Witch.grab` vaults and the `vaultOwners[vaultId]` field is set to the original owner. However, when the auction time is over and the debt has not been fully paid back, the original owner is not restored, and the witch can grab the same vault again, overwriting the original owner `vaultOwners[vaultId]` field permanently with the witch.  ```solidity function grab(bytes12 vaultId) public {     DataTypes.Vault memory vault = cauldron.vaults(vaultId);     vaultOwners[vaultId] = vault.owner;     cauldron.grab(vaultId, address(this)); } ```  Even a full repayment will not restore the original vault owner anymore.  ## Impact No funds will be stuck as the vault can still be correctly liquidated (calling `settle`). However, the vault owner will not be restored which is bad if it is a valuable vaultId (low number) that has a special meaning or would be used as an NFT/for retroactive airdrops for initial liquidity providers down the road.  ## Recommended Mitigation Steps When grabbing check if `vaultOwners[vaultId]` is already the witch and in that case just do an early return of the function - not overwriting the `vaultOwners[vaultId]` field.   
# Handle  cmichel   # Vulnerability details  `Ladle._close` (and many other occurrences) reverts the transaction on certain signed inputs that are negated and cast to unsigned integers.  ```solidity // Ladle._close calling it with art or ink as type(int128).min will crash uint128 amt = _debtInBase(vault.seriesId, series, uint128(-art)); ilkJoin.exit(to, uint128(-ink))  // explanation int128 art = type(int128).min; // -2^127 uint128 amt = uint128(-art); // this fails as -art=--2^127=2^127 cannot be represented in int128 ```  Other places: - `CauldronMath.add` - `Ladle._pour` - everywhere where `-int*` is used  ## Impact One cannot use the actual `type(int128).min` value for function parameters.  ## Recommended Mitigation Steps Revert with a meaningful error message as is done in the `/math/Cast*` functions.   
# Handle  pauliax   # Vulnerability details  ## Impact enum TokenType in library PoolDataTypes is not used anywhere.  ## Recommended Mitigation Steps Either remove it or use it where intended.  
# Handle  pauliax   # Vulnerability details  ## Impact function setSources in Oracle contracts does not need 'auth' modifier as it will be checked anyway in function setSource. This does not impact the security, it is just a useless check that can be removed.  ## Recommended Mitigation Steps Remove 'auth' modifer from function setSources.  
# Handle  pauliax   # Vulnerability details  ## Impact In the contract ChainlinkMultiOracle both functions 'peek' and 'get' are identical. They are declared as views while based on IOracle interface 'get' should be transactional.   
# Handle  0xsomeone   # Vulnerability details  ## Impact  It is possible to duplicate currently held `ink` or `art` within a Cauldron, thereby breaking the contract's accounting system minting units out of thin air.  ## Proof of Concept  The `stir` function of the `Cauldron`, which can be invoked via a `Ladle` operation, caches balances in memory before decrementing and incrementing. As a result, if a transfer to self is performed, the assignment `balances[to] = balancesTo` will contain the added-to balance instead of the neutral balance.  This allows one to duplicate any number of `ink` or `art` units at will, thereby severely affecting the protocol's integrity. A similar attack was exploited in the third bZx hack resulting in a roughly 8 million loss.  Code Referenced: https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L268-L295  ## Tools Used  Manual Review.  ## Recommended Mitigation Steps  A `require` check should be imposed that prohibits the `from` and `to` variables to be equivalent.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function getRevertMsg of RevertMsgExtractor.sol uses assembly to retrieve revert information. The latest solidity version have new functions that allows you to retrieve information without assembly.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/utils/RevertMsgExtractor.sol function getRevertMsg(bytes memory returnData) internal pure returns (string memory) { ..        assembly {             // Slice the sighash.             returnData := add(returnData, 0x04)         }   ## Tools Used  ## Recommended Mitigation Steps Below is a piece of code showing the new functionality:  pragma solidity ^0.8.1;  contract ContractError {     function Underflow() public pure returns (uint) {          uint x = 0;          x--; // this will generate an underflow          return x;     }     function UncheckedUnderflow() public pure returns (uint) {          uint x = 0;          unchecked { x--; } // this will generate an underflow          return x;     }  }  contract C {     ContractError e = new ContractError();          function TestUnderflow() public view returns (string memory) {          try e.Underflow() returns (uint) {             return "Ok";         } catch Error(string memory reason) {             return reason;         } catch Panic(uint _code) {             if (_code == 0x01) { return "Assertion failed"; }             else if (_code == 0x11) { return "Underflow/overflow"; }             // We ignore the other errors.             return "Other Panic";         } catch (bytes memory reason) {              uint x=0;             for (uint i=0;i<4;i++) //get first 4 bytes                 x = (x<<8) + uint(uint8(reason[i]));                      if (x == 0x08c379a0) // abi.encodeWithSignature("Error(string)")                 return "Error";             return "Unknown";         }     } }   
# Handle  gpersoon   # Vulnerability details  ## Impact PoolFactory and JoinFactory contain very similar but also relatively complicated code. // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/yieldspace/PoolFactory.sol // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/JoinFactory.sol  The risk is that future changes/improvements in one contract might not be updated in the other.  ## Proof of Concept  ## Tools Used Editor  ## Recommended Mitigation Steps Consider refactoring the code where the core code is put in a library and reused from both of the contracts.   
# Handle  gpersoon   # Vulnerability details  ## Impact Several implementations of the value of "chi" and "rate" are used, sometimes as constant and sometimes the direct value is used, see proof of concept below. The risk is that if it is changed in one place if might not be changed in another place, leading to bugs.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Wand.sol#L26 bytes6 public constant CHI = "chi"; bytes6 public constant RATE = "rate";  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L27 bytes32 constant CHI = "chi";  //https://github.com/code-423n4/2021-05-yield/blob/main/contracts/oracles/compound/CompoundMultiOracle.sol#L40     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {       ...         if (kind == "rate") rawPrice = CTokenInterface(source).borrowIndex();         else if (kind == "chi") rawPrice = CTokenInterface(source).exchangeRateStored();  ## Tools Used grep  ## Recommended Mitigation Steps Define the constants for "chi" and "rate" on one location and include this where required.   
# Handle  gpersoon   # Vulnerability details  ## Impact The code still has some todos, which should be resolved before production  ## Proof of Concept Ladle.sol:        weth.deposit{ value: ethTransferred }();   // TODO: Test gas savings using WETH10 `depositTo` Ladle.sol:        weth.withdraw(ethTransferred);   // TODO: Test gas savings using WETH10 `withdrawTo` Wand.sol:        cauldron.setRateOracle(assetId, IOracle(address(oracle))); // TODO: Consider adding a registry of chi oracles in cauldron as well Wand.sol:        ); // TODO: Use a FYTokenFactory to make Wand deployable at 20000 runs Wand.sol:            name,     // Derive from base and maturity, perhaps Wand.sol:            symbol    // Derive from base and maturity, perhaps  ## Tools Used Grep  ## Recommended Mitigation Steps Check and fix or remove the todos   
# Handle  gpersoon   # Vulnerability details  ## Impact The witch.sol contract gets access to a vault via the grab function, in case of liquidation. If the witch.sol contract can't sell the debt within a certain amount of time, a second grab can occur.  After the second grab, the information of the original owner of the vault is lost and the vault can't be returned to the original owner once the debt has been sold.  The grab function stores the previous owner in vaultOwners[vaultId] and then the contract itself is the new owner (via cauldron.grab and cauldron._give). The vaultOwners[vaultId] is overwritten at the second grab  The function buy of Witch.sol tried to give the vault back to the original owner, which won't succeed after a second grab.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L50     function grab(bytes12 vaultId) public {         DataTypes.Vault memory vault = cauldron.vaults(vaultId);         vaultOwners[vaultId] = vault.owner;         cauldron.grab(vaultId, address(this));     }  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L349     function grab(bytes12 vaultId, address receiver)  external  auth   {      ...         _give(vaultId, receiver);       // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L349  function _give(bytes12 vaultId, address receiver) internal returns(DataTypes.Vault memory vault)  {     ...         vault.owner = receiver;         vaults[vaultId] = vault;  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L57  function buy(bytes12 vaultId, uint128 art, uint128 min) public {      ....             cauldron.give(vaultId, vaultOwners[vaultId]);  ## Tools Used Editor  ## Recommended Mitigation Steps Assuming it's useful to give back to vault to the original owner: Make a stack/array of previous owners if multiple instances of the witch.sol contract would be used. Or check if the witch is already the owner (in the grab function) and keep the vaultOwners[vaultId] if that is the case  
# Handle  gpersoon   # Vulnerability details  ## Impact The auth modifier of AccessControl.sol doesn't work as you would expect.  It checks if you are authorized for "msg.sig", however msg.sig is the signature of the first function you have called, not of the current function. So if you call function A, which calls function B, the "auth" modifier of function B checks if you are authorized for function A!  There is a difference between external an public functions. For external functions this works as expected because a fresh call (with a new msg.sig) is always made. However with a public functions, which are called from within the same contract, this doesn't happen and the problem described above occurs. See in the proof of concept for a piece of code which shows the problem. In the code there are several functions which have public and auth combined, see also in the proof of concept .  In the current codebase I couldn't find a problem situation, however this could be accidentally introduced with future changes. If could also be introduced via the _moduleCall of Ladle.sol, which allows functions to be defined which might call the public functions.  ## Proof of Concept ### auth // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/utils/access/AccessControl.sol#L90 modifier auth() {         require (_hasRole(msg.sig, msg.sender), "Access denied");         _;     }  ### example pragma solidity ^0.8.0; contract TestMsgSig {      event log(bytes4);      function setFeePublic(uint256) public  {          emit log(this.setFeePublic.selector);          emit log(msg.sig);     }     function setFeeExternal(uint256) external  {          emit log(this.setFeeExternal.selector);          emit log(msg.sig);     }      function TestPublic() public {         setFeePublic(2);     }      function TestExternal() public {        this.setFeeExternal(2);     } } ### occurrences of public auth Wand.sol:   function addAsset(bytes6 assetId,address asset) public auth { Wand.sol:    function makeBase(bytes6 assetId, IMultiOracleGov oracle, address rateSource, address chiSource) public auth { Wand.sol:    function makeIlk(bytes6 baseId, bytes6 ilkId, IMultiOracleGov oracle, address spotSource, uint32 ratio, uint96 max, uint24 min, uint8 dec) public auth { Wand.sol:     function addSeries(...  ) public auth { Witch.sol:    function setAuctionTime(uint128 auctionTime_) public auth { Witch.sol:    function setInitialProportion(uint128 initialProportion_) public auth {  Ladle.sol:     function setFee(uint256 fee)         public        auth      Join.sol:    function setFlashFeeFactor(uint256 flashFeeFactor_) public   auth     {  oracles\chainlink\ChainlinkMultiOracle.sol:    function setSource(bytes6 base, bytes6 quote, address source) public auth { oracles\chainlink\ChainlinkMultiOracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth { oracles\compound\CompoundMultiOracle.sol:    function setSource(bytes6 base, bytes6 kind, address source) public auth { oracles\compound\CompoundMultiOracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory kinds, address[] memory sources_) public auth { oracles\uniswap\UniswapV3Oracle.sol:    function setSecondsAgo(uint32 secondsAgo_) public auth { oracles\uniswap\UniswapV3Oracle.sol:    function setSource(bytes6 base, bytes6 quote, address source) public auth { oracles\uniswap\UniswapV3Oracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth { fytoken.sol:  function setOracle(IOracle oracle_)  public  auth     {   ## Tools Used grep  ## Recommended Mitigation Steps make sure all auth functions use external  (still error prone) or change the modifier to something like:     modifier auth(bytes4 fs) {         require (msg.sig == fs,"Wrong selector");         require (_hasRole(msg.sig, msg.sender), "Access denied");         _;     }      function setFee(uint256) public auth(this.setFee.selector) {        .....     }    
# Handle  gpersoon   # Vulnerability details  ## Impact In several locations in the code numbers like 1e12, 1e18, 1e27 are used. The same goes for values like: type(uint256).max It quite easy to make a mistake somewhere, also when comparing values.  ## Proof of Concept .\Cauldron.sol:        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32("rate"), 1e18); .\Cauldron.sol:            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32("rate"), 1e18); .\Cauldron.sol:        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals) .\Cauldron.sol:        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals .\FYToken.sol:        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18); .\FYToken.sol:            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18); .\FYToken.sol:        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals) .\Witch.sol:        require (initialProportion_ <= 1e18, "Only at or under 100%"); .\Witch.sol:            uint256 term2 = initialProportion_ + (1e18 - initialProportion_).wmul(dividend2.wdiv(divisor2)); .\Witch.sol:            price = uint256(1e18).wdiv(term1.wmul(term2)); .\oracles\chainlink\ChainlinkMultiOracle.sol:        value = price * amount / 1e18; .\oracles\chainlink\ChainlinkMultiOracle.sol:        value = price * amount / 1e18; .\oracles\compound\CompoundMultiOracle.sol:        value = price * amount / 1e18; .\oracles\compound\CompoundMultiOracle.sol:        value = price * amount / 1e18; .\yieldspace\Pool.sol:            uint256 scaledFYTokenCached = uint256(_fyTokenCached) * 1e27; .\yieldspace\YieldMath.sol:      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero .\yieldspace\YieldMath.sol:      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero .\yieldspace\YieldMath.sol:      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max .\yieldspace\YieldMath.sol:      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max  .\FYToken.sol:    uint256 public chiAtMaturity = type(uint256).max;           // Spot price (exchange rate) between the base and an interest accruing token at maturity .\FYToken.sol:        require (chiAtMaturity == type(uint256).max, "Already matured"); .\FYToken.sol:        if (chiAtMaturity == type(uint256).max) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.    ## Tools Used grep  ## Recommended Mitigation Steps Define constants for the numbers used throughout the code.   
# Handle  gpersoon   # Vulnerability details  ## Impact The V1 version of YieldMath.sol contains ">=" (larger or equal), while the V2 version of YieldMath.sol containt ">" (larger) in the log_2 function. This change doesn't seem logical and might lead to miss calculations. The difference is present in a number of adjacent lines.  ## Proof of Concept // https://github.com/yieldprotocol/yieldspace-v1/blob/master/contracts/YieldMath.sol#L217 function log_2 (uint128 x) ... b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}   //https://github.com/code-423n4/2021-05-yield/blob/main/contracts/yieldspace/YieldMath.sol#L58 function log_2(uint128 x) ... b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}  ## Tools Used diff  ## Recommended Mitigation Steps Check which version is the correct version and fix the incorrect version.    
# Handle  shw   # Vulnerability details  ## Impact  According to the protocol design, users have to pay borrowing interest when repaying the debt with underlying tokens after maturity. However, a user can give his vault to `Witch` and then buy all his collateral using underlying tokens to avoid paying the interest. Besides, this bug could make users less incentivized to repay the debt before maturity and hold the underlying tokens until liquidation.  ## Proof of Concept  1. A user creates a new vault and opens a borrowing position as usual. 2. The maturity date passed. If the user wants to close the position using underlying tokens, he has to pay a borrowing interest (line 350 in `Ladle`), which is his debt multiplied by the rate accrual (line 373). 3. Now, the user wants to avoid paying the borrowing interest. He gives his vault to `Witch` by calling the function `batch` of `Ladle` with the operation `GIVE`. 4. He then calls the function `buy` of `Witch` with the corresponding `vaultId` to buy all his collateral using underlying tokens.  In the last step, the `elapsed` time (line 61) is equal to the current timestamp since the vault is never grabbed by `Witch` before, and thus the auction time of the vault, `cauldron.auctions(vaultId)`, is 0 (the default mapping value). Therefore, the collateral is sold at a price of `balances_.art/balances_.ink` (line 74). The user can buy `balances_.ink` amount of collateral using `balances_.art` but not paying for borrowing fees.  Referenced code: [Ladle.sol#L350](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L350) [Ladle.sol#L368-L377](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L368-L377) [Ladle.sol#L267-L272](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L267-L272) [Cauldron.sol#L234-L252](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L234-L252) [Witch.sol#L61](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L61) [Witch.sol#L74](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L74)  ## Recommended Mitigation Steps  Do not allow users to `give` vaults to `Witch`. To be more careful, require `vaultOwners[vaultId]` and `cauldron.auctions(vaultId)` to be non-zero at the beginning of function `buy`.  
# Handle  shw   # Vulnerability details  ## Impact  It is possible for an attacker to intendedly create a fake `Join` corresponding to a specific token beforehand to make `Wand` unable to deploy the actual `Join`, causing a DoS attack.  ## Proof of Concept  The address of `Join` corresponding to an underlying `asset` is determined as follows and thus unique:  ```solidity Join join = new Join{salt: keccak256(abi.encodePacked(asset))}(); ```  Besides, the function `createJoin` in the contract `JoinFactory` is permissionless: Anyone can create the `Join` corresponding to the `asset`. An attacker could then deploy a large number of `Joins` with different common underlying assets (e.g., DAI, USDC, ETH) before the `Wand` deploying them. The attempt of deploying these `Joins` by `Wand` would fail since the attacker had occupied the desired addresses with fake `Joins`, resulting in a DoS attack.  Moreover, the attacker can also perform DoS attacks on newly added assets: He monitors the mempool to find transactions calling the function `addAsset` of `Wand` and front-runs them to create the corresponding `Join` to make the benign transaction fail.  Referenced code: [JoinFactory.sol#L64-L75](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/JoinFactory.sol#L64-L75) [Wand.sol#L53](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Wand.sol#L53)  ## Recommended Mitigation Steps  Enable access control in `createJoin` (e.g., adding the `auth` modifier) and allow `Wand` to call it.  
# Handle  shw   # Vulnerability details  ## Impact  At line 172 in the contract `FYToken`, the `unchecked` keyword is unnecessary since no arithmetic operation is involved.  ## Proof of Concept  Referenced code: [FYToken.sol#L172](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L172)  ## Recommended Mitigation Steps  Consider removing the `unchecked` keyword.  
# Handle  a_delamo   # Vulnerability details  ## Impact  In the Pool.sol contract there is the following code:  ``` function _update(         uint128 baseBalance,         uint128 fyBalance,         uint112 _baseCached,         uint112 _fyTokenCached     ) private {         ....              cumulativeBalancesRatio +=                 (scaledFYTokenCached / _baseCached) *                 timeElapsed;         ....     } ```  The multiplication should be always placed at the end to avoid miscalculations like the following one:  ```   a = (b/d)*c   0 = (5/10)*2      a = (b * c)/ 2   1 = (5 * 2)/10  ```      
# Handle  a_delamo   # Vulnerability details  ## Impact The following methods could be external instead of public  ``` level(bytes12) should be declared external:         - Cauldron.level(bytes12) (contracts/Cauldron.sol#513-521) mature(bytes6) should be declared external:         - Cauldron.mature(bytes6) (contracts/Cauldron.sol#524-532) accrual(bytes6) should be declared external:         - Cauldron.accrual(bytes6) (contracts/Cauldron.sol#546-553) setFlashFeeFactor(uint256) should be declared external:         - Join.setFlashFeeFactor(uint256) (contracts/Join.sol#33-36) maxFlashLoan(address) should be declared external:         - Join.maxFlashLoan(address) (contracts/Join.sol#90-97) flashFee(address,uint256) should be declared external:         - Join.flashFee(address,uint256) (contracts/Join.sol#105-113) flashLoan(IERC3156FlashBorrower,address,uint256,bytes) should be declared external:         - Join.flashLoan(IERC3156FlashBorrower,address,uint256,bytes) (contracts/Join.sol#132-151) setFee(uint256) should be declared external:         - Ladle.setFee(uint256) (contracts/Ladle.sol#102-105) addAsset(bytes6,address) should be declared external:         - Wand.addAsset(bytes6,address) (contracts/Wand.sol#49-61) makeBase(bytes6,IMultiOracleGov,address,address) should be declared external:         - Wand.makeBase(bytes6,IMultiOracleGov,address,address) (contracts/Wand.sol#65-78) makeIlk(bytes6,bytes6,IMultiOracleGov,address,uint32,uint96,uint24,uint8) should be declared external:         - Wand.makeIlk(bytes6,bytes6,IMultiOracleGov,address,uint32,uint96,uint24,uint8) (contracts/Wand.sol#81-94) addSeries(bytes6,bytes6,uint32,bytes6[],string,string) should be declared external:         - Wand.addSeries(bytes6,bytes6,uint32,bytes6[],string,string) (contracts/Wand.sol#98-154) setAuctionTime(uint128) should be declared external:         - Witch.setAuctionTime(uint128) (contracts/Witch.sol#41-44) setInitialProportion(uint128) should be declared external:         - Witch.setInitialProportion(uint128) (contracts/Witch.sol#47-51) grab(bytes12) should be declared external:         - Witch.grab(bytes12) (contracts/Witch.sol#54-59) buy(bytes12,uint128,uint128) should be declared external:         - Witch.buy(bytes12,uint128,uint128) (contracts/Witch.sol#62-99) mint(address,uint256) should be declared external:         - DAIMock.mint(address,uint256) (contracts/mocks/DAIMock.sol#36-38) mint(address,uint256) should be declared external:         - ERC20Mock.mint(address,uint256) (contracts/mocks/ERC20Mock.sol#11-13) mint(address,uint256) should be declared external:         - RestrictedERC20Mock.mint(address,uint256) (contracts/mocks/RestrictedERC20Mock.sol#12-14) burn(address,uint256) should be declared external:         - RestrictedERC20Mock.burn(address,uint256) (contracts/mocks/RestrictedERC20Mock.sol#17-19) pull(address,uint256) should be declared external:         - GemJoinMock.pull(address,uint256) (contracts/mocks/TLMMock.sol#14-16) mint(address,uint256) should be declared external:         - USDCMock.mint(address,uint256) (contracts/mocks/USDCMock.sol#13-15) withdraw(uint256) should be declared external:         - WETH9Mock.withdraw(uint256) (contracts/mocks/WETH9Mock.sol#21-26) totalSupply() should be declared external:         - WETH9Mock.totalSupply() (contracts/mocks/WETH9Mock.sol#28-30) latestRoundData() should be declared external:         - ChainlinkAggregatorV3Mock.latestRoundData() (contracts/mocks/oracles/chainlink/ChainlinkAggregatorV3Mock.sol#22-34) exchangeRateCurrent() should be declared external:         - CTokenChiMock.exchangeRateCurrent() (contracts/mocks/oracles/compound/CTokenChiMock.sol#12-14) tickSpacing() should be declared external:         - UniswapV3PoolMock.tickSpacing() (contracts/mocks/oracles/uniswap/UniswapV3PoolMock.sol#27-29) maxLiquidityPerTick() should be declared external:         - UniswapV3PoolMock.maxLiquidityPerTick() (contracts/mocks/oracles/uniswap/UniswapV3PoolMock.sol#31-33) setSources(bytes6[],bytes6[],address[]) should be declared external:         - ChainlinkMultiOracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#56-68) peek(bytes32,bytes32,uint256) should be declared external:         - ChainlinkMultiOracle.peek(bytes32,bytes32,uint256) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#105-113)         - CompoundMultiOracle.peek(bytes32,bytes32,uint256) (contracts/oracles/compound/CompoundMultiOracle.sol#78-86)         - UniswapV3Oracle.peek(bytes32,bytes32,uint256) (contracts/oracles/uniswap/UniswapV3Oracle.sol#126-132) get(bytes32,bytes32,uint256) should be declared external:         - ChainlinkMultiOracle.get(bytes32,bytes32,uint256) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#119-127)         - CompoundMultiOracle.get(bytes32,bytes32,uint256) (contracts/oracles/compound/CompoundMultiOracle.sol#92-100)         - UniswapV3Oracle.get(bytes32,bytes32,uint256) (contracts/oracles/uniswap/UniswapV3Oracle.sol#138-144) setSources(bytes6[],bytes6[],address[]) should be declared external:         - CompoundMultiOracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/compound/CompoundMultiOracle.sol#37-48) setSecondsAgo(uint32) should be declared external:         - UniswapV3Oracle.setSecondsAgo(uint32) (contracts/oracles/uniswap/UniswapV3Oracle.sol#44-48) setSources(bytes6[],bytes6[],address[]) should be declared external:         - UniswapV3Oracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/uniswap/UniswapV3Oracle.sol#73-85) transferOwnership(address) should be declared external:         - Ownable.transferOwnership(address) (contracts/utils/access/Ownable.sol#25-28) tokenSymbol(address) should be declared external:         - SafeERC20Namer.tokenSymbol(address) (contracts/utils/token/SafeERC20Namer.sol#87-95) tokenName(address) should be declared external:         - SafeERC20Namer.tokenName(address) (contracts/utils/token/SafeERC20Namer.sol#98-106) setParameter(bytes32,int128) should be declared external:         - Pool.setParameter(bytes32,int128) (contracts/yieldspace/Pool.sol#135-141) getK() should be declared external:         - Pool.getK() (contracts/yieldspace/Pool.sol#144-147) getG1() should be declared external:         - Pool.getG1() (contracts/yieldspace/Pool.sol#150-152) getG2() should be declared external:         - Pool.getG2() (contracts/yieldspace/Pool.sol#155-157) getCache() should be declared external:         - Pool.getCache() (contracts/yieldspace/Pool.sol#175-185) fyTokenOutForBaseIn(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.fyTokenOutForBaseIn(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#657-694) baseOutForFYTokenIn(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.baseOutForFYTokenIn(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#707-744) fyTokenInForBaseOut(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.fyTokenInForBaseOut(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#757-797) baseInForFYTokenOut(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.baseInForFYTokenOut(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#811-848) ```  Here more information about the gas optimizations of external vs public: https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tools Used  Slither   
# Handle  pauliax   # Vulnerability details  ## Impact It would be helpful if function build explicitly check that seriesId != bytes12(0). In practice, it is not possible to have a series with an id of 0, so this check will not pass:     require (ilks[seriesId][ilkId] == true, "Ilk not added to series"); however, the error message is not very informative, thus I am suggesting adding an explicit check.  ## Recommended Mitigation Steps require (seriesId != bytes12(0), "Series id is zero");  
# Handle  pauliax   # Vulnerability details  ## Impact function redeem in contract FYToken should return 'redeemed' amount. There return value is not used anywhere, but it's a mistake that it assigns 'redeemed' but returns 'amount'.  ## Recommended Mitigation Steps Remove return sentence or explicitly return 'redeemed'.  
# Handle  pauliax   # Vulnerability details  ## Impact external function transferToPool is pretty useless and error-prone. It relies on the user not to leave these tokens in a separate tx, otherwise, it will just be feeding the bots. To use it directly users will have to write their own custom smart contract and chain actions.  ## Recommended Mitigation Steps It would be better to remove this function and leave the only way to invoke it via a batch function.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function batch of Ladle.sol, at the operation GIVE, the value of vault is stored and is deleted directly afterwards. So storing is unnecessary. Maybe the solidity compiler already optimizes this.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L228   function batch( } else if (operation == Operation.GIVE) {                ...                  vault = _give(vaultId, to);                 delete vault;   // Clear the cache, since the vault doesn't necessarily belong to msg.sender anymore              ## Tools Used  ## Recommended Mitigation Steps Remove the " vault = "   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Project uses multiple compiler versions with most specifying ^0.8.0, some specifying >=0.8.0 which allows breaking versions >= 0.9.0 in future if reused/redeployed, and some even allowing much older >= 0.5.0/0.6.0.   The dangers of allowing multiple compilers across breaking revisions is that the security bug fixes and features might be different across different contracts introducing vulnerabilities or giving a false sense of security.  For example, most contract use ^0.8.0 which means they have default checked arithmetic to prevent overflows/underflows without using OZ SafeMath. This doesn’t apply to the few (inherited) contracts that may be compiled with <0.8.0 and have unchecked overflows/underflows.   ## Proof of Concept  ^0.8.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L2  >= 0.8.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/yieldspace/YieldMath.sol#L2  >= 0.5.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/token/SafeERC20Namer.sol#L3  >= 0.6.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/token/TransferHelper.sol#L4  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. Update all contracts to use pragma solidity ^0.8.0 or better a fixed version like 0.8.4 2. Deploy with the same compiler version which was used for testing  
# Handle  0xRajeev   # Vulnerability details  ## Impact  flashFeeFactor is uninitialized at declaration and so zero initially until set by setFlashFeeFactor(). As indicated in one of the the explainer videos, the idea is to set this by default to uint256.max to disable flash loans by default.  Currently, flash loans are enabled by default with a zero flash fee unless changed by setFlashFeeFactor().  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L26  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L32-L39  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L107-L110  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L117-L119  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L132   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Initialize at declaration with a reasonable value which could be uint256.max to disable flash loans by default.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The LOCK role is special in AccessControl because it has itself as the admin role (like ROOT) but no members. This means that calling setRoleAdmin(msg.sig, LOCK) means no one can grant/revoke that msg.sig role anymore and it gets locked irreversibly. This means it disables admin-based permissioning management of that role and therefore is very powerful in its impact.  Given this, there is a special function lockRole() which is specifically meant to enforce LOCK as the admin for the specified role parameter. For all other role admin creations, the generic setRoleAdmin() may be used. However, setRoleAdmin() does not itself prevent specifying the use of LOCK as the admin. If this is accidentally used then it leads to disabling that role’s admin management irreversibly similar to the lockRole() function.  It is safer to force admins to use lockRole() as the only way to set admin to LOCK and prevent the use of LOCK as the adminRole parameter in setRoleAdmin(), because doing so will make the intention of the caller clearer as lockRole() clearly has that functionality specified in its name and that’s the only thing it does.   ## Proof of Concept  Alice who is the admin for foo() wants to give the admin rights to Bob (0xFFFFFFF0) but instead of calling setRoleAdmin(foo.sig, 0xFFFFFFF0), she calls setRoleAdmin(foo.sig, 0xFFFFFFFF) where 0xFFFFFFFF is LOCK. This makes LOCK as the admin for foo() and prevents any further admin-based access control management for foo().  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L48  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L129-L131  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L235-L240  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L165-L176  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Prevent the use of LOCK as the adminRole parameter in setRoleAdmin().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Add an address check in receive() of Ladle.sol to ensure the only address sending ETH being received in receive() is the Weth9 contract (similar to the check in PoolRouter.sol) for Ether withdrawal in _exitEther().  This will prevent stray Ether from being sent accidentally to this contract and getting locked.  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L521-L522  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/yieldspace/PoolRouter.sol#L145-L148   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add an address check in receive() of Ladle.sol to ensure only Weth9 contract can send Ether to this contract.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Many batched operation functions return values but these are ignored by the caller batch(). While this may be acceptable for the front-end which picks up any state changes from such functions via emitted events, integrating protocols that make a call to batch() may require it to package and send back return values of all operations from the batch to react on-chain to the success/failure or other return values from such calls. Otherwise, they will be in the dark on the success/impact of batched operations they’ve triggered.  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L120-L245  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L250  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L258  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L284-L286  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L296-L298  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L326-L328  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L342-L344  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L382-L384  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L396-L398  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L410-L412  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L446-L448  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L462-L464  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L527-L529  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L539-L541  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L559-L561  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L588-L590  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Package and send back return values of all batched operations’ functions to the caller of batch().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The grab() function in Cauldron is used by the Witch or other liquidation engines to grab vaults that are under-collateralized. To prevent re-grabbing without sufficient time for auctioning collateral/debt, the logic uses an auctionInterval threshold to give a reasonable window to a liquidation engine that has grabbed the vault.  The grab() function has a comment on Line 354: “// Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.” indicating a requirement of the auctionInterval being equal to one day. This can happen only if the auctionInterval is set appropriately. However, this state variable is uninitialized (defaults to 0) and depends on setAuctionInterval() being called with the appropriate auctionInterval_ value which is also not validated.  Discussion with the project lead indicated that this comment is incorrect. Nevertheless, it is safer to initialize auctionInterval at declaration to a safe default value instead of the current 0 which will allow liquidation engines to re-grab vaults without making any progress on liquidation auction. It is also good to add a threshold check in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value.  Rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because liquidation engines will keep re-grabbing vaults from each other and potentially result in liquidation bots entering a live-lock situation without making any progress on liquidation auctions. This will result in collateral being stuck and impact entire protocol’s functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.   ## Proof of Concept  Configuration recipe forgets to set the auctionInterval state variable by calling setAuctionInterval() and inadvertently leaves it at the default value of 0. Alternatively, it calls it but with a lower than intended/reasonable auction interval value. Both scenarios fail to give sufficient protection to liquidation engines from having their grabbed vaults re-grabbed without sufficient time for liquidation auctions.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L63  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L108-L115  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L354   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. Initialize auctionInterval  at declaration with a reasonable default value. 2. Add a threshold check in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The vaultID for a new vault being built is required to be specified by the user building a vault via the build() function (instead of being assigned by the Cauldron/protocol). An attacker can observe a build() as part of a batch transaction in the mempool, identify the vaultID being requested and front-run that by constructing a malicious batch transaction with only the build operation with that same vaultID. The protocol would create a vault with that vaultID and assign attacker as its owner. More importantly, the valid batch transaction in the mempool which was front-run will later fail to create its vault because that vaultID already exists, as per the check on Line180 of Cauldron.sol. As a result, the valid batch transaction fails entirely because of the attacker front-running with the observed vaultID.  While the attacker gains nothing except the ownership of an empty vault after spending the gas, this could grief the protocol’s real users by preventing them from opening a vault and interacting with the protocol in any manner.  Rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because valid vaults from the Yield front-end will never be successfully created and will lead to a DoS against the entire protocol’s functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.  ## Proof of Concept  Alice uses Yield’s front-end to create a valid batch transaction. Evil Eve observes that in the mempool and identifies the vaultID of the vault being built by Alice. Eve submits her own batch transaction (without using the front-end) with only a build operation using Alice’s vaultID. She uses a higher gas price to front-run Alice’s transaction and get’s the protocol to assign that vaultID to herself. Alice’s batch transaction later fails because the vaultID she requested is already assigned to Eve. Eve can do this for any valid transaction to grief protocol users by wasting her gas to cause DoS.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L180  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L173-L190  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L133-L135  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L249-L255   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Mitigate this DoS vector by having the Cauldron assign the vauldID instead of user specifying it in the build() operation. This would likely require the build() to be a separate non-batch transaction followed by other operations that use the vaultID assigned in build(). Consider the pros/cons of this approach because it will significantly affect the batching/caching logic in Ladle.  Alternatively, consider adding validation logic in Ladle’s batching to revert batches that have only build or a subset of the operations that do not make sense to the protocol’s operations per valid recipes, which could be an attacker’s signature pattern.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  setDebtLimits() is used to set the maximum and minimum debt for an underlying and ilk pair. The assumption is that max will be greater than min while setting them because otherwise the debt checks in _pour() for line/dust will fail and revert.  While max and min debt limits can be reset, it is safer to perform input validation on them in setDebtLimits().  ## Proof of Concept  A recipe incorrectly interchanges the values of min and max debt which leads to exceptions in pouring into the vaults.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L91-L92  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L319-L322  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Wand.sol#L79   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a check to ensure max > mix.  
# Handle  pauliax   # Vulnerability details  ## Impact In contract UniswapV3Oracle function _peek has visibility of public while the name and similar functions in other oracles are declared as private.  ## Recommended Mitigation Steps give _peek private visibility.  
# Handle  pauliax   # Vulnerability details  ## Impact function transferToPool is marked as 'payable'. It only transfers ERC20 tokens, no Ether, so there is no need in having 'payable' here.  ## Recommended Mitigation Steps Remove 'payable' modifier from function transferToPool.  
# Handle  pauliax   # Vulnerability details  ## Impact Function _burnInternal always returns 0 as a third parameter. It should return tokensBurnt, tokenOut, fyTokenOut.  ## Recommended Mitigation Steps return (tokensBurned, tokenOut, fyTokenOut);  
# Handle  cmichel   # Vulnerability details  The `FYToken.constructor` performs an external call to `IERC20Metadata(address(IJoin(join_).asset())).decimals()`. This function was optional in the initial ERC-20 and might fail for old tokens that therefore did not implement it.  ## Impact FyTokens cannot be created for tokens that implemented the old initial ERC20 without the `decimals` function.  ## Recommended Mitigation Steps Consider using the helper function in the utils to retrieve it `SafeERC20Namer.tokenDecimals`, the same way the `Pool.constructor` works.  
# Handle  cmichel   # Vulnerability details  The witch can `Witch.grab` vaults and the `vaultOwners[vaultId]` field is set to the original owner. However, when the auction time is over and the debt has not been fully paid back, the original owner is not restored, and the witch can grab the same vault again, overwriting the original owner `vaultOwners[vaultId]` field permanently with the witch.  ```solidity function grab(bytes12 vaultId) public {     DataTypes.Vault memory vault = cauldron.vaults(vaultId);     vaultOwners[vaultId] = vault.owner;     cauldron.grab(vaultId, address(this)); } ```  Even a full repayment will not restore the original vault owner anymore.  ## Impact No funds will be stuck as the vault can still be correctly liquidated (calling `settle`). However, the vault owner will not be restored which is bad if it is a valuable vaultId (low number) that has a special meaning or would be used as an NFT/for retroactive airdrops for initial liquidity providers down the road.  ## Recommended Mitigation Steps When grabbing check if `vaultOwners[vaultId]` is already the witch and in that case just do an early return of the function - not overwriting the `vaultOwners[vaultId]` field.   
# Handle  cmichel   # Vulnerability details  `Ladle._close` (and many other occurrences) reverts the transaction on certain signed inputs that are negated and cast to unsigned integers.  ```solidity // Ladle._close calling it with art or ink as type(int128).min will crash uint128 amt = _debtInBase(vault.seriesId, series, uint128(-art)); ilkJoin.exit(to, uint128(-ink))  // explanation int128 art = type(int128).min; // -2^127 uint128 amt = uint128(-art); // this fails as -art=--2^127=2^127 cannot be represented in int128 ```  Other places: - `CauldronMath.add` - `Ladle._pour` - everywhere where `-int*` is used  ## Impact One cannot use the actual `type(int128).min` value for function parameters.  ## Recommended Mitigation Steps Revert with a meaningful error message as is done in the `/math/Cast*` functions.   
# Handle  pauliax   # Vulnerability details  ## Impact enum TokenType in library PoolDataTypes is not used anywhere.  ## Recommended Mitigation Steps Either remove it or use it where intended.  
# Handle  pauliax   # Vulnerability details  ## Impact function setSources in Oracle contracts does not need 'auth' modifier as it will be checked anyway in function setSource. This does not impact the security, it is just a useless check that can be removed.  ## Recommended Mitigation Steps Remove 'auth' modifer from function setSources.  
# Handle  pauliax   # Vulnerability details  ## Impact In the contract ChainlinkMultiOracle both functions 'peek' and 'get' are identical. They are declared as views while based on IOracle interface 'get' should be transactional.   
# Handle  0xsomeone   # Vulnerability details  ## Impact  It is possible to duplicate currently held `ink` or `art` within a Cauldron, thereby breaking the contract's accounting system minting units out of thin air.  ## Proof of Concept  The `stir` function of the `Cauldron`, which can be invoked via a `Ladle` operation, caches balances in memory before decrementing and incrementing. As a result, if a transfer to self is performed, the assignment `balances[to] = balancesTo` will contain the added-to balance instead of the neutral balance.  This allows one to duplicate any number of `ink` or `art` units at will, thereby severely affecting the protocol's integrity. A similar attack was exploited in the third bZx hack resulting in a roughly 8 million loss.  Code Referenced: https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L268-L295  ## Tools Used  Manual Review.  ## Recommended Mitigation Steps  A `require` check should be imposed that prohibits the `from` and `to` variables to be equivalent.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function getRevertMsg of RevertMsgExtractor.sol uses assembly to retrieve revert information. The latest solidity version have new functions that allows you to retrieve information without assembly.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/utils/RevertMsgExtractor.sol function getRevertMsg(bytes memory returnData) internal pure returns (string memory) { ..        assembly {             // Slice the sighash.             returnData := add(returnData, 0x04)         }   ## Tools Used  ## Recommended Mitigation Steps Below is a piece of code showing the new functionality:  pragma solidity ^0.8.1;  contract ContractError {     function Underflow() public pure returns (uint) {          uint x = 0;          x--; // this will generate an underflow          return x;     }     function UncheckedUnderflow() public pure returns (uint) {          uint x = 0;          unchecked { x--; } // this will generate an underflow          return x;     }  }  contract C {     ContractError e = new ContractError();          function TestUnderflow() public view returns (string memory) {          try e.Underflow() returns (uint) {             return "Ok";         } catch Error(string memory reason) {             return reason;         } catch Panic(uint _code) {             if (_code == 0x01) { return "Assertion failed"; }             else if (_code == 0x11) { return "Underflow/overflow"; }             // We ignore the other errors.             return "Other Panic";         } catch (bytes memory reason) {              uint x=0;             for (uint i=0;i<4;i++) //get first 4 bytes                 x = (x<<8) + uint(uint8(reason[i]));                      if (x == 0x08c379a0) // abi.encodeWithSignature("Error(string)")                 return "Error";             return "Unknown";         }     } }   
# Handle  gpersoon   # Vulnerability details  ## Impact PoolFactory and JoinFactory contain very similar but also relatively complicated code. // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/yieldspace/PoolFactory.sol // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/JoinFactory.sol  The risk is that future changes/improvements in one contract might not be updated in the other.  ## Proof of Concept  ## Tools Used Editor  ## Recommended Mitigation Steps Consider refactoring the code where the core code is put in a library and reused from both of the contracts.   
# Handle  gpersoon   # Vulnerability details  ## Impact Several implementations of the value of "chi" and "rate" are used, sometimes as constant and sometimes the direct value is used, see proof of concept below. The risk is that if it is changed in one place if might not be changed in another place, leading to bugs.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Wand.sol#L26 bytes6 public constant CHI = "chi"; bytes6 public constant RATE = "rate";  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L27 bytes32 constant CHI = "chi";  //https://github.com/code-423n4/2021-05-yield/blob/main/contracts/oracles/compound/CompoundMultiOracle.sol#L40     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {       ...         if (kind == "rate") rawPrice = CTokenInterface(source).borrowIndex();         else if (kind == "chi") rawPrice = CTokenInterface(source).exchangeRateStored();  ## Tools Used grep  ## Recommended Mitigation Steps Define the constants for "chi" and "rate" on one location and include this where required.   
# Handle  gpersoon   # Vulnerability details  ## Impact The code still has some todos, which should be resolved before production  ## Proof of Concept Ladle.sol:        weth.deposit{ value: ethTransferred }();   // TODO: Test gas savings using WETH10 `depositTo` Ladle.sol:        weth.withdraw(ethTransferred);   // TODO: Test gas savings using WETH10 `withdrawTo` Wand.sol:        cauldron.setRateOracle(assetId, IOracle(address(oracle))); // TODO: Consider adding a registry of chi oracles in cauldron as well Wand.sol:        ); // TODO: Use a FYTokenFactory to make Wand deployable at 20000 runs Wand.sol:            name,     // Derive from base and maturity, perhaps Wand.sol:            symbol    // Derive from base and maturity, perhaps  ## Tools Used Grep  ## Recommended Mitigation Steps Check and fix or remove the todos   
# Handle  gpersoon   # Vulnerability details  ## Impact The witch.sol contract gets access to a vault via the grab function, in case of liquidation. If the witch.sol contract can't sell the debt within a certain amount of time, a second grab can occur.  After the second grab, the information of the original owner of the vault is lost and the vault can't be returned to the original owner once the debt has been sold.  The grab function stores the previous owner in vaultOwners[vaultId] and then the contract itself is the new owner (via cauldron.grab and cauldron._give). The vaultOwners[vaultId] is overwritten at the second grab  The function buy of Witch.sol tried to give the vault back to the original owner, which won't succeed after a second grab.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L50     function grab(bytes12 vaultId) public {         DataTypes.Vault memory vault = cauldron.vaults(vaultId);         vaultOwners[vaultId] = vault.owner;         cauldron.grab(vaultId, address(this));     }  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L349     function grab(bytes12 vaultId, address receiver)  external  auth   {      ...         _give(vaultId, receiver);       // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L349  function _give(bytes12 vaultId, address receiver) internal returns(DataTypes.Vault memory vault)  {     ...         vault.owner = receiver;         vaults[vaultId] = vault;  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L57  function buy(bytes12 vaultId, uint128 art, uint128 min) public {      ....             cauldron.give(vaultId, vaultOwners[vaultId]);  ## Tools Used Editor  ## Recommended Mitigation Steps Assuming it's useful to give back to vault to the original owner: Make a stack/array of previous owners if multiple instances of the witch.sol contract would be used. Or check if the witch is already the owner (in the grab function) and keep the vaultOwners[vaultId] if that is the case  
# Handle  gpersoon   # Vulnerability details  ## Impact The auth modifier of AccessControl.sol doesn't work as you would expect.  It checks if you are authorized for "msg.sig", however msg.sig is the signature of the first function you have called, not of the current function. So if you call function A, which calls function B, the "auth" modifier of function B checks if you are authorized for function A!  There is a difference between external an public functions. For external functions this works as expected because a fresh call (with a new msg.sig) is always made. However with a public functions, which are called from within the same contract, this doesn't happen and the problem described above occurs. See in the proof of concept for a piece of code which shows the problem. In the code there are several functions which have public and auth combined, see also in the proof of concept .  In the current codebase I couldn't find a problem situation, however this could be accidentally introduced with future changes. If could also be introduced via the _moduleCall of Ladle.sol, which allows functions to be defined which might call the public functions.  ## Proof of Concept ### auth // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/utils/access/AccessControl.sol#L90 modifier auth() {         require (_hasRole(msg.sig, msg.sender), "Access denied");         _;     }  ### example pragma solidity ^0.8.0; contract TestMsgSig {      event log(bytes4);      function setFeePublic(uint256) public  {          emit log(this.setFeePublic.selector);          emit log(msg.sig);     }     function setFeeExternal(uint256) external  {          emit log(this.setFeeExternal.selector);          emit log(msg.sig);     }      function TestPublic() public {         setFeePublic(2);     }      function TestExternal() public {        this.setFeeExternal(2);     } } ### occurrences of public auth Wand.sol:   function addAsset(bytes6 assetId,address asset) public auth { Wand.sol:    function makeBase(bytes6 assetId, IMultiOracleGov oracle, address rateSource, address chiSource) public auth { Wand.sol:    function makeIlk(bytes6 baseId, bytes6 ilkId, IMultiOracleGov oracle, address spotSource, uint32 ratio, uint96 max, uint24 min, uint8 dec) public auth { Wand.sol:     function addSeries(...  ) public auth { Witch.sol:    function setAuctionTime(uint128 auctionTime_) public auth { Witch.sol:    function setInitialProportion(uint128 initialProportion_) public auth {  Ladle.sol:     function setFee(uint256 fee)         public        auth      Join.sol:    function setFlashFeeFactor(uint256 flashFeeFactor_) public   auth     {  oracles\chainlink\ChainlinkMultiOracle.sol:    function setSource(bytes6 base, bytes6 quote, address source) public auth { oracles\chainlink\ChainlinkMultiOracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth { oracles\compound\CompoundMultiOracle.sol:    function setSource(bytes6 base, bytes6 kind, address source) public auth { oracles\compound\CompoundMultiOracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory kinds, address[] memory sources_) public auth { oracles\uniswap\UniswapV3Oracle.sol:    function setSecondsAgo(uint32 secondsAgo_) public auth { oracles\uniswap\UniswapV3Oracle.sol:    function setSource(bytes6 base, bytes6 quote, address source) public auth { oracles\uniswap\UniswapV3Oracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth { fytoken.sol:  function setOracle(IOracle oracle_)  public  auth     {   ## Tools Used grep  ## Recommended Mitigation Steps make sure all auth functions use external  (still error prone) or change the modifier to something like:     modifier auth(bytes4 fs) {         require (msg.sig == fs,"Wrong selector");         require (_hasRole(msg.sig, msg.sender), "Access denied");         _;     }      function setFee(uint256) public auth(this.setFee.selector) {        .....     }    
# Handle  gpersoon   # Vulnerability details  ## Impact In several locations in the code numbers like 1e12, 1e18, 1e27 are used. The same goes for values like: type(uint256).max It quite easy to make a mistake somewhere, also when comparing values.  ## Proof of Concept .\Cauldron.sol:        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32("rate"), 1e18); .\Cauldron.sol:            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32("rate"), 1e18); .\Cauldron.sol:        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals) .\Cauldron.sol:        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals .\FYToken.sol:        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18); .\FYToken.sol:            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18); .\FYToken.sol:        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals) .\Witch.sol:        require (initialProportion_ <= 1e18, "Only at or under 100%"); .\Witch.sol:            uint256 term2 = initialProportion_ + (1e18 - initialProportion_).wmul(dividend2.wdiv(divisor2)); .\Witch.sol:            price = uint256(1e18).wdiv(term1.wmul(term2)); .\oracles\chainlink\ChainlinkMultiOracle.sol:        value = price * amount / 1e18; .\oracles\chainlink\ChainlinkMultiOracle.sol:        value = price * amount / 1e18; .\oracles\compound\CompoundMultiOracle.sol:        value = price * amount / 1e18; .\oracles\compound\CompoundMultiOracle.sol:        value = price * amount / 1e18; .\yieldspace\Pool.sol:            uint256 scaledFYTokenCached = uint256(_fyTokenCached) * 1e27; .\yieldspace\YieldMath.sol:      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero .\yieldspace\YieldMath.sol:      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero .\yieldspace\YieldMath.sol:      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max .\yieldspace\YieldMath.sol:      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max  .\FYToken.sol:    uint256 public chiAtMaturity = type(uint256).max;           // Spot price (exchange rate) between the base and an interest accruing token at maturity .\FYToken.sol:        require (chiAtMaturity == type(uint256).max, "Already matured"); .\FYToken.sol:        if (chiAtMaturity == type(uint256).max) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.    ## Tools Used grep  ## Recommended Mitigation Steps Define constants for the numbers used throughout the code.   
# Handle  gpersoon   # Vulnerability details  ## Impact The V1 version of YieldMath.sol contains ">=" (larger or equal), while the V2 version of YieldMath.sol containt ">" (larger) in the log_2 function. This change doesn't seem logical and might lead to miss calculations. The difference is present in a number of adjacent lines.  ## Proof of Concept // https://github.com/yieldprotocol/yieldspace-v1/blob/master/contracts/YieldMath.sol#L217 function log_2 (uint128 x) ... b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}   //https://github.com/code-423n4/2021-05-yield/blob/main/contracts/yieldspace/YieldMath.sol#L58 function log_2(uint128 x) ... b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}  ## Tools Used diff  ## Recommended Mitigation Steps Check which version is the correct version and fix the incorrect version.    
# Handle  shw   # Vulnerability details  ## Impact  According to the protocol design, users have to pay borrowing interest when repaying the debt with underlying tokens after maturity. However, a user can give his vault to `Witch` and then buy all his collateral using underlying tokens to avoid paying the interest. Besides, this bug could make users less incentivized to repay the debt before maturity and hold the underlying tokens until liquidation.  ## Proof of Concept  1. A user creates a new vault and opens a borrowing position as usual. 2. The maturity date passed. If the user wants to close the position using underlying tokens, he has to pay a borrowing interest (line 350 in `Ladle`), which is his debt multiplied by the rate accrual (line 373). 3. Now, the user wants to avoid paying the borrowing interest. He gives his vault to `Witch` by calling the function `batch` of `Ladle` with the operation `GIVE`. 4. He then calls the function `buy` of `Witch` with the corresponding `vaultId` to buy all his collateral using underlying tokens.  In the last step, the `elapsed` time (line 61) is equal to the current timestamp since the vault is never grabbed by `Witch` before, and thus the auction time of the vault, `cauldron.auctions(vaultId)`, is 0 (the default mapping value). Therefore, the collateral is sold at a price of `balances_.art/balances_.ink` (line 74). The user can buy `balances_.ink` amount of collateral using `balances_.art` but not paying for borrowing fees.  Referenced code: [Ladle.sol#L350](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L350) [Ladle.sol#L368-L377](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L368-L377) [Ladle.sol#L267-L272](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L267-L272) [Cauldron.sol#L234-L252](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L234-L252) [Witch.sol#L61](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L61) [Witch.sol#L74](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L74)  ## Recommended Mitigation Steps  Do not allow users to `give` vaults to `Witch`. To be more careful, require `vaultOwners[vaultId]` and `cauldron.auctions(vaultId)` to be non-zero at the beginning of function `buy`.  
# Handle  shw   # Vulnerability details  ## Impact  It is possible for an attacker to intendedly create a fake `Join` corresponding to a specific token beforehand to make `Wand` unable to deploy the actual `Join`, causing a DoS attack.  ## Proof of Concept  The address of `Join` corresponding to an underlying `asset` is determined as follows and thus unique:  ```solidity Join join = new Join{salt: keccak256(abi.encodePacked(asset))}(); ```  Besides, the function `createJoin` in the contract `JoinFactory` is permissionless: Anyone can create the `Join` corresponding to the `asset`. An attacker could then deploy a large number of `Joins` with different common underlying assets (e.g., DAI, USDC, ETH) before the `Wand` deploying them. The attempt of deploying these `Joins` by `Wand` would fail since the attacker had occupied the desired addresses with fake `Joins`, resulting in a DoS attack.  Moreover, the attacker can also perform DoS attacks on newly added assets: He monitors the mempool to find transactions calling the function `addAsset` of `Wand` and front-runs them to create the corresponding `Join` to make the benign transaction fail.  Referenced code: [JoinFactory.sol#L64-L75](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/JoinFactory.sol#L64-L75) [Wand.sol#L53](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Wand.sol#L53)  ## Recommended Mitigation Steps  Enable access control in `createJoin` (e.g., adding the `auth` modifier) and allow `Wand` to call it.  
# Handle  shw   # Vulnerability details  ## Impact  At line 172 in the contract `FYToken`, the `unchecked` keyword is unnecessary since no arithmetic operation is involved.  ## Proof of Concept  Referenced code: [FYToken.sol#L172](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L172)  ## Recommended Mitigation Steps  Consider removing the `unchecked` keyword.  
# Handle  a_delamo   # Vulnerability details  ## Impact  In the Pool.sol contract there is the following code:  ``` function _update(         uint128 baseBalance,         uint128 fyBalance,         uint112 _baseCached,         uint112 _fyTokenCached     ) private {         ....              cumulativeBalancesRatio +=                 (scaledFYTokenCached / _baseCached) *                 timeElapsed;         ....     } ```  The multiplication should be always placed at the end to avoid miscalculations like the following one:  ```   a = (b/d)*c   0 = (5/10)*2      a = (b * c)/ 2   1 = (5 * 2)/10  ```      
# Handle  a_delamo   # Vulnerability details  ## Impact The following methods could be external instead of public  ``` level(bytes12) should be declared external:         - Cauldron.level(bytes12) (contracts/Cauldron.sol#513-521) mature(bytes6) should be declared external:         - Cauldron.mature(bytes6) (contracts/Cauldron.sol#524-532) accrual(bytes6) should be declared external:         - Cauldron.accrual(bytes6) (contracts/Cauldron.sol#546-553) setFlashFeeFactor(uint256) should be declared external:         - Join.setFlashFeeFactor(uint256) (contracts/Join.sol#33-36) maxFlashLoan(address) should be declared external:         - Join.maxFlashLoan(address) (contracts/Join.sol#90-97) flashFee(address,uint256) should be declared external:         - Join.flashFee(address,uint256) (contracts/Join.sol#105-113) flashLoan(IERC3156FlashBorrower,address,uint256,bytes) should be declared external:         - Join.flashLoan(IERC3156FlashBorrower,address,uint256,bytes) (contracts/Join.sol#132-151) setFee(uint256) should be declared external:         - Ladle.setFee(uint256) (contracts/Ladle.sol#102-105) addAsset(bytes6,address) should be declared external:         - Wand.addAsset(bytes6,address) (contracts/Wand.sol#49-61) makeBase(bytes6,IMultiOracleGov,address,address) should be declared external:         - Wand.makeBase(bytes6,IMultiOracleGov,address,address) (contracts/Wand.sol#65-78) makeIlk(bytes6,bytes6,IMultiOracleGov,address,uint32,uint96,uint24,uint8) should be declared external:         - Wand.makeIlk(bytes6,bytes6,IMultiOracleGov,address,uint32,uint96,uint24,uint8) (contracts/Wand.sol#81-94) addSeries(bytes6,bytes6,uint32,bytes6[],string,string) should be declared external:         - Wand.addSeries(bytes6,bytes6,uint32,bytes6[],string,string) (contracts/Wand.sol#98-154) setAuctionTime(uint128) should be declared external:         - Witch.setAuctionTime(uint128) (contracts/Witch.sol#41-44) setInitialProportion(uint128) should be declared external:         - Witch.setInitialProportion(uint128) (contracts/Witch.sol#47-51) grab(bytes12) should be declared external:         - Witch.grab(bytes12) (contracts/Witch.sol#54-59) buy(bytes12,uint128,uint128) should be declared external:         - Witch.buy(bytes12,uint128,uint128) (contracts/Witch.sol#62-99) mint(address,uint256) should be declared external:         - DAIMock.mint(address,uint256) (contracts/mocks/DAIMock.sol#36-38) mint(address,uint256) should be declared external:         - ERC20Mock.mint(address,uint256) (contracts/mocks/ERC20Mock.sol#11-13) mint(address,uint256) should be declared external:         - RestrictedERC20Mock.mint(address,uint256) (contracts/mocks/RestrictedERC20Mock.sol#12-14) burn(address,uint256) should be declared external:         - RestrictedERC20Mock.burn(address,uint256) (contracts/mocks/RestrictedERC20Mock.sol#17-19) pull(address,uint256) should be declared external:         - GemJoinMock.pull(address,uint256) (contracts/mocks/TLMMock.sol#14-16) mint(address,uint256) should be declared external:         - USDCMock.mint(address,uint256) (contracts/mocks/USDCMock.sol#13-15) withdraw(uint256) should be declared external:         - WETH9Mock.withdraw(uint256) (contracts/mocks/WETH9Mock.sol#21-26) totalSupply() should be declared external:         - WETH9Mock.totalSupply() (contracts/mocks/WETH9Mock.sol#28-30) latestRoundData() should be declared external:         - ChainlinkAggregatorV3Mock.latestRoundData() (contracts/mocks/oracles/chainlink/ChainlinkAggregatorV3Mock.sol#22-34) exchangeRateCurrent() should be declared external:         - CTokenChiMock.exchangeRateCurrent() (contracts/mocks/oracles/compound/CTokenChiMock.sol#12-14) tickSpacing() should be declared external:         - UniswapV3PoolMock.tickSpacing() (contracts/mocks/oracles/uniswap/UniswapV3PoolMock.sol#27-29) maxLiquidityPerTick() should be declared external:         - UniswapV3PoolMock.maxLiquidityPerTick() (contracts/mocks/oracles/uniswap/UniswapV3PoolMock.sol#31-33) setSources(bytes6[],bytes6[],address[]) should be declared external:         - ChainlinkMultiOracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#56-68) peek(bytes32,bytes32,uint256) should be declared external:         - ChainlinkMultiOracle.peek(bytes32,bytes32,uint256) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#105-113)         - CompoundMultiOracle.peek(bytes32,bytes32,uint256) (contracts/oracles/compound/CompoundMultiOracle.sol#78-86)         - UniswapV3Oracle.peek(bytes32,bytes32,uint256) (contracts/oracles/uniswap/UniswapV3Oracle.sol#126-132) get(bytes32,bytes32,uint256) should be declared external:         - ChainlinkMultiOracle.get(bytes32,bytes32,uint256) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#119-127)         - CompoundMultiOracle.get(bytes32,bytes32,uint256) (contracts/oracles/compound/CompoundMultiOracle.sol#92-100)         - UniswapV3Oracle.get(bytes32,bytes32,uint256) (contracts/oracles/uniswap/UniswapV3Oracle.sol#138-144) setSources(bytes6[],bytes6[],address[]) should be declared external:         - CompoundMultiOracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/compound/CompoundMultiOracle.sol#37-48) setSecondsAgo(uint32) should be declared external:         - UniswapV3Oracle.setSecondsAgo(uint32) (contracts/oracles/uniswap/UniswapV3Oracle.sol#44-48) setSources(bytes6[],bytes6[],address[]) should be declared external:         - UniswapV3Oracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/uniswap/UniswapV3Oracle.sol#73-85) transferOwnership(address) should be declared external:         - Ownable.transferOwnership(address) (contracts/utils/access/Ownable.sol#25-28) tokenSymbol(address) should be declared external:         - SafeERC20Namer.tokenSymbol(address) (contracts/utils/token/SafeERC20Namer.sol#87-95) tokenName(address) should be declared external:         - SafeERC20Namer.tokenName(address) (contracts/utils/token/SafeERC20Namer.sol#98-106) setParameter(bytes32,int128) should be declared external:         - Pool.setParameter(bytes32,int128) (contracts/yieldspace/Pool.sol#135-141) getK() should be declared external:         - Pool.getK() (contracts/yieldspace/Pool.sol#144-147) getG1() should be declared external:         - Pool.getG1() (contracts/yieldspace/Pool.sol#150-152) getG2() should be declared external:         - Pool.getG2() (contracts/yieldspace/Pool.sol#155-157) getCache() should be declared external:         - Pool.getCache() (contracts/yieldspace/Pool.sol#175-185) fyTokenOutForBaseIn(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.fyTokenOutForBaseIn(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#657-694) baseOutForFYTokenIn(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.baseOutForFYTokenIn(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#707-744) fyTokenInForBaseOut(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.fyTokenInForBaseOut(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#757-797) baseInForFYTokenOut(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.baseInForFYTokenOut(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#811-848) ```  Here more information about the gas optimizations of external vs public: https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tools Used  Slither   
# Handle  pauliax   # Vulnerability details  ## Impact It would be helpful if function build explicitly check that seriesId != bytes12(0). In practice, it is not possible to have a series with an id of 0, so this check will not pass:     require (ilks[seriesId][ilkId] == true, "Ilk not added to series"); however, the error message is not very informative, thus I am suggesting adding an explicit check.  ## Recommended Mitigation Steps require (seriesId != bytes12(0), "Series id is zero");  
# Handle  pauliax   # Vulnerability details  ## Impact function redeem in contract FYToken should return 'redeemed' amount. There return value is not used anywhere, but it's a mistake that it assigns 'redeemed' but returns 'amount'.  ## Recommended Mitigation Steps Remove return sentence or explicitly return 'redeemed'.  
# Handle  pauliax   # Vulnerability details  ## Impact external function transferToPool is pretty useless and error-prone. It relies on the user not to leave these tokens in a separate tx, otherwise, it will just be feeding the bots. To use it directly users will have to write their own custom smart contract and chain actions.  ## Recommended Mitigation Steps It would be better to remove this function and leave the only way to invoke it via a batch function.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function batch of Ladle.sol, at the operation GIVE, the value of vault is stored and is deleted directly afterwards. So storing is unnecessary. Maybe the solidity compiler already optimizes this.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L228   function batch( } else if (operation == Operation.GIVE) {                ...                  vault = _give(vaultId, to);                 delete vault;   // Clear the cache, since the vault doesn't necessarily belong to msg.sender anymore              ## Tools Used  ## Recommended Mitigation Steps Remove the " vault = "   
# Handle  0xRajeev   # Vulnerability details  ## Impact  Project uses multiple compiler versions with most specifying ^0.8.0, some specifying >=0.8.0 which allows breaking versions >= 0.9.0 in future if reused/redeployed, and some even allowing much older >= 0.5.0/0.6.0.   The dangers of allowing multiple compilers across breaking revisions is that the security bug fixes and features might be different across different contracts introducing vulnerabilities or giving a false sense of security.  For example, most contract use ^0.8.0 which means they have default checked arithmetic to prevent overflows/underflows without using OZ SafeMath. This doesn’t apply to the few (inherited) contracts that may be compiled with <0.8.0 and have unchecked overflows/underflows.   ## Proof of Concept  ^0.8.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L2  >= 0.8.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/yieldspace/YieldMath.sol#L2  >= 0.5.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/token/SafeERC20Namer.sol#L3  >= 0.6.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/token/TransferHelper.sol#L4  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. Update all contracts to use pragma solidity ^0.8.0 or better a fixed version like 0.8.4 2. Deploy with the same compiler version which was used for testing  
# Handle  0xRajeev   # Vulnerability details  ## Impact  flashFeeFactor is uninitialized at declaration and so zero initially until set by setFlashFeeFactor(). As indicated in one of the the explainer videos, the idea is to set this by default to uint256.max to disable flash loans by default.  Currently, flash loans are enabled by default with a zero flash fee unless changed by setFlashFeeFactor().  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L26  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L32-L39  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L107-L110  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L117-L119  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L132   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Initialize at declaration with a reasonable value which could be uint256.max to disable flash loans by default.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The LOCK role is special in AccessControl because it has itself as the admin role (like ROOT) but no members. This means that calling setRoleAdmin(msg.sig, LOCK) means no one can grant/revoke that msg.sig role anymore and it gets locked irreversibly. This means it disables admin-based permissioning management of that role and therefore is very powerful in its impact.  Given this, there is a special function lockRole() which is specifically meant to enforce LOCK as the admin for the specified role parameter. For all other role admin creations, the generic setRoleAdmin() may be used. However, setRoleAdmin() does not itself prevent specifying the use of LOCK as the admin. If this is accidentally used then it leads to disabling that role’s admin management irreversibly similar to the lockRole() function.  It is safer to force admins to use lockRole() as the only way to set admin to LOCK and prevent the use of LOCK as the adminRole parameter in setRoleAdmin(), because doing so will make the intention of the caller clearer as lockRole() clearly has that functionality specified in its name and that’s the only thing it does.   ## Proof of Concept  Alice who is the admin for foo() wants to give the admin rights to Bob (0xFFFFFFF0) but instead of calling setRoleAdmin(foo.sig, 0xFFFFFFF0), she calls setRoleAdmin(foo.sig, 0xFFFFFFFF) where 0xFFFFFFFF is LOCK. This makes LOCK as the admin for foo() and prevents any further admin-based access control management for foo().  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L48  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L129-L131  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L235-L240  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L165-L176  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Prevent the use of LOCK as the adminRole parameter in setRoleAdmin().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Add an address check in receive() of Ladle.sol to ensure the only address sending ETH being received in receive() is the Weth9 contract (similar to the check in PoolRouter.sol) for Ether withdrawal in _exitEther().  This will prevent stray Ether from being sent accidentally to this contract and getting locked.  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L521-L522  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/yieldspace/PoolRouter.sol#L145-L148   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add an address check in receive() of Ladle.sol to ensure only Weth9 contract can send Ether to this contract.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Many batched operation functions return values but these are ignored by the caller batch(). While this may be acceptable for the front-end which picks up any state changes from such functions via emitted events, integrating protocols that make a call to batch() may require it to package and send back return values of all operations from the batch to react on-chain to the success/failure or other return values from such calls. Otherwise, they will be in the dark on the success/impact of batched operations they’ve triggered.  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L120-L245  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L250  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L258  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L284-L286  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L296-L298  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L326-L328  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L342-L344  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L382-L384  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L396-L398  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L410-L412  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L446-L448  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L462-L464  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L527-L529  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L539-L541  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L559-L561  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L588-L590  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Package and send back return values of all batched operations’ functions to the caller of batch().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The grab() function in Cauldron is used by the Witch or other liquidation engines to grab vaults that are under-collateralized. To prevent re-grabbing without sufficient time for auctioning collateral/debt, the logic uses an auctionInterval threshold to give a reasonable window to a liquidation engine that has grabbed the vault.  The grab() function has a comment on Line 354: “// Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.” indicating a requirement of the auctionInterval being equal to one day. This can happen only if the auctionInterval is set appropriately. However, this state variable is uninitialized (defaults to 0) and depends on setAuctionInterval() being called with the appropriate auctionInterval_ value which is also not validated.  Discussion with the project lead indicated that this comment is incorrect. Nevertheless, it is safer to initialize auctionInterval at declaration to a safe default value instead of the current 0 which will allow liquidation engines to re-grab vaults without making any progress on liquidation auction. It is also good to add a threshold check in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value.  Rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because liquidation engines will keep re-grabbing vaults from each other and potentially result in liquidation bots entering a live-lock situation without making any progress on liquidation auctions. This will result in collateral being stuck and impact entire protocol’s functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.   ## Proof of Concept  Configuration recipe forgets to set the auctionInterval state variable by calling setAuctionInterval() and inadvertently leaves it at the default value of 0. Alternatively, it calls it but with a lower than intended/reasonable auction interval value. Both scenarios fail to give sufficient protection to liquidation engines from having their grabbed vaults re-grabbed without sufficient time for liquidation auctions.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L63  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L108-L115  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L354   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. Initialize auctionInterval  at declaration with a reasonable default value. 2. Add a threshold check in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The vaultID for a new vault being built is required to be specified by the user building a vault via the build() function (instead of being assigned by the Cauldron/protocol). An attacker can observe a build() as part of a batch transaction in the mempool, identify the vaultID being requested and front-run that by constructing a malicious batch transaction with only the build operation with that same vaultID. The protocol would create a vault with that vaultID and assign attacker as its owner. More importantly, the valid batch transaction in the mempool which was front-run will later fail to create its vault because that vaultID already exists, as per the check on Line180 of Cauldron.sol. As a result, the valid batch transaction fails entirely because of the attacker front-running with the observed vaultID.  While the attacker gains nothing except the ownership of an empty vault after spending the gas, this could grief the protocol’s real users by preventing them from opening a vault and interacting with the protocol in any manner.  Rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because valid vaults from the Yield front-end will never be successfully created and will lead to a DoS against the entire protocol’s functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.  ## Proof of Concept  Alice uses Yield’s front-end to create a valid batch transaction. Evil Eve observes that in the mempool and identifies the vaultID of the vault being built by Alice. Eve submits her own batch transaction (without using the front-end) with only a build operation using Alice’s vaultID. She uses a higher gas price to front-run Alice’s transaction and get’s the protocol to assign that vaultID to herself. Alice’s batch transaction later fails because the vaultID she requested is already assigned to Eve. Eve can do this for any valid transaction to grief protocol users by wasting her gas to cause DoS.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L180  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L173-L190  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L133-L135  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L249-L255   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Mitigate this DoS vector by having the Cauldron assign the vauldID instead of user specifying it in the build() operation. This would likely require the build() to be a separate non-batch transaction followed by other operations that use the vaultID assigned in build(). Consider the pros/cons of this approach because it will significantly affect the batching/caching logic in Ladle.  Alternatively, consider adding validation logic in Ladle’s batching to revert batches that have only build or a subset of the operations that do not make sense to the protocol’s operations per valid recipes, which could be an attacker’s signature pattern.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  setDebtLimits() is used to set the maximum and minimum debt for an underlying and ilk pair. The assumption is that max will be greater than min while setting them because otherwise the debt checks in _pour() for line/dust will fail and revert.  While max and min debt limits can be reset, it is safer to perform input validation on them in setDebtLimits().  ## Proof of Concept  A recipe incorrectly interchanges the values of min and max debt which leads to exceptions in pouring into the vaults.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L91-L92  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L319-L322  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Wand.sol#L79   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a check to ensure max > mix.  
# Handle  pauliax   # Vulnerability details  ## Impact In contract UniswapV3Oracle function _peek has visibility of public while the name and similar functions in other oracles are declared as private.  ## Recommended Mitigation Steps give _peek private visibility.  
# Handle  pauliax   # Vulnerability details  ## Impact function transferToPool is marked as 'payable'. It only transfers ERC20 tokens, no Ether, so there is no need in having 'payable' here.  ## Recommended Mitigation Steps Remove 'payable' modifier from function transferToPool.  
# Handle  pauliax   # Vulnerability details  ## Impact Function _burnInternal always returns 0 as a third parameter. It should return tokensBurnt, tokenOut, fyTokenOut.  ## Recommended Mitigation Steps return (tokensBurned, tokenOut, fyTokenOut);  
# Handle  cmichel   # Vulnerability details  The `FYToken.constructor` performs an external call to `IERC20Metadata(address(IJoin(join_).asset())).decimals()`. This function was optional in the initial ERC-20 and might fail for old tokens that therefore did not implement it.  ## Impact FyTokens cannot be created for tokens that implemented the old initial ERC20 without the `decimals` function.  ## Recommended Mitigation Steps Consider using the helper function in the utils to retrieve it `SafeERC20Namer.tokenDecimals`, the same way the `Pool.constructor` works.  
# Handle  cmichel   # Vulnerability details  The witch can `Witch.grab` vaults and the `vaultOwners[vaultId]` field is set to the original owner. However, when the auction time is over and the debt has not been fully paid back, the original owner is not restored, and the witch can grab the same vault again, overwriting the original owner `vaultOwners[vaultId]` field permanently with the witch.  ```solidity function grab(bytes12 vaultId) public {     DataTypes.Vault memory vault = cauldron.vaults(vaultId);     vaultOwners[vaultId] = vault.owner;     cauldron.grab(vaultId, address(this)); } ```  Even a full repayment will not restore the original vault owner anymore.  ## Impact No funds will be stuck as the vault can still be correctly liquidated (calling `settle`). However, the vault owner will not be restored which is bad if it is a valuable vaultId (low number) that has a special meaning or would be used as an NFT/for retroactive airdrops for initial liquidity providers down the road.  ## Recommended Mitigation Steps When grabbing check if `vaultOwners[vaultId]` is already the witch and in that case just do an early return of the function - not overwriting the `vaultOwners[vaultId]` field.   
# Handle  cmichel   # Vulnerability details  `Ladle._close` (and many other occurrences) reverts the transaction on certain signed inputs that are negated and cast to unsigned integers.  ```solidity // Ladle._close calling it with art or ink as type(int128).min will crash uint128 amt = _debtInBase(vault.seriesId, series, uint128(-art)); ilkJoin.exit(to, uint128(-ink))  // explanation int128 art = type(int128).min; // -2^127 uint128 amt = uint128(-art); // this fails as -art=--2^127=2^127 cannot be represented in int128 ```  Other places: - `CauldronMath.add` - `Ladle._pour` - everywhere where `-int*` is used  ## Impact One cannot use the actual `type(int128).min` value for function parameters.  ## Recommended Mitigation Steps Revert with a meaningful error message as is done in the `/math/Cast*` functions.   
# Handle  pauliax   # Vulnerability details  ## Impact enum TokenType in library PoolDataTypes is not used anywhere.  ## Recommended Mitigation Steps Either remove it or use it where intended.  
# Handle  pauliax   # Vulnerability details  ## Impact function setSources in Oracle contracts does not need 'auth' modifier as it will be checked anyway in function setSource. This does not impact the security, it is just a useless check that can be removed.  ## Recommended Mitigation Steps Remove 'auth' modifer from function setSources.  
# Handle  pauliax   # Vulnerability details  ## Impact In the contract ChainlinkMultiOracle both functions 'peek' and 'get' are identical. They are declared as views while based on IOracle interface 'get' should be transactional.   
# Handle  0xsomeone   # Vulnerability details  ## Impact  It is possible to duplicate currently held `ink` or `art` within a Cauldron, thereby breaking the contract's accounting system minting units out of thin air.  ## Proof of Concept  The `stir` function of the `Cauldron`, which can be invoked via a `Ladle` operation, caches balances in memory before decrementing and incrementing. As a result, if a transfer to self is performed, the assignment `balances[to] = balancesTo` will contain the added-to balance instead of the neutral balance.  This allows one to duplicate any number of `ink` or `art` units at will, thereby severely affecting the protocol's integrity. A similar attack was exploited in the third bZx hack resulting in a roughly 8 million loss.  Code Referenced: https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L268-L295  ## Tools Used  Manual Review.  ## Recommended Mitigation Steps  A `require` check should be imposed that prohibits the `from` and `to` variables to be equivalent.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function getRevertMsg of RevertMsgExtractor.sol uses assembly to retrieve revert information. The latest solidity version have new functions that allows you to retrieve information without assembly.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/utils/RevertMsgExtractor.sol function getRevertMsg(bytes memory returnData) internal pure returns (string memory) { ..        assembly {             // Slice the sighash.             returnData := add(returnData, 0x04)         }   ## Tools Used  ## Recommended Mitigation Steps Below is a piece of code showing the new functionality:  pragma solidity ^0.8.1;  contract ContractError {     function Underflow() public pure returns (uint) {          uint x = 0;          x--; // this will generate an underflow          return x;     }     function UncheckedUnderflow() public pure returns (uint) {          uint x = 0;          unchecked { x--; } // this will generate an underflow          return x;     }  }  contract C {     ContractError e = new ContractError();          function TestUnderflow() public view returns (string memory) {          try e.Underflow() returns (uint) {             return "Ok";         } catch Error(string memory reason) {             return reason;         } catch Panic(uint _code) {             if (_code == 0x01) { return "Assertion failed"; }             else if (_code == 0x11) { return "Underflow/overflow"; }             // We ignore the other errors.             return "Other Panic";         } catch (bytes memory reason) {              uint x=0;             for (uint i=0;i<4;i++) //get first 4 bytes                 x = (x<<8) + uint(uint8(reason[i]));                      if (x == 0x08c379a0) // abi.encodeWithSignature("Error(string)")                 return "Error";             return "Unknown";         }     } }   
# Handle  gpersoon   # Vulnerability details  ## Impact PoolFactory and JoinFactory contain very similar but also relatively complicated code. // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/yieldspace/PoolFactory.sol // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/JoinFactory.sol  The risk is that future changes/improvements in one contract might not be updated in the other.  ## Proof of Concept  ## Tools Used Editor  ## Recommended Mitigation Steps Consider refactoring the code where the core code is put in a library and reused from both of the contracts.   
# Handle  gpersoon   # Vulnerability details  ## Impact Several implementations of the value of "chi" and "rate" are used, sometimes as constant and sometimes the direct value is used, see proof of concept below. The risk is that if it is changed in one place if might not be changed in another place, leading to bugs.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Wand.sol#L26 bytes6 public constant CHI = "chi"; bytes6 public constant RATE = "rate";  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L27 bytes32 constant CHI = "chi";  //https://github.com/code-423n4/2021-05-yield/blob/main/contracts/oracles/compound/CompoundMultiOracle.sol#L40     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {       ...         if (kind == "rate") rawPrice = CTokenInterface(source).borrowIndex();         else if (kind == "chi") rawPrice = CTokenInterface(source).exchangeRateStored();  ## Tools Used grep  ## Recommended Mitigation Steps Define the constants for "chi" and "rate" on one location and include this where required.   
# Handle  gpersoon   # Vulnerability details  ## Impact The code still has some todos, which should be resolved before production  ## Proof of Concept Ladle.sol:        weth.deposit{ value: ethTransferred }();   // TODO: Test gas savings using WETH10 `depositTo` Ladle.sol:        weth.withdraw(ethTransferred);   // TODO: Test gas savings using WETH10 `withdrawTo` Wand.sol:        cauldron.setRateOracle(assetId, IOracle(address(oracle))); // TODO: Consider adding a registry of chi oracles in cauldron as well Wand.sol:        ); // TODO: Use a FYTokenFactory to make Wand deployable at 20000 runs Wand.sol:            name,     // Derive from base and maturity, perhaps Wand.sol:            symbol    // Derive from base and maturity, perhaps  ## Tools Used Grep  ## Recommended Mitigation Steps Check and fix or remove the todos   
# Handle  gpersoon   # Vulnerability details  ## Impact The witch.sol contract gets access to a vault via the grab function, in case of liquidation. If the witch.sol contract can't sell the debt within a certain amount of time, a second grab can occur.  After the second grab, the information of the original owner of the vault is lost and the vault can't be returned to the original owner once the debt has been sold.  The grab function stores the previous owner in vaultOwners[vaultId] and then the contract itself is the new owner (via cauldron.grab and cauldron._give). The vaultOwners[vaultId] is overwritten at the second grab  The function buy of Witch.sol tried to give the vault back to the original owner, which won't succeed after a second grab.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L50     function grab(bytes12 vaultId) public {         DataTypes.Vault memory vault = cauldron.vaults(vaultId);         vaultOwners[vaultId] = vault.owner;         cauldron.grab(vaultId, address(this));     }  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L349     function grab(bytes12 vaultId, address receiver)  external  auth   {      ...         _give(vaultId, receiver);       // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L349  function _give(bytes12 vaultId, address receiver) internal returns(DataTypes.Vault memory vault)  {     ...         vault.owner = receiver;         vaults[vaultId] = vault;  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L57  function buy(bytes12 vaultId, uint128 art, uint128 min) public {      ....             cauldron.give(vaultId, vaultOwners[vaultId]);  ## Tools Used Editor  ## Recommended Mitigation Steps Assuming it's useful to give back to vault to the original owner: Make a stack/array of previous owners if multiple instances of the witch.sol contract would be used. Or check if the witch is already the owner (in the grab function) and keep the vaultOwners[vaultId] if that is the case  
# Handle  gpersoon   # Vulnerability details  ## Impact The auth modifier of AccessControl.sol doesn't work as you would expect.  It checks if you are authorized for "msg.sig", however msg.sig is the signature of the first function you have called, not of the current function. So if you call function A, which calls function B, the "auth" modifier of function B checks if you are authorized for function A!  There is a difference between external an public functions. For external functions this works as expected because a fresh call (with a new msg.sig) is always made. However with a public functions, which are called from within the same contract, this doesn't happen and the problem described above occurs. See in the proof of concept for a piece of code which shows the problem. In the code there are several functions which have public and auth combined, see also in the proof of concept .  In the current codebase I couldn't find a problem situation, however this could be accidentally introduced with future changes. If could also be introduced via the _moduleCall of Ladle.sol, which allows functions to be defined which might call the public functions.  ## Proof of Concept ### auth // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/utils/access/AccessControl.sol#L90 modifier auth() {         require (_hasRole(msg.sig, msg.sender), "Access denied");         _;     }  ### example pragma solidity ^0.8.0; contract TestMsgSig {      event log(bytes4);      function setFeePublic(uint256) public  {          emit log(this.setFeePublic.selector);          emit log(msg.sig);     }     function setFeeExternal(uint256) external  {          emit log(this.setFeeExternal.selector);          emit log(msg.sig);     }      function TestPublic() public {         setFeePublic(2);     }      function TestExternal() public {        this.setFeeExternal(2);     } } ### occurrences of public auth Wand.sol:   function addAsset(bytes6 assetId,address asset) public auth { Wand.sol:    function makeBase(bytes6 assetId, IMultiOracleGov oracle, address rateSource, address chiSource) public auth { Wand.sol:    function makeIlk(bytes6 baseId, bytes6 ilkId, IMultiOracleGov oracle, address spotSource, uint32 ratio, uint96 max, uint24 min, uint8 dec) public auth { Wand.sol:     function addSeries(...  ) public auth { Witch.sol:    function setAuctionTime(uint128 auctionTime_) public auth { Witch.sol:    function setInitialProportion(uint128 initialProportion_) public auth {  Ladle.sol:     function setFee(uint256 fee)         public        auth      Join.sol:    function setFlashFeeFactor(uint256 flashFeeFactor_) public   auth     {  oracles\chainlink\ChainlinkMultiOracle.sol:    function setSource(bytes6 base, bytes6 quote, address source) public auth { oracles\chainlink\ChainlinkMultiOracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth { oracles\compound\CompoundMultiOracle.sol:    function setSource(bytes6 base, bytes6 kind, address source) public auth { oracles\compound\CompoundMultiOracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory kinds, address[] memory sources_) public auth { oracles\uniswap\UniswapV3Oracle.sol:    function setSecondsAgo(uint32 secondsAgo_) public auth { oracles\uniswap\UniswapV3Oracle.sol:    function setSource(bytes6 base, bytes6 quote, address source) public auth { oracles\uniswap\UniswapV3Oracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth { fytoken.sol:  function setOracle(IOracle oracle_)  public  auth     {   ## Tools Used grep  ## Recommended Mitigation Steps make sure all auth functions use external  (still error prone) or change the modifier to something like:     modifier auth(bytes4 fs) {         require (msg.sig == fs,"Wrong selector");         require (_hasRole(msg.sig, msg.sender), "Access denied");         _;     }      function setFee(uint256) public auth(this.setFee.selector) {        .....     }    
# Handle  gpersoon   # Vulnerability details  ## Impact In several locations in the code numbers like 1e12, 1e18, 1e27 are used. The same goes for values like: type(uint256).max It quite easy to make a mistake somewhere, also when comparing values.  ## Proof of Concept .\Cauldron.sol:        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32("rate"), 1e18); .\Cauldron.sol:            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32("rate"), 1e18); .\Cauldron.sol:        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals) .\Cauldron.sol:        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals .\FYToken.sol:        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18); .\FYToken.sol:            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18); .\FYToken.sol:        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals) .\Witch.sol:        require (initialProportion_ <= 1e18, "Only at or under 100%"); .\Witch.sol:            uint256 term2 = initialProportion_ + (1e18 - initialProportion_).wmul(dividend2.wdiv(divisor2)); .\Witch.sol:            price = uint256(1e18).wdiv(term1.wmul(term2)); .\oracles\chainlink\ChainlinkMultiOracle.sol:        value = price * amount / 1e18; .\oracles\chainlink\ChainlinkMultiOracle.sol:        value = price * amount / 1e18; .\oracles\compound\CompoundMultiOracle.sol:        value = price * amount / 1e18; .\oracles\compound\CompoundMultiOracle.sol:        value = price * amount / 1e18; .\yieldspace\Pool.sol:            uint256 scaledFYTokenCached = uint256(_fyTokenCached) * 1e27; .\yieldspace\YieldMath.sol:      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero .\yieldspace\YieldMath.sol:      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero .\yieldspace\YieldMath.sol:      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max .\yieldspace\YieldMath.sol:      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max  .\FYToken.sol:    uint256 public chiAtMaturity = type(uint256).max;           // Spot price (exchange rate) between the base and an interest accruing token at maturity .\FYToken.sol:        require (chiAtMaturity == type(uint256).max, "Already matured"); .\FYToken.sol:        if (chiAtMaturity == type(uint256).max) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.    ## Tools Used grep  ## Recommended Mitigation Steps Define constants for the numbers used throughout the code.   
# Handle  gpersoon   # Vulnerability details  ## Impact The V1 version of YieldMath.sol contains ">=" (larger or equal), while the V2 version of YieldMath.sol containt ">" (larger) in the log_2 function. This change doesn't seem logical and might lead to miss calculations. The difference is present in a number of adjacent lines.  ## Proof of Concept // https://github.com/yieldprotocol/yieldspace-v1/blob/master/contracts/YieldMath.sol#L217 function log_2 (uint128 x) ... b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}   //https://github.com/code-423n4/2021-05-yield/blob/main/contracts/yieldspace/YieldMath.sol#L58 function log_2(uint128 x) ... b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}  ## Tools Used diff  ## Recommended Mitigation Steps Check which version is the correct version and fix the incorrect version.    
