# Handle  shw   # Vulnerability details  ## Impact  The function `foreclosureTimeUser` of `RCTreasury` underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card.  ## Proof of Concept  The variable `timeLeftOfDeposit` at line 668 is calculated based on `depositAbleToWithdraw(_user)`, the user's deposit minus the rent from the last rent calculation to the current time. Thus, the variable `timeLeftOfDeposit` indicates the time left of deposit, starting from now. However, at line 672, the `foreclosureTimeWithoutNewCard` is calculated by `timeLeftOfDeposit` plus the user's last rent calculation time instead of the current time. As a result, the user's foreclosure time is reduced. From another perspective, the rent between the last rent calculation time and the current time is counted twice.  Referenced code: [RCTreasury.sol#L642-L653](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L642-L653) [RCTreasury.sol#L669](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L669) [RCTreasury.sol#L672](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L672) [RCTreasury.sol#L678](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L678) [RCOrderbook.sol#L553-L557](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L553-L557)  ## Recommended Mitigation Steps  Change `depositAbleToWithdraw(_user)` at line 669 to `user[_user].deposit`. Or, change `user[_user].lastRentCalc` at both line 672 and 678 to `block.timestamp`.  
# Handle  shw   # Vulnerability details  ## Impact  The variable `domainSeperator` in `EIP712Base` is cached in the contract storage and will not change after the contract is initialized. However, if a hard fork happens after the contract deployment, the `domainSeperator` would become invalid on one of the forked chains due to the `block.chainid` has changed.  ## Proof of Concept  Referenced code: [EIP712Base.sol#L25-L44](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/lib/EIP712Base.sol#L25-L44)  ## Recommended Mitigation Steps  Consider using the [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/draft-EIP712.sol) from OpenZeppelin, which recalculates the domain separator if the current `block.chainid` is not the cached chain ID.  
# Handle  a_delamo   # Vulnerability details  On `RCFactory` is using uint to represent the enum Mode while on RCMarket is using the enum directly.  It would make the code much readable if RCFactory would use Mode directly.   
# Handle  a_delamo   # Vulnerability details  ## Impact  `RCMarket` contains the constant variable `isMarket` to indicate it is a Market `bool public constant override isMarket = true;`. This is after used in `RCFactory` ``` function changeMarketApproval(address _market) external onlyGovernors {         require(_market != address(0));         // check it's an RC contract         IRCMarket _marketToApprove = IRCMarket(_market);         assert(_marketToApprove.isMarket());         isMarketApproved[_market] = !isMarketApproved[_market];         emit LogMarketApproved(_market, isMarketApproved[_market]);     } ```  Why not use `mappingOfMarkets` to verify the address is a Market? This would reduce the state space used.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `RCNftHubL2.safeTransferFrom` function does not correctly implement the ERC721 spec:  > When using safeTransferFrom, the token contract checks to see that the receiver is an IERC721Receiver, which implies that it knows how to handle ERC721 tokens. [ERC721](https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#IERC721-safeTransferFrom)  This check is not implemented, it just drops the `_data` argument.  ## Impact  Contracts that don't know how to handle ERC721 tokens (are not an `IERC721Receiver`) can accept them but they should not when using `safeTransferFrom` according to spec.  ## Recommended Mitigation Steps  Implement the `IERC721Receiver` check in `safeTransferFrom`.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  Usually one tries to avoid toggle functions in blockchains, because it could be that you think that the first transaction you sent was not correctly submitted (but it's just pending for a long time), or you might even be unaware that it was already sent if multiple roles can set it (like with `changeMarketApproval` / `onlyGovernors`) or if it's an msig. This results in potentially double-toggling the state, i.e, it is set to the initial value again.  Some example functions: `changeMarketCreationGovernorsOnly`, `changeMarketApproval`, and the ones that follow.  ## Impact  The outcome of toggle functions is hard to predict on blockchains due to the very async nature and lack of information about pending transactions.  ## Recommended Mitigation Steps  Use functions that accept a specific value as a parameter instead.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `uberOwner` cannot do the same things the owner can. They can "only" set the reference contract for the market.  The same ideas apply to `Treasury` and `Factory`'s `uberOwner`.  ## Impact  The name is misleading as it sounds like the uber-owner is more powerful than the owner.  ## Recommended Mitigation Steps  Uberowner should at least be able to set the owner if not be allowed to call all functions that an `owner` can. Alternatively, rename the `uberOwner`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `Factory.createMarket` iterates over all `_cardAffiliateAddresses`.  ## Impact  The transactions can fail if the arrays get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.   ## Recommended Mitigation Steps  Perform a `_cardAffiliateAddresses.length == 0 || _cardAffiliateAddresses.length == tokenUris.length` check in `createMarket` instead of silently skipping card affiliate cuts in `Market.initialize`. This would restrict the `_cardAffiliateAddresses` length to the `nftMintingLimit` as well.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The treasury only checks its `globalPause` field but does not check its market-specific `marketPaused` field for `Treasury.sponsor`. A paused market contract can therefore still deposit as a sponsor using `Market.sponsor`  ## Impact  The market-specific pause does not work correctly.  ## Recommended Mitigation Steps  Add checks for `marketPaused` in the Treasury for `sponsor`.   
# Handle  a_delamo   # Vulnerability details  ## Impact On `RCOrderbook`, there are duplicated the state variable `treasuryAddress` and `treasury`  ```     address public treasuryAddress;     IRCTreasury public treasury; ``` ```     constructor(address _factoryAddress, address _treasuryAddress) {         factoryAddress = _factoryAddress;         treasuryAddress = _treasuryAddress;         treasury = IRCTreasury(treasuryAddress);         uberOwner = msgSender();     }  ```  
# Handle  pauliax   # Vulnerability details  ## Impact I can't find a reason why totalNftMintCount in Factory can't be replaced with ERC721 totalSupply() to make it less error-prone. As nfthub.mint issues a new token it should automatically increment totalSupply and this assignment won't be needed:       totalNftMintCount = totalNftMintCount + _tokenURIs.length; Also in function setNftHubAddress you need to manually set _newNftMintCount if you want to change nfthub so an invalid value may crash the system. totalSupply() will eliminate totalNftMintCount and make the system more robust.  ## Recommended Mitigation Steps Replace totalNftMintCount with nfthub totalSupply() in Factory contract.  
# Handle  maplesyrup   # Vulnerability details  ## Impact 1 - Low Risk    - Possible incorrect use of variables are at stake which may have bad side effects to the contract if implemented incorrectly.  ## Proof of Concept  According to the Slither-analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing), shadowing local variables is naming conventions found in two or more variables that are similar. Although they do not pose any immediate risk to the contract, incorrect usage of the variables is possible and can cause serious issues if the developer does not pay close attention.   It is recommended that the naming of the following variables should be changed slightly to avoid any confusion:   -------------------------------------------------------------------  RCOrderbook._updateBidInOrderbook(address,address,uint256,uint256,uint256,RCOrderbook.Bid)._owner   (contracts/RCOrderbook.sol line(s)#358) shadows:  Ownable._owner <------(state variable)  (node_modules/@openzeppelin/contracts/access/Ownable.sol line(s)#19)    -------------------------------------------------------------------  RCOrderbook.closeMarket()._owner   (contracts/RCOrderbook.sol line(s)#639) shadows:  Ownable._owner <------(state variable)  (node_modules/@openzeppelin/contracts/access/Ownable.sol line(s)#19)   -------------------------------------------------------------------  ## Tools Used  Solidity Compiler 0.8.4 Hardhat v2.3.3 Slither v0.8.0  Compiled, Tested, Deployed contracts on a local hardhat network.  Ran Slither-analyzer for further detecting and testing.  ## Recommended Mitigation Steps  (Worked best under python venv) 1. Clone Project Repository 2. Run Project against Hardhat network;    compile and run default test on contracts. 3. Installed slither analyzer:   https://github.com/crytic/slither 4. Ran [$ slither .] against RCOrderbook.sol and all contracts to verify results  
# Handle  pauliax   # Vulnerability details  ## Impact   _amount -= (_amount - marketBalance); is basically the same as:    _amount = marketBalance;   
# Handle  a_delamo   # Vulnerability details  ## Impact  The method `_collectRentAction` contains the following code: ``` ...            } else if (!_foreclosed && _limitHit && _marketLocked) {                 // CASE 4                 // didn't foreclose AND                 // did hit time limit AND                 // did lock market                 // THEN refund rent between the earliest event and now                 if (_cardTimeLimitTimestamp < marketLockingTime) {                     // time limit hit before market locked                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = block.timestamp - _cardTimeLimitTimestamp;                 } else {                     // market locked before time limit hit                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = block.timestamp - marketLockingTime;                 }             } else if (_foreclosed && !_limitHit && !_marketLocked) {                 // CASE 5                 // did foreclose AND                 // didn't hit time limit AND                 // didn't lock market                 // THEN rent OK, find new owner                 _timeOfThisCollection = _timeUserForeclosed;                 _newOwner = true;                 _refundTime = 0;             } else if (_foreclosed && !_limitHit && _marketLocked) {                 // CASE 6                 // did foreclose AND                 // didn't hit time limit AND                 // did lock market                 // THEN if foreclosed first rent ok, otherwise refund after locking                 if (_timeUserForeclosed < marketLockingTime) {                     // user foreclosed before market locked                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else {                     // market locked before user foreclosed                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = block.timestamp - marketLockingTime;                 }             } else if (_foreclosed && _limitHit && !_marketLocked) {                 // CASE 7                 // did foreclose AND                 // did hit time limit AND                 // didn't lock market                 // THEN if foreclosed first rent ok, otherwise refund after limit                 if (_timeUserForeclosed < _cardTimeLimitTimestamp) {                     // user foreclosed before time limit                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else {                     // time limit hit before user foreclosed                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;                 }             } else {                 // CASE 8                 // did foreclose AND                 // did hit time limit AND                 // did lock market                 // THEN (╯°益°)╯彡┻━┻                 if (                     _timeUserForeclosed <= _cardTimeLimitTimestamp &&                     _timeUserForeclosed < marketLockingTime                 ) {                     // user foreclosed first (or at same time as time limit)                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else if (                     _cardTimeLimitTimestamp < _timeUserForeclosed &&                     _cardTimeLimitTimestamp < marketLockingTime                 ) {                     // time limit hit first                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;                 } else {                     // market locked first                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = _timeUserForeclosed - marketLockingTime;                 } ... ```  On the case 6, instead of doing `_refundTime = _timeUserForeclosed - marketLockingTime;` like the following cases, is doing `_refundTime = block.timestamp - marketLockingTime;`. This could lead to funds being drained by the miscalculation.   
# Handle  a_delamo   # Vulnerability details  ## Impact  On `RCTreasury`, we have the method `collectRentUser`. This method is public, so anyone can call it using whatever user and whatever timestamp.  So, calling this method using `user = XXXXX` and `_timeToCollectTo = type(uint256).max)`, would make `isForeclosed[user] = true`.  ```     function collectRentUser(address _user, uint256 _timeToCollectTo)         public         override         returns (             uint256 newTimeLastCollectedOnForeclosure         )     {         require(!globalPause, "Global pause is enabled");         assert(_timeToCollectTo != 0);         if (user[_user].lastRentCalc < _timeToCollectTo) {             uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);              if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {                 // The User has run out of deposit already.                 uint256 previousCollectionTime = user[_user].lastRentCalc;                  /*             timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)                                   = (now - previousCollectionTime) * (usersDeposit/rentOwed)             */                 uint256 timeUsersDepositLasts =                     ((_timeToCollectTo - previousCollectionTime) *                         uint256(user[_user].deposit)) / rentOwedByUser;                 /*             Users last collection time = previousCollectionTime + timeTheirDepsitLasted             */                 rentOwedByUser = uint256(user[_user].deposit);                 newTimeLastCollectedOnForeclosure =                     previousCollectionTime +                     timeUsersDepositLasts;                 _increaseMarketBalance(rentOwedByUser, _user);                 user[_user].lastRentCalc = SafeCast.toUint64(                     newTimeLastCollectedOnForeclosure                 );                 assert(user[_user].deposit == 0);                 isForeclosed[_user] = true;                 emit LogUserForeclosed(_user, true);             } else {                 // User has enough deposit to pay rent.                 _increaseMarketBalance(rentOwedByUser, _user);                 user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);             }             emit LogAdjustDeposit(_user, rentOwedByUser, false);         }     } ```  Now, we can do the same for all the users bidding for a specific token.  Finally, I can become the owner of the token by just calling `newRental` and using a small price. `newRental` will iterate over all the previous bid and will remove them because there are foreclosed.   ## Tools Used Editor  ## Recommended Mitigation Steps  `collectRentUser` should be private and create a new public method with `onlyOrderbook` modifier  
# Handle  0xRajeev   # Vulnerability details  ## Impact  ERC721 standard and implementation allows the use of approved addresses to affect transfers besides the token owners. However, the L2 NFT Hub implementation deviates from ERC721 by ignoring the presence of any approvers in the overriding function implementations of transferFrom() and safeTransferFrom().   Impact: The system interactions with NFT platforms may not work if they expect ERC721 adherence. Users who interact via approved addresses will see their transfers failing for their approved addresses.   Given that the key value proposition of this project is the use of NFTs, the expectation will be that it is fully compatible with ERC721.   ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/nfthubs/RCNftHubL2.sol#L212-L234  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/00128bd26061986d10172573ceec914a4f3b4d3c/contracts/token/ERC721/ERC721.sol#L158   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add support for approval in NFT transfers.  
# Handle  pauliax   # Vulnerability details  ## Impact questionFinalised is redundant, it is only set to true or false but never queried or used in any meaningful way.  ## Recommended Mitigation Steps Remove questionFinalised from the codebase.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Orderbook.removeBids() as commented “///remove bids in closed markets for a given user ///this can reduce the users bidRate and chance to foreclose”  removeOldBids() is performed currently in Market.newRental() and Treasury.deposit() to  “do some cleaning up, it might help cancel their foreclosure” as commented. However, this is missing in the withdrawDeposit() function where the need is the most because user is removing deposit which may lead to foreclosure and is even commented as being useful on L356.  Impact: If we do not remove closed market bids during withdrawDeposit, the closed market bids still get accounted in user's bidrate in the conditional on L357 and therefore do not prevent the foreclosure in withdrawDeposit that may happen in L357-L367. User may get foreclosed because of mis-accounted closed-market bids in the order book.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCOrderbook.sol#L671-L713  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L356  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L357-L367  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L704-L705  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L300-L301   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add call to removeOldBids() on L355 of withdrawDeposit() of Treasury.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The code base uses a mix of named return values and explicit returns. In some places, the named return values are never assigned to and explicit returns are used instead.   Impact: This makes code readability and auditability hard potentially leading to errors and missed vulnerabilities.  ## Proof of Concept  Named return value shouldContinue is never assigned in _collectRentAction(): https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L856   Named return value didUpdateEverything is never assigned in _collectRent(): https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1040  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unassigned named return variables and be consistent in named vs explicit return usage.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In Market sponsor() the call to treasury.checkSponsorship() checks allowance and balance  of user. This is redundant because the call to treasury.sponsor downstream checks allowance again and insufficient balance would cause any transfer to fail anyway.  Impact: Given the gas sensitivity of the code base, removing this redundant check could help conserve gas and prevent any DoS from breaking gas limits.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L810  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L386-L396  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L474-L478   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove redundant checks.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The exitedTimestamp flag is used to prevent front-running of user exiting and re-entering in the same block. The setting of this flag in exit() should really be inside the conditionals and triggered only if current owner or if bidExists. It currently assumes that either of the two will always be true which may not necessarily be the case.  Impact: A user accidentally exiting a card he doesn't own or have a bid for currently will be marked as exited and prevented from a newRental in the same block. User can prevent one's own newRental from succeeding, because it was accidentally triggered, by front-running it himself with an exit. There could be other more realistic scenarios.   ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L784-L804  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L56-L57  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L678-L681   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Set exitedTimestamp flag only when the conditionals are true within exit()  
# Handle  0xRajeev   # Vulnerability details  ## Impact  rentAllCards() requires the sender to specify a _maxSumOfPrices parameter which specifies “limit to the sum of the bids to place” as specified in the Natspec @param comment. This is apparently for front-run protection.  However, this function parameter constraint for _maxSumOfPrices is broken in the function implementation which leads to the total of bids places greater than the _maxSumOfPrices specified.  Impact: The user may not have sufficient deposit, be foreclosed and/or impacted on other bids/markets.  ## Proof of Concept  Scenario: Assume two cards for a market with current winning rentals of 50 each. _maxSumofPrices = 101 passes check on L643 but then the forced 10% increase on L650 (assuming sender is not the owner of either card) causes newRentals to be called with 55 for each card thus totalling to 110 which is > 101 as requested by the user.  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L636-L637  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L639-L657   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Modify the max sum of prices check logic to consider the 10% increase scenarios. Document and suggest the max sum of prices for the user in the UI based on the card prices and 10% requirement depending on card ownership.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Missing _checkState(States.OPEN) on first line of rentAllCards() as specified on L617. These core market functions are supposed to operate only when market is open but the missing check allows control to proceed further in the control flow. In this case, the function proceeds to call newRental() which has a conditional check state == States.OPEN and silently returns success otherwise, without reverting.  Impact: rentAllCards does not fail if executed when market is closed or locked. newRental returns silently without failure when market is closed or locked.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L617  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L637-L658  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L672   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a require() to check market open state in the beginning of all core market functions and revert with an informative error string otherwise.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Misplaced zero-address check for nfthub on L595 in createMarket() because nfthub cannot be 0 at this point as nfthub.addMarket() on L570 would have already reverted if that were the case.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L570  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L595  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move nfthub zero-address check to before the call to nfthub.addMarket().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Once market is approved and operational, changing approval to false should not be allowed or else it will prevent NFTs from being withdrawn to mainnet. All other Governor controlled variables are used during market creation and not thereafter, except this one. The other onlyGovernors functions only affect state before market creation but this one affects after creation.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L382-L391  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L326-L330   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Once market is approved and operational, changing approval to false should not be allowed.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The general definition of basis points is 100 bps = 1%. The usage here, 1000 bps = 100%, deviates from generally accepted definition and could cause confusion among users/creators/affiliates or potential miscalculations.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L228  https://www.investopedia.com/terms/b/basispoint.asp  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Document the used definition of basis points or switch to the generally accepted definition.  
# Handle  jvaqa   # Vulnerability details  Redundant require() statement in RCFactory.createMarket()  ## Impact  RCFactory.createMarket() contains two require() statements side-by-side both checking the value of the relative values of _timestamps[0] and block.timestamp. // [1]  However, there is no case where the first require() statement would be triggered without the second require() statement also being triggered, since advancedWarning cannot have a negative value. // [2]  Thus, the first require() statement is redundant, and unnecessarily uses gas.  ## Proof of Concept  Alice can call RCFactory.createMarket() with an advancedWarning value greater than zero, and a _timestamps[0] value less than block.timestamp.  ## Recommended Mitigation Steps  Remove this require statement:  require(                 _timestamps[0] >= block.timestamp,                 "Market opening time not set"             ); // [3]   [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L520  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L524  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L520  
# Handle  jvaqa   # Vulnerability details  RCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0], even though proper functioning requires them to be so.  ## Impact  IRCMarket defines a sequence of events that each market should progress through sequentially, CLOSED, OPEN, LOCKED, WITHDRAW. // [1]  The comments explicitly state that _incrementState() should be called "thrice". // [2]  However, it is possible to create a market where these events do not occur sequentially.  You can create a market where the marketOpeningTime is later than the marketLockingTime and oracleResolutionTime.  This is because although RCFactory checks to ensure that _timestamps[2] is greater than _timestamps[1], it does not check to ensure that _timestamps[1] is greater than _timestamps[0]. // [3]  This is also because although RCFactory checks to ensure that _timestamps[0] is equal to or greater than block.timestamp, it makes no check for a minimum value for _timestamps[1] or _timestamps[2], or a relative check between the value of _timestamps[0] and _timestamps[1]. // [4]  Thus, you can create a market where the marketLockingTime and the oracleResolutionTime occur before the marketOpeningTime.  ## Proof of Concept  When calling RCFactory.createMarket(), Alice can supply 0 as the argument for _timestamps[1] and _timestamps[2], and any value equal to or greater than block.timestamp for _timestamps[0]. // [5]  ## Recommended Mitigation Steps  Add the following check to RCFactory.createMarket():  require(     _timestamps[0] < _timestamps[1],     "market must begin before market can lock" );  [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L7  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1093  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L539  [4] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L521  [5] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L468  
# Handle  JMukesh   # Vulnerability details  ## Impact   constructor of RCorderbook.sol lacks zero address validation , since parameter of costructor are used initialize state variable which are used in other function of the contract , error in these state variable can lead to redeployment of contract  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L106  ## Tools Used manual review  ## Recommended Mitigation Steps add require condition to check for zero address  
# Handle  JMukesh   # Vulnerability details  ## Impact checking the return value from function indicates ether function call was success or failure because of that, we should utilise the return value   ## Proof of Concept  In RCmarket.sol  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1025  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1060  ## Tools Used slither  ## Recommended Mitigation Steps  Utilize return value  
# Handle  jvaqa   # Vulnerability details  RCTreasury.addToWhitelist() will erroneously remove user from whitelist if user is already whitelisted  ## Impact  The comments state that calling addToWhitelist() should add a user to the whitelist. [1]  However, since the implementation simply flips the user's whitelist bool, if the user is already on the whitelist, then calling addToWhitelist() will actually remove them from the whitelist. [2]  Since batchAddToWhitelist() will repeatedly call addToWhitelist() with an entire array of users, it is very possible that someone could inadvertently call addToWhitelist twice for a particular user, thereby leaving them off of the whitelist. [3]   ## Proof of Concept  If a governor calls addToWhitelist() with the same user twice, the user will not be added to the whitelist, even though the comments state that they should.  ## Recommended Mitigation Steps  Change addToWhitelist to only ever flip a user's bool to true. To clarify the governor's intention, create a corresponding removeFromWhitelist and batchRemoveFromWhitelist which flip a user's bool to false, so that the governor does not accidently remove a user when intending to add them.   Change this:  isAllowed[_user] = !isAllowed[_user]; // [4]  To this:  isAllowed[_user] = true; // [4]  And add this:      /// @notice Remove a user to the whitelist     function removeFromWhitelist(address _user) public override {         IRCFactory factory = IRCFactory(factoryAddress);         require(factory.isGovernor(msgSender()), "Not authorised");         isAllowed[_user] = false;     }      /// @notice Remove multiple users from the whitelist     function batchRemoveFromWhitelist(address[] calldata _users) public override {         for (uint256 index = 0; index < _users.length; index++) {             removeFromWhitelist(_users[index]);         }     }   [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L209  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L213  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L217  [4] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L213   
# Handle  pauliax   # Vulnerability details  ## Impact This function sponsor should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary _sponsorAddress address and transfer tokens from them if the allowance is > 0:     /// @notice ability to add liqudity to the pot without being able to win.     /// @dev called by Factory during market creation     /// @param _sponsorAddress the msgSender of createMarket in the Factory     function sponsor(address _sponsorAddress, uint256 _amount)         external         override     {         _sponsor(_sponsorAddress, _amount);     }  ## Recommended Mitigation Steps Check that the sender is a factory contract.  
# Handle  pauliax   # Vulnerability details  ## Impact function circuitBreaker calls _incrementState but later sets the state itself again:     function _incrementState() internal {         assert(uint256(state) < 4);         state = States(uint256(state) + (1));         emit LogStateChange(uint256(state));     }      function circuitBreaker() external {         require(             block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),             "Too early"         );         _incrementState();         orderbook.closeMarket();         state = States.WITHDRAW;     }  ## Recommended Mitigation Steps state = States.WITHDRAW; shouldn't be there, or another solution would be to put it before orderbook.closeMarket(); and remove _incrementState(); instead but then LogStateChange event will also need to be emitted manually.  
# Handle  pauliax   # Vulnerability details  ## Impact contract RCTreasury has an unused storage variable nfthub and setNftHubAddress function. This variable was moved to the Factory contract so it is useless here.  ## Recommended Mitigation Steps Remove nfthub variable and function setNftHubAddress.  
# Handle  pauliax   # Vulnerability details  ## Impact function safeTransferFrom is almost identical to function transferFrom. It would be better to reduce code duplication by re-using the code.  ## Recommended Mitigation Steps    function safeTransferFrom(         address from,         address to,         uint256 tokenId,         bytes memory _data     ) public override {         transferFrom(from, to, tokenId);         _data;     }  
# Handle  pauliax   # Vulnerability details  ## Impact event WithdrawnBatch in contract RCNftHubL2 is not used anywhere.  ## Recommended Mitigation Steps Remove or use it where intended.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function withdrawDeposit of RCTreasury.sol, the value of isForeclosed[_msgSender]  is set to true. In the next statement it is overwritten with a new value. So the first statement seem redundant. However this is not the case because it is retrieved from the function removeUserFromOrderbook (see proof of concept below)  As this is not obvious it is probably useful to add a comment so future developers can understand this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L322 function withdrawDeposit(uint256 _amount, bool _localWithdrawal)  external  override  balancedBooks  {   ...      isForeclosed[_msgSender] = true;   // this seems to be redundant     isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook( _msgSender );  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L575   function removeUserFromOrderbook(address _user)  external override returns (bool _userForeclosed) {         require(treasury.isForeclosed(_user), "User must be foreclosed");   // this checks the isForeclosed value from the treasury contract   ## Tools Used  ## Recommended Mitigation Steps Add a comment to  isForeclosed[_msgSender] = true;  explaining this line is important.   
# Handle  gpersoon   # Vulnerability details  ## Impact The function payout of RCTreasury.sol doesn't undo the isForeclosed state of a user. This would be possible because with a payout a user will receive funds so he can lose his isForeclosed status.  For example the function refundUser does check and update the isForeclosed status.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L429  function payout(address _user, uint256 _amount)  external override balancedBooks onlyMarkets returns (bool) {         require(!globalPause, "Payouts are disabled");         assert(marketPot[msgSender()] >= _amount);         user[_user].deposit += SafeCast.toUint128(_amount);         marketPot[msgSender()] -= _amount;         totalMarketPots -= _amount;         totalDeposits += _amount;         emit LogAdjustDeposit(_user, _amount, true);         return true;     }  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L447  function refundUser(address _user, uint256 _refund)  external override onlyMarkets {      ...         if ( isForeclosed[_user] && user[_user].deposit > user[_user].bidRate / minRentalDayDivisor )  {             isForeclosed[_user] = false;             emit LogUserForeclosed(_user, false);         }  ## Tools Used  ## Recommended Mitigation Steps Check and update the isForeclosed state in the payout function  
# Handle  gpersoon   # Vulnerability details  ## Impact The function deposit of RCTreasury.sol resets the isForeclosed state and emits LogUserForeclosed, if the use have enough funds. However this also happens if the user is not Foreclosed and so the emit is redundant and confusing.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L279 function deposit(uint256 _amount, address _user) public override balancedBooks returns (bool) {    ....         // this deposit could cancel the users foreclosure         if ( (user[_user].deposit + _amount) > (user[_user].bidRate / minRentalDayDivisor) ) {             isForeclosed[_user] = false;             emit LogUserForeclosed(_user, false);         }         return true;     }  ## Tools Used  ## Recommended Mitigation Steps Only do the emit when isForeclosed was true  
# Handle  gpersoon   # Vulnerability details  ## Impact The function addToWhitelist of RCTreasury.sol does a call to the factory contract, however the factoryAddress might not be initialized, because it is set via a different function (setFactoryAddress). The function addToWhitelist will revert when it calls a 0 address, but it might be more difficult to troubleshoot.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L233    function setFactoryAddress(address _newFactory) external override {         ...         factoryAddress = _newFactory;     }  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L210     function addToWhitelist(address _user) public override {         IRCFactory factory = IRCFactory(factoryAddress);         require(factory.isGovernor(msgSender()), "Not authorised");         isAllowed[_user] = !isAllowed[_user];     }  ## Tools Used  ## Recommended Mitigation Steps Verify that factoryAddress is set in the function addToWhitelist, for example using the following code.  require(factory != address(0), "Must have an address");  
# Handle  heiho1   # Vulnerability details  ## Impact  RCMarket#tokenURI(uint256) is declared external in the IRCMarket interface but is declared public in the RCMarket implementation.   This is inconsistent and affect the gas behavior of the function: https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L27  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L344  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L344  ## Tools Used  Slither  ## Recommended Mitigation Steps  Mark the implementation method as external.  
# Handle  heiho1   # Vulnerability details  ## Impact  RCMarket#initialize(uint256,uint32[],uint256,uint256,address,address,address[],address,string) has a potentially expensive loop that modifies state continually over an indeterminate number of cards.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L252  ## Tools Used  Slither  ## Recommended Mitigation Steps  Potentially a gas-expensive loop because of arbitrary length of _cardAffiliateAddresses possibly assigning to state variable cardAffiliateCut multiple times. * It appears that the loop may be exited on the first cardAffiliateCut = 0 to optimize gas * Alternatively a local variable may be assigned temporarily and then assigned to state: https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop   
# Handle  heiho1   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Minimal code quality issue.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCFactory.sol#L26  The function setminimumPriceIncreasePercent does not follow the code standard of camel casing of function names.    ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Rename the function to have proper camel casing.  
# Handle  gpersoon   # Vulnerability details  ## Impact Within RCMarket.sol the functions ownerOf and onlyTokenOwner do not check if the _cardId/_token is smaller than numberOfCards. So it's possible to supply a larger number and access cards of other markets. The most problematic seems to be upgradeCard. Here the check for isMarketApproved can be circumvented by trying to move the card via another market.  You can still only move cards you own.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L338     function ownerOf(uint256 _cardId) public view override returns (address) {         uint256 _tokenId = _cardId + totalNftMintCount; // doesn't check if _cardId < numberOfCards         return nfthub.ownerOf(_tokenId);     }  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L313   modifier onlyTokenOwner(uint256 _token) {         require(msgSender() == ownerOf(_token), "Not owner"); // _token could be higher than numberOfCards,         _;     }    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {   // _card  could be higher than numberOfCards,         _checkState(States.WITHDRAW);         require(             !factory.trapIfUnapproved() ||                 factory.isMarketApproved(address(this)),   // this can be circumvented by calling the function via another market             "Upgrade blocked"         );         uint256 _tokenId = _card + totalNftMintCount;    // _card  could be higher than numberOfCards, thus accessing a card in another market         _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place         nfthub.withdrawWithMetadata(_tokenId);         emit LogNftUpgraded(_card, _tokenId);     }    ## Tools Used  ## Recommended Mitigation Steps Add the following to ownerOf: require(_card < numberOfCards, "Card does not exist");   
# Handle  gpersoon   # Vulnerability details  ## Impact A value of 1000 is used to indicate 100%. This value is hardcoded on several places. It's saver to use a constant, to prevent mistakes in future updates.  ## Proof of Concept .\RCFactory.sol:    /// @dev in basis points (so 1000 = 100%) .\RCFactory.sol:                1000, .\RCMarket.sol:                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) - .\RCMarket.sol:            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) - .\RCMarket.sol:            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000); .\RCMarket.sol:                (1000); .\RCMarket.sol:            _remainingPot = (totalRentCollected * _remainingCut) / (1000); .\RCMarket.sol:            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut; .\RCMarket.sol:            (_rentCollected * _remainingCut) / (1000); .\RCMarket.sol:            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000); .\RCMarket.sol:            uint256 _payment = (totalRentCollected * _cut) / (1000);  ## Tools Used grep  ## Recommended Mitigation Steps Replace 1000 with a constant.   
# Handle  gpersoon   # Vulnerability details  ## Impact For the enums Mode and State, checks are made that the variables are within bounds. Here specific size are used, e.g. 2 and 4. If the size of the enums would be changed in the future, those numbers don't change automatically. Also solidity provides in-built check to check that variables are within bounds, which could be used instead. This also make the code more readable.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L202 enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE} function initialize(      ...         assert(_mode <= 2);        // can be removed       ...          mode = Mode(_mode);  // this makes sure: 0<=mode<=2   // move to top  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/interfaces/IRCMarket.sol#L7     enum States {CLOSED, OPEN, LOCKED, WITHDRAW}  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1094     function _incrementState() internal {         assert(uint256(state) < 4);                 // can be removed         state = States(uint256(state) + (1));  // this makes sure: 0<=state<=3         emit LogStateChange(uint256(state));     }  ## Tools Used  ## Recommended Mitigation Steps For function initialize: Remove the "assert(_mode <= 2);" and move the statement "mode = Mode(_mode);" to the top of the function and add a comment  For function _incrementState:  Remove "assert(uint256(state) < 4);" and add a comment at "state = States(uint256(state) + (1));"  
# Handle  gpersoon   # Vulnerability details  ## Impact The number 1000000  is used in the constructor of RCTreasury.sol. This is difficult to read in a glance. Solidity allows the use of an underscore ( _ ) to make numbers more readable.  ## Proof of Concept https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L114 setMaxContractBalance(1000000 ether); // 1m  ## Tools Used  ## Recommended Mitigation Steps  Replace 1000000 with 1_000_000   
# Handle  gpersoon   # Vulnerability details  ## Impact The variable _realitioAddress of RCMarket.sol isn't used. The variable realitio seems to used instead. Two variables with the same purpose is confusing.  ## Proof of Concept https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L121     IRealitio public realitio;     address public _realitioAddress;  ## Tools Used  ## Recommended Mitigation Steps Remove     address public _realitioAddress;  
# Handle  gpersoon   # Vulnerability details  ## Impact Several variables are only set once. So it might be useful to make them immutable to reduced the change of accidental updates See the "proof of concept" for examples.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol uint256 public numberOfCards; uint256 public totalNftMintCount; IRCTreasury public treasury; IRCFactory public factory; IRCNftHubL2 public nfthub; IRCOrderbook public orderbook; uint256 public minimumPriceIncreasePercent; uint256 public minRentalDayDivisor; uint256 public maxRentIterations; uint32 public marketOpeningTime; uint32 public override marketLockingTime; uint32 public oracleResolutionTime;    address public artistAddress; address public affiliateAddress; address public marketCreatorAddress; uint256 public creatorCut;     address[] public cardAffiliateAddresses; address public arbitrator; IRealitio public realitio;  //https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCFactory.sol#L113 IRCTreasury public override treasury;      ## Tools Used  ## Recommended Mitigation Steps Use the immutable keyword where possible   
# Handle  axic   # Vulnerability details  ## Impact  Some major tokens went live before ERC20 was finalised, resulting in a discrepancy whether the transfer functions a) should return a boolean or b) revert/fail on error. The current best practice is that they should revert, but return “true” on success. However, not every token claiming ERC20-compatibility is doing this — some only return true/false; some revert, but do not return anything on success. This is a well known issue, heavily discussed since mid-2018.  Today many tools, including OpenZeppelin, offer a wrapper for “safe ERC20 transfer”: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol  RealityCards is not using such a wrapper, but instead tries to ensure successful transfers via the `balancedBooks` modifier:  ```     modifier balancedBooks {         _;         // using >= not == in case anyone sends tokens direct to contract         require(             erc20.balanceOf(address(this)) >=                 totalDeposits + marketBalance + totalMarketPots,             "Books are unbalanced!"         );     } ```  This modifier is present on most functions, but is missing on `topupMarketBalance`: ```     function topupMarketBalance(uint256 _amount) external override {         erc20.transferFrom(msgSender(), address(this), _amount);         if (_amount > marketBalanceDiscrepancy) {             marketBalanceDiscrepancy = 0;         } else {             marketBalanceDiscrepancy -= _amount;         }         marketBalance += _amount;     } ```  In the case an ERC20 token which is not reverting on failures is used, a malicious actor could call `topupMarketBalance` with a failing transfer, but also move the value of `marketBalance` above the actual holdings. After this, `deposit`, `withdrawDeposit`, `payRent`, `payout`, `sponsor`, etc. could be locked up and always failing with “Books are unbalanced”.  ## Proof of Concept  Anyone can call `topupMarketBalance` with some unrealistically large number, so that `marketBalance` does not overflow, but is above the actually helping balances. This is only possible if the underlying ERC20 used is not reverting on failures, but return “false” instead.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  1. Use something like OpenZeppelin’s SafeERC20 2. Set up an allow list for tokens, which are knowingly safe 3. Consider a different approach to the `balancedBooks` modifier   
# Handle  axic   # Vulnerability details  ## Impact  In `lib/NativeMetaTransactions.sol` there is a frequently used helper `msgSender`: ```     function msgSender() internal view returns (address payable sender) {         if (msg.sender == address(this)) {             bytes memory array = msg.data;             uint256 index = msg.data.length;             assembly {                 // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.                 sender := and(                     mload(add(array, index)),                     0xffffffffffffffffffffffffffffffffffffffff                 )             }         } else { ... ```  Even though only the last 20-bytes matter, the `bytes memory array = msg.data;` line causes the *entire* calldata to be copied to memory. This is exaggerated by the fact, that if `msgSender()` is called multiple times in a transaction, the calldata will be also copied multiple times as memory is not freed.  ## Proof of Concept  N/A  ## Tools Used  Manual review.  ## Recommended Mitigation Steps  There are multiple ways to avoid this:  1. Make use of calldata slices and conversions  Something along the lines of (untested!): ```             // Copy last 20 bytes             bytes calldata data = msg.data[(msg.data.length - 20):];             sender = payable(address(uint160(bytes20(data)))); ```  2. Implementing purely in assembly  The OpenZeppelin implementation (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol#L21-L30) is an example of an optimised assembly version: ```             assembly {                 sender := shr(96, calldataload(sub(calldatasize(), 20)))             } ```  3. Combining slices and assembly  One must note that the pure assembly version is obviously the most gas efficient, at least today.   
# Handle  shw   # Vulnerability details  ## Impact  The function `foreclosureTimeUser` of `RCTreasury` underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card.  ## Proof of Concept  The variable `timeLeftOfDeposit` at line 668 is calculated based on `depositAbleToWithdraw(_user)`, the user's deposit minus the rent from the last rent calculation to the current time. Thus, the variable `timeLeftOfDeposit` indicates the time left of deposit, starting from now. However, at line 672, the `foreclosureTimeWithoutNewCard` is calculated by `timeLeftOfDeposit` plus the user's last rent calculation time instead of the current time. As a result, the user's foreclosure time is reduced. From another perspective, the rent between the last rent calculation time and the current time is counted twice.  Referenced code: [RCTreasury.sol#L642-L653](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L642-L653) [RCTreasury.sol#L669](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L669) [RCTreasury.sol#L672](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L672) [RCTreasury.sol#L678](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L678) [RCOrderbook.sol#L553-L557](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L553-L557)  ## Recommended Mitigation Steps  Change `depositAbleToWithdraw(_user)` at line 669 to `user[_user].deposit`. Or, change `user[_user].lastRentCalc` at both line 672 and 678 to `block.timestamp`.  
# Handle  shw   # Vulnerability details  ## Impact  The variable `domainSeperator` in `EIP712Base` is cached in the contract storage and will not change after the contract is initialized. However, if a hard fork happens after the contract deployment, the `domainSeperator` would become invalid on one of the forked chains due to the `block.chainid` has changed.  ## Proof of Concept  Referenced code: [EIP712Base.sol#L25-L44](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/lib/EIP712Base.sol#L25-L44)  ## Recommended Mitigation Steps  Consider using the [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/draft-EIP712.sol) from OpenZeppelin, which recalculates the domain separator if the current `block.chainid` is not the cached chain ID.  
# Handle  a_delamo   # Vulnerability details  On `RCFactory` is using uint to represent the enum Mode while on RCMarket is using the enum directly.  It would make the code much readable if RCFactory would use Mode directly.   
# Handle  a_delamo   # Vulnerability details  ## Impact  `RCMarket` contains the constant variable `isMarket` to indicate it is a Market `bool public constant override isMarket = true;`. This is after used in `RCFactory` ``` function changeMarketApproval(address _market) external onlyGovernors {         require(_market != address(0));         // check it's an RC contract         IRCMarket _marketToApprove = IRCMarket(_market);         assert(_marketToApprove.isMarket());         isMarketApproved[_market] = !isMarketApproved[_market];         emit LogMarketApproved(_market, isMarketApproved[_market]);     } ```  Why not use `mappingOfMarkets` to verify the address is a Market? This would reduce the state space used.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `RCNftHubL2.safeTransferFrom` function does not correctly implement the ERC721 spec:  > When using safeTransferFrom, the token contract checks to see that the receiver is an IERC721Receiver, which implies that it knows how to handle ERC721 tokens. [ERC721](https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#IERC721-safeTransferFrom)  This check is not implemented, it just drops the `_data` argument.  ## Impact  Contracts that don't know how to handle ERC721 tokens (are not an `IERC721Receiver`) can accept them but they should not when using `safeTransferFrom` according to spec.  ## Recommended Mitigation Steps  Implement the `IERC721Receiver` check in `safeTransferFrom`.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  Usually one tries to avoid toggle functions in blockchains, because it could be that you think that the first transaction you sent was not correctly submitted (but it's just pending for a long time), or you might even be unaware that it was already sent if multiple roles can set it (like with `changeMarketApproval` / `onlyGovernors`) or if it's an msig. This results in potentially double-toggling the state, i.e, it is set to the initial value again.  Some example functions: `changeMarketCreationGovernorsOnly`, `changeMarketApproval`, and the ones that follow.  ## Impact  The outcome of toggle functions is hard to predict on blockchains due to the very async nature and lack of information about pending transactions.  ## Recommended Mitigation Steps  Use functions that accept a specific value as a parameter instead.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `uberOwner` cannot do the same things the owner can. They can "only" set the reference contract for the market.  The same ideas apply to `Treasury` and `Factory`'s `uberOwner`.  ## Impact  The name is misleading as it sounds like the uber-owner is more powerful than the owner.  ## Recommended Mitigation Steps  Uberowner should at least be able to set the owner if not be allowed to call all functions that an `owner` can. Alternatively, rename the `uberOwner`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `Factory.createMarket` iterates over all `_cardAffiliateAddresses`.  ## Impact  The transactions can fail if the arrays get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.   ## Recommended Mitigation Steps  Perform a `_cardAffiliateAddresses.length == 0 || _cardAffiliateAddresses.length == tokenUris.length` check in `createMarket` instead of silently skipping card affiliate cuts in `Market.initialize`. This would restrict the `_cardAffiliateAddresses` length to the `nftMintingLimit` as well.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The treasury only checks its `globalPause` field but does not check its market-specific `marketPaused` field for `Treasury.sponsor`. A paused market contract can therefore still deposit as a sponsor using `Market.sponsor`  ## Impact  The market-specific pause does not work correctly.  ## Recommended Mitigation Steps  Add checks for `marketPaused` in the Treasury for `sponsor`.   
# Handle  a_delamo   # Vulnerability details  ## Impact On `RCOrderbook`, there are duplicated the state variable `treasuryAddress` and `treasury`  ```     address public treasuryAddress;     IRCTreasury public treasury; ``` ```     constructor(address _factoryAddress, address _treasuryAddress) {         factoryAddress = _factoryAddress;         treasuryAddress = _treasuryAddress;         treasury = IRCTreasury(treasuryAddress);         uberOwner = msgSender();     }  ```  
# Handle  pauliax   # Vulnerability details  ## Impact I can't find a reason why totalNftMintCount in Factory can't be replaced with ERC721 totalSupply() to make it less error-prone. As nfthub.mint issues a new token it should automatically increment totalSupply and this assignment won't be needed:       totalNftMintCount = totalNftMintCount + _tokenURIs.length; Also in function setNftHubAddress you need to manually set _newNftMintCount if you want to change nfthub so an invalid value may crash the system. totalSupply() will eliminate totalNftMintCount and make the system more robust.  ## Recommended Mitigation Steps Replace totalNftMintCount with nfthub totalSupply() in Factory contract.  
# Handle  maplesyrup   # Vulnerability details  ## Impact 1 - Low Risk    - Possible incorrect use of variables are at stake which may have bad side effects to the contract if implemented incorrectly.  ## Proof of Concept  According to the Slither-analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing), shadowing local variables is naming conventions found in two or more variables that are similar. Although they do not pose any immediate risk to the contract, incorrect usage of the variables is possible and can cause serious issues if the developer does not pay close attention.   It is recommended that the naming of the following variables should be changed slightly to avoid any confusion:   -------------------------------------------------------------------  RCOrderbook._updateBidInOrderbook(address,address,uint256,uint256,uint256,RCOrderbook.Bid)._owner   (contracts/RCOrderbook.sol line(s)#358) shadows:  Ownable._owner <------(state variable)  (node_modules/@openzeppelin/contracts/access/Ownable.sol line(s)#19)    -------------------------------------------------------------------  RCOrderbook.closeMarket()._owner   (contracts/RCOrderbook.sol line(s)#639) shadows:  Ownable._owner <------(state variable)  (node_modules/@openzeppelin/contracts/access/Ownable.sol line(s)#19)   -------------------------------------------------------------------  ## Tools Used  Solidity Compiler 0.8.4 Hardhat v2.3.3 Slither v0.8.0  Compiled, Tested, Deployed contracts on a local hardhat network.  Ran Slither-analyzer for further detecting and testing.  ## Recommended Mitigation Steps  (Worked best under python venv) 1. Clone Project Repository 2. Run Project against Hardhat network;    compile and run default test on contracts. 3. Installed slither analyzer:   https://github.com/crytic/slither 4. Ran [$ slither .] against RCOrderbook.sol and all contracts to verify results  
# Handle  pauliax   # Vulnerability details  ## Impact   _amount -= (_amount - marketBalance); is basically the same as:    _amount = marketBalance;   
# Handle  a_delamo   # Vulnerability details  ## Impact  The method `_collectRentAction` contains the following code: ``` ...            } else if (!_foreclosed && _limitHit && _marketLocked) {                 // CASE 4                 // didn't foreclose AND                 // did hit time limit AND                 // did lock market                 // THEN refund rent between the earliest event and now                 if (_cardTimeLimitTimestamp < marketLockingTime) {                     // time limit hit before market locked                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = block.timestamp - _cardTimeLimitTimestamp;                 } else {                     // market locked before time limit hit                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = block.timestamp - marketLockingTime;                 }             } else if (_foreclosed && !_limitHit && !_marketLocked) {                 // CASE 5                 // did foreclose AND                 // didn't hit time limit AND                 // didn't lock market                 // THEN rent OK, find new owner                 _timeOfThisCollection = _timeUserForeclosed;                 _newOwner = true;                 _refundTime = 0;             } else if (_foreclosed && !_limitHit && _marketLocked) {                 // CASE 6                 // did foreclose AND                 // didn't hit time limit AND                 // did lock market                 // THEN if foreclosed first rent ok, otherwise refund after locking                 if (_timeUserForeclosed < marketLockingTime) {                     // user foreclosed before market locked                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else {                     // market locked before user foreclosed                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = block.timestamp - marketLockingTime;                 }             } else if (_foreclosed && _limitHit && !_marketLocked) {                 // CASE 7                 // did foreclose AND                 // did hit time limit AND                 // didn't lock market                 // THEN if foreclosed first rent ok, otherwise refund after limit                 if (_timeUserForeclosed < _cardTimeLimitTimestamp) {                     // user foreclosed before time limit                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else {                     // time limit hit before user foreclosed                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;                 }             } else {                 // CASE 8                 // did foreclose AND                 // did hit time limit AND                 // did lock market                 // THEN (╯°益°)╯彡┻━┻                 if (                     _timeUserForeclosed <= _cardTimeLimitTimestamp &&                     _timeUserForeclosed < marketLockingTime                 ) {                     // user foreclosed first (or at same time as time limit)                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else if (                     _cardTimeLimitTimestamp < _timeUserForeclosed &&                     _cardTimeLimitTimestamp < marketLockingTime                 ) {                     // time limit hit first                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;                 } else {                     // market locked first                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = _timeUserForeclosed - marketLockingTime;                 } ... ```  On the case 6, instead of doing `_refundTime = _timeUserForeclosed - marketLockingTime;` like the following cases, is doing `_refundTime = block.timestamp - marketLockingTime;`. This could lead to funds being drained by the miscalculation.   
# Handle  a_delamo   # Vulnerability details  ## Impact  On `RCTreasury`, we have the method `collectRentUser`. This method is public, so anyone can call it using whatever user and whatever timestamp.  So, calling this method using `user = XXXXX` and `_timeToCollectTo = type(uint256).max)`, would make `isForeclosed[user] = true`.  ```     function collectRentUser(address _user, uint256 _timeToCollectTo)         public         override         returns (             uint256 newTimeLastCollectedOnForeclosure         )     {         require(!globalPause, "Global pause is enabled");         assert(_timeToCollectTo != 0);         if (user[_user].lastRentCalc < _timeToCollectTo) {             uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);              if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {                 // The User has run out of deposit already.                 uint256 previousCollectionTime = user[_user].lastRentCalc;                  /*             timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)                                   = (now - previousCollectionTime) * (usersDeposit/rentOwed)             */                 uint256 timeUsersDepositLasts =                     ((_timeToCollectTo - previousCollectionTime) *                         uint256(user[_user].deposit)) / rentOwedByUser;                 /*             Users last collection time = previousCollectionTime + timeTheirDepsitLasted             */                 rentOwedByUser = uint256(user[_user].deposit);                 newTimeLastCollectedOnForeclosure =                     previousCollectionTime +                     timeUsersDepositLasts;                 _increaseMarketBalance(rentOwedByUser, _user);                 user[_user].lastRentCalc = SafeCast.toUint64(                     newTimeLastCollectedOnForeclosure                 );                 assert(user[_user].deposit == 0);                 isForeclosed[_user] = true;                 emit LogUserForeclosed(_user, true);             } else {                 // User has enough deposit to pay rent.                 _increaseMarketBalance(rentOwedByUser, _user);                 user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);             }             emit LogAdjustDeposit(_user, rentOwedByUser, false);         }     } ```  Now, we can do the same for all the users bidding for a specific token.  Finally, I can become the owner of the token by just calling `newRental` and using a small price. `newRental` will iterate over all the previous bid and will remove them because there are foreclosed.   ## Tools Used Editor  ## Recommended Mitigation Steps  `collectRentUser` should be private and create a new public method with `onlyOrderbook` modifier  
# Handle  0xRajeev   # Vulnerability details  ## Impact  ERC721 standard and implementation allows the use of approved addresses to affect transfers besides the token owners. However, the L2 NFT Hub implementation deviates from ERC721 by ignoring the presence of any approvers in the overriding function implementations of transferFrom() and safeTransferFrom().   Impact: The system interactions with NFT platforms may not work if they expect ERC721 adherence. Users who interact via approved addresses will see their transfers failing for their approved addresses.   Given that the key value proposition of this project is the use of NFTs, the expectation will be that it is fully compatible with ERC721.   ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/nfthubs/RCNftHubL2.sol#L212-L234  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/00128bd26061986d10172573ceec914a4f3b4d3c/contracts/token/ERC721/ERC721.sol#L158   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add support for approval in NFT transfers.  
# Handle  pauliax   # Vulnerability details  ## Impact questionFinalised is redundant, it is only set to true or false but never queried or used in any meaningful way.  ## Recommended Mitigation Steps Remove questionFinalised from the codebase.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Orderbook.removeBids() as commented “///remove bids in closed markets for a given user ///this can reduce the users bidRate and chance to foreclose”  removeOldBids() is performed currently in Market.newRental() and Treasury.deposit() to  “do some cleaning up, it might help cancel their foreclosure” as commented. However, this is missing in the withdrawDeposit() function where the need is the most because user is removing deposit which may lead to foreclosure and is even commented as being useful on L356.  Impact: If we do not remove closed market bids during withdrawDeposit, the closed market bids still get accounted in user's bidrate in the conditional on L357 and therefore do not prevent the foreclosure in withdrawDeposit that may happen in L357-L367. User may get foreclosed because of mis-accounted closed-market bids in the order book.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCOrderbook.sol#L671-L713  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L356  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L357-L367  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L704-L705  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L300-L301   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add call to removeOldBids() on L355 of withdrawDeposit() of Treasury.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The code base uses a mix of named return values and explicit returns. In some places, the named return values are never assigned to and explicit returns are used instead.   Impact: This makes code readability and auditability hard potentially leading to errors and missed vulnerabilities.  ## Proof of Concept  Named return value shouldContinue is never assigned in _collectRentAction(): https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L856   Named return value didUpdateEverything is never assigned in _collectRent(): https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1040  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unassigned named return variables and be consistent in named vs explicit return usage.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In Market sponsor() the call to treasury.checkSponsorship() checks allowance and balance  of user. This is redundant because the call to treasury.sponsor downstream checks allowance again and insufficient balance would cause any transfer to fail anyway.  Impact: Given the gas sensitivity of the code base, removing this redundant check could help conserve gas and prevent any DoS from breaking gas limits.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L810  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L386-L396  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L474-L478   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove redundant checks.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The exitedTimestamp flag is used to prevent front-running of user exiting and re-entering in the same block. The setting of this flag in exit() should really be inside the conditionals and triggered only if current owner or if bidExists. It currently assumes that either of the two will always be true which may not necessarily be the case.  Impact: A user accidentally exiting a card he doesn't own or have a bid for currently will be marked as exited and prevented from a newRental in the same block. User can prevent one's own newRental from succeeding, because it was accidentally triggered, by front-running it himself with an exit. There could be other more realistic scenarios.   ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L784-L804  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L56-L57  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L678-L681   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Set exitedTimestamp flag only when the conditionals are true within exit()  
# Handle  0xRajeev   # Vulnerability details  ## Impact  rentAllCards() requires the sender to specify a _maxSumOfPrices parameter which specifies “limit to the sum of the bids to place” as specified in the Natspec @param comment. This is apparently for front-run protection.  However, this function parameter constraint for _maxSumOfPrices is broken in the function implementation which leads to the total of bids places greater than the _maxSumOfPrices specified.  Impact: The user may not have sufficient deposit, be foreclosed and/or impacted on other bids/markets.  ## Proof of Concept  Scenario: Assume two cards for a market with current winning rentals of 50 each. _maxSumofPrices = 101 passes check on L643 but then the forced 10% increase on L650 (assuming sender is not the owner of either card) causes newRentals to be called with 55 for each card thus totalling to 110 which is > 101 as requested by the user.  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L636-L637  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L639-L657   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Modify the max sum of prices check logic to consider the 10% increase scenarios. Document and suggest the max sum of prices for the user in the UI based on the card prices and 10% requirement depending on card ownership.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Missing _checkState(States.OPEN) on first line of rentAllCards() as specified on L617. These core market functions are supposed to operate only when market is open but the missing check allows control to proceed further in the control flow. In this case, the function proceeds to call newRental() which has a conditional check state == States.OPEN and silently returns success otherwise, without reverting.  Impact: rentAllCards does not fail if executed when market is closed or locked. newRental returns silently without failure when market is closed or locked.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L617  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L637-L658  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L672   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a require() to check market open state in the beginning of all core market functions and revert with an informative error string otherwise.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Misplaced zero-address check for nfthub on L595 in createMarket() because nfthub cannot be 0 at this point as nfthub.addMarket() on L570 would have already reverted if that were the case.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L570  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L595  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move nfthub zero-address check to before the call to nfthub.addMarket().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Once market is approved and operational, changing approval to false should not be allowed or else it will prevent NFTs from being withdrawn to mainnet. All other Governor controlled variables are used during market creation and not thereafter, except this one. The other onlyGovernors functions only affect state before market creation but this one affects after creation.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L382-L391  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L326-L330   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Once market is approved and operational, changing approval to false should not be allowed.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The general definition of basis points is 100 bps = 1%. The usage here, 1000 bps = 100%, deviates from generally accepted definition and could cause confusion among users/creators/affiliates or potential miscalculations.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L228  https://www.investopedia.com/terms/b/basispoint.asp  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Document the used definition of basis points or switch to the generally accepted definition.  
# Handle  jvaqa   # Vulnerability details  Redundant require() statement in RCFactory.createMarket()  ## Impact  RCFactory.createMarket() contains two require() statements side-by-side both checking the value of the relative values of _timestamps[0] and block.timestamp. // [1]  However, there is no case where the first require() statement would be triggered without the second require() statement also being triggered, since advancedWarning cannot have a negative value. // [2]  Thus, the first require() statement is redundant, and unnecessarily uses gas.  ## Proof of Concept  Alice can call RCFactory.createMarket() with an advancedWarning value greater than zero, and a _timestamps[0] value less than block.timestamp.  ## Recommended Mitigation Steps  Remove this require statement:  require(                 _timestamps[0] >= block.timestamp,                 "Market opening time not set"             ); // [3]   [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L520  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L524  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L520  
# Handle  jvaqa   # Vulnerability details  RCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0], even though proper functioning requires them to be so.  ## Impact  IRCMarket defines a sequence of events that each market should progress through sequentially, CLOSED, OPEN, LOCKED, WITHDRAW. // [1]  The comments explicitly state that _incrementState() should be called "thrice". // [2]  However, it is possible to create a market where these events do not occur sequentially.  You can create a market where the marketOpeningTime is later than the marketLockingTime and oracleResolutionTime.  This is because although RCFactory checks to ensure that _timestamps[2] is greater than _timestamps[1], it does not check to ensure that _timestamps[1] is greater than _timestamps[0]. // [3]  This is also because although RCFactory checks to ensure that _timestamps[0] is equal to or greater than block.timestamp, it makes no check for a minimum value for _timestamps[1] or _timestamps[2], or a relative check between the value of _timestamps[0] and _timestamps[1]. // [4]  Thus, you can create a market where the marketLockingTime and the oracleResolutionTime occur before the marketOpeningTime.  ## Proof of Concept  When calling RCFactory.createMarket(), Alice can supply 0 as the argument for _timestamps[1] and _timestamps[2], and any value equal to or greater than block.timestamp for _timestamps[0]. // [5]  ## Recommended Mitigation Steps  Add the following check to RCFactory.createMarket():  require(     _timestamps[0] < _timestamps[1],     "market must begin before market can lock" );  [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L7  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1093  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L539  [4] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L521  [5] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L468  
# Handle  JMukesh   # Vulnerability details  ## Impact   constructor of RCorderbook.sol lacks zero address validation , since parameter of costructor are used initialize state variable which are used in other function of the contract , error in these state variable can lead to redeployment of contract  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L106  ## Tools Used manual review  ## Recommended Mitigation Steps add require condition to check for zero address  
# Handle  JMukesh   # Vulnerability details  ## Impact checking the return value from function indicates ether function call was success or failure because of that, we should utilise the return value   ## Proof of Concept  In RCmarket.sol  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1025  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1060  ## Tools Used slither  ## Recommended Mitigation Steps  Utilize return value  
# Handle  jvaqa   # Vulnerability details  RCTreasury.addToWhitelist() will erroneously remove user from whitelist if user is already whitelisted  ## Impact  The comments state that calling addToWhitelist() should add a user to the whitelist. [1]  However, since the implementation simply flips the user's whitelist bool, if the user is already on the whitelist, then calling addToWhitelist() will actually remove them from the whitelist. [2]  Since batchAddToWhitelist() will repeatedly call addToWhitelist() with an entire array of users, it is very possible that someone could inadvertently call addToWhitelist twice for a particular user, thereby leaving them off of the whitelist. [3]   ## Proof of Concept  If a governor calls addToWhitelist() with the same user twice, the user will not be added to the whitelist, even though the comments state that they should.  ## Recommended Mitigation Steps  Change addToWhitelist to only ever flip a user's bool to true. To clarify the governor's intention, create a corresponding removeFromWhitelist and batchRemoveFromWhitelist which flip a user's bool to false, so that the governor does not accidently remove a user when intending to add them.   Change this:  isAllowed[_user] = !isAllowed[_user]; // [4]  To this:  isAllowed[_user] = true; // [4]  And add this:      /// @notice Remove a user to the whitelist     function removeFromWhitelist(address _user) public override {         IRCFactory factory = IRCFactory(factoryAddress);         require(factory.isGovernor(msgSender()), "Not authorised");         isAllowed[_user] = false;     }      /// @notice Remove multiple users from the whitelist     function batchRemoveFromWhitelist(address[] calldata _users) public override {         for (uint256 index = 0; index < _users.length; index++) {             removeFromWhitelist(_users[index]);         }     }   [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L209  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L213  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L217  [4] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L213   
# Handle  pauliax   # Vulnerability details  ## Impact This function sponsor should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary _sponsorAddress address and transfer tokens from them if the allowance is > 0:     /// @notice ability to add liqudity to the pot without being able to win.     /// @dev called by Factory during market creation     /// @param _sponsorAddress the msgSender of createMarket in the Factory     function sponsor(address _sponsorAddress, uint256 _amount)         external         override     {         _sponsor(_sponsorAddress, _amount);     }  ## Recommended Mitigation Steps Check that the sender is a factory contract.  
# Handle  pauliax   # Vulnerability details  ## Impact function circuitBreaker calls _incrementState but later sets the state itself again:     function _incrementState() internal {         assert(uint256(state) < 4);         state = States(uint256(state) + (1));         emit LogStateChange(uint256(state));     }      function circuitBreaker() external {         require(             block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),             "Too early"         );         _incrementState();         orderbook.closeMarket();         state = States.WITHDRAW;     }  ## Recommended Mitigation Steps state = States.WITHDRAW; shouldn't be there, or another solution would be to put it before orderbook.closeMarket(); and remove _incrementState(); instead but then LogStateChange event will also need to be emitted manually.  
# Handle  pauliax   # Vulnerability details  ## Impact contract RCTreasury has an unused storage variable nfthub and setNftHubAddress function. This variable was moved to the Factory contract so it is useless here.  ## Recommended Mitigation Steps Remove nfthub variable and function setNftHubAddress.  
# Handle  pauliax   # Vulnerability details  ## Impact function safeTransferFrom is almost identical to function transferFrom. It would be better to reduce code duplication by re-using the code.  ## Recommended Mitigation Steps    function safeTransferFrom(         address from,         address to,         uint256 tokenId,         bytes memory _data     ) public override {         transferFrom(from, to, tokenId);         _data;     }  
# Handle  pauliax   # Vulnerability details  ## Impact event WithdrawnBatch in contract RCNftHubL2 is not used anywhere.  ## Recommended Mitigation Steps Remove or use it where intended.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function withdrawDeposit of RCTreasury.sol, the value of isForeclosed[_msgSender]  is set to true. In the next statement it is overwritten with a new value. So the first statement seem redundant. However this is not the case because it is retrieved from the function removeUserFromOrderbook (see proof of concept below)  As this is not obvious it is probably useful to add a comment so future developers can understand this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L322 function withdrawDeposit(uint256 _amount, bool _localWithdrawal)  external  override  balancedBooks  {   ...      isForeclosed[_msgSender] = true;   // this seems to be redundant     isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook( _msgSender );  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L575   function removeUserFromOrderbook(address _user)  external override returns (bool _userForeclosed) {         require(treasury.isForeclosed(_user), "User must be foreclosed");   // this checks the isForeclosed value from the treasury contract   ## Tools Used  ## Recommended Mitigation Steps Add a comment to  isForeclosed[_msgSender] = true;  explaining this line is important.   
# Handle  gpersoon   # Vulnerability details  ## Impact The function payout of RCTreasury.sol doesn't undo the isForeclosed state of a user. This would be possible because with a payout a user will receive funds so he can lose his isForeclosed status.  For example the function refundUser does check and update the isForeclosed status.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L429  function payout(address _user, uint256 _amount)  external override balancedBooks onlyMarkets returns (bool) {         require(!globalPause, "Payouts are disabled");         assert(marketPot[msgSender()] >= _amount);         user[_user].deposit += SafeCast.toUint128(_amount);         marketPot[msgSender()] -= _amount;         totalMarketPots -= _amount;         totalDeposits += _amount;         emit LogAdjustDeposit(_user, _amount, true);         return true;     }  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L447  function refundUser(address _user, uint256 _refund)  external override onlyMarkets {      ...         if ( isForeclosed[_user] && user[_user].deposit > user[_user].bidRate / minRentalDayDivisor )  {             isForeclosed[_user] = false;             emit LogUserForeclosed(_user, false);         }  ## Tools Used  ## Recommended Mitigation Steps Check and update the isForeclosed state in the payout function  
# Handle  gpersoon   # Vulnerability details  ## Impact The function deposit of RCTreasury.sol resets the isForeclosed state and emits LogUserForeclosed, if the use have enough funds. However this also happens if the user is not Foreclosed and so the emit is redundant and confusing.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L279 function deposit(uint256 _amount, address _user) public override balancedBooks returns (bool) {    ....         // this deposit could cancel the users foreclosure         if ( (user[_user].deposit + _amount) > (user[_user].bidRate / minRentalDayDivisor) ) {             isForeclosed[_user] = false;             emit LogUserForeclosed(_user, false);         }         return true;     }  ## Tools Used  ## Recommended Mitigation Steps Only do the emit when isForeclosed was true  
# Handle  gpersoon   # Vulnerability details  ## Impact The function addToWhitelist of RCTreasury.sol does a call to the factory contract, however the factoryAddress might not be initialized, because it is set via a different function (setFactoryAddress). The function addToWhitelist will revert when it calls a 0 address, but it might be more difficult to troubleshoot.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L233    function setFactoryAddress(address _newFactory) external override {         ...         factoryAddress = _newFactory;     }  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L210     function addToWhitelist(address _user) public override {         IRCFactory factory = IRCFactory(factoryAddress);         require(factory.isGovernor(msgSender()), "Not authorised");         isAllowed[_user] = !isAllowed[_user];     }  ## Tools Used  ## Recommended Mitigation Steps Verify that factoryAddress is set in the function addToWhitelist, for example using the following code.  require(factory != address(0), "Must have an address");  
# Handle  heiho1   # Vulnerability details  ## Impact  RCMarket#tokenURI(uint256) is declared external in the IRCMarket interface but is declared public in the RCMarket implementation.   This is inconsistent and affect the gas behavior of the function: https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L27  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L344  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L344  ## Tools Used  Slither  ## Recommended Mitigation Steps  Mark the implementation method as external.  
# Handle  heiho1   # Vulnerability details  ## Impact  RCMarket#initialize(uint256,uint32[],uint256,uint256,address,address,address[],address,string) has a potentially expensive loop that modifies state continually over an indeterminate number of cards.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L252  ## Tools Used  Slither  ## Recommended Mitigation Steps  Potentially a gas-expensive loop because of arbitrary length of _cardAffiliateAddresses possibly assigning to state variable cardAffiliateCut multiple times. * It appears that the loop may be exited on the first cardAffiliateCut = 0 to optimize gas * Alternatively a local variable may be assigned temporarily and then assigned to state: https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop   
# Handle  heiho1   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Minimal code quality issue.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCFactory.sol#L26  The function setminimumPriceIncreasePercent does not follow the code standard of camel casing of function names.    ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Rename the function to have proper camel casing.  
# Handle  gpersoon   # Vulnerability details  ## Impact Within RCMarket.sol the functions ownerOf and onlyTokenOwner do not check if the _cardId/_token is smaller than numberOfCards. So it's possible to supply a larger number and access cards of other markets. The most problematic seems to be upgradeCard. Here the check for isMarketApproved can be circumvented by trying to move the card via another market.  You can still only move cards you own.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L338     function ownerOf(uint256 _cardId) public view override returns (address) {         uint256 _tokenId = _cardId + totalNftMintCount; // doesn't check if _cardId < numberOfCards         return nfthub.ownerOf(_tokenId);     }  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L313   modifier onlyTokenOwner(uint256 _token) {         require(msgSender() == ownerOf(_token), "Not owner"); // _token could be higher than numberOfCards,         _;     }    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {   // _card  could be higher than numberOfCards,         _checkState(States.WITHDRAW);         require(             !factory.trapIfUnapproved() ||                 factory.isMarketApproved(address(this)),   // this can be circumvented by calling the function via another market             "Upgrade blocked"         );         uint256 _tokenId = _card + totalNftMintCount;    // _card  could be higher than numberOfCards, thus accessing a card in another market         _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place         nfthub.withdrawWithMetadata(_tokenId);         emit LogNftUpgraded(_card, _tokenId);     }    ## Tools Used  ## Recommended Mitigation Steps Add the following to ownerOf: require(_card < numberOfCards, "Card does not exist");   
# Handle  gpersoon   # Vulnerability details  ## Impact A value of 1000 is used to indicate 100%. This value is hardcoded on several places. It's saver to use a constant, to prevent mistakes in future updates.  ## Proof of Concept .\RCFactory.sol:    /// @dev in basis points (so 1000 = 100%) .\RCFactory.sol:                1000, .\RCMarket.sol:                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) - .\RCMarket.sol:            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) - .\RCMarket.sol:            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000); .\RCMarket.sol:                (1000); .\RCMarket.sol:            _remainingPot = (totalRentCollected * _remainingCut) / (1000); .\RCMarket.sol:            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut; .\RCMarket.sol:            (_rentCollected * _remainingCut) / (1000); .\RCMarket.sol:            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000); .\RCMarket.sol:            uint256 _payment = (totalRentCollected * _cut) / (1000);  ## Tools Used grep  ## Recommended Mitigation Steps Replace 1000 with a constant.   
# Handle  gpersoon   # Vulnerability details  ## Impact For the enums Mode and State, checks are made that the variables are within bounds. Here specific size are used, e.g. 2 and 4. If the size of the enums would be changed in the future, those numbers don't change automatically. Also solidity provides in-built check to check that variables are within bounds, which could be used instead. This also make the code more readable.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L202 enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE} function initialize(      ...         assert(_mode <= 2);        // can be removed       ...          mode = Mode(_mode);  // this makes sure: 0<=mode<=2   // move to top  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/interfaces/IRCMarket.sol#L7     enum States {CLOSED, OPEN, LOCKED, WITHDRAW}  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1094     function _incrementState() internal {         assert(uint256(state) < 4);                 // can be removed         state = States(uint256(state) + (1));  // this makes sure: 0<=state<=3         emit LogStateChange(uint256(state));     }  ## Tools Used  ## Recommended Mitigation Steps For function initialize: Remove the "assert(_mode <= 2);" and move the statement "mode = Mode(_mode);" to the top of the function and add a comment  For function _incrementState:  Remove "assert(uint256(state) < 4);" and add a comment at "state = States(uint256(state) + (1));"  
# Handle  gpersoon   # Vulnerability details  ## Impact The number 1000000  is used in the constructor of RCTreasury.sol. This is difficult to read in a glance. Solidity allows the use of an underscore ( _ ) to make numbers more readable.  ## Proof of Concept https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L114 setMaxContractBalance(1000000 ether); // 1m  ## Tools Used  ## Recommended Mitigation Steps  Replace 1000000 with 1_000_000   
# Handle  gpersoon   # Vulnerability details  ## Impact The variable _realitioAddress of RCMarket.sol isn't used. The variable realitio seems to used instead. Two variables with the same purpose is confusing.  ## Proof of Concept https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L121     IRealitio public realitio;     address public _realitioAddress;  ## Tools Used  ## Recommended Mitigation Steps Remove     address public _realitioAddress;  
# Handle  gpersoon   # Vulnerability details  ## Impact Several variables are only set once. So it might be useful to make them immutable to reduced the change of accidental updates See the "proof of concept" for examples.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol uint256 public numberOfCards; uint256 public totalNftMintCount; IRCTreasury public treasury; IRCFactory public factory; IRCNftHubL2 public nfthub; IRCOrderbook public orderbook; uint256 public minimumPriceIncreasePercent; uint256 public minRentalDayDivisor; uint256 public maxRentIterations; uint32 public marketOpeningTime; uint32 public override marketLockingTime; uint32 public oracleResolutionTime;    address public artistAddress; address public affiliateAddress; address public marketCreatorAddress; uint256 public creatorCut;     address[] public cardAffiliateAddresses; address public arbitrator; IRealitio public realitio;  //https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCFactory.sol#L113 IRCTreasury public override treasury;      ## Tools Used  ## Recommended Mitigation Steps Use the immutable keyword where possible   
# Handle  axic   # Vulnerability details  ## Impact  Some major tokens went live before ERC20 was finalised, resulting in a discrepancy whether the transfer functions a) should return a boolean or b) revert/fail on error. The current best practice is that they should revert, but return “true” on success. However, not every token claiming ERC20-compatibility is doing this — some only return true/false; some revert, but do not return anything on success. This is a well known issue, heavily discussed since mid-2018.  Today many tools, including OpenZeppelin, offer a wrapper for “safe ERC20 transfer”: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol  RealityCards is not using such a wrapper, but instead tries to ensure successful transfers via the `balancedBooks` modifier:  ```     modifier balancedBooks {         _;         // using >= not == in case anyone sends tokens direct to contract         require(             erc20.balanceOf(address(this)) >=                 totalDeposits + marketBalance + totalMarketPots,             "Books are unbalanced!"         );     } ```  This modifier is present on most functions, but is missing on `topupMarketBalance`: ```     function topupMarketBalance(uint256 _amount) external override {         erc20.transferFrom(msgSender(), address(this), _amount);         if (_amount > marketBalanceDiscrepancy) {             marketBalanceDiscrepancy = 0;         } else {             marketBalanceDiscrepancy -= _amount;         }         marketBalance += _amount;     } ```  In the case an ERC20 token which is not reverting on failures is used, a malicious actor could call `topupMarketBalance` with a failing transfer, but also move the value of `marketBalance` above the actual holdings. After this, `deposit`, `withdrawDeposit`, `payRent`, `payout`, `sponsor`, etc. could be locked up and always failing with “Books are unbalanced”.  ## Proof of Concept  Anyone can call `topupMarketBalance` with some unrealistically large number, so that `marketBalance` does not overflow, but is above the actually helping balances. This is only possible if the underlying ERC20 used is not reverting on failures, but return “false” instead.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  1. Use something like OpenZeppelin’s SafeERC20 2. Set up an allow list for tokens, which are knowingly safe 3. Consider a different approach to the `balancedBooks` modifier   
# Handle  axic   # Vulnerability details  ## Impact  In `lib/NativeMetaTransactions.sol` there is a frequently used helper `msgSender`: ```     function msgSender() internal view returns (address payable sender) {         if (msg.sender == address(this)) {             bytes memory array = msg.data;             uint256 index = msg.data.length;             assembly {                 // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.                 sender := and(                     mload(add(array, index)),                     0xffffffffffffffffffffffffffffffffffffffff                 )             }         } else { ... ```  Even though only the last 20-bytes matter, the `bytes memory array = msg.data;` line causes the *entire* calldata to be copied to memory. This is exaggerated by the fact, that if `msgSender()` is called multiple times in a transaction, the calldata will be also copied multiple times as memory is not freed.  ## Proof of Concept  N/A  ## Tools Used  Manual review.  ## Recommended Mitigation Steps  There are multiple ways to avoid this:  1. Make use of calldata slices and conversions  Something along the lines of (untested!): ```             // Copy last 20 bytes             bytes calldata data = msg.data[(msg.data.length - 20):];             sender = payable(address(uint160(bytes20(data)))); ```  2. Implementing purely in assembly  The OpenZeppelin implementation (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol#L21-L30) is an example of an optimised assembly version: ```             assembly {                 sender := shr(96, calldataload(sub(calldatasize(), 20)))             } ```  3. Combining slices and assembly  One must note that the pure assembly version is obviously the most gas efficient, at least today.   
# Handle  shw   # Vulnerability details  ## Impact  The function `foreclosureTimeUser` of `RCTreasury` underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card.  ## Proof of Concept  The variable `timeLeftOfDeposit` at line 668 is calculated based on `depositAbleToWithdraw(_user)`, the user's deposit minus the rent from the last rent calculation to the current time. Thus, the variable `timeLeftOfDeposit` indicates the time left of deposit, starting from now. However, at line 672, the `foreclosureTimeWithoutNewCard` is calculated by `timeLeftOfDeposit` plus the user's last rent calculation time instead of the current time. As a result, the user's foreclosure time is reduced. From another perspective, the rent between the last rent calculation time and the current time is counted twice.  Referenced code: [RCTreasury.sol#L642-L653](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L642-L653) [RCTreasury.sol#L669](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L669) [RCTreasury.sol#L672](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L672) [RCTreasury.sol#L678](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L678) [RCOrderbook.sol#L553-L557](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L553-L557)  ## Recommended Mitigation Steps  Change `depositAbleToWithdraw(_user)` at line 669 to `user[_user].deposit`. Or, change `user[_user].lastRentCalc` at both line 672 and 678 to `block.timestamp`.  
# Handle  shw   # Vulnerability details  ## Impact  The variable `domainSeperator` in `EIP712Base` is cached in the contract storage and will not change after the contract is initialized. However, if a hard fork happens after the contract deployment, the `domainSeperator` would become invalid on one of the forked chains due to the `block.chainid` has changed.  ## Proof of Concept  Referenced code: [EIP712Base.sol#L25-L44](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/lib/EIP712Base.sol#L25-L44)  ## Recommended Mitigation Steps  Consider using the [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/draft-EIP712.sol) from OpenZeppelin, which recalculates the domain separator if the current `block.chainid` is not the cached chain ID.  
# Handle  a_delamo   # Vulnerability details  On `RCFactory` is using uint to represent the enum Mode while on RCMarket is using the enum directly.  It would make the code much readable if RCFactory would use Mode directly.   
# Handle  a_delamo   # Vulnerability details  ## Impact  `RCMarket` contains the constant variable `isMarket` to indicate it is a Market `bool public constant override isMarket = true;`. This is after used in `RCFactory` ``` function changeMarketApproval(address _market) external onlyGovernors {         require(_market != address(0));         // check it's an RC contract         IRCMarket _marketToApprove = IRCMarket(_market);         assert(_marketToApprove.isMarket());         isMarketApproved[_market] = !isMarketApproved[_market];         emit LogMarketApproved(_market, isMarketApproved[_market]);     } ```  Why not use `mappingOfMarkets` to verify the address is a Market? This would reduce the state space used.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `RCNftHubL2.safeTransferFrom` function does not correctly implement the ERC721 spec:  > When using safeTransferFrom, the token contract checks to see that the receiver is an IERC721Receiver, which implies that it knows how to handle ERC721 tokens. [ERC721](https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#IERC721-safeTransferFrom)  This check is not implemented, it just drops the `_data` argument.  ## Impact  Contracts that don't know how to handle ERC721 tokens (are not an `IERC721Receiver`) can accept them but they should not when using `safeTransferFrom` according to spec.  ## Recommended Mitigation Steps  Implement the `IERC721Receiver` check in `safeTransferFrom`.   
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  Usually one tries to avoid toggle functions in blockchains, because it could be that you think that the first transaction you sent was not correctly submitted (but it's just pending for a long time), or you might even be unaware that it was already sent if multiple roles can set it (like with `changeMarketApproval` / `onlyGovernors`) or if it's an msig. This results in potentially double-toggling the state, i.e, it is set to the initial value again.  Some example functions: `changeMarketCreationGovernorsOnly`, `changeMarketApproval`, and the ones that follow.  ## Impact  The outcome of toggle functions is hard to predict on blockchains due to the very async nature and lack of information about pending transactions.  ## Recommended Mitigation Steps  Use functions that accept a specific value as a parameter instead.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `uberOwner` cannot do the same things the owner can. They can "only" set the reference contract for the market.  The same ideas apply to `Treasury` and `Factory`'s `uberOwner`.  ## Impact  The name is misleading as it sounds like the uber-owner is more powerful than the owner.  ## Recommended Mitigation Steps  Uberowner should at least be able to set the owner if not be allowed to call all functions that an `owner` can. Alternatively, rename the `uberOwner`.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `Factory.createMarket` iterates over all `_cardAffiliateAddresses`.  ## Impact  The transactions can fail if the arrays get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.   ## Recommended Mitigation Steps  Perform a `_cardAffiliateAddresses.length == 0 || _cardAffiliateAddresses.length == tokenUris.length` check in `createMarket` instead of silently skipping card affiliate cuts in `Market.initialize`. This would restrict the `_cardAffiliateAddresses` length to the `nftMintingLimit` as well.  
# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The treasury only checks its `globalPause` field but does not check its market-specific `marketPaused` field for `Treasury.sponsor`. A paused market contract can therefore still deposit as a sponsor using `Market.sponsor`  ## Impact  The market-specific pause does not work correctly.  ## Recommended Mitigation Steps  Add checks for `marketPaused` in the Treasury for `sponsor`.   
# Handle  a_delamo   # Vulnerability details  ## Impact On `RCOrderbook`, there are duplicated the state variable `treasuryAddress` and `treasury`  ```     address public treasuryAddress;     IRCTreasury public treasury; ``` ```     constructor(address _factoryAddress, address _treasuryAddress) {         factoryAddress = _factoryAddress;         treasuryAddress = _treasuryAddress;         treasury = IRCTreasury(treasuryAddress);         uberOwner = msgSender();     }  ```  
# Handle  pauliax   # Vulnerability details  ## Impact I can't find a reason why totalNftMintCount in Factory can't be replaced with ERC721 totalSupply() to make it less error-prone. As nfthub.mint issues a new token it should automatically increment totalSupply and this assignment won't be needed:       totalNftMintCount = totalNftMintCount + _tokenURIs.length; Also in function setNftHubAddress you need to manually set _newNftMintCount if you want to change nfthub so an invalid value may crash the system. totalSupply() will eliminate totalNftMintCount and make the system more robust.  ## Recommended Mitigation Steps Replace totalNftMintCount with nfthub totalSupply() in Factory contract.  
# Handle  maplesyrup   # Vulnerability details  ## Impact 1 - Low Risk    - Possible incorrect use of variables are at stake which may have bad side effects to the contract if implemented incorrectly.  ## Proof of Concept  According to the Slither-analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing), shadowing local variables is naming conventions found in two or more variables that are similar. Although they do not pose any immediate risk to the contract, incorrect usage of the variables is possible and can cause serious issues if the developer does not pay close attention.   It is recommended that the naming of the following variables should be changed slightly to avoid any confusion:   -------------------------------------------------------------------  RCOrderbook._updateBidInOrderbook(address,address,uint256,uint256,uint256,RCOrderbook.Bid)._owner   (contracts/RCOrderbook.sol line(s)#358) shadows:  Ownable._owner <------(state variable)  (node_modules/@openzeppelin/contracts/access/Ownable.sol line(s)#19)    -------------------------------------------------------------------  RCOrderbook.closeMarket()._owner   (contracts/RCOrderbook.sol line(s)#639) shadows:  Ownable._owner <------(state variable)  (node_modules/@openzeppelin/contracts/access/Ownable.sol line(s)#19)   -------------------------------------------------------------------  ## Tools Used  Solidity Compiler 0.8.4 Hardhat v2.3.3 Slither v0.8.0  Compiled, Tested, Deployed contracts on a local hardhat network.  Ran Slither-analyzer for further detecting and testing.  ## Recommended Mitigation Steps  (Worked best under python venv) 1. Clone Project Repository 2. Run Project against Hardhat network;    compile and run default test on contracts. 3. Installed slither analyzer:   https://github.com/crytic/slither 4. Ran [$ slither .] against RCOrderbook.sol and all contracts to verify results  
# Handle  pauliax   # Vulnerability details  ## Impact   _amount -= (_amount - marketBalance); is basically the same as:    _amount = marketBalance;   
# Handle  a_delamo   # Vulnerability details  ## Impact  The method `_collectRentAction` contains the following code: ``` ...            } else if (!_foreclosed && _limitHit && _marketLocked) {                 // CASE 4                 // didn't foreclose AND                 // did hit time limit AND                 // did lock market                 // THEN refund rent between the earliest event and now                 if (_cardTimeLimitTimestamp < marketLockingTime) {                     // time limit hit before market locked                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = block.timestamp - _cardTimeLimitTimestamp;                 } else {                     // market locked before time limit hit                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = block.timestamp - marketLockingTime;                 }             } else if (_foreclosed && !_limitHit && !_marketLocked) {                 // CASE 5                 // did foreclose AND                 // didn't hit time limit AND                 // didn't lock market                 // THEN rent OK, find new owner                 _timeOfThisCollection = _timeUserForeclosed;                 _newOwner = true;                 _refundTime = 0;             } else if (_foreclosed && !_limitHit && _marketLocked) {                 // CASE 6                 // did foreclose AND                 // didn't hit time limit AND                 // did lock market                 // THEN if foreclosed first rent ok, otherwise refund after locking                 if (_timeUserForeclosed < marketLockingTime) {                     // user foreclosed before market locked                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else {                     // market locked before user foreclosed                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = block.timestamp - marketLockingTime;                 }             } else if (_foreclosed && _limitHit && !_marketLocked) {                 // CASE 7                 // did foreclose AND                 // did hit time limit AND                 // didn't lock market                 // THEN if foreclosed first rent ok, otherwise refund after limit                 if (_timeUserForeclosed < _cardTimeLimitTimestamp) {                     // user foreclosed before time limit                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else {                     // time limit hit before user foreclosed                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;                 }             } else {                 // CASE 8                 // did foreclose AND                 // did hit time limit AND                 // did lock market                 // THEN (╯°益°)╯彡┻━┻                 if (                     _timeUserForeclosed <= _cardTimeLimitTimestamp &&                     _timeUserForeclosed < marketLockingTime                 ) {                     // user foreclosed first (or at same time as time limit)                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else if (                     _cardTimeLimitTimestamp < _timeUserForeclosed &&                     _cardTimeLimitTimestamp < marketLockingTime                 ) {                     // time limit hit first                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;                 } else {                     // market locked first                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = _timeUserForeclosed - marketLockingTime;                 } ... ```  On the case 6, instead of doing `_refundTime = _timeUserForeclosed - marketLockingTime;` like the following cases, is doing `_refundTime = block.timestamp - marketLockingTime;`. This could lead to funds being drained by the miscalculation.   
# Handle  a_delamo   # Vulnerability details  ## Impact  On `RCTreasury`, we have the method `collectRentUser`. This method is public, so anyone can call it using whatever user and whatever timestamp.  So, calling this method using `user = XXXXX` and `_timeToCollectTo = type(uint256).max)`, would make `isForeclosed[user] = true`.  ```     function collectRentUser(address _user, uint256 _timeToCollectTo)         public         override         returns (             uint256 newTimeLastCollectedOnForeclosure         )     {         require(!globalPause, "Global pause is enabled");         assert(_timeToCollectTo != 0);         if (user[_user].lastRentCalc < _timeToCollectTo) {             uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);              if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {                 // The User has run out of deposit already.                 uint256 previousCollectionTime = user[_user].lastRentCalc;                  /*             timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)                                   = (now - previousCollectionTime) * (usersDeposit/rentOwed)             */                 uint256 timeUsersDepositLasts =                     ((_timeToCollectTo - previousCollectionTime) *                         uint256(user[_user].deposit)) / rentOwedByUser;                 /*             Users last collection time = previousCollectionTime + timeTheirDepsitLasted             */                 rentOwedByUser = uint256(user[_user].deposit);                 newTimeLastCollectedOnForeclosure =                     previousCollectionTime +                     timeUsersDepositLasts;                 _increaseMarketBalance(rentOwedByUser, _user);                 user[_user].lastRentCalc = SafeCast.toUint64(                     newTimeLastCollectedOnForeclosure                 );                 assert(user[_user].deposit == 0);                 isForeclosed[_user] = true;                 emit LogUserForeclosed(_user, true);             } else {                 // User has enough deposit to pay rent.                 _increaseMarketBalance(rentOwedByUser, _user);                 user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);             }             emit LogAdjustDeposit(_user, rentOwedByUser, false);         }     } ```  Now, we can do the same for all the users bidding for a specific token.  Finally, I can become the owner of the token by just calling `newRental` and using a small price. `newRental` will iterate over all the previous bid and will remove them because there are foreclosed.   ## Tools Used Editor  ## Recommended Mitigation Steps  `collectRentUser` should be private and create a new public method with `onlyOrderbook` modifier  
# Handle  0xRajeev   # Vulnerability details  ## Impact  ERC721 standard and implementation allows the use of approved addresses to affect transfers besides the token owners. However, the L2 NFT Hub implementation deviates from ERC721 by ignoring the presence of any approvers in the overriding function implementations of transferFrom() and safeTransferFrom().   Impact: The system interactions with NFT platforms may not work if they expect ERC721 adherence. Users who interact via approved addresses will see their transfers failing for their approved addresses.   Given that the key value proposition of this project is the use of NFTs, the expectation will be that it is fully compatible with ERC721.   ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/nfthubs/RCNftHubL2.sol#L212-L234  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/00128bd26061986d10172573ceec914a4f3b4d3c/contracts/token/ERC721/ERC721.sol#L158   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add support for approval in NFT transfers.  
# Handle  pauliax   # Vulnerability details  ## Impact questionFinalised is redundant, it is only set to true or false but never queried or used in any meaningful way.  ## Recommended Mitigation Steps Remove questionFinalised from the codebase.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Orderbook.removeBids() as commented “///remove bids in closed markets for a given user ///this can reduce the users bidRate and chance to foreclose”  removeOldBids() is performed currently in Market.newRental() and Treasury.deposit() to  “do some cleaning up, it might help cancel their foreclosure” as commented. However, this is missing in the withdrawDeposit() function where the need is the most because user is removing deposit which may lead to foreclosure and is even commented as being useful on L356.  Impact: If we do not remove closed market bids during withdrawDeposit, the closed market bids still get accounted in user's bidrate in the conditional on L357 and therefore do not prevent the foreclosure in withdrawDeposit that may happen in L357-L367. User may get foreclosed because of mis-accounted closed-market bids in the order book.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCOrderbook.sol#L671-L713  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L356  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L357-L367  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L704-L705  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L300-L301   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add call to removeOldBids() on L355 of withdrawDeposit() of Treasury.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The code base uses a mix of named return values and explicit returns. In some places, the named return values are never assigned to and explicit returns are used instead.   Impact: This makes code readability and auditability hard potentially leading to errors and missed vulnerabilities.  ## Proof of Concept  Named return value shouldContinue is never assigned in _collectRentAction(): https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L856   Named return value didUpdateEverything is never assigned in _collectRent(): https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1040  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unassigned named return variables and be consistent in named vs explicit return usage.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  In Market sponsor() the call to treasury.checkSponsorship() checks allowance and balance  of user. This is redundant because the call to treasury.sponsor downstream checks allowance again and insufficient balance would cause any transfer to fail anyway.  Impact: Given the gas sensitivity of the code base, removing this redundant check could help conserve gas and prevent any DoS from breaking gas limits.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L810  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L386-L396  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L474-L478   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove redundant checks.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The exitedTimestamp flag is used to prevent front-running of user exiting and re-entering in the same block. The setting of this flag in exit() should really be inside the conditionals and triggered only if current owner or if bidExists. It currently assumes that either of the two will always be true which may not necessarily be the case.  Impact: A user accidentally exiting a card he doesn't own or have a bid for currently will be marked as exited and prevented from a newRental in the same block. User can prevent one's own newRental from succeeding, because it was accidentally triggered, by front-running it himself with an exit. There could be other more realistic scenarios.   ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L784-L804  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L56-L57  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L678-L681   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Set exitedTimestamp flag only when the conditionals are true within exit()  
# Handle  0xRajeev   # Vulnerability details  ## Impact  rentAllCards() requires the sender to specify a _maxSumOfPrices parameter which specifies “limit to the sum of the bids to place” as specified in the Natspec @param comment. This is apparently for front-run protection.  However, this function parameter constraint for _maxSumOfPrices is broken in the function implementation which leads to the total of bids places greater than the _maxSumOfPrices specified.  Impact: The user may not have sufficient deposit, be foreclosed and/or impacted on other bids/markets.  ## Proof of Concept  Scenario: Assume two cards for a market with current winning rentals of 50 each. _maxSumofPrices = 101 passes check on L643 but then the forced 10% increase on L650 (assuming sender is not the owner of either card) causes newRentals to be called with 55 for each card thus totalling to 110 which is > 101 as requested by the user.  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L636-L637  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L639-L657   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Modify the max sum of prices check logic to consider the 10% increase scenarios. Document and suggest the max sum of prices for the user in the UI based on the card prices and 10% requirement depending on card ownership.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Missing _checkState(States.OPEN) on first line of rentAllCards() as specified on L617. These core market functions are supposed to operate only when market is open but the missing check allows control to proceed further in the control flow. In this case, the function proceeds to call newRental() which has a conditional check state == States.OPEN and silently returns success otherwise, without reverting.  Impact: rentAllCards does not fail if executed when market is closed or locked. newRental returns silently without failure when market is closed or locked.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L617  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L637-L658  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L672   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a require() to check market open state in the beginning of all core market functions and revert with an informative error string otherwise.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Misplaced zero-address check for nfthub on L595 in createMarket() because nfthub cannot be 0 at this point as nfthub.addMarket() on L570 would have already reverted if that were the case.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L570  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L595  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move nfthub zero-address check to before the call to nfthub.addMarket().  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Once market is approved and operational, changing approval to false should not be allowed or else it will prevent NFTs from being withdrawn to mainnet. All other Governor controlled variables are used during market creation and not thereafter, except this one. The other onlyGovernors functions only affect state before market creation but this one affects after creation.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L382-L391  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L326-L330   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Once market is approved and operational, changing approval to false should not be allowed.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The general definition of basis points is 100 bps = 1%. The usage here, 1000 bps = 100%, deviates from generally accepted definition and could cause confusion among users/creators/affiliates or potential miscalculations.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L228  https://www.investopedia.com/terms/b/basispoint.asp  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Document the used definition of basis points or switch to the generally accepted definition.  
# Handle  jvaqa   # Vulnerability details  Redundant require() statement in RCFactory.createMarket()  ## Impact  RCFactory.createMarket() contains two require() statements side-by-side both checking the value of the relative values of _timestamps[0] and block.timestamp. // [1]  However, there is no case where the first require() statement would be triggered without the second require() statement also being triggered, since advancedWarning cannot have a negative value. // [2]  Thus, the first require() statement is redundant, and unnecessarily uses gas.  ## Proof of Concept  Alice can call RCFactory.createMarket() with an advancedWarning value greater than zero, and a _timestamps[0] value less than block.timestamp.  ## Recommended Mitigation Steps  Remove this require statement:  require(                 _timestamps[0] >= block.timestamp,                 "Market opening time not set"             ); // [3]   [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L520  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L524  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L520  
# Handle  jvaqa   # Vulnerability details  RCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0], even though proper functioning requires them to be so.  ## Impact  IRCMarket defines a sequence of events that each market should progress through sequentially, CLOSED, OPEN, LOCKED, WITHDRAW. // [1]  The comments explicitly state that _incrementState() should be called "thrice". // [2]  However, it is possible to create a market where these events do not occur sequentially.  You can create a market where the marketOpeningTime is later than the marketLockingTime and oracleResolutionTime.  This is because although RCFactory checks to ensure that _timestamps[2] is greater than _timestamps[1], it does not check to ensure that _timestamps[1] is greater than _timestamps[0]. // [3]  This is also because although RCFactory checks to ensure that _timestamps[0] is equal to or greater than block.timestamp, it makes no check for a minimum value for _timestamps[1] or _timestamps[2], or a relative check between the value of _timestamps[0] and _timestamps[1]. // [4]  Thus, you can create a market where the marketLockingTime and the oracleResolutionTime occur before the marketOpeningTime.  ## Proof of Concept  When calling RCFactory.createMarket(), Alice can supply 0 as the argument for _timestamps[1] and _timestamps[2], and any value equal to or greater than block.timestamp for _timestamps[0]. // [5]  ## Recommended Mitigation Steps  Add the following check to RCFactory.createMarket():  require(     _timestamps[0] < _timestamps[1],     "market must begin before market can lock" );  [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L7  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1093  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L539  [4] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L521  [5] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L468  
# Handle  JMukesh   # Vulnerability details  ## Impact   constructor of RCorderbook.sol lacks zero address validation , since parameter of costructor are used initialize state variable which are used in other function of the contract , error in these state variable can lead to redeployment of contract  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L106  ## Tools Used manual review  ## Recommended Mitigation Steps add require condition to check for zero address  
# Handle  JMukesh   # Vulnerability details  ## Impact checking the return value from function indicates ether function call was success or failure because of that, we should utilise the return value   ## Proof of Concept  In RCmarket.sol  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1025  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1060  ## Tools Used slither  ## Recommended Mitigation Steps  Utilize return value  
# Handle  jvaqa   # Vulnerability details  RCTreasury.addToWhitelist() will erroneously remove user from whitelist if user is already whitelisted  ## Impact  The comments state that calling addToWhitelist() should add a user to the whitelist. [1]  However, since the implementation simply flips the user's whitelist bool, if the user is already on the whitelist, then calling addToWhitelist() will actually remove them from the whitelist. [2]  Since batchAddToWhitelist() will repeatedly call addToWhitelist() with an entire array of users, it is very possible that someone could inadvertently call addToWhitelist twice for a particular user, thereby leaving them off of the whitelist. [3]   ## Proof of Concept  If a governor calls addToWhitelist() with the same user twice, the user will not be added to the whitelist, even though the comments state that they should.  ## Recommended Mitigation Steps  Change addToWhitelist to only ever flip a user's bool to true. To clarify the governor's intention, create a corresponding removeFromWhitelist and batchRemoveFromWhitelist which flip a user's bool to false, so that the governor does not accidently remove a user when intending to add them.   Change this:  isAllowed[_user] = !isAllowed[_user]; // [4]  To this:  isAllowed[_user] = true; // [4]  And add this:      /// @notice Remove a user to the whitelist     function removeFromWhitelist(address _user) public override {         IRCFactory factory = IRCFactory(factoryAddress);         require(factory.isGovernor(msgSender()), "Not authorised");         isAllowed[_user] = false;     }      /// @notice Remove multiple users from the whitelist     function batchRemoveFromWhitelist(address[] calldata _users) public override {         for (uint256 index = 0; index < _users.length; index++) {             removeFromWhitelist(_users[index]);         }     }   [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L209  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L213  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L217  [4] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L213   
# Handle  pauliax   # Vulnerability details  ## Impact This function sponsor should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary _sponsorAddress address and transfer tokens from them if the allowance is > 0:     /// @notice ability to add liqudity to the pot without being able to win.     /// @dev called by Factory during market creation     /// @param _sponsorAddress the msgSender of createMarket in the Factory     function sponsor(address _sponsorAddress, uint256 _amount)         external         override     {         _sponsor(_sponsorAddress, _amount);     }  ## Recommended Mitigation Steps Check that the sender is a factory contract.  
# Handle  pauliax   # Vulnerability details  ## Impact function circuitBreaker calls _incrementState but later sets the state itself again:     function _incrementState() internal {         assert(uint256(state) < 4);         state = States(uint256(state) + (1));         emit LogStateChange(uint256(state));     }      function circuitBreaker() external {         require(             block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),             "Too early"         );         _incrementState();         orderbook.closeMarket();         state = States.WITHDRAW;     }  ## Recommended Mitigation Steps state = States.WITHDRAW; shouldn't be there, or another solution would be to put it before orderbook.closeMarket(); and remove _incrementState(); instead but then LogStateChange event will also need to be emitted manually.  
# Handle  pauliax   # Vulnerability details  ## Impact contract RCTreasury has an unused storage variable nfthub and setNftHubAddress function. This variable was moved to the Factory contract so it is useless here.  ## Recommended Mitigation Steps Remove nfthub variable and function setNftHubAddress.  
# Handle  pauliax   # Vulnerability details  ## Impact function safeTransferFrom is almost identical to function transferFrom. It would be better to reduce code duplication by re-using the code.  ## Recommended Mitigation Steps    function safeTransferFrom(         address from,         address to,         uint256 tokenId,         bytes memory _data     ) public override {         transferFrom(from, to, tokenId);         _data;     }  
# Handle  pauliax   # Vulnerability details  ## Impact event WithdrawnBatch in contract RCNftHubL2 is not used anywhere.  ## Recommended Mitigation Steps Remove or use it where intended.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function withdrawDeposit of RCTreasury.sol, the value of isForeclosed[_msgSender]  is set to true. In the next statement it is overwritten with a new value. So the first statement seem redundant. However this is not the case because it is retrieved from the function removeUserFromOrderbook (see proof of concept below)  As this is not obvious it is probably useful to add a comment so future developers can understand this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L322 function withdrawDeposit(uint256 _amount, bool _localWithdrawal)  external  override  balancedBooks  {   ...      isForeclosed[_msgSender] = true;   // this seems to be redundant     isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook( _msgSender );  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L575   function removeUserFromOrderbook(address _user)  external override returns (bool _userForeclosed) {         require(treasury.isForeclosed(_user), "User must be foreclosed");   // this checks the isForeclosed value from the treasury contract   ## Tools Used  ## Recommended Mitigation Steps Add a comment to  isForeclosed[_msgSender] = true;  explaining this line is important.   
# Handle  gpersoon   # Vulnerability details  ## Impact The function payout of RCTreasury.sol doesn't undo the isForeclosed state of a user. This would be possible because with a payout a user will receive funds so he can lose his isForeclosed status.  For example the function refundUser does check and update the isForeclosed status.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L429  function payout(address _user, uint256 _amount)  external override balancedBooks onlyMarkets returns (bool) {         require(!globalPause, "Payouts are disabled");         assert(marketPot[msgSender()] >= _amount);         user[_user].deposit += SafeCast.toUint128(_amount);         marketPot[msgSender()] -= _amount;         totalMarketPots -= _amount;         totalDeposits += _amount;         emit LogAdjustDeposit(_user, _amount, true);         return true;     }  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L447  function refundUser(address _user, uint256 _refund)  external override onlyMarkets {      ...         if ( isForeclosed[_user] && user[_user].deposit > user[_user].bidRate / minRentalDayDivisor )  {             isForeclosed[_user] = false;             emit LogUserForeclosed(_user, false);         }  ## Tools Used  ## Recommended Mitigation Steps Check and update the isForeclosed state in the payout function  
# Handle  gpersoon   # Vulnerability details  ## Impact The function deposit of RCTreasury.sol resets the isForeclosed state and emits LogUserForeclosed, if the use have enough funds. However this also happens if the user is not Foreclosed and so the emit is redundant and confusing.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L279 function deposit(uint256 _amount, address _user) public override balancedBooks returns (bool) {    ....         // this deposit could cancel the users foreclosure         if ( (user[_user].deposit + _amount) > (user[_user].bidRate / minRentalDayDivisor) ) {             isForeclosed[_user] = false;             emit LogUserForeclosed(_user, false);         }         return true;     }  ## Tools Used  ## Recommended Mitigation Steps Only do the emit when isForeclosed was true  
# Handle  gpersoon   # Vulnerability details  ## Impact The function addToWhitelist of RCTreasury.sol does a call to the factory contract, however the factoryAddress might not be initialized, because it is set via a different function (setFactoryAddress). The function addToWhitelist will revert when it calls a 0 address, but it might be more difficult to troubleshoot.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L233    function setFactoryAddress(address _newFactory) external override {         ...         factoryAddress = _newFactory;     }  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L210     function addToWhitelist(address _user) public override {         IRCFactory factory = IRCFactory(factoryAddress);         require(factory.isGovernor(msgSender()), "Not authorised");         isAllowed[_user] = !isAllowed[_user];     }  ## Tools Used  ## Recommended Mitigation Steps Verify that factoryAddress is set in the function addToWhitelist, for example using the following code.  require(factory != address(0), "Must have an address");  
# Handle  heiho1   # Vulnerability details  ## Impact  RCMarket#tokenURI(uint256) is declared external in the IRCMarket interface but is declared public in the RCMarket implementation.   This is inconsistent and affect the gas behavior of the function: https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L27  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L344  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L344  ## Tools Used  Slither  ## Recommended Mitigation Steps  Mark the implementation method as external.  
# Handle  heiho1   # Vulnerability details  ## Impact  RCMarket#initialize(uint256,uint32[],uint256,uint256,address,address,address[],address,string) has a potentially expensive loop that modifies state continually over an indeterminate number of cards.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L252  ## Tools Used  Slither  ## Recommended Mitigation Steps  Potentially a gas-expensive loop because of arbitrary length of _cardAffiliateAddresses possibly assigning to state variable cardAffiliateCut multiple times. * It appears that the loop may be exited on the first cardAffiliateCut = 0 to optimize gas * Alternatively a local variable may be assigned temporarily and then assigned to state: https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop   
# Handle  heiho1   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Minimal code quality issue.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCFactory.sol#L26  The function setminimumPriceIncreasePercent does not follow the code standard of camel casing of function names.    ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Rename the function to have proper camel casing.  
# Handle  gpersoon   # Vulnerability details  ## Impact Within RCMarket.sol the functions ownerOf and onlyTokenOwner do not check if the _cardId/_token is smaller than numberOfCards. So it's possible to supply a larger number and access cards of other markets. The most problematic seems to be upgradeCard. Here the check for isMarketApproved can be circumvented by trying to move the card via another market.  You can still only move cards you own.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L338     function ownerOf(uint256 _cardId) public view override returns (address) {         uint256 _tokenId = _cardId + totalNftMintCount; // doesn't check if _cardId < numberOfCards         return nfthub.ownerOf(_tokenId);     }  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L313   modifier onlyTokenOwner(uint256 _token) {         require(msgSender() == ownerOf(_token), "Not owner"); // _token could be higher than numberOfCards,         _;     }    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {   // _card  could be higher than numberOfCards,         _checkState(States.WITHDRAW);         require(             !factory.trapIfUnapproved() ||                 factory.isMarketApproved(address(this)),   // this can be circumvented by calling the function via another market             "Upgrade blocked"         );         uint256 _tokenId = _card + totalNftMintCount;    // _card  could be higher than numberOfCards, thus accessing a card in another market         _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place         nfthub.withdrawWithMetadata(_tokenId);         emit LogNftUpgraded(_card, _tokenId);     }    ## Tools Used  ## Recommended Mitigation Steps Add the following to ownerOf: require(_card < numberOfCards, "Card does not exist");   
# Handle  gpersoon   # Vulnerability details  ## Impact A value of 1000 is used to indicate 100%. This value is hardcoded on several places. It's saver to use a constant, to prevent mistakes in future updates.  ## Proof of Concept .\RCFactory.sol:    /// @dev in basis points (so 1000 = 100%) .\RCFactory.sol:                1000, .\RCMarket.sol:                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) - .\RCMarket.sol:            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) - .\RCMarket.sol:            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000); .\RCMarket.sol:                (1000); .\RCMarket.sol:            _remainingPot = (totalRentCollected * _remainingCut) / (1000); .\RCMarket.sol:            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut; .\RCMarket.sol:            (_rentCollected * _remainingCut) / (1000); .\RCMarket.sol:            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000); .\RCMarket.sol:            uint256 _payment = (totalRentCollected * _cut) / (1000);  ## Tools Used grep  ## Recommended Mitigation Steps Replace 1000 with a constant.   
# Handle  gpersoon   # Vulnerability details  ## Impact For the enums Mode and State, checks are made that the variables are within bounds. Here specific size are used, e.g. 2 and 4. If the size of the enums would be changed in the future, those numbers don't change automatically. Also solidity provides in-built check to check that variables are within bounds, which could be used instead. This also make the code more readable.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L202 enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE} function initialize(      ...         assert(_mode <= 2);        // can be removed       ...          mode = Mode(_mode);  // this makes sure: 0<=mode<=2   // move to top  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/interfaces/IRCMarket.sol#L7     enum States {CLOSED, OPEN, LOCKED, WITHDRAW}  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1094     function _incrementState() internal {         assert(uint256(state) < 4);                 // can be removed         state = States(uint256(state) + (1));  // this makes sure: 0<=state<=3         emit LogStateChange(uint256(state));     }  ## Tools Used  ## Recommended Mitigation Steps For function initialize: Remove the "assert(_mode <= 2);" and move the statement "mode = Mode(_mode);" to the top of the function and add a comment  For function _incrementState:  Remove "assert(uint256(state) < 4);" and add a comment at "state = States(uint256(state) + (1));"  
# Handle  gpersoon   # Vulnerability details  ## Impact The number 1000000  is used in the constructor of RCTreasury.sol. This is difficult to read in a glance. Solidity allows the use of an underscore ( _ ) to make numbers more readable.  ## Proof of Concept https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L114 setMaxContractBalance(1000000 ether); // 1m  ## Tools Used  ## Recommended Mitigation Steps  Replace 1000000 with 1_000_000   
# Handle  gpersoon   # Vulnerability details  ## Impact The variable _realitioAddress of RCMarket.sol isn't used. The variable realitio seems to used instead. Two variables with the same purpose is confusing.  ## Proof of Concept https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L121     IRealitio public realitio;     address public _realitioAddress;  ## Tools Used  ## Recommended Mitigation Steps Remove     address public _realitioAddress;  
# Handle  gpersoon   # Vulnerability details  ## Impact Several variables are only set once. So it might be useful to make them immutable to reduced the change of accidental updates See the "proof of concept" for examples.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol uint256 public numberOfCards; uint256 public totalNftMintCount; IRCTreasury public treasury; IRCFactory public factory; IRCNftHubL2 public nfthub; IRCOrderbook public orderbook; uint256 public minimumPriceIncreasePercent; uint256 public minRentalDayDivisor; uint256 public maxRentIterations; uint32 public marketOpeningTime; uint32 public override marketLockingTime; uint32 public oracleResolutionTime;    address public artistAddress; address public affiliateAddress; address public marketCreatorAddress; uint256 public creatorCut;     address[] public cardAffiliateAddresses; address public arbitrator; IRealitio public realitio;  //https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCFactory.sol#L113 IRCTreasury public override treasury;      ## Tools Used  ## Recommended Mitigation Steps Use the immutable keyword where possible   
# Handle  axic   # Vulnerability details  ## Impact  Some major tokens went live before ERC20 was finalised, resulting in a discrepancy whether the transfer functions a) should return a boolean or b) revert/fail on error. The current best practice is that they should revert, but return “true” on success. However, not every token claiming ERC20-compatibility is doing this — some only return true/false; some revert, but do not return anything on success. This is a well known issue, heavily discussed since mid-2018.  Today many tools, including OpenZeppelin, offer a wrapper for “safe ERC20 transfer”: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol  RealityCards is not using such a wrapper, but instead tries to ensure successful transfers via the `balancedBooks` modifier:  ```     modifier balancedBooks {         _;         // using >= not == in case anyone sends tokens direct to contract         require(             erc20.balanceOf(address(this)) >=                 totalDeposits + marketBalance + totalMarketPots,             "Books are unbalanced!"         );     } ```  This modifier is present on most functions, but is missing on `topupMarketBalance`: ```     function topupMarketBalance(uint256 _amount) external override {         erc20.transferFrom(msgSender(), address(this), _amount);         if (_amount > marketBalanceDiscrepancy) {             marketBalanceDiscrepancy = 0;         } else {             marketBalanceDiscrepancy -= _amount;         }         marketBalance += _amount;     } ```  In the case an ERC20 token which is not reverting on failures is used, a malicious actor could call `topupMarketBalance` with a failing transfer, but also move the value of `marketBalance` above the actual holdings. After this, `deposit`, `withdrawDeposit`, `payRent`, `payout`, `sponsor`, etc. could be locked up and always failing with “Books are unbalanced”.  ## Proof of Concept  Anyone can call `topupMarketBalance` with some unrealistically large number, so that `marketBalance` does not overflow, but is above the actually helping balances. This is only possible if the underlying ERC20 used is not reverting on failures, but return “false” instead.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  1. Use something like OpenZeppelin’s SafeERC20 2. Set up an allow list for tokens, which are knowingly safe 3. Consider a different approach to the `balancedBooks` modifier   
# Handle  axic   # Vulnerability details  ## Impact  In `lib/NativeMetaTransactions.sol` there is a frequently used helper `msgSender`: ```     function msgSender() internal view returns (address payable sender) {         if (msg.sender == address(this)) {             bytes memory array = msg.data;             uint256 index = msg.data.length;             assembly {                 // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.                 sender := and(                     mload(add(array, index)),                     0xffffffffffffffffffffffffffffffffffffffff                 )             }         } else { ... ```  Even though only the last 20-bytes matter, the `bytes memory array = msg.data;` line causes the *entire* calldata to be copied to memory. This is exaggerated by the fact, that if `msgSender()` is called multiple times in a transaction, the calldata will be also copied multiple times as memory is not freed.  ## Proof of Concept  N/A  ## Tools Used  Manual review.  ## Recommended Mitigation Steps  There are multiple ways to avoid this:  1. Make use of calldata slices and conversions  Something along the lines of (untested!): ```             // Copy last 20 bytes             bytes calldata data = msg.data[(msg.data.length - 20):];             sender = payable(address(uint160(bytes20(data)))); ```  2. Implementing purely in assembly  The OpenZeppelin implementation (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol#L21-L30) is an example of an optimised assembly version: ```             assembly {                 sender := shr(96, calldataload(sub(calldatasize(), 20)))             } ```  3. Combining slices and assembly  One must note that the pure assembly version is obviously the most gas efficient, at least today.   
