# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CNote.sol#L70-L87   # Vulnerability details  Having no reentrancy control and updating the records after external interactions allows for funds draining by reentrancy.  Setting the severity to medium as this is conditional to transfer flow control introduction on future upgrades, but the impact is up to the full loss of the available funds by unrestricted borrowing.  ## Proof of Concept  CNote runs doTransferOut before borrowing accounts are updated:  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CNote.sol#L70-L87  ```         /*          * We invoke doTransferOut for the borrower and the borrowAmount.          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.          *  On success, the cToken borrowAmount less of cash.          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.          */         doTransferOut(borrower, borrowAmount);         require(getCashPrior() == 0,"CNote::borrowFresh: Error in doTransferOut, impossible Liquidity in LendingMarket");     //Amount minted by Accountant is always flashed from account          /* We write the previously calculated values into storage */         accountBorrows[borrower].principal = accountBorrowsNew;         accountBorrows[borrower].interestIndex = borrowIndex;         totalBorrows = totalBorrowsNew;          /* We emit a Borrow event */         emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);     } ```  Call sequence here is borrow() -> borrowInternal() -> borrowFresh() -> doTransferOut(), which transfers the token to an external recipient:  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CErc20.sol#L189-L200  ```     /**      * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified      *      it is >= amount, this should not revert in normal conditions.      *      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca      */     function doTransferOut(address payable to, uint amount) virtual override internal {         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);         token.transfer(to, amount); ```  There an attacker can call exitMarket() that have no reentrancy control to remove the account of the debt:  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/Comptroller.sol#L167-L174  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/ComptrollerG7.sol#L157-L164  ```     /**      * @notice Removes asset from sender's account liquidity calculation      * @dev Sender must not have an outstanding borrow balance in the asset,      *  or be providing necessary collateral for an outstanding borrow.      * @param cTokenAddress The address of the asset to be removed      * @return Whether or not the account successfully exited the market      */     function exitMarket(address cTokenAddress) override external returns (uint) { ```  This attack was carried out several times:  https://certik.medium.com/fei-protocol-incident-analysis-8527440696cc   ## Recommended Mitigation Steps  Consider moving accounting update before funds were sent out, for example as it is done in CToken's borrowFresh():  ``` https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CToken.sol#L595-L609          /*          * We write the previously calculated values into storage.          *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.         `*/         accountBorrows[borrower].principal = accountBorrowsNew;         accountBorrows[borrower].interestIndex = borrowIndex;         totalBorrows = totalBorrowsNew;          /*          * We invoke doTransferOut for the borrower and the borrowAmount.          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.          *  On success, the cToken borrowAmount less of cash.          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.          */         doTransferOut(borrower, borrowAmount); ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Governance/GovernorBravoDelegate.sol#L115   # Vulnerability details  ## Impact  `state()` function cannot view the state from any proposal except for the latest one.  ## Proof of Concept  ```solidity require(proposalCount >= proposalId && proposalId > initialProposalId, "GovernorBravo::state: invalid proposal id"); ```  Currently `proposalCount` needs to be bigger or equal to `proposalId`.  Assuming `proposalId` is incremented linearly in conjunction with `proposalCount`, this implies only the most recent `proposalId` will pass the `require()` check above. All other proposals will not be able to have their states checked via this function.   ## Tools Used Manual Review.  ## Recommended Mitigation Steps  Change above function to `proposalCount <= proposalId` (assuming `proposalId` is set linearly, which currently is not enforced by code).   
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L43 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L114 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L198 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L310   # Vulnerability details  ## Impact  The contract expects the balance of the underlying token to == 0 at all points when calling the contract functions by requiring getCashPrior() == 0, which checks token.balanceOf(address(this)) where token is the underlying asset.  An attacker can transfer any amount of the underlying asset directly to the contract and make all of the functions requiring getCashPrior() == 0 to revert.   ## Proof of Concept [CNote.sol#L43](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L43) [CNote.sol#L114](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L114) [CNote.sol#198](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L198) [CNote.sol#310](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L310)  1. Attacker gets any balance of Note (amount = 1 token) 2. Attacker transfers the token to CNote which uses Note as an underlying asset, by calling note.transfer(CNoteAddress, amount). The function is available since Note inherits from ERC20 3. Any calls to CNote functions now revert due to getCashPrior() not being equal to 0  ## Recommended Mitigation Steps Instead of checking the underlying token balance via balanceOf(address(this)) the contract could hold an internal balance of the token, mitigating the impact of tokens being forcefully transferred to the contract.  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L104   # Vulnerability details  ## Impact WETH.allowance() returns wrong result. I can't find other contracts that use this function but WETH.sol is a base contract and it should be fixed properly.   ## Proof of Concept In this function, the "return" keyword is missing and it will always output 0 in this case.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps L104 should be changed like below. ``` return _allowance[owner][spender]; ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CNote.sol#L14   # Vulnerability details  ## Impact  Affected code:  - [https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CNote.sol#L14](https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CNote.sol#L14)  The function `_setAccountantContract()` is supposed to be called after contract initialization, so that the `accountant` is immediately set. However, this function completely lacks any access control (it’s just `public`) so an attacker can monitor the mempool and frontrun the transaction in order to become both `accountant` and `admin`  ## Tools Used  Editor  ## Recommended Mitigation Steps  The function should:  1. have a guard that regulates access control 2. not set the `admin` too, which is dangerous and out of scope  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47   # Vulnerability details  ## Impact  Affected code:  - [https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47](https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47)  `WETH.sol` is almost copied from the infamous WETH contract that lives in mainnet. This contract is supposed to receive the native currency of the blockchain (for example ETH) and wrap it into a tokenized, ERC-20 form. This contract computes the `totalSupply()` using the balance of the contract itself stored in the `balanceOf` mapping, when instead it should be using the native `balance` function. This way, `totalSupply()` always returns zero as the `WETH` contract itself has no way of calling `deposit` to itself and increase its own balance  ## Proof of Concept  1. Alice transfers 100 ETH to `WETH.sol` 2. Alice calls `balanceOf()` for her address and it returns 100 WETH 3. Alice calls `totalSupply()`, expecting to see 100 WETH, but it returns 0  ## Tools Used  Editor  ## Recommended Mitigation Steps  ```jsx function totalSupply() public view returns (uint) {     return address(this).balance } ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Note.sol#L13-L31   # Vulnerability details  ```solidity function _mint_to_Accountant(address accountantDelegator) external {     if (accountant == address(0)) {         _setAccountantAddress(msg.sender);     }     require(msg.sender == accountant, "Note::_mint_to_Accountant: ");     _mint(msg.sender, type(uint).max); }  function RetAccountant() public view returns(address) {     return accountant; }  function _setAccountantAddress(address accountant_) internal {     if(accountant != address(0)) {         require(msg.sender == admin, "Note::_setAccountantAddress: Only admin may call this function");     }     accountant = accountant_;     admin = accountant; } ```  `_mint_to_Accountant()` calls `_setAccountantAddress()` when `accountant == address(0)`, which will always be the case when `_mint_to_Accountant()` is called for the first time.  And `_setAccountantAddress()` only checks if `msg.sender == admin` when `accountant != address(0)` which will always be `false`, therefore the access control is not working.  L17 will then check if `msg.sender == accountant`, now it will always be the case, because at L29, `accountant` was set to `msg.sender`.  
# Lines of code  https://github.com/Plex-Engineer/zeroswap/blob/03507a80322112f4f3c723fc68bed0f138702836/contracts/uniswapv2/libraries/UniswapV2Library.sol#L20-L28   # Vulnerability details  ```solidity function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {     (address token0, address token1) = sortTokens(tokenA, tokenB);     pair = address(uint(keccak256(abi.encodePacked(             hex'ff',             factory,             keccak256(abi.encodePacked(token0, token1)),             hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash         )))); } ```  The `init code hash` in `UniswapV2Library.pairFor()` should be updated since the code of `UniswapV2Pair` has been changed. Otherwise, the `pair` address calculated will be wrong, most likely non-existing address.  There are many other functions and other contracts across the codebase, including  `UniswapV2Oracle`, `UniswapV2Router02`, and `SushiRoll`, that rely on the `UniswapV2Library.pairFor()` function for the address of the pair, with the `UniswapV2Library.pairFor()` returning a wrong and non-existing address, these functions and contracts will malfunction.  ### Recommendation  Update the init code hash from `hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303'` to the value of `UniswapV2Factory.pairCodeHash()`.  
# Lines of code  https://github.com/Plex-Engineer/stableswap/blob/0dd7ac65d923bb7462c47f6d56b564af34b34118/contracts/BaseV1-core.sol#L154-L171   # Vulnerability details  ```solidity function _update(uint balance0, uint balance1, uint _reserve0, uint _reserve1) internal {     uint blockTimestamp = block.timestamp;     uint timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired     if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {         reserve0CumulativeLast += _reserve0 * timeElapsed;         reserve1CumulativeLast += _reserve1 * timeElapsed;     }      Observation memory _point = lastObservation();     timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event     if (timeElapsed > periodSize) {         observations.push(Observation(blockTimestamp, reserve0CumulativeLast, reserve1CumulativeLast));     }     reserve0 = balance0;     reserve1 = balance1;     blockTimestampLast = blockTimestamp;     emit Sync(reserve0, reserve1); } ```  This was forked from Uniswap v2's `update()`:  https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L72-L81  ```solidity=L72 // update reserves and, on the first call per block, price accumulators function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {     require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');     uint32 blockTimestamp = uint32(block.timestamp % 2**32);     uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired     if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {         // * never overflows, and + overflow is desired         price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;         price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;     } ```  UniswapV2's Pair is using Solidity 0.5.16, in which the arithmetic operations will overflow/underflow without revert.  As the solidity version used in the current implementation of `BaseV1Pair.sol` is `0.8.11`, and there are some breaking changes in Solidity v0.8.0, including:  > Arithmetic operations revert on underflow and overflow.   Ref: https://docs.soliditylang.org/en/v0.8.11/080-breaking-changes.html#silent-changes-of-the-semantics  When updating `reserve0CumulativeLast` and `reserve1CumulativeLast` in `BaseV1Pair.sol`, overflow and underflow are desired as per the comment.  However, the intended overflow only works for solidity < `0.8.0` by default. If overflow and underflow are desired, then the math should be put into an `unchecked` block. Otherwise, the transaction will revert.  ### Impact  Since the overflow is desired in the original version, and it's broken because of using Solidity version >0.8. The `BaseV1Pair` contract will break when the desired overflow happens, which will be sooner or later depending on the decimals of the tokens and trading volume.  ### Recommendation  Change to:  ```solidity unchecked {     uint timeElapsed = blockTimestamp - blockTimestampLast;     if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {         reserve0CumulativeLast += _reserve0 * timeElapsed;         reserve1CumulativeLast += _reserve1 * timeElapsed;     } } ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1380 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L87 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L89 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CErc20.sol#L128 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CEther.sol#L150 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56   # Vulnerability details  ## Impact Multiple calls to transfer are frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of “false” is returned. It’s important to check this, users or admin could gain or lose tokens if return value of transfer() is not checked.  The following functions are affected: Comptroller.grantCompInternal() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1380 AccountantDelegate.sweepInterest() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L87 AccountantDelegate.sweepInterest() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L89 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56 CErc20.sweepToken() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CErc20.sol#L128 CEther.doTransferOut() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CEther.sol#L150 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56  ## Tools Used Slither and manual review  ## Recommended Mitigation Steps Check the returned values of transfers or use a SafeERC20 transfer.  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Note.sol#L13-L19   # Vulnerability details  ## Impact In Note contract, if _initialSupply ! = 0, _totalSupply will overflow when the _mint_to_Accountant function executes _mint(msg.sender, type(uint).max) ```     constructor(string memory name_, string memory symbol_, uint256 totalSupply_) public {         _name = name_;         _symbol = symbol_;      _initialSupply = totalSupply_;      _totalSupply = totalSupply_;     } ...     function _mint(address account, uint256 amount) internal   {         require(account != address(0), "ERC20: mint to the zero address");          _beforeTokenTransfer(address(0), account, amount);          _totalSupply += amount;         _balances[account] += amount;         emit Transfer(address(0), account, amount);          _afterTokenTransfer(address(0), account, amount);     } ``` ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Note.sol#L13-L19 https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/ERC20.sol#L29-L34 https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/ERC20.sol#L237-L247 ## Tools Used None ## Recommended Mitigation Steps ERC20.sol ```     constructor(string memory name_, string memory symbol_) public {         _name = name_;         _symbol = symbol_;     } ``` note.sol ```     constructor() ERC20("Note", "NOTE") {         admin = msg.sender;     } ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L15-L20   # Vulnerability details  ## Impact AccountantDelegate.initialize() is missing a zero address check for `treasury_` parameter, which could may allow treasury to be mistakenly set to 0 address.  ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L20  ## Tools Used Manual review  ## Recommended Mitigation Steps Add a require() check for zero address for the treasury parameter before changing the treasury address in the initialize function.  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L14-L21 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L31 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L96 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L178 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L258   # Vulnerability details  ## Impact In CNote._setAccountantContract() , the require() check only works when `address(_accountant) != address(0)` , leading to the ability to set `_accountant` state variable to the zero address, as well as setting admin to zero address.  The following below are impacts arising from above: ## A. Users can gain underlying asset tokens for free by minting CToken in `mintFresh()` then calling `redeemFresh()`  ## Proof of Concept 1. Alice calls `_setAccountantContract()` with parameter input as 0. 2. The _accountant state variable is now 0. 3. Alice/or a contract calls `mintFresh()` with input address 0 and mintAmount 1000. (assuming function is external, reporting a separate issue on the mutability) 4. This passes the `if (minter == address(_accountant))` and proceeds to mint 1000 CTokens to address(0) 5. Alice then calls `redeemFresh()` with her address as the `redeemer` parameter, and redeemTokensIn as 1000. 6. Assume exchangeRate is 1, Alice would receive 1000 tokens in underlying asset.    ## B. Users could borrow CToken asset for free A user can borrow CToken asset from the contract, then set _accountant to 0 after. With _accountant being set to 0 , the borrower , then call `repayBorrowFresh()` to have _accountant (address 0) to repay back the borrowed tokens assuming address(0) already has some tokens, and user's borrowed asset (all/part) are repaid.  ## Proof of Concept 1. Alice calls `borrowFresh()` to borrow 500 CTokens from contract. 2. Then Alice calls `_setAccountantContract()` with parameter input as 0. 2. The _accountant state variable is now 0. 3. With _accountant being set to 0, Alice calls `repayBorrowFresh()` having the payer be address 0, borrower being her address and 500 as repayAmount. 4. Assume address 0 already holds 1000 CTokens, Alice's debt will be fully repaid and she'll gain 500 CTokens for free.   ## C. Accounting contract could loses funds/tokens When the _accountant is set to 0, CTokens/CNote will be sent to the zero address making the Accounting contract lose funds whenever  `doTransferOut` is called.    ## Tools Used Manual review  ## Recommended Mitigation Steps Instead of a `if (address(_accountant) != address(0))` statement, an additional require check to ensure `accountant_` parameter is not 0 address can be used in addition to the require check for caller is admin.  Change this  ```if (address(_accountant) != address(0)){             require(msg.sender == admin, "CNote::_setAccountantContract:Only admin may call this function");         } ```  to this ``` require(msg.sender == admin, "CNote::_setAccountantContract:Only admin may call this function"); require(accountant_ != address(0), "accoutant can't be zero address"); ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L129   # Vulnerability details  ## Impact It was observed that in repayBorrowFresh function, User is asked to send repayAmount instead of repayAmountFinal. This can lead to loss of user funds as user might be paying extra  ## Proof of Concept 1. User is making a repayment which eventually calls repayBorrowFresh function  2. Assuming repayAmount == type(uint).max, so repayAmountFinal becomes accountBorrowsPrev  3. This means User should only transfer in accountBorrowsPrev instead of repayAmount but that is not true. Contract is transferring repayAmount instead of repayAmountFinal as seen at CNote.sol#L129  ``` uint actualRepayAmount = doTransferIn(payer, repayAmount); ```  ## Recommended Mitigation Steps Revise CNote.sol#L129 to below:  ``` uint actualRepayAmount = doTransferIn(payer, repayAmountFinal); ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Accountant/AccountantDelegate.sol#L74-L92   # Vulnerability details  ## Impact When the user borrows note tokens, the AccountantDelegate contract provides note tokens and gets cnote tokens. Later, when the user repays the note tokens, the cnote tokens are destroyed and the note tokens are transferred to the AccountantDelegate contract. However, in the sweepInterest function of the AccountantDelegate contract, all cnote tokens in the contract will be transferred to address 0. This will prevent the user from repaying the note tokens, and the sweepInterest function will not calculate the interest correctly later. ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Accountant/AccountantDelegate.sol#L74-L92 https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CToken.sol#L533 ## Tools Used None ## Recommended Mitigation Steps ```     function sweepInterest() external override returns(uint) {      uint noteBalance = note.balanceOf(address(this));   uint CNoteBalance = cnote.balanceOf(address(this));    Exp memory expRate = Exp({mantissa: cnote.exchangeRateStored()}); // obtain exchange Rate from cNote Lending Market as a mantissa (scaled by 1e18)   uint cNoteConverted = mul_ScalarTruncate(expRate, CNoteBalance); //calculate truncate(cNoteBalance* mantissa{expRate})   uint noteDifferential = sub_(note.totalSupply(), noteBalance); //cannot underflow, subtraction first to prevent against overflow, subtraction as integers    require(cNoteConverted >= noteDifferential, "Note Loaned to LendingMarket must increase in value");      uint amtToSweep = sub_(cNoteConverted, noteDifferential);    note.transfer(treasury, amtToSweep);  -  cnote.transfer(address(0), CNoteBalance);    return 0;     } ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegator.sol#L44-L56   # Vulnerability details  ## Impact In AccountantDelegator and TreasuryDelegator contracts, when using abi.decode(data, (uint)) to convert data to uint type, the length of data is not checked, when the returned data is of bytes type, the abi.decode will return 0x20. ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegator.sol#L44-L56 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegator.sol#L54-L74 This contract can test that when the function returns bytes data, abi.encode will decode the return value as 0x20. ``` pragma solidity 0.8.10; contract A{     uint public destination;     uint256 public number;     function convertA() external{         (bool su,bytes memory ret )= address(this).call(abi.encodeWithSelector(this.ret.selector));         number = ret.length;         destination = abi.decode(ret, (uint));     }     function ret() public returns(bytes memory){         return "1234";     } } ``` ## Tools Used None ## Recommended Mitigation Steps Requires data.length == 32  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/NoteInterest.sol#L73-L77   # Vulnerability details  ## Impact baseRatePerBlock cannot be relied on to accurately contain current interest rate  ## Proof of Concept baseRatePerBlock is set in the constructor but then not update in either updateBaseRate or _setBaseRatePerYear which update baseRatePerYear. Any contract that pulls the interest rate from baseRatePerBlock will always get the interest rate initially set at the creation of the contract  ## Tools Used  ## Recommended Mitigation Steps Update baseRatePerBlock in updateBaseRate and _setBaseRatePerYear  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Accountant/AccountantDelegate.sol#L29   # Vulnerability details  ## Impact It's not possible to initialize the accountant because of a mistake in the function's require statement.  I rate it as MED since a key part of the protocol wouldn't be available until the contract is modified and redeployed.  ## Proof of Concept The issue is the following `require()` statement: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Accountant/AccountantDelegate.sol#L29  There, the function checks whether the accountant has received the correct amount of tokens. But, it compares the accountant's balance with the `_initialSupply`. That value is always 0. So the require statement will always fail  When the Note contract is initialized, `_initialSupply` is set to 0:  - https://github.com/Plex-Engineer/lending-market/blob/main/deploy/canto/004_deploy_Note.ts#L14 - https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Note.sol#L9 - https://github.com/Plex-Engineer/lending-market/blob/main/contracts/ERC20.sol#L32  After `_mint_to_Accountant()` mints `type(uint).max` tokens to the accountant: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Note.sol#L18 That increases the `totalSupply` but not the `_initialSupply`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/ERC20.sol#L242  The `_initialSupply` value is only modified by the ERC20 contract's constructor.  ## Tools Used none  ## Recommended Mitigation Steps Change the require statement to ```sol require(note.balanceOf(msg.sender) == note.totalSupply(), "AccountantDelegate::initiatlize: Accountant has not received payment"); ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1469   # Vulnerability details  ## Impact The Comptroller contract uses a hardcoded address for the WETH contract which is not the correct one. Because of that, it will be impossible to claim COMP rewards. That results in a loss of funds so I rate it as HIGH.  ## Proof of Concept The Comptroller's `getWETHAddress()` function: https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1469  It's a left-over from the original compound repo: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1469  It's used by the `grantCompInternal()` function: https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1377  That function is called by `claimComp()`: https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1365   If there is a contract stored in that address and it doesn't adhere to the interface (doesn't have a `balanceOf()` and `transfer()` function), the transaction will revert. If there is no contract, the call will succeed without having any effect. In both cases, the user doesn't get their COMP rewards.  ## Tools Used none  ## Recommended Mitigation Steps The WETH contract's address should be parsed to the Comptroller through the constructor or another function instead of being hardcoded.  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L63 https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L87   # Vulnerability details  ## Impact It's not possible to execute a proposal through the GovernorBravoDelegate contract because the `executed` property of it is set to `true` when it's queued up.  Since this means that the governance contract is unusable, it might result in locked-up funds if those were transferred to the contract before the issue comes up. Because of that I'd rate it as HIGH.  ## Proof of Concept `executed` is set to `true`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L63  Here, the `execute()` function checks whether the proposal's state is `Queued`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L87 But, since the `execute` property is `true`, the `state()` function will return `Executed`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L117  In the original compound repo, `executed` is `false` when the proposal is queued up: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorBravoDelegate.sol#L111  ## Tools Used none  ## Recommended Mitigation Steps Just delete the line where `executed` is set to `true`. Since the zero-value is `false` anyway, you'll save gas as well.  
# Lines of code  https://github.com/Plex-Engineer/manifest/blob/688e9b4e7835854c22ef44b045d6d226b784b4b8/contracts/Proposal-Store.sol#L46 https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Governance/GovernorBravoDelegate.sol#L37   # Vulnerability details  ## Impact Proposal Store is used to store proposals that have already passed (https://code4rena.com/contests/2022-06-new-blockchain-contest#unigov-module-615-sloc) " Upon a proposal’s passing, the proposalHandler either deploys the ProposalStore contract (if it is not already deployed) or appends the proposal into the ProposalStore’s mapping ( uint ⇒ Proposal)"  But anyone can add proposals to the contract directly via AddProposal() function.  Unigov proposals can be queued and executed by anyone in GovernorBravoDelegate contract https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Governance/GovernorBravoDelegate.sol#L37  ## Proof of Concept https://github.com/Plex-Engineer/manifest/blob/688e9b4e7835854c22ef44b045d6d226b784b4b8/contracts/Proposal-Store.sol#L46  ## Recommended Mitigation Steps Authorization checks for AddProposal, only governance module should be able to update  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/NoteInterest.sol#L118-L129   # Vulnerability details  ## Impact The `updateBaseRate()` function is public and lacks access control, so anyone can set the critical variable `baseRatePerYear` once the block delta has surpassed the `updateFrequency` variable. This will have negative effects on the borrow and supply rates used anywhere else in the protocol.  The updateFrequency is explained to default to 24 hours per the comments, so this vulnerability will be available every day. Important to note, the admin can fix the `baseRatePerYear` by calling the admin-only `_setBaseRatePerYear()` function. However, calling this function does not set the `lastUpdateBlock` so users will still be able to change the rate back after the 24 hours waiting period from the previous change.   ## Proof of Concept ```     function updateBaseRate(uint newBaseRatePerYear) public {         // check the current block number         uint blockNumber = block.number;         uint deltaBlocks = blockNumber.sub(lastUpdateBlock);           if (deltaBlocks > updateFrequency) {             // pass in a base rate per year             baseRatePerYear = newBaseRatePerYear;             lastUpdateBlock = blockNumber;             emit NewInterestParams(baseRatePerYear);         }     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps I have trouble understanding the intention of this function. It appears that the rate should only be able to be set by the admin, so the `_setBaseRatePerYear()` function seems sufficient. Otherwise, add access control for only trusted parties.  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/WETH.sol#L85   # Vulnerability details  ## Impact Allows anyone to steal all wrapped manifest from the WETH.sol contract. Attacker can also withdraw to convert Wrapped Manifest to Manifest.  Issue in approve(address owner, address spender) external function. This allows an attacker to approve themselves to spend another user's tokens.  Attacker can then use transferFrom(address src, address dst, uint wad) function to send tokens to themself.  ## Proof of Concept Hardhat + Chai test to show exploit. Test file is test/POC.js https://github.com/soosh1337/POC_lending_market_WETH   ## Tools Used VScode, hardhat  ## Recommended Mitigation Steps I believe there is no need for this function. There is another approve(address guy, uint wad) function that uses msg.sender to approve allowance. There should be no need for someone to approve another user's allowance.  Remove the approve(address owner, address spender) function.  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CNote.sol#L70-L87   # Vulnerability details  Having no reentrancy control and updating the records after external interactions allows for funds draining by reentrancy.  Setting the severity to medium as this is conditional to transfer flow control introduction on future upgrades, but the impact is up to the full loss of the available funds by unrestricted borrowing.  ## Proof of Concept  CNote runs doTransferOut before borrowing accounts are updated:  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CNote.sol#L70-L87  ```         /*          * We invoke doTransferOut for the borrower and the borrowAmount.          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.          *  On success, the cToken borrowAmount less of cash.          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.          */         doTransferOut(borrower, borrowAmount);         require(getCashPrior() == 0,"CNote::borrowFresh: Error in doTransferOut, impossible Liquidity in LendingMarket");     //Amount minted by Accountant is always flashed from account          /* We write the previously calculated values into storage */         accountBorrows[borrower].principal = accountBorrowsNew;         accountBorrows[borrower].interestIndex = borrowIndex;         totalBorrows = totalBorrowsNew;          /* We emit a Borrow event */         emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);     } ```  Call sequence here is borrow() -> borrowInternal() -> borrowFresh() -> doTransferOut(), which transfers the token to an external recipient:  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CErc20.sol#L189-L200  ```     /**      * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified      *      it is >= amount, this should not revert in normal conditions.      *      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca      */     function doTransferOut(address payable to, uint amount) virtual override internal {         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);         token.transfer(to, amount); ```  There an attacker can call exitMarket() that have no reentrancy control to remove the account of the debt:  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/Comptroller.sol#L167-L174  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/ComptrollerG7.sol#L157-L164  ```     /**      * @notice Removes asset from sender's account liquidity calculation      * @dev Sender must not have an outstanding borrow balance in the asset,      *  or be providing necessary collateral for an outstanding borrow.      * @param cTokenAddress The address of the asset to be removed      * @return Whether or not the account successfully exited the market      */     function exitMarket(address cTokenAddress) override external returns (uint) { ```  This attack was carried out several times:  https://certik.medium.com/fei-protocol-incident-analysis-8527440696cc   ## Recommended Mitigation Steps  Consider moving accounting update before funds were sent out, for example as it is done in CToken's borrowFresh():  ``` https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CToken.sol#L595-L609          /*          * We write the previously calculated values into storage.          *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.         `*/         accountBorrows[borrower].principal = accountBorrowsNew;         accountBorrows[borrower].interestIndex = borrowIndex;         totalBorrows = totalBorrowsNew;          /*          * We invoke doTransferOut for the borrower and the borrowAmount.          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.          *  On success, the cToken borrowAmount less of cash.          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.          */         doTransferOut(borrower, borrowAmount); ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Governance/GovernorBravoDelegate.sol#L115   # Vulnerability details  ## Impact  `state()` function cannot view the state from any proposal except for the latest one.  ## Proof of Concept  ```solidity require(proposalCount >= proposalId && proposalId > initialProposalId, "GovernorBravo::state: invalid proposal id"); ```  Currently `proposalCount` needs to be bigger or equal to `proposalId`.  Assuming `proposalId` is incremented linearly in conjunction with `proposalCount`, this implies only the most recent `proposalId` will pass the `require()` check above. All other proposals will not be able to have their states checked via this function.   ## Tools Used Manual Review.  ## Recommended Mitigation Steps  Change above function to `proposalCount <= proposalId` (assuming `proposalId` is set linearly, which currently is not enforced by code).   
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L43 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L114 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L198 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L310   # Vulnerability details  ## Impact  The contract expects the balance of the underlying token to == 0 at all points when calling the contract functions by requiring getCashPrior() == 0, which checks token.balanceOf(address(this)) where token is the underlying asset.  An attacker can transfer any amount of the underlying asset directly to the contract and make all of the functions requiring getCashPrior() == 0 to revert.   ## Proof of Concept [CNote.sol#L43](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L43) [CNote.sol#L114](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L114) [CNote.sol#198](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L198) [CNote.sol#310](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L310)  1. Attacker gets any balance of Note (amount = 1 token) 2. Attacker transfers the token to CNote which uses Note as an underlying asset, by calling note.transfer(CNoteAddress, amount). The function is available since Note inherits from ERC20 3. Any calls to CNote functions now revert due to getCashPrior() not being equal to 0  ## Recommended Mitigation Steps Instead of checking the underlying token balance via balanceOf(address(this)) the contract could hold an internal balance of the token, mitigating the impact of tokens being forcefully transferred to the contract.  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L104   # Vulnerability details  ## Impact WETH.allowance() returns wrong result. I can't find other contracts that use this function but WETH.sol is a base contract and it should be fixed properly.   ## Proof of Concept In this function, the "return" keyword is missing and it will always output 0 in this case.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps L104 should be changed like below. ``` return _allowance[owner][spender]; ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CNote.sol#L14   # Vulnerability details  ## Impact  Affected code:  - [https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CNote.sol#L14](https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CNote.sol#L14)  The function `_setAccountantContract()` is supposed to be called after contract initialization, so that the `accountant` is immediately set. However, this function completely lacks any access control (it’s just `public`) so an attacker can monitor the mempool and frontrun the transaction in order to become both `accountant` and `admin`  ## Tools Used  Editor  ## Recommended Mitigation Steps  The function should:  1. have a guard that regulates access control 2. not set the `admin` too, which is dangerous and out of scope  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47   # Vulnerability details  ## Impact  Affected code:  - [https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47](https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47)  `WETH.sol` is almost copied from the infamous WETH contract that lives in mainnet. This contract is supposed to receive the native currency of the blockchain (for example ETH) and wrap it into a tokenized, ERC-20 form. This contract computes the `totalSupply()` using the balance of the contract itself stored in the `balanceOf` mapping, when instead it should be using the native `balance` function. This way, `totalSupply()` always returns zero as the `WETH` contract itself has no way of calling `deposit` to itself and increase its own balance  ## Proof of Concept  1. Alice transfers 100 ETH to `WETH.sol` 2. Alice calls `balanceOf()` for her address and it returns 100 WETH 3. Alice calls `totalSupply()`, expecting to see 100 WETH, but it returns 0  ## Tools Used  Editor  ## Recommended Mitigation Steps  ```jsx function totalSupply() public view returns (uint) {     return address(this).balance } ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Note.sol#L13-L31   # Vulnerability details  ```solidity function _mint_to_Accountant(address accountantDelegator) external {     if (accountant == address(0)) {         _setAccountantAddress(msg.sender);     }     require(msg.sender == accountant, "Note::_mint_to_Accountant: ");     _mint(msg.sender, type(uint).max); }  function RetAccountant() public view returns(address) {     return accountant; }  function _setAccountantAddress(address accountant_) internal {     if(accountant != address(0)) {         require(msg.sender == admin, "Note::_setAccountantAddress: Only admin may call this function");     }     accountant = accountant_;     admin = accountant; } ```  `_mint_to_Accountant()` calls `_setAccountantAddress()` when `accountant == address(0)`, which will always be the case when `_mint_to_Accountant()` is called for the first time.  And `_setAccountantAddress()` only checks if `msg.sender == admin` when `accountant != address(0)` which will always be `false`, therefore the access control is not working.  L17 will then check if `msg.sender == accountant`, now it will always be the case, because at L29, `accountant` was set to `msg.sender`.  
# Lines of code  https://github.com/Plex-Engineer/zeroswap/blob/03507a80322112f4f3c723fc68bed0f138702836/contracts/uniswapv2/libraries/UniswapV2Library.sol#L20-L28   # Vulnerability details  ```solidity function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {     (address token0, address token1) = sortTokens(tokenA, tokenB);     pair = address(uint(keccak256(abi.encodePacked(             hex'ff',             factory,             keccak256(abi.encodePacked(token0, token1)),             hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash         )))); } ```  The `init code hash` in `UniswapV2Library.pairFor()` should be updated since the code of `UniswapV2Pair` has been changed. Otherwise, the `pair` address calculated will be wrong, most likely non-existing address.  There are many other functions and other contracts across the codebase, including  `UniswapV2Oracle`, `UniswapV2Router02`, and `SushiRoll`, that rely on the `UniswapV2Library.pairFor()` function for the address of the pair, with the `UniswapV2Library.pairFor()` returning a wrong and non-existing address, these functions and contracts will malfunction.  ### Recommendation  Update the init code hash from `hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303'` to the value of `UniswapV2Factory.pairCodeHash()`.  
# Lines of code  https://github.com/Plex-Engineer/stableswap/blob/0dd7ac65d923bb7462c47f6d56b564af34b34118/contracts/BaseV1-core.sol#L154-L171   # Vulnerability details  ```solidity function _update(uint balance0, uint balance1, uint _reserve0, uint _reserve1) internal {     uint blockTimestamp = block.timestamp;     uint timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired     if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {         reserve0CumulativeLast += _reserve0 * timeElapsed;         reserve1CumulativeLast += _reserve1 * timeElapsed;     }      Observation memory _point = lastObservation();     timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event     if (timeElapsed > periodSize) {         observations.push(Observation(blockTimestamp, reserve0CumulativeLast, reserve1CumulativeLast));     }     reserve0 = balance0;     reserve1 = balance1;     blockTimestampLast = blockTimestamp;     emit Sync(reserve0, reserve1); } ```  This was forked from Uniswap v2's `update()`:  https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L72-L81  ```solidity=L72 // update reserves and, on the first call per block, price accumulators function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {     require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');     uint32 blockTimestamp = uint32(block.timestamp % 2**32);     uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired     if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {         // * never overflows, and + overflow is desired         price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;         price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;     } ```  UniswapV2's Pair is using Solidity 0.5.16, in which the arithmetic operations will overflow/underflow without revert.  As the solidity version used in the current implementation of `BaseV1Pair.sol` is `0.8.11`, and there are some breaking changes in Solidity v0.8.0, including:  > Arithmetic operations revert on underflow and overflow.   Ref: https://docs.soliditylang.org/en/v0.8.11/080-breaking-changes.html#silent-changes-of-the-semantics  When updating `reserve0CumulativeLast` and `reserve1CumulativeLast` in `BaseV1Pair.sol`, overflow and underflow are desired as per the comment.  However, the intended overflow only works for solidity < `0.8.0` by default. If overflow and underflow are desired, then the math should be put into an `unchecked` block. Otherwise, the transaction will revert.  ### Impact  Since the overflow is desired in the original version, and it's broken because of using Solidity version >0.8. The `BaseV1Pair` contract will break when the desired overflow happens, which will be sooner or later depending on the decimals of the tokens and trading volume.  ### Recommendation  Change to:  ```solidity unchecked {     uint timeElapsed = blockTimestamp - blockTimestampLast;     if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {         reserve0CumulativeLast += _reserve0 * timeElapsed;         reserve1CumulativeLast += _reserve1 * timeElapsed;     } } ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1380 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L87 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L89 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CErc20.sol#L128 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CEther.sol#L150 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56   # Vulnerability details  ## Impact Multiple calls to transfer are frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of “false” is returned. It’s important to check this, users or admin could gain or lose tokens if return value of transfer() is not checked.  The following functions are affected: Comptroller.grantCompInternal() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1380 AccountantDelegate.sweepInterest() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L87 AccountantDelegate.sweepInterest() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L89 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56 CErc20.sweepToken() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CErc20.sol#L128 CEther.doTransferOut() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CEther.sol#L150 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56  ## Tools Used Slither and manual review  ## Recommended Mitigation Steps Check the returned values of transfers or use a SafeERC20 transfer.  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Note.sol#L13-L19   # Vulnerability details  ## Impact In Note contract, if _initialSupply ! = 0, _totalSupply will overflow when the _mint_to_Accountant function executes _mint(msg.sender, type(uint).max) ```     constructor(string memory name_, string memory symbol_, uint256 totalSupply_) public {         _name = name_;         _symbol = symbol_;      _initialSupply = totalSupply_;      _totalSupply = totalSupply_;     } ...     function _mint(address account, uint256 amount) internal   {         require(account != address(0), "ERC20: mint to the zero address");          _beforeTokenTransfer(address(0), account, amount);          _totalSupply += amount;         _balances[account] += amount;         emit Transfer(address(0), account, amount);          _afterTokenTransfer(address(0), account, amount);     } ``` ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Note.sol#L13-L19 https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/ERC20.sol#L29-L34 https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/ERC20.sol#L237-L247 ## Tools Used None ## Recommended Mitigation Steps ERC20.sol ```     constructor(string memory name_, string memory symbol_) public {         _name = name_;         _symbol = symbol_;     } ``` note.sol ```     constructor() ERC20("Note", "NOTE") {         admin = msg.sender;     } ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L15-L20   # Vulnerability details  ## Impact AccountantDelegate.initialize() is missing a zero address check for `treasury_` parameter, which could may allow treasury to be mistakenly set to 0 address.  ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L20  ## Tools Used Manual review  ## Recommended Mitigation Steps Add a require() check for zero address for the treasury parameter before changing the treasury address in the initialize function.  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L14-L21 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L31 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L96 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L178 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L258   # Vulnerability details  ## Impact In CNote._setAccountantContract() , the require() check only works when `address(_accountant) != address(0)` , leading to the ability to set `_accountant` state variable to the zero address, as well as setting admin to zero address.  The following below are impacts arising from above: ## A. Users can gain underlying asset tokens for free by minting CToken in `mintFresh()` then calling `redeemFresh()`  ## Proof of Concept 1. Alice calls `_setAccountantContract()` with parameter input as 0. 2. The _accountant state variable is now 0. 3. Alice/or a contract calls `mintFresh()` with input address 0 and mintAmount 1000. (assuming function is external, reporting a separate issue on the mutability) 4. This passes the `if (minter == address(_accountant))` and proceeds to mint 1000 CTokens to address(0) 5. Alice then calls `redeemFresh()` with her address as the `redeemer` parameter, and redeemTokensIn as 1000. 6. Assume exchangeRate is 1, Alice would receive 1000 tokens in underlying asset.    ## B. Users could borrow CToken asset for free A user can borrow CToken asset from the contract, then set _accountant to 0 after. With _accountant being set to 0 , the borrower , then call `repayBorrowFresh()` to have _accountant (address 0) to repay back the borrowed tokens assuming address(0) already has some tokens, and user's borrowed asset (all/part) are repaid.  ## Proof of Concept 1. Alice calls `borrowFresh()` to borrow 500 CTokens from contract. 2. Then Alice calls `_setAccountantContract()` with parameter input as 0. 2. The _accountant state variable is now 0. 3. With _accountant being set to 0, Alice calls `repayBorrowFresh()` having the payer be address 0, borrower being her address and 500 as repayAmount. 4. Assume address 0 already holds 1000 CTokens, Alice's debt will be fully repaid and she'll gain 500 CTokens for free.   ## C. Accounting contract could loses funds/tokens When the _accountant is set to 0, CTokens/CNote will be sent to the zero address making the Accounting contract lose funds whenever  `doTransferOut` is called.    ## Tools Used Manual review  ## Recommended Mitigation Steps Instead of a `if (address(_accountant) != address(0))` statement, an additional require check to ensure `accountant_` parameter is not 0 address can be used in addition to the require check for caller is admin.  Change this  ```if (address(_accountant) != address(0)){             require(msg.sender == admin, "CNote::_setAccountantContract:Only admin may call this function");         } ```  to this ``` require(msg.sender == admin, "CNote::_setAccountantContract:Only admin may call this function"); require(accountant_ != address(0), "accoutant can't be zero address"); ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L129   # Vulnerability details  ## Impact It was observed that in repayBorrowFresh function, User is asked to send repayAmount instead of repayAmountFinal. This can lead to loss of user funds as user might be paying extra  ## Proof of Concept 1. User is making a repayment which eventually calls repayBorrowFresh function  2. Assuming repayAmount == type(uint).max, so repayAmountFinal becomes accountBorrowsPrev  3. This means User should only transfer in accountBorrowsPrev instead of repayAmount but that is not true. Contract is transferring repayAmount instead of repayAmountFinal as seen at CNote.sol#L129  ``` uint actualRepayAmount = doTransferIn(payer, repayAmount); ```  ## Recommended Mitigation Steps Revise CNote.sol#L129 to below:  ``` uint actualRepayAmount = doTransferIn(payer, repayAmountFinal); ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Accountant/AccountantDelegate.sol#L74-L92   # Vulnerability details  ## Impact When the user borrows note tokens, the AccountantDelegate contract provides note tokens and gets cnote tokens. Later, when the user repays the note tokens, the cnote tokens are destroyed and the note tokens are transferred to the AccountantDelegate contract. However, in the sweepInterest function of the AccountantDelegate contract, all cnote tokens in the contract will be transferred to address 0. This will prevent the user from repaying the note tokens, and the sweepInterest function will not calculate the interest correctly later. ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Accountant/AccountantDelegate.sol#L74-L92 https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CToken.sol#L533 ## Tools Used None ## Recommended Mitigation Steps ```     function sweepInterest() external override returns(uint) {      uint noteBalance = note.balanceOf(address(this));   uint CNoteBalance = cnote.balanceOf(address(this));    Exp memory expRate = Exp({mantissa: cnote.exchangeRateStored()}); // obtain exchange Rate from cNote Lending Market as a mantissa (scaled by 1e18)   uint cNoteConverted = mul_ScalarTruncate(expRate, CNoteBalance); //calculate truncate(cNoteBalance* mantissa{expRate})   uint noteDifferential = sub_(note.totalSupply(), noteBalance); //cannot underflow, subtraction first to prevent against overflow, subtraction as integers    require(cNoteConverted >= noteDifferential, "Note Loaned to LendingMarket must increase in value");      uint amtToSweep = sub_(cNoteConverted, noteDifferential);    note.transfer(treasury, amtToSweep);  -  cnote.transfer(address(0), CNoteBalance);    return 0;     } ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegator.sol#L44-L56   # Vulnerability details  ## Impact In AccountantDelegator and TreasuryDelegator contracts, when using abi.decode(data, (uint)) to convert data to uint type, the length of data is not checked, when the returned data is of bytes type, the abi.decode will return 0x20. ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegator.sol#L44-L56 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegator.sol#L54-L74 This contract can test that when the function returns bytes data, abi.encode will decode the return value as 0x20. ``` pragma solidity 0.8.10; contract A{     uint public destination;     uint256 public number;     function convertA() external{         (bool su,bytes memory ret )= address(this).call(abi.encodeWithSelector(this.ret.selector));         number = ret.length;         destination = abi.decode(ret, (uint));     }     function ret() public returns(bytes memory){         return "1234";     } } ``` ## Tools Used None ## Recommended Mitigation Steps Requires data.length == 32  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/NoteInterest.sol#L73-L77   # Vulnerability details  ## Impact baseRatePerBlock cannot be relied on to accurately contain current interest rate  ## Proof of Concept baseRatePerBlock is set in the constructor but then not update in either updateBaseRate or _setBaseRatePerYear which update baseRatePerYear. Any contract that pulls the interest rate from baseRatePerBlock will always get the interest rate initially set at the creation of the contract  ## Tools Used  ## Recommended Mitigation Steps Update baseRatePerBlock in updateBaseRate and _setBaseRatePerYear  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Accountant/AccountantDelegate.sol#L29   # Vulnerability details  ## Impact It's not possible to initialize the accountant because of a mistake in the function's require statement.  I rate it as MED since a key part of the protocol wouldn't be available until the contract is modified and redeployed.  ## Proof of Concept The issue is the following `require()` statement: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Accountant/AccountantDelegate.sol#L29  There, the function checks whether the accountant has received the correct amount of tokens. But, it compares the accountant's balance with the `_initialSupply`. That value is always 0. So the require statement will always fail  When the Note contract is initialized, `_initialSupply` is set to 0:  - https://github.com/Plex-Engineer/lending-market/blob/main/deploy/canto/004_deploy_Note.ts#L14 - https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Note.sol#L9 - https://github.com/Plex-Engineer/lending-market/blob/main/contracts/ERC20.sol#L32  After `_mint_to_Accountant()` mints `type(uint).max` tokens to the accountant: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Note.sol#L18 That increases the `totalSupply` but not the `_initialSupply`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/ERC20.sol#L242  The `_initialSupply` value is only modified by the ERC20 contract's constructor.  ## Tools Used none  ## Recommended Mitigation Steps Change the require statement to ```sol require(note.balanceOf(msg.sender) == note.totalSupply(), "AccountantDelegate::initiatlize: Accountant has not received payment"); ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1469   # Vulnerability details  ## Impact The Comptroller contract uses a hardcoded address for the WETH contract which is not the correct one. Because of that, it will be impossible to claim COMP rewards. That results in a loss of funds so I rate it as HIGH.  ## Proof of Concept The Comptroller's `getWETHAddress()` function: https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1469  It's a left-over from the original compound repo: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1469  It's used by the `grantCompInternal()` function: https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1377  That function is called by `claimComp()`: https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1365   If there is a contract stored in that address and it doesn't adhere to the interface (doesn't have a `balanceOf()` and `transfer()` function), the transaction will revert. If there is no contract, the call will succeed without having any effect. In both cases, the user doesn't get their COMP rewards.  ## Tools Used none  ## Recommended Mitigation Steps The WETH contract's address should be parsed to the Comptroller through the constructor or another function instead of being hardcoded.  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L63 https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L87   # Vulnerability details  ## Impact It's not possible to execute a proposal through the GovernorBravoDelegate contract because the `executed` property of it is set to `true` when it's queued up.  Since this means that the governance contract is unusable, it might result in locked-up funds if those were transferred to the contract before the issue comes up. Because of that I'd rate it as HIGH.  ## Proof of Concept `executed` is set to `true`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L63  Here, the `execute()` function checks whether the proposal's state is `Queued`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L87 But, since the `execute` property is `true`, the `state()` function will return `Executed`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L117  In the original compound repo, `executed` is `false` when the proposal is queued up: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorBravoDelegate.sol#L111  ## Tools Used none  ## Recommended Mitigation Steps Just delete the line where `executed` is set to `true`. Since the zero-value is `false` anyway, you'll save gas as well.  
# Lines of code  https://github.com/Plex-Engineer/manifest/blob/688e9b4e7835854c22ef44b045d6d226b784b4b8/contracts/Proposal-Store.sol#L46 https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Governance/GovernorBravoDelegate.sol#L37   # Vulnerability details  ## Impact Proposal Store is used to store proposals that have already passed (https://code4rena.com/contests/2022-06-new-blockchain-contest#unigov-module-615-sloc) " Upon a proposal’s passing, the proposalHandler either deploys the ProposalStore contract (if it is not already deployed) or appends the proposal into the ProposalStore’s mapping ( uint ⇒ Proposal)"  But anyone can add proposals to the contract directly via AddProposal() function.  Unigov proposals can be queued and executed by anyone in GovernorBravoDelegate contract https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Governance/GovernorBravoDelegate.sol#L37  ## Proof of Concept https://github.com/Plex-Engineer/manifest/blob/688e9b4e7835854c22ef44b045d6d226b784b4b8/contracts/Proposal-Store.sol#L46  ## Recommended Mitigation Steps Authorization checks for AddProposal, only governance module should be able to update  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/NoteInterest.sol#L118-L129   # Vulnerability details  ## Impact The `updateBaseRate()` function is public and lacks access control, so anyone can set the critical variable `baseRatePerYear` once the block delta has surpassed the `updateFrequency` variable. This will have negative effects on the borrow and supply rates used anywhere else in the protocol.  The updateFrequency is explained to default to 24 hours per the comments, so this vulnerability will be available every day. Important to note, the admin can fix the `baseRatePerYear` by calling the admin-only `_setBaseRatePerYear()` function. However, calling this function does not set the `lastUpdateBlock` so users will still be able to change the rate back after the 24 hours waiting period from the previous change.   ## Proof of Concept ```     function updateBaseRate(uint newBaseRatePerYear) public {         // check the current block number         uint blockNumber = block.number;         uint deltaBlocks = blockNumber.sub(lastUpdateBlock);           if (deltaBlocks > updateFrequency) {             // pass in a base rate per year             baseRatePerYear = newBaseRatePerYear;             lastUpdateBlock = blockNumber;             emit NewInterestParams(baseRatePerYear);         }     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps I have trouble understanding the intention of this function. It appears that the rate should only be able to be set by the admin, so the `_setBaseRatePerYear()` function seems sufficient. Otherwise, add access control for only trusted parties.  
# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/WETH.sol#L85   # Vulnerability details  ## Impact Allows anyone to steal all wrapped manifest from the WETH.sol contract. Attacker can also withdraw to convert Wrapped Manifest to Manifest.  Issue in approve(address owner, address spender) external function. This allows an attacker to approve themselves to spend another user's tokens.  Attacker can then use transferFrom(address src, address dst, uint wad) function to send tokens to themself.  ## Proof of Concept Hardhat + Chai test to show exploit. Test file is test/POC.js https://github.com/soosh1337/POC_lending_market_WETH   ## Tools Used VScode, hardhat  ## Recommended Mitigation Steps I believe there is no need for this function. There is another approve(address guy, uint wad) function that uses msg.sender to approve allowance. There should be no need for someone to approve another user's allowance.  Remove the approve(address owner, address spender) function.  
