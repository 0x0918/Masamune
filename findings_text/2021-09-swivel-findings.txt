# Handle  0xsanson   # Vulnerability details  ## Impact There are multiple instances of divisions performed before multiplications, whereas the opposite is generally suggested. To mitigate the precision loss, a factor like `1e18` is multiplied and then divided, but this solution is arbitrary and can be avoided.  For example: ```js uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18; ```  can be rewritten like: ```js uint256 principalFilled = a * o.principal / o.premium; ```  ## Proof of Concept Run `grep '1e18' Swivel.sol` for a complete list.  ## Tools Used grep, editor  ## Recommended Mitigation Steps Suggested checking all instances and trying to simplify the math.  
# Handle  0xsanson   # Vulnerability details  ## Impact `Marketplace.calculateReturn` can be rewritten from: ```js function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {   // calculate difference between the cToken exchange rate @ maturity and the current cToken exchange rate   uint256 yield = ((CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent() * 1e26) / maturityRate[u][m]) - 1e26;   uint256 interest = (yield * a) / 1e26;    // calculate the total amount of underlying principle to return   return a + interest; } ```  to: ```js function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {   uint256 rate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();   return  a*rate/ maturityRate[u][m]; } ```  Less math operations means less approximations and less gas used.  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L160-L167  ## Tools Used editor  
# Handle  pauliax   # Vulnerability details  ## Impact boolean flag 'matured' could be removed if you agree to accept maturityRate > 0 as a matured vault, basically replacing:   require(!matured, 'already matured'); with:   require(maturityRate == 0, 'already matured'); This would eliminate one storage variable and thus reduce gas usage. The risk is that exchangeRateCurrent can never be 0 as this would mean an immature state.  ## Recommended Mitigation Steps Consider getting rid of 'matured' as per suggestion.   
# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why there are many functions that always return a boolean value of true. While this may be your agreed practice that you try to follow, it also incurs more gas consumption as the caller needs to receive and check these returned values.  ## Recommended Mitigation Steps If you want to optimize for gas, consider dropping return values for functions that actually do not need them.  
# Handle  pauliax   # Vulnerability details  ## Impact Having both modifiers 'onlyAdmin' and 'onlySwivel' is not only more expensive but also misleading as these modifiers basically do the same job of checking an address against msg.sender.  ## Recommended Mitigation Steps Better have a generalized modifier, something like onlyAddress(address a), and re-use it with both admin and swivel:   modifier onlyAddress(address a) {     require(msg.sender == a, 'sender not authorized');     _;   }   onlyAddress(admin)   onlyAddress(swivel)  
# Handle  pauliax   # Vulnerability details  ## Impact When creating the market (function createMarket), you do not need to specify the address of underlying, it would be less error-prone to dynamically get this from cToken: https://github.com/compound-finance/compound-protocol/blob/master/contracts/CTokenInterfaces.sol#L254   ## Recommended Mitigation Steps While only the admin can create new markets, I think it would still be nice to algorithmically ensure that this underlying token belongs to this cToken and do not leave a chance for human errors.  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact The line:     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');  in Swivel.sol https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L171  Is checking for the return value of `MarketPlace.p2pZcTokenExchange`, however `p2pZcTokenExchange` will always return true or revert  As such the require is not necessary, and doesn't provide any additional guarantees.  ## Recommended Mitigation Steps  Replace `     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed'); `  With  ` MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a) `  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact The function `custodialExit` in Marketplace.sol: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L194  Always returns true or reverts  In swivel.sol the check  `require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed'); ` will always pass, unless the function `custodialExit` reverts  This extra require is not necessary, and provides no additional guarantees as `custodialExit` will always return true or revert   ## Recommended Mitigation Steps Replace ` require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed'); `  With ` mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a) `  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact The variable `marketplace` in Swivel.sol https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L21  is stored as an immutable address  However, every single instance of it's usage casts it to `MarketPlace`  Would recommend storing `marketplace` as `MarketPlace` to make the code cleaner   ## Recommended Mitigation Steps Replace `  address public immutable marketPlace; ` With `   Marketplace public immutable marketPlace; `  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Swivel initiate() and exit() functions accept unbounded arrays from users which may lead to OOG exceptions with insufficient gas sent in transaction.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L55-L77  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L209-L234  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Bounding array lengths or checking gasleft are a good idea to reduce risk of OOG and save userâ€™s gas.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L57  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L211   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove explicit 0 initialization of for loop index variable.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  to.notional += a  can be replaced by to.notional = a because to.notional = 0 in the else part. This will save a few MLOADs.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L189  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Replace to.notional += a  by to.notional = a  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The require(matureMarket(u, m) is redundant because matureMarket always returns true and reverts if any of its require() check fails.  Removing this can save a little gas.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L127  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L75-L91  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove redundant require()  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There are few places across contracts where the same state variables are read multiple times or the same external calls are made multiple times within a function. Caching state variables or results from external calls in local/memory variables avoids SLOADs and CALLs to save gas. Warm SLOADs cost 100 gas and CALLs cost 2600 gas after Berlin upgrade. MLOADs cost only 3 gas units.  ## Proof of Concept  Cache swivel: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L61-L64  Cache markets[u][m]: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L76-L86  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L99-L100  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L111-L112  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L181-L182  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L195-L196   Cache matured and maturityRate: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L156-L179\  Cache vaults: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L244   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Cache state variables or results from external calls in local/memory variables to save gas.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The setFee onlyAdmin function sets the fee denominator but does not perform input validation to check that the fenominator index is between 0-3 which are the only valid values for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit].  The onlyAdmin function performs no threshold check on the new values, emits no event and immediately changes the fenominator value to any arbitrary value proposed by the admin.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L399-L405  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L23-L24  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L46  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Add input validation, threshold check, event and timelock  
# Handle  0xRajeev   # Vulnerability details  ## Impact  This implementation of Sig.sol doesnâ€™t support compact signature (EIP-2098), where signature length can be 64 bytes instead of 65, as supported in the widely used OpenZeppelinâ€™s ECDSA library. This lack of support could lead to DoS for users/clients that use compact signatures.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Sig.sol#L41  See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/1b27c13096d6e4389d62e7b0766a1db53fbb3f1b/contracts/utils/cryptography/ECDSA.sol#L57  https://eips.ethereum.org/EIPS/eip-2098  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider adding support for compact signatures, use OZ ECDSA library or highlight in documentation about this lack of support for EIP-2098.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  TheÂ ecrecoverÂ function is used to verify and execute EIP-2612 permit transactions. The built-in EVM precompile ecrecover is susceptible to signature malleability (because of non-unique s and v values) which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121 and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57).   While this is not exploitable for replay attacks in the current implementation because of the use of nonces, this may become a vulnerability if used elsewhere.   ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/tokens/Erc2612.sol#L48  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Consider using OpenZeppelinâ€™s ECDSA library (which prevents this malleability) instead of the built-in function: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Interfaces are not allowed to define any functions while abstract contracts can have a few defined functions (with at least one undefined function). Abstract contracts declared in the project should really be interfaces because they do not define any functions.   Keeping them abstract is risky because they allow defining functions that may be mistakenly exposed in inherited contracts. Interfaces by design prevent this security risk.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Abstracts.sol#L5-L40  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Convert contracts that do not define any functions to interfaces.  
# Handle  JMukesh   # Vulnerability details  ## Impact In matureMarket(address u, uint256 m) function , different parameter is used in event      emit Mature(u, m, block.timestamp, currentExchangeRate);  maturity rate should before matured timestamp //   event Mature(address indexed underlying, uint256 indexed maturity, uint256 maturityRate, uint256 matured);  impact of this can be severe .   This   error   may   negatively   impact    off-chain   tools   that   are   monitoring   events data  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L88  ## Tools Used manual review  ## Recommended Mitigation Steps   
# Handle  cmichel   # Vulnerability details  The `Swivel` contract approves the `cToken` address whenever it wants to mint `cTokens` upon order fulfilment, see `initiateVaultFillingZcTokenInitiate`.  It could just approve the `cToken` contract once for each market underlying it supports with the max value and save the approval call for each order fulfilment.   
# Handle  leastwood   # Vulnerability details  ## Impact  The `cTokenAddress()` getter function in `MarketPlace.sol` is missing relevant dev comments and appropriate matching syntax. `address a` does not correctly match the proper representation which is the underlying token, typically referenced as `address u`.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L169-L171  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider adding relevant dev comments and updating `address a` -> `address u` to better reflect its meaning.  
# Handle  gpersoon   # Vulnerability details  # Impact The function transferNotionalFrom of VaultTracker.sol uses temporary variables to store the balances. If the "from" and "to" address are the same then the balance of "from" is overwritten by the balance of "to". This means the balance of "from" and "to" are increased and no balances are decreased, effectively printing money.  Note: transferNotionalFrom can be called via transferVaultNotional by everyone.  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/v2/test/vaulttracker/VaultTracker.sol#L144-L196   function transferNotionalFrom(address f, address t, uint256 a) external onlyAdmin(admin) returns (bool) {     Vault memory from = vaults[f];     Vault memory to = vaults[t];     ...     vaults[f] = from;     ...     vaults[t] = to;    // if f==t then this will overwrite vaults[f]    https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L234-L238 function transferVaultNotional(address u, uint256 m, address t, uint256 a) public returns (bool) {     require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(msg.sender, t, a), 'vault transfer failed');     ## Tools Used  ## Recommended Mitigation Steps Add something like the following:    require (f != t,"Same");  
# Handle  gpersoon   # Vulnerability details  ## Impact The contract Swivel.sol contains a few of the following requires:  require(a <= (o.premium - filled[hash]), 'taker amount > available volume');    If "o.premium" happens to be smaller than "filled[hash]", a revert will occur at "o.premium - filled[hash]" and no error message will be displayed.  Also note the statements use slightly different syntax with the parentheses.   ## Proof of Concept Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require((a <= o.principal  - filled[hash]),  'taker amount > available volume');  // slightly different syntax Swivel.sol:    require(a <= ((o.principal - filled[hash])), 'taker amount > available volume');  // slightly different syntax Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.principal  - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.principal  - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume');  ## Tools Used  ## Recommended Mitigation Steps replace  require(a <= (o.xxxx - filled[hash]), 'taker amount > available volume');   with  require( (a + filled[hash]) <= o.xxxx), 'taker amount > available volume');  Use the same parentheses structure everywhere.  
# Handle  pants   # Vulnerability details  The Sig.split function (defined at Line 40 of Sig library) is called only inside the library. Thus function could be set as private.  https://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Sig.sol#L40  ## Recommended Mitigation Steps Make it private :)  ## Tool Used Manual code review.   
# Handle  pants   # Vulnerability details  At both line 59 and 61 the code reads o[i]. It happens inside a loop therefore the best practice which is more gas efficient is to cache o[i] once and use it instead.  https://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Swivel.sol#L59  ## Tool Used Manual code review.   
# Handle  ye0lde   # Vulnerability details  ## Impact Operating on a copy of a state variable seems inefficient and confusing in this case.   From a "gas" standpoint it's less efficient.  And future changes could render the addresses in the copied struct invalid if functions being called in redeemZcToken operate on the original state variable.  ## Proof of Concept The copy occurs here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L123  The "mkt" variable is referenced here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L131  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove line #123: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L123  Replace "mkt" with "markets[u][m]" in line #131 https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L131   
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Taker is charged fees twice in `exitVaultFillingVaultInitiate()` . Maker is transferring less than premiumFilled to taker and then taker is expected to pay fees i.e. taker's net balance is premiumFilled - 2*fee  ## Recommended Mitigation Steps  ```jsx function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {     bytes32 hash = validOrderHash(o, c);      require(a <= (o.principal - filled[hash]), 'taker amount > available volume');          filled[hash] += a;              uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;     uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;      Erc20 uToken = Erc20(o.underlying);     // transfer premium from maker to sender     uToken.transferFrom(o.maker, msg.sender, premiumFilled);      // transfer fee in underlying to swivel from sender     uToken.transferFrom(msg.sender, address(this), fee);      // transfer <a> vault.notional (nTokens) from sender to maker     require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');      emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled); } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  In `initiateZcTokenFillingZcTokenExit()` , this comment `// transfer underlying tokens - the premium paid + fee in underlying to swivel (from sender)`  is incorrect because you are actually transferring the underlying tokens - premium paid to the maker (from sender) AND you have to pay fee separately to swivel.  initiateZCTokenFillingZcTokenExit means I want to sell my nTokens so that means `a` is the amount of principal I want to fill. Let's use a hypothetical example where I (taker) wants to fill 10 units of ZcTokenExit for maker.  1. I transfer 10 units of underlying to Swivel. The net balances are: me (-a), swivel (+a) 2. I transfer fee (in underlying) to Swivel. The net balances are: me (-a-fee), swivel (+a+fee)  3. Swivel initiates my position, sends me the ZcToken and sends Maker the nTokens 4. Maker pays me premiumFilled for the nTokens. The net balances are: me (-a-fee+premiumsFilled), swivel (+a+fee), maker (-premiumsFilled) 5. Maker closes position. The net balances are: me (-a-fee+premiumsFilled), swivel (+fee), maker (-premiumsFilled+a)  So effectively, I (taker) should be paying a-premium to maker and fee to swivel.  ## Recommended Mitigation Steps  ```jsx function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {     bytes32 hash = validOrderHash(o, c);      require(a <= o.principal - filled[hash]), 'taker amount > available volume'); // Note: you don't need to wrap these in brackets because if you look at the https://docs.soliditylang.org/en/latest/cheatsheet.html#order-of-precedence-of-operators, subtraction will always go before comparison       filled[hash] += a;      uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;     uint256 fee = ((premiumFilled * 1e18) / fenominator[0]) / 1e18;      // transfer underlying tokens - the premium paid in underlying to maker (from sender)     Erc20(o.underlying).transferFrom(msg.sender, o.maker, a - premiumFilled);   Erc20(o.underlying).transferFrom(msg.sender, swivel, fee);     // transfer <a> zcTokens between users in marketplace     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');                  emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled); } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  There is no impact to the funds but to align with [best practices]([https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html)), it is always better to update internal state before any external function calls.  ## Recommended Mitigation Steps  For functions `exitVaultFillingZcTokenExit()` and `exitZcTokenFillingVaultExit()`, you should do `mPlace.custodialExit(...)` to update the internal accounting before transferring the tokens out.  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Misleading comments  ## Recommended Mitigation Steps  For these 4 functions, it should say "taker's init" instead of "taker's exit"  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas optimisation. In the function `transferNotionalFee()`,  `sVault.exchangeRate` is only 0 for the very first time this function is called so the if check to see if `sVault.exchangeRate != 0` is only used once to handle this edge case.  It makes more sense to set the exchangeRate when the vault is created and remove these if conditions.  ## Recommended Mitigation Steps  ```jsx constructor(uint256 m, address c, address s) {    admin = msg.sender;    maturity = m;    cTokenAddr = c;    swivel = s;   uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();   vault[swivel] = Vault({        notional: 0,        redeemable: 0,        exchangeRate: exchangeRate    }); } ... function transferNotionalFee(address f, uint256 a) external onlyAdmin(admin) returns(bool) {     Vault memory oVault = vaults[f];     Vault memory sVault = vaults[swivel];      // remove notional from its owner     oVault.notional -= a;      uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();     uint256 yield;     uint256 interest;      // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate     if (sVault.exchangeRate != exchangeRate) {        // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate        // otherwise, calculate marginal exchange rate between current and previous exchange rate.        if (matured) {            // calculate marginal interest            yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;        } else {            yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;        }          interest = (yield * sVault.notional) / 1e26;        sVault.redeemable += interest;       sVault.exchangeRate = exchangeRate;     }      // add notional to swivel's vault     sVault.notional += a;      // store the adjusted vaults     vaults[swivel] = sVault;     vaults[f] = oVault;     return true;   } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Since you are already querying the exchangeRate for the current block in `MarketPlace.matureMarket()` , might as well pass it along to `VaultTracker.sol` instead of querying it a second time.  ## Recommended Mitigation Steps  ```jsx // In VaultTracker.sol function matureVault(uint256 _maturityRate) external onlyAdmin(admin) returns (bool) {    require(!matured, 'already matured');    require(block.timestamp >= maturity, 'maturity has not been reached');    matured = true;   maturityRate = _maturityRate;    return true; } ```  ```jsx // In MarketPlace.sol function matureMarket(address u, uint256 m) public returns (bool) {    require(!mature[u][m], 'market already matured');    require(block.timestamp >= ZcToken(markets[u][m].zcTokenAddr).maturity(), "maturity not reached");      // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate    uint256 currentExchangeRate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();    maturityRate[u][m] = currentExchangeRate;    // set the maturity state to true (for zcb market)    mature[u][m] = true;      // set vault "matured" to true   require(VaultTracker(markets[u][m].vaultAddr).matureVault(currentExchangeRate), 'maturity not reached');      emit Mature(u, m, block.timestamp, currentExchangeRate);      return true; } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  You don't need to store maturity in `VaultTracker.sol` or `ZcToken.sol` because `mapping (address => mapping (uint256 => bool)) public mature;` should already cover it. This will help to remove unnecessary external calls and also reduce the number of maturity checks.  ## Recommended Mitigation Steps  ```jsx // In MarketPlace.sol function createMarket(    address u,    uint256 m,    address c,    string memory n,    string memory s,    uint8 d ) public onlyAdmin(admin) returns (bool) {    require(swivel != address(0), 'swivel contract address not set');    // TODO can we live with the factory pattern here both bytecode size wise and CREATE opcode cost wise?   address zctAddr = address(new ZcToken(u, n, s, d));    address vAddr = address(new VaultTracker(c, swivel));    markets[u][m] = Market(c, zctAddr, vAddr);      emit Create(u, m, c, zctAddr, vAddr);      return true; } ... function matureMarket(address u, uint256 m) public returns (bool) {   require(block.timestamp >= m, "maturity not reached");    require(!mature[u][m], 'market already matured');      // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate    uint256 currentExchangeRate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();    maturityRate[u][m] = currentExchangeRate;    // set the maturity state to true (for zcb market)    mature[u][m] = true;      // set vault "matured" to true    require(VaultTracker(markets[u][m].vaultAddr).matureVault(), 'maturity not reached');      emit Mature(u, m, block.timestamp, currentExchangeRate);      return true; } ```  ```jsx  // In VaultTracker.sol ... // uint256 public immutable maturity; // deleted this ... constructor(address c, address s) {    admin = msg.sender;    cTokenAddr = c;    swivel = s; } ... function matureVault() external onlyAdmin(admin) returns (bool) {    matured = true;    maturityRate = CErc20(cTokenAddr).exchangeRateCurrent();    return true; } ```  ```jsx // uint256 public immutable maturity; // deleted this ... constructor(address u, string memory n, string memory s, uint8 d) Erc2612(n, s, d) {    admin = msg.sender;    underlying = u; } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas op. Since vlt.notional has to be updated in both branches of the if check, you can take vlt.notional out of both branches and skip the else check.  ## Recommended Mitigation Steps  ```jsx function addNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {   uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();   Vault memory vlt = vaults[o];      if (vlt.notional > 0) {      uint256 yield;      uint256 interest;          // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate      // otherwise, calculate marginal exchange rate between current and previous exchange rate.      if (matured) { // Calculate marginal interest         yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;      } else {         yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;      }          interest = (yield * vlt.notional) / 1e26;      // add interest and amount to position, reset cToken exchange rate      vlt.redeemable += interest;       }      vlt.notional += a;   vlt.exchangeRate = exchangeRate;   vaults[o] = vlt;      return true; } ```  
# Handle  defsec   # Vulnerability details  ## Impact  If data can fit into 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. On the MarketPlace.sol contract, string memory variable can be replaced with bytes32 array. That will save gas on the contract.   ## Proof of Concept  1. Navigate to "https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol" contract. 2. Investigate createMarket function. n and s variables can be replaced with bytes32 variable.  ```   function createMarket(     address u,     uint256 m,     address c,     string memory n,     string memory s,     uint8 d   ) public onlyAdmin(admin) returns (bool) {     require(swivel != address(0), 'swivel contract address not set');     // TODO can we live with the factory pattern here both bytecode size wise and CREATE opcode cost wise?     address zctAddr = address(new ZcToken(u, m, n, s, d));     address vAddr = address(new VaultTracker(m, c, swivel));     markets[u][m] = Market(c, zctAddr, vAddr);      emit Create(u, m, c, zctAddr, vAddr);      return true;   } ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to replace string variables with bytes32. That should be definitely cheaper.   
# Handle  ye0lde   # Vulnerability details  ## Impact  There is additional gas usage when an array's length value is used directly in a "for" loop.  ## Proof of Concept  The array's length value is used directly in a for loop here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L57 https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L211   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the loops above from: <code> for (uint256 i=0; i < o.length; i++) </code>  to <code> unit256 length = o.length; for (uint256 i=0; i < length; i++) </code>  When I tested these changes there was a small gas saving.   
# Handle  loop   # Vulnerability details  the parameter `uint8 d` of the `createMarket` function is lacking a parameter description in function spec.    ## Impact No direct impact, but with the parameter naming scheme of only using the first letter of its description the parameter spec is essential.  ## Proof of Concept Code snippet for funciton spec + declaration: ``` /// @notice Allows the owner to create new markets /// @param u Underlying token address associated with the new market /// @param m Maturity timestamp of the new market /// @param c cToken address associated with underlying for the new market /// @param n Name of the new zcToken market /// @param s Symbol of the new zcToken market function createMarket(     address u,     uint256 m,     address c,     string memory n,     string memory s,     uint8 d ) public onlyAdmin(admin) returns (bool) ```  ## Recommended Mitigation Steps Add parameter spec for `uint8 d`  
# Handle  loop   # Vulnerability details  Line 124 of Swivel.sol describes the parameter `uint256 a`, but has wrong parameter name: `/// @param o Amount of volume (principal) being filled by the taker's exit`  ## Impact No direct impact apart from code readability  ## Proof of Concept Code snippet for function declaration + spec: ``` /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order   /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate   /// @param o Order being filled   /// @param o Amount of volume (principal) being filled by the taker's exit   /// @param c Components of a valid ECDSA signature   function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal ```  ## Recommended Mitigation Steps Change the second `o` to `a`  
# Handle  0xsanson   # Vulnerability details  ## Impact There are multiple instances of divisions performed before multiplications, whereas the opposite is generally suggested. To mitigate the precision loss, a factor like `1e18` is multiplied and then divided, but this solution is arbitrary and can be avoided.  For example: ```js uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18; ```  can be rewritten like: ```js uint256 principalFilled = a * o.principal / o.premium; ```  ## Proof of Concept Run `grep '1e18' Swivel.sol` for a complete list.  ## Tools Used grep, editor  ## Recommended Mitigation Steps Suggested checking all instances and trying to simplify the math.  
# Handle  0xsanson   # Vulnerability details  ## Impact `Marketplace.calculateReturn` can be rewritten from: ```js function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {   // calculate difference between the cToken exchange rate @ maturity and the current cToken exchange rate   uint256 yield = ((CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent() * 1e26) / maturityRate[u][m]) - 1e26;   uint256 interest = (yield * a) / 1e26;    // calculate the total amount of underlying principle to return   return a + interest; } ```  to: ```js function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {   uint256 rate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();   return  a*rate/ maturityRate[u][m]; } ```  Less math operations means less approximations and less gas used.  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L160-L167  ## Tools Used editor  
# Handle  pauliax   # Vulnerability details  ## Impact boolean flag 'matured' could be removed if you agree to accept maturityRate > 0 as a matured vault, basically replacing:   require(!matured, 'already matured'); with:   require(maturityRate == 0, 'already matured'); This would eliminate one storage variable and thus reduce gas usage. The risk is that exchangeRateCurrent can never be 0 as this would mean an immature state.  ## Recommended Mitigation Steps Consider getting rid of 'matured' as per suggestion.   
# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why there are many functions that always return a boolean value of true. While this may be your agreed practice that you try to follow, it also incurs more gas consumption as the caller needs to receive and check these returned values.  ## Recommended Mitigation Steps If you want to optimize for gas, consider dropping return values for functions that actually do not need them.  
# Handle  pauliax   # Vulnerability details  ## Impact Having both modifiers 'onlyAdmin' and 'onlySwivel' is not only more expensive but also misleading as these modifiers basically do the same job of checking an address against msg.sender.  ## Recommended Mitigation Steps Better have a generalized modifier, something like onlyAddress(address a), and re-use it with both admin and swivel:   modifier onlyAddress(address a) {     require(msg.sender == a, 'sender not authorized');     _;   }   onlyAddress(admin)   onlyAddress(swivel)  
# Handle  pauliax   # Vulnerability details  ## Impact When creating the market (function createMarket), you do not need to specify the address of underlying, it would be less error-prone to dynamically get this from cToken: https://github.com/compound-finance/compound-protocol/blob/master/contracts/CTokenInterfaces.sol#L254   ## Recommended Mitigation Steps While only the admin can create new markets, I think it would still be nice to algorithmically ensure that this underlying token belongs to this cToken and do not leave a chance for human errors.  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact The line:     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');  in Swivel.sol https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L171  Is checking for the return value of `MarketPlace.p2pZcTokenExchange`, however `p2pZcTokenExchange` will always return true or revert  As such the require is not necessary, and doesn't provide any additional guarantees.  ## Recommended Mitigation Steps  Replace `     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed'); `  With  ` MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a) `  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact The function `custodialExit` in Marketplace.sol: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L194  Always returns true or reverts  In swivel.sol the check  `require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed'); ` will always pass, unless the function `custodialExit` reverts  This extra require is not necessary, and provides no additional guarantees as `custodialExit` will always return true or revert   ## Recommended Mitigation Steps Replace ` require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed'); `  With ` mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a) `  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact The variable `marketplace` in Swivel.sol https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L21  is stored as an immutable address  However, every single instance of it's usage casts it to `MarketPlace`  Would recommend storing `marketplace` as `MarketPlace` to make the code cleaner   ## Recommended Mitigation Steps Replace `  address public immutable marketPlace; ` With `   Marketplace public immutable marketPlace; `  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Swivel initiate() and exit() functions accept unbounded arrays from users which may lead to OOG exceptions with insufficient gas sent in transaction.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L55-L77  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L209-L234  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Bounding array lengths or checking gasleft are a good idea to reduce risk of OOG and save userâ€™s gas.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L57  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L211   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove explicit 0 initialization of for loop index variable.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  to.notional += a  can be replaced by to.notional = a because to.notional = 0 in the else part. This will save a few MLOADs.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L189  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Replace to.notional += a  by to.notional = a  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The require(matureMarket(u, m) is redundant because matureMarket always returns true and reverts if any of its require() check fails.  Removing this can save a little gas.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L127  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L75-L91  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove redundant require()  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There are few places across contracts where the same state variables are read multiple times or the same external calls are made multiple times within a function. Caching state variables or results from external calls in local/memory variables avoids SLOADs and CALLs to save gas. Warm SLOADs cost 100 gas and CALLs cost 2600 gas after Berlin upgrade. MLOADs cost only 3 gas units.  ## Proof of Concept  Cache swivel: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L61-L64  Cache markets[u][m]: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L76-L86  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L99-L100  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L111-L112  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L181-L182  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L195-L196   Cache matured and maturityRate: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L156-L179\  Cache vaults: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L244   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Cache state variables or results from external calls in local/memory variables to save gas.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The setFee onlyAdmin function sets the fee denominator but does not perform input validation to check that the fenominator index is between 0-3 which are the only valid values for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit].  The onlyAdmin function performs no threshold check on the new values, emits no event and immediately changes the fenominator value to any arbitrary value proposed by the admin.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L399-L405  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L23-L24  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L46  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Add input validation, threshold check, event and timelock  
# Handle  0xRajeev   # Vulnerability details  ## Impact  This implementation of Sig.sol doesnâ€™t support compact signature (EIP-2098), where signature length can be 64 bytes instead of 65, as supported in the widely used OpenZeppelinâ€™s ECDSA library. This lack of support could lead to DoS for users/clients that use compact signatures.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Sig.sol#L41  See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/1b27c13096d6e4389d62e7b0766a1db53fbb3f1b/contracts/utils/cryptography/ECDSA.sol#L57  https://eips.ethereum.org/EIPS/eip-2098  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider adding support for compact signatures, use OZ ECDSA library or highlight in documentation about this lack of support for EIP-2098.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  TheÂ ecrecoverÂ function is used to verify and execute EIP-2612 permit transactions. The built-in EVM precompile ecrecover is susceptible to signature malleability (because of non-unique s and v values) which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121 and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57).   While this is not exploitable for replay attacks in the current implementation because of the use of nonces, this may become a vulnerability if used elsewhere.   ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/tokens/Erc2612.sol#L48  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Consider using OpenZeppelinâ€™s ECDSA library (which prevents this malleability) instead of the built-in function: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Interfaces are not allowed to define any functions while abstract contracts can have a few defined functions (with at least one undefined function). Abstract contracts declared in the project should really be interfaces because they do not define any functions.   Keeping them abstract is risky because they allow defining functions that may be mistakenly exposed in inherited contracts. Interfaces by design prevent this security risk.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Abstracts.sol#L5-L40  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Convert contracts that do not define any functions to interfaces.  
# Handle  JMukesh   # Vulnerability details  ## Impact In matureMarket(address u, uint256 m) function , different parameter is used in event      emit Mature(u, m, block.timestamp, currentExchangeRate);  maturity rate should before matured timestamp //   event Mature(address indexed underlying, uint256 indexed maturity, uint256 maturityRate, uint256 matured);  impact of this can be severe .   This   error   may   negatively   impact    off-chain   tools   that   are   monitoring   events data  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L88  ## Tools Used manual review  ## Recommended Mitigation Steps   
# Handle  cmichel   # Vulnerability details  The `Swivel` contract approves the `cToken` address whenever it wants to mint `cTokens` upon order fulfilment, see `initiateVaultFillingZcTokenInitiate`.  It could just approve the `cToken` contract once for each market underlying it supports with the max value and save the approval call for each order fulfilment.   
# Handle  leastwood   # Vulnerability details  ## Impact  The `cTokenAddress()` getter function in `MarketPlace.sol` is missing relevant dev comments and appropriate matching syntax. `address a` does not correctly match the proper representation which is the underlying token, typically referenced as `address u`.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L169-L171  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider adding relevant dev comments and updating `address a` -> `address u` to better reflect its meaning.  
# Handle  gpersoon   # Vulnerability details  # Impact The function transferNotionalFrom of VaultTracker.sol uses temporary variables to store the balances. If the "from" and "to" address are the same then the balance of "from" is overwritten by the balance of "to". This means the balance of "from" and "to" are increased and no balances are decreased, effectively printing money.  Note: transferNotionalFrom can be called via transferVaultNotional by everyone.  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/v2/test/vaulttracker/VaultTracker.sol#L144-L196   function transferNotionalFrom(address f, address t, uint256 a) external onlyAdmin(admin) returns (bool) {     Vault memory from = vaults[f];     Vault memory to = vaults[t];     ...     vaults[f] = from;     ...     vaults[t] = to;    // if f==t then this will overwrite vaults[f]    https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L234-L238 function transferVaultNotional(address u, uint256 m, address t, uint256 a) public returns (bool) {     require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(msg.sender, t, a), 'vault transfer failed');     ## Tools Used  ## Recommended Mitigation Steps Add something like the following:    require (f != t,"Same");  
# Handle  gpersoon   # Vulnerability details  ## Impact The contract Swivel.sol contains a few of the following requires:  require(a <= (o.premium - filled[hash]), 'taker amount > available volume');    If "o.premium" happens to be smaller than "filled[hash]", a revert will occur at "o.premium - filled[hash]" and no error message will be displayed.  Also note the statements use slightly different syntax with the parentheses.   ## Proof of Concept Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require((a <= o.principal  - filled[hash]),  'taker amount > available volume');  // slightly different syntax Swivel.sol:    require(a <= ((o.principal - filled[hash])), 'taker amount > available volume');  // slightly different syntax Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.principal  - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.principal  - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume');  ## Tools Used  ## Recommended Mitigation Steps replace  require(a <= (o.xxxx - filled[hash]), 'taker amount > available volume');   with  require( (a + filled[hash]) <= o.xxxx), 'taker amount > available volume');  Use the same parentheses structure everywhere.  
# Handle  pants   # Vulnerability details  The Sig.split function (defined at Line 40 of Sig library) is called only inside the library. Thus function could be set as private.  https://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Sig.sol#L40  ## Recommended Mitigation Steps Make it private :)  ## Tool Used Manual code review.   
# Handle  pants   # Vulnerability details  At both line 59 and 61 the code reads o[i]. It happens inside a loop therefore the best practice which is more gas efficient is to cache o[i] once and use it instead.  https://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Swivel.sol#L59  ## Tool Used Manual code review.   
# Handle  ye0lde   # Vulnerability details  ## Impact Operating on a copy of a state variable seems inefficient and confusing in this case.   From a "gas" standpoint it's less efficient.  And future changes could render the addresses in the copied struct invalid if functions being called in redeemZcToken operate on the original state variable.  ## Proof of Concept The copy occurs here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L123  The "mkt" variable is referenced here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L131  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove line #123: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L123  Replace "mkt" with "markets[u][m]" in line #131 https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L131   
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Taker is charged fees twice in `exitVaultFillingVaultInitiate()` . Maker is transferring less than premiumFilled to taker and then taker is expected to pay fees i.e. taker's net balance is premiumFilled - 2*fee  ## Recommended Mitigation Steps  ```jsx function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {     bytes32 hash = validOrderHash(o, c);      require(a <= (o.principal - filled[hash]), 'taker amount > available volume');          filled[hash] += a;              uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;     uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;      Erc20 uToken = Erc20(o.underlying);     // transfer premium from maker to sender     uToken.transferFrom(o.maker, msg.sender, premiumFilled);      // transfer fee in underlying to swivel from sender     uToken.transferFrom(msg.sender, address(this), fee);      // transfer <a> vault.notional (nTokens) from sender to maker     require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');      emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled); } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  In `initiateZcTokenFillingZcTokenExit()` , this comment `// transfer underlying tokens - the premium paid + fee in underlying to swivel (from sender)`  is incorrect because you are actually transferring the underlying tokens - premium paid to the maker (from sender) AND you have to pay fee separately to swivel.  initiateZCTokenFillingZcTokenExit means I want to sell my nTokens so that means `a` is the amount of principal I want to fill. Let's use a hypothetical example where I (taker) wants to fill 10 units of ZcTokenExit for maker.  1. I transfer 10 units of underlying to Swivel. The net balances are: me (-a), swivel (+a) 2. I transfer fee (in underlying) to Swivel. The net balances are: me (-a-fee), swivel (+a+fee)  3. Swivel initiates my position, sends me the ZcToken and sends Maker the nTokens 4. Maker pays me premiumFilled for the nTokens. The net balances are: me (-a-fee+premiumsFilled), swivel (+a+fee), maker (-premiumsFilled) 5. Maker closes position. The net balances are: me (-a-fee+premiumsFilled), swivel (+fee), maker (-premiumsFilled+a)  So effectively, I (taker) should be paying a-premium to maker and fee to swivel.  ## Recommended Mitigation Steps  ```jsx function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {     bytes32 hash = validOrderHash(o, c);      require(a <= o.principal - filled[hash]), 'taker amount > available volume'); // Note: you don't need to wrap these in brackets because if you look at the https://docs.soliditylang.org/en/latest/cheatsheet.html#order-of-precedence-of-operators, subtraction will always go before comparison       filled[hash] += a;      uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;     uint256 fee = ((premiumFilled * 1e18) / fenominator[0]) / 1e18;      // transfer underlying tokens - the premium paid in underlying to maker (from sender)     Erc20(o.underlying).transferFrom(msg.sender, o.maker, a - premiumFilled);   Erc20(o.underlying).transferFrom(msg.sender, swivel, fee);     // transfer <a> zcTokens between users in marketplace     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');                  emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled); } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  There is no impact to the funds but to align with [best practices]([https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html)), it is always better to update internal state before any external function calls.  ## Recommended Mitigation Steps  For functions `exitVaultFillingZcTokenExit()` and `exitZcTokenFillingVaultExit()`, you should do `mPlace.custodialExit(...)` to update the internal accounting before transferring the tokens out.  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Misleading comments  ## Recommended Mitigation Steps  For these 4 functions, it should say "taker's init" instead of "taker's exit"  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas optimisation. In the function `transferNotionalFee()`,  `sVault.exchangeRate` is only 0 for the very first time this function is called so the if check to see if `sVault.exchangeRate != 0` is only used once to handle this edge case.  It makes more sense to set the exchangeRate when the vault is created and remove these if conditions.  ## Recommended Mitigation Steps  ```jsx constructor(uint256 m, address c, address s) {    admin = msg.sender;    maturity = m;    cTokenAddr = c;    swivel = s;   uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();   vault[swivel] = Vault({        notional: 0,        redeemable: 0,        exchangeRate: exchangeRate    }); } ... function transferNotionalFee(address f, uint256 a) external onlyAdmin(admin) returns(bool) {     Vault memory oVault = vaults[f];     Vault memory sVault = vaults[swivel];      // remove notional from its owner     oVault.notional -= a;      uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();     uint256 yield;     uint256 interest;      // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate     if (sVault.exchangeRate != exchangeRate) {        // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate        // otherwise, calculate marginal exchange rate between current and previous exchange rate.        if (matured) {            // calculate marginal interest            yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;        } else {            yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;        }          interest = (yield * sVault.notional) / 1e26;        sVault.redeemable += interest;       sVault.exchangeRate = exchangeRate;     }      // add notional to swivel's vault     sVault.notional += a;      // store the adjusted vaults     vaults[swivel] = sVault;     vaults[f] = oVault;     return true;   } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Since you are already querying the exchangeRate for the current block in `MarketPlace.matureMarket()` , might as well pass it along to `VaultTracker.sol` instead of querying it a second time.  ## Recommended Mitigation Steps  ```jsx // In VaultTracker.sol function matureVault(uint256 _maturityRate) external onlyAdmin(admin) returns (bool) {    require(!matured, 'already matured');    require(block.timestamp >= maturity, 'maturity has not been reached');    matured = true;   maturityRate = _maturityRate;    return true; } ```  ```jsx // In MarketPlace.sol function matureMarket(address u, uint256 m) public returns (bool) {    require(!mature[u][m], 'market already matured');    require(block.timestamp >= ZcToken(markets[u][m].zcTokenAddr).maturity(), "maturity not reached");      // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate    uint256 currentExchangeRate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();    maturityRate[u][m] = currentExchangeRate;    // set the maturity state to true (for zcb market)    mature[u][m] = true;      // set vault "matured" to true   require(VaultTracker(markets[u][m].vaultAddr).matureVault(currentExchangeRate), 'maturity not reached');      emit Mature(u, m, block.timestamp, currentExchangeRate);      return true; } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  You don't need to store maturity in `VaultTracker.sol` or `ZcToken.sol` because `mapping (address => mapping (uint256 => bool)) public mature;` should already cover it. This will help to remove unnecessary external calls and also reduce the number of maturity checks.  ## Recommended Mitigation Steps  ```jsx // In MarketPlace.sol function createMarket(    address u,    uint256 m,    address c,    string memory n,    string memory s,    uint8 d ) public onlyAdmin(admin) returns (bool) {    require(swivel != address(0), 'swivel contract address not set');    // TODO can we live with the factory pattern here both bytecode size wise and CREATE opcode cost wise?   address zctAddr = address(new ZcToken(u, n, s, d));    address vAddr = address(new VaultTracker(c, swivel));    markets[u][m] = Market(c, zctAddr, vAddr);      emit Create(u, m, c, zctAddr, vAddr);      return true; } ... function matureMarket(address u, uint256 m) public returns (bool) {   require(block.timestamp >= m, "maturity not reached");    require(!mature[u][m], 'market already matured');      // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate    uint256 currentExchangeRate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();    maturityRate[u][m] = currentExchangeRate;    // set the maturity state to true (for zcb market)    mature[u][m] = true;      // set vault "matured" to true    require(VaultTracker(markets[u][m].vaultAddr).matureVault(), 'maturity not reached');      emit Mature(u, m, block.timestamp, currentExchangeRate);      return true; } ```  ```jsx  // In VaultTracker.sol ... // uint256 public immutable maturity; // deleted this ... constructor(address c, address s) {    admin = msg.sender;    cTokenAddr = c;    swivel = s; } ... function matureVault() external onlyAdmin(admin) returns (bool) {    matured = true;    maturityRate = CErc20(cTokenAddr).exchangeRateCurrent();    return true; } ```  ```jsx // uint256 public immutable maturity; // deleted this ... constructor(address u, string memory n, string memory s, uint8 d) Erc2612(n, s, d) {    admin = msg.sender;    underlying = u; } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas op. Since vlt.notional has to be updated in both branches of the if check, you can take vlt.notional out of both branches and skip the else check.  ## Recommended Mitigation Steps  ```jsx function addNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {   uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();   Vault memory vlt = vaults[o];      if (vlt.notional > 0) {      uint256 yield;      uint256 interest;          // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate      // otherwise, calculate marginal exchange rate between current and previous exchange rate.      if (matured) { // Calculate marginal interest         yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;      } else {         yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;      }          interest = (yield * vlt.notional) / 1e26;      // add interest and amount to position, reset cToken exchange rate      vlt.redeemable += interest;       }      vlt.notional += a;   vlt.exchangeRate = exchangeRate;   vaults[o] = vlt;      return true; } ```  
# Handle  defsec   # Vulnerability details  ## Impact  If data can fit into 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. On the MarketPlace.sol contract, string memory variable can be replaced with bytes32 array. That will save gas on the contract.   ## Proof of Concept  1. Navigate to "https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol" contract. 2. Investigate createMarket function. n and s variables can be replaced with bytes32 variable.  ```   function createMarket(     address u,     uint256 m,     address c,     string memory n,     string memory s,     uint8 d   ) public onlyAdmin(admin) returns (bool) {     require(swivel != address(0), 'swivel contract address not set');     // TODO can we live with the factory pattern here both bytecode size wise and CREATE opcode cost wise?     address zctAddr = address(new ZcToken(u, m, n, s, d));     address vAddr = address(new VaultTracker(m, c, swivel));     markets[u][m] = Market(c, zctAddr, vAddr);      emit Create(u, m, c, zctAddr, vAddr);      return true;   } ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to replace string variables with bytes32. That should be definitely cheaper.   
# Handle  ye0lde   # Vulnerability details  ## Impact  There is additional gas usage when an array's length value is used directly in a "for" loop.  ## Proof of Concept  The array's length value is used directly in a for loop here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L57 https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L211   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the loops above from: <code> for (uint256 i=0; i < o.length; i++) </code>  to <code> unit256 length = o.length; for (uint256 i=0; i < length; i++) </code>  When I tested these changes there was a small gas saving.   
# Handle  loop   # Vulnerability details  the parameter `uint8 d` of the `createMarket` function is lacking a parameter description in function spec.    ## Impact No direct impact, but with the parameter naming scheme of only using the first letter of its description the parameter spec is essential.  ## Proof of Concept Code snippet for funciton spec + declaration: ``` /// @notice Allows the owner to create new markets /// @param u Underlying token address associated with the new market /// @param m Maturity timestamp of the new market /// @param c cToken address associated with underlying for the new market /// @param n Name of the new zcToken market /// @param s Symbol of the new zcToken market function createMarket(     address u,     uint256 m,     address c,     string memory n,     string memory s,     uint8 d ) public onlyAdmin(admin) returns (bool) ```  ## Recommended Mitigation Steps Add parameter spec for `uint8 d`  
# Handle  loop   # Vulnerability details  Line 124 of Swivel.sol describes the parameter `uint256 a`, but has wrong parameter name: `/// @param o Amount of volume (principal) being filled by the taker's exit`  ## Impact No direct impact apart from code readability  ## Proof of Concept Code snippet for function declaration + spec: ``` /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order   /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate   /// @param o Order being filled   /// @param o Amount of volume (principal) being filled by the taker's exit   /// @param c Components of a valid ECDSA signature   function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal ```  ## Recommended Mitigation Steps Change the second `o` to `a`  
# Handle  0xsanson   # Vulnerability details  ## Impact There are multiple instances of divisions performed before multiplications, whereas the opposite is generally suggested. To mitigate the precision loss, a factor like `1e18` is multiplied and then divided, but this solution is arbitrary and can be avoided.  For example: ```js uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18; ```  can be rewritten like: ```js uint256 principalFilled = a * o.principal / o.premium; ```  ## Proof of Concept Run `grep '1e18' Swivel.sol` for a complete list.  ## Tools Used grep, editor  ## Recommended Mitigation Steps Suggested checking all instances and trying to simplify the math.  
# Handle  0xsanson   # Vulnerability details  ## Impact `Marketplace.calculateReturn` can be rewritten from: ```js function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {   // calculate difference between the cToken exchange rate @ maturity and the current cToken exchange rate   uint256 yield = ((CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent() * 1e26) / maturityRate[u][m]) - 1e26;   uint256 interest = (yield * a) / 1e26;    // calculate the total amount of underlying principle to return   return a + interest; } ```  to: ```js function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {   uint256 rate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();   return  a*rate/ maturityRate[u][m]; } ```  Less math operations means less approximations and less gas used.  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L160-L167  ## Tools Used editor  
# Handle  pauliax   # Vulnerability details  ## Impact boolean flag 'matured' could be removed if you agree to accept maturityRate > 0 as a matured vault, basically replacing:   require(!matured, 'already matured'); with:   require(maturityRate == 0, 'already matured'); This would eliminate one storage variable and thus reduce gas usage. The risk is that exchangeRateCurrent can never be 0 as this would mean an immature state.  ## Recommended Mitigation Steps Consider getting rid of 'matured' as per suggestion.   
# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why there are many functions that always return a boolean value of true. While this may be your agreed practice that you try to follow, it also incurs more gas consumption as the caller needs to receive and check these returned values.  ## Recommended Mitigation Steps If you want to optimize for gas, consider dropping return values for functions that actually do not need them.  
# Handle  pauliax   # Vulnerability details  ## Impact Having both modifiers 'onlyAdmin' and 'onlySwivel' is not only more expensive but also misleading as these modifiers basically do the same job of checking an address against msg.sender.  ## Recommended Mitigation Steps Better have a generalized modifier, something like onlyAddress(address a), and re-use it with both admin and swivel:   modifier onlyAddress(address a) {     require(msg.sender == a, 'sender not authorized');     _;   }   onlyAddress(admin)   onlyAddress(swivel)  
# Handle  pauliax   # Vulnerability details  ## Impact When creating the market (function createMarket), you do not need to specify the address of underlying, it would be less error-prone to dynamically get this from cToken: https://github.com/compound-finance/compound-protocol/blob/master/contracts/CTokenInterfaces.sol#L254   ## Recommended Mitigation Steps While only the admin can create new markets, I think it would still be nice to algorithmically ensure that this underlying token belongs to this cToken and do not leave a chance for human errors.  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact The line:     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');  in Swivel.sol https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L171  Is checking for the return value of `MarketPlace.p2pZcTokenExchange`, however `p2pZcTokenExchange` will always return true or revert  As such the require is not necessary, and doesn't provide any additional guarantees.  ## Recommended Mitigation Steps  Replace `     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed'); `  With  ` MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a) `  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact The function `custodialExit` in Marketplace.sol: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L194  Always returns true or reverts  In swivel.sol the check  `require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed'); ` will always pass, unless the function `custodialExit` reverts  This extra require is not necessary, and provides no additional guarantees as `custodialExit` will always return true or revert   ## Recommended Mitigation Steps Replace ` require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed'); `  With ` mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a) `  
# Handle  GalloDaSballo   # Vulnerability details  ## Impact The variable `marketplace` in Swivel.sol https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L21  is stored as an immutable address  However, every single instance of it's usage casts it to `MarketPlace`  Would recommend storing `marketplace` as `MarketPlace` to make the code cleaner   ## Recommended Mitigation Steps Replace `  address public immutable marketPlace; ` With `   Marketplace public immutable marketPlace; `  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Swivel initiate() and exit() functions accept unbounded arrays from users which may lead to OOG exceptions with insufficient gas sent in transaction.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L55-L77  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L209-L234  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Bounding array lengths or checking gasleft are a good idea to reduce risk of OOG and save userâ€™s gas.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L57  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L211   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove explicit 0 initialization of for loop index variable.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  to.notional += a  can be replaced by to.notional = a because to.notional = 0 in the else part. This will save a few MLOADs.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L189  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Replace to.notional += a  by to.notional = a  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The require(matureMarket(u, m) is redundant because matureMarket always returns true and reverts if any of its require() check fails.  Removing this can save a little gas.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L127  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L75-L91  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove redundant require()  
# Handle  0xRajeev   # Vulnerability details  ## Impact  There are few places across contracts where the same state variables are read multiple times or the same external calls are made multiple times within a function. Caching state variables or results from external calls in local/memory variables avoids SLOADs and CALLs to save gas. Warm SLOADs cost 100 gas and CALLs cost 2600 gas after Berlin upgrade. MLOADs cost only 3 gas units.  ## Proof of Concept  Cache swivel: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L61-L64  Cache markets[u][m]: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L76-L86  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L99-L100  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L111-L112  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L181-L182  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L195-L196   Cache matured and maturityRate: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L156-L179\  Cache vaults: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L244   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Cache state variables or results from external calls in local/memory variables to save gas.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  The setFee onlyAdmin function sets the fee denominator but does not perform input validation to check that the fenominator index is between 0-3 which are the only valid values for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit].  The onlyAdmin function performs no threshold check on the new values, emits no event and immediately changes the fenominator value to any arbitrary value proposed by the admin.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L399-L405  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L23-L24  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L46  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Add input validation, threshold check, event and timelock  
# Handle  0xRajeev   # Vulnerability details  ## Impact  This implementation of Sig.sol doesnâ€™t support compact signature (EIP-2098), where signature length can be 64 bytes instead of 65, as supported in the widely used OpenZeppelinâ€™s ECDSA library. This lack of support could lead to DoS for users/clients that use compact signatures.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Sig.sol#L41  See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/1b27c13096d6e4389d62e7b0766a1db53fbb3f1b/contracts/utils/cryptography/ECDSA.sol#L57  https://eips.ethereum.org/EIPS/eip-2098  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider adding support for compact signatures, use OZ ECDSA library or highlight in documentation about this lack of support for EIP-2098.  
# Handle  0xRajeev   # Vulnerability details  ## Impact  TheÂ ecrecoverÂ function is used to verify and execute EIP-2612 permit transactions. The built-in EVM precompile ecrecover is susceptible to signature malleability (because of non-unique s and v values) which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121 and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57).   While this is not exploitable for replay attacks in the current implementation because of the use of nonces, this may become a vulnerability if used elsewhere.   ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/tokens/Erc2612.sol#L48  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Consider using OpenZeppelinâ€™s ECDSA library (which prevents this malleability) instead of the built-in function: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol  
# Handle  0xRajeev   # Vulnerability details  ## Impact  Interfaces are not allowed to define any functions while abstract contracts can have a few defined functions (with at least one undefined function). Abstract contracts declared in the project should really be interfaces because they do not define any functions.   Keeping them abstract is risky because they allow defining functions that may be mistakenly exposed in inherited contracts. Interfaces by design prevent this security risk.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Abstracts.sol#L5-L40  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Convert contracts that do not define any functions to interfaces.  
# Handle  JMukesh   # Vulnerability details  ## Impact In matureMarket(address u, uint256 m) function , different parameter is used in event      emit Mature(u, m, block.timestamp, currentExchangeRate);  maturity rate should before matured timestamp //   event Mature(address indexed underlying, uint256 indexed maturity, uint256 maturityRate, uint256 matured);  impact of this can be severe .   This   error   may   negatively   impact    off-chain   tools   that   are   monitoring   events data  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L88  ## Tools Used manual review  ## Recommended Mitigation Steps   
# Handle  cmichel   # Vulnerability details  The `Swivel` contract approves the `cToken` address whenever it wants to mint `cTokens` upon order fulfilment, see `initiateVaultFillingZcTokenInitiate`.  It could just approve the `cToken` contract once for each market underlying it supports with the max value and save the approval call for each order fulfilment.   
# Handle  leastwood   # Vulnerability details  ## Impact  The `cTokenAddress()` getter function in `MarketPlace.sol` is missing relevant dev comments and appropriate matching syntax. `address a` does not correctly match the proper representation which is the underlying token, typically referenced as `address u`.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L169-L171  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider adding relevant dev comments and updating `address a` -> `address u` to better reflect its meaning.  
# Handle  gpersoon   # Vulnerability details  # Impact The function transferNotionalFrom of VaultTracker.sol uses temporary variables to store the balances. If the "from" and "to" address are the same then the balance of "from" is overwritten by the balance of "to". This means the balance of "from" and "to" are increased and no balances are decreased, effectively printing money.  Note: transferNotionalFrom can be called via transferVaultNotional by everyone.  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/v2/test/vaulttracker/VaultTracker.sol#L144-L196   function transferNotionalFrom(address f, address t, uint256 a) external onlyAdmin(admin) returns (bool) {     Vault memory from = vaults[f];     Vault memory to = vaults[t];     ...     vaults[f] = from;     ...     vaults[t] = to;    // if f==t then this will overwrite vaults[f]    https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L234-L238 function transferVaultNotional(address u, uint256 m, address t, uint256 a) public returns (bool) {     require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(msg.sender, t, a), 'vault transfer failed');     ## Tools Used  ## Recommended Mitigation Steps Add something like the following:    require (f != t,"Same");  
# Handle  gpersoon   # Vulnerability details  ## Impact The contract Swivel.sol contains a few of the following requires:  require(a <= (o.premium - filled[hash]), 'taker amount > available volume');    If "o.premium" happens to be smaller than "filled[hash]", a revert will occur at "o.premium - filled[hash]" and no error message will be displayed.  Also note the statements use slightly different syntax with the parentheses.   ## Proof of Concept Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require((a <= o.principal  - filled[hash]),  'taker amount > available volume');  // slightly different syntax Swivel.sol:    require(a <= ((o.principal - filled[hash])), 'taker amount > available volume');  // slightly different syntax Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.principal  - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.principal  - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume');  ## Tools Used  ## Recommended Mitigation Steps replace  require(a <= (o.xxxx - filled[hash]), 'taker amount > available volume');   with  require( (a + filled[hash]) <= o.xxxx), 'taker amount > available volume');  Use the same parentheses structure everywhere.  
# Handle  pants   # Vulnerability details  The Sig.split function (defined at Line 40 of Sig library) is called only inside the library. Thus function could be set as private.  https://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Sig.sol#L40  ## Recommended Mitigation Steps Make it private :)  ## Tool Used Manual code review.   
# Handle  pants   # Vulnerability details  At both line 59 and 61 the code reads o[i]. It happens inside a loop therefore the best practice which is more gas efficient is to cache o[i] once and use it instead.  https://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Swivel.sol#L59  ## Tool Used Manual code review.   
# Handle  ye0lde   # Vulnerability details  ## Impact Operating on a copy of a state variable seems inefficient and confusing in this case.   From a "gas" standpoint it's less efficient.  And future changes could render the addresses in the copied struct invalid if functions being called in redeemZcToken operate on the original state variable.  ## Proof of Concept The copy occurs here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L123  The "mkt" variable is referenced here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L131  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove line #123: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L123  Replace "mkt" with "markets[u][m]" in line #131 https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L131   
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Taker is charged fees twice in `exitVaultFillingVaultInitiate()` . Maker is transferring less than premiumFilled to taker and then taker is expected to pay fees i.e. taker's net balance is premiumFilled - 2*fee  ## Recommended Mitigation Steps  ```jsx function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {     bytes32 hash = validOrderHash(o, c);      require(a <= (o.principal - filled[hash]), 'taker amount > available volume');          filled[hash] += a;              uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;     uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;      Erc20 uToken = Erc20(o.underlying);     // transfer premium from maker to sender     uToken.transferFrom(o.maker, msg.sender, premiumFilled);      // transfer fee in underlying to swivel from sender     uToken.transferFrom(msg.sender, address(this), fee);      // transfer <a> vault.notional (nTokens) from sender to maker     require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');      emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled); } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  In `initiateZcTokenFillingZcTokenExit()` , this comment `// transfer underlying tokens - the premium paid + fee in underlying to swivel (from sender)`  is incorrect because you are actually transferring the underlying tokens - premium paid to the maker (from sender) AND you have to pay fee separately to swivel.  initiateZCTokenFillingZcTokenExit means I want to sell my nTokens so that means `a` is the amount of principal I want to fill. Let's use a hypothetical example where I (taker) wants to fill 10 units of ZcTokenExit for maker.  1. I transfer 10 units of underlying to Swivel. The net balances are: me (-a), swivel (+a) 2. I transfer fee (in underlying) to Swivel. The net balances are: me (-a-fee), swivel (+a+fee)  3. Swivel initiates my position, sends me the ZcToken and sends Maker the nTokens 4. Maker pays me premiumFilled for the nTokens. The net balances are: me (-a-fee+premiumsFilled), swivel (+a+fee), maker (-premiumsFilled) 5. Maker closes position. The net balances are: me (-a-fee+premiumsFilled), swivel (+fee), maker (-premiumsFilled+a)  So effectively, I (taker) should be paying a-premium to maker and fee to swivel.  ## Recommended Mitigation Steps  ```jsx function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {     bytes32 hash = validOrderHash(o, c);      require(a <= o.principal - filled[hash]), 'taker amount > available volume'); // Note: you don't need to wrap these in brackets because if you look at the https://docs.soliditylang.org/en/latest/cheatsheet.html#order-of-precedence-of-operators, subtraction will always go before comparison       filled[hash] += a;      uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;     uint256 fee = ((premiumFilled * 1e18) / fenominator[0]) / 1e18;      // transfer underlying tokens - the premium paid in underlying to maker (from sender)     Erc20(o.underlying).transferFrom(msg.sender, o.maker, a - premiumFilled);   Erc20(o.underlying).transferFrom(msg.sender, swivel, fee);     // transfer <a> zcTokens between users in marketplace     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');                  emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled); } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  There is no impact to the funds but to align with [best practices]([https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html)), it is always better to update internal state before any external function calls.  ## Recommended Mitigation Steps  For functions `exitVaultFillingZcTokenExit()` and `exitZcTokenFillingVaultExit()`, you should do `mPlace.custodialExit(...)` to update the internal accounting before transferring the tokens out.  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Misleading comments  ## Recommended Mitigation Steps  For these 4 functions, it should say "taker's init" instead of "taker's exit"  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas optimisation. In the function `transferNotionalFee()`,  `sVault.exchangeRate` is only 0 for the very first time this function is called so the if check to see if `sVault.exchangeRate != 0` is only used once to handle this edge case.  It makes more sense to set the exchangeRate when the vault is created and remove these if conditions.  ## Recommended Mitigation Steps  ```jsx constructor(uint256 m, address c, address s) {    admin = msg.sender;    maturity = m;    cTokenAddr = c;    swivel = s;   uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();   vault[swivel] = Vault({        notional: 0,        redeemable: 0,        exchangeRate: exchangeRate    }); } ... function transferNotionalFee(address f, uint256 a) external onlyAdmin(admin) returns(bool) {     Vault memory oVault = vaults[f];     Vault memory sVault = vaults[swivel];      // remove notional from its owner     oVault.notional -= a;      uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();     uint256 yield;     uint256 interest;      // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate     if (sVault.exchangeRate != exchangeRate) {        // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate        // otherwise, calculate marginal exchange rate between current and previous exchange rate.        if (matured) {            // calculate marginal interest            yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;        } else {            yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;        }          interest = (yield * sVault.notional) / 1e26;        sVault.redeemable += interest;       sVault.exchangeRate = exchangeRate;     }      // add notional to swivel's vault     sVault.notional += a;      // store the adjusted vaults     vaults[swivel] = sVault;     vaults[f] = oVault;     return true;   } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Since you are already querying the exchangeRate for the current block in `MarketPlace.matureMarket()` , might as well pass it along to `VaultTracker.sol` instead of querying it a second time.  ## Recommended Mitigation Steps  ```jsx // In VaultTracker.sol function matureVault(uint256 _maturityRate) external onlyAdmin(admin) returns (bool) {    require(!matured, 'already matured');    require(block.timestamp >= maturity, 'maturity has not been reached');    matured = true;   maturityRate = _maturityRate;    return true; } ```  ```jsx // In MarketPlace.sol function matureMarket(address u, uint256 m) public returns (bool) {    require(!mature[u][m], 'market already matured');    require(block.timestamp >= ZcToken(markets[u][m].zcTokenAddr).maturity(), "maturity not reached");      // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate    uint256 currentExchangeRate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();    maturityRate[u][m] = currentExchangeRate;    // set the maturity state to true (for zcb market)    mature[u][m] = true;      // set vault "matured" to true   require(VaultTracker(markets[u][m].vaultAddr).matureVault(currentExchangeRate), 'maturity not reached');      emit Mature(u, m, block.timestamp, currentExchangeRate);      return true; } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  You don't need to store maturity in `VaultTracker.sol` or `ZcToken.sol` because `mapping (address => mapping (uint256 => bool)) public mature;` should already cover it. This will help to remove unnecessary external calls and also reduce the number of maturity checks.  ## Recommended Mitigation Steps  ```jsx // In MarketPlace.sol function createMarket(    address u,    uint256 m,    address c,    string memory n,    string memory s,    uint8 d ) public onlyAdmin(admin) returns (bool) {    require(swivel != address(0), 'swivel contract address not set');    // TODO can we live with the factory pattern here both bytecode size wise and CREATE opcode cost wise?   address zctAddr = address(new ZcToken(u, n, s, d));    address vAddr = address(new VaultTracker(c, swivel));    markets[u][m] = Market(c, zctAddr, vAddr);      emit Create(u, m, c, zctAddr, vAddr);      return true; } ... function matureMarket(address u, uint256 m) public returns (bool) {   require(block.timestamp >= m, "maturity not reached");    require(!mature[u][m], 'market already matured');      // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate    uint256 currentExchangeRate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();    maturityRate[u][m] = currentExchangeRate;    // set the maturity state to true (for zcb market)    mature[u][m] = true;      // set vault "matured" to true    require(VaultTracker(markets[u][m].vaultAddr).matureVault(), 'maturity not reached');      emit Mature(u, m, block.timestamp, currentExchangeRate);      return true; } ```  ```jsx  // In VaultTracker.sol ... // uint256 public immutable maturity; // deleted this ... constructor(address c, address s) {    admin = msg.sender;    cTokenAddr = c;    swivel = s; } ... function matureVault() external onlyAdmin(admin) returns (bool) {    matured = true;    maturityRate = CErc20(cTokenAddr).exchangeRateCurrent();    return true; } ```  ```jsx // uint256 public immutable maturity; // deleted this ... constructor(address u, string memory n, string memory s, uint8 d) Erc2612(n, s, d) {    admin = msg.sender;    underlying = u; } ```  
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas op. Since vlt.notional has to be updated in both branches of the if check, you can take vlt.notional out of both branches and skip the else check.  ## Recommended Mitigation Steps  ```jsx function addNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {   uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();   Vault memory vlt = vaults[o];      if (vlt.notional > 0) {      uint256 yield;      uint256 interest;          // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate      // otherwise, calculate marginal exchange rate between current and previous exchange rate.      if (matured) { // Calculate marginal interest         yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;      } else {         yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;      }          interest = (yield * vlt.notional) / 1e26;      // add interest and amount to position, reset cToken exchange rate      vlt.redeemable += interest;       }      vlt.notional += a;   vlt.exchangeRate = exchangeRate;   vaults[o] = vlt;      return true; } ```  
# Handle  defsec   # Vulnerability details  ## Impact  If data can fit into 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. On the MarketPlace.sol contract, string memory variable can be replaced with bytes32 array. That will save gas on the contract.   ## Proof of Concept  1. Navigate to "https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol" contract. 2. Investigate createMarket function. n and s variables can be replaced with bytes32 variable.  ```   function createMarket(     address u,     uint256 m,     address c,     string memory n,     string memory s,     uint8 d   ) public onlyAdmin(admin) returns (bool) {     require(swivel != address(0), 'swivel contract address not set');     // TODO can we live with the factory pattern here both bytecode size wise and CREATE opcode cost wise?     address zctAddr = address(new ZcToken(u, m, n, s, d));     address vAddr = address(new VaultTracker(m, c, swivel));     markets[u][m] = Market(c, zctAddr, vAddr);      emit Create(u, m, c, zctAddr, vAddr);      return true;   } ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to replace string variables with bytes32. That should be definitely cheaper.   
# Handle  ye0lde   # Vulnerability details  ## Impact  There is additional gas usage when an array's length value is used directly in a "for" loop.  ## Proof of Concept  The array's length value is used directly in a for loop here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L57 https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L211   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the loops above from: <code> for (uint256 i=0; i < o.length; i++) </code>  to <code> unit256 length = o.length; for (uint256 i=0; i < length; i++) </code>  When I tested these changes there was a small gas saving.   
# Handle  loop   # Vulnerability details  the parameter `uint8 d` of the `createMarket` function is lacking a parameter description in function spec.    ## Impact No direct impact, but with the parameter naming scheme of only using the first letter of its description the parameter spec is essential.  ## Proof of Concept Code snippet for funciton spec + declaration: ``` /// @notice Allows the owner to create new markets /// @param u Underlying token address associated with the new market /// @param m Maturity timestamp of the new market /// @param c cToken address associated with underlying for the new market /// @param n Name of the new zcToken market /// @param s Symbol of the new zcToken market function createMarket(     address u,     uint256 m,     address c,     string memory n,     string memory s,     uint8 d ) public onlyAdmin(admin) returns (bool) ```  ## Recommended Mitigation Steps Add parameter spec for `uint8 d`  
# Handle  loop   # Vulnerability details  Line 124 of Swivel.sol describes the parameter `uint256 a`, but has wrong parameter name: `/// @param o Amount of volume (principal) being filled by the taker's exit`  ## Impact No direct impact apart from code readability  ## Proof of Concept Code snippet for function declaration + spec: ``` /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order   /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate   /// @param o Order being filled   /// @param o Amount of volume (principal) being filled by the taker's exit   /// @param c Components of a valid ECDSA signature   function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal ```  ## Recommended Mitigation Steps Change the second `o` to `a`  
