# Handle  pants   # Vulnerability details  WadRayMath state variables WAD, halfWAD could be set private.  
# Handle  pants   # Vulnerability details  In Treasury.editSchedule      function editSchedule(         uint256 dripStart_,         uint256 dripRate_,         address target_,         uint256 amount_     ) public onlyAdmin {         require(tokenSchedules[target_].target != address(0), "Target schedule doesn't exist");         tokenSchedules[target_].dripStart = dripStart_;         tokenSchedules[target_].dripRate = dripRate_;         tokenSchedules[target_].amount = amount_;     }   We suggest to cache  tokenSchedules[target_] at start and then use the cached value to save repeated access to a *storage* state variable.  
# Handle  pants   # Vulnerability details  See for example the AssetsManager.rebalance function. There you read the value moneyMarkets[i] twice at the same iteration instead of caching it. This happens in the same file in many other places, deposit, withdraw and more. Inside a loop caching is very important.   
# Handle  pants   # Vulnerability details  The function __UToken_init can be frontrun. We recommend adding an initializer owner which only it allowed to call such functions, instead of the current _admin there.  Not sure whether frontrunning is Low / Medium risk.  
# Handle  pants   # Vulnerability details  This is one of many examples of the appearance of private instead of internal. Since we manually code reviewing and writing issues we don't list all the appearances. Calling a private function is more gas efficient than calling internal.   Here we refer to UToken.sol._redeemFresh function that is used only in UToken.sol file.   
# Handle  pants   # Vulnerability details  Line 57  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Resolve the TODO and bubble up the error.  
# Handle  pauliax   # Vulnerability details  ## Impact .length in a loop can be extracted into a variable and used where necessary to reduce the number of storage reads. An example where this could be applied:   for (uint256 i = 0; i < moneyMarkets.length; i++) Solution:   uint moneyMarketsLength = moneyMarkets.length;   for (uint256 i = 0; i < moneyMarketsLength; i++) Cache the length of the array and use this local variable when iterating over the storage array.  
# Handle  pauliax   # Vulnerability details  ## Impact This duration calculation does not change so can be pre-calculated to reduce gas costs:   // before   amount = (vestingAmount * (block.timestamp - lastUpdate)) / (vestingEnd - vestingBegin);    // after   uint256 public constant VESTING_DURATION; // constant state variable   VESTING_DURATION = vestingEnd - vestingBegin; // assign value in the constructor   amount = (vestingAmount * (block.timestamp - lastUpdate)) / VESTING_DURATION;  Same with this:   return (token.getPastTotalSupply(blockNumber) * 4e16) / 1e18; //4%   
# Handle  pauliax   # Vulnerability details  ## Impact It is not efficient to have a struct with only 1 field as structs are meant for grouping related information together. A market struct can be replaced by directly pointing to a bool value:     //before     mapping(address => Market) public supportedMarkets;     struct Market {         bool isSupported;     }     //after    mapping(address => bool) public supportedMarkets;   
# Handle  pauliax   # Vulnerability details  ## Impact In Treasury function setAdmin allows an admin to change it to a different address. This function has no validations, even a simple check for zero-address is missing, and there is no validation of the new address being correct. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked because the swivel cannot be corrected and none of the other functions that require admin caller can be executed. A similar issue was reported in a previous contest and was assigned a severity of medium: https://github.com/code-423n4/2021-06-realitycards-findings/issues/105  ## Recommended Mitigation Steps Consider either introducing a two-step process or making a test call to the new admin before updating it.  
# Handle  kenzo   # Vulnerability details  By adding a small of amount of staking to a normal user scenario, and not approving this small amount as a loan for anybody, a staker can gain disproportionate amounts of comptroller rewards, even to the point of draining the contract. For example: Stakers A,B,C stake 100, 65, 20, approve it for borrower Z, then staker B stakes an additional 0.07 DAI, and borrower Z borrows 185. This will result in disproportionate amount of rewards.   As far as I see, this is the main line that causes the inflated amount (*deep breath*): In calculateRewardsByBlocks, you set: ``` userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140 Note that a staker can make this amount very small (depending of course on the current numbers of the protocol). (A more advanced attacker might diminish the effect of the current numbers of the protocol by initiating fake loans to himself and not paying them.) This field is then passed to calculateRewards, and passed further to _getInflationIndexNew, and further to _getInflationIndex. passed to calculateRewards : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L167 passed to _getInflationIndexNew : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L259 passed to _getInflationIndex : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L238 Now we actually use it in the following line (as effectiveAmount): ``` return blockDelta * inflationPerBlock(effectiveAmount).wadDiv(effectiveAmount) + inflationIndex; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L315 So 2 things are happening here: 1. mul by ```inflationPerBlock(effectiveAmount)``` - uses the lookup table in Comptroller. This value gets bigger as effectiveAmount gets smaller, and if effectiveAmount is in the area of 10**18, we will get the maximum amount of the lookup. 2. div by ```effectiveAmount``` - as we saw, this can be made small, thereby enlarging the result. All together, this calculation will be set to ```curInflationIndex``` and then used in the following line: ``` return (curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount).wadMul(inflationIndex); ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L263 Note the ```curInflationIndex - startInflationIndex```: per my POC (see below), this can result in a curInflationIndex which is orders of magnitude larger (200x) than startInflationIndex. This creates a huge inflation of rewards.  ## Impact Comptroller rewards can be drained.  ## Proof of Concept See the following script for a POC of reward drainage. It is based on the scenario in test/integration/testUserManager: Stakers A,B,C stake 100, 65, 20, and borrower Z borrows 185. But the difference in my script is that just before borrower Z borrows 185, staker B stakes an additional 0.07 DAI. (This will be the small amount that is ```totalStaked - totalFrozen```). Then, we wait 11 blocks to make the loan overdue, call updateOverdueInfo so totalFrozen would be updated, and then staker B calls withdrawRewards. He ends up with 873 unionTokens out of the 1000 the Comptroller has been seeded with. And this number can be enlarged by changing the small additional amount that staker B staked. In this scenario, when calling withdrawRewards, the calculated ```curInflationIndex``` will be 215 WAD, while ```startInflationIndex``` is 1 WAD, and this is the main issue as I understand it.  File password: "union". https://pastebin.com/3bJF8mTe   ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Are you sure that this line should deduct the totalFrozen? ``` userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140 Per my tests, if we change it to just  ``` userManagerData.totalStaked = userManagerContract.totalStaked(); ``` Then we are getting normal results again and no drainage. And the var _is_ called just totalStaked... So maybe this is the change that needs to be made? But maybe you have a reason to deduct the totalFrozen. If so, then a mitigation will perhaps be to limit curInflationIndex somehow, maybe by changing the lookup table, or limiting it to a percentage from startInflationIndex ; but even then, there is also the issue of dividing by ```userManagerData.totalStaked``` which can be made quite small as the user has control over that.  
# Handle  WatchPug   # Vulnerability details  In the current implementation, `UToken.sol` does not inherit and comply with `IUToken.sol`. This is against the best practices and inconsistent with other contracts in the codebase that do inherit and comply with their interfaces.  For example, the `repay()` function defined in `IUToken.sol` is implementated as `repayBorrowBehalf()` and `repayBorrow()`.  It makes the `IUToken.sol` unable to be used and misleading.  ### Recommendation  Make `UToken.sol` inherits and complies with `IUToken.sol`.  
# Handle  cmichel   # Vulnerability details  The `UToken` contract uses solidity version 0.8 which already comes with implicit overflow checks. The explicit overflow checks in `removeReserves` can be removed:  ```solidity // We checked reduceAmount <= totalReserves above, so this should never revert. // @audit this overflow check already happened implicitly require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow"); ```  
# Handle  cmichel   # Vulnerability details  The `UToken` contract uses solidity version 0.8 which already comes with implicit overflow checks. The explicit overflow checks in `addReserves` can be removed:  ```solidity /* Revert on overflow */ // @audit this overflow check already happened implicitly require(totalReservesNew >= totalReserves, "add reserves unexpected overflow"); totalReserves = totalReservesNew; ```  
# Handle  cmichel   # Vulnerability details  The `UnionToken` can check for a whitelist on each transfer in `_beforeTokenTransfer`:  ```solidity if (whitelistEnabled) {     require(isWhitelisted(msg.sender) || to == address(0), "Whitelistable: address not whitelisted"); } ```  This whitelist is checked on `msg.sender` not on `from`, the token owner.  ## Impact A single whitelisted account can act as an operator (everyone calls `unionToken.allow(operator, max)` where the operator is a whitelisted trusted smart contract) for all other accounts. This essentially bypasses the whitelist.  ## Recommended Mitigation Steps Think about if the whitelist on `msg.sender` is correct or if it should be on `from`.  
# Handle  cmichel   # Vulnerability details  The `UToken.repayBorrowWithPermit` function is missing the `repayBorrowWithPermit` modifier which the other repay functions (`repayBorrow`, `repayBorrowBehalf`) have.  ## Impact There's a possibility for re-entrancy. Even though I did not find a way to exploit it, it seems like this function should have the `nonReentrant` modifier as the other similar `repay*` functions have it as well.  ## Recommended Mitigation Steps Add `nonReentrant` to `repayBorrowWithPermit`.  
# Handle  cmichel   # Vulnerability details  The `UToken.borrow` function first checks the borrowed balance and the old credit limit _before_ accruing the actual interest on the market:  ```solidity // @audit this uses the old value require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, "UToken: amount large than borrow size max");  require(     // @audit this calls uToken.calculateInterest(account) which returns old value     uint256(_getCreditLimit(msg.sender)) >= amount + fee,     "UToken: The loan amount plus fee is greater than credit limit" );  // @audit accrual only happens here require(accrueInterest(), "UToken: accrue interest failed"); ```  Thus the borrowed balance of the user does not include the latest interest as it uses the old global `borrowIndex` but the new `borrowIndex` is only set in `accrueInterest`.  ## Impact In low-activity markets, it could be that the `borrowIndex` accruals (`accrueInterest` calls) happen infrequently and a long time is between them. A borrower could borrow tokens, and borrow more tokens later at a different time without first having their latest debt accrued. This will lead to borrowers being able to borrow more than `maxBorrow` and **more than their credit limit** as these checks are performed before updating accruing interest.  ## Recommended Mitigation Steps The `require(accrueInterest(), "UToken: accrue interest failed");` call should happen at the beginning of the function.   
# Handle  cmichel   # Vulnerability details  The `MarketRegistry.deleteMarket` iterates over all `uTokenList` elements.  ## Impact The transactions can fail if the arrays get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.  ## Recommended Mitigation Steps Keep the array small or use an [EnumerableSet])(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol) that can delete in constant time.  
# Handle  cmichel   # Vulnerability details  The `AssetManager.rebalance` function has a check at the end to ensure that all tokens are deposited again:  ```solidity require(token.balanceOf(address(this)) == 0, "AssetManager: there are remaining funds in the fund pool"); ```  The idea is that the last market deposits all `remainingTokens` but the last market does not have to support the token in which case the transaction will fail, or the `percentages` parameter needs to be chosen to distribute all tokens before the last one (they need to add up to `1e4`). However, these percentages have a low precision as they are in base points, i.e, the lowest unit is `1 = 0.01%`. This will leave dust in the contract in most cases as the tokens have much higher precision.  ## POC Assume the last market does not support the token and thus `percentages` are chosen as `[5000, 5000]` to rebalance the first two markets. Withdrawing all tokens form the markets leads to a `tokenSupply = token.balanceOf(address(this)) = 10,001`:  Then the deposited amount is `amountToDeposit = (tokenSupply * percentages[i]) / 10000 = 10,001 * 5,000 / 10,000 = 5,000`. The two deposits will leave dust of `10,001 - 2 * 5,000 = 1` in the contract and the `token.balanceOf(address(this)) == 0` balance check will revert.  ## Impact Rebalancing will fail in most cases if the last market does not support the token due to precision errors.  ## Recommended Mitigation Steps Remove the final zero balance check, or make sure that the last market that is actually deposited to receives all remaining tokens.   
# Handle  cmichel   # Vulnerability details  The `AssetManager.withdraw` function iterates through the markets based on the `withdrawSeq` array field. This field must be manually set to cover all markets on each new market addition.  ## Impact It could be that a market is added but this array is not updated. Thus not all markets are iterated and users might not be able to withdraw their entire `amount` as the new market is skipped  ## Recommended Mitigation Steps Ensure that `withdrawSeq` is always up-to-date when `addAdapter` is called, for example, `addAdapter` could add the new adapter as the last element to `withdrawSeq` until it's manually set through `changeWithdrawSequence`.   
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  The require statement in `updateTotalFrozen` and `batchUpdateTotalFrozen` to check that totalStaked ≥ totalFrozen should be done both before and after `_updateTotalFrozen` is called to ensure that totalStake is still ≥ totalFrozen. This will serve as a sanity check to ensure that the integrity of the system is not compromised.  
# Handle  ye0lde   # Vulnerability details  ## Impact  There is no need to keep iterating through a loop for the full length once the condition being searched for is met.  This will save gas.  ## Proof of Concept  The loops are here: https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L436-L441 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L444-L449 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L479-L485 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L488-L495  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add a "break" statement to the loops mentioned above. Note also that there are unnecessary default value initializations of variables associated with the loops.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The ability of a borrower to repay a loan is disabled if the interest rate is  set too high by the `InterestRateModel`.  However, there is neither a check when setting the interest rate nor an  indication in the `IInterestRateModel`'s specs of this behavior.  But this issue could also be used in an adversarial fashion by the  `FixedInterestRateModel`-owner if he/she would disable the repay functionality  for some time and enables it at a later point again with the demand of a  higher interest to be paid by the borrower.  ## Proof of Concept If an account wants to repay a loan, the function  `UToken::_repayBorrowFresh()` is used. This function calls  `UToken::accrueInterest()` ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L465) 465)  which fetches the current borrow rate of the interest rate model  ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L546) 546  and [line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L330) 330).  The function `UToken::borrowRatePerBlock()` requires an not "absurdly high"  rate, or fails otherwise ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L331) 331).  However, there is no check or indicator in `FixedInterestRateModel.sol` to  prevent the owner to set such a high rate that effectively disables repay of borrowed funds ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/FixedInterestRateModel.sol#L36) 36).  ## Recommended Mitigation Steps Disallow setting the interest rate too high with a check in  `FixedInterestRateModel::setInterestRate()`.  
# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in UserManager.sol.  ## Proof of Concept   Missing events  https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L156  https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L160   See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function setHalfDecayPoint allows setting an arbitrary value of halfDecayPoint. However if halfDecayPoint == 0 then inflationPerBlock will have a division by 0.  Probably it is also useful to have an upper limit for halfDecayPoint.  ## Proof of Concept https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/token/Comptroller.sol#L67-L69  https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/token/Comptroller.sol#L275-L278   ## Tools Used  ## Recommended Mitigation Steps In the function setHalfDecayPoint: Verify that the new value of halfDecayPoint is within an allowable range ( certainly != 0)  
# Handle  defsec   # Vulnerability details  ## Impact  Zero-address checks are a best-practise for input validation of critical address parameters. While the codebase applies this to most addresses in setters, there are many places where this is missing in constructors and setters.  Impact: Accidental use of zero-addresses may result in exceptions, burn fees/tokens or force redeployment of contracts.  ## Proof of Concept  The following code sections are missing zero address check.   https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/Treasury.sol#L36 https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/Treasury.sol#L104 https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/TreasuryVester.sol#L19 https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Whitelistable.sol#L55 https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L157 https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L170 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L138 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L142 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L721 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/MarketRegistry.sol#L59 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AssetManager.sol#L78 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AssetManager.sol#L72 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AaveAdapter.sol#L89 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AaveAdapter.sol#L93   ## Tools Used  None  ## Recommended Mitigation Steps  Consider to Add zero-address checks.    
# Handle  pants   # Vulnerability details  WadRayMath state variables WAD, halfWAD could be set private.  
# Handle  pants   # Vulnerability details  In Treasury.editSchedule      function editSchedule(         uint256 dripStart_,         uint256 dripRate_,         address target_,         uint256 amount_     ) public onlyAdmin {         require(tokenSchedules[target_].target != address(0), "Target schedule doesn't exist");         tokenSchedules[target_].dripStart = dripStart_;         tokenSchedules[target_].dripRate = dripRate_;         tokenSchedules[target_].amount = amount_;     }   We suggest to cache  tokenSchedules[target_] at start and then use the cached value to save repeated access to a *storage* state variable.  
# Handle  pants   # Vulnerability details  See for example the AssetsManager.rebalance function. There you read the value moneyMarkets[i] twice at the same iteration instead of caching it. This happens in the same file in many other places, deposit, withdraw and more. Inside a loop caching is very important.   
# Handle  pants   # Vulnerability details  The function __UToken_init can be frontrun. We recommend adding an initializer owner which only it allowed to call such functions, instead of the current _admin there.  Not sure whether frontrunning is Low / Medium risk.  
# Handle  pants   # Vulnerability details  This is one of many examples of the appearance of private instead of internal. Since we manually code reviewing and writing issues we don't list all the appearances. Calling a private function is more gas efficient than calling internal.   Here we refer to UToken.sol._redeemFresh function that is used only in UToken.sol file.   
# Handle  pants   # Vulnerability details  Line 57  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Resolve the TODO and bubble up the error.  
# Handle  pauliax   # Vulnerability details  ## Impact .length in a loop can be extracted into a variable and used where necessary to reduce the number of storage reads. An example where this could be applied:   for (uint256 i = 0; i < moneyMarkets.length; i++) Solution:   uint moneyMarketsLength = moneyMarkets.length;   for (uint256 i = 0; i < moneyMarketsLength; i++) Cache the length of the array and use this local variable when iterating over the storage array.  
# Handle  pauliax   # Vulnerability details  ## Impact This duration calculation does not change so can be pre-calculated to reduce gas costs:   // before   amount = (vestingAmount * (block.timestamp - lastUpdate)) / (vestingEnd - vestingBegin);    // after   uint256 public constant VESTING_DURATION; // constant state variable   VESTING_DURATION = vestingEnd - vestingBegin; // assign value in the constructor   amount = (vestingAmount * (block.timestamp - lastUpdate)) / VESTING_DURATION;  Same with this:   return (token.getPastTotalSupply(blockNumber) * 4e16) / 1e18; //4%   
# Handle  pauliax   # Vulnerability details  ## Impact It is not efficient to have a struct with only 1 field as structs are meant for grouping related information together. A market struct can be replaced by directly pointing to a bool value:     //before     mapping(address => Market) public supportedMarkets;     struct Market {         bool isSupported;     }     //after    mapping(address => bool) public supportedMarkets;   
# Handle  pauliax   # Vulnerability details  ## Impact In Treasury function setAdmin allows an admin to change it to a different address. This function has no validations, even a simple check for zero-address is missing, and there is no validation of the new address being correct. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked because the swivel cannot be corrected and none of the other functions that require admin caller can be executed. A similar issue was reported in a previous contest and was assigned a severity of medium: https://github.com/code-423n4/2021-06-realitycards-findings/issues/105  ## Recommended Mitigation Steps Consider either introducing a two-step process or making a test call to the new admin before updating it.  
# Handle  kenzo   # Vulnerability details  By adding a small of amount of staking to a normal user scenario, and not approving this small amount as a loan for anybody, a staker can gain disproportionate amounts of comptroller rewards, even to the point of draining the contract. For example: Stakers A,B,C stake 100, 65, 20, approve it for borrower Z, then staker B stakes an additional 0.07 DAI, and borrower Z borrows 185. This will result in disproportionate amount of rewards.   As far as I see, this is the main line that causes the inflated amount (*deep breath*): In calculateRewardsByBlocks, you set: ``` userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140 Note that a staker can make this amount very small (depending of course on the current numbers of the protocol). (A more advanced attacker might diminish the effect of the current numbers of the protocol by initiating fake loans to himself and not paying them.) This field is then passed to calculateRewards, and passed further to _getInflationIndexNew, and further to _getInflationIndex. passed to calculateRewards : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L167 passed to _getInflationIndexNew : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L259 passed to _getInflationIndex : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L238 Now we actually use it in the following line (as effectiveAmount): ``` return blockDelta * inflationPerBlock(effectiveAmount).wadDiv(effectiveAmount) + inflationIndex; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L315 So 2 things are happening here: 1. mul by ```inflationPerBlock(effectiveAmount)``` - uses the lookup table in Comptroller. This value gets bigger as effectiveAmount gets smaller, and if effectiveAmount is in the area of 10**18, we will get the maximum amount of the lookup. 2. div by ```effectiveAmount``` - as we saw, this can be made small, thereby enlarging the result. All together, this calculation will be set to ```curInflationIndex``` and then used in the following line: ``` return (curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount).wadMul(inflationIndex); ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L263 Note the ```curInflationIndex - startInflationIndex```: per my POC (see below), this can result in a curInflationIndex which is orders of magnitude larger (200x) than startInflationIndex. This creates a huge inflation of rewards.  ## Impact Comptroller rewards can be drained.  ## Proof of Concept See the following script for a POC of reward drainage. It is based on the scenario in test/integration/testUserManager: Stakers A,B,C stake 100, 65, 20, and borrower Z borrows 185. But the difference in my script is that just before borrower Z borrows 185, staker B stakes an additional 0.07 DAI. (This will be the small amount that is ```totalStaked - totalFrozen```). Then, we wait 11 blocks to make the loan overdue, call updateOverdueInfo so totalFrozen would be updated, and then staker B calls withdrawRewards. He ends up with 873 unionTokens out of the 1000 the Comptroller has been seeded with. And this number can be enlarged by changing the small additional amount that staker B staked. In this scenario, when calling withdrawRewards, the calculated ```curInflationIndex``` will be 215 WAD, while ```startInflationIndex``` is 1 WAD, and this is the main issue as I understand it.  File password: "union". https://pastebin.com/3bJF8mTe   ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Are you sure that this line should deduct the totalFrozen? ``` userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140 Per my tests, if we change it to just  ``` userManagerData.totalStaked = userManagerContract.totalStaked(); ``` Then we are getting normal results again and no drainage. And the var _is_ called just totalStaked... So maybe this is the change that needs to be made? But maybe you have a reason to deduct the totalFrozen. If so, then a mitigation will perhaps be to limit curInflationIndex somehow, maybe by changing the lookup table, or limiting it to a percentage from startInflationIndex ; but even then, there is also the issue of dividing by ```userManagerData.totalStaked``` which can be made quite small as the user has control over that.  
# Handle  WatchPug   # Vulnerability details  In the current implementation, `UToken.sol` does not inherit and comply with `IUToken.sol`. This is against the best practices and inconsistent with other contracts in the codebase that do inherit and comply with their interfaces.  For example, the `repay()` function defined in `IUToken.sol` is implementated as `repayBorrowBehalf()` and `repayBorrow()`.  It makes the `IUToken.sol` unable to be used and misleading.  ### Recommendation  Make `UToken.sol` inherits and complies with `IUToken.sol`.  
# Handle  cmichel   # Vulnerability details  The `UToken` contract uses solidity version 0.8 which already comes with implicit overflow checks. The explicit overflow checks in `removeReserves` can be removed:  ```solidity // We checked reduceAmount <= totalReserves above, so this should never revert. // @audit this overflow check already happened implicitly require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow"); ```  
# Handle  cmichel   # Vulnerability details  The `UToken` contract uses solidity version 0.8 which already comes with implicit overflow checks. The explicit overflow checks in `addReserves` can be removed:  ```solidity /* Revert on overflow */ // @audit this overflow check already happened implicitly require(totalReservesNew >= totalReserves, "add reserves unexpected overflow"); totalReserves = totalReservesNew; ```  
# Handle  cmichel   # Vulnerability details  The `UnionToken` can check for a whitelist on each transfer in `_beforeTokenTransfer`:  ```solidity if (whitelistEnabled) {     require(isWhitelisted(msg.sender) || to == address(0), "Whitelistable: address not whitelisted"); } ```  This whitelist is checked on `msg.sender` not on `from`, the token owner.  ## Impact A single whitelisted account can act as an operator (everyone calls `unionToken.allow(operator, max)` where the operator is a whitelisted trusted smart contract) for all other accounts. This essentially bypasses the whitelist.  ## Recommended Mitigation Steps Think about if the whitelist on `msg.sender` is correct or if it should be on `from`.  
# Handle  cmichel   # Vulnerability details  The `UToken.repayBorrowWithPermit` function is missing the `repayBorrowWithPermit` modifier which the other repay functions (`repayBorrow`, `repayBorrowBehalf`) have.  ## Impact There's a possibility for re-entrancy. Even though I did not find a way to exploit it, it seems like this function should have the `nonReentrant` modifier as the other similar `repay*` functions have it as well.  ## Recommended Mitigation Steps Add `nonReentrant` to `repayBorrowWithPermit`.  
# Handle  cmichel   # Vulnerability details  The `UToken.borrow` function first checks the borrowed balance and the old credit limit _before_ accruing the actual interest on the market:  ```solidity // @audit this uses the old value require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, "UToken: amount large than borrow size max");  require(     // @audit this calls uToken.calculateInterest(account) which returns old value     uint256(_getCreditLimit(msg.sender)) >= amount + fee,     "UToken: The loan amount plus fee is greater than credit limit" );  // @audit accrual only happens here require(accrueInterest(), "UToken: accrue interest failed"); ```  Thus the borrowed balance of the user does not include the latest interest as it uses the old global `borrowIndex` but the new `borrowIndex` is only set in `accrueInterest`.  ## Impact In low-activity markets, it could be that the `borrowIndex` accruals (`accrueInterest` calls) happen infrequently and a long time is between them. A borrower could borrow tokens, and borrow more tokens later at a different time without first having their latest debt accrued. This will lead to borrowers being able to borrow more than `maxBorrow` and **more than their credit limit** as these checks are performed before updating accruing interest.  ## Recommended Mitigation Steps The `require(accrueInterest(), "UToken: accrue interest failed");` call should happen at the beginning of the function.   
# Handle  cmichel   # Vulnerability details  The `MarketRegistry.deleteMarket` iterates over all `uTokenList` elements.  ## Impact The transactions can fail if the arrays get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.  ## Recommended Mitigation Steps Keep the array small or use an [EnumerableSet])(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol) that can delete in constant time.  
# Handle  cmichel   # Vulnerability details  The `AssetManager.rebalance` function has a check at the end to ensure that all tokens are deposited again:  ```solidity require(token.balanceOf(address(this)) == 0, "AssetManager: there are remaining funds in the fund pool"); ```  The idea is that the last market deposits all `remainingTokens` but the last market does not have to support the token in which case the transaction will fail, or the `percentages` parameter needs to be chosen to distribute all tokens before the last one (they need to add up to `1e4`). However, these percentages have a low precision as they are in base points, i.e, the lowest unit is `1 = 0.01%`. This will leave dust in the contract in most cases as the tokens have much higher precision.  ## POC Assume the last market does not support the token and thus `percentages` are chosen as `[5000, 5000]` to rebalance the first two markets. Withdrawing all tokens form the markets leads to a `tokenSupply = token.balanceOf(address(this)) = 10,001`:  Then the deposited amount is `amountToDeposit = (tokenSupply * percentages[i]) / 10000 = 10,001 * 5,000 / 10,000 = 5,000`. The two deposits will leave dust of `10,001 - 2 * 5,000 = 1` in the contract and the `token.balanceOf(address(this)) == 0` balance check will revert.  ## Impact Rebalancing will fail in most cases if the last market does not support the token due to precision errors.  ## Recommended Mitigation Steps Remove the final zero balance check, or make sure that the last market that is actually deposited to receives all remaining tokens.   
# Handle  cmichel   # Vulnerability details  The `AssetManager.withdraw` function iterates through the markets based on the `withdrawSeq` array field. This field must be manually set to cover all markets on each new market addition.  ## Impact It could be that a market is added but this array is not updated. Thus not all markets are iterated and users might not be able to withdraw their entire `amount` as the new market is skipped  ## Recommended Mitigation Steps Ensure that `withdrawSeq` is always up-to-date when `addAdapter` is called, for example, `addAdapter` could add the new adapter as the last element to `withdrawSeq` until it's manually set through `changeWithdrawSequence`.   
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  The require statement in `updateTotalFrozen` and `batchUpdateTotalFrozen` to check that totalStaked ≥ totalFrozen should be done both before and after `_updateTotalFrozen` is called to ensure that totalStake is still ≥ totalFrozen. This will serve as a sanity check to ensure that the integrity of the system is not compromised.  
# Handle  ye0lde   # Vulnerability details  ## Impact  There is no need to keep iterating through a loop for the full length once the condition being searched for is met.  This will save gas.  ## Proof of Concept  The loops are here: https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L436-L441 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L444-L449 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L479-L485 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L488-L495  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add a "break" statement to the loops mentioned above. Note also that there are unnecessary default value initializations of variables associated with the loops.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The ability of a borrower to repay a loan is disabled if the interest rate is  set too high by the `InterestRateModel`.  However, there is neither a check when setting the interest rate nor an  indication in the `IInterestRateModel`'s specs of this behavior.  But this issue could also be used in an adversarial fashion by the  `FixedInterestRateModel`-owner if he/she would disable the repay functionality  for some time and enables it at a later point again with the demand of a  higher interest to be paid by the borrower.  ## Proof of Concept If an account wants to repay a loan, the function  `UToken::_repayBorrowFresh()` is used. This function calls  `UToken::accrueInterest()` ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L465) 465)  which fetches the current borrow rate of the interest rate model  ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L546) 546  and [line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L330) 330).  The function `UToken::borrowRatePerBlock()` requires an not "absurdly high"  rate, or fails otherwise ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L331) 331).  However, there is no check or indicator in `FixedInterestRateModel.sol` to  prevent the owner to set such a high rate that effectively disables repay of borrowed funds ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/FixedInterestRateModel.sol#L36) 36).  ## Recommended Mitigation Steps Disallow setting the interest rate too high with a check in  `FixedInterestRateModel::setInterestRate()`.  
# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in UserManager.sol.  ## Proof of Concept   Missing events  https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L156  https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L160   See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function setHalfDecayPoint allows setting an arbitrary value of halfDecayPoint. However if halfDecayPoint == 0 then inflationPerBlock will have a division by 0.  Probably it is also useful to have an upper limit for halfDecayPoint.  ## Proof of Concept https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/token/Comptroller.sol#L67-L69  https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/token/Comptroller.sol#L275-L278   ## Tools Used  ## Recommended Mitigation Steps In the function setHalfDecayPoint: Verify that the new value of halfDecayPoint is within an allowable range ( certainly != 0)  
# Handle  defsec   # Vulnerability details  ## Impact  Zero-address checks are a best-practise for input validation of critical address parameters. While the codebase applies this to most addresses in setters, there are many places where this is missing in constructors and setters.  Impact: Accidental use of zero-addresses may result in exceptions, burn fees/tokens or force redeployment of contracts.  ## Proof of Concept  The following code sections are missing zero address check.   https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/Treasury.sol#L36 https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/Treasury.sol#L104 https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/TreasuryVester.sol#L19 https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Whitelistable.sol#L55 https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L157 https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L170 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L138 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L142 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L721 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/MarketRegistry.sol#L59 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AssetManager.sol#L78 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AssetManager.sol#L72 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AaveAdapter.sol#L89 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AaveAdapter.sol#L93   ## Tools Used  None  ## Recommended Mitigation Steps  Consider to Add zero-address checks.    
# Handle  pants   # Vulnerability details  WadRayMath state variables WAD, halfWAD could be set private.  
# Handle  pants   # Vulnerability details  In Treasury.editSchedule      function editSchedule(         uint256 dripStart_,         uint256 dripRate_,         address target_,         uint256 amount_     ) public onlyAdmin {         require(tokenSchedules[target_].target != address(0), "Target schedule doesn't exist");         tokenSchedules[target_].dripStart = dripStart_;         tokenSchedules[target_].dripRate = dripRate_;         tokenSchedules[target_].amount = amount_;     }   We suggest to cache  tokenSchedules[target_] at start and then use the cached value to save repeated access to a *storage* state variable.  
# Handle  pants   # Vulnerability details  See for example the AssetsManager.rebalance function. There you read the value moneyMarkets[i] twice at the same iteration instead of caching it. This happens in the same file in many other places, deposit, withdraw and more. Inside a loop caching is very important.   
# Handle  pants   # Vulnerability details  The function __UToken_init can be frontrun. We recommend adding an initializer owner which only it allowed to call such functions, instead of the current _admin there.  Not sure whether frontrunning is Low / Medium risk.  
# Handle  pants   # Vulnerability details  This is one of many examples of the appearance of private instead of internal. Since we manually code reviewing and writing issues we don't list all the appearances. Calling a private function is more gas efficient than calling internal.   Here we refer to UToken.sol._redeemFresh function that is used only in UToken.sol file.   
# Handle  pants   # Vulnerability details  Line 57  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Resolve the TODO and bubble up the error.  
# Handle  pauliax   # Vulnerability details  ## Impact .length in a loop can be extracted into a variable and used where necessary to reduce the number of storage reads. An example where this could be applied:   for (uint256 i = 0; i < moneyMarkets.length; i++) Solution:   uint moneyMarketsLength = moneyMarkets.length;   for (uint256 i = 0; i < moneyMarketsLength; i++) Cache the length of the array and use this local variable when iterating over the storage array.  
# Handle  pauliax   # Vulnerability details  ## Impact This duration calculation does not change so can be pre-calculated to reduce gas costs:   // before   amount = (vestingAmount * (block.timestamp - lastUpdate)) / (vestingEnd - vestingBegin);    // after   uint256 public constant VESTING_DURATION; // constant state variable   VESTING_DURATION = vestingEnd - vestingBegin; // assign value in the constructor   amount = (vestingAmount * (block.timestamp - lastUpdate)) / VESTING_DURATION;  Same with this:   return (token.getPastTotalSupply(blockNumber) * 4e16) / 1e18; //4%   
# Handle  pauliax   # Vulnerability details  ## Impact It is not efficient to have a struct with only 1 field as structs are meant for grouping related information together. A market struct can be replaced by directly pointing to a bool value:     //before     mapping(address => Market) public supportedMarkets;     struct Market {         bool isSupported;     }     //after    mapping(address => bool) public supportedMarkets;   
# Handle  pauliax   # Vulnerability details  ## Impact In Treasury function setAdmin allows an admin to change it to a different address. This function has no validations, even a simple check for zero-address is missing, and there is no validation of the new address being correct. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked because the swivel cannot be corrected and none of the other functions that require admin caller can be executed. A similar issue was reported in a previous contest and was assigned a severity of medium: https://github.com/code-423n4/2021-06-realitycards-findings/issues/105  ## Recommended Mitigation Steps Consider either introducing a two-step process or making a test call to the new admin before updating it.  
# Handle  kenzo   # Vulnerability details  By adding a small of amount of staking to a normal user scenario, and not approving this small amount as a loan for anybody, a staker can gain disproportionate amounts of comptroller rewards, even to the point of draining the contract. For example: Stakers A,B,C stake 100, 65, 20, approve it for borrower Z, then staker B stakes an additional 0.07 DAI, and borrower Z borrows 185. This will result in disproportionate amount of rewards.   As far as I see, this is the main line that causes the inflated amount (*deep breath*): In calculateRewardsByBlocks, you set: ``` userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140 Note that a staker can make this amount very small (depending of course on the current numbers of the protocol). (A more advanced attacker might diminish the effect of the current numbers of the protocol by initiating fake loans to himself and not paying them.) This field is then passed to calculateRewards, and passed further to _getInflationIndexNew, and further to _getInflationIndex. passed to calculateRewards : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L167 passed to _getInflationIndexNew : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L259 passed to _getInflationIndex : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L238 Now we actually use it in the following line (as effectiveAmount): ``` return blockDelta * inflationPerBlock(effectiveAmount).wadDiv(effectiveAmount) + inflationIndex; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L315 So 2 things are happening here: 1. mul by ```inflationPerBlock(effectiveAmount)``` - uses the lookup table in Comptroller. This value gets bigger as effectiveAmount gets smaller, and if effectiveAmount is in the area of 10**18, we will get the maximum amount of the lookup. 2. div by ```effectiveAmount``` - as we saw, this can be made small, thereby enlarging the result. All together, this calculation will be set to ```curInflationIndex``` and then used in the following line: ``` return (curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount).wadMul(inflationIndex); ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L263 Note the ```curInflationIndex - startInflationIndex```: per my POC (see below), this can result in a curInflationIndex which is orders of magnitude larger (200x) than startInflationIndex. This creates a huge inflation of rewards.  ## Impact Comptroller rewards can be drained.  ## Proof of Concept See the following script for a POC of reward drainage. It is based on the scenario in test/integration/testUserManager: Stakers A,B,C stake 100, 65, 20, and borrower Z borrows 185. But the difference in my script is that just before borrower Z borrows 185, staker B stakes an additional 0.07 DAI. (This will be the small amount that is ```totalStaked - totalFrozen```). Then, we wait 11 blocks to make the loan overdue, call updateOverdueInfo so totalFrozen would be updated, and then staker B calls withdrawRewards. He ends up with 873 unionTokens out of the 1000 the Comptroller has been seeded with. And this number can be enlarged by changing the small additional amount that staker B staked. In this scenario, when calling withdrawRewards, the calculated ```curInflationIndex``` will be 215 WAD, while ```startInflationIndex``` is 1 WAD, and this is the main issue as I understand it.  File password: "union". https://pastebin.com/3bJF8mTe   ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Are you sure that this line should deduct the totalFrozen? ``` userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140 Per my tests, if we change it to just  ``` userManagerData.totalStaked = userManagerContract.totalStaked(); ``` Then we are getting normal results again and no drainage. And the var _is_ called just totalStaked... So maybe this is the change that needs to be made? But maybe you have a reason to deduct the totalFrozen. If so, then a mitigation will perhaps be to limit curInflationIndex somehow, maybe by changing the lookup table, or limiting it to a percentage from startInflationIndex ; but even then, there is also the issue of dividing by ```userManagerData.totalStaked``` which can be made quite small as the user has control over that.  
# Handle  WatchPug   # Vulnerability details  In the current implementation, `UToken.sol` does not inherit and comply with `IUToken.sol`. This is against the best practices and inconsistent with other contracts in the codebase that do inherit and comply with their interfaces.  For example, the `repay()` function defined in `IUToken.sol` is implementated as `repayBorrowBehalf()` and `repayBorrow()`.  It makes the `IUToken.sol` unable to be used and misleading.  ### Recommendation  Make `UToken.sol` inherits and complies with `IUToken.sol`.  
# Handle  cmichel   # Vulnerability details  The `UToken` contract uses solidity version 0.8 which already comes with implicit overflow checks. The explicit overflow checks in `removeReserves` can be removed:  ```solidity // We checked reduceAmount <= totalReserves above, so this should never revert. // @audit this overflow check already happened implicitly require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow"); ```  
# Handle  cmichel   # Vulnerability details  The `UToken` contract uses solidity version 0.8 which already comes with implicit overflow checks. The explicit overflow checks in `addReserves` can be removed:  ```solidity /* Revert on overflow */ // @audit this overflow check already happened implicitly require(totalReservesNew >= totalReserves, "add reserves unexpected overflow"); totalReserves = totalReservesNew; ```  
# Handle  cmichel   # Vulnerability details  The `UnionToken` can check for a whitelist on each transfer in `_beforeTokenTransfer`:  ```solidity if (whitelistEnabled) {     require(isWhitelisted(msg.sender) || to == address(0), "Whitelistable: address not whitelisted"); } ```  This whitelist is checked on `msg.sender` not on `from`, the token owner.  ## Impact A single whitelisted account can act as an operator (everyone calls `unionToken.allow(operator, max)` where the operator is a whitelisted trusted smart contract) for all other accounts. This essentially bypasses the whitelist.  ## Recommended Mitigation Steps Think about if the whitelist on `msg.sender` is correct or if it should be on `from`.  
# Handle  cmichel   # Vulnerability details  The `UToken.repayBorrowWithPermit` function is missing the `repayBorrowWithPermit` modifier which the other repay functions (`repayBorrow`, `repayBorrowBehalf`) have.  ## Impact There's a possibility for re-entrancy. Even though I did not find a way to exploit it, it seems like this function should have the `nonReentrant` modifier as the other similar `repay*` functions have it as well.  ## Recommended Mitigation Steps Add `nonReentrant` to `repayBorrowWithPermit`.  
# Handle  cmichel   # Vulnerability details  The `UToken.borrow` function first checks the borrowed balance and the old credit limit _before_ accruing the actual interest on the market:  ```solidity // @audit this uses the old value require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, "UToken: amount large than borrow size max");  require(     // @audit this calls uToken.calculateInterest(account) which returns old value     uint256(_getCreditLimit(msg.sender)) >= amount + fee,     "UToken: The loan amount plus fee is greater than credit limit" );  // @audit accrual only happens here require(accrueInterest(), "UToken: accrue interest failed"); ```  Thus the borrowed balance of the user does not include the latest interest as it uses the old global `borrowIndex` but the new `borrowIndex` is only set in `accrueInterest`.  ## Impact In low-activity markets, it could be that the `borrowIndex` accruals (`accrueInterest` calls) happen infrequently and a long time is between them. A borrower could borrow tokens, and borrow more tokens later at a different time without first having their latest debt accrued. This will lead to borrowers being able to borrow more than `maxBorrow` and **more than their credit limit** as these checks are performed before updating accruing interest.  ## Recommended Mitigation Steps The `require(accrueInterest(), "UToken: accrue interest failed");` call should happen at the beginning of the function.   
# Handle  cmichel   # Vulnerability details  The `MarketRegistry.deleteMarket` iterates over all `uTokenList` elements.  ## Impact The transactions can fail if the arrays get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.  ## Recommended Mitigation Steps Keep the array small or use an [EnumerableSet])(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol) that can delete in constant time.  
# Handle  cmichel   # Vulnerability details  The `AssetManager.rebalance` function has a check at the end to ensure that all tokens are deposited again:  ```solidity require(token.balanceOf(address(this)) == 0, "AssetManager: there are remaining funds in the fund pool"); ```  The idea is that the last market deposits all `remainingTokens` but the last market does not have to support the token in which case the transaction will fail, or the `percentages` parameter needs to be chosen to distribute all tokens before the last one (they need to add up to `1e4`). However, these percentages have a low precision as they are in base points, i.e, the lowest unit is `1 = 0.01%`. This will leave dust in the contract in most cases as the tokens have much higher precision.  ## POC Assume the last market does not support the token and thus `percentages` are chosen as `[5000, 5000]` to rebalance the first two markets. Withdrawing all tokens form the markets leads to a `tokenSupply = token.balanceOf(address(this)) = 10,001`:  Then the deposited amount is `amountToDeposit = (tokenSupply * percentages[i]) / 10000 = 10,001 * 5,000 / 10,000 = 5,000`. The two deposits will leave dust of `10,001 - 2 * 5,000 = 1` in the contract and the `token.balanceOf(address(this)) == 0` balance check will revert.  ## Impact Rebalancing will fail in most cases if the last market does not support the token due to precision errors.  ## Recommended Mitigation Steps Remove the final zero balance check, or make sure that the last market that is actually deposited to receives all remaining tokens.   
# Handle  cmichel   # Vulnerability details  The `AssetManager.withdraw` function iterates through the markets based on the `withdrawSeq` array field. This field must be manually set to cover all markets on each new market addition.  ## Impact It could be that a market is added but this array is not updated. Thus not all markets are iterated and users might not be able to withdraw their entire `amount` as the new market is skipped  ## Recommended Mitigation Steps Ensure that `withdrawSeq` is always up-to-date when `addAdapter` is called, for example, `addAdapter` could add the new adapter as the last element to `withdrawSeq` until it's manually set through `changeWithdrawSequence`.   
# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  The require statement in `updateTotalFrozen` and `batchUpdateTotalFrozen` to check that totalStaked ≥ totalFrozen should be done both before and after `_updateTotalFrozen` is called to ensure that totalStake is still ≥ totalFrozen. This will serve as a sanity check to ensure that the integrity of the system is not compromised.  
# Handle  ye0lde   # Vulnerability details  ## Impact  There is no need to keep iterating through a loop for the full length once the condition being searched for is met.  This will save gas.  ## Proof of Concept  The loops are here: https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L436-L441 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L444-L449 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L479-L485 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L488-L495  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add a "break" statement to the loops mentioned above. Note also that there are unnecessary default value initializations of variables associated with the loops.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact The ability of a borrower to repay a loan is disabled if the interest rate is  set too high by the `InterestRateModel`.  However, there is neither a check when setting the interest rate nor an  indication in the `IInterestRateModel`'s specs of this behavior.  But this issue could also be used in an adversarial fashion by the  `FixedInterestRateModel`-owner if he/she would disable the repay functionality  for some time and enables it at a later point again with the demand of a  higher interest to be paid by the borrower.  ## Proof of Concept If an account wants to repay a loan, the function  `UToken::_repayBorrowFresh()` is used. This function calls  `UToken::accrueInterest()` ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L465) 465)  which fetches the current borrow rate of the interest rate model  ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L546) 546  and [line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L330) 330).  The function `UToken::borrowRatePerBlock()` requires an not "absurdly high"  rate, or fails otherwise ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L331) 331).  However, there is no check or indicator in `FixedInterestRateModel.sol` to  prevent the owner to set such a high rate that effectively disables repay of borrowed funds ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/FixedInterestRateModel.sol#L36) 36).  ## Recommended Mitigation Steps Disallow setting the interest rate too high with a check in  `FixedInterestRateModel::setInterestRate()`.  
# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in UserManager.sol.  ## Proof of Concept   Missing events  https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L156  https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L160   See similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function setHalfDecayPoint allows setting an arbitrary value of halfDecayPoint. However if halfDecayPoint == 0 then inflationPerBlock will have a division by 0.  Probably it is also useful to have an upper limit for halfDecayPoint.  ## Proof of Concept https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/token/Comptroller.sol#L67-L69  https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/token/Comptroller.sol#L275-L278   ## Tools Used  ## Recommended Mitigation Steps In the function setHalfDecayPoint: Verify that the new value of halfDecayPoint is within an allowable range ( certainly != 0)  
# Handle  defsec   # Vulnerability details  ## Impact  Zero-address checks are a best-practise for input validation of critical address parameters. While the codebase applies this to most addresses in setters, there are many places where this is missing in constructors and setters.  Impact: Accidental use of zero-addresses may result in exceptions, burn fees/tokens or force redeployment of contracts.  ## Proof of Concept  The following code sections are missing zero address check.   https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/Treasury.sol#L36 https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/Treasury.sol#L104 https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/TreasuryVester.sol#L19 https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Whitelistable.sol#L55 https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L157 https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L170 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L138 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L142 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L721 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/MarketRegistry.sol#L59 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AssetManager.sol#L78 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AssetManager.sol#L72 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AaveAdapter.sol#L89 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AaveAdapter.sol#L93   ## Tools Used  None  ## Recommended Mitigation Steps  Consider to Add zero-address checks.    
