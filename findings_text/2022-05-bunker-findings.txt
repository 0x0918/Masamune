# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/CNft.sol#L204   # Vulnerability details  The function safeTransferFrom is a standard interface in ERC1155, and its expected to succeed if all the parametes are valid, and revert on error, which is not the case here so its a deviation.  Refer to the EIP-1155 safeTransferFrom rules: > MUST revert if _to is the zero address. > MUST revert if balance of holder for token _id is lower than the _value sent to the recipient. > MUST revert on any other error.  There is no loss of assets, but the assets or tokens and CNft contract can be unusable by other protocols, and likelihood & impact of this issue is high.  ## Impact If other protocols want to integrate CNft, then in that case just for CNft Contract / tokens, they have to take exception and use safeBatchTransferFrom, instead of safeTransferFrom. If they dont take care of this exception, then their protocol functions will fail while using CNft, even if valid values are given.  ## Proof of Concept Contract : CNft.sol  Function : safeTransferFrom  > Line 204   revert("CNFT: Use safeBatchTransferFrom instead");  ## Recommended Mitigation Steps Instead of revert, call function safeBatchTransferFrom with 1 item in the array, e.g., > safeBatchTransferFrom(from, to, [id], [amount], data)   
# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L1337-L1359   # Vulnerability details  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L1337-L1359  ```solidity function _initializeNftCollateral(CNftInterface cNft, NftPriceOracle _nftOracle, uint256 _collateralFactorMantissa) external returns (uint) {     require(address(nftMarket) == address(0), "nft collateral already initialized");     require(address(cNft) != address(0), "cannot initialize nft market to the 0 address");      if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);     }      if (markets[address(cNft)].isListed) {         return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);     }      cNft.isCNft(); // Sanity check to make sure its really a cNFT.      nftMarket = cNft;     nftOracle = _nftOracle;      // Note that isComped is not in active use anymore     markets[address(cNft)] = Market({isListed: true, isComped: false, collateralFactorMantissa: _collateralFactorMantissa});      // We do not support borrowing NFTs.     borrowGuardianPaused[address(cNft)] = false; } ```  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L80-L81  ```solidity // No collateralFactorMantissa may exceed this value uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9 ```   There is a `collateralFactorMaxMantissa` which limits the collateral factor to be always lower than 0.9.  Per the comment:  > No collateralFactorMantissa may exceed this value  However, in `_initializeNftCollateral()`, the `_collateralFactorMantissa` is set without any check, which means it can be set to a value > 0.9 or even > 1.  As a result, the borrowers may deliberately choose not to repay as their collateral may not be worth the debt in the first place. This can accumulate bad debt in the whole system.  ### Recommendation  Change to:  ```solidity // Check collateral factor <= 0.9 Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa}); if (lessThanExp(highLimit, _collateralFactorMantissa)) {     return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION); }  markets[address(cNft)] = Market({isListed: true, isComped: false, collateralFactorMantissa: _collateralFactorMantissa}); ```  
# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/ERC1155Enumerable.sol#L70-L71 https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/CNft.sol#L282-L283   # Vulnerability details  ## Impact  The code base contains several upgradeable contracts that inherit other upgradeable contracts, including `ERC1155Enumerable.sol` and `CNFT.sol`. These contracts currently do not contain any storage gap.  For upgradeable contracts, there must be storage gap to "allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments" (quote OpenZeppelin). Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts, potentially causing loss of user fund or cause the contract to malfunction completely.   Refer to the bottom part of this article: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable   ## Proof of Concept  All OpenZeppelin upgradeable contract templates contain storage gap, including `ReentrancyGuardUpgradeable`, `OwnableUpgradeable` and `ERC1155Upgradeable` that are used in this project. Refer to the bottom of the code in the links below:   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/security/ReentrancyGuardUpgradeable.sol  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/access/OwnableUpgradeable.sol  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC1155/ERC1155Upgradeable.sol  The storage gap is essential for upgradeable contract because "It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments". Refer to the bottom part of this article:   https://docs.openzeppelin.com/contracts/3.x/upgradeable  Note that it isn't enough to simply have the OpenZeppelin base contracts contain storage gaps. In this project, the `CNFt` contract inherits the `ERC1155Enumerable` contract, which inherits `ERC1155Upgradeable`. We know the `ERC1155Upgradeable` contract contains a storage gap, so that contract can add additional variables without affecting its child contracts. However, `ERC1155Enumerable` currently does not contain a storage gap, and if in a future upgrade, a new variable is used in the `ERC1155Enumerable` contract, the storage slot of that new variable would overlap with the existing storage slots that are used by `CNFt` and overwrites it, causing unintended and potentially serious consequences including a complete malfunction of the `CNFt` contract. Refer to the bottom of this link for an example and explanation:   https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.   ```solidity   uint256[50] private __gap; ```  
# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/PriceOracleImplementation.sol#L29-L30   # Vulnerability details  ## Impact According to Chainlink's documentation, the latestAnswer function is deprecated. This function might suddenly stop working if Chainlink stop supporting deprecated APIs. And the old API can return stale data.  ## Proof of Concept https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/PriceOracleImplementation.sol#L29-L30 ## Tools Used None ## Recommended Mitigation Steps Use the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete https://docs.chain.link/docs/price-feeds-api-reference/  
# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/CNft.sol#L204   # Vulnerability details  The function safeTransferFrom is a standard interface in ERC1155, and its expected to succeed if all the parametes are valid, and revert on error, which is not the case here so its a deviation.  Refer to the EIP-1155 safeTransferFrom rules: > MUST revert if _to is the zero address. > MUST revert if balance of holder for token _id is lower than the _value sent to the recipient. > MUST revert on any other error.  There is no loss of assets, but the assets or tokens and CNft contract can be unusable by other protocols, and likelihood & impact of this issue is high.  ## Impact If other protocols want to integrate CNft, then in that case just for CNft Contract / tokens, they have to take exception and use safeBatchTransferFrom, instead of safeTransferFrom. If they dont take care of this exception, then their protocol functions will fail while using CNft, even if valid values are given.  ## Proof of Concept Contract : CNft.sol  Function : safeTransferFrom  > Line 204   revert("CNFT: Use safeBatchTransferFrom instead");  ## Recommended Mitigation Steps Instead of revert, call function safeBatchTransferFrom with 1 item in the array, e.g., > safeBatchTransferFrom(from, to, [id], [amount], data)   
# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L1337-L1359   # Vulnerability details  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L1337-L1359  ```solidity function _initializeNftCollateral(CNftInterface cNft, NftPriceOracle _nftOracle, uint256 _collateralFactorMantissa) external returns (uint) {     require(address(nftMarket) == address(0), "nft collateral already initialized");     require(address(cNft) != address(0), "cannot initialize nft market to the 0 address");      if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);     }      if (markets[address(cNft)].isListed) {         return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);     }      cNft.isCNft(); // Sanity check to make sure its really a cNFT.      nftMarket = cNft;     nftOracle = _nftOracle;      // Note that isComped is not in active use anymore     markets[address(cNft)] = Market({isListed: true, isComped: false, collateralFactorMantissa: _collateralFactorMantissa});      // We do not support borrowing NFTs.     borrowGuardianPaused[address(cNft)] = false; } ```  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L80-L81  ```solidity // No collateralFactorMantissa may exceed this value uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9 ```   There is a `collateralFactorMaxMantissa` which limits the collateral factor to be always lower than 0.9.  Per the comment:  > No collateralFactorMantissa may exceed this value  However, in `_initializeNftCollateral()`, the `_collateralFactorMantissa` is set without any check, which means it can be set to a value > 0.9 or even > 1.  As a result, the borrowers may deliberately choose not to repay as their collateral may not be worth the debt in the first place. This can accumulate bad debt in the whole system.  ### Recommendation  Change to:  ```solidity // Check collateral factor <= 0.9 Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa}); if (lessThanExp(highLimit, _collateralFactorMantissa)) {     return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION); }  markets[address(cNft)] = Market({isListed: true, isComped: false, collateralFactorMantissa: _collateralFactorMantissa}); ```  
# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/ERC1155Enumerable.sol#L70-L71 https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/CNft.sol#L282-L283   # Vulnerability details  ## Impact  The code base contains several upgradeable contracts that inherit other upgradeable contracts, including `ERC1155Enumerable.sol` and `CNFT.sol`. These contracts currently do not contain any storage gap.  For upgradeable contracts, there must be storage gap to "allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments" (quote OpenZeppelin). Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts, potentially causing loss of user fund or cause the contract to malfunction completely.   Refer to the bottom part of this article: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable   ## Proof of Concept  All OpenZeppelin upgradeable contract templates contain storage gap, including `ReentrancyGuardUpgradeable`, `OwnableUpgradeable` and `ERC1155Upgradeable` that are used in this project. Refer to the bottom of the code in the links below:   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/security/ReentrancyGuardUpgradeable.sol  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/access/OwnableUpgradeable.sol  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC1155/ERC1155Upgradeable.sol  The storage gap is essential for upgradeable contract because "It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments". Refer to the bottom part of this article:   https://docs.openzeppelin.com/contracts/3.x/upgradeable  Note that it isn't enough to simply have the OpenZeppelin base contracts contain storage gaps. In this project, the `CNFt` contract inherits the `ERC1155Enumerable` contract, which inherits `ERC1155Upgradeable`. We know the `ERC1155Upgradeable` contract contains a storage gap, so that contract can add additional variables without affecting its child contracts. However, `ERC1155Enumerable` currently does not contain a storage gap, and if in a future upgrade, a new variable is used in the `ERC1155Enumerable` contract, the storage slot of that new variable would overlap with the existing storage slots that are used by `CNFt` and overwrites it, causing unintended and potentially serious consequences including a complete malfunction of the `CNFt` contract. Refer to the bottom of this link for an example and explanation:   https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.   ```solidity   uint256[50] private __gap; ```  
# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/PriceOracleImplementation.sol#L29-L30   # Vulnerability details  ## Impact According to Chainlink's documentation, the latestAnswer function is deprecated. This function might suddenly stop working if Chainlink stop supporting deprecated APIs. And the old API can return stale data.  ## Proof of Concept https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/PriceOracleImplementation.sol#L29-L30 ## Tools Used None ## Recommended Mitigation Steps Use the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete https://docs.chain.link/docs/price-feeds-api-reference/  
